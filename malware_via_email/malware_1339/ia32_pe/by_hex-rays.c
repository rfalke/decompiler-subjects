/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// signed __int64 __usercall ftol@<edx:eax>(_DWORD, double@<st0>); weak
// int __thiscall _p__osver(_DWORD); weak
// int __usercall sub_401288@<eax>(double@<st0>);
char *sub_401340();
// char *__usercall sub_4014E8@<eax>(double@<st0>, __int128);
// int __usercall start@<eax>(int@<ebx>, char *@<edi>, int@<esi>, double@<st0>, int, __int64);

//-------------------------------------------------------------------------
// Data declarations

// extern HRESULT (__stdcall *ReadClassStg)(LPSTORAGE pStg, CLSID *pclsid);
// extern LSTATUS (__stdcall *RegEnumKeyW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName);
// extern BOOL (__stdcall *IsValidAcl)(PACL pAcl);
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern UINT (__stdcall *GetOEMCP)();
// extern HANDLE (__stdcall *OpenMutexW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern BOOL (__stdcall *GetCPInfo)(UINT CodePage, LPCPINFO lpCPInfo);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern HRSRC (__stdcall *FindResourceW)(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern void (__cdecl *_set_app_type)(_crt_app_type Type);
// extern FILE *(__cdecl *_p__iob)();
// extern int (__cdecl *chsize)(int FileHandle, int Size);
_UNKNOWN unk_406C4B; // weak
_UNKNOWN unk_407C63; // weak


//----- (00401288) --------------------------------------------------------
int __usercall sub_401288@<eax>(double a1@<st0>)
{
  __int16 v1; // cx
  int v2; // edx
  char SubKey[20]; // [esp+150h] [ebp-100h] BYREF
  struct HKEY__ hKey; // [esp+164h] [ebp-ECh] BYREF
  struct _FILETIME v6[2]; // [esp+174h] [ebp-DCh] BYREF
  HKEY phkResult; // [esp+184h] [ebp-CCh] BYREF
  struct HKEY__ v8; // [esp+194h] [ebp-BCh] BYREF
  int Reserved[4]; // [esp+1D4h] [ebp-7Ch] BYREF
  int cchName[3]; // [esp+1E4h] [ebp-6Ch] BYREF
  int cchClass[24]; // [esp+1F0h] [ebp-60h] BYREF

  GetCurrentProcessId();
  _p__osver(v1 & 0x1B5);
  RegOpenKeyA(&hKey, SubKey, &phkResult);
  ftol(0, a1);
  GetSystemTimeAsFileTime(v6);
  RegEnumKeyExW(
    &v8,
    0,
    (LPWSTR)0x20,
    (LPDWORD)cchName,
    (LPDWORD)Reserved,
    (LPWSTR)v6,
    (LPDWORD)cchClass,
    (PFILETIME)0x1C);
  return chsize(-358155457, v2);
}
// 401299: variable 'v1' is possibly undefined
// 40132F: variable 'v2' is possibly undefined
// 401248: using guessed type signed __int64 __usercall ftol@<edx:eax>(_DWORD, double@<st0>);
// 401250: using guessed type int __thiscall _p__osver(_DWORD);
// 401288: using guessed type CHAR SubKey[20];
// 401288: using guessed type DWORD cchClass[24];
// 401288: using guessed type DWORD Reserved[4];
// 401288: using guessed type DWORD cchName[3];

//----- (00401340) --------------------------------------------------------
char *sub_401340()
{
  int v0; // eax
  int v1; // edx
  unsigned int v2; // ecx
  int v3; // eax
  char *v4; // edx
  char *result; // eax
  int v6; // [esp+D8h] [ebp-300h]
  char v7; // [esp+1B8h] [ebp-220h] BYREF
  int v8; // [esp+1BDh] [ebp-21Bh]
  _BYTE v9[7]; // [esp+1C1h] [ebp-217h]
  char v10; // [esp+1CCh] [ebp-20Ch]
  char v11[6]; // [esp+1EEh] [ebp-1EAh]
  char v12; // [esp+1F4h] [ebp-1E4h] BYREF
  int v13; // [esp+1FCh] [ebp-1DCh]
  char v14; // [esp+208h] [ebp-1D0h]
  __int16 v15; // [esp+240h] [ebp-198h]
  char v16; // [esp+2ACh] [ebp-12Ch] BYREF
  int v17; // [esp+2B2h] [ebp-126h]
  __int16 v18; // [esp+2BAh] [ebp-11Eh]
  struct _FILETIME v19; // [esp+2E0h] [ebp-F8h] BYREF
  struct HKEY__ hKey; // [esp+2E8h] [ebp-F0h] BYREF
  __int16 v21; // [esp+30Ch] [ebp-CCh]
  struct HKEY__ v22; // [esp+338h] [ebp-A0h] BYREF
  char v23; // [esp+344h] [ebp-94h] BYREF
  char v24[16]; // [esp+358h] [ebp-80h] BYREF
  __int16 Name[4]; // [esp+368h] [ebp-70h] BYREF
  int v26; // [esp+370h] [ebp-68h]
  __int16 v27[42]; // [esp+384h] [ebp-54h] BYREF
  int savedregs; // [esp+3D8h] [ebp+0h] BYREF

  *(_DWORD *)&v9[3] -= 107;
  RegEnumKeyW(&hKey, 0x10u, (LPWSTR)v27, 0xBu);
  v14 ^= 0x39u;
  v21 += 196;
  v26 &= 0xB3u;
  v10 |= 0xC8u;
  v0 = _p__osver(&savedregs);
  v3 = v2 | v0;
  if ( !v2 )
  {
    v2 = (unsigned int)&v16;
    v1 = v17 + (v1 | 0x2ACD);
    v3 &= v18 & 0x28D2;
  }
  v4 = (char *)((v1 ^ 0xB19) - v3);
  if ( v3 == 532 )
  {
    v2 = *(_DWORD *)&v11[2] ^ (*(_DWORD *)v11 | (v13 + (v8 | *(_DWORD *)v9 | v2) - ((unsigned int)&v7 ^ 0x16EE)));
    v4 = &v12;
  }
  if ( ((v2 - 9055) & v6) == 0 )
    v4 = 0;
  if ( v4 == (char *)466 )
    v15 &= 0x58u;
  GetSystemTimeAsFileTime(&v19);
  RegEnumKeyW(&v22, 1u, (LPWSTR)Name, 0x1Au);
  result = v24;
  if ( &v23 )
    return &v24[-3723];
  return result;
}
// 4014C5: returning address of temporary local variable '%var_80'
// 4013EE: variable 'v2' is possibly undefined
// 4013F9: variable 'v1' is possibly undefined
// 401456: variable 'v6' is possibly undefined
// 401250: using guessed type int __thiscall _p__osver(_DWORD);
// 401340: using guessed type WCHAR Name[4];
// 401340: using guessed type WCHAR anonymous_6[42];

//----- (004014E8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__usercall sub_4014E8@<eax>(double a1@<st0>, __int128 a2)
{
  int v2; // ecx
  _BYTE *v3; // eax
  unsigned int v4; // edx
  _BYTE *v5; // ecx
  int v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  unsigned int v10; // eax
  __int16 v11; // cx
  int v12; // eax
  int v13; // ecx
  unsigned __int8 v14; // al
  int v15; // ecx
  unsigned __int8 v16; // dl
  unsigned int v17; // eax
  bool v18; // cf
  UINT OEMCP; // eax
  int v20; // ecx
  UINT v21; // eax
  int v22; // ecx
  unsigned int v23; // edx
  int v24; // edx
  int v25; // edx
  char *result; // eax
  int v27; // [esp+1Ch] [ebp-384h]
  int v28; // [esp+2Ch] [ebp-374h]
  int v29; // [esp+1DCh] [ebp-1C4h]
  int v30; // [esp+1E4h] [ebp-1BCh]
  char v31[8]; // [esp+1F0h] [ebp-1B0h] BYREF
  _BYTE v32[6]; // [esp+1F8h] [ebp-1A8h] BYREF
  char v33; // [esp+200h] [ebp-1A0h] BYREF
  int v34; // [esp+214h] [ebp-18Ch]
  int v35; // [esp+21Ch] [ebp-184h]
  _BYTE v36[7]; // [esp+230h] [ebp-170h] BYREF
  int v37; // [esp+237h] [ebp-169h]
  char v38; // [esp+244h] [ebp-15Ch]
  __int16 v39; // [esp+24Ch] [ebp-154h]
  char v40; // [esp+268h] [ebp-138h]
  char v41; // [esp+278h] [ebp-128h]
  int v42; // [esp+288h] [ebp-118h]
  char v43; // [esp+290h] [ebp-110h]
  __int16 v44; // [esp+2ACh] [ebp-F4h]
  DWORD cchClass; // [esp+2B4h] [ebp-ECh] BYREF
  int v46; // [esp+2B8h] [ebp-E8h]
  unsigned int v47; // [esp+2C4h] [ebp-DCh]
  WCHAR v48; // [esp+2C8h] [ebp-D8h] BYREF
  LARGE_INTEGER PerformanceCount; // [esp+2CCh] [ebp-D4h] BYREF
  struct HKEY__ v50; // [esp+2DCh] [ebp-C4h] BYREF
  int v51; // [esp+2F0h] [ebp-B0h]
  int v52; // [esp+314h] [ebp-8Ch]
  struct _cpinfo v53; // [esp+324h] [ebp-7Ch] BYREF
  int cchName[2]; // [esp+338h] [ebp-68h] BYREF
  int v55; // [esp+340h] [ebp-60h]
  int v56; // [esp+35Ch] [ebp-44h]
  int v57; // [esp+360h] [ebp-40h]
  int v58; // [esp+370h] [ebp-30h]
  int v59; // [esp+380h] [ebp-20h]
  int v60; // [esp+398h] [ebp-8h]
  int v61; // [esp+39Ch] [ebp-4h]
  _BYTE savedregs[2]; // [esp+3A0h] [ebp+0h] BYREF
  __int16 savedregs_2; // [esp+3A2h] [ebp+2h] OVERLAPPED
  void *retaddr; // [esp+3A4h] [ebp+4h] OVERLAPPED

  OpenMutexW(5u, 0, (LPCWSTR)(v27 - 244));
  sub_401288(a1);
  v41 |= 0x2Cu;
  sub_401288(a1);
  if ( v2 == v35 )
    v57 &= 0xC0u;
  if ( v52 == _p__osver(v2) )
  {
    v56 ^= 0x5Fu;
    *(_WORD *)&v36[4] += 56;
  }
  sub_401288(a1);
  GetCPInfo(0x8F60C1AB, &v53);
  sub_401288(a1);
  v3 = (_BYTE *)sub_401288(a1);
  if ( v3 != v5 )
  {
    LOBYTE(v57) = v57 - 27;
    v3 = v32;
    v4 = (unsigned int)v32 & (*(_DWORD *)&v32[2] + v4);
  }
  v40 -= 68;
  v58 -= (int)&v3[v4];
  sub_401288(a1);
  ftol(-1655541100, a1);
  *(_DWORD *)v36 += v6;
  QueryPerformanceCounter(&PerformanceCount);
  v7 = sub_401288(a1);
  if ( v8 == v7 )
    LOBYTE(v28) = v28 + 127;
  v61 ^= 0x4Fu;
  sub_401288(a1);
  sub_401288(a1);
  v10 = chsize(381699196, v9);
  v55 += v10;
  if ( v10 == (v11 & 0x65D) )
    v10 = *(_DWORD *)((char *)&a2 + 6) ^ *(_DWORD *)((char *)&a2 + 3) ^ (unsigned int)&v33;
  if ( v10 != v34 )
    v42 -= 90;
  RegEnumKeyExW(&v50, 6u, (LPWSTR)0xF, (LPDWORD)cchName, (LPDWORD)&PerformanceCount.HighPart, &v48, &cchClass, 0);
  LOWORD(cchName[0]) = cchName[0] & 0xBC;
  v12 = sub_401288(a1);
  if ( v13 != 131 )
  {
    v60 |= v12;
    v13 ^= 0x20B4u;
  }
  v14 = _p__osver(v13);
  v17 = v16 & v14 & 0x9A;
  v18 = v47 < v17;
  if ( v47 == v17 )
  {
    v17 &= 0x19FFu;
    v18 = 0;
  }
  if ( v17 != -v18 )
    v17 = ((v37 | (*(_DWORD *)&v36[3] + v15)) - 418) & (*(unsigned int *)((char *)&retaddr + 3) | (unsigned int)&v36[-*(_DWORD *)((char *)&a2 + 1)]);
  PerformanceCount.LowPart ^= v17;
  if ( v17 == 385 )
    v44 |= 0x29u;
  *(_DWORD *)v32 += 236;
  sub_401288(a1);
  OEMCP = GetOEMCP();
  v53.LeadByte[6] += 7;
  v21 = OEMCP - 12676;
  v22 = (*(_DWORD *)((char *)&a2 + 5) | v20) ^ 0x269F;
  if ( v22 == v30 )
  {
    v51 -= v21 + ((unsigned int)savedregs & v22);
    v35 &= 0x6Eu;
  }
  v59 &= v21;
  v23 = (unsigned int)&savedregs[-v21];
  if ( &savedregs[-v21] != (_BYTE *)144 )
  {
    v39 &= 0xA2u;
    v23 -= v28;
  }
  if ( (v23 & v29) != 0 )
  {
    LOBYTE(v46) = v46 - 78;
    v32[4] &= 0x4Eu;
    v43 -= 59;
  }
  v38 -= 55;
  sub_401288(a1);
  v25 = *(_DWORD *)&savedregs_2 | v24;
  result = v31;
  if ( &STACK[0x2CBD] )
    return (char *)(v25 & (unsigned int)v31 ^ 0x1B1D);
  return result;
}
// 4014E8: variables would overlap: ^3A2.2 and ^3A2.4
// 4014E8: variables would overlap: ^3A4.4(retaddr) and ^3A7.4
// 401248: using guessed type signed __int64 __usercall ftol@<edx:eax>(_DWORD, double@<st0>);
// 401250: using guessed type int __thiscall _p__osver(_DWORD);
// 4014E8: using guessed type DWORD cchName[2];

//----- (00401A48) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall start@<eax>(int a1@<ebx>, char *a2@<edi>, int a3@<esi>, double a4@<st0>, int a5, __int64 a6)
{
  DWORD CurrentThreadId; // eax
  int v7; // edx
  int v8; // ecx
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // ecx
  void *v15; // ecx
  LSTATUS v16; // eax
  HRSRC ResourceW; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // ecx
  unsigned int v21; // eax
  int v22; // eax
  int v23; // eax
  HRESULT ClassStg; // eax
  unsigned int v25; // edx
  int v26; // ecx
  unsigned int v27; // ecx
  int v28; // eax
  bool v29; // cf
  int v30; // ecx
  char *v31; // ecx
  int *v32; // ebx
  int v33; // edi
  _DWORD *v34; // esi
  int v35; // eax
  char *v36; // ecx
  int v37; // eax
  int v38; // ett
  char *v39; // edi
  int v40; // edx
  int v41; // ecx
  unsigned int v42; // edi
  int v43; // edx
  int v44; // ecx
  int v46; // [esp+10h] [ebp-3C8h]
  unsigned int v47; // [esp+14h] [ebp-3C4h]
  unsigned int v48; // [esp+18h] [ebp-3C0h]
  char *v50; // [esp+28h] [ebp-3B0h]
  _BYTE v51[20]; // [esp+2Ch] [ebp-3ACh] BYREF
  char v52[3]; // [esp+44h] [ebp-394h] BYREF
  int v53; // [esp+47h] [ebp-391h]
  __int64 v54; // [esp+5Ch] [ebp-37Ch]
  int v55; // [esp+6Ch] [ebp-36Ch]
  int v56; // [esp+70h] [ebp-368h]
  char v57; // [esp+74h] [ebp-364h]
  int v58; // [esp+80h] [ebp-358h]
  int v59; // [esp+88h] [ebp-350h]
  char v60; // [esp+A0h] [ebp-338h]
  int v61; // [esp+D4h] [ebp-304h]
  int v62; // [esp+DCh] [ebp-2FCh]
  unsigned __int16 v63; // [esp+E4h] [ebp-2F4h]
  int v64; // [esp+10Ch] [ebp-2CCh]
  char v65; // [esp+124h] [ebp-2B4h] BYREF
  int v66; // [esp+13Ch] [ebp-29Ch]
  char v67; // [esp+148h] [ebp-290h]
  char v68; // [esp+15Ch] [ebp-27Ch]
  int v69; // [esp+184h] [ebp-254h]
  int v70; // [esp+18Ch] [ebp-24Ch]
  int v71; // [esp+194h] [ebp-244h]
  int v72; // [esp+198h] [ebp-240h]
  __int16 v73; // [esp+1C0h] [ebp-218h]
  _DWORD *v74; // [esp+1CCh] [ebp-20Ch]
  char v75; // [esp+1D8h] [ebp-200h] BYREF
  int v76; // [esp+1E8h] [ebp-1F0h]
  int v77; // [esp+1ECh] [ebp-1ECh]
  int v78; // [esp+1F8h] [ebp-1E0h]
  int v79; // [esp+20Ch] [ebp-1CCh]
  __int16 v80; // [esp+220h] [ebp-1B8h]
  int v81; // [esp+23Ch] [ebp-19Ch]
  int v82; // [esp+260h] [ebp-178h]
  int v83[4]; // [esp+268h] [ebp-170h] BYREF
  char v84; // [esp+278h] [ebp-160h] BYREF
  int v85; // [esp+27Fh] [ebp-159h]
  char v86[16]; // [esp+29Ch] [ebp-13Ch] BYREF
  char *v87; // [esp+2C8h] [ebp-110h]
  char v88; // [esp+2D4h] [ebp-104h]
  char v89; // [esp+2D8h] [ebp-100h]
  struct HKEY__ v90; // [esp+2DCh] [ebp-FCh] BYREF
  int v91; // [esp+2E4h] [ebp-F4h]
  CHAR SubKey[4]; // [esp+2ECh] [ebp-ECh] BYREF
  int v93[2]; // [esp+2F0h] [ebp-E8h] BYREF
  struct HKEY__ v94; // [esp+2F8h] [ebp-E0h] BYREF
  HKEY v95; // [esp+2FCh] [ebp-DCh] BYREF
  int ExitCode[3]; // [esp+300h] [ebp-D8h] BYREF
  int v97[3]; // [esp+30Ch] [ebp-CCh] BYREF
  DWORD cchName[2]; // [esp+318h] [ebp-C0h] BYREF
  struct _ACL v99; // [esp+320h] [ebp-B8h] BYREF
  __int16 Type[4]; // [esp+330h] [ebp-A8h] BYREF
  __int16 v101; // [esp+338h] [ebp-A0h]
  struct HKEY__ hKey; // [esp+33Ch] [ebp-9Ch] BYREF
  int v103; // [esp+348h] [ebp-90h]
  DWORD v104; // [esp+350h] [ebp-88h] BYREF
  __int16 v105; // [esp+358h] [ebp-80h]
  WCHAR v106; // [esp+360h] [ebp-78h] BYREF
  HKEY phkResult; // [esp+364h] [ebp-74h] BYREF
  char v108[8]; // [esp+368h] [ebp-70h] BYREF
  char v109; // [esp+370h] [ebp-68h]
  char v110; // [esp+374h] [ebp-64h]
  struct HINSTANCE__ v111; // [esp+384h] [ebp-54h] BYREF
  int v112; // [esp+398h] [ebp-40h]
  int v113; // [esp+3A0h] [ebp-38h]
  int v114; // [esp+3A4h] [ebp-34h]
  unsigned int v115; // [esp+3BCh] [ebp-1Ch]
  int v116; // [esp+3C4h] [ebp-14h]
  char savedregs; // [esp+3D8h] [ebp+0h] BYREF
  _BYTE savedregs_1[3]; // [esp+3D9h] [ebp+1h] OVERLAPPED
  _BYTE *retaddr; // [esp+3DCh] [ebp+4h] OVERLAPPED

  v78 += 90;
  _p__iob();
  LOBYTE(v77) = v77 & 0x59;
  sub_4014E8(a4, *(__int128 *)&v51[4]);
  v69 -= 100;
  sub_4014E8(a4, *(__int128 *)&v51[4]);
  RegOpenKeyA(&hKey, SubKey, &v95);
  GetCurrentProcessId();
  CurrentThreadId = GetCurrentThreadId();
  v9 = v7 & v8;
  if ( (_DWORD)v54 != CurrentThreadId )
  {
    v60 -= 2;
    v9 = *(_DWORD *)SubKey ^ (unsigned int)&v75;
  }
  v10 = _p__osver(v9);
  Type[0] ^= 0xC3u;
  v70 += v10;
  _set_app_type(_crt_gui_app);
  sub_4014E8(a4, *(__int128 *)v51);
  sub_4014E8(a4, *(__int128 *)&v51[4]);
  IsValidAcl(&v99);
  sub_4014E8(a4, *(__int128 *)&v51[4]);
  v12 = _p__osver(v11);
  if ( v14 == v12 )
    v14 = v12 + (v14 < v13) + v14 - v13;
  v15 = (void *)(*(unsigned int *)((char *)&retaddr + 1) & v14);
  if ( v15 == (void *)318 )
  {
    v112 &= 0xCCu;
    v15 = (void *)(*(_DWORD *)((_BYTE *)&a6 + 3) & (*(_DWORD *)((char *)&a6 + 2) | *(int *)((char *)&a5 + 2) & 0x12));
  }
  GetExitCodeProcess(v15, (LPDWORD)ExitCode);
  sub_401288(a4);
  sub_401340();
  v16 = RegOpenKeyA(&v94, v108, &phkResult);
  if ( v83[1] != v16 )
    v116 += v16;
  ResourceW = FindResourceW(&v111, &v106, (LPCWSTR)Type);
  v20 = v19 - (_DWORD)ResourceW;
  v73 &= 5u;
  v21 = (unsigned int)&v65;
  if ( v20 != v18 )
  {
    v29 = v63 < 0x85u;
    v63 -= 133;
    v18 -= v29 + v20;
    v21 = (unsigned int)v83 ^ 0x27E2;
  }
  *(_DWORD *)v51 = 0;
  v22 = v18 | v21;
  *(_DWORD *)&v51[16] ^= 0xF2u;
  if ( v22 )
  {
    v109 &= 0x98u;
    v20 ^= 0x2ED8u;
  }
  v23 = v58 | v22;
  if ( !(*(_DWORD *)savedregs_1 + v20) )
  {
    v57 ^= 0xDEu;
    v76 += *(_DWORD *)((char *)&v54 + 2) | v23;
    v63 |= 0xE0u;
  }
  ClassStg = ReadClassStg(0, *(CLSID **)v51);
  v27 = v25 + v29 + v26;
  if ( v25 == v27 )
  {
    v27 &= 0x2567u;
    v72 -= v27;
  }
  if ( ClassStg == -2147024809 )
  {
    v28 = 1918866546;
    v29 = v27 < v25;
    if ( v27 != v25 )
    {
      v27 &= 0x725F9472u;
      v28 = v71 ^ 0x725FADBE;
      v29 = 0;
    }
    *(_DWORD *)v51 = a3;
    v50 = a2;
    v48 = v27;
    v47 = v25;
    v46 = v28;
    v76 -= v25 - (v29 + v28);
    v74 = VirtualAlloc(0, 0x5000u, 0x1000u, 0x40u);
    v31 = (char *)((v30 ^ 0x17D0) - *(_DWORD *)((char *)&retaddr + 2) - (_DWORD)&savedregs + 14838);
    v105 += 148;
    v32 = (int *)&unk_406C4B;
    v33 = v81 & (a2 - retaddr);
    v34 = v74;
    v115 = -70690680;
    do
    {
      if ( (char *)v33 == v31 )
      {
        v33 &= 0x148Du;
        v101 |= 0x9Du;
      }
      v35 = *v32;
      v36 = v31 + 1859;
      if ( (v33 & v77) == 0 )
      {
        v36 = &savedregs;
        v67 ^= 0x4Eu;
      }
      v37 = v115 + v35;
      v38 = (__PAIR64__(&savedregs, v115) + 530324449) >> 32;
      v115 += 530324449;
      v39 = v86;
      v61 |= 0x3Cu;
      if ( v87 == &v36[-v38] )
        v39 = (char *)(*(_DWORD *)((_BYTE *)&a6 + 3) & (unsigned int)v86);
      *v34 = v37;
      v31 = v52;
      v113 &= 0xD0u;
      ++v32;
      ++v34;
      v33 = v66 | (unsigned int)&v39[-v53];
      if ( (char *)v33 != v52 )
      {
        v80 += 125;
        v79 -= 62;
        v31 = &savedregs;
        v33 &= 0x2D1u;
        v110 ^= 0x7Au;
      }
    }
    while ( v32 != (int *)&unk_407C63 );
    if ( v33 )
      v59 += 173;
    ((void (__stdcall *)(int, unsigned int, unsigned int, int, _BYTE *, char *, char *, _DWORD))v74)(
      v46,
      v47,
      v48,
      a1,
      &v51[4],
      &savedregs,
      v50,
      *(_DWORD *)v51);
    a2 = &v84;
    v25 = v85 + v40;
  }
  v89 += 51;
  v97[0] += v25;
  if ( a2 )
  {
    v64 -= (int)&savedregs;
    HIDWORD(v54) ^= v27;
    v55 ^= v27;
    LOBYTE(a2) = a6 & (unsigned __int8)a2;
  }
  RegEnumKeyExW(&hKey, 0, 0, cchName, &v104, (LPWSTR)cchName, (LPDWORD)v93, (PFILETIME)((unsigned __int8)a2 & 0x14));
  v68 |= 0xA6u;
  v56 += (int)&hKey;
  GetCurrentProcessId();
  v42 = v41 | (unsigned int)&hKey;
  WORD2(v54) += 136;
  _p__osver(v41);
  if ( (v43 & v114) != 0 )
  {
    LOWORD(v82) = v82 & 0x74;
    v62 -= v42;
    v88 -= 48;
  }
  OpenMutexW(0xCu, 0, (LPCWSTR)v97);
  RegEnumKeyW(&v90, 4u, (LPWSTR)&phkResult, 0x19u);
  GetCurrentProcessId();
  v103 |= 0x70u;
  return _p__osver(v91 | v44);
}
// 401A48: variables would overlap: ^3D9.3 and ^3D9.4
// 401A48: variables would overlap: ^3DC.4(retaddr) and ^3DD.4,^3DE.4
// 401250: using guessed type int __thiscall _p__osver(_DWORD);
// 401A48: using guessed type WCHAR Type[4];
// 401A48: using guessed type DWORD ExitCode[3];
// 401A48: using guessed type int var_CC[3];
// 401A48: using guessed type DWORD anonymous_2[2];
// 401A48: using guessed type CHAR anonymous_8[8];

// nfuncs=4 queued=4 decompiled=4 lumina nreq=0 worse=0 better=0
// ALL OK, 4 function(s) have been successfully decompiled
