/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall start(char@<al>, int@<edx>, int@<ecx>, unsigned int@<ebx>, int@<edi>, int@<esi>);


//----- (0040C6D6) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall start(char a1@<al>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebx>, int a5@<edi>, int a6@<esi>)
{
  int v7; // edi
  char v9; // of
  int v13; // esi
  __int16 v15; // bx
  bool v17; // of
  int v18; // eax
  int v21; // edi
  bool v22; // tt
  int v23; // esi
  int v24; // edx
  int v25; // ecx
  int v26; // esi
  unsigned int v27; // ebx
  char v28; // cc
  __int16 v29; // cx
  __int16 v31; // dx
  unsigned int v37; // ebx
  int v38; // esi
  int v40; // edx
  char v43; // tt
  unsigned int v47; // ett
  unsigned int v48; // edi
  unsigned int v49; // edi
  unsigned int v50; // edi
  unsigned int v51; // ett
  int v55; // edi
  int v58; // edi
  char v62; // dh
  int v63; // edi
  bool v64; // cc
  unsigned int v68; // ebx
  __int16 v72; // bx
  unsigned int v77; // ecx
  int v78; // edi
  int v80; // esi
  unsigned int v81; // ecx
  bool v82; // cf
  int v83; // edi
  char v84; // bh
  unsigned int v87; // ebx
  int v88; // [esp-24h] [ebp-24h]
  char v89; // [esp-20h] [ebp-20h]
  char v90; // [esp-1Fh] [ebp-1Fh]
  char v91; // [esp-1Ch] [ebp-1Ch]
  _BYTE v92[2]; // [esp-1Ah] [ebp-1Ah] BYREF
  int v93; // [esp-18h] [ebp-18h]
  __int16 v94; // [esp-Ch] [ebp-Ch]

  _EBX = a4 >> a3;
  v77 = a6 ^ a3;
  v78 = a5 - a6;
  LOBYTE(_EBX) = (a1 | _EBX) - 43;
  v80 = __ROL4__(a6, v77);
  v81 = v77 >> v77;
  v82 = __CFSHR__(v78, v81);
  v83 = v78 >> v81;
  if ( !v82 && v82 )
    __asm { retf }
  _ESI = _EBX | v80;
  _ECX = _EBX + v81;
  __asm { rcr     ebx, cl }
  _EAX = -1907496365;
  LOBYTE(_ECX) = __ROL4__(_ECX, _ECX);
  ++_ESI;
  v63 = v83 << _ECX;
  __asm
  {
    rcr     bl, cl
    rcl     esi, cl
  }
  SBYTE1(a2) >>= _ECX;
  v68 = -1907496365;
  _ECX = -1907496365;
  while ( 1 )
  {
    v87 = v68 >> _ECX;
    __asm { rcl     ch, cl }
    v55 = _ECX ^ (v63 << _ECX);
    BYTE1(_ECX) <<= _ECX;
    LOBYTE(v87) = BYTE1(_EAX);
    __asm { rcl     ecx, cl }
    SBYTE1(v87) >>= _ECX;
    v82 = __CFADD__(v87, a2);
    _EDX = v87 + a2;
    LOBYTE(_ECX) = -8 - (v82 - 52);
    v82 = __CFSHL__(v55, _ECX);
    v58 = v55 << _ECX;
    __asm { rcr     dl, cl }
    BYTE1(_ECX) = (BYTE1(_ECX) < (unsigned __int8)(v82 + BYTE1(v87))) + BYTE1(_ECX) - (v82 + BYTE1(v87)) - 31;
    BYTE1(v87) <<= _ECX;
    __asm
    {
      rcl     ecx, cl
      rcl     edx, cl
    }
    v21 = v87 & v58;
    v22 = __CFSHL__(_ECX, _ECX);
    _ECX = __ROL4__(_ECX, _ECX);
    LOBYTE(_EDX) = _EDX + 86;
    _EDX = _EAX + v22 + _EDX;
    LOBYTE(_EDX) = BYTE1(_EAX) ^ _EDX;
    __asm { rcl     dl, cl }
    _EDX = __ROR4__(_EDX, _ECX);
    LOBYTE(_EDX) = _EDX + 1;
    LOBYTE(v87) = __ROR1__(BYTE1(_EAX) ^ 0x8E, _ECX) | 0x5D;
    __asm { rcl     dh, cl }
    BYTE1(v87) = __ROL1__(BYTE1(v87), _ECX);
    v37 = __ROL4__(v87, _ECX);
    SBYTE1(_ECX) >>= _ECX;
    v38 = (_DWORD)_ESI << _ECX << _ECX;
    LOBYTE(_ECX) = __ROR1__(_ECX, _ECX);
    v23 = _EAX + v38;
    BYTE1(v37) = _EDX + 1;
    v24 = __ROL4__(_EDX, _ECX);
    v25 = v23 ^ _ECX;
    v82 = __CFSHL__(v23, v25);
    v26 = v23 << v25;
    v27 = (__PAIR64__(v37 - (v82 + v21), v37) - __PAIR64__(v21, (unsigned int)v82 + v21)) >> 32;
    LOBYTE(v25) = (_BYTE)v25 << v25;
    v28 = (v25 + 1 < 0) ^ __OFADD__(1, v25) | (v25 == -1);
    v29 = v25 + 1;
    if ( !v28 )
    {
      if ( v28 )
        break;
    }
    LOBYTE(v27) = BYTE1(v27) & v27;
    BYTE1(v24) = __CFSHR__(BYTE1(v24), v29) + __ROR1__(BYTE1(v24), v29) - 124;
    v40 = __ROR4__(v24, v29);
    _ESI = v21 + v26;
    BYTE1(v27) = HIBYTE(v29) - 1;
    BYTE1(v40) &= 0x9Eu;
    _ECX = _ESI;
    BYTE1(v27) <<= _ESI;
    v43 = __CFSHR__(BYTE1(v27), _ESI);
    BYTE1(v27) = __ROR1__(BYTE1(v27), _ESI);
    v82 = __CFADD__(v43, BYTE1(v27));
    BYTE1(v27) += v43;
    v82 |= __CFADD__(BYTE1(_EAX), BYTE1(v27));
    BYTE1(v27) += BYTE1(_EAX);
    __asm { rcr     ch, cl }
    v47 = v82 + v40;
    v82 = v27 < v47;
    _EBX = v27 - v47;
    v48 = _EBX + v82 + v21;
    BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ESI);
    LOBYTE(_EBX) = _EBX - _ESI;
    v82 = v48 < _ECX;
    v49 = v48 - _ECX;
    v51 = v82 + _EBX;
    v82 = v49 < v51;
    v50 = v49 - v51;
    _EDX = _EBX + v82 + v40;
    BYTE1(_EBX) += BYTE1(_ECX) + __CFSHR__(_ESI, _ESI);
    LOBYTE(_ECX) = (char)_ESI >> _ESI;
    _ECX = _ECX << ((char)_ESI >> _ESI);
    BYTE1(_EBX) += _EAX;
    __asm { rcr     dl, cl }
    LOBYTE(v51) = __CFSHR__(v50, _ECX);
    _EDI = __ROR4__(v50, _ECX);
    __asm
    {
      rcl     ebx, cl
      rcl     edi, cl
    }
    LOBYTE(_EBX) = _EBX + 1;
    _EDX = _ESI + (unsigned __int8)v51 + __ROR4__(_EDX, _ECX);
    v82 = __CFSHR__(BYTE1(_EDX), _ECX);
    BYTE1(_EDX) >>= _ECX;
    __asm { rcl     bh, cl }
    v7 = _ECX + v82 + _EDI;
    BYTE1(_EBX) = _BH >> _ECX;
    __asm { rcl     esi, cl }
    LOBYTE(_EDX) = 92;
    BYTE1(_ECX) = BYTE1(_EBX);
    if ( ((_EBX & 0x8000) != 0) != v9 || ((_EBX & 0x8000) != 0) == v9 )
      JUMPOUT(0x40C176);
    BYTE1(_EAX) = -26;
    v13 = _ESI >> 1;
    __debugbreak();
    __asm { rcr     edx, cl }
    LOBYTE(_EBX) = _EBX ^ 0xC2;
    v15 = v13 ^ _EBX;
    __asm { rcr     ecx, cl }
    v17 = __OFADD__(v13, _EAX);
    v18 = v13 + _EAX;
    if ( !v17 && v17 )
      JUMPOUT(0x40BF2E);
    HIWORD(a2) = HIWORD(v7);
    LOBYTE(_ECX) = _ECX - HIBYTE(v15);
    _EAX = v18 >> _ECX;
    _ECX = _ECX - v7;
    LOBYTE(v72) = _ECX ^ v15;
    BYTE1(_EAX) -= _EAX;
    HIBYTE(v72) = 102;
    __asm { rcr     cl, cl }
    v84 = __ROR1__((v13 + (v13 & v72)) & ((unsigned __int16)(v13 + (v13 & v72)) >> 8), _ECX);
    LOBYTE(_EAX) = (unsigned __int8)_EAX >> _ECX;
    BYTE1(a2) = BYTE1(v7) << _ECX;
    _ECX = v13 + __CFSHL__(BYTE1(v7), _ECX) + _ECX;
    LOBYTE(_EAX) = _EAX | 0x15;
    __asm
    {
      rcr     eax, cl
      rcr     ah, cl
    }
    v62 = (SBYTE1(a2) >> _ECX) + 27;
    LOBYTE(a2) = (v84 | v7) - 1;
    v82 = __CFADD__(v62, -88);
    BYTE1(a2) = v62 - 88;
    v63 = _ECX + v13 + v82 + v7;
    __asm { rcr     ah, cl }
    BYTE1(_EAX) ^= a2;
    v64 = (unsigned __int8)_EAX <= 0x43u;
    LOBYTE(_EAX) = _EAX - 67;
    if ( v64 || !v64 )
      JUMPOUT(0x40C2BA);
    _ESI = &v92[_ECX];
    __asm { rep shr cl, cl }
    _ECX = _ECX - _EAX;
    v68 = v63;
    LOBYTE(_ECX) = (char)_ECX >> _ECX;
    BYTE1(v68) = _EAX + BYTE1(v63);
    if ( _EAX == 2073108301 )
    {
      LOBYTE(a2) = ((unsigned __int16)(8013
                                     - (((unsigned __int8)a2 < (unsigned __int8)(__CFADD__(
                                                                                   (_DWORD)_ESI << _ECX,
                                                                                   2073108301)
                                                                               + 59))
                                      + (_WORD)_ECX)) >> 8)
                 + a2
                 - (__CFADD__((_DWORD)_ESI << _ECX, 2073108301)
                  + 59);
      if ( !__OFADD__(1, a2) && __OFADD__(1, a2) )
        JUMPOUT(0x40C4FF);
      JUMPOUT(0x40C4BA);
    }
  }
  _AL = v88;
  HIBYTE(v31) = v90;
  _CL = v91;
  _EBX = v93;
  BYTE1(_EBX) = BYTE1(v93) - 97;
  __asm { rcr     ebx, cl }
  LOBYTE(v31) = v89 - *(_BYTE *)(v88 + 28);
  _DX = v94 | v31;
  __asm { rcl     dh, cl }
  BYTE1(_EBX) <<= HIBYTE(_DX) + v91;
  _CL = HIBYTE(_DX) + v91 + 1;
  __asm { rcr     al, cl }
  v82 = __CFSHL__(_EBX, _CL);
  _EBX = _EBX << _CL;
  LOBYTE(_EBX) = _EBX + 1 - (v82 + HIBYTE(_DX));
  _CL = (_DX - 41) & _CL;
  __asm { rcl     ebx, cl }
  _CL = 65;
  __asm { rcl     cl, cl }
  JUMPOUT(0x40C5BD);
}
// 40C62A: positive sp value 24 has been found
// 40BF2C: control flows out of bounds to 40BF2E
// 40C109: control flows out of bounds to 40C10B
// 40C1AB: control flows out of bounds to 40C1AD
// 40C292: inconsistent fpu stack
// 40C45E: control flows out of bounds to 40C45F
// 40C4F9: control flows out of bounds to 40C4FF
// 40C53E: control flows out of bounds to 40C53F
// 40C62D: control flows out of bounds to 40C62F
// 40C6CA: control flows out of bounds to 40C6D0
// 40C6FB: unbalanced stack, ignored a potential tail call
// 40C177: control flows out of bounds to EC13BD4E
// 40C512: control flows out of bounds to 40BF0F
// 40C557: control flows out of bounds to 40C5BD
// 40C5F2: control flows out of bounds to 40C4BA
// 40C793: control flows out of bounds to 40C176
// 40C7EE: control flows out of bounds to 5BB8132F
// 40C02B: control flows out of bounds to 40C018
// 40C16F: control flows out of bounds to 40C156
// 40C226: control flows out of bounds to 40C1A8
// 40C381: control flows out of bounds to 40C2BA
// 40C3BF: control flows out of bounds to 40C3B0
// 40C696: control flows out of bounds to 40C295
// 40C220: conditional instruction was optimized away because edx.4>=0
// 40C2F1: conditional instruction was optimized away because bl.1!=0
// 40C3B8: conditional instruction was optimized away because esi.4!=0
// 40C574: conditional instruction was optimized away because ah.1!=0
// 40C6FB: variable 'v88' is possibly undefined
// 40BEFC: variable 'v9' is possibly undefined
// 40BF61: variable 'v90' is possibly undefined
// 40BF61: variable 'v91' is possibly undefined
// 40BF62: variable 'v89' is possibly undefined

// nfuncs=2 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
