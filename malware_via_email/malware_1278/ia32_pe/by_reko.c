// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_tB6A8; // 0040B000
<anonymous> * __imp__VirtualAlloc = &g_tB6BA; // 0040B004
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_tB6CA; // 0040B008
<anonymous> * __imp__HeapDestroy = &g_tB6E4; // 0040B00C
<anonymous> * __imp__HeapFree = &g_tB6F2; // 0040B010
<anonymous> * __imp__EnterCriticalSection = &g_tB6FE; // 0040B014
<anonymous> * __imp__Sleep = &g_tB716; // 0040B018
<anonymous> * __imp__lstrcmpiW = &g_tB71E; // 0040B01C
<anonymous> * __imp__VirtualAlloc = &g_tB72A; // 0040B020
<anonymous> * __imp__VirtualProtect = &g_tB73A; // 0040B024
<anonymous> * __imp__GetCurrentProcessId = &g_tB74C; // 0040B028
<anonymous> * __imp__MultiByteToWideChar = &g_tB762; // 0040B02C
<anonymous> * __imp__LoadLibraryW = &g_tB778; // 0040B030
<anonymous> * __imp__InterlockedDecrement = &g_tB788; // 0040B034
<anonymous> * __imp__CreateThread = &g_tB7A0; // 0040B038
<anonymous> * __imp__VirtualProtect = &g_tB7B0; // 0040B03C
<anonymous> * __imp__GetVersionExA = &g_tB7C2; // 0040B040
<anonymous> * __imp__GetVersionExA = &g_tB7D2; // 0040B044
<anonymous> * __imp__InitializeCriticalSection = &g_tB7E2; // 0040B048
<anonymous> * __imp__GetVersionExA = &g_tB7FE; // 0040B04C
<anonymous> * __imp__CloseHandle = &g_tB80E; // 0040B050
<anonymous> * __imp__CloseHandle = &g_tB81C; // 0040B054
<anonymous> * __imp__FreeLibrary = &g_tB82A; // 0040B058
<anonymous> * __imp__ReadFile = &g_tB838; // 0040B05C
<anonymous> * __imp__GetVersionExA = &g_tB844; // 0040B060
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_tB854; // 0040B064
<anonymous> * __imp__GetProcessHeap = &g_tB86E; // 0040B068
<anonymous> * __imp__LoadLibraryA = &g_tB880; // 0040B06C
<anonymous> * __imp__LoadLibraryA = &g_tB890; // 0040B070
<anonymous> * __imp__GetLastError = &g_tB8A0; // 0040B074
<anonymous> * __imp__GetVersionExA = &g_tB8B0; // 0040B078
<anonymous> * __imp__InterlockedExchange = &g_tB8C0; // 0040B07C
<anonymous> * __imp__LocalAlloc = &g_tB8D6; // 0040B080
<anonymous> * __imp__MultiByteToWideChar = &g_tB8E4; // 0040B084
<anonymous> * __imp__GetCurrentProcessId = &g_tB8FA; // 0040B088
<anonymous> * __imp__GetModuleHandleA = &g_tB910; // 0040B08C
<anonymous> * __imp__GetTickCount = &g_tB924; // 0040B090
<anonymous> * __imp__InterlockedDecrement = &g_tB934; // 0040B094
<anonymous> * __imp__GetProcessHeap = &g_tB94C; // 0040B098
<anonymous> * __imp__GetModuleHandleW = &g_tB95E; // 0040B09C
<anonymous> * __imp__GetLastError = &g_tB972; // 0040B0A0
<anonymous> * __imp__lstrlenA = &g_tB982; // 0040B0A4
<anonymous> * __imp__GetCurrentThreadId = &g_tB98E; // 0040B0A8
<anonymous> * __imp__Sleep = &g_tB9A4; // 0040B0AC
<anonymous> * __imp__CloseHandle = &g_tB9AC; // 0040B0B0
<anonymous> * __imp__GetLastError = &g_tB9BA; // 0040B0B4
<anonymous> * __imp__lstrcmpiW = &g_tB9CA; // 0040B0B8
<anonymous> * __imp__LoadLibraryA = &g_tB9D6; // 0040B0BC
<anonymous> * __imp__GetLastError = &g_tB9E6; // 0040B0C0
<anonymous> * __imp__HeapFree = &g_tB9F6; // 0040B0C4
<anonymous> * __imp__SetTimer = &g_tBA10; // 0040B0CC
<anonymous> * __imp__BeginPaint = &g_tBA1C; // 0040B0D0
<anonymous> * __imp__BeginPaint = &g_tBA2A; // 0040B0D4
<anonymous> * __imp__PostMessageW = &g_tBA38; // 0040B0D8
<anonymous> * __imp__LoadStringW = &g_tBA48; // 0040B0DC
<anonymous> * __imp__GetClientRect = &g_tBA56; // 0040B0E0
<anonymous> * __imp__KillTimer = &g_tBA66; // 0040B0E4
<anonymous> * __imp__CharNextW = &g_tBA72; // 0040B0E8
<anonymous> * __imp__SetTimer = &g_tBA7E; // 0040B0EC
<anonymous> * __imp__BeginPaint = &g_tBA8A; // 0040B0F0
<anonymous> * __imp__MessageBoxW = &g_tBA98; // 0040B0F4
<anonymous> * __imp__SetWindowTextW = &g_tBAA6; // 0040B0F8
<anonymous> * __imp__GetDlgItem = &g_tBAB8; // 0040B0FC
<anonymous> * __imp__LoadIconW = &g_tBAC6; // 0040B100
<anonymous> * __imp__SetFocus = &g_tBAD2; // 0040B104
<anonymous> * __imp__EndPaint = &g_tBADE; // 0040B108
<anonymous> * __imp__CreateWindowExW = &g_tBAEA; // 0040B10C
<anonymous> * __imp__GetDlgItem = &g_tBAFC; // 0040B110
<anonymous> * __imp__GetSystemMetrics = &g_tBB0A; // 0040B114
<anonymous> * __imp__LoadCursorW = &g_tBB1E; // 0040B118
<anonymous> * __imp__GetSysColor = &g_tBB2C; // 0040B11C
<anonymous> * __imp__SetForegroundWindow = &g_tBB3A; // 0040B120
<anonymous> * __imp__SetFocus = &g_tBB50; // 0040B124
<anonymous> * __imp__SetTimer = &g_tBB5C; // 0040B128
<anonymous> * __imp__InvalidateRect = &g_tBB68; // 0040B12C
<anonymous> * __imp__SetCursor = &g_tBB7A; // 0040B130
<anonymous> * __imp__InvalidateRect = &g_tBB86; // 0040B134
<anonymous> * __imp__GetFocus = &g_tBB98; // 0040B138
<anonymous> * __imp__BeginPaint = &g_tBBA4; // 0040B13C
<anonymous> * __imp__InvalidateRect = &g_tBBB2; // 0040B140
<anonymous> * __imp__IsWindow = &g_tBBC4; // 0040B144
<anonymous> * __imp__GetDesktopWindow = &g_tBBD0; // 0040B148
<anonymous> * __imp__SetWindowPos = &g_tBBE4; // 0040B14C
<anonymous> * __imp__DialogBoxParamW = &g_tBBF4; // 0040B150
<anonymous> * __imp__LoadStringW = &g_tBC06; // 0040B154
<anonymous> * __imp__SetForegroundWindow = &g_tBC14; // 0040B158
<anonymous> * __imp__GetClientRect = &g_tBC2A; // 0040B15C
<anonymous> * __imp__BeginPaint = &g_tBC3A; // 0040B160
<anonymous> * __imp__GetFocus = &g_tBC48; // 0040B164
<anonymous> * __imp__SetWindowLongW = &g_tBC54; // 0040B168
<anonymous> * __imp__DialogBoxParamW = &g_tBC66; // 0040B16C
<anonymous> * __imp__PostQuitMessage = &g_tBC78; // 0040B170
<anonymous> * __imp__GetDC = &g_tBC8A; // 0040B174
<anonymous> * __imp__PostQuitMessage = &g_tBC92; // 0040B178
<anonymous> * __imp__DialogBoxParamW = &g_tBCA4; // 0040B17C
<anonymous> * __imp__MoveToEx = &g_tBCC2; // 0040B184
<anonymous> * __imp__GetWindowExtEx = &g_tBCCE; // 0040B188
<anonymous> * __imp__CreateFontA = &g_tBCE0; // 0040B18C
<anonymous> * __imp__SetTextColor = &g_tBCEE; // 0040B190
<anonymous> * __imp__Ellipse = &g_tBCFE; // 0040B194
<anonymous> * __imp__GetBkColor = &g_tBD08; // 0040B198
<anonymous> * __imp__MoveToEx = &g_tBD16; // 0040B19C
<anonymous> * __imp__CreateFontIndirectA = &g_tBD22; // 0040B1A0
<anonymous> * __imp__CreateDIBSection = &g_tBD38; // 0040B1A4
<anonymous> * __imp__GetPixel = &g_tBD4C; // 0040B1A8
<anonymous> * __imp__CreateCompatibleDC = &g_tBD58; // 0040B1AC
<anonymous> * __imp__GetBkMode = &g_tBD6E; // 0040B1B0
<anonymous> * __imp__GetBkColor = &g_tBD7A; // 0040B1B4
<anonymous> * __imp__CreatePen = &g_tBD88; // 0040B1B8
<anonymous> * __imp__SetBkColor = &g_tBD94; // 0040B1BC
<anonymous> * __imp__MoveToEx = &g_tBDA2; // 0040B1C0
<anonymous> * __imp__SetTextColor = &g_tBDAE; // 0040B1C4
<anonymous> * __imp__CreateFontIndirectA = &g_tBDBE; // 0040B1C8
<anonymous> * __imp__CreateBitmapIndirect = &g_tBDD4; // 0040B1CC
<anonymous> * __imp__PatBlt = &g_tBDEC; // 0040B1D0
<anonymous> * __imp__SelectObject = &g_tBDF6; // 0040B1D4
<anonymous> * __imp__GetBkMode = &g_tBE06; // 0040B1D8
<anonymous> * __imp__PatBlt = &g_tBE12; // 0040B1DC
<anonymous> * __imp__CreateDIBSection = &g_tBE1C; // 0040B1E0
<anonymous> * __imp__LineTo = &g_tBE30; // 0040B1E4
<anonymous> * __imp__CreatePen = &g_tBE3A; // 0040B1E8
<anonymous> * __imp__CreateDIBitmap = &g_tBE46; // 0040B1EC
<anonymous> * __imp__BitBlt = &g_tBE58; // 0040B1F0
<anonymous> * __imp__Ellipse = &g_tBE62; // 0040B1F4
<anonymous> * __imp__SelectObject = &g_tBE6C; // 0040B1F8
<anonymous> * __imp__RoundRect = &g_tBE7C; // 0040B1FC
<anonymous> * __imp__SelectObject = &g_tBE88; // 0040B200
<anonymous> * __imp__CreateDIBSection = &g_tBE98; // 0040B204
<anonymous> * __imp__SetBkMode = &g_tBEAC; // 0040B208
<anonymous> * __imp__CreateBitmapIndirect = &g_tBEB8; // 0040B20C
<anonymous> * __imp__Polygon = &g_tBED0; // 0040B210
<anonymous> * __imp__CreateDIBitmap = &g_tBEDA; // 0040B214
<anonymous> * __imp__CreateFontIndirectA = &g_tBEEC; // 0040B218
<anonymous> * __imp__CreateBitmap = &g_tBF02; // 0040B21C
<anonymous> * __imp__Polygon = &g_tBF12; // 0040B220
<anonymous> * __imp__SetWindowOrgEx = &g_tBF1C; // 0040B224
<anonymous> * __imp__RoundRect = &g_tBF2E; // 0040B228
<anonymous> * __imp__LineTo = &g_tBF3A; // 0040B22C
<anonymous> * __imp__CombineRgn = &g_tBF44; // 0040B230
<anonymous> * __imp__PatBlt = &g_tBF52; // 0040B234
<anonymous> * __imp__PatBlt = &g_tBF5C; // 0040B238
<anonymous> * __imp__SetTextColor = &g_tBF66; // 0040B23C
<anonymous> * __imp__GetWindowOrgEx = &g_tBF76; // 0040B240
<anonymous> * __imp__LsaGetQuotasForAccount = &g_tBF92; // 0040B248
<anonymous> * __imp__SetNamedSecurityInfoExW = &g_tBFAC; // 0040B24C
<anonymous> * __imp__CryptDestroyHash = &g_tBFC6; // 0040B250
<anonymous> * __imp__GetSidLengthRequired = &g_tBFDA; // 0040B254
<anonymous> * __imp__CryptGetProvParam = &g_tBFF2; // 0040B258
<anonymous> * __imp__ElfClearEventLogFileW = &g_tC006; // 0040B25C
<anonymous> * __imp__LsaEnumerateTrustedDomains = &g_tC01E; // 0040B260
<anonymous> * __imp__GetSecurityDescriptorRMControl = &g_tC03C; // 0040B264
<anonymous> * __imp__GetTrusteeFormW = &g_tC05E; // 0040B268
<anonymous> * __imp__LsaEnumeratePrivileges = &g_tC070; // 0040B26C
<anonymous> * __imp__OpenEncryptedFileRawW = &g_tC08A; // 0040B270
<anonymous> * __imp__SetSecurityInfoExW = &g_tC0A2; // 0040B274
<anonymous> * __imp__GetMultipleTrusteeOperationW = &g_tC0B8; // 0040B278
<anonymous> * __imp__TrusteeAccessToObjectW = &g_tC0D8; // 0040B27C
<anonymous> * __imp__GetMultipleTrusteeA = &g_tC0F2; // 0040B280
<anonymous> * __imp__ChangeServiceConfig2A = &g_tC108; // 0040B284
<anonymous> * __imp__InitiateSystemShutdownExW = &g_tC120; // 0040B288
<anonymous> * __imp__CryptAcquireContextA = &g_tC13C; // 0040B28C
<anonymous> * __imp__GetSecurityInfoExW = &g_tC154; // 0040B290
<anonymous> * __imp__IsValidSecurityDescriptor = &g_tC16A; // 0040B294
<anonymous> * __imp__ReadEventLogA = &g_tC186; // 0040B298
<anonymous> * __imp__SystemFunction007 = &g_tC196; // 0040B29C
<anonymous> * __imp__RegisterServiceCtrlHandlerA = &g_tC1AA; // 0040B2A0
<anonymous> * __imp__CommandLineFromMsiDescriptor = &g_tC1C8; // 0040B2A4
<anonymous> * __imp__AreAllAccessesGranted = &g_tC1E8; // 0040B2A8
<anonymous> * __imp__LsaCreateAccount = &g_tC200; // 0040B2AC
<anonymous> * __imp__RegGetKeySecurity = &g_tC214; // 0040B2B0
<anonymous> * __imp__QueryServiceObjectSecurity = &g_tC228; // 0040B2B4
<anonymous> * __imp__EncryptFileW = &g_tC246; // 0040B2B8
<anonymous> * __imp__FileEncryptionStatusA = &g_tC256; // 0040B2BC
<anonymous> * __imp__SetServiceBits = &g_tC26E; // 0040B2C0
<anonymous> * __imp__LsaEnumerateAccountRights = &g_tC280; // 0040B2C4
<anonymous> * __imp__LsaEnumerateAccountsWithUserRight = &g_tC29C; // 0040B2C8
<anonymous> * __imp__CryptSetProvParam = &g_tC2C0; // 0040B2CC
<anonymous> * __imp__CryptGenKey = &g_tC2D4; // 0040B2D0
<anonymous> * __imp__GetEffectiveRightsFromAclW = &g_tC2E2; // 0040B2D4
<anonymous> * __imp__QueryServiceConfigA = &g_tC300; // 0040B2D8
<anonymous> * __imp__ElfReportEventA = &g_tC316; // 0040B2DC
<anonymous> * __imp__IsValidSecurityDescriptor = &g_tC328; // 0040B2E0
<anonymous> * __imp__ElfReadEventLogA = &g_tC344; // 0040B2E4
<anonymous> * __imp__CryptVerifySignatureW = &g_tC358; // 0040B2E8
<anonymous> * __imp__SystemFunction004 = &g_tC370; // 0040B2EC
<anonymous> * __imp__LsaQueryTrustedDomainInfoByName = &g_tC384; // 0040B2F0
<anonymous> * __imp__AddAuditAccessAce = &g_tC3A6; // 0040B2F4
<anonymous> * __imp__GetSidLengthRequired = &g_tC3BA; // 0040B2F8
<anonymous> * __imp__IsTextUnicode = &g_tC3D2; // 0040B2FC
<anonymous> * __imp__AddAccessDeniedAceEx = &g_tC3E2; // 0040B300
<anonymous> * __imp__GetSecurityDescriptorControl = &g_tC3FA; // 0040B304
<anonymous> * __imp__WmiMofEnumerateResourcesW = &g_tC41A; // 0040B308
<anonymous> * __imp__CryptExportKey = &g_tC436; // 0040B30C
<anonymous> * __imp__RegCreateKeyExW = &g_tC448; // 0040B310
<anonymous> * __imp__QueryServiceConfigW = &g_tC45A; // 0040B314
<anonymous> * __imp__SetUserFileEncryptionKey = &g_tC470; // 0040B318
word32 g_dw40B388 = 46760; // 0040B388
word32 g_dw40B38C = 0xB6BA; // 0040B38C
word32 g_dw40B390 = 46794; // 0040B390
word32 g_dw40B394 = 0xB6E4; // 0040B394
word32 g_dw40B398 = 46834; // 0040B398
word32 g_dw40B39C = 46846; // 0040B39C
word32 g_dw40B3A0 = 0xB716; // 0040B3A0
word32 g_dw40B3A4 = 46878; // 0040B3A4
word32 g_dw40B3A8 = 0xB72A; // 0040B3A8
word32 g_dw40B3AC = 46906; // 0040B3AC
word32 g_dw40B3B0 = 46924; // 0040B3B0
word32 g_dw40B3B4 = 46946; // 0040B3B4
word32 g_dw40B3B8 = 0xB778; // 0040B3B8
word32 g_dw40B3BC = 0xB788; // 0040B3BC
word32 g_dw40B3C0 = 0xB7A0; // 0040B3C0
word32 g_dw40B3C4 = 0xB7B0; // 0040B3C4
word32 g_dw40B3C8 = 47042; // 0040B3C8
word32 g_dw40B3CC = 0xB7D2; // 0040B3CC
word32 g_dw40B3D0 = 47074; // 0040B3D0
word32 g_dw40B3D4 = 0xB7FE; // 0040B3D4
word32 g_dw40B3D8 = 0xB80E; // 0040B3D8
word32 g_dw40B3DC = 0xB81C; // 0040B3DC
word32 g_dw40B3E0 = 47146; // 0040B3E0
word32 g_dw40B3E4 = 0xB838; // 0040B3E4
word32 g_dw40B3E8 = 0xB844; // 0040B3E8
word32 g_dw40B3EC = 47188; // 0040B3EC
word32 g_dw40B3F0 = 47214; // 0040B3F0
word32 g_dw40B3F4 = 0xB880; // 0040B3F4
word32 g_dw40B3F8 = 0xB890; // 0040B3F8
word32 g_dw40B3FC = 0xB8A0; // 0040B3FC
word32 g_dw40B400 = 0xB8B0; // 0040B400
word32 g_dw40B404 = 0xB8C0; // 0040B404
word32 g_dw40B408 = 0xB8D6; // 0040B408
word32 g_dw40B40C = 47332; // 0040B40C
word32 g_dw40B410 = 47354; // 0040B410
word32 g_dw40B414 = 0xB910; // 0040B414
word32 g_dw40B418 = 0xB924; // 0040B418
word32 g_dw40B41C = 47412; // 0040B41C
word32 g_dw40B420 = 47436; // 0040B420
word32 g_dw40B424 = 47454; // 0040B424
word32 g_dw40B428 = 47474; // 0040B428
word32 g_dw40B42C = 47490; // 0040B42C
word32 g_dw40B430 = 0xB98E; // 0040B430
word32 g_dw40B434 = 47524; // 0040B434
word32 g_dw40B438 = 0xB9AC; // 0040B438
word32 g_dw40B43C = 0xB9BA; // 0040B43C
word32 g_dw40B440 = 0xB9CA; // 0040B440
word32 g_dw40B444 = 47574; // 0040B444
word32 g_dw40B448 = 0xB9E6; // 0040B448
word32 g_dw40B44C = 47606; // 0040B44C
word32 g_dw40B454 = 0xBA10; // 0040B454
word32 g_dw40B458 = 47644; // 0040B458
word32 g_dw40B45C = 0xBA2A; // 0040B45C
word32 g_dw40B460 = 47672; // 0040B460
word32 g_dw40B464 = 47688; // 0040B464
word32 g_dw40B468 = 47702; // 0040B468
word32 g_dw40B46C = 0xBA66; // 0040B46C
word32 g_dw40B470 = 47730; // 0040B470
word32 g_dw40B474 = 47742; // 0040B474
word32 g_dw40B478 = 47754; // 0040B478
word32 g_dw40B47C = 47768; // 0040B47C
word32 g_dw40B480 = 0xBAA6; // 0040B480
word32 g_dw40B484 = 0xBAB8; // 0040B484
word32 g_dw40B488 = 47814; // 0040B488
word32 g_dw40B48C = 0xBAD2; // 0040B48C
word32 g_dw40B490 = 47838; // 0040B490
word32 g_dw40B494 = 0xBAEA; // 0040B494
word32 g_dw40B498 = 47868; // 0040B498
word32 g_dw40B49C = 0xBB0A; // 0040B49C
word32 g_dw40B4A0 = 0xBB1E; // 0040B4A0
word32 g_dw40B4A4 = 0xBB2C; // 0040B4A4
word32 g_dw40B4A8 = 0xBB3A; // 0040B4A8
word32 g_dw40B4AC = 0xBB50; // 0040B4AC
word32 g_dw40B4B0 = 0xBB5C; // 0040B4B0
word32 g_dw40B4B4 = 0xBB68; // 0040B4B4
word32 g_dw40B4B8 = 47994; // 0040B4B8
word32 g_dw40B4BC = 0xBB86; // 0040B4BC
word32 g_dw40B4C0 = 0xBB98; // 0040B4C0
word32 g_dw40B4C4 = 0xBBA4; // 0040B4C4
word32 g_dw40B4C8 = 0xBBB2; // 0040B4C8
word32 g_dw40B4CC = 0xBBC4; // 0040B4CC
word32 g_dw40B4D0 = 0xBBD0; // 0040B4D0
word32 g_dw40B4D4 = 0xBBE4; // 0040B4D4
word32 g_dw40B4D8 = 0xBBF4; // 0040B4D8
word32 g_dw40B4DC = 0xBC06; // 0040B4DC
word32 g_dw40B4E0 = 48148; // 0040B4E0
word32 g_dw40B4E4 = 0xBC2A; // 0040B4E4
word32 g_dw40B4E8 = 48186; // 0040B4E8
word32 g_dw40B4EC = 48200; // 0040B4EC
word32 g_dw40B4F0 = 48212; // 0040B4F0
word32 g_dw40B4F4 = 0xBC66; // 0040B4F4
word32 g_dw40B4F8 = 48248; // 0040B4F8
word32 g_dw40B4FC = 48266; // 0040B4FC
word32 g_dw40B500 = 48274; // 0040B500
word32 g_dw40B504 = 48292; // 0040B504
word32 g_dw40B50C = 0xBCC2; // 0040B50C
word32 g_dw40B510 = 48334; // 0040B510
word32 g_dw40B514 = 0xBCE0; // 0040B514
word32 g_dw40B518 = 0xBCEE; // 0040B518
word32 g_dw40B51C = 48382; // 0040B51C
word32 g_dw40B520 = 0xBD08; // 0040B520
word32 g_dw40B524 = 48406; // 0040B524
word32 g_dw40B528 = 48418; // 0040B528
word32 g_dw40B52C = 48440; // 0040B52C
word32 g_dw40B530 = 48460; // 0040B530
word32 g_dw40B534 = 48472; // 0040B534
word32 g_dw40B538 = 48494; // 0040B538
word32 g_dw40B53C = 0xBD7A; // 0040B53C
word32 g_dw40B540 = 0xBD88; // 0040B540
word32 g_dw40B544 = 0xBD94; // 0040B544
word32 g_dw40B548 = 48546; // 0040B548
word32 g_dw40B54C = 48558; // 0040B54C
word32 g_dw40B550 = 0xBDBE; // 0040B550
word32 g_dw40B554 = 0xBDD4; // 0040B554
word32 g_dw40B558 = 0xBDEC; // 0040B558
word32 g_dw40B55C = 0xBDF6; // 0040B55C
word32 g_dw40B560 = 48646; // 0040B560
word32 g_dw40B564 = 48658; // 0040B564
word32 g_dw40B568 = 48668; // 0040B568
word32 g_dw40B56C = 48688; // 0040B56C
word32 g_dw40B570 = 48698; // 0040B570
word32 g_dw40B574 = 0xBE46; // 0040B574
word32 g_dw40B578 = 48728; // 0040B578
word32 g_dw40B57C = 48738; // 0040B57C
word32 g_dw40B580 = 48748; // 0040B580
word32 g_dw40B584 = 48764; // 0040B584
word32 g_dw40B588 = 0xBE88; // 0040B588
word32 g_dw40B58C = 0xBE98; // 0040B58C
word32 g_dw40B590 = 48812; // 0040B590
word32 g_dw40B594 = 48824; // 0040B594
word32 g_dw40B598 = 48848; // 0040B598
word32 g_dw40B59C = 48858; // 0040B59C
word32 g_dw40B5A0 = 0xBEEC; // 0040B5A0
word32 g_dw40B5A4 = 48898; // 0040B5A4
word32 g_dw40B5A8 = 48914; // 0040B5A8
word32 g_dw40B5AC = 48924; // 0040B5AC
word32 g_dw40B5B0 = 48942; // 0040B5B0
word32 g_dw40B5B4 = 48954; // 0040B5B4
word32 g_dw40B5B8 = 0xBF44; // 0040B5B8
word32 g_dw40B5BC = 48978; // 0040B5BC
word32 g_dw40B5C0 = 48988; // 0040B5C0
word32 g_dw40B5C4 = 48998; // 0040B5C4
word32 g_dw40B5C8 = 49014; // 0040B5C8
word32 g_dw40B5D0 = 49042; // 0040B5D0
word32 g_dw40B5D4 = 0xBFAC; // 0040B5D4
word32 g_dw40B5D8 = 49094; // 0040B5D8
word32 g_dw40B5DC = 49114; // 0040B5DC
word32 g_dw40B5E0 = 0xBFF2; // 0040B5E0
word32 g_dw40B5E4 = 0xC006; // 0040B5E4
word32 g_dw40B5E8 = 0xC01E; // 0040B5E8
word32 g_dw40B5EC = 0xC03C; // 0040B5EC
word32 g_dw40B5F0 = 0xC05E; // 0040B5F0
word32 g_dw40B5F4 = 0xC070; // 0040B5F4
word32 g_dw40B5F8 = 0xC08A; // 0040B5F8
word32 g_dw40B5FC = 0xC0A2; // 0040B5FC
word32 g_dw40B600 = 0xC0B8; // 0040B600
word32 g_dw40B604 = 0xC0D8; // 0040B604
word32 g_dw40B608 = 49394; // 0040B608
word32 g_dw40B60C = 0xC108; // 0040B60C
word32 g_dw40B610 = 49440; // 0040B610
word32 g_dw40B614 = 0xC13C; // 0040B614
word32 g_dw40B618 = 49492; // 0040B618
word32 g_dw40B61C = 49514; // 0040B61C
word32 g_dw40B620 = 49542; // 0040B620
word32 g_dw40B624 = 49558; // 0040B624
word32 g_dw40B628 = 0xC1AA; // 0040B628
word32 g_dw40B62C = 0xC1C8; // 0040B62C
word32 g_dw40B630 = 49640; // 0040B630
word32 g_dw40B634 = 0xC200; // 0040B634
word32 g_dw40B638 = 49684; // 0040B638
word32 g_dw40B63C = 0xC228; // 0040B63C
word32 g_dw40B640 = 49734; // 0040B640
word32 g_dw40B644 = 0xC256; // 0040B644
word32 g_dw40B648 = 49774; // 0040B648
word32 g_dw40B64C = 0xC280; // 0040B64C
word32 g_dw40B650 = 0xC29C; // 0040B650
word32 g_dw40B654 = 0xC2C0; // 0040B654
word32 g_dw40B658 = 0xC2D4; // 0040B658
word32 g_dw40B65C = 0xC2E2; // 0040B65C
word32 g_dw40B660 = 0xC300; // 0040B660
word32 g_dw40B664 = 49942; // 0040B664
word32 g_dw40B668 = 49960; // 0040B668
word32 g_dw40B66C = 49988; // 0040B66C
word32 g_dw40B670 = 50008; // 0040B670
word32 g_dw40B674 = 0xC370; // 0040B674
word32 g_dw40B678 = 50052; // 0040B678
word32 g_dw40B67C = 50086; // 0040B67C
word32 g_dw40B680 = 50106; // 0040B680
word32 g_dw40B684 = 50130; // 0040B684
word32 g_dw40B688 = 0xC3E2; // 0040B688
word32 g_dw40B68C = 50170; // 0040B68C
word32 g_dw40B690 = 50202; // 0040B690
word32 g_dw40B694 = 50230; // 0040B694
word32 g_dw40B698 = 0xC448; // 0040B698
word32 g_dw40B69C = 50266; // 0040B69C
word32 g_dw40B6A0 = 0xC470; // 0040B6A0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040845C: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
l0040845C:
	v4 = (ah & 0x01 << 0x08 - 0x19) != 0x00;
	ah = __rol<byte,byte>(ah, 0x19);
	--bx;
	v9 = (esi & 0x01 << 0x20 - 0x15) != 0x00;
	esi = __rol<word32,byte>(esi, 0x15);
	C = v9;
	--ah;
	v12 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rcl<byte,byte>(dl, cl, C);
	v14 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	ax = ax ^ bx;
	C.u0 = false;
	v19 = (dl & 0x01 << 0x06) != 0x00;
	dl = __rcr<byte,byte>(dl, 0x06, C);
	SZP = cond(bh & 0xA8);
	&SCZO.u4->a0000->u0 = cond(esi - 0x697D9BB8);
	if (Test(EQ,Z))
	{
		&edi.u4->a0000->u0 = (word32) ebp + 0x006A;
l00408480:
		bl = -bl;
		ecx += 2675558986;
		cl = -cl;
		ecx -= eax;
		&bl.u4->a0000->u0 = (byte) bl + 1;
		edx = edx ^ edx;
		edi <<= 0x19;
		SZP = cond(cl & dh);
		&SCZO.u4->a0000->u0 = cond(eax - ~0x2C9BAA70);
		if (Test(NE,Z))
		{
			ecx >>= cl;
			&ecx.u4->a0000->u0 = (word32) ecx - 487242905;
			bl >>= 0x0F;
			SZP = cond(ch & 0x8B);
			bl >>= 0x08;
			cl <<= cl;
			bl = bl ^ 0xCC;
			di += cx;
			&SCZO.u4->a0000->u0 = cond(di);
			bl = bl - al - C;
			&SCZO.u4->a0000->u0 = cond(bl);
			v153 = (bx & 0x01 << cl) != 0x00;
			bx = __ror<word16,byte>(bx, cl);
			C = v153;
			gs = ax;
			v155 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rcl<byte,byte>(bh, cl, C);
			bl <<= cl;
			esi <<= cl;
			SZP = cond(ecx & edi);
			C.u0 = false;
			ch = ch + cl + C;
			ebx |= esi;
			edi = edi ^ ebx;
			C.u0 = false;
			v156 = (bl & 0x01 << cl) != 0x00;
			bl = __rcr<byte,byte>(bl, cl, C);
			di &= si;
			ch <<= cl;
			ch >>= cl;
			&SCZO.u4->a0000->u0 = cond(ch);
			goto l004081CE;
		}
		ebp.u0 = 2018271613;
		v30 = (*edx.u5 & 0x01 << ~0x04) != 0x00;
		*edx.u5 = __ror<byte,byte>(*edx.u5, ~0x04);
		C = v30;
l004084A8:
		edx <<= 0x14;
		SZP = cond(ecx & 4013301962);
		C.u0 = false;
		v32 = (edx & 0x01 << cl) != 0x00;
		edx = __rcr<word32,byte>(edx, cl, C);
		v33 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rol<byte,byte>(bl, cl);
		C = v33;
		v34 = (dx & 0x01 << cl) != 0x00;
		dx = __rcr<word16,byte>(dx, cl, C);
		&SCZO.u4->a0000->u0 = cond(eax - 616654900);
		if (Test(EQ,Z))
		{
			al = __in<byte>(dx);
			Top->r0000 /= Top->r0001;
			bh.u0 = 0x1E;
			if (Test(NE,Z))
				;
			v40 = Mem0[esi + 0x00:byte] + bl;
			*esi.u5 = v40;
			&SCZO.u4->a0000->u0 = cond(v40);
			if (Test(ULE,CZ))
			{
l00408459:
				edi = edi ^ (ecx.u4)->dwFFFFFFDA;
				SZ = cond(edi);
				O = false;
				C.u0 = false;
				goto l0040845C;
			}
			goto l004083DF;
		}
		edx <<= cl;
		v42 = (ebx & 0x01 << 0x07) != 0x00;
		ebx = __ror<word32,byte>(ebx, 0x07);
		eax = esi;
		ecx += esi;
		&SCZO.u4->a0000->u0 = cond(ecx);
		v43 = (cx & 0x01 << 0x10 - cl) != 0x00;
		cx = __rcl<word16,byte>(cx, cl, C);
		bl >>= cl;
		&SCZO.u4->a0000->u0 = cond(esi - 996899550);
		if (Test(EQ,Z))
		{
			ebp.u0 = 2800870245;
			goto l004080C7;
		}
		&edx.u4->a0000->u0 = (word32) edx + 0x509E86E1;
		&SCZO.u4->a0000->u0 = cond(edx);
		ch = ch - dh - C;
		eax >>= 0x02;
		SCZ = cond(eax);
		al = al - bh - C;
		dh >>= 0x18;
		edx <<= cl;
		&SCZO.u4->a0000->u0 = cond(edx);
		&ah.u4->a0000->u0 = (bool) C.u0 + ((byte) ah + 0x00BE);
		&SCZO.u4->a0000->u0 = cond(ah);
		v125 = (edi & 0x01 << cl) != 0x00;
		edi = __rcr<word32,byte>(edi, cl, C);
		C = v125;
		cl = cl + ch + C;
		edx = edx ^ eax;
		--dh;
		SZO = cond(dh);
		v126 = (ecx & 0x01 << 0x20 - cl) != 0x00;
		ecx = __rol<word32,byte>(ecx, cl);
		C = v126;
		&cl.u4->a0000->u0 = (byte) cl + 0x00EA;
		al <<= 22;
		v129 = (dl & 0x01 << 22) != 0x00;
		dl = __ror<byte,byte>(dl, 22);
		C = v129;
		di = ~di;
		v130 = (ah & 0x01 << 0x08 - cl) != 0x00;
		ah = __rcl<byte,byte>(ah, cl, C);
		ch.u0 = 0x68;
		SZP = cond(ax & cx);
		&ah.u4->a0000->u0 = (byte) ah + 0x00D1;
		ah <<= cl;
		&SCZO.u4->a0000->u0 = cond(ebx - 0x6B942F5F);
		if (Test(NE,Z))
		{
			v138 = (eax & 0x01 << 0x01) != 0x00;
			eax = __rcr<word32,byte>(eax, 0x01, C);
			cl = -cl;
			SZP = cond(cl & 244);
			C.u0 = false;
			v139 = (ch & 0x01 << 0x08 - 0x07) != 0x00;
			ch = __rcl<byte,byte>(ch, 0x07, C);
			&ah.u4->a0000->u0 = (byte) ah + 0x00BD;
			cx <<= cl;
			&SCZO.u4->a0000->u0 = cond(cx);
			cx = ~cx;
			v140 = (ecx & 0x01 << cl) != 0x00;
			ecx = __rcr<word32,byte>(ecx, cl, C);
			v141 = (dl & 0x01 << 0x08 - cl) != 0x00;
			dl = __rol<byte,byte>(dl, cl);
			v142 = (al & 0x01 << 0x1A) != 0x00;
			al = __ror<byte,byte>(al, 0x1A);
			al >>= 0x10;
			ax >>= cl;
			SCZ = cond(ax);
			dh = dh + bh + C;
			v143 = (eax & 0x01 << 0x20 - 0x10) != 0x00;
			eax = __rol<word32,byte>(eax, 0x10);
			C = v143;
			&dh.u4->a0000->u0 = (bool) C.u0 + ((byte) dh + 0x00E7);
			ax -= si;
			--ch;
			al <<= 0x0D;
			&SCZO.u4->a0000->u0 = cond(al);
			ah = ah - ~0x01 - C;
			&SCZO.u4->a0000->u0 = cond(ah);
			bl = bl - dl - C;
			&SCZO.u4->a0000->u0 = cond(bl);
			v146 = (ax & 0x01 << cl) != 0x00;
			ax = __rcr<word16,byte>(ax, cl, C);
			C = v146;
			v147 = (eax & 0x01 << 0x20 - cl) != 0x00;
			eax = __rcl<word32,byte>(eax, cl, C);
			cx >>= cl;
			&SCZO.u4->a0000->u0 = cond(cx);
			bx = bx - cx - C;
			v148 = (ecx & 0x01 << cl) != 0x00;
			ecx = __ror<word32,byte>(ecx, cl);
			C = v148;
			dx = ~dx;
			v149 = (esi & 0x01 << 0x13) != 0x00;
			esi = __rcr<word32,byte>(esi, 0x13, C);
			eax = fs->t0030;
			&ch.u4->a0000->u0 = (byte) ch.u0 + 1;
			v151 = (dx & 0x01 << 0x10 - cl) != 0x00;
			dx = __rol<word16,byte>(dx, cl);
			edi <<= cl;
			v152 = (bh & 0x01 << cl) != 0x00;
			bh = __ror<byte,byte>(bh, cl);
			&SCZO.u4->a0000->u0 = cond(ebx - 3169122973);
			if (Test(EQ,Z))
			{
				--ebp;
				&SCZO.u4->a0000->u0 = cond(eax - 0xCC640811);
				goto l0040807F;
			}
			bl <<= 0x01;
			dl <<= 0x13;
			bh >>= 0x08;
			v154 = (dx & 0x01 << 0x10 - cl) != 0x00;
			dx = __rol<word16,byte>(dx, cl);
			ch <<= 0x0E;
			ecx.u0 = 1783088376;
			si <<= cl;
			bl >>= 0x1B;
			bl -= al;
			&SCZO.u4->a0000->u0 = cond(bl);
l004083DF:
			&eax.u4->a0000->u0 = eax.u4->t0090.u4;
			ch = ch + cl + C;
			&SCZO.u4->a0000->u0 = cond(ch);
			v66 = (bh & 0x01 << 0x05) != 0x00;
			bh = __rcr<byte,byte>(bh, 0x05, C);
			ebx.u0 = ~0x0EC4D6B0;
			ch -= dh;
			edx >>= 0x08;
			dh |= 0xA5;
			SZ = cond(dh);
			O = false;
			C.u0 = false;
			v67 = (esi & 0x01 << cl) != 0x00;
			esi = __rcr<word32,byte>(esi, cl, C);
			C = v67;
			esi >>= 0x10;
			&SCZO.u4->a0000->u0 = cond(esi);
l004082D8:
			&eax.u4->a0000->u0 = eax.u4->a0000[0].u4;
			&ch.u4->a0000->u0 = (byte) ch + 141;
			ecx |= 511771642;
			C.u0 = false;
			edx = edx - 3243926448 - C;
			edx >>= cl;
			&SCZO.u4->a0000->u0 = cond(edx);
			ecx = ecx + ebx + C;
			ecx >>= 0x15;
			esi.u0 = 4004078971;
			&SCZO.u4->a0000->u0 = cond(ebx - 2736610706);
			if (Test(EQ,Z))
			{
				--ebx;
				dl = dl - *((byte) ebx.u0 + (ecx * 0x08 - 0x7FF5153F)) - C;
				&SCZO.u4->a0000->u0 = cond(dl);
				goto l00408308;
			}
l004080C7:
			v46 = (esi & 0x01 << 0x1E) != 0x00;
			esi = __ror<word32,byte>(esi, 0x1E);
			ecx <<= 0x04;
			&SCZO.u4->a0000->u0 = cond(ecx);
			dx = dx - di - C;
			&eax.u4->a0000->u0 = eax.u4->t0008.u4;
			cl <<= 0x07;
			ecx = ecx ^ eax;
			edi -= esi;
			v48 = (dh & 0x01 << 0x08 - 11) != 0x00;
			dh = __rol<byte,byte>(dh, 11);
			v49 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rol<byte,byte>(bh, cl);
			SZP = cond(edx & 0x63F4D970);
			C.u0 = false;
			edx = edx - edi - C;
			bh -= ah;
			&SCZO.u4->a0000->u0 = cond(eax - 3080075478);
			if (Test(EQ,Z))
			{
				esi |= *((char *) edx.u5 + edi * 0x04);
				C.u0 = false;
				v50 = (cl & 0x01 << cl) != 0x00;
				cl = __rcr<byte,byte>(cl, cl, C);
				C = v50;
				esi = esi + ecx + C;
				ch >>= cl;
				cl &= ah;
				C.u0 = false;
				bh = bh + al + C;
				&SCZO.u4->a0000->u0 = cond(bh);
				bl.u0 = 0xC5;
				&bl.u4->a0000->u0 = (byte) bl.u0 + 1;
				v52 = (ebx & 0x01 << 0x0A) != 0x00;
				ebx = __rcr<word32,byte>(ebx, 0x0A, C);
				C = v52;
				cl = bl;
				v53 = (bx & 0x01 << 0x10 - cl) != 0x00;
				bx = __rcl<word16,byte>(bx, cl, C);
				ebx <<= 0x03;
				&SCZO.u4->a0000->u0 = cond(ebx);
				esi = esi + ~0x4886C8AA + C;
				&SCZO.u4->a0000->u0 = cond(esi);
				fn004093AC();
				goto l004086FD;
			}
			si <<= cl;
			&SCZO.u4->a0000->u0 = cond(si);
l00408343:
			&esi.u4->a0000->u0 = (word32) esi + 23877251;
			ch &= bh;
			bh = ~bh;
			edi &= 0x1196AF5C;
			--ch;
			eax &= ~0x11111111;
			di <<= cl;
			SZP = cond(bl & ~0x70);
			bl &= ~0x45;
			SZ = cond(bl);
			O = false;
			C.u0 = false;
			bh <<= 0x03;
			edx = -edx;
			edx = edx ^ 1311722578;
			C.u0 = false;
			v68 = (edi & 0x01 << cl) != 0x00;
			edi = __rcr<word32,byte>(edi, cl, C);
			v69 = (edx & 0x01 << 0x20 - 0x10) != 0x00;
			edx = __rol<word32,byte>(edx, 0x10);
			edx = ~edx;
			ecx += ~0x46C64835;
			&SCZO.u4->a0000->u0 = cond(ecx);
			&bh.u4->a0000->u0 = (byte) bh.u0 + 1;
			&dh.u4->a0000->u0 = (bool) C.u0 + ((byte) dh + 211);
			&SCZO.u4->a0000->u0 = cond(dh);
			eax -= ~0x11111111;
			&SCZO.u4->a0000->u0 = cond(eax);
l00408610:
			cx = cx + ax + C;
			&bl.u4->a0000->u0 = (byte) bl + 1;
			cl <<= cl;
			dl <<= 0x1B;
			cl >>= cl;
			SCZ = cond(cl);
			edx = edx + 0x432B1730 + C;
			--bl;
			dh = ah;
			&SCZO.u4->a0000->u0 = cond(edi - (struct Eq_1809 *) 1044060412);
			if (Test(EQ,Z))
			{
				FPUF.u0 = cond(Top->r0000 - Top->r0000);
				Top = (struct Eq_5 *) &Top->r0000;
				al |= 0x22;
				SZ = cond(al);
				O = false;
				C.u0 = false;
				fn1BE1_D2FC();
l00408646:
				do
				{
					Top->r0000 *= (real64) edx.u4->wD2F88AE8;
					--ecx;
				} while (Test(EQ,Z) && ecx != 0x00);
				ebx.u0->u0 = 3534052124;
				SCZO = *esp.u5;
				&esp.u4->a0000->u0 = (word32) esp + 4;
				return;
			}
			eax |= eax;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
			{
				eax |= eax;
				SZ = cond(eax);
				O = false;
				C.u0 = false;
				if (Test(NE,Z))
					return;
			}
			ebx <<= cl;
			ebx >>= 0x07;
			&SCZO.u4->a0000->u0 = cond(ebx);
			bl >>= 0x1E;
			v90 = (cl & 0x01 << cl) != 0x00;
			cl = __ror<byte,byte>(cl, cl);
			bh |= 0x92;
			C.u0 = false;
			v91 = (edi & 0x01 << 0x03) != 0x00;
			edi = __rcr<word32,byte>(edi, 0x03, C);
			v92 = (ecx & 0x01 << 0x18) != 0x00;
			ecx = __ror<word32,byte>(ecx, 0x18);
			edx <<= 0x0D;
			&SCZO.u4->a0000->u0 = cond(edx);
			ch = ch - ah - C;
			&SCZO.u4->a0000->u0 = cond(ch);
			&dx.u4->a0000->u0 = (word16) dx + 1;
			SZO = cond(dx);
			v93 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v93;
			SZP = cond(ecx & esi);
			ch = ch ^ al;
			edx = edx ^ edx;
			ebx -= 3450530236;
			&cl.u4->a0000->u0 = (byte) cl + 1;
			bl >>= 0x12;
			bl = -bl;
			si &= ax;
			esi |= eax;
			ch <<= cl;
			bl.u0 = ~0x01;
			&SCZO.u4->a0000->u0 = cond(edi - (struct Eq_1276 *) 3810952033);
			if (Test(EQ,Z))
			{
				(*ebx.u0)();
				return;
			}
			__syscall<byte>(0x2E);
			ecx += 1165940267;
			C = cl != 0x00;
			cl = -cl;
			ebx = ebx - 0xF4A22DE0 - C;
			cl >>= cl;
			&SCZO.u4->a0000->u0 = cond(cl);
			v97 = (ebx & 0x01 << 0x03) != 0x00;
			ebx = __rcr<word32,byte>(ebx, 0x03, C);
			C = v97;
			v98 = (ch & 0x01 << 0x0F) != 0x00;
			ch = __rcr<byte,byte>(ch, 0x0F, C);
			&SCZO.u4->a0000->u0 = cond(edi - (struct Eq_1385 *) 2709102275);
			if (Test(EQ,Z))
			{
				*edi.u5 = al;
				++edi;
				&cl.u4->a0000->u0 = (bool) C.u0 + ((byte) cl.u0 + ((esi.u4)->tFFFFFFD2).u0);
				&SCZO.u4->a0000->u0 = cond(cl);
l004081CE:
				__ffree(Top->r0000);
				if (ecx != 0x00)
				{
					v99 = (ch & 0x01 << 0x08 - 0x0A) != 0x00;
					ch = __rcl<byte,byte>(ch, 0x0A, C);
					bh >>= cl;
					&SCZO.u4->a0000->u0 = cond(bh);
					v100 = (edi & 0x01 << 0x20 - 0x0E) != 0x00;
					edi = __rcl<word32,byte>(edi, 0x0E, C);
					C = v100;
				}
				else
				{
					esp -= 2;
					*esp.u5 = cs;
				}
				&bl.u4->a0000->u0 = (bool) C.u0 + ((byte) bl.u0 + 0x00CE);
				ebx <<= cl;
				v101 = (edi & 0x01 << cl) != 0x00;
				edi = __ror<word32,byte>(edi, cl);
				bh <<= 0x07;
				&SCZO.u4->a0000->u0 = cond(bh);
				ebx = ebx + ecx + C;
				&SCZO.u4->a0000->u0 = cond(ebx);
				while (true)
				{
					ebx = ebx ^ ecx;
					ecx <<= 0x1B;
					&SCZO.u4->a0000->u0 = cond(ecx);
					bl = bl + ah + C;
					bh += dl;
					&SCZO.u4->a0000->u0 = cond(bh);
					&cx.u4->a0000->u0 = (word16) cx + 1;
					ch = ch + cl + C;
					edi <<= 0x18;
					bx -= di;
					ecx <<= 0x1A;
					&SCZO.u4->a0000->u0 = cond(ecx);
					bl = bl - 0xC4 - C;
					cx = cx ^ ax;
					&SCZO.u4->a0000->u0 = cond(esi - 2748614458);
					if (Test(EQ,Z))
						break;
					++edi;
					v105 = (bh & 0x01 << cl) != 0x00;
					bh = __ror<byte,byte>(bh, cl);
					esi >>= 0x07;
					eax = gs;
					v107 = (cl & 0x01 << 0x08 - 0x11) != 0x00;
					cl = __rol<byte,byte>(cl, 0x11);
					ch >>= cl;
					ecx += 2421797612;
					cl >>= 0x1D;
					SZP = cond(edi & 3136646873);
					cl &= bh;
					O = false;
					cl >>= 0x1C;
					SCZ = cond(cl);
					SZP = cond(di & dx);
					ebx += 2732554444;
					ebx |= 0x02105257;
					cl |= 252;
					C.u0 = false;
					bh = bh - ch - C;
					esi &= eax;
					C.u0 = false;
					v111 = (ebx & 0x01 << 0x20 - 0x13) != 0x00;
					ebx = __rcl<word32,byte>(ebx, 0x13, C);
					&SCZO.u4->a0000->u0 = cond(esi - 1581112374);
					if (Test(EQ,Z))
					{
						esp -= 2;
						*esp.u5 = ds;
						if (Test(ULE,CZ))
							goto l00408459;
						goto l004083DF;
					}
					cl |= 0x04;
					bh <<= 0x09;
					di <<= cl;
					&SCZO.u4->a0000->u0 = cond(di);
					bx = bx - dx - C;
					bx -= cx;
					&edx.u4->a0000->u0 = (word32) edx + 1;
					bh <<= 0x15;
					di = ~di;
					ebx &= esi;
					bl |= cl;
					&SCZO.u4->a0000->u0 = cond(edx - 787368874);
					if (Test(EQ,Z))
					{
						es_esp.u1 = ebp.u4->t2DDE4388.u1;
						goto l00408610;
					}
					edi &= 1980398019;
					C.u0 = false;
					edi = edi + 1591033769 + C;
					v120 = (bh & 0x01 << 0x08 - 0x12) != 0x00;
					bh = __rol<byte,byte>(bh, 0x12);
					edi |= ecx;
					edi <<= 0x1D;
					bh <<= cl;
					di |= dx;
					C.u0 = false;
					bl = bl + al + C;
					&SCZO.u4->a0000->u0 = cond(bl);
					&cl.u4->a0000->u0 = (bool) C.u0 + ((byte) cl + 0x00C9);
					++edi;
					v121 = (cl & 0x01 << 0x04) != 0x00;
					cl = __ror<byte,byte>(cl, 0x04);
					C = v121;
					cl = cl + bl + C;
					&SCZO.u4->a0000->u0 = cond(cl);
					v122 = (cx & 0x01 << cl) != 0x00;
					cx = __rcr<word16,byte>(cx, cl, C);
					&SCZO.u4->a0000->u0 = cond(edx - ~0x2D660296);
					if (Test(NE,Z))
					{
						ecx = ecx + 1745115822 + C;
						bl -= ch;
						&SCZO.u4->a0000->u0 = cond(edx - (struct Eq_1925 *) 20070272);
						if (Test(NE,Z))
							goto l00408646;
						dl = bh;
						dl <<= cl;
						ch += cl;
						edi = esi;
						ebx += esi;
						&SCZO.u4->a0000->u0 = cond(ebx);
						ah = -ah;
						&dl.u4->a0000->u0 = (byte) dl + 1;
						v144 = (edi & 0x01 << cl) != 0x00;
						edi = __ror<word32,byte>(edi, cl);
						dl &= bl;
						eax >>= 0x0D;
						&SCZO.u4->a0000->u0 = cond(eax);
						eax = eax + 0xF034809E + C;
						&SCZO.u4->a0000->u0 = cond(eax);
						v145 = (esi & 0x01 << 0x20 - 0x1C) != 0x00;
						esi = __rcl<word32,byte>(esi, 0x1C, C);
						C = v145;
						return;
					}
					al = *(union Eq_3 *) 332885692;
				}
				ss = *esp.u5;
				&esp.u4->a0000->u0 = (word32) esp + 2;
				cl = cl ^ (edi.u4)->bF981C34B;
				SZ = cond(cl);
				O = false;
				C.u0 = false;
l004082A3:
				C.u0 = false;
				v84 = (cl & 0x01 << 0x08 - 0x13) != 0x00;
				cl = __rcl<byte,byte>(cl, 0x13, C);
				C = v84;
				cl = al;
				v85 = (dl & 0x01 << cl) != 0x00;
				dl = __rcr<byte,byte>(dl, cl, C);
				ax += di;
				bx -= cx;
				eax <<= cl;
				&SCZO.u4->a0000->u0 = cond(eax);
				v86 = (eax & 0x01 << cl) != 0x00;
				eax = __rcr<word32,byte>(eax, cl, C);
				SZP = cond(eax & 3700546033);
				di = -di;
				cx = bx;
				&SCZO.u4->a0000->u0 = cond(edx - 532064337);
				if (Test(EQ,Z))
				{
					v87 = *esi.u5;
					*edi.u5 = v87;
					&esi.u4->a0000->u0 = (word32) esi + 1;
					++edi;
					&SCZO.u4->a0000->u0 = cond(al - 0xC1);
					goto l004082D8;
				}
				--ah;
				v88 = (eax & 0x01 << 0x20 - 0x1C) != 0x00;
				eax = __rol<word32,byte>(eax, 0x1C);
				C = v88;
				v89 = (cl & 0x01 << 0x1B) != 0x00;
				cl = __rcr<byte,byte>(cl, 0x1B, C);
				ch &= al;
				edi = edi ^ esi;
				ah >>= 0x0E;
				al |= bl;
				ax = ~ax;
				&cl.u4->a0000->u0 = (byte) cl.u0 + 1;
				SZP = cond(ch & 0x00);
				ch >>= 0x1B;
				&SCZO.u4->a0000->u0 = cond(ch);
				goto l004084A8;
			}
			si <<= cl;
			ch += dl;
			v102 = (ebx & 0x01 << cl) != 0x00;
			ebx = __ror<word32,byte>(ebx, cl);
			ebx += ~0x3591B111;
			ecx >>= 0x0D;
			&SCZO.u4->a0000->u0 = cond(edx - ~0x00);
			if (Test(NE,Z))
			{
				&SCZO.u4->a0000->u0 = cond(edx - 299338464);
				if (Test(EQ,Z))
				{
					ebp = ebp - 61309259 - C;
					&SCZO.u4->a0000->u0 = cond(ebp);
					goto l0040801E;
				}
				al.u0 = edx.u4->tFFFFFFFF.u0;
			}
			else
				al.u0 = 0x2E;
			&SCZO.u4->a0000->u0 = cond(eax - 0xC000002E);
			if (Test(NE,Z))
			{
				ah = ah ^ dl;
				ebx <<= 0x06;
				&SCZO.u4->a0000->u0 = cond(ebx);
				v108 = (di & 0x01 << cl) != 0x00;
				di = __rcr<word16,byte>(di, cl, C);
				C = v108;
				di = ~di;
				edi -= (struct Eq_1641 *) 0x01;
				SZO = cond(edi);
				v109 = (esi & 0x01 << 0x20 - cl) != 0x00;
				esi = __rcl<word32,byte>(esi, cl, C);
				ah >>= 0x06;
				SCZ = cond(ah);
				v110 = (bh & 0x01 << cl) != 0x00;
				bh = __rcr<byte,byte>(bh, cl, C);
				C = v110;
l0040801E:
				v103 = (edx & 0x01 << 11) != 0x00;
				edx = __ror<word32,byte>(edx, 11);
				C = v103;
				return;
			}
			v112 = (al & 0x01 << 0x08 - 0x18) != 0x00;
			al = __rcl<byte,byte>(al, 0x18, C);
			dx >>= cl;
			SCZ = cond(dx);
			dh = dh + cl + C;
			ch >>= cl;
			C = ch != 0x00;
			ch = -ch;
			SZO = cond(ch);
			v114 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			dh = dh ^ 0x01;
			C.u0 = false;
			v115 = (dh & 0x01 << 0x14) != 0x00;
			dh = __rcr<byte,byte>(dh, 0x14, C);
			dl |= 0x86;
			SZP = cond(ch & ~0x60);
			dl.u0 = 0x04;
			&SCZO.u4->a0000->u0 = cond(ebx - 3976733199);
			if (Test(EQ,Z))
			{
				v116 = *esi.u5;
				C = v116 != 0x00;
				v117 = -v116;
				*esi.u5 = v117;
				SZO = cond(v117);
				esp -= 2;
				*esp.u5 = ss;
				eax = __in<word32>(232);
l004086FD:
				ah = SCZOP;
				__out<byte>(dx, al);
				if (Test(UGT,CZ))
				{
l0040876D:
					esp -= 4;
					*esp.u5 = esi;
					--ecx;
					if (Test(NE,Z) || ecx == 0x00)
					{
						v70 = ebp.u4->b0074 << cl;
						ebp.u4->b0074 = v70;
						&SCZO.u4->a0000->u0 = cond(v70);
						__lock();
						esp -= 4;
						*esp.u5 = eax;
						esp -= 4;
						*esp.u5 = eax;
						if (Test(UGT,CZ))
						{
							SZP = cond(eax.u4->t0035.u0 & dh);
							O = false;
							C.u0 = false;
							v71 = ecx;
							ecx = eax;
							eax = v71;
							if (Test(NS,S))
							{
								cl.u0 = 0x0A;
								if (Test(NO,O))
								{
									++eax;
									edx = eax.u4->dwFFFFFFE2 *s ~0x0D;
									&SCZO.u4->a0000->u0 = cond(edx);
									fn611D_C117();
									return;
								}
l004087EA:
								if (Test(EQ,Z))
								{
									esp -= 4;
									*esp.u5 = ecx;
									esp -= 4;
									*esp.u5 = eax;
									esp -= 4;
									*esp.u5 = eax;
									al = *((byte) ebx.u0 + (uint32) al);
									v79 = (bh & 0x01 << 0x08 - 225) != 0x00;
									bh = __rcl<byte,byte>(bh, 225, C);
									C = v79;
								}
							}
							else
							{
								while (true)
								{
									esp -= 4;
									*esp.u5 = eax;
									al.u0 = 0x56;
									if (Test(NS,S))
										break;
									v94 = (eax.u4->tFFFFFFE6.u0 & 0x01 << 0x08 - 0x01) != 0x00;
									eax.u4->tFFFFFFE6.u0 = (int8) __rcl<byte,byte>(eax.u4->tFFFFFFE6.u0, 0x01, C);
									ebp &= edx;
									al &= bl;
									SZ = cond(al);
									O = false;
									C.u0 = false;
									esp -= 4;
									*esp.u5 = edx;
									al.u0 = 226;
									esp -= 4;
									*esp.u5 = ecx;
									--ecx;
									if (Test(NE,Z) || ecx == 0x00)
									{
										esp -= 4;
										*esp.u5 = ebx;
										&esi.u4->a0000->u0 = (word32) esi + 1;
										SZO = cond(esi);
										goto l004087EA;
									}
									&SCZO.u4->a0000->u0 = cond(eax - *edi.u5);
									edi += 4;
									&esi.u4->a0000->u0 = (byte) esi.u0 + 1;
									SZO = cond(esi);
									esp -= 4;
									*esp.u5 = ebp;
									eax = *esp.u5;
									&esp.u4->a0000->u0 = (word32) esp + 4;
									cl.u0 = 0x50;
								}
							}
						}
						__fsave(eax.u4->w4B55D4E2);
						v95 = eax.u4->t0050.u0 ^ dl;
						eax.u4->t0050.u0 = (int8) v95;
						SZ = cond(eax.u4->t0050.u0);
						edi &= esp;
						esp -= 4;
						*esp.u5 = edi;
						v96 = *edi.u5 ^ ah;
						*edi.u5 = v96;
						SZ = cond(*edi.u5);
						O = false;
						C.u0 = false;
						return;
					}
					goto l00408758;
				}
				else
				{
					eax &= edi;
					Top->r0000 /= (real64) eax.u4->dwFFFFFF87;
					v55 = *((byte) ebx.u0 - 0x03CDADD3) & esi;
					&((byte) ebx.u0 - 0x03CDADD3)->u4->a0000->u0 = v55;
					SZ = cond(*((byte) ebx.u0 - 0x03CDADD3));
					O = false;
					C.u0 = false;
					if (Test(EQ,Z))
					{
						v56 = ecx;
						eax = v56;
						esp -= 4;
						*esp.u5 = eax;
						esp -= 4;
						*esp.u5 = eax;
						Top->r0000 = __fprem_x87(Top->r0000, Top->r0001);
						C2 = __fprem_incomplete(Top->r0000);
						edi = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						esi = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						ebp = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						ebx = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						edx = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						ecx = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						eax = *esp.u5;
						&esp.u4->a0000->u0 = (word32) esp + 4;
						esp -= 4;
						*esp.u5 = esi;
						eax = __in<word32>(0x4F);
						v58 = eax.u4->a0000[0].u0 & bh;
						eax.u4->a0000[0].u0 = (int8) v58;
						SZ = cond(eax.u4->a0000[0].u0);
						v59 = *ecx.u5 << 0x01;
						*ecx.u5 = v59;
						esp -= 2;
						*esp.u5 = es;
						v61 = *ecx.u5 << 0x01;
						*ecx.u5 = v61;
						&SCZO.u4->a0000->u0 = cond(v61);
						esp -= 2;
						*esp.u5 = cs;
						do
							;
						while (Test(NE,Z));
						v63 = Mem0[eax + 80:byte] + dl + C;
						eax.u4->t0050.u0 = (int8) v63;
						v64 = *ecx.u5 & ecx;
						*ecx.u5 = v64;
						SZ = cond(*ecx.u5);
						--edx;
						bl -= eax.u4->t0035.u0;
						&SCZO.u4->a0000->u0 = cond(bl);
						esp -= 4;
						*esp.u5 = ecx;
						if (Test(SG,S))
						{
							eax = eax - 2922916705 - C;
							&SCZO.u4->a0000->u0 = cond(eax);
						}
						cl.u0 = 0x0A;
						if (Test(NO,O))
						{
							if (Test(NS,S))
							{
								SZP = cond(eax.u4->a0000[0].u4 & esp);
								O = false;
								C.u0 = false;
								goto l00408739;
							}
							ebp = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							v72 = ecx.u4->dwFFFFFFF6 << 0x01;
							ecx.u4->dwFFFFFFF6 = v72;
							&SCZO.u4->a0000->u0 = cond(v72);
							if (Test(NS,S))
							{
l00408759:
								eax = __in<word32>(dx);
								edi += 4;
								goto l0040875A;
							}
							++esi;
							SZO = cond(esi);
							--ecx;
							if (Test(EQ,Z) && ecx != 0x00)
							{
l00408739:
								edx = eax.u4->dwFFFFFFE2 *s 0x12;
								&SCZO.u4->a0000->u0 = cond(edx);
								fn611D_C117();
								return;
							}
							v73 = (esi.u4->t0005.u0 & 0x01 << 0x08 - cl) != 0x00;
							esi.u4->t0005.u0 = (int8) __rol<byte,byte>(esi.u4->t0005.u0, cl);
							esp -= 4;
							*esp.u5 = eax;
							eax += 0x6D564550;
							&SCZO.u4->a0000->u0 = cond(eax);
l0040875A:
							ds = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 2;
							al |= 0x55;
							esp -= 2;
							*esp.u5 = ds;
							v80 = ecx;
							eax = v80;
							esp -= 4;
							*esp.u5 = eax;
							esp -= 4;
							*esp.u5 = eax;
							&ebp.u4->a0000->u0 = (word32) ebp + 1;
							v81 = edx;
							edi = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							esi = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							ebp = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							ebx = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							edx = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							ecx = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							eax = *esp.u5;
							&esp.u4->a0000->u0 = (word32) esp + 4;
							v83 = edx_eax;
							&edx.u4->a0000->u0 = (uint32) (v83 % (edx.u4)->dw0046);
							&eax.u4->a0000->u0 = (uint32) (v83 /u (edx.u4)->dw0046);
							esp -= 4;
							*esp.u5 = ebp;
							eax -= 0xB0505051;
							&SCZO.u4->a0000->u0 = cond(eax);
							goto l0040876D;
						}
						esp -= 4;
						*esp.u5 = eax;
						&ebp.u4->a0000->u0 = (byte) ebp.u0 + 1;
						SZO = cond(ebp);
					}
l00408758:
					esp -= 4;
					*esp.u5 = esi;
					goto l00408759;
				}
			}
			v118 = (edx & 0x01 << 0x20 - 0x1E) != 0x00;
			edx = __rol<word32,byte>(edx, 0x1E);
			dl >>= cl;
			SCZ = cond(dl);
			bl = bl + dl + C;
			&SCZO.u4->a0000->u0 = cond(bl);
			eax = eax - 0xC5C02C8A - C;
			dx |= di;
			ebx &= 248352561;
			&di.u4->a0000->u0 = (word16) di.u3 + 1;
			cl <<= 0x04;
			cl <<= 0x0E;
			v119 = (eax & 0x01 << 0x20 - 0x04) != 0x00;
			eax = __rol<word32,byte>(eax, 0x04);
			C = v119;
			&dl.u4->a0000->u0 = (byte) dl.u0 + 1;
			SZO = cond(dl);
			cx = cx + dx + C;
			C = edi != 0x00;
			edi = -edi;
			v123 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rcl<byte,byte>(ah, cl, C);
			eax.u0 = 0x03;
			dh -= bl;
			ch.u0 = ~0x4C;
			bl >>= 0x02;
			SCZ = cond(bl);
			v124 = (bl & 0x01 << 0x08 - 0x01) != 0x00;
			bl = __rcl<byte,byte>(bl, 0x01, C);
			edi <<= 0x06;
			ch <<= cl;
			&SCZO.u4->a0000->u0 = cond(ch);
l0040807F:
			bl <<= cl;
			edx = edx ^ edi;
			cx >>= cl;
			edx >>= cl;
			bl = bl ^ ~0x28;
			edi >>= 0x15;
			dl |= dh;
			di -= cx;
			&SCZO.u4->a0000->u0 = cond(edi - (struct Eq_1967 *) 0xD9807583);
			if (Test(EQ,Z))
			{
				SZP = cond(al & bh);
				O = false;
				C.u0 = false;
				fnCBC1_F2D3();
				return;
			}
			goto l00408480;
		}
		v131 = *edi.u5 - eax;
		*edi.u5 = v131;
		&SCZO.u4->a0000->u0 = cond(v131);
		ebp.u0 = 3556053654;
	}
	else
	{
		&edx.u4->a0000->u0 = (word32) edx + 2025662225;
		&SCZO.u4->a0000->u0 = cond(edx);
		esi = eax;
		ax = ax - si - C;
		SZP = cond(edi & 496124695);
		--bl;
		bx = ax;
		cl = -cl;
		&SCZO.u4->a0000->u0 = cond(ebx - 0x4A46E643);
		if (Test(EQ,Z))
		{
			v39 = esp;
			esp -= 4;
			*esp.u5 = v39;
			return;
		}
		dh = dh + ch + C;
		edx <<= cl;
		&SCZO.u4->a0000->u0 = cond(edx);
	}
	++ecx;
	ax = ~ax;
	ebx = edi;
	ebx = ebx ^ 0x07D80061;
	bl <<= cl;
	dh >>= 0x12;
	SZP = cond(ecx & 313585323);
	v127 = (di & 0x01 << 0x10 - cl) != 0x00;
	di = __rol<word16,byte>(di, cl);
	C = v127;
	v128 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	C = cx != 0x00;
	cx = -cx;
	SZO = cond(cx);
	dh = dh + bh + C;
	&SCZO.u4->a0000->u0 = cond(dh);
	v132 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rcl<byte,byte>(ah, cl, C);
	C = v132;
	ebx = ebx - eax - C;
	&SCZO.u4->a0000->u0 = cond(ebx);
	v133 = (bx & 0x01 << cl) != 0x00;
	bx = __rcr<word16,byte>(bx, cl, C);
	edi -= (struct Eq_2030 *) 0xF22EC7A0;
	al = -al;
	eax |= ~0x073808A8;
	ecx -= 952028220;
	&SCZO.u4->a0000->u0 = cond(ecx);
	ch <<= cl;
	--bh;
	v134 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	bl = cl;
	di += ax;
	&SCZO.u4->a0000->u0 = cond(di);
	v135 = (ch & 0x01 << cl) != 0x00;
	ch = __ror<byte,byte>(ch, cl);
	C = v135;
	v136 = (eax & 0x01 << 22) != 0x00;
	eax = __rcr<word32,byte>(eax, 22, C);
	C = v136;
	v137 = (cx & 0x01 << 0x10 - cl) != 0x00;
	cx = __rcl<word16,byte>(cx, cl, C);
	C = v137;
l00408308:
	al = *((byte) eax.u0 - 0x0F3F6039);
	v74 = esi.u4->dwFFFFFFF7 | esp;
	esi.u4->dwFFFFFFF7 = v74;
	SZ = cond(esi.u4->dwFFFFFFF7);
	v75 = esi.u4->bFFFFFFD3 << cl;
	esi.u4->bFFFFFFD3 = v75;
	esp -= 4;
	*esp.u5 = ebp;
	esp -= -15405;
	bl.u0 = 0x06;
	edi = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	esi = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	ebp = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	ebx = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	edx = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	ecx = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	eax = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	ecx = ~ecx;
	SZP = cond(al & dl);
	ebx &= 4141844368;
	v76 = (ecx & 0x01 << cl) != 0x00;
	ecx = __ror<word32,byte>(ecx, cl);
	edi <<= cl;
	&SCZO.u4->a0000->u0 = cond(edi - (struct Eq_2263 *) 197390510);
	if (Test(NE,Z))
	{
		&SCZO.u4->a0000->u0 = cond(ecx - 2632023545);
		goto l004082A3;
	}
	if (Test(OV,O))
		__syscall<byte>(0x04);
	edx = *esp.u5;
	&esp.u4->a0000->u0 = (word32) esp + 4;
	--ah;
	al &= 0x66;
	SZ = cond(al);
	O = false;
	C.u0 = false;
	goto l00408343;
}

// 00409243: define fn00409243
// Called from:
//      fn0040938C
define fn00409243
{
	esp = fp;
	Top = null;
	cl >>= 0x18;
	SCZO = cond(cl);
	bh = 0xC5;
	bx = ~bx;
	&cl.u4->a0000->u0 = C.u5 + ((byte) cl.u2 + dl) /8 0x4B55D4E4;
	&cl.u4->a0000->u0 = cl.u4 + dh /8 2033105907;
	ecx |= 3853313598;
	dh <<= cl;
	SCZO = cond(dh);
	v14 = (bx & 0x01 << 0x10 - cl) != 0x00;
	bx = __rcl<word16,byte>(bx, cl, C);
	SCZO = cond(esi - 1943491641);
	if (Test(NE,Z))
		fn004092FA();
	else
	{
		ebx = *esp;
		++esp;
		--ebp;
		SZO = cond(ebp);
		*Top /= *Top;
		Top = (real64 *) ((char *) Top + 1);
		if (Test(OV,O))
			__syscall<byte>(0x04);
		esp -= 4;
		*esp = ebp;
		al = al - ~0x09 - C;
		SCZO = cond(al);
		fn004092FA();
	}
}

// 004092A8: define fn004092A8
// Called from:
//      fn004093AC
define fn004092A8
{
	esp = fp;
	Top = 0;
	v4 = (ebx & 0x01 << 0x20 - 0x03) != 0x00;
	ebx = __rol<word32,byte>(ebx, 0x03);
	C = v4;
	v7 = (ecx & 0x01 << 0x20 - 0x15) != 0x00;
	ecx = __rcl<word32,byte>(ecx, 0x15, C);
	al = al ^ 222;
	cl |= ah;
	SCZO = cond(ecx - 0xC4975339);
	&ecx.u4->a0000->u0 = (bool) C.u0 + ((word32) ecx + 279900527);
	ch -= 0x4E;
	bx += di;
	ecx -= eax;
	SCZO = cond(ecx);
	fn004092FA();
}

// 004092FA: define fn004092FA
// Called from:
//      fn00409243
//      fn004092A8
define fn004092FA
{
	esp = fp;
	Top = null;
	while (true)
	{
		ch <<= cl;
		dl += dh;
		al = -al;
		ch <<= 0x13;
		dl &= al;
		edx |= 2466989389;
		edx <<= 0x0D;
		ecx -= esi;
		SCZO = cond(ecx);
		++bh;
		v20 = (dx & 0x01 << 0x10 - cl) != 0x00;
		dx = __rol<word16,byte>(dx, cl);
		cl <<= 0x08;
		&edx.u4->a0000->u0 = (word32) edx + 1;
		bh >>= cl;
		SCZ = cond(bh);
		dh = dh - ah - C;
		al -= 0x46;
		v23 = (edx & 0x01 << cl) != 0x00;
		edx = __ror<word32,byte>(edx, cl);
		C = v23;
		v24 = (ecx & 0x01 << 0x20 - 0x1D) != 0x00;
		ecx = __rcl<word32,byte>(ecx, 0x1D, C);
		dl >>= cl;
		SCZO = cond(dl);
		ecx = ecx - 0xC0600C03 - C;
		cl = ~cl;
		SCZO = cond(ebx - 0x804DE83F);
		if (Test(EQ,Z))
			break;
		--Top;
		*Top = (real64) ecx.u4->w792EBBF1;
		esp -= 4;
		*esp = (struct Eq_2723 **) ebp;
		C = cx != 0x00;
		cx = -cx;
		bl = (byte) (C.u5 + (bl + 0x8C) /8 0x4B55D4E4);
		v31 = (ecx & 0x01 << 0x05) != 0x00;
		ecx = __ror<word32,byte>(ecx, 0x05);
		SZP = cond(bh & al);
		ebx &= 481779290;
		ecx += ebx;
		v33 = (al & 0x01 << 0x15) != 0x00;
		al = __ror<byte,byte>(al, 0x15);
		dl >>= cl;
		SCZO = cond(dl);
		v34 = (dh & 0x01 << 0x02) != 0x00;
		dh = __rcr<byte,byte>(dh, 0x02, C);
		C = v34;
		ch = ch + cl + C;
		SCZO = cond(edi - 709450938);
		if (Test(NE,Z))
		{
			v40 = (cl & 0x01 << 0x18) != 0x00;
			cl = __ror<byte,byte>(cl, 0x18);
			ebx = ebx ^ ~0x7E9885C2;
			dh = dh ^ 0x56;
			edx |= ~0x1642B774;
			ecx = ecx ^ ~0x0F8618EE;
			dh.u0 = 0x25;
			v41 = (dl & 0x01 << 0x0F) != 0x00;
			dl = __ror<byte,byte>(dl, 0x0F);
			C = v41;
			&dx.u4->a0000->u0 = C.u5 + ((word16) dx.u3 + di) /16 0x4B55D4E4;
			SCZO = cond(ecx - (struct Eq_2890 *) 1690676679);
			if (Test(NE,Z))
			{
				fn004096D2();
				return;
			}
			__out<byte>(dx, al);
			++esi;
			if (Test(OV,O))
			{
				fn0040948A();
				return;
			}
			else
			{
				fn0040944F();
				return;
			}
		}
		__out<byte>(0x82, al);
		if (Test(OV,O))
			__syscall<byte>(0x04);
		*(struct Eq_2828 **) 0x03C3C1AA = eax;
		v37 = (ecx & 0x01 << 0x20 - 0x15) != 0x00;
		ecx = __rcl<word32,byte>(ecx, 0x15, C);
		al = al ^ 222;
		cl |= ah;
		SCZO = cond(ecx - 0xC4975339);
		ecx = ecx + 279900527 + C;
		ch -= 0x4E;
		bx += di;
		ecx -= eax;
		SCZO = cond(ecx);
	}
	bl = ebp->bFFFFFFCD;
	al.u0 = ebx[(uint32) al].t0000.u0;
	ebx = ebx - 4035820382 - C;
	v29 = (ecx & 0x01 << 0x20 - 0x19) != 0x00;
	ecx = __rol<word32,byte>(ecx, 0x19);
	&dl.u4->a0000->u0 = (byte) dl.u2 + 0x00A4;
	dh -= ~0x08;
	SCZO = cond(dh);
	ecx >>= 0x08;
	SCZ = cond(ecx);
}

// 0040938C: define fn0040938C
// Called from:
//      fn004093AC
define fn0040938C
{
	esp = fp;
	Top = 0;
	esi = esi + ecx + C;
	SCZO = cond(esi);
	v9 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	C = v9;
	--dl;
	bl = (byte) (C.u5 + (bl + dh) /8 0x4B55D4E4);
	SZP = cond(al & bh);
	ebx |= edi;
	si = ax;
	v23 = (ebx & 0x01 << 0x0A) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x0A);
	eax &= 1727419451;
	edx <<= cl;
	SCZO = cond(edx);
	ebx &= 1548714775;
	al = ~al;
	edi -= ~0x0AA9;
	SCZO = cond(edi);
	edx = edx - 1829333934 - C;
	SCZO = cond(edx);
	eax.u0 = 0x6821AA16;
	ch = ch + dl + C;
	cl <<= 0x02;
	ch += 0x10;
	SCZO = cond(ch);
	dl = dl - ~0x15 - C;
	SCZO = cond(dl);
	v27 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	SCZO = cond(edi - 0x780FB85B);
	if (Test(NE,Z))
	{
		++ah;
		v30 = (ecx & 0x01 << 0x0A) != 0x00;
		ecx = __rcr<word32,byte>(ecx, 0x0A, C);
		v31 = (esi & 0x01 << 0x20 - 0x1E) != 0x00;
		esi = __rol<word32,byte>(esi, 0x1E);
		esp -= 4;
		*esp = edi;
		al += bh;
		SZP = cond(dl & ~0x31);
		ch <<= 0x17;
		SCZO = cond(ch);
		&edx.u4->a0000->u0 = C.u5 + ((word32) edx - 461948707) / 0x4B55D4E4;
		v32 = (ax & 0x01 << 0x10 - cl) != 0x00;
		ax = __rol<word16,byte>(ax, cl);
		dl |= cl;
		ax = -ax;
		ecx += eax;
		dx >>= cl;
		SCZO = cond(eax - 4185690549);
		if (Test(NE,Z))
		{
			ecx >>= cl;
			ecx = ecx ^ 562367385;
			C.u0 = false;
			v41 = (si & 0x01 << 0x10 - cl) != 0x00;
			si = __rcl<word16,byte>(si, cl, C);
			C = v41;
			al = (bool) C.u0 + (al + 0x06);
			edi += ~0x0AA9;
			bx = si;
			v42 = (eax & 0x01 << 0x20 - 0x10) != 0x00;
			eax = __rol<word32,byte>(eax, 0x10);
			ebx.u0 = ~0x7249DC25;
			v43 = (eax & 0x01 << 0x17) != 0x00;
			eax = __ror<word32,byte>(eax, 0x17);
			ecx <<= cl;
			SCZO = cond(ecx);
			dx = dx - bx - C;
			SCZO = cond(dx);
			--esi;
			v47 = (ebx & 0x01 << 0x20 - 0x0F) != 0x00;
			ebx = __rcl<word32,byte>(ebx, 0x0F, C);
			esi.u0 = 0x20061B67;
			ebx = ebx ^ 3200224728;
			SZ = cond(ebx);
			O = false;
			C.u0 = false;
			fn00409729();
		}
		else
		{
			ah = bl;
			*(union Eq_3 *) 248627442 = edx;
			fn004096D2();
		}
	}
	else
	{
		C = __das(al, &al);
		__halt();
	}
}

// 004093AC: define fn004093AC
// Called from:
//      Win32CrtStartup
define fn004093AC
{
	esp = fp;
	Top = 0;
	ecx <<= cl;
	SCZO = cond(ecx);
	edx = edx + ecx + C;
	bh = bh ^ bl;
	SZP = cond(edx & edi);
	O = false;
	C.u0 = false;
	v15 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	v17 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rol<word32,byte>(ecx, cl);
	C = v17;
	v18 = (eax & 0x01 << 0x10) != 0x00;
	eax = __rcr<word32,byte>(eax, 0x10, C);
	C = v18;
	fn004093BB();
}

// 004093BB: define fn004093BB
// Called from:
//      fn0040938C
//      fn004093AC
define fn004093BB
{
	ptr32 fp;
	word16 ax;
	word16 bx;
	bool C;
	Top_5 = 0;
	ax_9 = ax - bx - (word16) C;
	SCZO_10 = cond(ax_9);
	C_30 = SLICE(SCZO_10, bool, 1);
	O_31 = SLICE(SCZO_10, bool, 4);
	S_32 = (bool) SCZO_10;
	Z_33 = SLICE(SCZO_10, bool, 2);
	esp_22 = fp - 0x0C;
	fn004094A9();
}

// 0040944F: define fn0040944F
// Called from:
//      fn00409243
//      fn00409729
define fn0040944F
{
}

// 00409484: define fn00409484
// Called from:
//      fn0040938C
define fn00409484
{
	esp = fp;
	Top = 0;
	fn0040948A();
}

// 0040948A: define fn0040948A
// Called from:
//      fn00409243
//      fn004093AC
//      fn00409484
define fn0040948A
{
	esp = fp;
	Top = 0;
}

// 004094A9: define fn004094A9
// Called from:
//      fn004093AC
//      fn004093BB
define fn004094A9
{
	Top_3 = 0;
	ecx_4 = 4232366;
	eax_5 = 0x01;
	fn0040948A();
}

// 004096D2: define fn004096D2
// Called from:
//      fn00409243
//      fn0040938C
define fn004096D2
{
	esp = fp;
	Top = 0;
	v4 = (cl & 0x01 << 0x08 - 0x0E) != 0x00;
	cl = __rcl<byte,byte>(cl, 0x0E, C);
	al += ~0x49;
	ecx >>= cl;
	SCZO = cond(ecx);
	v10 = (ch & 0x01 << 0x08 - 0x07) != 0x00;
	ch = __rcl<byte,byte>(ch, 0x07, C);
	C = v10;
	fn004096DD();
}

// 004096DD: define fn004096DD
// Called from:
//      fn004096D2
//      fn00409729
define fn004096DD
{
	esp = fp;
	Top = 0;
	v4 = (cl & 0x01 << 0x0E) != 0x00;
	cl = __rcr<byte,byte>(cl, 0x0E, C);
	dh >>= 0x14;
	bx = ax;
	dh >>= cl;
	SCZO = cond(dh);
	cx = cx - di - C;
	SCZO = cond(cx);
	v14 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rcl<word32,byte>(edx, cl, C);
	C = v14;
	bx = bx - ax - C;
	ecx <<= 0x07;
	SCZO = cond(ecx);
	fn00409729();
}

// 00409729: define fn00409729
// Called from:
//      fn0040938C
//      fn0040944F
//      fn004096DD
define fn00409729
{
fn00409729_entry:
	esp = fp
	Top = 0
	cx = ax
	ecx = ecx | 2675297569
	dx = dx << cl
	SCZO = cond(dx)
	bx = (word16) (C.u5 + (bx + di) /16 0x4B55D4E4)
	v17 = (bl & 0x01 << cl) != 0x00
	bl = __ror<byte,byte>(bl, cl)
	cl = cl >> cl
	v19 = (cl & 0x01 << 0x08 - 0x06) != 0x00
	cl = __rol<byte,byte>(cl, 0x06)
	SCZO = cond(ebx - 0xFA62D806)
	branch Test(NE,Z) l00409318
	goto l0040974E
l00409318:
	bh = bh ^ ch
	*edi = al
	ebx = ebx | 0x2C1072BB
	v30 = (bl & 0x01 << 0x0C) != 0x00
	bl = __ror<byte,byte>(bl, 0x0C)
	ebx = ebx >> cl
	SCZO = cond(ebx)
	&edx.u4->a0000->u0 = C.u5 + ((word32) edx + 49242441) / 0x4B55D4E4
	SCZO = cond(edx)
l00409329:
	v31 = (ecx & 0x01 << cl) != 0x00
	ecx = __ror<word32,byte>(ecx, cl)
	cx = cx << cl
	cx = dx
	bh = bh - dh
	SCZO = cond(bh)
	v33 = (edx & 0x01 << 0x20 - 0x10) != 0x00
	edx = __rcl<word32,byte>(edx, 0x10, C)
	C = v33
	bh = bh - ch - C
	SCZO = cond(bh)
	&edx.u4->a0000->u0 = C.u5 + ((word32) edx - 0x6B1A5EE8) / 0x4B55D4E4
	SCZO = cond(edx - 0x0E3064E2)
	branch Test(NE,Z) l004094F4
l00409351:
	eax = __in<word32>(dx)
	ecx = ecx - 0x01
	branch Test(EQ,Z) && ecx != 0x00 l00409329
l00409354:
	branch Test(NS,S) l00409354_thunk_fn004093BB
	goto l00409356
l00409354_thunk_fn004093BB:
	fn004093BB()
	return
l00409356:
	branch Test(UGT,CZ) l004092D9
l004094CC:
l004094F4:
	edi = edi + 1
	C.u0 = false
	dl = (ui8) ((bool) C.u0 + (dl + ~0x70))
	dl = ~dl
	SZP = cond(bh & ah)
	C.u0 = false
	dl = (ui8) ((bool) C.u0 + (dl + 0x41))
	ch = ch & 0x23
	C.u0 = false
	v39 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	dl = dl << 0x0C
	v40 = (bh & 0x01 << cl) != 0x00
	bh = __ror<byte,byte>(bh, cl)
	C = v40
	v41 = (bh & 0x01 << 0x08 - 0x13) != 0x00
	bh = __rcl<byte,byte>(bh, 0x13, C)
	C = v41
	esi = esi - 0x01
	SZO = cond(esi)
	v43 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rcl<byte,byte>(dh, cl, C)
	bl = bl - 225
	SZP = cond(dl & dh)
	ch = ch & dl
	C.u0 = false
	ebx = ebx + edx + C
	SCZO = cond(ebx)
	ch = ch - cl - C
	SCZO = cond(ch)
	edx = edx - ecx - C
	cx = cx - 0x01
	bl = bl ^ 0x1C
	cx = cx >> cl
	SCZO = cond(cx)
	ecx.u0 = 764833613
	ebx = ebx | edx
	SZ = cond(ebx)
	O = false
	C.u0 = false
	fn0040944F()
	return
l0040967E:
l0040967E_thunk_fn0040944F:
l00409729:
l0040974E:
	&edx.u4->a0000->u0 = (word32) edx + 1
	ecx = ebx *s ~0x1017177E
	SCZO = cond(ecx)
	fn0040944F()
	return
l0040974F_thunk_fn0040944F:
fn00409729_exit:
}

