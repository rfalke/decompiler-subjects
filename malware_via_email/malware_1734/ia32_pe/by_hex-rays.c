/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __userpurge start(int@<eax>, int@<edx>, int@<ecx>, int@<ebx>, int@<edi>, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);


//----- (0040C670) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge start(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<edi>,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  int v64; // edi
  bool v65; // tt
  unsigned int v66; // eax
  int v68; // eax
  int v69; // edx
  int v71; // ebx
  int v72; // edi
  int v73; // eax
  int v74; // ebx
  int v75; // eax
  int v76; // edi
  int v77; // eax
  int v80; // edi
  int v81; // edx
  bool v82; // cf
  unsigned int v83; // eax
  bool v85; // tt
  int v86; // edx
  bool v87; // tt
  int v89; // eax
  unsigned int v90; // edi
  char v93; // tt
  int v94; // ecx
  int v96; // ebx
  int v98; // ebx
  bool v99; // tt
  int v101; // ebx
  unsigned int v104; // esi
  int v105; // eax
  bool v108; // tt
  unsigned int v110; // edi
  int v111; // eax
  bool v112; // tt
  int v114; // edx
  int v116; // edx
  bool v118; // tt
  int v120; // edi
  bool v121; // zf
  int v122; // edx
  int v123; // esi
  int v124; // ebx
  int v130; // eax

  BYTE1(a2) = BYTE1(a1);
  v116 = a2 << a3;
  v118 = __CFSHR__(a3, a3);
  _ECX = __ROR4__(a3, a3);
  BYTE1(a4) = -28;
  _EBX = a4 - 1;
  BYTE1(a1) += BYTE1(v116) + v118;
  v120 = _EBX & a5;
  v122 = v120 ^ v116;
  v121 = v122 == 0;
  BYTE1(v122) = -85;
  v123 = -1982266438;
  if ( !v121 && v121 )
  {
    __asm
    {
      fdivr   st, st(5)
      rcr     bl, cl
    }
    v124 = -_EBX;
    BYTE1(_ECX) = BYTE1(v124);
    LOBYTE(v124) = __ROR1__(v124 - a1, _ECX);
    BYTE1(v124) = __ROR1__(_ECX & BYTE1(v124), _ECX);
    BYTE1(_ECX) = (BYTE1(_ECX) << _ECX) & 0xAB;
    _EDI = (unsigned int)(v122 + (v120 << _ECX)) >> ~(_BYTE)_ECX;
    LOBYTE(_ECX) = BYTE1(a1);
    _ECX = _ECX - (v122 | v124);
    v104 = __ROL4__(-1982266438, _ECX);
    BYTE1(_ECX) = ~(__ROR1__(BYTE1(_ECX), _ECX) ^ 0xAB);
    LOBYTE(_ECX) = v122 ^ 0x18;
    v74 = _ECX >> (v122 ^ 0x18);
    BYTE1(v74) <<= v122 ^ 0x18;
    LOBYTE(_ECX) = (v122 ^ 0x18) - 124;
    _EBX = v74 >> _ECX;
    LOBYTE(_ECX) = _ECX & 0x87;
    _ESI = __ROL4__(v104 >> 3, _ECX);
    __asm
    {
      rcr     cl, cl
      rcr     edi, cl
      rcr     esi, cl
      rcr     bl, cl
    }
    JUMPOUT(0x40C4D1);
  }
  v112 = __CFSHR__(a1, _ECX);
  v111 = __ROR4__(a1, _ECX);
  BYTE1(_EBX) += BYTE1(v111) + v112;
  BYTE1(_ECX) <<= _ECX;
  v76 = _ECX & __ROL4__(v120, _ECX);
  LOBYTE(v122) = v122 ^ 0x21;
  LOBYTE(v111) = v111 | 0x19;
  BYTE1(v111) &= v111;
  _ECX = v76;
  v77 = v111 << v76;
  BYTE1(v122) = -__ROL1__(-85, v76);
  __asm { rcl     cl, cl }
  do
  {
    BYTE1(v77) ^= v77;
    LOBYTE(v77) = _EBX + v77;
    _EDX = v122 + 1;
    LOBYTE(_ECX) = _EDX | _ECX;
    _ECX = _EBX & _ECX;
    v71 = _EBX << _ECX;
    v72 = v76 >> _ECX;
    BYTE1(_EDX) = _ECX + BYTE1(_EDX) - (__CFSHL__(BYTE1(v71), _ECX) + v71);
    v73 = __ROR4__(v77 - v123, _ECX);
    LOBYTE(v73) = BYTE1(_ECX) | v73;
    __asm { rcr     dl, cl }
    BYTE1(v73) <<= _ECX;
    BYTE1(v71) = __ROR1__((BYTE1(v71) << _ECX) + 8, _ECX);
    v65 = __CFSHR__(v72, _ECX);
    v64 = __ROR4__(v72, _ECX);
    v66 = v73 - (v65 + v71);
    BYTE1(_EDX) = _ECX + (BYTE1(_EDX) << _ECX);
    v82 = __CFSHL__(v66, _ECX);
    LOBYTE(v66) = (_BYTE)v66 << _ECX;
    BYTE1(v66) = 6;
    BYTE1(v71) += v82 + 125;
    v83 = v66 >> _ECX;
    BYTE1(_ECX) = __ROR1__(__ROR1__(BYTE1(_ECX), _ECX), _ECX);
    _ECX = _EDX + _ECX;
    v105 = _EDX ^ v83;
    LOBYTE(v105) = v105 - 77;
    SBYTE1(v105) >>= _ECX;
    LOBYTE(v71) = BYTE1(v71) | 0x4D;
    v69 = v105;
    LOBYTE(_ECX) = _ECX & 0x97;
    ++v71;
    _EDI = v64 << _ECX;
    LOBYTE(v69) = ~((unsigned __int8)v105 >> _ECX);
    v114 = _EDI & v69;
    LOBYTE(v71) = ((unsigned __int8)v114 < 0x25u) + v71 - 124;
    BYTE1(v71) = __ROR1__(BYTE1(v71), _ECX) + 1;
    __asm { rcr     cl, cl }
    _ECX = v123 | _ECX;
    LOBYTE(v114) = (v114 - 37) ^ 0x74;
    LOBYTE(v105) = (BYTE1(v105) | v105) ^ 0x43;
    LOBYTE(_ECX) = __ROL1__((v71 << _ECX) + _ECX, (v71 << _ECX) + _ECX);
    _EAX = __ROL4__(v105, _ECX);
    BYTE1(_EAX) = ~BYTE1(_EAX);
    BYTE1(v114) = 119 - BYTE1(_EAX);
    __asm { rcl     edi, cl }
    v80 = v114 + _EDI;
    v81 = v114 >> _ECX;
    LOBYTE(_EAX) = -107;
    v85 = __CFSHL__(BYTE1(v81), _ECX);
    BYTE1(v81) = __ROL1__(BYTE1(v81), _ECX);
    LOBYTE(_ECX) = _ECX - (v85 + BYTE1(_EAX));
    v86 = v81 << _ECX;
    v87 = __CFSHL__(v86, _ECX);
    LOBYTE(v86) = __ROL1__(v86, _ECX);
    --v86;
    LOBYTE(_ECX) = _ECX - 1;
    __asm { rcr     eax, cl }
    v89 = _ECX + v87 + _EAX;
    BYTE1(v89) <<= _ECX;
    BYTE1(_ECX) = v86;
    LOBYTE(v86) = BYTE1(v86) ^ v86;
    LOBYTE(v89) = (unsigned __int8)-(char)v89 >> _ECX;
    _ECX = v86 + _ECX;
    LOBYTE(v86) = 0;
    v110 = __ROR4__(v80, 204);
    _EBX = v110;
    LOBYTE(_ECX) = BYTE1(_ECX);
    __asm { rcl     ebx, cl }
    LOBYTE(_EBX) = (unsigned __int8)_EBX >> SBYTE1(_ECX);
    BYTE1(_ECX) ^= BYTE1(_EBX);
    v108 = __CFSHR__(_ECX, _ECX);
    LOBYTE(_ECX) = __ROR1__(_ECX, _ECX);
    _EBX = v110 | (v110 + v108 + _EBX);
    v68 = v89 - _ECX;
    SBYTE1(_ECX) >>= _ECX;
    v82 = (unsigned __int8)v68 < BYTE1(_EBX);
    LOBYTE(v68) = v68 - BYTE1(_EBX);
    __asm { rcl     bh, cl }
    BYTE1(v68) -= v82 + 71;
    v122 = __ROR4__(v86, _ECX);
    v82 = __CFSHL__(BYTE1(v68), _ECX);
    BYTE1(v68) <<= _ECX;
    v93 = v82;
    v82 = __CFADD__(v82, BYTE1(v68));
    BYTE1(v68) += v93;
    v82 |= __CFADD__(BYTE1(v68), 84);
    BYTE1(v68) += 84;
    v94 = _ECX - (v82 + v68);
    _EAX = v123 & v68;
    v96 = -_EBX;
    BYTE1(v96) -= _EAX;
    LOBYTE(v122) = v122 - BYTE1(v122);
    _ECX = (v110 ^ v94) - v123;
    v99 = __CFSHR__(v96, _ECX);
    v98 = __ROR4__(v96, _ECX);
    __asm { rcl     eax, cl }
    v82 = __CFADD__(v99, v98);
    v101 = v99 + v98;
    v82 |= __CFADD__(v122, v101);
    v101 += v122;
    LOBYTE(v101) = BYTE1(v122) + v82 + v101;
    BYTE1(v101) &= BYTE1(_ECX);
    _EBX = _EAX + v101;
    LOBYTE(_EAX) = _EAX | 0xD6;
    _ECX = _ECX << _ECX;
    v130 = v123 & _EAX;
    LOBYTE(_EBX) = -44;
    __asm { rcr     bl, cl }
    LOBYTE(_ECX) = _ECX - 1;
    __asm { rcl     cl, cl }
    LOBYTE(v130) = v130 - 72;
    BYTE1(_EBX) = (BYTE1(_EBX) | 0x45) + 32;
    LOBYTE(_EBX) = (unsigned __int8)_EBX >> _ECX;
    _ECX = v130 | _ECX;
    __asm { rcr     ebx, cl }
    --BYTE1(_EBX);
    BYTE1(v130) = (BYTE1(v130) - BYTE1(_EBX)) << _ECX;
    --v130;
    LOBYTE(v130) = (_BYTE)v130 << _ECX;
    LOBYTE(_ECX) = (_BYTE)_ECX << _ECX;
    BYTE1(v130) = ((unsigned __int8)_EBX < (unsigned __int8)v130) + BYTE1(v122) + 34;
    LOBYTE(_EBX) = (_EBX - v130) & 0xE;
    v90 = (__PAIR64__(v130, -2099764721) + __PAIR64__(v110, v123)) >> 32;
    v123 -= 2099764721;
    LOBYTE(v130) = v130 ^ 0xB6;
    BYTE1(_ECX) = ~BYTE1(_ECX);
    BYTE1(_EBX) -= _ECX;
    BYTE1(v130) ^= BYTE1(v122);
    v75 = (__PAIR64__(v130, v122) + __PAIR64__(v122, (v122 ^ v90) << _ECX)) >> 32;
    v76 = v122 + ((v122 ^ v90) << _ECX);
    v77 = _ECX ^ v75;
    LOBYTE(_EBX) = (unsigned __int8)_EBX >> _ECX;
    BYTE1(v77) ^= _ECX;
    BYTE1(_ECX) = 85;
  }
  while ( v123 != 2121165485 );
  JUMPOUT(0x40C5E2);
}
// 40C06B: positive sp value 4 has been found
// 40C694: inconsistent fpu stack
// 40BFC3: control flows out of bounds to 40BFC4
// 40C06D: control flows out of bounds to 40C06F
// 40C1A0: control flows out of bounds to 40C1A6
// 40C235: control flows out of bounds to 40C23B
// 40C36B: control flows out of bounds to 40C36C
// 40C397: control flows out of bounds to 40C399
// 40C731: control flows out of bounds to 40C732
// 40C799: control flows out of bounds to 40C79E
// 40C7EB: control flows out of bounds to 40C7EC
// 40C899: control flows out of bounds to 40C89F
// 40C936: control flows out of bounds to 40C93C
// 40C17E: control flows out of bounds to 40C7C1
// 40C411: control flows out of bounds to 40C8CA
// 40C7F3: control flows out of bounds to 40C939
// 40C902: control flows out of bounds to 40C4D1
// 40BFB3: control flows out of bounds to 40C04B
// 40C037: control flows out of bounds to 40C4A0
// 40C06D: control flows out of bounds to 40C04F
// 40C155: control flows out of bounds to 40C5E2
// 40C395: control flows out of bounds to 40C3B9
// 40C5B3: control flows out of bounds to 40C60B
// 40C876: control flows out of bounds to 40C84A
// 40C8B5: control flows out of bounds to 40C093
// 40C0BF: conditional instruction was optimized away because ebx.4!=0
// 40C15D: conditional instruction was optimized away because ah.1!=0
// 40C494: conditional instruction was optimized away because ebx.4!=0
// 40C5D7: conditional instruction was optimized away because bl.1!=0
// 40C666: conditional instruction was optimized away because edx.4!=0
// 40C670: too many input arguments, some ignored

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
