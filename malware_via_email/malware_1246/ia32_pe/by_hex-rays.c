/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall start@<eax>(unsigned int a1@<eax>, char a2@<cl>, int a3@<ebp>, _BYTE *a4, _BYTE *a5);
int __thiscall nullsub_1(_DWORD); // weak
void __stdcall __spoils<ecx> sub_401076(_BYTE *a1, _BYTE *a2);
void __stdcall __spoils<ecx> sub_4010B5(_BYTE *a1);


//----- (00401000) --------------------------------------------------------
int __usercall start@<eax>(unsigned int a1@<eax>, char a2@<cl>, int a3@<ebp>, _BYTE *a4, _BYTE *a5)
{
  int v5; // ebx
  int v6; // edx
  int v7; // ecx
  int result; // eax
  int v9; // [esp+4h] [ebp-2Ch]
  int (__cdecl *v10)(int); // [esp+8h] [ebp-28h]
  int *v11; // [esp+10h] [ebp-20h] BYREF
  int v12; // [esp+14h] [ebp-1Ch] BYREF
  int v13; // [esp+1Ch] [ebp-14h]

  nullsub_1(a3 + (a1 >> (-a2 - 2)));
  HIWORD(v5) = HIWORD(v13);
  LOWORD(v5) = 0;
  v13 = v5 + *(_DWORD *)(*(_DWORD *)(v5 + 60) + v5 + *(unsigned __int16 *)(*(_DWORD *)(v5 + 60) + v5 + 20) + 76) + 2375;
  sub_4010B5((_BYTE *)0xCEF2EDA8);
  if ( MEMORY[0](0, v5 + 1, v13) )
    return nullsub_1(v7);
  sub_4010B5((_BYTE *)0x10066F2F);
  v11 = &v12;
  MEMORY[0](v5 + *(_DWORD *)(v6 + 52), *(_DWORD *)(v6 + 48), 64, &v11);
  result = v10(v9);
  sub_401076(a4, a5);
  return result;
}
// 401064: variable 'v6' is possibly undefined
// 401074: variable 'v10' is possibly undefined
// 401074: variable 'v9' is possibly undefined
// 401051: variable 'v7' is possibly undefined
// 401018: using guessed type int __thiscall nullsub_1(_DWORD);

//----- (00401076) --------------------------------------------------------
void __stdcall __spoils<ecx> sub_401076(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // ecx
  _BYTE *v4; // edi
  unsigned int v6; // eax
  char v7; // bl
  char v8; // cf

  v2 = a1;
  v3 = a2;
  if ( !a2 )
  {
    v4 = a1;
    while ( *v4++ != 0 )
      ;
    v3 = (_BYTE *)(v4 - 1 - a1);
  }
  v6 = -1;
  do
  {
    LOBYTE(v6) = *v2++ ^ v6;
    v7 = 8;
    do
    {
      v8 = v6 & 1;
      v6 >>= 1;
      if ( v8 )
        v6 ^= 0xEDB88320;
      --v7;
    }
    while ( v7 );
    --v3;
  }
  while ( v3 );
}
// 401076: could not find valid save-restore pair for esi

//----- (004010B5) --------------------------------------------------------
void __stdcall __spoils<ecx> sub_4010B5(_BYTE *a1)
{
  _DWORD *v1; // edx
  char *v2; // edi
  __int16 *v3; // esi
  int v4; // ecx
  __int16 v5; // ax
  int v6; // ecx
  char *v7; // esi
  char *v8; // edi
  char v9; // al
  int v10; // ebx
  int *v11; // esi
  int *v12; // edi
  int v13; // ecx
  int v14; // eax
  int *v15; // esi
  int v16; // edx
  int v17; // eax
  _BYTE *v18; // eax
  char v19[13]; // [esp+Bh] [ebp-19h] BYREF
  int v20[2]; // [esp+18h] [ebp-Ch] BYREF

  v1 = (_DWORD *)*((_DWORD *)NtCurrentPeb()->ImageBaseAddress + 3);
  do
  {
    v1 = (_DWORD *)*v1;
    v2 = v19;
    v3 = (__int16 *)v1[12];
    v4 = 13;
    do
    {
      v5 = *v3++;
      *v2++ = v5;
      if ( !v5 )
        break;
      --v4;
    }
    while ( v4 );
    v6 = 13;
    v7 = v19;
    v8 = v19;
    do
    {
      v9 = *v7++;
      if ( (unsigned __int8)v9 <= 0x5Au && (unsigned __int8)v9 >= 0x41u )
        v9 += 32;
      *v8++ = v9;
      --v6;
    }
    while ( v6 );
    sub_401076(v19, 0);
  }
  while ( (unsigned int)v19 != 0x6AE69F02 );
  v10 = v1[6];
  v11 = (int *)(v10 + *(_DWORD *)(*(_DWORD *)(v10 + 60) + v10 + 120) + 28);
  v12 = v20;
  v13 = 3;
  do
  {
    v14 = *v11++;
    *v12++ = v10 + v14;
    --v13;
  }
  while ( v13 );
  v15 = (int *)v20[1];
  v16 = -1;
  do
  {
    ++v16;
    v17 = *v15++;
    v18 = (_BYTE *)(v10 + v17);
    sub_401076(v18, 0);
  }
  while ( a1 != v18 );
}
// 4010B5: could not find valid save-restore pair for esi

// nfuncs=4 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled
