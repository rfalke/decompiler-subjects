// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_481 g_t40105C = // 0040105C;
word32 g_dw401093 = 0x3000; // 00401093
// 004010A9: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 fp;
	ui32 ebp;
	<anonymous> * ebx;
	struct Eq_6 * fs;
	struct Eq_7 * dwArg00;
	ui32 esi_27 = __rol<word32,byte>(548142871, 0x07) & ebp;
	struct Eq_17 * edx_29 = __ror<word32,byte>(0x025FE000, 0x05)[(fp & __rol<word32,byte>(0xE000001F, 0x03)) / 4];
	do
	{
		++edx_29;
		if (edx_29->dw0000 == ~0x6F)
		{
			byte cl_44 = (byte) __rol<word32,byte>(0xC000003F, 0x02);
			do
				;
			while (edx_29[4] != cl_44);
			goto l0040110D;
		}
	} while (edx_29->dw0000 != esi_27);
	ui32 ecx_56 = __rol<word32,byte>(0x40000002, 0x06);
	if (edx_29->bFFFFFFFF != (byte) ecx_56)
	{
		Eq_2 eax_66;
		ebx();
		return eax_66;
	}
	else
	{
l0040110D:
		word16 cx_807 = (word16) fp;
		word16 ecx_16_16_812 = SLICE(fp, word16, 16);
		struct Eq_7 * edx_89 = dwArg00;
		ui32 eax_104 = SEQ(~0x00, __ror<word16,byte>(~0x6F, 0x0C));
		while (true)
		{
			cx_807 += ~0x24;
			++edx_89;
			word32 ecx_107 = SEQ(ecx_16_16_812, cx_807);
			if (edx_89->t0000.u0 == __ror<word32,byte>(0x0186, 0x01))
				break;
			eax_104 <<= 0x1B;
		}
		struct Eq_79 * esp_112;
		edx_89();
		struct Eq_80 * eax_130 = fs->ptr0030->ptr000C;
		struct Eq_87 * edi_148 = *((char *) *eax_130->ptr001C + 8);
		esp_112->ptrFFFFFFFC = (struct Eq_87 *) 4167466597;
		esp_112->ptrFFFFFFF8 = edi_148;
		struct Eq_87 * ecx_158 = fn00401477(esp_112->ptrFFFFFFF8, esp_112->ptrFFFFFFFC);
		esp_112->ptrFFFFFFFC = (struct Eq_87 *) 0x6C;
		esp_112->ptrFFFFFFF8 = (struct Eq_87 *) 1818504812;
		esp_112->ptrFFFFFFF4 = (struct Eq_87 *) 0x6C64746E;
		esp_112->ptrFFFFFFF0 = esp_112 - 0x0C;
		ecx_158();
		esp_112->ptrFFFFFFF8 = (struct Eq_87 *) 392494317;
		esp_112->ptrFFFFFFF4 = SEQ(SLICE((char *) &eax_130->ptr001C + 520625342, word16, 16), (word16) eax_130 + 0x1D2C);
		struct Eq_87 * ecx_201 = fn00401477(esp_112->ptrFFFFFFF4, esp_112->ptrFFFFFFF8);
		esp_112->ptrFFFFFFF8 = ecx_201;
		struct Eq_87 * edx_209 = esp_112->ptrFFFFFFF8;
		esp_112->ptrFFFFFFF8 = null;
		esp_112->ptrFFFFFFF4 = null;
		esp_112->ptrFFFFFFF0 = 0x00;
		esp_112->dwFFFFFFEC = 0x00D0FA22;
		esp_112->dwFFFFFFE8 = ~0x12600063;
		esp_112->dwFFFFFFE4 = 0x02BE;
		word32 ecx_228;
		edx_209();
		<anonymous> * edx_243 = *(<anonymous> **) 1909409;
		ui32 * eax_249;
		edx_243();
		byte * eax_255 = eax_249 & *eax_249;
		*eax_255 += (byte) eax_255;
		struct Eq_87 * eax_285 = *((char *) *fs->ptr0030->ptr000C->ptr001C + 8);
		fn00401477(eax_285, *(struct Eq_87 *) 850356788)();
		eax_285[106500] = (struct Eq_87) eax_285;
		eax_285[0x0001A018] = (struct Eq_87) fn00401477(eax_285, (struct Eq_87 *) 4167466597);
		eax_285[0x0001A020] = (struct Eq_87) fn00401477(eax_285, (struct Eq_87 *) 1116944593);
		fn00401477(eax_285, *(struct Eq_87 *) 1491169839)();
		word32 edi_374 = g_dw401093;
		__wait();
		struct Eq_87 * ebp_291 = eax_285;
		word24 eax_24_8_402 = 0x00;
		word32 ecx_385;
		byte * esi_391 = edi_374 + 0x00400117;
		for (ecx_385 = 0x48F0; ecx_385 != 0x00; --ecx_385)
		{
			byte al_395 = *esi_391;
			Eq_2 eax_403 = SEQ(eax_24_8_402, al_395);
			if (eax_403 != 0x00)
			{
				eax_403 = SEQ(eax_24_8_402, al_395 ^ ~0x49);
				if (eax_403 != 0x00)
				{
					*esi_391 = al_395 ^ ~0x49;
					eax_403 = SEQ(eax_24_8_402, al_395 ^ ~0x49);
				}
			}
			eax_24_8_402 = SLICE(eax_403, word24, 8);
			++esi_391;
		}
		struct Eq_87 * edi_482 = eax_285;
		byte * esi_493 = g_dw401093 + 0x00400117;
		Eq_304 dl_502 = 0x80;
		word24 ebx_24_8_836 = 0x00;
		while (true)
		{
			edi_482->t0000.u0 = *esi_493;
			byte * esi_512 = esi_493 + 1;
			++edi_482;
			word32 ebx_558 = SEQ(ebx_24_8_836, 0x02);
			while (true)
			{
				fn00401429(dl_502, esi_512, out dl_502, out esi_493);
				ebx_24_8_836 = SLICE(ebx_558, word24, 8);
				bool C_526 = <invalid>;
				if (C_526)
					break;
				Eq_322 ecx_582;
				struct Eq_87 * eax_731;
				struct Eq_87 * eax_591;
				Eq_304 dl_535;
				byte * esi_536;
				fn00401429(dl_502, esi_493, out dl_535, out esi_536);
				bool C_538 = <invalid>;
				if (!C_538)
				{
					fn00401429(dl_535, esi_536, out dl_502, out esi_512);
					bool P_619 = <invalid>;
					bool O_618 = <invalid>;
					bool D_617 = <invalid>;
					bool Z_616 = <invalid>;
					bool C_615 = <invalid>;
					bool S_614 = <invalid>;
					Eq_365 SCZDOP_624 = P_619 | O_618 | D_617 | Z_616 | C_615 | S_614;
					if (!C_615)
					{
						__wait();
						ecx_582.u0 = 0x01;
						uint8 al_755 = 0x10;
						ebx_558 = SEQ(ebx_24_8_836, 0x02);
						do
						{
							__wait();
							fn00401429(dl_502, esi_512, out dl_502, out esi_512);
							bool C_761 = <invalid>;
							__wait();
							al_755 = al_755 * 0x02 + (byte) C_761;
							eax_731 = (uint32) al_755;
						} while (al_755 >= 0x00);
						if (al_755 == 0x00)
						{
							edi_482->t0000.u0 = al_755;
							__wait();
							++edi_482;
							continue;
						}
						goto l0040141C;
					}
					uint32 eax_629 = (uint32) *esi_512;
					++esi_512;
					eax_591 = eax_629 >> 0x01;
					byte SCZDOP_672 = cond(eax_629 >> 0x01) | SLICE(SCZDOP_624, bool, 5);
					if (eax_629 >> 0x01 == 0x00)
					{
						fn00401533(eax_285);
						memcpy(eax_285 + 0x0001A000, &g_t40105C, 0x25);
						return eax_403;
					}
					__wait();
					ecx_582 = (word32) SLICE(SCZDOP_672, bool, 1);
					goto l00401402;
				}
				Eq_304 dl_543;
				byte * esi_545;
				up32 ecx_559 = fn00401442(0x00, dl_535, esi_536, out dl_543, out esi_545) - ebx_558;
				if (ecx_559 == 0x00)
				{
					ecx_582 = fn0040143D(dl_543, esi_545, out dl_502, out esi_512);
					goto l0040140F;
				}
				byte al_579 = *esi_545;
				ecx_582 = fn0040143D(dl_543, esi_545 + 1, out dl_502, out esi_512);
				eax_591 = SEQ(ecx_559 - 0x01, al_579);
				if (eax_591 < (struct Eq_87 *) 0x7D00)
				{
					if (ecx_559 >= 0x06)
						goto l00401406;
					if (eax_591 <= (struct Eq_87 *) 0x7F)
						goto l00401402;
				}
				else
				{
l00401402:
					__wait();
					ecx_582 = (word32) ecx_582.u0 + 1;
l00401406:
					ecx_582 = (word32) ecx_582 + 1;
				}
				ebp_291 = eax_591;
l0040140F:
				__wait();
				__wait();
				eax_731 = ebp_291;
				ebx_558 = SEQ(ebx_24_8_836, 0x01);
l0040141C:
				memcpy(edi_482, edi_482 - eax_731, ecx_582);
				edi_482 += ecx_582;
			}
		}
	}
}

// 00401429: FlagGroup byte fn00401429(Register Eq_304 dl, Register (ptr32 byte) esi, Register out Eq_331 dlOut, Register out (ptr32 byte) esiOut)
// Called from:
//      Win32CrtStartup
//      fn00401442
byte fn00401429(Eq_304 dl, byte * esi, union Eq_331 & dlOut, byte & esiOut)
{
	ptr32 fp;
	Eq_331 dl_10 = dl *8 0x02;
	if (dl *8 0x02 == 0x00)
	{
		++esi;
		dl_10 = *esi * 0x02 + (fp - 4);
	}
	dlOut = dl_10;
	esiOut = esi;
	return <invalid>;
}

// 0040143D: Register word32 fn0040143D(Register Eq_304 dl, Register (ptr32 byte) esi, Register out Eq_442 dlOut, Register out (ptr32 byte) esiOut)
// Called from:
//      Win32CrtStartup
word32 fn0040143D(Eq_304 dl, byte * esi, union Eq_442 & dlOut, byte & esiOut)
{
	__wait();
	Eq_442 dl_16;
	byte * esi_18;
	word32 ecx_17 = fn00401442(0x00, dl, esi, out dl_16, out esi_18);
	dlOut = dl_16;
	esiOut = esi_18;
	return ecx_17;
}

// 00401442: Register ui32 fn00401442(Register ui32 ecx, Register Eq_304 dl, Register (ptr32 byte) esi, Register out Eq_304 dlOut, Register out (ptr32 byte) esiOut)
// Called from:
//      Win32CrtStartup
//      fn0040143D
ui32 fn00401442(ui32 ecx, Eq_304 dl, byte * esi, union Eq_304 & dlOut, byte & esiOut)
{
	ui32 ecx_10 = ecx + 0x01;
	do
	{
		Eq_304 dl_14;
		byte * esi_15;
		fn00401429(dl, esi, out dl_14, out esi_15);
		bool C_17 = <invalid>;
		fn00401429(dl_14, esi_15, out dl, out esi);
		ecx_10 = ecx_10 * 0x02 + (word32) C_17;
		bool C_28 = <invalid>;
	} while (C_28);
	dlOut = dl;
	esiOut = esi;
	return ecx_10;
}

// 00401477: Register word32 fn00401477(Stack (ptr32 Eq_87) dwArg04, Stack (ptr32 Eq_87) dwArg08)
// Called from:
//      Win32CrtStartup
word32 fn00401477(struct Eq_87 * dwArg04, struct Eq_87 * dwArg08)
{
	struct Eq_542 * edx_32 = dwArg04 + (*((byte) (dwArg04)[60].t0000 + (dwArg04 - ~0x77)) - ~0x1B);
	word32 * edx_42 = dwArg04 + edx_32->dw0004;
	word32 ecx_39[] = dwArg04 + edx_32->dw0000;
	word16 eax_49[] = dwArg04 + edx_32->dw0008;
	word32 * ecx_116 = edx_42;
	ui32 dwLoc1C_144 = 0x00;
	byte * eax_119 = dwArg04 + *edx_42;
	ui8 dl_128 = 0x00;
	ui24 edx_24_8_131 = 0x00;
	while (true)
	{
		do
		{
			struct Eq_17 * (* edx_76)[] = __ror<word32,byte>(SEQ(edx_24_8_131, dl_128 + *eax_119), 0x13);
			dl_128 = (byte) edx_76 ^ 0x07;
			edx_24_8_131 = SLICE(edx_76, word24, 8) ^ 0x00F542D4;
			++eax_119;
		} while (*eax_119 != 0x00);
		if ((edx_76 ^ 4114797575 ^ dwArg08) == 0x00)
			break;
		++ecx_116;
		eax_119 = (byte *) (dwArg04 + *ecx_116);
		++dwLoc1C_144;
		dl_128 = 0x00;
		edx_24_8_131 = 0x00;
	}
	return dwArg04 + ecx_39[(uint32) eax_49[dwLoc1C_144]];
}

// 00401533: void fn00401533(Register (ptr32 Eq_87) ebx)
// Called from:
//      Win32CrtStartup
void fn00401533(struct Eq_87 * ebx)
{
	ebx[0x0001A031] = (struct Eq_87) ebx;
	struct Eq_628 * eax_121 = ebx + 100224;
	while (true)
	{
		word32 ecx_40 = eax_121->dw000C;
		if (ecx_40 == 0x00)
			break;
		ebx[0x0001A05B] = (struct Eq_87) eax_121->ptr0010;
		ptr32 edx_70 = eax_121->ptr0000;
		ebx[106568] = (struct Eq_87) edx_70;
		if (edx_70 == 0x00)
			edx_70 = eax_121->ptr0010;
		struct Eq_87 * esi_81 = ebx[0x0001A031];
		ui32 * edx_88 = esi_81 + edx_70;
		ebx[106600] = (struct Eq_87) edx_88;
		struct Eq_87 * ecx_97 = ebx[0x0001A018];
		word32 eax_104;
		struct Eq_660 * esp_103;
		ecx_97();
		ebx[106609] = (struct Eq_87) eax_104;
		while (true)
		{
			ui32 * edx_112 = ebx[106600];
			ui32 ecx_113 = *edx_112;
			if (ecx_113 == 0x00)
				break;
			ui32 ecx_133;
			if ((ecx_113 & 0x80000000) == 0x00)
			{
				ecx_113 += 0x02;
				if (ecx_113 == ~0x01)
					goto l004015B9;
				ecx_133 = (ui32) ((byte) ebx[0x0001A031].t0000 + (ecx_113 + 0x02));
			}
			else
			{
l004015B9:
				ecx_133 = ecx_113 & 0x7FFFFFFF;
			}
			struct Eq_689 * esp_142 = esp_103 - 4;
			esp_142->dw0000 = ecx_133;
			esp_142->dwFFFFFFFC = (word32) ebx[106609];
			struct Eq_87 * eax_153 = ebx[0x0001A020];
			struct Eq_660 * esp_168;
			word32 eax_169;
			eax_153();
			esp_168->dwFFFFFFFC = eax_169;
			Mem185[Mem175[ebx + 0x0001A05B:word32] + Mem175[ebx + 0x0001A031:word32]:word32] = Mem175[esp_168 + -4:word32];
			ebx[0x0001A05B] = (struct Eq_87) ((byte) ebx[0x0001A05B].t0000 + 4);
			ebx[106600] = (struct Eq_87) (ebx[106600] - ~0x03);
			esp_103 = esp_168;
		}
		eax_121 = esp_103->dw0004 + 0x14;
	}
}

