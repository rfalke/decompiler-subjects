/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall start(unsigned __int8 _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<ebp>);
// __int64 __usercall sub_40A0EC@<edx:eax>(char a1@<dl>, _BYTE *a2@<esi>);
// __int64 __usercall sub_40A14B@<edx:eax>(__int64 result@<edx:eax>, _BYTE *a2@<esi>);

//-------------------------------------------------------------------------
// Data declarations

int dword_40A000[2] = { 568, 1149218270 }; // weak


//----- (0040A042) --------------------------------------------------------
void __usercall start(unsigned __int8 _CF@<cf>, char _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<ebp>)
{
  int v5; // ebx
  unsigned int v6; // eax
  _DWORD *v7; // esi
  void (*v8)(void); // ebx
  void *v9; // edi
  _DWORD *v10; // edx
  int v11; // ecx
  _DWORD *v12; // esi
  _DWORD *v13; // edi
  unsigned int v14; // ebx
  _BYTE *v15; // edi
  _BYTE *v16; // esi
  __int64 v17; // rax
  int v18; // ebx
  _BYTE *v19; // edi
  __int64 v21; // rax
  unsigned int v22; // ecx
  int v23; // ecx
  __int64 v24; // rax
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  unsigned int v28; // ecx
  int v29; // [esp+4h] [ebp-5Eh]
  unsigned int v30; // [esp+4h] [ebp-5Eh]
  int v31; // [esp+8h] [ebp-5Ah]
  unsigned int v32; // [esp+8h] [ebp-5Ah]
  int v33; // [esp+Ch] [ebp-56h]
  _DWORD *v34; // [esp+Ch] [ebp-56h]
  _DWORD *v35; // [esp+10h] [ebp-52h]

  v6 = (unsigned int)dword_40A000;
  __asm { pushfw }
  while ( 1 )
  {
    v7 = (_DWORD *)(*(_DWORD *)v6 + v6 + 8);
    *(_DWORD *)v6 = 4196224;
    v8 = (void (*)(void))v7[4];
    v35 = v7;
    ((void (__cdecl *)(int, int, int))v8)(4196224, 2176, 4);
    v7 -= 2;
    qmemcpy((void *)0x400780, v7, 4 * v29);
    v9 = (void *)(4 * v29 + 4196224);
    LOWORD(v9) = 4 * v29 + 2024;
    qmemcpy(v9, &v7[v29 + 25], 4 * v31);
    v8();
    v10 = (_DWORD *)(v33 + 440);
    do
    {
      do
      {
        while ( 1 )
        {
          v11 = *v10;
          _CF = _bittestandreset(&v11, 0x1Fu);
          if ( !_CF )
            break;
          v12 = (_DWORD *)((char *)v35 + v10[1]);
          v13 = (_DWORD *)((char *)v35 + v10[2]);
          while ( v11 )
          {
            *v13-- = *v12--;
            --v11;
          }
          v10 += 3;
        }
        v10 += 4;
        v14 = *(v10 - 3);
      }
      while ( !v14 );
      v15 = (char *)v35 + *(v10 - 2);
      v34 = v10;
      v16 = (char *)v35 + v11;
      if ( v14 >= 0x10000 )
      {
        if ( v14 >= 0x40000 )
        {
          v32 = -32000;
          v30 = -1280;
        }
        else
        {
          v32 = -32384;
          v30 = -1664;
        }
      }
      else
      {
        v32 = -16288;
        v30 = -928;
      }
      BYTE4(v17) = 0;
      v18 = v14 - 1;
      *v15 = *v16;
      _ESI = v16 + 1;
      v19 = v15 + 1;
      while ( v18 > 0 )
      {
        v17 = sub_40A0EC(SBYTE4(v17), _ESI);
        if ( _CF )
        {
          a5 = 0;
          v21 = sub_40A14B(v17, _ESI);
          if ( v22 >= 3 )
          {
            do
            {
              v21 = sub_40A0EC(SBYTE4(v21), _ESI);
              LODWORD(v21) = v21 + _CF + (_DWORD)v21;
            }
            while ( v23 != 1 );
            a5 = (~(_DWORD)v21 < v32) + (~(_DWORD)v21 < v30) + 1;
          }
          v24 = sub_40A0EC(SBYTE4(v21), _ESI);
          v17 = sub_40A0EC(SBYTE4(v24), _ESI);
          v26 = v25 + _CF + v25;
          if ( !v26 )
          {
            v17 = sub_40A14B(v17, _ESI);
            v26 = v27 + 2;
          }
          v28 = a5 + v26;
          v18 -= v28;
          qmemcpy(v19, &v19[v17], v28);
          v19 += v28;
        }
        else
        {
          *v19 = *_ESI++;
          *v19++ ^= v18--;
        }
      }
      v10 = v34;
    }
    while ( !v18 );
    v5 = MEMORY[6];
    ((void (__cdecl *)(_DWORD, int, int, int))*MEMORY[6])(0, 58, 51, 16);
    v6 = ((unsigned __int64 (__cdecl *)(int))*(_DWORD *)(v5 + 12))(-1);
    ++a5;
    *(_DWORD *)v6 &= v6;
    __asm { outsd }
    if ( v5 != -1 )
      JUMPOUT(0x40A0AA);
  }
}
// 40A038: control flows out of bounds to 40A0AA
// 40A03E: control flows out of bounds to 40A0A1
// 40A093: variable 'v29' is possibly undefined
// 40A0A0: variable 'v31' is possibly undefined
// 40A0A5: variable 'v33' is possibly undefined
// 40A142: variable '_CF' is possibly undefined
// 40A165: variable 'v22' is possibly undefined
// 40A17A: variable 'v23' is possibly undefined
// 40A19C: variable 'v25' is possibly undefined
// 40A1A5: variable 'v27' is possibly undefined
// 40A000: using guessed type int dword_40A000[2];

//----- (0040A0EC) --------------------------------------------------------
__int64 __usercall sub_40A0EC@<edx:eax>(char a1@<dl>, _BYTE *a2@<esi>)
{
  __int64 result; // rax

  BYTE4(result) = 2 * a1;
  if ( !BYTE4(result) )
    BYTE4(result) = *a2 + (a2 != (_BYTE *)-1) + *a2;
  return result;
}

//----- (0040A14B) --------------------------------------------------------
__int64 __usercall sub_40A14B@<edx:eax>(__int64 result@<edx:eax>, _BYTE *a2@<esi>)
{
  __int64 v2; // rax
  char v3; // cf

  do
  {
    v2 = sub_40A0EC(SBYTE4(result), a2);
    result = sub_40A0EC(SBYTE4(v2), a2);
  }
  while ( v3 );
  return result;
}
// 40A158: variable 'v3' is possibly undefined

// nfuncs=3 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled
