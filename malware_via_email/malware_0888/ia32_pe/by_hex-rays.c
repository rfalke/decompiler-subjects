/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void start();
// int __usercall sub_4010CA@<eax>(int a1@<ecx>, int a2@<ebx>, _WORD *a3@<ebp>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8, int a9, int a10, int a11);
_DWORD nullsub_1(); // weak
void sub_401697();


//----- (00401005) --------------------------------------------------------
void start()
{
  JUMPOUT(0x401145);
}
// 401087: control flows out of bounds to 401145

//----- (004010CA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_4010CA@<eax>(
        int a1@<ecx>,
        int a2@<ebx>,
        _WORD *a3@<ebp>,
        int a4@<edi>,
        int a5@<esi>,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  _WORD *v11; // eax
  unsigned int i; // eax
  int v13; // ebp
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // edi
  int v19; // edi
  int v20; // eax
  unsigned __int16 v21; // cx
  unsigned int v22; // eax
  int v23; // esi
  int v24; // ebp
  __int16 v25; // bx
  int v26; // edx
  char *v27; // edx
  int v28; // esi
  int v29; // eax
  int v30; // ebp
  int j; // edi
  unsigned __int8 v32; // cl
  int v33; // ebx
  char v34; // dh
  _DWORD v36[2]; // [esp-8h] [ebp-150h]
  int v37; // [esp+0h] [ebp-148h]
  int *v38; // [esp+4h] [ebp-144h]
  int v39; // [esp+8h] [ebp-140h]
  int v40[64]; // [esp+Ch] [ebp-13Ch] BYREF
  _DWORD v41[2]; // [esp+10Ch] [ebp-3Ch] BYREF
  int *v42; // [esp+114h] [ebp-34h]
  int v43; // [esp+118h] [ebp-30h] BYREF
  int v44; // [esp+11Ch] [ebp-2Ch]
  int v45; // [esp+120h] [ebp-28h]
  int v46; // [esp+124h] [ebp-24h]
  int *v47; // [esp+128h] [ebp-20h]
  int v48; // [esp+12Ch] [ebp-1Ch]
  int v49; // [esp+130h] [ebp-18h]
  int v50; // [esp+134h] [ebp-14h]
  _WORD *v51; // [esp+138h] [ebp-10h]
  _WORD *v52; // [esp+13Ch] [ebp-Ch]
  _WORD *v53; // [esp+140h] [ebp-8h]
  int v55; // [esp+150h] [ebp+8h]

  v52 = a3;
  HIWORD(v11) = HIWORD(v53);
  HIWORD(v51) = 0;
  LOWORD(v11) = 0;
  LOWORD(a1) = *v11;
  LOWORD(v11) = 0;
  v53 = v11 + 12312;
  v52 = v11 + 13886;
  v51 = v11 + 12312;
  v50 = a5;
  v49 = a2;
  v48 = a4;
  v47 = 0;
  v46 = 0;
  v45 = 16711681;
  v44 = a4 - (a1 + 42418) + 2;
  v43 = 16711686;
  v13 = (int)a3 + 1;
  v42 = &v43;
  sub_401697();
  v47 = &v43;
  v46 = v14;
  v45 = v14;
  v44 = v14;
  (*(void (**)(void))(a2 + 24))();
  v43 = (*(int (**)(void))(a2 + 28))() + 6;
  v42 = (int *)v43;
  v55 = (unsigned __int16)(__readfsword(9 * v43 - 2) + 2) - 1;
  v41[1] = (*(int (**)(void))a2)();
  v41[0] = v15;
  v40[63] = (int)v41;
  v40[62] = 64;
  v48 = 0;
  v16 = (*(int (__cdecl **)(int, int *, int))(a2 - 4 + 16))(-1, v47, v50);
  v17 = __readfsdword(v16 + 47) + v16;
  v47 = (int *)((char *)v47 + *(_DWORD *)(v17 + 3));
  v50 ^= *(_DWORD *)(v17 + 3);
  v38 = v42;
  v39 = v46;
  v37 = v40[61];
  for ( i = 0; i < 0x100; ++i )
    *((_BYTE *)v40 + i) = i;
  v19 = v37;
  if ( (_BYTE)v52 != 121 )
  {
    v19 = (int)v51;
    do
    {
      (*(void (**)(void))(v19 + 24))();
      __asm { int     0; - internal hardware - DIVIDE ERROR }
      (*(void (**)(void))(v19 + 24))();
      (*(void (**)(void))(v19 + 24))();
      (*(void (**)(void))(v19 + 24))();
      (*(void (**)(void))(v19 + 24))();
      (*(void (**)(void))(v19 + 24))();
      v20 = (*(int (**)(void))(v19 + 16))() + 1;
    }
    while ( (unsigned __int16)v20 < v21 );
  }
  v37 = v13;
  v36[1] = v41;
  v36[0] = v19;
  v18 = v44;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  do
  {
    LOBYTE(v25) = *((_BYTE *)v40 + v24);
    v26 = v23 + (unsigned __int8)v25 + *(unsigned __int8 *)(v39 + v22);
    BYTE1(v26) = 0;
    ++v22;
    v23 = v26;
    if ( v22 >= v18 )
      v22 = 0;
    *((_BYTE *)v40 + v24++) = *((_BYTE *)v40 + v26);
    v27 = (char *)v40 + v26 - v22;
    HIBYTE(v25) = v27[v22 + 1];
    *(_WORD *)&v27[v22] = v25;
  }
  while ( BYTE1(v24) != 1 );
  v28 = 0;
  v29 = 0;
  v30 = v45;
  for ( j = (int)v38; v30; --v30 )
  {
    ++v29;
    BYTE1(v29) = 0;
    v32 = *((_BYTE *)v40 + v29);
    v33 = v28 + v32;
    BYTE1(v33) = 0;
    v34 = *((_BYTE *)&v36[5] + v33);
    *((_BYTE *)v40 + v29) = v34;
    *((_BYTE *)&v36[5] + v33) = v32;
    v28 = v33;
    *(_WORD *)(j++ - 1) ^= *(_WORD *)((char *)&v36[5] + (unsigned __int8)(v32 + v34)) << 8;
  }
  return ((int (__cdecl *)(int, int, int, int, int, int, _DWORD))nullsub_1)(a2, v55, a8, 589887373, a10, a11, 0);
}
// 4011E9: positive sp value 8 has been found
// 4010CA: could not find valid save-restore pair for esi
// 40121A: variable 'v14' is possibly undefined
// 4012A2: variable 'v15' is possibly undefined
// 401431: variable 'v21' is possibly undefined
// 401678: using guessed type _DWORD nullsub_1();

//----- (00401697) --------------------------------------------------------
void sub_401697()
{
  JUMPOUT(0x4014EE);
}
// 4016C5: control flows out of bounds to 4014EE

// nfuncs=4 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled
