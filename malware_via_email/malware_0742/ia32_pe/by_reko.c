// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_2 g_t402001 = // 00402001
	{
		&g_a4277
	};
Eq_106 g_t402005 = 0x5600; // 00402005
Eq_816 g_a402009[] = // 00402009
	{
	};
Eq_2 g_t4063F4 = // 004063F4
	{
		null
	};
word32 g_dw4063F8 = 0x00; // 004063F8
Eq_2 g_t4063FC = // 004063FC
	{
		null
	};
word32 g_dw406400 = 0x00; // 00406400
ptr32 g_ptr406404 = 0x00; // 00406404
word32 g_dw406408 = 0x00; // 00406408
Eq_2 g_t40640C = // 0040640C
	{
		null
	};
struct Eq_135 * g_ptr406410 = null; // 00406410
<anonymous> * g_ptr406414 = null; // 00406414
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetModuleHandleA = &g_t1A7C; // 00401000
<anonymous> * __imp__CreateFileA = &g_t1A90; // 00401004
<anonymous> * __imp__lstrcatA = &g_t1A9E; // 00401008
<anonymous> * __imp__GetProcAddress = &g_t1AAA; // 0040100C
<anonymous> * __imp__LoadLibraryA = &g_t1ABC; // 00401010
<anonymous> * __imp__CloseHandle = &g_t1ACC; // 00401014
<anonymous> * __imp__lstrcpyA = &g_t1ADA; // 00401018
<anonymous> * __imp__VirtualAlloc = &g_t1AE6; // 0040101C
// 00401040: void fn00401040(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00401300
//      fn004016F0
void fn00401040(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	g_t4063FC.u0 = 0x00;
	while (g_t4063FC.u0 < dwArg0C)
	{
		Mem23[dwArg04 + Mem9[0x004063FC<p32>:word32]:byte] = Mem9[dwArg08 + Mem9[0x004063FC<p32>:word32]:byte];
		g_t4063FC.u0 = (Eq_642 (*)[]) ((char *) g_t4063FC.u0 + 1);
	}
}

// 004010D0: Register Eq_20 Win32CrtStartup()
Eq_20 Win32CrtStartup()
{
	ptr32 fp;
	word32 ebx;
	word32 esi;
	word32 edi;
	struct Eq_25 * fs;
	Eq_26 tLoc74;
	GetProcAddress(LoadLibraryA(4219544), 0x00406280)();
	lstrcatA(&tLoc74, 0x004062A8);
	Eq_2 eax_65 = CreateFileA(&tLoc74, 0x01, 0x03, null, 0x03, 0x80, 0x00);
	if (eax_65 == ~0x00 || eax_65 == 0x00)
		return 0x00;
	if (GetProcAddress(LoadLibraryA(0x004062C4), 0x004062B8)() != 0x00 || (GetProcAddress)(LoadLibraryA(4219624), 4219612)() == 0x00)
		return 0x00;
	Eq_2 eax_130 = GetModuleHandleA(0x00);
	Eq_2 eax_135 = g_t402001.u0;
	Eq_106 edx_138 = g_t402005;
	Eq_2 dwLoc08_291 = 0x00;
	eax_151 = eax_135;
	while (true)
	{
		Eq_2 eax_151;
		if (dwLoc08_291 >= eax_135)
			break;
		GetModuleHandleA(0x00);
		dwLoc08_291.u1->dw402009 = dwLoc08_291.u1->dw402009 ^ 11152423;
		&eax_151.u0->u0 = (word32) dwLoc08_291 + 8;
		&dwLoc08_291.u0->u0 = (word32) dwLoc08_291 + 8;
	}
	fn004016C0(edx_138);
	g_t40640C.u0 = (Eq_642 (*)[]) eax_151;
	fn00401880(g_a402009, g_t40640C.u0, eax_135);
	g_dw406400 = edi;
	g_dw4063F8 = esi;
	g_dw406408 = ebx;
	g_ptr406410 = 24;
	g_ptr406404 = fp - 4;
	fn004016F0(4199081 - eax_130, eax_130);
	fn00401300(g_t40640C.u0);
	Eq_20 eax_223;
	g_ptr406414();
	return eax_223;
}

// 004012E0: void fn004012E0(Stack Eq_2 dwArg04, Stack Eq_30 dwArg08)
// Called from:
//      fn00401300
void fn004012E0(Eq_2 dwArg04, Eq_30 dwArg08)
{
	GetProcAddress(dwArg04, dwArg08);
}

// 00401300: void fn00401300(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00401300(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_26 tLocBC;
	lstrcpyA(&tLocBC, 0x0040630C);
	Eq_2 eax_18 = GetModuleHandleA(0x00406314);
	Eq_37 eax_26 = GetProcAddress(eax_18, 0x00406324);
	Eq_37 eax_34 = GetProcAddress(eax_18, 0x00406334);
	Eq_37 eax_42 = GetProcAddress(eax_18, 0x00406348);
	Eq_37 eax_50 = GetProcAddress(eax_18, 0x00406358);
	Eq_37 eax_58 = GetProcAddress(eax_18, 0x00406364);
	struct Eq_230 * edx_65 = &(dwArg04.u0 + (dwArg04.u1)->dw003C / 4)->u0;
	struct Eq_235 * dwLoc2C_498 = &edx_65->w0014 + 2 + (word32) edx_65->w0014 / 64;
	Eq_2 eax_84 = eax_42();
	fn00401040(eax_84, dwArg04, dwArg04.u1->dw003C + 0x0138 + (word32) edx_65->w0006 *s 0x28);
	up32 dwLoc10_504;
	for (dwLoc10_504 = 0x00; dwLoc10_504 < (word32) edx_65->w0006; ++dwLoc10_504)
	{
		if (dwLoc2C_498->dw0014 != 0x00 && dwLoc2C_498->dw0010 != 0x00)
			fn00401040(&(eax_84.u0 + dwLoc2C_498->dw000C / 4)->u0, &(dwArg04.u0 + dwLoc2C_498->dw0014 / 4)->u0, (uint32) ((uint64) (dwLoc2C_498->dw0010 - 1 + (edx_65->t003C).u0) /u (edx_65->t003C).u0) *s (edx_65->t003C).u0);
		++dwLoc2C_498;
	}
	struct Eq_267 * ecx_123 = &(eax_84.u0 + (eax_84.u1)->dw003C / 4)->u0;
	Eq_2 eax_143 = eax_34();
	struct Eq_274 * dwLocCC_512 = &(eax_84.u0 + ecx_123->dw0080 / 4)->u0;
	while (dwLocCC_512->dw0010 != 0x00)
	{
		word32 * dwLoc38_535;
		ui32 * dwLoc28_534;
		Eq_2 eax_319 = LoadLibraryA(&(eax_84.u0 + dwLocCC_512->dw000C / 4)->u0);
		if (dwLocCC_512->dw0000 != 0x00)
		{
			dwLoc28_534 = &(eax_84.u0 + dwLocCC_512->dw0000 / 4)->u0;
			dwLoc38_535 = &(eax_84.u0 + dwLocCC_512->dw0010 / 4)->u0;
		}
		else
		{
			dwLoc28_534 = &(eax_84.u0 + dwLocCC_512->dw0010 / 4)->u0;
			dwLoc38_535 = &(eax_84.u0 + dwLocCC_512->dw0000 / 4)->u0;
		}
		word32 dwLoc1C_538 = 0x00;
		if (dwLocCC_512->dw0010 != 0x00 && dwLocCC_512->dw0000 != 0x00)
			dwLoc1C_538 = 0x01;
		while (*dwLoc28_534 != 0x00)
		{
			if ((*dwLoc28_534 & 0x80000000) != 0x00)
			{
				ui32 eax_384 = *dwLoc28_534;
				fn004012E0(eax_319, eax_384 & 0x7FFFFFFF);
				*dwLoc28_534 = eax_384 & 0x7FFFFFFF;
			}
			else
			{
				Eq_30 eax_371 = &(eax_84.u0 + (*dwLoc28_534 + 2) / 4)->u0;
				fn004012E0(eax_319, eax_371);
				*dwLoc28_534 = (ui32) eax_371;
			}
			if (dwLoc1C_538 != 0x00)
				*dwLoc38_535 = *dwLoc28_534;
			++dwLoc28_534;
			++dwLoc38_535;
		}
		++dwLocCC_512;
	}
	g_t4063F4.u0 = (Eq_642 (*)[]) eax_58();
	ptr32 esp_176 = fp - 0x010C;
	if (g_t4063F4.u0 == 0x00)
	{
		ptr32 esp_189 = fp - 0x0110;
		if (eax_26() == 0x00)
		{
			esp_189 = fp - 0x011C;
			if (eax_50() == 0x00)
				return;
		}
		struct Eq_443 * esp_222 = esp_189 - 4;
		esp_222->dw0000 = ecx_123->dw0034;
		esp_222->dwFFFFFFFC = 0x00;
		esp_222->dwFFFFFFF8 = 0x00;
		esp_222->dwFFFFFFF4 = 0x00;
		esp_222->dwFFFFFFF0 = 0x22;
		esp_222->tFFFFFFEC.u0 = (Eq_642 (*)[]) eax_143;
		g_t4063F4.u0 = (Eq_642 (*)[]) eax_58();
		esp_176 = esp_222 - 20;
		if (g_t4063F4.u0 == 0x00)
		{
			esp_222->dwFFFFFFE8 = 0x40;
			esp_222->dwFFFFFFE4 = 0x3000;
			esp_222->tFFFFFFE0.u0 = ecx_123->t0050.u0;
			esp_222->dwFFFFFFDC = ecx_123->dw0034;
			g_t4063F4.u0 = (Eq_642 (*)[]) eax_42();
			esp_176 = esp_222 - 36;
		}
	}
	struct Eq_379 * esp_268 = esp_176 - 4;
	esp_268->t0000.u0 = (Eq_642 (*)[]) eax_143;
	CloseHandle(esp_268->t0000);
	esp_268->t0000.u0 = ecx_123->t0050.u0;
	esp_268->tFFFFFFFC.u0 = (Eq_642 (*)[]) eax_84;
	esp_268->tFFFFFFF8.u0 = g_t4063F4.u0;
	fn00401040(esp_268->tFFFFFFF8.u0, esp_268->tFFFFFFFC.u0, esp_268->t0000.u0);
	esp_268->t0000.u0 = g_t4063F4.u0;
	fn00401850(esp_268->t0000.u0);
	Mem300[0x00406414<p32>:word32] = Mem291[0x004063F4<p32>:word32] + Mem291[ecx_123 + 40:word32];
	ecx_123->ptr0028 = g_ptr406414;
}

// 004016C0: void fn004016C0(Stack Eq_106 dwArg04)
// Called from:
//      Win32CrtStartup
void fn004016C0(Eq_106 dwArg04)
{
	VirtualAlloc(null, dwArg04, 0x3000, 0x04);
}

// 004016F0: void fn004016F0(Stack word32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      Win32CrtStartup
void fn004016F0(word32 dwArg04, Eq_2 dwArg08)
{
	struct Eq_570 * edx_16 = &(dwArg08.u0 + (dwArg08.u1)->dw003C / 4)->u0;
	g_t4063F4.u0 = (Eq_642 (*)[]) GetProcAddress(GetModuleHandleA(0x00406384), 0x00406374)();
	if (g_t4063F4.u0 == 0x00)
		return;
	fn00401040(g_t4063F4.u0, dwArg08, edx_16->t0050.u0);
	int32 eax_66 = g_t4063F4.u0 - dwArg08;
	if (edx_16->dw00A4 != 0x00)
	{
		word32 dwLoc0C_173 = dwArg08 + Mem67[edx_16 + 0xA0:word32];
		while (dwLoc0C_173.u1->t0004.u0 != 0x00)
		{
			uint32 eax_101 = dwLoc0C_173.u1->t0004.u0 - 0x08 >> 0x01;
			word32 dwLoc20_179 = dwLoc0C_173 + 0x08;
			uint32 dwLoc08_180;
			for (dwLoc08_180 = 0x00; dwLoc08_180 < eax_101; ++dwLoc08_180)
			{
				if ((word32) *((word32) dwLoc20_179 + dwLoc08_180 * 0x02) >> 0x0C == 0x03)
					Mem141[Mem109[0x004063F4<p32>:word32] + Mem109[dwLoc0C_173 + 0x00:word32] + (CONVERT(dwLoc20_179[dwLoc08_180 * 0x02], word16, word32) & 0x0FFF):word32] = Mem109[Mem109[0x004063F4<p32>:word32] + Mem109[dwLoc0C_173 + 0x00:word32] + (CONVERT(dwLoc20_179[dwLoc08_180 * 0x02], word16, word32) & 0x0FFF):word32] + eax_66;
			}
			dwLoc0C_173 += Mem109[dwLoc0C_173 + 4:word32];
		}
	}
	<anonymous> * ecx_84 = &(g_t4063F4.u0 + dwArg04 / 4)->u0;
	ecx_84();
}

// 00401850: void fn00401850(Stack Eq_2 dwArg04)
// Called from:
//      fn00401300
void fn00401850(Eq_2 dwArg04)
{
	g_ptr406410->ptr0030->t0008.u0 = (Eq_642 (*)[]) dwArg04;
}

// 00401880: void fn00401880(Stack (ptr32 byte) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn00401880(byte * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_26 tLoc94;
	Eq_681 tLoc20;
	Eq_682 tLoc10;
	byte cl_12 = *dwArg04;
	lstrcpyA(&tLoc94, 4219844);
	Eq_2 dwLoc0C_143 = 0x01;
	int32 dwLoc18_148 = 0x00;
	do
	{
		byte cl_26 = Mem23[dwArg04 + dwLoc0C_143:byte];
		&dwLoc0C_143.u0->u0 = (word32) dwLoc0C_143 + 1;
		if ((word32) cl_26 == (word32) cl_12)
		{
			if ((word32) dwArg04[(word32) dwLoc0C_143 + 1] == 0x00)
			{
				&((word32) dwArg08 + dwLoc18_148)->u0->u0 = cl_12;
				++dwLoc18_148;
				&dwLoc0C_143.u0->u0 = (word32) dwLoc0C_143 + 2;
			}
			else
			{
				int32 eax_67 = fn004019B0(&tLoc10, dwArg04 + ((word32) dwLoc0C_143 + 1)) + ((word32) dwLoc0C_143 + 1);
				dwLoc0C_143 = fn004019B0(&tLoc20, dwArg04 + eax_67) + eax_67;
				up32 dwLoc1C_163;
				for (dwLoc1C_163 = 0x00; dwLoc1C_163 < tLoc10; ++dwLoc1C_163)
				{
					*((word32) dwArg08 + dwLoc18_148) = *((word32) dwArg08 + (dwLoc18_148 - tLoc20));
					++dwLoc18_148;
				}
			}
		}
		else
		{
			&((word32) dwArg08 + dwLoc18_148)->u0->u0 = cl_26;
			++dwLoc18_148;
		}
	} while (dwLoc0C_143 < dwArg0C);
	lstrcpyA(&tLoc94, 0x004063DC);
}

// 004019B0: Register word32 fn004019B0(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn00401880
word32 fn004019B0(ui32 * dwArg04, byte * dwArg08)
{
	Eq_26 tLoc84;
	lstrcpyA(&tLoc84, 0x00406394);
	ui32 dwLoc08_59 = 0x00;
	word32 dwLoc10_60 = 0x00;
	do
	{
		ui32 edx_22 = (word32) *dwArg08;
		ui32 edx_32 = edx_22 & 0x7F | dwLoc08_59 << 0x07;
		++dwArg08;
		dwLoc08_59 = edx_32;
		++dwLoc10_60;
	} while ((edx_22 & 0x80) != 0x00);
	lstrcpyA(&tLoc84, 0x004063AC);
	*dwArg04 = edx_32;
	return dwLoc10_60;
}

word32 g_dw401A58 = 0x1A7C; // 00401A58
word32 g_dw401A5C = 6800; // 00401A5C
word32 g_dw401A60 = 0x1A9E; // 00401A60
word32 g_dw401A64 = 0x1AAA; // 00401A64
word32 g_dw401A68 = 6844; // 00401A68
word32 g_dw401A6C = 0x1ACC; // 00401A6C
word32 g_dw401A70 = 0x1ADA; // 00401A70
word32 g_dw401A74 = 6886; // 00401A74
