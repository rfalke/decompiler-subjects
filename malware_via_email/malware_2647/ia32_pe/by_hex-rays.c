/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

LPVOID __stdcall sub_401000(int *, _BYTE *, DWORD, _DWORD *);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// LPVOID __userpurge start@<eax>(DWORD dwByteCount@<ecx>, _BYTE *ebx0@<ebx>, BYTE *esi0@<esi>, int, int, int, int);
void __stdcall sub_401349(int);
void __stdcall sub_401354(int);
void __stdcall sub_4013B3(int);

//-------------------------------------------------------------------------
// Data declarations

// extern DWORD (__stdcall *TraceDumpExA)(DWORD dwTraceID, DWORD dwFlags, LPBYTE lpbBytes, DWORD dwByteCount, DWORD dwGroupSize, BOOL bAddressPrefix, LPCSTR lpszPrefix);
// extern DWORD (__stdcall *TraceDumpExW)(DWORD dwTraceID, DWORD dwFlags, LPBYTE lpbBytes, DWORD dwByteCount, DWORD dwGroupSize, BOOL bAddressPrefix, LPCWSTR lpszPrefix);
// extern NTSTATUS (__stdcall *RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN NewValue, BOOLEAN ForThread, PBOOLEAN OldValue);
// extern NTSTATUS (__stdcall *NtSetSystemEnvironmentValue)(PUNICODE_STRING VariableName, PUNICODE_STRING Value);
// extern NTSTATUS (__stdcall *NtQuerySemaphore)(HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG Length, PULONG ReturnLength);
_UNKNOWN unk_415000; // weak


//----- (00401000) --------------------------------------------------------
LPVOID __stdcall sub_401000(int *a1, _BYTE *a2, DWORD a3, _DWORD *a4)
{
  LPVOID result; // eax
  int v5; // ebx
  char v6; // cf
  _DWORD *v7; // ecx

  if ( RtlAdjustPrivilege(0, 0, 0, 0) != -1073741727 )
    return VirtualAlloc(a1, (SIZE_T)a2, a3, (DWORD)a4);
  result = 0;
  if ( a3 )
  {
    v5 = *a1;
    LOBYTE(v5) = *a2 - *a4;
    *a1 = 0;
    sub_4013B3((int)a1);
    *v7 = v6 + *v7 - v5;
    JUMPOUT(0x4012AB);
  }
  return result;
}
// 4010F6: control flows out of bounds to 4012AB
// 4010CA: variable 'v6' is possibly undefined
// 4010CA: variable 'v7' is possibly undefined

//----- (00401102) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
LPVOID __userpurge start@<eax>(
        DWORD dwByteCount@<ecx>,
        _BYTE *ebx0@<ebx>,
        BYTE *esi0@<esi>,
        int a4,
        int a5,
        int a6,
        int a7)
{
  int v8; // eax
  DWORD v9; // edx
  unsigned int i; // [esp+0h] [ebp-1ACh]
  char v11[16]; // [esp+4h] [ebp-1A8h] BYREF
  _DWORD v12[61]; // [esp+14h] [ebp-198h] BYREF
  int *v13; // [esp+108h] [ebp-A4h]
  _BYTE *v14; // [esp+10Ch] [ebp-A0h]
  LPBYTE v15; // [esp+110h] [ebp-9Ch]
  _DWORD *v16; // [esp+114h] [ebp-98h]
  DWORD v17; // [esp+118h] [ebp-94h]
  BOOL v18; // [esp+11Ch] [ebp-90h]
  LPCWSTR v19; // [esp+120h] [ebp-8Ch]
  DWORD v20; // [esp+124h] [ebp-88h]
  DWORD v21; // [esp+128h] [ebp-84h]
  LPBYTE v22; // [esp+12Ch] [ebp-80h]
  DWORD v23; // [esp+130h] [ebp-7Ch]
  DWORD v24; // [esp+134h] [ebp-78h]
  BOOL v25; // [esp+138h] [ebp-74h]
  LPCSTR v26; // [esp+13Ch] [ebp-70h]
  DWORD v27; // [esp+140h] [ebp-6Ch]
  DWORD v28; // [esp+144h] [ebp-68h]
  LPBYTE v29; // [esp+148h] [ebp-64h]
  DWORD v30; // [esp+14Ch] [ebp-60h]
  DWORD v31; // [esp+150h] [ebp-5Ch]
  BOOL v32; // [esp+154h] [ebp-58h]
  LPCWSTR v33; // [esp+158h] [ebp-54h]
  DWORD v34; // [esp+15Ch] [ebp-50h]
  DWORD v35; // [esp+160h] [ebp-4Ch]
  LPBYTE v36; // [esp+164h] [ebp-48h]
  DWORD v37; // [esp+168h] [ebp-44h]
  DWORD v38; // [esp+16Ch] [ebp-40h]
  BOOL SemaphoreHandle; // [esp+170h] [ebp-3Ch] BYREF
  LPCSTR v40; // [esp+174h] [ebp-38h]
  DWORD v41; // [esp+178h] [ebp-34h]
  DWORD v42; // [esp+17Ch] [ebp-30h]
  LPBYTE v43; // [esp+180h] [ebp-2Ch]
  int *v44; // [esp+184h] [ebp-28h]
  SIZE_T dwSize; // [esp+188h] [ebp-24h] BYREF
  BOOL v46; // [esp+18Ch] [ebp-20h]
  const WCHAR *v47; // [esp+190h] [ebp-1Ch]
  DWORD v48; // [esp+194h] [ebp-18h]
  DWORD v49; // [esp+198h] [ebp-14h]
  char *v50; // [esp+19Ch] [ebp-10h]
  DWORD v51; // [esp+1A0h] [ebp-Ch]
  DWORD v52; // [esp+1A4h] [ebp-8h]
  BOOL v53; // [esp+1A8h] [ebp-4h]
  LPCSTR vars0; // [esp+1ACh] [ebp+0h] BYREF

  v16 = (_DWORD *)dwByteCount;
  v15 = esi0;
  v51 = 0;
  v14 = ebx0;
  v13 = (int *)&vars0;
  v40 = 0;
  if ( NtSetSystemEnvironmentValue(0, 0) == -1073741819 )
  {
    SemaphoreHandle = 0;
    v8 = NtQuerySemaphore(
           &SemaphoreHandle,
           (SEMAPHORE_INFORMATION_CLASS)&SemaphoreHandle,
           &SemaphoreHandle,
           (ULONG)&SemaphoreHandle,
           (PULONG)&SemaphoreHandle)
       + 1073741821;
    if ( v8 && v8 != 1 )
      sub_401000(v13, v14, (DWORD)v15, v16);
    if ( TraceDumpExA(0, 0, 0, 0, 0, 0, 0) == 87 )
    {
      v36 = 0;
      v51 += 2146436741;
      v9 = v51;
      v51 -= 2146436741;
      v48 = v51;
      v53 &= v51;
      v51 += v51 - (2140100229 - v9);
      v50 = v11;
      v44 = (_DWORD *)&unk_415000;
      v47 = (const WCHAR *)v12;
      v53 -= 48;
      v53 = ~v53;
      ++v53;
      v16 = (_DWORD *)&unk_415000;
      v15 = (LPBYTE)v53;
      v14 = (_BYTE *)v51;
      sub_401354((int)v11);
      dwSize = *(_DWORD *)v50 + *((_DWORD *)v50 + 1);
      v48 = 0;
      v52 = (DWORD)VirtualAlloc(0, (SIZE_T)&dwSize, 0x3000u, 0x40u);
      v46 = 0x400000;
      for ( i = 0; i < *((_DWORD *)v50 + 2); ++i )
      {
        v13 = v44;
        v12[60] = *((_DWORD *)v47 + 1);
        v12[59] = *(_DWORD *)v47 + v46;
        sub_401349(v48 + v52);
        v48 += *((_DWORD *)v47 + 1);
        v47 += 4;
      }
      JUMPOUT(0x401362);
    }
  }
  else
  {
    __debugbreak();
    TraceDumpExW((DWORD)v13, (DWORD)v14, v15, (DWORD)v16, v17, v18, v19);
    TraceDumpExA(v20, v21, v22, v23, v24, v25, v26);
    TraceDumpExW(v27, v28, v29, v30, v31, v32, v33);
    TraceDumpExA(v34, v35, v36, v37, v38, SemaphoreHandle, v40);
    TraceDumpExW(v41, v42, v43, (DWORD)v44, dwSize, v46, v47);
    TraceDumpExA(v48, v49, (LPBYTE)v50, v51, v52, v53, vars0);
  }
  return sub_401000((int *)a4, (_BYTE *)a5, a6, (_DWORD *)a7);
}
// 401162: positive sp value 94 has been found
// 401049: control flows out of bounds to 40104C
// 4012D5: control flows out of bounds to 401362
// 40125E: bad sp value at call

//----- (00401349) --------------------------------------------------------
void __stdcall sub_401349(int a1)
{
  JUMPOUT(0x401000);
}
// 40134E: control flows out of bounds to 401000

//----- (00401354) --------------------------------------------------------
void __stdcall sub_401354(int a1)
{
  JUMPOUT(0x401000);
}
// 40135C: control flows out of bounds to 401000
// 4013B0: unbalanced stack, ignored a potential tail call

//----- (004013B3) --------------------------------------------------------
void __stdcall sub_4013B3(int a1)
{
  ;
}

// nfuncs=6 queued=5 decompiled=5 lumina nreq=0 worse=0 better=0
// ALL OK, 5 function(s) have been successfully decompiled
