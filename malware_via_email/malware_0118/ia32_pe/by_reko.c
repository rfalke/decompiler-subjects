// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_5 g_t405000 = null; // 00405000
word32 g_dw405004 = 0x00; // 00405004
<anonymous> * g_ptr405AA8 = null; // 00405AA8
word32 g_dw406BA0 = 0x00; // 00406BA0
word32 g_dw406BCC = 0x00; // 00406BCC
word16 g_w406BD0 = 0x00; // 00406BD0
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__CloseHandle = &g_t40DC; // 00404000
<anonymous> * __imp__CreateEventA = &g_t40EA; // 00404004
<anonymous> * __imp__CreateMutexA = &g_t40FA; // 00404008
<anonymous> * __imp__EnterCriticalSection = &g_t410A; // 0040400C
<anonymous> * __imp__FreeLibrary = &g_t4122; // 00404010
<anonymous> * __imp__GetCommandLineA = &g_t4130; // 00404014
<anonymous> * __imp__GetFileSize = &g_t4142; // 00404018
<anonymous> * __imp__GetModuleFileNameA = &g_t4150; // 0040401C
<anonymous> * __imp__GetPrivateProfileStringA = &g_t4166; // 00404020
<anonymous> * __imp__GlobalLock = &g_t4182; // 00404024
<anonymous> * __imp__LoadLibraryA = &g_t4190; // 00404028
<anonymous> * __imp__DestroyWindow = &g_t41AE; // 00404030
<anonymous> * __imp__DrawFocusRect = &g_t41BE; // 00404034
<anonymous> * __imp__MessageBoxA = &g_t41CE; // 00404038
<anonymous> * __imp__MessageBoxW = &g_t41DC; // 0040403C
<anonymous> * __imp__PostQuitMessage = &g_t41EA; // 00404040
<anonymous> * __imp__SendDlgItemMessageW = &g_t41FC; // 00404044
<anonymous> * __imp__TranslateMessage = &g_t4212; // 00404048
word32 g_dw40408C = 0x40DC; // 0040408C
word32 g_dw404090 = 16618; // 00404090
word32 g_dw404094 = 0x40FA; // 00404094
word32 g_dw404098 = 0x410A; // 00404098
word32 g_dw40409C = 0x4122; // 0040409C
word32 g_dw4040A0 = 16688; // 004040A0
word32 g_dw4040A4 = 0x4142; // 004040A4
word32 g_dw4040A8 = 0x4150; // 004040A8
word32 g_dw4040AC = 0x4166; // 004040AC
word32 g_dw4040B0 = 16770; // 004040B0
word32 g_dw4040B4 = 0x4190; // 004040B4
word32 g_dw4040BC = 16814; // 004040BC
word32 g_dw4040C0 = 0x41BE; // 004040C0
word32 g_dw4040C4 = 16846; // 004040C4
word32 g_dw4040C8 = 16860; // 004040C8
word32 g_dw4040CC = 0x41EA; // 004040CC
word32 g_dw4040D0 = 0x41FC; // 004040D0
word32 g_dw4040D4 = 0x4212; // 004040D4
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn00402764
//      fn0040298D
//      Win32CrtStartup
void fn00401000(Eq_2 dwArg04, word32 dwArg08)
{
	if (g_t405000 == null)
		g_t405000 = LoadLibraryA("ntdll");
	if (g_dw405004 == 0x00)
		g_dw405004 = fn00401091(g_t405000, 2517111233);
	if (fn00401091(LoadLibraryA(dwArg04), dwArg08) == 0x00)
		int3();
}

// 0040105B: Register word32 fn0040105B(Stack (ptr32 byte) dwArg04)
// Called from:
//      fn00401091
word32 fn0040105B(byte * dwArg04)
{
	byte * edi_33 = dwArg04;
	byte bl_40 = 0x00;
	word24 ebx_24_8_51 = 0x00;
	uint8 cl_36 = 0x00;
	do
	{
		word32 ebx_52 = SEQ(ebx_24_8_51, bl_40 ^ *edi_33);
		for (cl_36 = cl_36 ^ *edi_33; cl_36 >= 0x20; cl_36 -= 0x20)
			;
		word32 ebx_54 = __rol<word32,byte>(ebx_52, cl_36);
		++edi_33;
		bl_40 = (byte) ebx_54;
		ebx_24_8_51 = SLICE(ebx_54, word24, 8);
	} while (*edi_33 != 0x00);
	return ebx_54;
}

// 00401091: Register word32 fn00401091(Stack Eq_5 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn00401000
word32 fn00401091(Eq_5 dwArg04, word32 dwArg08)
{
	word32 eax;
	if (dwArg04 == null)
		return eax;
	word32 dwLoc18_110 = 0x00;
	int32 v8_13 = dwArg04[0x0F];
	if (dwArg04[v8_13 / 4] == 0x4550)
	{
		word32 ecx_20 = dwArg04[(v8_13 + 0x0078) / 4];
		if (ecx_20 != 0x00)
		{
			struct Eq_95 * ecx_26 = dwArg04 + ecx_20 / 4;
			ui32 v14_27 = ecx_26->dw0018;
			word32 eax_39[] = dwArg04 + ecx_26->dw001C / 4;
			Eq_255 edi_44[] = dwArg04 + ecx_26->dw0024 / 4;
			word32 * esi_50 = dwArg04 + ecx_26->dw0020 / 4;
			ui32 dwLoc08_120 = v14_27;
			do
			{
				if (fn0040105B(dwArg04 + *esi_50 / 4) == dwArg08)
				{
					dwLoc18_110 = dwArg04 + eax_39[(edi_44)[v14_27 - dwLoc08_120].dw0000 & 0xFFFF] / 4;
					return dwLoc18_110;
				}
				ui32 v19_95 = dwLoc08_120 - 0x01;
				++esi_50;
				dwLoc08_120 = v19_95;
			} while (v19_95 != 0x00);
		}
	}
	return dwLoc18_110;
}

// 0040161D: void fn0040161D()
// Called from:
//      Win32CrtStartup
void fn0040161D()
{
}

word32 g_dw401B20 = 0x0C09EDCD; // 00401B20
word32 g_dw401DDD = 1770834613; // 00401DDD
word32 g_dw40222C = 1597688813; // 0040222C
// 00402764: Register (ptr32 code) fn00402764(Register (ptr32 code) eax)
// Called from:
//      Win32CrtStartup
<anonymous> * fn00402764(<anonymous> * eax)
{
	fn00401000("kernel32", g_dw402766);
	if (eax != null)
		eax();
	return g_dw40222C ^ 188;
}

word32 g_dw402766 = 15548435; // 00402766
// 0040298D: void fn0040298D(Register (ptr32 code) eax)
// Called from:
//      Win32CrtStartup
void fn0040298D(<anonymous> * eax)
{
	fn00401000("advapi32", g_dw401DDD);
	<anonymous> * eax_26 = eax;
	if (eax != null)
		eax();
	if (eax_26 == null)
		return;
	g_ptr405AA8 = eax_26;
}

// 0040306F: Register Eq_168 Win32CrtStartup()
Eq_168 Win32CrtStartup()
{
	<anonymous> * eax;
	fn0040298D(eax);
	struct Eq_173 * esp_10 = (struct Eq_173 *) <invalid>;
	esp_10->ptrFFFFFFFC = null;
	fn0040161D();
	struct Eq_173 * esp_20 = (struct Eq_173 *) <invalid>;
	esp_20->ptrFFFFFFFC = (<anonymous> *) 0x01;
	Eq_168 eax_29 = fn00402764(esp_20->ptrFFFFFFFC);
	esp_20->ptrFFFFFFFC = (<anonymous> *) 0x0400;
	esp_20->dwFFFFFFF8 = 0x00406EE0;
	esp_20->dwFFFFFFF4 = 0x00;
	esp_20->dwFFFFFFF0 = g_dw401B20;
	esp_20->tFFFFFFEC = (Eq_2) "kernel32";
	fn00401000(esp_20->tFFFFFFEC, esp_20->dwFFFFFFF0);
	Eq_168 eax_60 = eax_29;
	if (eax_29 != null)
		eax_29();
	g_dw406BA0 = 0x44;
	g_dw406BCC = 0x01;
	g_w406BD0 = 0x02;
	return eax_60;
}

