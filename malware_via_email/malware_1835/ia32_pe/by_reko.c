// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct HINSTANCE__ g_t400000 = // 00400000
	{
		9460301,
	};
// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct HMENU__ g_t402000 = // 00402000
	{
		-0x09F5D549,
	};
// 00404A00: Register word32 fn00404A00(Register word32 ecx)
// Called from:
//      Win32CrtStartup
word32 fn00404A00(word32 ecx)
{
	Eq_4 tLoc08;
	tLoc08 = (Eq_4) ecx;
	fn00405BAE(&tLoc08);
	return tLoc08;
}

// 00404A13: Register word32 fn00404A13()
// Called from:
//      Win32CrtStartup
word32 fn00404A13()
{
	ptr32 fp;
	word32 dwLoc0174;
	word32 dwLocDC;
	word32 dwLoc08;
	word32 dwLoc01C0;
	word32 dwLoc0124;
	word32 dwLoc2C;
	dwLoc98_867 = 0x1F;
	while (true)
	{
		dwLoc98_868 = ϕ(dwLoc98_867, dwLoc98_992);
		if (dwLoc98_868 == 0x00)
			break;
		if (dwLoc98_868 == 0x2B)
			SetPixel((struct HDC__ *) 0x1D2D, dwLoc2C, 0x5A64, 0x00);
		dwLoc98_992 = dwLoc98_868 - 0x01;
	}
	edx_39 = (union Eq_939 *) ~0x100F;
	v15_41 = g_dw412D83 - 4271483;
	g_dw412D83 = v15_41;
	g_t412D8B.u0 = (int32) 4271347;
	v16_48 = g_t412D8B.u0 ^ 0x00412CFF;
	g_t412D8B.u0 = (int32) v16_48;
	v17_52 = g_t412D8B.u0 + 4271335;
	g_t412D8B.u0 = (int32) v17_52;
	esi_60 = 13610;
	edi_65 = 0x2529;
	eax_70 = g_ptr412E38;
	v23_72 = *eax_70 + 0x14;
	*eax_70 = v23_72;
	dwLoc0174_883 = dwLoc0174;
	Mem81 = Mem73;
	eax_82 = g_ptr412E9C;
	v24_83 = *eax_82 | 0x1A;
	*eax_82 = v24_83;
	g_ptr410474 = null;
	dwLoc0C_887 = (struct Eq_97 *) 0x03;
	do
	{
		dwLoc0C_889 = ϕ(dwLoc0C_887, dwLoc0C_890);
		Mem113 = ϕ(Mem112, Mem134);
		eax_114 = g_dw410080;
		if (eax_114 != 0x00)
			break;
		al_128 = dwLoc0C_889->b410495;
		al_130 = (al_128 ^ 0x5A) + 44;
		v31_131 = (struct Eq_97 *) ((char *) dwLoc0C_889 + 1);
		dwLoc0C_890 = v31_131;
		dwLoc0C_889->b410495 = al_130;
	} while (v31_131 < (struct Eq_97 *) 0x12);
	eax_140 = ~0x1002;
	do
	{
		eax_147 = ϕ(eax_140, eax_187);
		eax_149 = eax_147 ^ 13610;
		ecx_150 = eax_149 * 0x02 + 0x4A52;
		dwLoc0C_894 = ecx_150;
		ebx_152 = g_dw412D57;
		ecx_153 = g_ptr412EF4;
		ebx_154 = ebx_152 & *ecx_153;
		g_dw412D57 = ebx_154;
		cx_159 = ecx_150->w410478 ^ 0x032A;
		dwLocA8_895 = 0x00;
		while (true)
		{
			dwLocA8_896 = ϕ(dwLocA8_895, dwLocA8_985);
			esp_755 = fp - 0x38;
			eax_185 = ϕ(eax_149, eax_801);
			if (dwLocA8_896 >= 0x19)
				break;
			if (dwLocA8_896 == 0x1A)
				eax_758 = GetTextAlign((struct HDC__ *) 0x174C);
			eax_801 = ϕ(eax_185, eax_758);
			dwLocA8_985 = dwLocA8_896 + 0x01;
		}
		ebx_173 = ecx_150;
		ecx_174 = (word32) (cx_159 + 0x0229);
		cx_175 = (word16) ecx_174;
		ecx_150->w410480 = cx_175;
		ecx_179 = (union Eq_939 *) ~0x2527;
		v36_180 = g_dw412D0F - 4271567;
		g_dw412D0F = v36_180;
		v37_182 = g_dw412D0F ^ 4271411;
		g_dw412D0F = v37_182;
		eax_186 = (word32) eax_185 + 1;
		eax_187 = eax_186 ^ 13610;
	} while ((eax_186 ^ 13610) != ~0x100F);
	dwLoc1C_899 = ~0x1002;
	do
	{
		dwLoc0124_1236 = ϕ(dwLoc0124, dwLoc0124_1249);
		dwLoc1C_973 = ϕ(dwLoc1C_899, dwLoc1C_980);
		dwLoc0C_955 = ϕ(dwLoc0C_894, dwLoc0C_1285);
		dwLoc08_908 = ϕ(dwLoc08, dwLoc08_1079);
		edx_849 = ϕ(edx_39, edx_378);
		ecx_846 = ϕ(ecx_179, ecx_533);
		esi_455 = ϕ(esi_60, esi_390);
		ebx_321 = ϕ(ebx_173, ebx_374);
		esp_304 = ϕ(esp_755, esp_375);
		edi_204 = ϕ(edi_65, edi_393);
		ebp_198 = fp - 4;
		Mem192 = ϕ(Mem191, Mem536);
		eax_193 = g_dw410080;
		if (eax_193 != 0x00)
			break;
		eax_200 = g_ptr4102C4;
		eax_201 = eax_200->ptr000C;
		if (*eax_201 == null)
		{
			if (edi_204 < 34151)
				edx_215 = fp - 636;
			else
				edx_207 = dwLocDC;
			edx_632 = ϕ(edx_215, edx_207);
			ecx_232 = dwLoc08_908;
			eax_233 = 0x00;
			dwLoc08_909 = 0x00;
			dwLoc08_912 = 0x00010000;
			eax_242 = g_ptr410038;
			eax_243 = *eax_242;
			eax_244 = *eax_243;
			eax_250 = *eax_244 & 0xFFFF0000;
			dwLoc28_914 = eax_250;
			dwLoc0C_915 = fp - 40;
			ax_257 = *eax_250;
			ax_260 = ax_257 - 0x0229;
			while (true)
			{
				dwLoc28_1348 = ϕ(dwLoc28_914, dwLoc28_1349);
				ax_271 = ϕ(ax_260, ax_291);
				ax_273 = ax_271 ^ 0x032A;
				if (ax_273 == 0x5B0E)
					break;
				v48_280 = dwLoc28_1348 - 0x00010000;
				dwLoc28_1349 = v48_280;
				ax_287 = *v48_280;
				ax_291 = ax_287 - 0x0229;
			}
			ecx_293 = g_ptr4102C4;
			ecx_295 = ecx_293->ptr000C;
			*ecx_295 = (word16 **) dwLoc28_1348;
		}
		dwLoc0C_1287 = ϕ(dwLoc0C_955, dwLoc0C_915);
		dwLoc08_1084 = ϕ(dwLoc08_908, dwLoc08_912);
		eax_301 = g_ptr41010C;
		eax_302 = *eax_301;
		esp_307 = esp_304 - 4;
		esp_307->dw0000 = 0x00410498;
		esp_307->dwFFFFFFFC = eax_302;
		esp_307->dwFFFFFFF8 = 0x02;
		esp_307->dwFFFFFFF4 = 0x00410190;
		esp_307->dwFFFFFFF0 = eax_302;
		v68_317 = g_dw410550;
		esp_307->dwFFFFFFEC = v68_317;
		g_ptr41054C();
		dwLocF0_925 = 0x00;
		while (true)
		{
			dwLocF0_926 = ϕ(dwLocF0_925, dwLocF0_982);
			Mem339 = ϕ(Mem334, Mem752);
			if (dwLocF0_926 >= 0x10)
				break;
			if (dwLocF0_926 == 0x13)
			{
				esp_326->tFFFFFFFC = (Eq_1019) &g_dw412D8F;
				esp_326->tFFFFFFF8 = eax_327;
				GetClientRect(esp_326->tFFFFFFF8, esp_326->tFFFFFFFC);
			}
			dwLocF0_982 = dwLocF0_926 + 0x01;
		}
		eax_342 = g_ptr4102C4;
		eax_343 = eax_342->ptr000C;
		esp_326->dw0014 = 0x004104DC;
		v71_349 = (word16 *) *eax_343;
		esp_326->ptr0010 = v71_349;
		eax_327();
		g_dw4104D8 = eax_356;
		ecx_362 = ~0x1002;
		dwLoc0C_1285 = ϕ(dwLoc0C_953, dwLoc0C_1287);
		dwLoc0124_1249 = ϕ(dwLoc0124_1234, dwLoc0124_1236);
		dwLoc08_1079 = ϕ(dwLoc08_1080, dwLoc08_1084);
		edi_393 = ϕ(edi_504, edi_204);
		esi_390 = ϕ(esi_506, esi_455);
		ecx_382 = ϕ(ecx_519, ecx_362);
		esp_367 = ϕ(esp_512, esp_355);
		esp_368 = esp_367 - 4;
		*esp_368 = (struct Eq_143 **) (struct Eq_143 *) 0x5F;
		ebx_374 = (struct Eq_143 *) *esp_368;
		esp_375 = (struct Eq_135 *) ((char *) esp_368 + 4);
		edx_378 = (uint32) (0x0002CB36 % ebx_374);
		if (edx_378 <= (union Eq_939 *) 0x87 && ecx_382 != ~0x1032)
		{
			ebx_391 = ecx_382 ^ esi_390;
			ecx_392 = esi_390 ^ ~0x100E;
			ecx_394 = ecx_392 + edi_393;
			edx_eax_397 = (uint64) (ebx_391 + 0x2529);
			edx_399 = (uint32) (edx_eax_397 % ecx_394);
			dwLoc18_934 = ~0x1002;
			edx_402 = edx_399 << 0x03;
			dwLoc0C_935 = edx_399 << 0x03;
			dwLoc08_1082 = dwLoc08_1079;
			dwLoc0124_939 = dwLoc0124_1249;
			dwLoc18_937 = dwLoc18_934;
			dwLoc0C_936 = dwLoc0C_935;
			edx_634 = edx_402;
			ebx_475 = ebx_391;
			edi_470 = edi_393;
			esi_443 = esi_390;
			esp_408 = esp_375;
			esp_409 = esp_408 - 4;
			*esp_409 = dwLoc0C_936;
			v63_411 = g_dw412DBF & 4271507;
			g_dw412DBF = v63_411;
			v64_414 = g_dw412DBF + 0x00412DDF;
			g_dw412DBF = v64_414;
			fn00405F99(*esp_409);
			esp_421 = esp_409 + 1;
			SCZO_423 = cond(dwLoc01C0 - 32241);
			C_436 = SLICE(SCZO_423, bool, 1);
			if (dwLoc01C0 <= 32241)
			{
				SCZO_427 = cond(dwLoc0124_939 >> 0x01);
				C_437 = SLICE(SCZO_427, bool, 1);
				dwLoc0124_940 = dwLoc0124_939 >> 0x01;
			}
			dwLoc0124_1254 = ϕ(dwLoc0124_939, dwLoc0124_940);
			C_435 = ϕ(C_436, C_437);
			Mem432 = ϕ(Mem431, Mem428);
			eax_433.u0 = g_t412D37.u0;
			eax_438 = __rcr<word32,byte>(eax_433, 0x01, C_435);
			g_t412D37.u0 = (ui32) eax_438;
			eax_444 = esi_443 ^ ~0x100D;
			ecx_446 = dwLoc18_937 ^ esi_443;
		}
		eax_532 = esi_390 ^ ~0x100D;
		ecx_533 = dwLoc1C_973 ^ esi_390;
		eax_534 = &ecx_533->u0 + (eax_532 + 0x2529);
		eax_535 = eax_534 ^ esi_390;
		dwLoc1C_980 = eax_535;
	} while (eax_535 != ~0x11F2);
	edx_848 = ϕ(edx_849, edx_378);
	ecx_845 = ϕ(ecx_846, ecx_533);
	esp_844 = ϕ(esp_304, esp_375);
	edi_843 = ϕ(edi_204, edi_393);
	esi_842 = ϕ(esi_455, esi_390);
	ebp_841 = fp - 4;
	Mem840 = ϕ(Mem192, Mem536);
	ebx_539 = ~0x1109;
	do
	{
		edx_630 = ϕ(edx_848, edx_851);
		ecx_625 = ϕ(ecx_845, ecx_847);
		esp_578 = ϕ(esp_844, esp_725);
		edi_573 = ϕ(edi_843, edi_715);
		esi_569 = ϕ(esi_842, esi_706);
		ebp_563 = ϕ(ebp_841, ebp_697);
		Mem549 = ϕ(Mem840, Mem698);
		ebx_540 = ϕ(ebx_539, ebx_722);
		if (ebx_540 == ~0x1022)
		{
			eax_695 = (word32 *) (&ebp_563->dwFFFFFFF4 + 4);
			g_ptr410474 = eax_695;
			goto l00405215;
		}
		edx_629 = ϕ(edx_630, edx_631);
		ecx_624 = ϕ(ecx_625, ecx_451);
		esp_577 = ϕ(esp_578, esp_488);
		edi_572 = ϕ(edi_573, edi_467);
		esi_568 = ϕ(esi_569, esi_453);
		ebp_562 = ϕ(ebp_563, ebp_457);
		Mem548 = ϕ(Mem549, Mem461);
		ebx_543 = ϕ(ebx_540, ebx_472);
		switch (ebx_543)
		{
		case ~0x100C:
			ebp_562->dwFFFFFEB4 = 0x00;
			do
			{
				Mem598 = ϕ(Mem593, Mem610);
				eax_599 = ebp_562->dwFFFFFEB4;
				ebp_562->dwFFFFFEB4 = eax_599 + 0x01;
				if (ebp_562->dwFFFFFEB4 == 0x1F)
				{
					esp_605 = esp_577 - 4;
					*esp_605 = 12668;
					GetKeyState(*esp_605);
				}
				esp_728 = esp_577;
				Mem610 = ϕ(Mem606, Mem601);
			} while (ebp_562->dwFFFFFEB4 < 0x13);
			eax_613 = g_ptr410474;
			if (eax_613 == null)
				goto l004051E7;
			ebp_562->dwFFFFFDF8 = 0xDF51;
			if (ebp_562->dwFFFFFDF8 > 61265)
			{
				ecx_654 = ebp_562->dwFFFFFEEC;
				eax_655 = g_ptr412EFC;
				ecx_657 = ecx_654 + *eax_655 + (word32) (ebp_562->dwFFFFFDF8 < 61265);
				ebp_562->dwFFFFFEEC = ecx_657;
				ecx_660 = g_dw412D6F;
				eax_661 = ebp_562->dwFFFFFEA8;
				eax_663 = eax_661 - ecx_660 - (word32) (ecx_657 < 0x00);
				ebp_562->dwFFFFFEA8 = eax_663;
				eax_665 = g_dw412D67;
				ecx_666 = ebp_562->dwFFFFFEA0;
				eax_667 = eax_665 - ecx_666;
				g_dw412D67 = eax_667;
			}
			Mem670 = ϕ(Mem651, Mem669);
			eax_671 = g_ptr410474;
			if (ebp_562->dwFFFFFDD8 >= 22007)
			{
				ecx_679 = g_ptr412EF0;
				ecx_680 = *ecx_679;
				v58_681 = ebp_562->dwFFFFFE04 - ecx_680;
				ebp_562->dwFFFFFE04 = v58_681;
			}
			else
			{
				ecx_675 = ebp_562->dwFFFFFD68;
				ebp_562->dwFFFFFD68 = ecx_675 - 0x01;
			}
			Mem685 = ϕ(Mem682, Mem678);
			ecx_686 = ebp_562->dwFFFFFED0;
			v60_687 = ebp_562->dwFFFFFED8 | ecx_686;
			ebp_562->dwFFFFFED8 = v60_687;
			ecx_690 = g_ptr4100F0;
			v61_692 = &ecx_690->u0 + *eax_671;
			*eax_671 = v61_692;
			break;
		case ~0x11C2:
			eax_550 = g_ptr412EE8;
			v49_551 = *eax_550 - 0x22;
			*eax_550 = v49_551;
			eax_554 = g_dw410488;
			g_dw4102FC = eax_554;
			esp_576 = ϕ(esp_577, esp_304);
			edi_571 = ϕ(edi_572, edi_204);
			esi_567 = ϕ(esi_568, esi_455);
			ebp_561 = ϕ(ebp_562, ebp_198);
			Mem556 = ϕ(Mem555, Mem298);
			eax_557 = g_dw41048C;
			g_dw410300 = eax_557;
			eax_559 = g_dw410490;
			g_dw410304 = eax_559;
			eax_564 = ebp_561 - 40;
			g_dw4102F8 = eax_564;
			eax_579 = fn004059B9(esi_567, edi_571, esp_576->dwFFFFFFFC, out edx_583, out ebx_580, out esi_584, out edi_582);
			ecx_590 = g_ptr410494;
			ecx_590->u0 = (DWORD) eax_579;
			break;
		default:
l004051E7:
			esp_729 = esp_577;
			Mem619 = ϕ(Mem610, Mem548);
			eax_620 = ebp_562->ptrFFFFFFF0;
			ecx_636 = ebp_562->dwFFFFFE6C;
			v65_638 = g_dw412D73 + ecx_636 + (word32) (ecx_624 < edx_629);
			g_dw412D73 = v65_638;
			ecx_640 = ebp_562->ptrFFFFFFE4;
			ecx_642 = *ecx_640;
			ecx_643 = ecx_642 - eax_620 *s 0x00051501;
			eax_644 = ebp_562->ptrFFFFFFF0;
			ecx_645 = ecx_643 | eax_644;
			eax_646 = g_ptr412EB4;
			v66_647 = *eax_646 << 0x01;
			*eax_646 = v66_647;
			ebp_562->ptrFFFFFFF0 = ecx_645;
			break;
		}
l00405215:
		edx_851 = ϕ(edx_630, edx_629, edx_629, edx_583);
		ecx_847 = ϕ(ecx_625, ecx_690, ecx_645, ecx_590);
		esp_725 = ϕ(esp_578, esp_728, esp_729, esp_576);
		edi_715 = ϕ(edi_573, edi_572, edi_572, edi_582);
		esi_706 = ϕ(esi_569, esi_568, esi_568, esi_584);
		ebx_700 = ϕ(ebx_540, ebx_543, ebx_543, ebx_580);
		Mem698 = ϕ(Mem696, Mem693, Mem650, Mem591);
		ebp_697 = ϕ(ebp_563, ebp_562, ebp_562, ebp_561);
		eax_699 = ebp_697->dwFFFFFFF4;
		ebx_712 = ebx_700 ^ esi_706;
		eax_713 = eax_699 ^ esi_706;
		ebx_714 = ebx_712 - eax_713;
		ebx_721 = ebx_714 - edi_715;
		ebx_722 = ebx_721 ^ esi_706;
	} while (ebx_722 != ~0x100D);
	esp_731 = (word32 *) (&esp_725->dwFFFFFFFC + 2);
	esi_732 = *esp_731;
	return esi_732;
}

// 00405233: Register ui32 fn00405233(Register up32 ebx, Register word32 esi, Register up32 edi, Stack (ptr32 Eq_247) dwArg04, Stack (ptr32 word32) dwArg08, Register out (ptr32 Eq_1073) edxOut)
// Called from:
//      fn00405C69
ui32 fn00405233(up32 ebx, word32 esi, up32 edi, struct Eq_247 * dwArg04, word32 * dwArg08, struct Eq_1073 & edxOut)
{
	ptr32 fp;
	up32 dwLoc40;
	ui32 dwLoc60;
	up32 dwLoc48;
	word32 dwLoc24;
	struct Eq_1073 * edx;
	ptr32 esp_200 = fp - 0x10;
	word32 eax_11 = ~0x100D;
	word32 dwLoc38_208;
	for (dwLoc38_208 = 0x1A; dwLoc38_208 != 0x00; --dwLoc38_208)
	{
		if (dwLoc38_208 == 0x29)
		{
			eax_11 = COMCTL32.dll!ImageList_Destroy(dwLoc24);
			edx = edx_188;
			esp_200 = esp_185;
		}
	}
	word32 eax_160;
	g_dw412D2B = g_dw412D2B - *g_ptr412EA8 - (word32) (edi < dwLoc40);
	int32 ecx_39 = g_dw4100E0;
	struct Eq_1112 * esp_42 = esp_200 - 4;
	esp_42->dw0000 = esi;
	g_dw412DBB &= dwLoc60;
	esp_42->dwFFFFFFFC = edi;
	int32 eax_55 = (eax_11 ^ 13610) + 0x2529;
	if (eax_55 != ecx_39)
	{
		g_t412D9B.u0 = (ui32) (g_t412D9B.u0 ^ g_dw412D7B);
		if (*dwArg04->ptr0034 != 0x00)
		{
			struct Eq_247 * eax_97 = g_ptr4102C4;
			edx = (struct Eq_1073 *) *eax_97->ptr0008;
			g_dw412D27 = __ror<word32,byte>(g_dw412D27, 0x01);
			word32 ecx_106 = Mem103[Mem103[edx + 60:word32] + 40 + edx:word32] + edx;
			if (eax_97->dw003C != 0x00)
			{
				esp_42->dwFFFFFFF8 = g_dw4100E4;
				g_dw412DCF = g_dw412DCF - g_dw412DD3 - (word32) (ebx < dwLoc48);
				esp_42->dwFFFFFFF4 = g_dw4100E0;
				struct Eq_1073 ** eax_125 = g_ptr4102C4->ptr0008;
				esp_42->ptrFFFFFFF0 = (struct Eq_1073 *) *eax_125;
				g_dw412D7F += 4271451;
				g_dw412D7F |= 4271551;
				word32 eax_140;
				ecx_106();
				*dwArg08 = eax_140;
			}
			g_ptr4100F0 = null;
			g_dw4100F4 = 0x00;
			eax_160 = eax_11;
l004053D7:
			edxOut = edx;
			return (eax_160 ^ 13610) + 0x2529;
		}
	}
	g_dw412D13 -= g_dw412DC3;
	eax_160 = ~0x1002;
	goto l004053D7;
}

// 004053E1: Register ui32 fn004053E1(Register ui32 ecx, Register ptr32 edx, Register word32 esi, Register ptr32 edi, Register out ptr32 ediOut)
// Called from:
//      fn00407197
ui32 fn004053E1(ui32 ecx, ptr32 edx, word32 esi, ptr32 edi, ptr32 & ediOut)
{
	ptr32 fp;
	ui32 dwLoc017C;
	word32 dwLoc2C;
	word32 dwLoc0164;
	uint32 dwLoc02E0;
	word32 dwLoc0324;
	word32 dwLoc0208;
	word32 dwLoc018C;
	ptr32 esp_31 = fp - 0x5C;
	up32 dwLocC0_561 = 0x00;
	do
	{
		dwLocC0_561 = dwLocC0_1074 + 0x01;
		if (dwLocC0_561 == 44)
		{
			COMCTL32.dll!ImageList_Remove(0x87C8, dwLoc2C);
			esp_31 = esp_38;
			edx = edx_41;
			ecx = ecx_40;
		}
		dwLocC0_1074 = dwLocC0_561;
	} while (dwLocC0_1074 < 0x1B);
	struct Eq_1270 * esp_72 = esp_31 - 4;
	esp_72->dw0000 = esi;
	esp_72->ptrFFFFFFFC = edi;
	g_dw412CE7 -= 0x4BF60000;
	struct Eq_1284 * esp_534 = esp_72 - 4;
	word32 esi_103;
	ui32 ecx_1020;
	if (fn004063B0(ecx, edx, 13610, out ecx_1020, out esi_103) != 0x00)
	{
		fn00406276();
		word32 ecx_123 = g_dw4102D8;
		Eq_137 eax_130 = g_t4102D4.u0;
		g_dw412DB7 = g_dw412DB7 ^ *g_ptr412EEC;
		g_dw412CEF = g_dw412CEF ^ 0x4B2D;
		ui32 * edx_167 = g_ptr412E3C;
		*edx_167 |= dwLoc017C;
		uint32 dwLoc2C_585 = (esi_103 ^ ~0x100D) + 0x2529;
		up32 dwLoc0120_624 = 0x00;
		do
		{
			struct Eq_1284 * esp_196 = esp_31 - 8;
			dwLoc0120_624 = dwLoc0120_1075 + 0x01;
			if (dwLoc0120_624 == 0x17)
			{
				esp_196->tFFFFFFFC = (struct tagOFNA *) 0x4361;
				GetOpenFileNameA(esp_196->tFFFFFFFC);
			}
			esp_534 = esp_196;
			dwLoc0120_1075 = dwLoc0120_624;
		} while (dwLoc0120_1075 < 0x13);
		ui32 eax_205 = ~0x1002;
		ecx_1020 = ecx_123 + ~0x2528 ^ esi_103;
		if (~0x1002 - ecx_1020 != (esi_103 ^ ~0x1002) + 0x2529)
		{
			do
			{
				g_dw412D53 -= dwLoc0164;
				ui32 eax_250 = eax_205 ^ esi_103;
				byte cl_263 = Mem260[((esi_103 ^ ~0x100D) + 0x2529) *s (eax_250 + 0x2529) + eax_130:byte];
				Mem280[((esi_103 ^ ~0x100D) + 0x2529) *s (eax_250 + 0x2529) + eax_130:byte] = 0x00;
				ui32 dwLoc10_645 = 0x01;
				do
				{
					word32 * ecx_297 = (fp - 88)[dwLoc10_645 & 0x03];
					struct Eq_1284 * ebx_300 = dwLoc10_645 + ~0x2528 ^ esi_103;
					*ecx_297 = ebx_300 + *ecx_297 / 4;
					ui32 v36_303 = dwLoc10_645 + 0x01;
					dwLoc10_645 = v36_303;
				} while (v36_303 != 11);
				g_t412D9B.u0 = (ui32) 4271415;
				g_t412D9B.u0 = (ui32) (g_t412D9B.u0 & 0x00412D4F);
				g_t412D9B.u0 = (ui32) (g_t412D9B.u0 - 4271459);
				g_t412D17.u0 = (ui32) (g_t412D17.u0 + g_dw412CF3 + (word32) (ebx_300 < esp_196));
				g_dw412D1F = g_dw412D1F ^ 4271411;
				g_dw412D1F -= 4271535;
				g_dw412D1F |= 4271571;
				byte cl_329 = cl_263 - ((byte) esi_103 ^ ~0x2A) - 0x29;
				if (dwLoc2C_585 != (esi_103 ^ ~0x1002) + 0x2529)
				{
					g_dw412D3B = g_dw412D3B - dwLoc0324 - (word32) (dwLoc2C_585 < dwLoc02E0);
					g_dw412D0B += 4271483;
					g_dw412D0B = g_dw412D0B ^ 4271443;
				}
				uint32 eax_449 = ((word32) (((byte) esi_103 ^ ~0x2A) + 0x29 + cl_329) ^ 0x5A) + 44;
				byte bLoc05_682 = (byte) eax_449;
				g_dw412D3F = g_dw412D3F - dwLoc0208 - (word32) (eax_449 > ~0x100D);
				int32 dwLoc30_702 = (eax_205 ^ esi_103) + 0x2529;
				Mem480[((esi_103 ^ ~0x100D) + 0x2529) *s dwLoc30_702 + eax_130:byte] = Mem461[((esi_103 ^ ~0x100D) + 0x2529) *s dwLoc30_702 + eax_130:byte] ^ bLoc05_682;
				word32 * ecx_491 = g_ptr412F20;
				*ecx_491 += dwLoc018C;
				g_dw412D77 = g_dw412D77 ^ g_dw412D47;
				eax_205 = (esi_103 ^ ~0x100D) + 0x2529 + eax_250 ^ esi_103;
				esp_534 = esp_196;
				ecx_1020 = (esi_103 ^ ~0x1002) + 0x2529;
			} while (eax_205 - ecx_1020 != (esi_103 ^ ~0x1002) + 0x2529);
		}
	}
	ediOut = esp_534->ptr0000;
	return ecx_1020;
}

// 004059B9: Register word32 fn004059B9(Register word32 esi, Register int32 edi, Stack word32 dwArg00, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404A13
word32 fn004059B9(word32 esi, int32 edi, word32 dwArg00, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_1556 dwLoc10;
	g_dw412D13 |= g_dw412DC7;
	g_dw4100DC = g_dw4102FC;
	word32 dwLoc28_155 = 0x15;
	while (true)
	{
		if (dwLoc28_155 == 0x1E)
			PageSetupDlgW(dwLoc10);
		--dwLoc28_155;
	}
}

// 00405B8A: void fn00405B8A(Register (ptr32 Eq_1578) eax)
// Called from:
//      Win32CrtStartup
void fn00405B8A(struct Eq_1578 * eax)
{
	g_ptr4104F4 = (word32 *) ((char *) eax + 4);
	g_dw4104E8 = eax->dw0008;
	g_dw4104EC = eax->dw000C;
	g_dw4104F0 = eax->dw0010;
}

// 00405BAE: void fn00405BAE(Register (ptr32 word32) esi)
// Called from:
//      fn00404A00
void fn00405BAE(word32 * esi)
{
	if (wcslen(&g_b410510) != 0x06)
		*esi = 0x03;
	else
	{
		LoadAcceleratorsA(*g_ptr41004C, &g_t410520);
		*esi = 0x01;
	}
}

// 00405C69: Register word32 fn00405C69(Register word32 esi, Register up32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn004059B9
word32 fn00405C69(word32 esi, up32 edi, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	struct Eq_1631 * fp;
	word32 dwLocB8;
	up32 dwLoc3C;
	Eq_939 dwLoc18;
	word32 * eax_10 = g_ptr4102EC;
	word32 dwLoc60_169;
	for (dwLoc60_169 = 0x18; dwLoc60_169 != 0x00; --dwLoc60_169)
	{
		if (dwLoc60_169 == 0x23)
			HeapReAlloc(dwLoc18, dwLoc18, (void *) 12822, ~0x100D);
	}
	<anonymous> * eax_20 = g_ptr4102F4;
	g_dw412DAB += dwLocB8;
	up32 ebx_32 = g_dw4102F0;
	ptr32 edx_52;
	word32 eax_48 = fn00405233(ebx_32, esi, edi, g_ptr4102C4, eax_10, out edx_52);
	g_dw412D1B += 0x2427;
	if (eax_48 == 0x00)
	{
		word32 edi_82;
		word32 esi_83;
		fn00407197(0x00, edx_52, 13610, dwLoc3C, g_ptr4102C4, ebx_32, eax_20, 203270, out esi_83, out edi_82);
	}
	else
	{
		Mem114 = Mem62;
		byte * ebx_115 = g_ptr412E50;
		*ebx_115 = __ror<byte,byte>(*ebx_115, 0x09);
		ptr32 edi_123 = fp->ptrFFFFFFD8;
		ptr32 esi_129 = fp->ptrFFFFFFDC;
		ptr32 ebx_131 = fp->ptrFFFFFFE0;
		edxOut = edx_52;
		ebxOut = ebx_131;
		esiOut = esi_129;
		ediOut = edi_123;
		return 0x01;
	}
}

// 00405DCA: void fn00405DCA(Stack (ptr32 word32) dwArg04, Stack up32 dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      fn004059B9
void fn00405DCA(word32 * dwArg04, up32 dwArg08, <anonymous> * dwArg0C)
{
	Eq_939 dwLoc1C;
	Eq_1734 eax_11 = (struct HBITMAP__ *) ~0x1002;
	do
	{
		up32 dwLoc18_175 = 0x00;
		do
		{
			++dwLoc18_175;
			if (dwLoc18_175 == 0x1C)
			{
				dwLoc18_175 = 0x00412D2B;
				dwLoc1C.u0 = 7117;
				eax_11 = CreateDIBSection((struct HDC__ *) 9689, (BITMAPINFO *) 6086, 7117, &g_dw412D2B, dwLoc1C, dwLoc1C);
			}
		} while (dwLoc18_175 < 22);
		Eq_1758 edx_56 = (char *) &eax_11->unused + 1;
		g_dw412D87 = g_dw412D87 ^ 0x1C88;
		int32 * edx_74 = *((char *) g_a4100C4 + (edx_56 & 0x03) * 0x04);
		*edx_74 = *edx_74 *s eax_11 *s ~0x200F;
		g_dw412D57 -= 4271523;
		g_dw412D57 = g_dw412D57 ^ 4271431;
		g_dw412D57 -= 0x00412D1B;
		ui32 * edx_97 = *((char *) g_a4100C4 + (eax_11 - (struct HBITMAP__ *) 1 & 0x03) * 0x04);
		*edx_97 = *edx_97 ^ (eax_11 *s ~0x200C | eax_11);
		if (eax_11 == (struct HBITMAP__ *) ~0x1022)
			g_ptr4102EC = dwArg04;
		else if (eax_11 == (struct HBITMAP__ *) ~0x11C2)
		{
			g_ptr412D2F = 0x00412D8F;
			g_dw4102F0 = dwArg08;
		}
		else if (eax_11 == (struct HBITMAP__ *) ~0x1182)
		{
			g_dw412D83 -= *g_ptr412EB0;
			g_ptr4102F4 = dwArg0C;
		}
		ui32 eax_135 = eax_11 ^ 13610;
		word32 * edx_146 = *((char *) g_a4100C4 + ((eax_135 + 0x01 ^ 13610) & 0x03) * 0x04);
		*edx_146 += (eax_135 + 0x01 ^ 13610) *s ~0x200D ^ (eax_135 + 0x01 ^ 13610);
		ui32 * edx_154 = *((char *) g_a4100C4 + ((eax_135 + 0x01 ^ 13610) - 2 & 0x03) * 0x04);
		*edx_154 |= (eax_135 + 0x01 ^ 13610) *s ~0x200E;
		eax_11 = eax_135 + 0x01 ^ 13610;
	} while ((eax_135 + 0x01 ^ 13610) != ~0x1132);
}

// 00405F99: void fn00405F99(Stack ui32 dwArg04)
// Called from:
//      fn00404A13
void fn00405F99(ui32 dwArg04)
{
	Eq_1011 dwLoc24;
	word32 esi_13;
	for (esi_13 = 0x50; esi_13 != 0x00; --esi_13)
	{
		switch (esi_13)
		{
		case 0x30:
			word32 dwLoc44_132;
			for (dwLoc44_132 = 0x1C; dwLoc44_132 != 0x00; --dwLoc44_132)
			{
				if (dwLoc44_132 == 0x24)
					GetWindowTextA(dwLoc24, &g_dw412DC3, 32427);
			}
			if (g_dw4104A8 == 0x00)
			{
				struct Eq_247 * eax_73 = g_ptr4102C4;
				word16 ** eax_79 = eax_73->ptr000C;
				word32 eax_89;
				g_ptr41054C();
				g_dw4104A8 = eax_89;
			}
			break;
		case 0x20:
			g_t412D37.u0 = (ui32) 4271499;
			g_t412D37.u0 = (ui32) (g_t412D37.u0 - 0x00412D07);
			break;
		}
	}
}

// 00406097: Register Eq_939 Win32CrtStartup()
Eq_939 Win32CrtStartup()
{
	word32 * fp;
	word32 ecx;
	up32 dwLoc68;
	uint16 wArg04;
	real64 * ptrArg08;
	Eq_939 eax_131;
	if (fn00404A00(ecx) != 0x03)
	{
		fn00407324();
		g_ptr4104F4 = fp;
		word32 dwLoc28_161;
		for (dwLoc28_161 = 0x11; dwLoc28_161 != 0x00; --dwLoc28_161)
		{
			if (dwLoc28_161 == 0x15)
				wsprintfW(&g_t412F2C, &g_t41304F, 0x00);
		}
		fn00405B8A(fp - 4);
		g_dw410488 = g_dw4104E8;
		g_dw41048C = g_dw4104EC;
		ui8 * eax_67 = g_ptr412EB4;
		*eax_67 += 0x46;
		g_dw410490 = g_dw4104F0;
		g_ptr410494 = fp - 8;
		Eq_939 eax_75 = GetCurrentProcessId();
		word16 eax_16_16_191 = SLICE(eax_75, word16, 16);
		if (eax_75 == 0x00)
		{
			g_dw412D7B = g_dw412D7B ^ 4271459;
			g_dw412D7B += 4271423;
			g_dw412D7B |= 0x00412D23;
			ExitThread(0x00);
			return SEQ(eax_16_16_191, dKcbwEplR(wArg04, ptrArg08));
		}
		else
		{
			g_dw412D03 = g_dw412D03 - g_dw412CFB - (word32) (dwLoc68 < fn00404A13());
			ui32 * eax_116 = g_ptr412EFC;
			Eq_939 ecx_114 = g_ptr410494->u0;
			*eax_116 &= 26828;
			g_ptr4100F0 = g_dw4100F4 ^ g_ptr4100F0;
			word32 * eax_125 = g_ptr4104F4;
			*eax_125 = &g_ptr4100F0->u0 + *eax_125;
			eax_131 = ecx_114;
			return eax_131;
		}
	}
	else
	{
		eax_131.u0 = 0x00;
		return eax_131;
	}
}

// 00406230: Register uint16 dKcbwEplR(Stack uint16 wArg04, Stack (ptr32 real64) ptrArg08)
// Called from:
//      Win32CrtStartup
uint16 dKcbwEplR(uint16 wArg04, real64 * ptrArg08)
{
	g_dw412DB3 |= *g_ptr412F00;
	g_dw412D63 &= *g_ptr412E8C;
	g_dw412D97 += *g_ptr412EF8;
	return <invalid>;
}

// 00406276: void fn00406276()
// Called from:
//      fn004053E1
void fn00406276()
{
	ptr32 fp;
	word32 dwLoc24;
	ptr32 esp_39 = fp - 0x10;
	up32 dwLoc44_142 = 0x00;
	do
	{
		dwLoc44_142 = dwLoc44_180 + 0x01;
		if (dwLoc44_142 == 0x1B)
		{
			COMCTL32.dll!CreateStatusWindowW(0x229F, 4272233, dwLoc24, 0x4C52);
			esp_39 = esp_50;
		}
		dwLoc44_180 = dwLoc44_142;
	} while (dwLoc44_180 < 0x15);
	g_t412D17.u0 = (ui32) (g_t412D17.u0 & 0x00412DDB);
	struct Eq_247 * edx_84 = g_ptr4102C4;
	struct Eq_2123 * esp_88 = esp_39 - 4;
	esp_88->ptr0000 = fp - 0x0C;
	esp_88->dwFFFFFFFC = 0x40;
	esp_88->dwFFFFFFF8 = g_dw4102D8;
	esp_88->tFFFFFFF4.u0 = g_t4102D4.u0;
	esp_88->dwFFFFFFF0 = 0x04;
	esp_88->dwFFFFFFEC = (char *) &edx_84->dw003C + 0x00FE;
	esp_88->ptrFFFFFFE8 = (word16 *) *edx_84->ptr000C;
}

// 004063B0: Register word32 fn004063B0(Register ui32 ecx, Register ptr32 edx, Register word32 esi, Register out ptr32 ecxOut, Register out ptr32 esiOut)
// Called from:
//      fn004053E1
word32 fn004063B0(ui32 ecx, ptr32 edx, word32 esi, ptr32 & ecxOut, ptr32 & esiOut)
{
	word32 dwLoc80;
	Eq_137 eax_105 = g_ptr410070->u0;
	up32 dwLoc3C_124;
	for (dwLoc3C_124 = 0x00; dwLoc3C_124 < 0x1F; ++dwLoc3C_124)
	{
		if (dwLoc3C_124 == 0x28)
			eax_105 = GetDlgItemInt((struct HWND__ *) 0x4424, 0x1262, &g_dw412D7F, 0x00);
	}
	g_ptr412D2F -= *g_ptr412E5C;
	g_dw412D8F = g_dw412D8F ^ dwLoc80;
	g_t4102D4.u0 = (HMENU) eax_105;
}

// 00406D1F: Register ui32 fn00406D1F(Register ui32 ebx, Register word32 esi, Register int32 edi, Stack (ptr32 Eq_143) dwArg04, Stack (ptr32 Eq_703) dwArg08, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404A13
ui32 fn00406D1F(ui32 ebx, word32 esi, int32 edi, struct Eq_143 * dwArg04, struct Eq_703 * dwArg08, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 dwLoc01F8;
	ui32 dwLoc01AC;
	word32 dwLoc0164;
	up32 dwLoc0240;
	ui32 dwLoc01C8;
	int32 dwLoc14;
	Eq_137 dwLoc10;
	int32 eax_10 = dwArg08->dw410458;
	g_dw412D87 += dwLoc01F8;
	up32 dwLoc8C_424 = 0x00;
	eax_394 = eax_10;
	while (true)
	{
		int32 eax_394;
		if (dwLoc8C_424 >= 0x15)
			break;
		if (dwLoc8C_424 == 0x25)
			eax_394 = GetMenuStringA(dwLoc10, dwLoc10, &g_t412D33, dwLoc14, 28481);
		++dwLoc8C_424;
	}
	ui32 eax_67 = eax_394 ^ 13610;
	word32 * edi_83 = g_ptr412F10;
	*edi_83 += g_dw412D53;
	g_dw412DA7 &= dwLoc01AC;
	g_dw412DBB = g_dw412DBB ^ *g_ptr412EB0;
	g_a410308[(eax_67 + 0x2529) * 0x02] = 0x00;
	ui32 * eax_113 = g_ptr412ED4;
	*eax_113 = *eax_113 ^ dwLoc0164;
	g_dw412CFB -= 0x0D8B;
	word32 * edx_178 = g_ptr412EF8;
	*edx_178 = *edx_178 - 5152 - (word32) (dwLoc0240 > 23543);
	g_dw412DB3 |= dwLoc01C8;
	byte * ecx_236 = g_ptr412E40;
	*ecx_236 += 0x15;
}

// 00407197: Register ptr32 fn00407197(Register word32 ecx, Register ptr32 edx, Register ptr32 edi, Stack up32 dwArg00, Stack (ptr32 Eq_247) dwArg04, Stack up32 dwArg08, Stack (ptr32 code) dwArg0C, Stack up32 dwArg10, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00405C69
//      fn00407197
ptr32 fn00407197(word32 ecx, ptr32 edx, ptr32 edi, up32 dwArg00, struct Eq_247 * dwArg04, up32 dwArg08, <anonymous> * dwArg0C, up32 dwArg10, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	word32 dwLoc68;
	Eq_137 dwLoc28;
	ptr32 * esp_11 = fp - 0x0C;
	if (dwArg10 == 550007)
	{
		dwArg0C();
		goto l004072BF;
	}
	switch (dwArg10)
	{
	case 0x00060421:
		up32 dwLoc48_217;
		for (dwLoc48_217 = 0x00; dwLoc48_217 < 22; ++dwLoc48_217)
		{
			if (dwLoc48_217 == 33)
				SetMenu((struct HWND__ *) 14997, dwLoc28);
		}
		ecx = 0x00;
		if (*g_ptr4102C4->ptr000C != null)
		{
			ecx = 0x00;
			if (g_dw410080 == 0x00)
				ecx = fn004053E1(0x00, edx, 550007, edi, out edi);
		}
		break;
	case 203270:
	default:
		goto l004072BF;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	up32 stackArg0 = <invalid>;
	up32 stackArg16 = <invalid>;
	word32 esi_324;
	word32 edi_325;
	edx = fn00407197(ecx, edx, edi, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg16, out esi_324, out edi_325);
	esp_11 = fp - 0x0C;
l004072BF:
	union Eq_939 * eax_167 = g_ptr4100F0;
	g_dw412D3B -= dwLoc68;
	ptr32 esi_178 = *esp_11;
	g_dw412DCB = g_dw412DCB + 0x00412DDF + (word32) (&eax_167->u0 + dwArg00 < fp - 4);
	g_dw412DCB |= 4271523;
	esiOut = esi_178;
	ediOut = edi;
	return edx;
}

// 00407324: void fn00407324()
// Called from:
//      Win32CrtStartup
void fn00407324()
{
	g_dw4104E8 = g_dw4104E8 ^ g_dw4104E8;
	g_dw4104EC = g_dw4104EC ^ g_dw4104EC;
	g_dw4104F0 = g_dw4104F0 ^ g_dw4104F0;
	g_ptr4104F4 = g_ptr4104F4;
}

<anonymous> g_t407357 = <code>; // 00407357
// subject_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 * g_ptr410028 = &g_dw401030; // 00410028
ui32 ** g_ptr410034 = &g_ptr410028; // 00410034
ui32 *** g_ptr410038 = &g_ptr410034; // 00410038
Eq_1611 g_t410040 = &g_t400000; // 00410040
HINSTANCE * g_ptr41004C = &g_t410040; // 0041004C
Eq_137 g_t410058 = // 00410058
	{
		&g_t402000
	};
union Eq_137 * g_ptr410070 = &g_t410058; // 00410070
struct Eq_1073 * g_ptr41007C = null; // 0041007C
word32 g_dw410080 = 0x00; // 00410080
int32 * g_a4100C4[] = // 004100C4
	{
	};
ui32 g_dw4100DC = 0x00; // 004100DC
int32 g_dw4100E0 = 0; // 004100E0
word32 g_dw4100E4 = 0x00; // 004100E4
word32 g_dw4100E8 = 0x00; // 004100E8
union Eq_939 * g_ptr4100F0 = null; // 004100F0
word32 g_dw4100F4 = 0x00; // 004100F4
word32 g_dw4100F8 = 0x00; // 004100F8
Eq_247 g_t410100 = // 00410100
	{
		&g_ptr41007C,
		&g_ptr4100F8,
		&g_dw4100E8,
		0x00,
	};
word32 * g_ptr41010C = &g_dw4100F8; // 0041010C
struct Eq_247 * g_ptr4102C4 = &g_t410100; // 004102C4
Eq_137 g_t4102D4 = // 004102D4
	{
		&g_t5456465
	};
word32 g_dw4102D8 = 0x0547574A; // 004102D8
word32 * g_ptr4102EC = &g_dw6546404; // 004102EC
up32 g_dw4102F0 = 6624259; // 004102F0
<anonymous> * g_ptr4102F4 = &g_tE61A67; // 004102F4
word32 g_dw4102F8 = 0x00077716; // 004102F8
ui32 g_dw4102FC = 0x06751716; // 004102FC
ui32 g_dw410300 = 395030; // 00410300
ui32 g_dw410304 = 0x07655767; // 00410304
word16 g_a410308[] = // 00410308
	{
	};
word32 * g_ptr410474 = &g_dw342501; // 00410474
ui32 g_dw410488 = 488800; // 00410488
ui32 g_dw41048C = 0x00077777; // 0041048C
ui32 g_dw410490 = 141969018; // 00410490
union Eq_939 * g_ptr410494 = &g_t42404; // 00410494
word32 g_dw4104A8 = 0x00; // 004104A8
word32 g_dw4104D8 = 0x00; // 004104D8
ui32 g_dw4104E8 = 7894548; // 004104E8
ui32 g_dw4104EC = 3478994; // 004104EC
ui32 g_dw4104F0 = 144131914; // 004104F0
word32 * g_ptr4104F4 = &g_dw76860436; // 004104F4
char g_b410510 = 'g'; // 00410510
CHAR g_t410520 = 'g'; // 00410520
<anonymous> * g_ptr41054C = &g_t407357; // 0041054C
word32 g_dw410550 = 0x004064D1; // 00410550
word32 g_dw412CE7 = 0x00104D71; // 00412CE7
ui32 g_dw412CEF = 0x00105064; // 00412CEF
int32 g_dw412CF3 = 1078244; // 00412CF3
byte g_b412CF7 = 0xCC; // 00412CF7
word32 g_dw412CFB = 0x00106791; // 00412CFB
word32 g_dw412D03 = 0x0010730E; // 00412D03
byte g_b412D07 = 0x1F; // 00412D07
ui32 g_dw412D0B = 0x00102461; // 00412D0B
ui32 g_dw412D0F = 0x00102F2C; // 00412D0F
ui32 g_dw412D13 = 0x00105A42; // 00412D13
Eq_707 g_t412D17 = // 00412D17
	{
		0x00102A0E
	};
word32 g_dw412D1B = 0x00106D30; // 00412D1B
ui32 g_dw412D1F = 1071911; // 00412D1F
word32 g_dw412D27 = 1070027; // 00412D27
word32 g_dw412D2B = 0x001042FE; // 00412D2B
ptr32 g_ptr412D2F = 0x001060F3; // 00412D2F
CHAR g_t412D33 = '\x97'; // 00412D33
Eq_882 g_t412D37 = // 00412D37
	{
		0x00101092
	};
word32 g_dw412D3B = 0x001035A0; // 00412D3B
word32 g_dw412D3F = 0x00102264; // 00412D3F
ui32 g_dw412D43 = 0x0010497D; // 00412D43
word32 g_dw412D47 = 1067126; // 00412D47
word32 g_dw412D53 = 0x0010105E; // 00412D53
ui32 g_dw412D57 = 0x00101C60; // 00412D57
ui32 g_dw412D5B = 0x00100545; // 00412D5B
word32 g_dw412D5F = 1064649; // 00412D5F
ui32 g_dw412D63 = 1058005; // 00412D63
word32 g_dw412D67 = 1060181; // 00412D67
ui8 g_b412D6B = ~0x61; // 00412D6B
word32 g_dw412D6F = 1067608; // 00412D6F
word32 g_dw412D73 = 0x00106C9A; // 00412D73
ui32 g_dw412D77 = 1075447; // 00412D77
ui32 g_dw412D7B = 1075747; // 00412D7B
ui32 g_dw412D7F = 0x001064C6; // 00412D7F
ui32 g_dw412D83 = 0x0010179B; // 00412D83
ui32 g_dw412D87 = 1081167; // 00412D87
Eq_29 g_t412D8B = // 00412D8B
	{
		1068621
	};
ui32 g_dw412D8F = 1080051; // 00412D8F
word32 g_dw412D97 = 0x001065C9; // 00412D97
Eq_1141 g_t412D9B = // 00412D9B
	{
		0x00104664
	};
byte g_b412D9F = 0x5E; // 00412D9F
word32 g_dw412DA3 = 1080901; // 00412DA3
ui32 g_dw412DA7 = 0x00100B80; // 00412DA7
word32 g_dw412DAB = 0x00106FAA; // 00412DAB
word32 g_dw412DAF = 0x0010318A; // 00412DAF
ui32 g_dw412DB3 = 0x00102B03; // 00412DB3
ui32 g_dw412DB7 = 0x001022BC; // 00412DB7
ui32 g_dw412DBB = 0x00106AD6; // 00412DBB
ui32 g_dw412DBF = 0x001031A7; // 00412DBF
word32 g_dw412DC3 = 0x0010390E; // 00412DC3
ui32 g_dw412DC7 = 1057721; // 00412DC7
ui32 g_dw412DCB = 1074115; // 00412DCB
word32 g_dw412DCF = 0x00105B6E; // 00412DCF
word32 g_dw412DD3 = 0x00106545; // 00412DD3
word32 g_dw412DD7 = 0x00106CAB; // 00412DD7
byte * g_ptr412E38 = &g_b412CEF; // 00412E38
ui32 * g_ptr412E3C = &g_dw412CF3; // 00412E3C
byte * g_ptr412E40 = &g_b412CF7; // 00412E40
byte * g_ptr412E50 = &g_b412D07; // 00412E50
word32 * g_ptr412E5C = &g_dw412D13; // 00412E5C
ui32 * g_ptr412E8C = &g_dw412D43; // 00412E8C
byte * g_ptr412E9C = &g_b412D53; // 00412E9C
word32 * g_ptr412EA8 = &g_dw412D5F; // 00412EA8
ui32 * g_ptr412EB0 = &g_dw412D67; // 00412EB0
ui8 * g_ptr412EB4 = &g_b412D6B; // 00412EB4
ui32 * g_ptr412ED4 = &g_dw412D8B; // 00412ED4
byte * g_ptr412EE8 = &g_b412D9F; // 00412EE8
word32 * g_ptr412EEC = &g_dw412DA3; // 00412EEC
word32 * g_ptr412EF0 = &g_dw412DA7; // 00412EF0
ui32 * g_ptr412EF4 = &g_dw412DAB; // 00412EF4
word32 * g_ptr412EF8 = &g_dw412DAF; // 00412EF8
ui32 * g_ptr412EFC = &g_dw412DB3; // 00412EFC
ui32 * g_ptr412F00 = &g_dw412DB7; // 00412F00
word32 * g_ptr412F10 = &g_dw412DC7; // 00412F10
word32 * g_ptr412F20 = &g_dw412DD7; // 00412F20
WCHAR g_t412F2C = 'V'; // 00412F2C
WCHAR g_t41304F = 'R'; // 0041304F
// subject_edata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40F11D = 0xF1C5; // 0040F11D
word32 g_dw40F121 = 61913; // 0040F121
word32 g_dw40F125 = 61929; // 0040F125
word32 g_dw40F12D = 0xF20B; // 0040F12D
word32 g_dw40F135 = 0xF22B; // 0040F135
word32 g_dw40F139 = 62007; // 0040F139
word32 g_dw40F13D = 62023; // 0040F13D
word32 g_dw40F141 = 0xF25B; // 0040F141
word32 g_dw40F145 = 0xF269; // 0040F145
word32 g_dw40F14D = 0xF285; // 0040F14D
word32 g_dw40F151 = 0xF299; // 0040F151
word32 g_dw40F155 = 62119; // 0040F155
word32 g_dw40F159 = 62133; // 0040F159
word32 g_dw40F15D = 0xF2CD; // 0040F15D
word32 g_dw40F161 = 0xF2E3; // 0040F161
word32 g_dw40F165 = 0xF2EF; // 0040F165
word32 g_dw40F169 = 0xF303; // 0040F169
word32 g_dw40F171 = 62241; // 0040F171
word32 g_dw40F175 = 0xF331; // 0040F175
word32 g_dw40F179 = 0xF33F; // 0040F179
word32 g_dw40F17D = 62289; // 0040F17D
word32 g_dw40F181 = 0xF35D; // 0040F181
word32 g_dw40F185 = 0xF36D; // 0040F185
word32 g_dw40F189 = 62333; // 0040F189
word32 g_dw40F18D = 0xF38D; // 0040F18D
word32 g_dw40F191 = 0xF39F; // 0040F191
word32 g_dw40F195 = 0xF3B3; // 0040F195
word32 g_dw40F199 = 0xF3BD; // 0040F199
word32 g_dw40F19D = 0xF3CD; // 0040F19D
word32 g_dw40F1A1 = 62427; // 0040F1A1
word32 g_dw40F1A9 = 0xF3FD; // 0040F1A9
word32 g_dw40F1B1 = 0xF411; // 0040F1B1
word32 g_dw40F1B5 = 0xF425; // 0040F1B5
word32 g_dw40F1B9 = 62521; // 0040F1B9
word32 g_dw40F1BD = 0xF455; // 0040F1BD
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetOpenFileNameA = &g_tF1C5; // 00401000
<anonymous> * __imp__PageSetupDlgW = &g_tF1D9; // 00401004
<anonymous> * __imp__GetOpenFileNameW = &g_tF1E9; // 00401008
<anonymous> * __imp__PathCommonPrefixW = &g_tF20B; // 00401010
<anonymous> * __imp__SetPixel = &g_tF22B; // 00401018
<anonymous> * __imp__GetTextAlign = &g_tF237; // 0040101C
<anonymous> * __imp__CreateDIBSection = &g_tF247; // 00401020
<anonymous> * __imp__SetRectRgn = &g_tF25B; // 00401024
<anonymous> * __imp__ExcludeClipRect = &g_tF269; // 00401028
<anonymous> * __imp__GetFullPathNameW = &g_tF285; // 00401030
<anonymous> * __imp__HeapReAlloc = &g_tF299; // 00401034
<anonymous> * __imp__ExitThread = &g_tF2A7; // 00401038
<anonymous> * __imp__GetWindowsDirectoryW = &g_tF2B5; // 0040103C
<anonymous> * __imp__GetCurrentProcessId = &g_tF2CD; // 00401040
<anonymous> * __imp__lstrcmpA = &g_tF2E3; // 00401044
<anonymous> * __imp__ReleaseSemaphore = &g_tF2EF; // 00401048
<anonymous> * __imp__FindResourceA = &g_tF303; // 0040104C
<anonymous> * __imp__GetClientRect = &g_tF321; // 00401054
<anonymous> * __imp__GetKeyState = &g_tF331; // 00401058
<anonymous> * __imp__GetWindowTextA = &g_tF33F; // 0040105C
<anonymous> * __imp__wsprintfW = &g_tF351; // 00401060
<anonymous> * __imp__GetDlgItemInt = &g_tF35D; // 00401064
<anonymous> * __imp__GetClassLongA = &g_tF36D; // 00401068
<anonymous> * __imp__GetClassNameW = &g_tF37D; // 0040106C
<anonymous> * __imp__GetMenuStringA = &g_tF38D; // 00401070
<anonymous> * __imp__LoadAcceleratorsA = &g_tF39F; // 00401074
<anonymous> * __imp__SetMenu = &g_tF3B3; // 00401078
<anonymous> * __imp__RedrawWindow = &g_tF3BD; // 0040107C
<anonymous> * __imp__OemToCharA = &g_tF3CD; // 00401080
<anonymous> * __imp__AdjustWindowRectEx = &g_tF3DB; // 00401084
<anonymous> * __imp__wcslen = &g_tF3FD; // 0040108C
<anonymous> * __imp__ImageList_Destroy = &g_tF411; // 00401094
<anonymous> * __imp__ImageList_Remove = &g_tF425; // 00401098
<anonymous> * __imp__CreatePropertySheetPageW = &g_tF439; // 0040109C
<anonymous> * __imp__CreateStatusWindowW = &g_tF455; // 004010A0
