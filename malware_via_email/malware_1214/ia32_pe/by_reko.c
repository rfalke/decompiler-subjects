// subject_rsrc.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw42BCC0 = 0x0002BD0C; // 0042BCC0
word32 g_dw42BCC4 = 179484; // 0042BCC4
word32 g_dw42BCC8 = 0x0002BD30; // 0042BCC8
word32 g_dw42BCCC = 0x0002BD40; // 0042BCCC
// subject_text_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401B84: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_4 * fs;
	Eq_5 ecx;
	struct Eq_6 * ebx;
	struct Eq_7 * edx;
	struct Eq_8 * esi;
	struct Eq_9 * edi;
	cu8 cl_42 = (byte) ecx;
	byte dl_50 = (byte) edx;
	word24 edx_24_8_58 = SLICE(edx, word24, 8);
	fs->ptr0000 = fp - 8;
	null = (union Eq_5 *) ecx;
	word16 ebx_16_16_51 = SLICE(&ebx->bFFFFFFF1 + 16, word16, 16);
	byte bl_52 = (byte) ebx + 0x01;
	if (!OVERFLOW<word32>((uint32) null - 952329243))
		edx->b436BDEB5 &= 110;
	else
	{
		word32 eax_33 = __in<word32>(233);
		edi->dw0000 = esi->dw0000;
		struct Eq_61 * ebx_53 = SEQ(ebx_16_16_51, esi->b57A37475, bl_52);
		Eq_2 eax_46 = eax_33 - ~0x3270C710 - (word32) (cl_42 - ebx->bFFFFFFF1 < 0x01);
		word32 edx_59 = SEQ(edx_24_8_58, dl_50 | ebx_53[fp - 0x0C]);
		if (Test(UGE,false))
			Mem65[ebx_53 + 0xE0148964:word32] = Mem39[ebx_53 + 0xE0148964:word32] | edi + 4;
		else
			fs->*eax_46 = edx_59;
		Mem84[edi + 4:byte] = Mem82[edi + 4:byte] + 0xA8;
		return eax_46;
	}
}

