// subject_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b3E3000 = 0xB2; // 003E3000
uint32 g_dw3ED40B = 0xA408; // 003ED40B
// subject_data_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw4199B2 = 0x00; // 004199B2
word32 g_dw4199B6 = 0x00; // 004199B6
word32 g_dw4199BA = 0x00; // 004199BA
word32 g_dw4199BE = 0x00; // 004199BE
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t2098; // 003E2000
<anonymous> * __imp__GetProcAddress = &g_t20AA; // 003E2004
<anonymous> * __imp__LoadLibraryA = &g_t20BC; // 003E2008
<anonymous> * __imp__ReadFile = &g_t20CC; // 003E200C
<anonymous> * __imp__WriteFile = &g_t20D8; // 003E2010
<anonymous> * __imp__CloseHandle = &g_t20E4; // 003E2014
<anonymous> * __imp__CreateThread = &g_t20F2; // 003E2018
<anonymous> * __imp__CreatePipe = &g_t2102; // 003E201C
<anonymous> * __imp__ExitProcess = &g_t2110; // 003E2020
<anonymous> * __imp__HeapAlloc = &g_t211E; // 003E2024
<anonymous> * __imp__GetProcessHeap = &g_t212A; // 003E2028
<anonymous> * __imp__HeapReAlloc = &g_t213C; // 003E202C
<anonymous> * __imp__HeapFree = &g_t214A; // 003E2030
word32 g_dw3E2060 = 8344; // 003E2060
word32 g_dw3E2064 = 0x20AA; // 003E2064
word32 g_dw3E2068 = 8380; // 003E2068
word32 g_dw3E206C = 0x20CC; // 003E206C
word32 g_dw3E2070 = 8408; // 003E2070
word32 g_dw3E2074 = 0x20E4; // 003E2074
word32 g_dw3E2078 = 0x20F2; // 003E2078
word32 g_dw3E207C = 0x2102; // 003E207C
word32 g_dw3E2080 = 0x2110; // 003E2080
word32 g_dw3E2084 = 0x211E; // 003E2084
word32 g_dw3E2088 = 0x212A; // 003E2088
word32 g_dw3E208C = 8508; // 003E208C
word32 g_dw3E2090 = 8522; // 003E2090
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack Eq_3 dwArg04, Register out (ptr32 Eq_4) ebpOut)
// Called from:
//      fn003E1320
word32 fn003E1000(Eq_3 dwArg04, struct Eq_4 & ebpOut)
{
	struct Eq_4 * dwArg00;
	word32 eax_27 = dwArg04 + Mem17[dwArg04 + 60:word32];
	ebpOut = dwArg00;
	return eax_27;
}

// 003E1021: void fn003E1021(Stack (ptr32 byte) dwArg04, Stack Eq_3 dwArg08, Stack Eq_13 dwArg0C)
// Called from:
//      fn003E1320
void fn003E1021(byte * dwArg04, Eq_3 dwArg08, Eq_13 dwArg0C)
{
	ptr32 fp;
	fn003E18F3(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 8);
}

// 003E1060: Register byte fn003E1060(Stack ui32 dwArg04)
// Called from:
//      fn003E1073
byte fn003E1060(ui32 dwArg04)
{
	return (byte) ((dwArg04 & 0x80000000) != 0x00);
}

// 003E1073: void fn003E1073(Stack (ptr32 Eq_38) dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn003E1320
void fn003E1073(struct Eq_38 * dwArg04, Eq_3 dwArg08)
{
	struct Eq_40 * dwLoc08_198 = dwArg08.u0 + dwArg04->dw0080;
	while (dwLoc08_198->dw000C != 0x00)
	{
		union Eq_45 * dwLoc10_209;
		Eq_46 eax_50 = LoadLibraryA(dwArg08.u0 + dwLoc08_198->dw000C);
		if (dwLoc08_198->dw0004 == 0x00)
			dwLoc10_209 = (union Eq_45 *) (dwArg08.u0 + dwLoc08_198->dw0010);
		else
			dwLoc10_209 = (union Eq_45 *) (dwArg08.u0 + dwLoc08_198->dw0000);
		word32 * dwLoc18_214 = dwArg08.u0 + dwLoc08_198->dw0010;
		while (dwLoc10_209->u1 != 0x00)
		{
			Eq_75 dwLoc14_231;
			if ((word32) fn003E1060(dwLoc10_209->u1) != 0x00)
				dwLoc14_231 = GetProcAddress(eax_50, (word32) dwLoc10_209->u0);
			else
				dwLoc14_231 = GetProcAddress(eax_50, dwArg08.u0 + dwLoc10_209->u1 + 2);
			*dwLoc18_214 = (word32) dwLoc14_231;
			++dwLoc18_214;
			dwLoc10_209 = (union Eq_45 *) ((char *) dwLoc10_209 + 4);
		}
		++dwLoc08_198;
	}
}

// 003E1197: void fn003E1197()
// Called from:
//      fn003E1320
void fn003E1197()
{
}

// 003E11A0: Register word32 fn003E11A0(Stack (ptr32 Eq_123) dwArg04, Stack word32 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fn003E1320
word32 fn003E11A0(struct Eq_123 * dwArg04, word32 dwArg08, uint32 dwArg0C)
{
	Eq_25 tLoc0C;
	Eq_25 tLoc08;
	word32 dwArg00;
	uint32 dwLoc10_102;
	for (dwLoc10_102 = 0x00; dwLoc10_102 < dwArg0C; dwLoc10_102 += 0x02)
	{
		WriteFile(dwArg04->t0004, dwArg08 + dwLoc10_102 * 0x04, 0x08, &tLoc08, null);
		ReadFile(dwArg04->t0000, dwArg08 + dwLoc10_102 * 0x04, 0x08, &tLoc0C, null);
	}
	return dwArg00;
}

DWORD g_t3E1207(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 003E1207
// 003E1300: void fn003E1300(Stack (ptr32 Eq_168) dwArg04)
// Called from:
//      fn003E1320
void fn003E1300(struct Eq_168 * dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
}

// 003E1320: Register word32 fn003E1320(Register out ptr32 ebpOut)
// Called from:
//      Win32CrtStartup
word32 fn003E1320(ptr32 & ebpOut)
{
	ptr32 fp;
	Eq_134 tLoc24;
	Eq_134 tLoc20;
	Eq_188 tLoc18;
	Eq_25 tLoc0C;
	struct Eq_190 * ebp_131 = fp - 4;
	ptr32 esp_138 = fp - 0x34;
	if ((word32) fn003E14F0()->ptr0030->b0002 == 0x00)
	{
		g_dw4199B2 = 4824;
		g_dw4199B2 += 0x4BEC;
		g_dw4199B6 = 8696;
		g_dw4199B6 += 11017;
		g_dw4199BA = 21231;
		g_dw4199BE = 0x0626;
		g_dw4199BE += 0x17FA;
		esp_138 = fp - 0x34;
		if (CreatePipe(&tLoc24, (char *) &tLoc18 + 4, null, 0x10) != 0x00)
		{
			esp_138 = fp - 0x34;
			if (CreatePipe(&tLoc18, &tLoc20, null, 0x10) != 0x00)
			{
				CreateThread(null, 0x00, &g_t3E1207, &tLoc24, 0x00, &tLoc0C);
				struct Eq_292 * ebp_99 = fn003E11A0(&tLoc18, 0x003E3000, g_dw3ED40B >> 0x02);
				fn003E1300(ebp_99 - 20);
				fn003E1300(ebp_99 - 32);
				CloseHandle(ebp_99->tFFFFFFDC);
				ebp_131->ptrFFFFFFF4 = fn003E1000(0x003E3000, out ebp_131);
				esp_138 = fp - 0x34;
				if (ebp_131->ptrFFFFFFF4 != null)
				{
					ebp_131->tFFFFFFD4.u0 = ebp_131->ptrFFFFFFF4->t0034.u0;
					fn003E1021(&g_b3E3000, ebp_131->tFFFFFFD4.u0, ebp_131->ptrFFFFFFF4->t0054);
					fn003E1500(ebp_131->ptrFFFFFFF4, 0x003E3000, ebp_131->tFFFFFFD4.u0);
					ebp_131->ptrFFFFFFD8 = fn003E1000(ebp_131->tFFFFFFD4.u0, out ebp_131);
					esp_138 = fp - 0x34;
					if (ebp_131->ptrFFFFFFD8 != null)
					{
						fn003E1073(ebp_131->ptrFFFFFFD8, ebp_131->tFFFFFFD4.u0);
						ebp_131 = fn003E16A9();
						Eq_3 ecx_253 = ebp_131->tFFFFFFD4.u0;
						ebp_131->ptrFFFFFFE8->t0008.u0 = (struct Eq_688 *) ecx_253;
						struct Eq_409 * esp_246 = (struct Eq_409 *) <invalid>;
						struct Eq_38 * edx_255 = ebp_131->ptrFFFFFFF4;
						esp_246->t0004.u0 = ebp_131->tFFFFFFD4.u0;
						<anonymous> * eax_261 = esp_246->t0004.u0 + edx_255->dw0028;
						ebp_131->ptrFFFFFFD0 = eax_261;
						ebp_131->ptrFFFFFFD0();
					}
				}
				fn003E1197();
			}
		}
	}
	struct Eq_190 ** esp_288 = esp_138 - 4;
	*esp_288 = (struct Eq_190 **) ebp_131;
	ebpOut = *((char *) *esp_288 + 4);
	return 0x00;
}

// 003E14D3: Register Eq_25 Win32CrtStartup()
Eq_25 Win32CrtStartup()
{
	struct Eq_435 * ebp_13;
	ebp_13->tFFFFFFFC = fn003E1320(out ebp_13);
	ExitProcess(ebp_13->tFFFFFFFC);
}

// 003E14F0: Register word32 fn003E14F0()
// Called from:
//      fn003E1320
word32 fn003E14F0()
{
	struct Eq_451 * fs;
	return fs->dw0018;
}

// 003E1500: void fn003E1500(Stack (ptr32 Eq_38) dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn003E1320
void fn003E1500(struct Eq_38 * dwArg04, word32 dwArg08, Eq_3 dwArg0C)
{
	word16 dx_18 = dwArg04->w0006;
	word16 wLoc14_124;
	for (wLoc14_124 = 0x00; (word32) wLoc14_124 < (word32) dx_18; ++wLoc14_124)
	{
		Eq_13 dwLoc2C_134;
		Eq_13 v13_40 = (&dwArg04->dw0080 + 30)[((word32) wLoc14_124 *s 0x28 + 8) / 0x0084];
		Eq_13 eax_49 = (&dwArg04->dw0080 + 30)[((word32) wLoc14_124 *s 0x28 + 16) / 0x0084];
		if (v13_40 < eax_49)
			dwLoc2C_134 = v13_40;
		else
			dwLoc2C_134 = eax_49;
		fn003E18F3(dwArg0C + Mem75[(CONVERT(wLoc14_124, word16, word32) *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem80[(CONVERT(wLoc14_124, word16, word32) *s 0x28 + 20) + (dwArg04 + 0xF8):word32], dwLoc2C_134);
	}
}

// 003E15D1: Register ui32 fn003E15D1(Stack ui32 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      fn003E16A9
ui32 fn003E15D1(ui32 dwArg04, ptr32 & ebpOut)
{
	ptr32 dwArg00;
	ui32 dwLoc08_244 = 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_244 = 0x0200;
	ui32 dwLoc08_249;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_249 = dwLoc08_244 | 0x40;
			else
				dwLoc08_249 = dwLoc08_244 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_249 = dwLoc08_244 | 0x80;
		else
			dwLoc08_249 = dwLoc08_244 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_249 = dwLoc08_244 | 0x04;
		else
			dwLoc08_249 = dwLoc08_244 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_249 = dwLoc08_244 | 0x08;
	else
		dwLoc08_249 = dwLoc08_244 | 0x01;
	ebpOut = dwArg00;
	return dwLoc08_249;
}

// 003E16A9: Register word32 fn003E16A9()
// Called from:
//      fn003E1320
word32 fn003E16A9()
{
	ptr32 fp;
	struct Eq_565 * ebp_23 = fp - 4;
	while (true)
	{
		struct Eq_565 * ebp_67;
		if ((word32) ebp_23->wFFFFFFF0 >= (word32) ebp_23->wFFFFFFF8)
			break;
		ebp_23->tFFFFFFE8.u0 = (struct Eq_688 *) (ebp_23->dw000C + *((word32) ((word32) ((word32) ebp_23->wFFFFFFF0 *s 0x28) + 0x0C) + ebp_23->dwFFFFFFFC));
		ebp_23->tFFFFFFE4 = (Eq_13) ((word32) ebp_23->wFFFFFFF0 *s 0x28)->a0008[ebp_23->dwFFFFFFFC / 4];
		VirtualProtect(ebp_67->tFFFFFFE8.u0, ebp_67->tFFFFFFE4, fn003E15D1(((word32) ebp_23->wFFFFFFF0 *s 0x28)->a0024[ebp_23->dwFFFFFFFC / 4], out ebp_67), ebp_23 - 20);
		++ebp_67->wFFFFFFF0;
		ebp_23 = ebp_67;
	}
	return ebp_23->dw0000;
}

// 003E18F3: void fn003E18F3(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Stack Eq_13 dwArg0C)
// Called from:
//      fn003E1021
//      fn003E1500
void fn003E18F3(Eq_3 dwArg04, byte * dwArg08, Eq_13 dwArg0C)
{
	while (true)
	{
		--dwArg0C;
		if (dwArg0C == 0x00)
			break;
		dwArg04.u0->b0000 = *dwArg08;
		&dwArg04.u0->b0000 = (word32) dwArg04 + 1;
		++dwArg08;
	}
}

