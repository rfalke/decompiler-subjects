// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__IsWindow = &g_tF134; // 00401000
<anonymous> * __imp__GetWindow = &g_tF140; // 00401004
<anonymous> * __imp__EnableScrollBar = &g_tF14C; // 00401008
<anonymous> * __imp__CharToOemW = &g_tF15E; // 0040100C
<anonymous> * __imp__SetWindowTextW = &g_tF16C; // 00401010
<anonymous> * __imp__CharLowerBuffW = &g_tF17E; // 00401014
<anonymous> * __imp__DeferWindowPos = &g_tF190; // 00401018
<anonymous> * __imp__BeginPaint = &g_tF1A2; // 0040101C
<anonymous> * __imp__IntersectRect = &g_tF1B0; // 00401020
<anonymous> * __imp__PostMessageW = &g_tF1C0; // 00401024
<anonymous> * __imp__CharNextA = &g_tF1D0; // 00401028
<anonymous> * __imp__wsprintfW = &g_tF1DC; // 0040102C
<anonymous> * __imp__PathMakePrettyW = &g_tF1F4; // 00401034
<anonymous> * __imp__StrSpnA = &g_tF206; // 00401038
<anonymous> * __imp__ExitProcess = &g_tF21C; // 00401040
<anonymous> * __imp__FindResourceExW = &g_tF22A; // 00401044
<anonymous> * __imp__InterlockedExchange = &g_tF23C; // 00401048
<anonymous> * __imp__GetTempPathA = &g_tF252; // 0040104C
<anonymous> * __imp__GetCurrentProcessId = &g_tF262; // 00401050
<anonymous> * __imp__GetCurrentThreadId = &g_tF278; // 00401054
<anonymous> * __imp__GetDateFormatW = &g_tF28E; // 00401058
<anonymous> * __imp__InterlockedExchangeAdd = &g_tF2A0; // 0040105C
<anonymous> * __imp__GetLastError = &g_tF2BA; // 00401060
<anonymous> * __imp__GetThreadContext = &g_tF2CA; // 00401064
<anonymous> * __imp__RaiseException = &g_tF2DE; // 00401068
<anonymous> * __imp___stricmp = &g_tF2FE; // 00401070
<anonymous> * __imp__memset = &g_tF30A; // 00401074
<anonymous> * __imp__ChooseColorW = &g_tF31E; // 0040107C
<anonymous> * __imp__GetOpenFileNameW = &g_tF32E; // 00401080
<anonymous> * __imp__GetSaveFileNameW = &g_tF342; // 00401084
<anonymous> * __imp__GetTextMetricsW = &g_tF364; // 0040108C
<anonymous> * __imp__GetLayout = &g_tF376; // 00401090
<anonymous> * __imp__Polyline = &g_tF382; // 00401094
<anonymous> * __imp__PatBlt = &g_tF38E; // 00401098
<anonymous> * __imp__CreateDiscardableBitmap = &g_tF398; // 0040109C
<anonymous> * __imp__RectInRegion = &g_tF3B2; // 004010A0
// 004038A8: Register int16 fjxT__LOi_o__bze(Stack (ptr32 uint32) ptrArg04, Stack uint32 dwArg08)
int16 fjxT__LOi_o__bze(uint32 * ptrArg04, uint32 dwArg08)
{
	g_t408222.u0 = (ui32) ((word32) g_t408222.u1 | *g_ptr4083ED);
	g_t4082B2.u0 = (uint32) ((word32) g_t4082B2.u1 ^ g_dw408256);
	ui32 * ebx_18 = g_ptr4083A1;
	*ebx_18 = *ebx_18 ^ (word32) g_b40826A;
	return <invalid>;
}

// 004038EB: FpuStack real32 esfvPXYO(Stack char bArg04, Stack bool fArg08)
real32 esfvPXYO(char bArg04, bool fArg08)
{
	ui32 * dwLoc20;
	ui32 * ebx_9 = g_ptr408311;
	g_t408262.u0 = (ui32) (g_t408262.u0 | *ebx_9);
	g_t4081D2.u0 = (ui32) ((word32) g_t4081D2.u1 & g_t4082C6.u1);
	g_dw4081E2 = g_dw4081E2 + g_dw40823E + (word32) (dwLoc20 < ebx_9);
	return <invalid>;
}

// 00403935: Register bool XJEMTX_KMW_Wk__xgt(Stack bool fArg04)
bool XJEMTX_KMW_Wk__xgt(bool fArg04)
{
	up32 edx;
	up32 dwLoc24;
	g_dw4081EA = g_dw4081EA ^ g_dw4082A2;
	g_dw4082A6 = g_dw4082A6 ^ *g_ptr4083BD;
	g_dw4081FE = g_dw4081FE + g_dw4081D6 + (word32) (edx < dwLoc24);
	return <invalid>;
}

// 0040397E: Register uint16 IPGoqcql(Stack int32 dwArg04, Stack uint32 dwArg08)
uint16 IPGoqcql(int32 dwArg04, uint32 dwArg08)
{
	g_dw4082A2 = g_dw4082A2 ^ *g_ptr408325;
	g_dw408272 &= *g_ptr4083C5;
	g_dw40828E = g_dw40828E ^ *g_ptr408369;
	return <invalid>;
}

// 004039C4: Register (ptr32 uint32) __nyDUEswS_L_vnlplpbB(Stack int16 wArg04, Stack real32 rArg08)
uint32 * __nyDUEswS_L_vnlplpbB(int16 wArg04, real32 rArg08)
{
	g_dw4082BE |= *g_ptr4083DD;
	g_dw408266 &= *g_ptr4083ED;
	word32 * edx_17 = g_ptr408325;
	*edx_17 += (word32) g_b4082AE;
	return (uint32 *) <invalid>;
}

// 00403A05: Register (ptr32 void) sqlTJX__iezceottnfknXU(Stack int16 wArg04, Stack int32 dwArg08)
void * sqlTJX__iezceottnfknXU(int16 wArg04, int32 dwArg08)
{
	uint32 edi;
	word32 * ecx_10 = g_ptr408389;
	*ecx_10 += g_dw408202;
	ui32 * ebx_15 = g_ptr4083E9;
	*ebx_15 = *ebx_15 - g_t4082BA.u1 - (word32) (edi < g_dw4081E2);
	g_t40824A.u0 = (ui32) (g_t40824A.u0 - (word32) g_b4082AE);
	return (void *) <invalid>;
}

// 00403A46: Register (ptr32 cu8) itiLZFB_NYKH(Stack cu8 bArg04)
cu8 * itiLZFB_NYKH(cu8 bArg04)
{
	word32 * ecx_10 = g_ptr4083B5;
	*ecx_10 += g_dw4082BE;
	g_dw408296 -= *g_ptr408381;
	word32 * edx_19 = g_ptr408309;
	*edx_19 -= g_dw40821A;
	return (cu8 *) <invalid>;
}

// 00403A82: Register (ptr32 uint32) PUP_SR__nk(Stack char bArg04, Stack (ptr32 int16) ptrArg08)
uint32 * PUP_SR__nk(char bArg04, int16 * ptrArg08)
{
	Eq_236 dwLoc24;
	word32 * ecx_9 = g_ptr408301;
	*ecx_9 -= g_dw4082A2;
	Eq_236 edx_14 = g_t40822E.u1;
	g_t408222.u0 = (ui32) (g_t408222.u0 & edx_14);
	g_dw40828E = g_dw40828E - (word32) g_t408286.u1 - (word32) (dwLoc24 < edx_14);
	return (uint32 *) <invalid>;
}

// 00403AC6: Register word32 fn00403AC6(Register word16 dx)
// Called from:
//      fn00404DF2
word32 fn00403AC6(word16 dx)
{
	word32 dwLoc30;
	up32 dwLoc14_179 = 0x00;
	do
	{
		dwLoc14_179 = dwLoc14_284 + 0x01;
		if (dwLoc14_179 == 0x1D)
			GetTextMetricsW((struct HDC__ *) 0x106E, &g_dw4081DA);
		dwLoc14_284 = dwLoc14_179;
	} while (dwLoc14_284 < 22);
	word32 * edx_54 = g_ptr4083E1;
	*edx_54 += (word32) g_w4082AA;
	g_t408252.u1 = (word32) ((word32) g_t408252.u0 + g_dw40825A);
}

Eq_409 g_t403C4F = // 00403C4F
	{
		<code>,
		0x40709405,
	};
// 00403C7F: Register word32 fn00403C7F(Stack (ptr32 Eq_306) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn0040528E
word32 fn00403C7F(struct Eq_306 * dwArg04, word32 * dwArg08)
{
	word32 dwLoc34;
	uint32 dwLoc2C;
	word16 wLoc30;
	up32 dwLoc48;
	byte bLoc40;
	word32 dwLoc1C;
	word24 nArg04_366 = (word24) dwArg04;
	word16 wLoc34 = (word16) dwLoc34;
	Eq_278 eax_10 = ~0x1003;
	up32 dwLoc14_234;
	for (dwLoc14_234 = 0x00; dwLoc14_234 < 0x1B; ++dwLoc14_234)
	{
		if (dwLoc14_234 == 33)
			eax_10 = ChooseColorW((struct tagCHOOSECOLORW *) 0x6133);
	}
	ui32 ecx_44 = g_dw4070F0;
	if (dwLoc2C > 27123)
		dwLoc2C &= g_dw4082A2;
	byte * esi_69 = g_ptr408361;
	*esi_69 &= 0x6C;
	if ((eax_10 ^ 13615) + 0x252E != ecx_44 && *dwArg04->ptr0038 != 0x00)
	{
		word16 wLoc34_370;
		word16 wLoc32_373;
		if (dwLoc48 < 0x1DED)
		{
			word32 eax_112 = dwLoc34 - g_dw408202;
			wLoc34_370 = (word16) eax_112;
			wLoc32_373 = SLICE(eax_112, word16, 16);
		}
		else
		{
			ui32 ecx_105 = (word32) wLoc34 & (word32) bLoc40;
			wLoc34_370 = (word16) ecx_105;
			wLoc32_373 = SLICE(ecx_105, word16, 16);
		}
		struct Eq_379 * ecx_121 = g_ptr4072D8;
		struct Eq_382 * edx_123 = *ecx_121->ptr0008;
		word32 eax_126 = Mem120[Mem120[edx_123 + 60:word32] + 40 + edx_123:word32] + edx_123;
		if (ecx_121->dw0040 != 0x00)
		{
			struct Eq_409 * edx_132 = g_ptr407310;
			edx_132->t0000 = (<anonymous>) 233;
			g_dw408232 += g_dw40822A;
			struct Eq_409 * ecx_143 = g_ptr407310;
			ecx_143->dw0001 = eax_126 - ~0x2528 - ecx_143 - 0x252E;
			struct Eq_382 ** eax_158 = g_ptr4072D8->ptr0008;
			word32 eax_167;
			g_ptr407310();
			*dwArg08 = eax_167;
		}
		g_dw407100 = 0x00;
		g_dw407104 = 0x00;
	}
}

// 00403EC3: void fn00403EC3(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00405105
void fn00403EC3(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	Eq_274 dwLoc2C;
	int32 ecx_11 = ~0x1002;
	up32 dwLoc14_180 = 0x00;
	do
	{
		dwLoc14_180 = dwLoc14_293 + 0x01;
		if (dwLoc14_180 == 0x1B)
			GetLayout(dwLoc2C);
		dwLoc14_293 = dwLoc14_180;
	} while (dwLoc14_293 < 0x14);
	int32 eax_155 = 0x0200B00F;
	do
	{
		int32 * esi_85 = *((char *) g_a4070D4 + (ecx_11 + 1 & 0x03) * 0x04);
		*esi_85 = *esi_85 *s ecx_11 *s ~0x2007;
		ui32 * esi_92 = *((char *) g_a4070D4 + (ecx_11 - 1 & 0x03) * 0x04);
		*esi_92 = *esi_92 ^ (eax_155 | ecx_11);
		g_dw407304 = dwArg04;
		switch (ecx_11)
		{
		case ~0x11C2:
			g_dw407308 = dwArg08;
			break;
		case ~0x1182:
			g_dw40730C = dwArg0C;
			break;
		}
		ui32 ecx_119 = ecx_11 ^ 13615;
		word32 * eax_145 = *((char *) g_a4070D4 + ((ecx_119 + 0x01 ^ 13615) & 0x03) * 0x04);
		*eax_145 += (ecx_119 + 0x01 ^ 13615) *s ~0x2003 ^ (ecx_119 + 0x01 ^ 13615);
		eax_155 = (ecx_119 + 0x01 ^ 13615) *s ~0x2004;
		ui32 * esi_158 = *((char *) g_a4070D4 + ((ecx_119 + 0x01 ^ 13615) - 2 & 0x03) * 0x04);
		*esi_158 |= eax_155;
		ecx_11 = ecx_119 + 0x01 ^ 13615;
	} while ((ecx_119 + 0x01 ^ 13615) != ~0x1132);
}

// 00404075: Register Eq_564 fn00404075(Register (ptr32 Eq_565) ebp, Register (ptr32 uint32) esi, Register uint32 edi, Register out Eq_568 cxOut)
// Called from:
//      Win32CrtStartup
Eq_564 fn00404075(struct Eq_565 * ebp, uint32 * esi, uint32 edi, union Eq_568 & cxOut)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				uint32 ecx_16 = *esi;
				if (ecx_16 > edi)
					*esi = ecx_16 - 0x01;
				else if (ecx_16 == 0x00)
					*esi = edi;
				else
				{
					g_dw40823E = 0x00;
					do
					{
						++g_dw40823E;
						if (g_dw40823E == 33)
							GetOpenFileNameW(ebp->tFFFFFFF0);
					} while (g_dw40823E < 0x14);
					*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_16;
				}
			} while (*esi != edi);
		}
		LONG eax_79 = InterlockedExchangeAdd(&g_t4072EC, 0x00760667);
	} while ((word32) eax_79 + 0x00760667 != g_t4072EC);
	cxOut.u0 = <invalid>;
	return (word32) eax_79 + 0x00760667;
}

// 0040411A: void fn0040411A(Register (ptr32 Eq_638) ebp, Register (ptr32 uint32) esi, Register uint32 edi)
// Called from:
//      Win32CrtStartup
void fn0040411A(struct Eq_638 * ebp, uint32 * esi, uint32 edi)
{
	*esi = 0x01;
	InterlockedExchange(&g_t4072EC, 0x00760667);
	while (*esi != edi)
	{
		uint32 ecx_20 = *esi;
		if (ecx_20 < edi)
		{
			if (ecx_20 == 0x00)
				goto l004041B5;
			g_dw4081FA = 0x00;
			while (g_dw4081FA < 0x1B)
			{
				if (g_dw4081FA == 0x26)
					Polyline(ebp->tFFFFFFD8, &g_dw4081FA, 0x68CE);
				++g_dw4081FA;
			}
			*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_20;
		}
		else if (ecx_20 == 0x00)
		{
l004041B5:
			*esi = edi;
		}
		else
			*esi = ecx_20 - 0x01;
	}
}

// 004041D5: Register ui32 fn004041D5(Register out ptr32 ecxOut)
// Called from:
//      fn00404A5C
ui32 fn004041D5(ptr32 & ecxOut)
{
	up32 dwLoc2C;
	word16 wLoc2C = (word16) dwLoc2C;
	Eq_278 eax_24 = g_ptr407080->u0;
	up32 dwLoc1C_124 = 0x00;
	do
	{
		dwLoc1C_124 = dwLoc1C_180 + 0x01;
		if (dwLoc1C_124 == 33)
			eax_24 = PatBlt((struct HDC__ *) ~0x1003, 0x4EE2, 35887, dwLoc1C_180 + 0x01, 0x853B, 0x2ADF);
		dwLoc1C_180 = dwLoc1C_124;
	} while (dwLoc1C_180 < 0x1C);
	word32 * eax_64 = g_ptr408341;
	up32 eax_62 = *g_ptr407084;
	*eax_64 += (word32) wLoc2C;
	g_t4072F0.u0 = (BOOL) eax_24;
	g_dw4081F2 = g_dw4081F2 - g_dw408202 - (word32) (eax_62 < dwLoc2C);
	g_dw4072F4 = eax_62 + (0x04 - g_t4072F0.u0);
	word32 eax_101 = ~0x1003;
	if (g_t4072F0.u0 == 0x00)
		eax_101 = ~0x1002;
	ecxOut = 0x252E;
	return (eax_101 ^ 13615) + 0x252E;
}

// 004042EB: void fn004042EB()
// Called from:
//      fn00404A5C
void fn004042EB()
{
	ptr32 fp;
	word16 wLoc30;
	ui32 dwLoc20;
	word32 dwLoc2C;
	word32 dwLoc24;
	Eq_616 dwLoc28;
	word16 wLoc30_150 = wLoc30 - *g_ptr408371;
	ui32 eax_18 = dwLoc20 | g_t408222.u0;
	g_dw40823A = 0x00;
	do
	{
		++g_dw40823A;
		if (g_dw40823A == 0x1C)
			GetSaveFileNameW(dwLoc28);
	} while (g_dw40823A < 22);
	struct Eq_379 * edx_65 = g_ptr4072D8;
	g_t40829E.u0 = (ui32) (g_t40829E.u0 | 4227546);
	word32 * eax_94 = edx_65->ptr000C;
	g_ptr407580();
}

// 004043E8: Register word32 fn004043E8(Register word32 ecx, Stack word32 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C, Stack word32 dwArg10)
// Called from:
//      fn004043E8
//      fn0040528E
word32 fn004043E8(word32 ecx, word32 dwArg00, word32 dwArg04, word32 dwArg08, <anonymous> * dwArg0C, word32 dwArg10)
{
}

// 00404551: Register word32 fn00404551(Stack (ptr32 Eq_897) dwArg04, Stack word32 dwArg08, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn004053E4
word32 fn00404551(struct Eq_897 * dwArg04, word32 dwArg08, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 dwLocAC;
	byte bLoc012C;
	word32 dwLoc74;
	Eq_904 dwLoc14;
	Eq_871 eax_10 = dwArg04->t40749C;
	up32 dwLoc58_492;
	for (dwLoc58_492 = 0x00; dwLoc58_492 < 0x1E; ++dwLoc58_492)
	{
		if (dwLoc58_492 == 33)
			eax_10 = GetWindow((struct HWND__ *) 11941, 8008);
	}
	g_t40829E.u0 = (ui32) ((word32) g_t40829E.u1 - dwLocAC);
	g_a407340[((eax_10 ^ 13615) + 0x252E) * 0x02] = 0x00;
	byte * ebx_99 = g_ptr4083B9;
	*ebx_99 |= 0x5F;
	g_dw408212 |= (word32) bLoc012C;
	g_dw40823A = g_dw40823A ^ dwLoc74;
	g_dw408276 = 0x00;
	Eq_957 eax_140 = (struct HRSRC__ *) 0xFEF6;
	while (g_dw408276 < 22)
	{
		if (g_dw408276 == 0x24)
			eax_140 = FindResourceExW(dwLoc14, &g_t40852E, &g_t408559, (WORD) dwLoc14);
		++g_dw408276;
	}
	g_dw4081D6 += 4227558;
	g_dw4081DA &= 4227622;
	g_dw4081E2 -= 4227706;
	g_dw4081E2 |= 4227562;
	byte * eax_260 = g_ptr40836D;
	*eax_260 |= 0x1E;
	word32 * eax_265 = g_ptr408329;
	*eax_265 += g_dw408206;
}

// 00404A5C: Register word32 fn00404A5C()
// Called from:
//      fn004043E8
word32 fn00404A5C()
{
	word16 wLoc40;
	ui32 dwLoc98;
	ui32 dwLocA4;
	word32 dwLoc74;
	int32 dwLoc90;
	word16 wLocCC;
	g_dw4081D6 = 0x00;
	do
	{
		++g_dw4081D6;
		if (g_dw4081D6 == 0x1D)
			CharToOemW(&g_t408548, &g_t408282);
	} while (g_dw4081D6 < 0x13);
	word32 ecx_81;
	if (fn004041D5(out ecx_81) != 0x00)
	{
		fn004042EB();
		g_dw408266 -= (word32) wLoc40;
		uint32 ecx_105 = g_dw4072F4;
		g_t408222.u0 = (ui32) ((word32) g_t408222.u2 | dwLoc98);
		Eq_278 eax_113 = g_t4072F0.u0;
		g_dw40823A &= dwLocA4;
		g_dw40825E = g_dw40825E ^ dwLoc74;
		ui32 dwLoc14_454 = ~0x252D;
		Eq_54 edx_135 = 0x00;
		if (ecx_105 != 0x00)
		{
			do
			{
				g_t4082B2.u0 = 0x00;
				while (g_t4082B2.u0 < 0x1D)
				{
					if (g_t4082B2.u0 == 0x1E)
						eax_113 = SetWindowTextW((struct HWND__ *) 0x5592, &g_t4085BD);
					g_t4082B2.u0 = (uint32) (g_t4082B2.u0 + 0x01);
				}
				byte cl_178 = Mem168[edx_135 + eax_113:byte];
				byte bl_207 = __ror<byte,byte>(cl_178 - 0x2E, 0x01);
				byte bl_256 = Mem243[edx_135 + eax_113:byte];
				g_dw408226 = g_dw408226 + 0x00408286 + (word32) (edx_135 < g_t4082C6.u1);
				g_dw408226 |= 0x004081EE;
				g_dw408226 += 0x00408272;
				Mem268[edx_135 + eax_113:byte] = Mem266[edx_135 + eax_113:byte] ^ bl_256;
				up32 dwLoc30_485 = 0x00;
				do
				{
					dwLoc30_485 = dwLoc30_694 + 0x01;
					if (dwLoc30_485 == 0x23)
						eax_113 = CharLowerBuffW(&g_dw40821A, 10074);
					dwLoc30_694 = dwLoc30_485;
				} while (dwLoc30_694 < 0x1D);
				word32 * ecx_297 = g_ptr40832D;
				*ecx_297 -= (word32) wLocCC;
				Mem315[edx_135 + eax_113:byte] = Mem309[edx_135 + eax_113:byte] + 0x01;
				Mem322[edx_135 + eax_113:byte] = Mem315[edx_135 + eax_113:byte] + bl_207;
				byte * ecx_323 = g_ptr408385;
				*ecx_323 |= 0x50;
				Mem332[edx_135 + eax_113:byte] = Mem325[edx_135 + eax_113:byte] - 0x01;
				g_dw408296 &= *g_ptr4083D5;
				ui32 edx_343 = dwLoc14_454 + 0x01 ^ 13615 ^ 13615;
				dwLoc14_454 = edx_343;
				edx_135 = edx_343 + 0x252E;
			} while (edx_343 + 0x252E != ecx_105);
		}
	}
}

// 00404DF2: Register ptr32 fn00404DF2()
// Called from:
//      fn004053E4
ptr32 fn00404DF2()
{
	Eq_942 dwLoc10;
	Eq_942 dwLoc20;
	Eq_1219 dwLoc2C;
	word32 dwLoc70;
	struct Eq_1221 * edx_117 = (struct Eq_1221 *) 0x05;
	while (g_dw407090 == 0x00)
	{
		Eq_1219 dwLoc1C_227 = 0x00;
		do
		{
			dwLoc1C_227 = (word32) dwLoc1C_227 + 1;
			if (dwLoc1C_227 == 44)
			{
				DeferWindowPos((void *) 33503, (struct HWND__ *) 0x119A, (struct HWND__ *) 0x324F, dwLoc2C, dwLoc2C, 33503, dwLoc20, dwLoc10);
				dwLoc10 = dwLoc20;
				dwLoc1C_227 = dwLoc2C;
				dwLoc20.u0 = 0x324F;
			}
		} while (dwLoc1C_227 < 0x1D);
		edx_117[4224215] = (struct Eq_1221) ((edx_117[4224215] ^ 0x5F) + 0x31);
		++edx_117;
		if (edx_117 >= (struct Eq_1221 *) 0x14)
			break;
	}
	Mem90 = Mem76;
	word32 edi_113 = 0x00;
	if (*g_ptr4072D8->ptr000C == 0x00)
		edi_113 = fn00403AC6((word16) edx_117);
	ui32 ecx_133 = ~0x1002;
	ptr32 edx_134 = 13615;
	do
	{
		g_dw4081CA -= dwLoc70;
		ui32 ecx_137 = ecx_133 ^ 13615;
		struct Eq_1293 * eax_138 = ecx_137 * 0x02 + 0x4A5C;
		eax_138->w4074C4 = (eax_138->w4074BC ^ 0x032F) + 0x022E;
		ecx_133 = ecx_137 + 0x01 ^ 13615;
	} while (ecx_133 != ~0x1005);
	if (edi_113 != 0x00)
	{
		struct Eq_1316 * ecx_176 = (struct Eq_1316 *) 0x09;
		edx_134 = 4224279;
		do
		{
			ecx_176[4224567] = (struct Eq_1316) ((ecx_176[4224279] ^ 0x5F) + 0x31);
			--ecx_176;
		} while (ecx_176 != null);
		*g_ptr4072D8->ptr000C = edi_113;
	}
	return edx_134;
}

// 00404F90: void fn00404F90()
// Called from:
//      Win32CrtStartup
void fn00404F90()
{
	word32 * fp;
	word32 dwLoc4C;
	g_ptr4074B8 = null;
	if (fn004053E4() == 0x00)
		return;
	g_dw407318 = g_dw4074CC;
	g_dw40731C = g_dw4074D0;
	g_dw407320 = g_dw4074D4;
	if (false)
	{
		word32 dwLoc18_176;
		for (dwLoc18_176 = 0x1F; dwLoc18_176 != 0x00; --dwLoc18_176)
		{
			if (dwLoc18_176 == 0x25)
				BeginPaint((struct HWND__ *) 20058, &g_dw4081DE);
		}
		word32 * eax_92 = g_ptr4074B8;
		*eax_92 += g_dw407100;
	}
	else if (false)
	{
		g_ptr407314 = fp - 0x0C;
		*g_ptr4074D8 = fn00405105(dwLoc4C);
	}
	g_ptr4074B8 = fp;
}

// 00405105: Register word32 fn00405105(Stack word32 dwArg00)
// Called from:
//      fn00404F90
word32 fn00405105(word32 dwArg00)
{
	word32 * fp;
	word32 ecx;
	word32 dwLoc48;
	g_dw407098 += 0x00677567;
	g_ptr4072F8 = fp;
	Mem157 = Mem146;
	*g_ptr4072F8 = dwArg00 + g_dw407100;
	return ecx;
}

// 0040528E: Register word32 fn0040528E()
// Called from:
//      fn00405105
word32 fn0040528E()
{
	int32 dwLoc28;
	word32 dwLoc20_169;
	for (dwLoc20_169 = 0x11; dwLoc20_169 != 0x00; --dwLoc20_169)
	{
		if (dwLoc20_169 == 0x1B)
			CreateDiscardableBitmap((struct HDC__ *) 35505, dwLoc28, 0x75F0);
	}
}

// 004053E4: Register word32 fn004053E4()
// Called from:
//      fn00404F90
word32 fn004053E4()
{
	RECT * dwLoc24;
	fn00404DF2();
	g_dw40825A = 0x00;
	while (g_dw40825A < 0x1D)
	{
		if (g_dw40825A == 0x26)
			RectInRegion((struct HRGN__ *) 28101, dwLoc24);
		++g_dw40825A;
	}
}

// 004058D0: Register (ptr32 word32) fn004058D0(Register (ptr32 (ptr32 Eq_1504)) esi, Register word32 edi, Stack (ptr32 word32) dwArg04, Stack (ptr32 up32) dwArg08, Stack (ptr32 Eq_1474) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14, Stack (ptr32 word32) dwArg18, Stack (ptr32 word32) dwArg1C, Stack (ptr32 up32) dwArg20)
// Called from:
//      fn0040680C
word32 * fn004058D0(struct Eq_1504 ** esi, word32 edi, word32 * dwArg04, up32 * dwArg08, struct Eq_1474 * dwArg0C, word32 * dwArg10, word32 * dwArg14, word32 * dwArg18, word32 * dwArg1C, up32 * dwArg20)
{
	ptr32 fp;
	ui32 ebx_11 = ~0x1002;
	do
	{
		up32 dwLoc18_261;
		for (dwLoc18_261 = 0x00; dwLoc18_261 < 0x15; ++dwLoc18_261)
		{
			if (dwLoc18_261 == 0x1E)
				CharNextA(&g_t40843F);
		}
		word32 * edx_147;
		up32 * ecx_189;
		up32 eax_183;
		Mem40 = Mem26;
		if ((uint32) ((uint64) ebx_11 % 0x43) != 118 && ebx_11 != ~0x1007)
		{
			ptr32 esp_125 = fp - 8;
			if ((uint32) ((uint64) ebx_11 % 118) >= 0x98 || ebx_11 == ~0x1005)
			{
				up32 dwLoc2C_282;
				for (dwLoc2C_282 = 0x00; dwLoc2C_282 < 0x1C; ++dwLoc2C_282)
				{
					if (dwLoc2C_282 == 0x26)
					{
						struct Eq_1600 * esp_126 = esp_125 - 4;
						esp_126->t0000 = (Eq_987) &g_t4085BD;
						esp_126->tFFFFFFFC = (Eq_1123) &g_t40856E;
						wsprintfW(esp_126->tFFFFFFFC, esp_126->t0000, 0x00);
						esp_125 = esp_126 - 4;
					}
				}
			}
			edx_147 = (uint32) ((uint64) ebx_11 % 101);
			if (edx_147 <= (word32 *) 0x0896 && ebx_11 != ~0x100B)
			{
				edx_147 = (uint32) ((uint64) ebx_11 % 0x87);
				if (edx_147 != (word32 *) 0x0103 && ebx_11 != ~0x1009)
					goto l00405AB3;
				struct Eq_1504 * eax_175 = *esi;
				*dwArg1C = eax_175->dw0024 + edi;
				edx_147 = dwArg1C;
				up32 ecx_182 = eax_175->dw0014;
				eax_183 = eax_175->dw0018;
				if (ecx_182 > eax_183)
					eax_183 = ecx_182;
				ecx_189 = dwArg20;
				goto l00405AB1;
			}
			*dwArg10 = ~0x1006;
			*dwArg14 = ~0x1006;
			*dwArg18 = ~0x1004;
		}
		else
		{
			struct Eq_1504 * eax_56 = *esi;
			word32 eax_65 = eax_56->dw0020;
			*dwArg04 = eax_56->dw001C + edi;
			edx_147 = dwArg04;
			ecx_189 = dwArg08;
			eax_183 = eax_65 + edi;
l00405AB1:
			*ecx_189 = eax_183;
		}
l00405AB3:
		ebx_11 = (ebx_11 ^ 13615) + 0x01 ^ 13615;
	} while (ebx_11 != ~0x1032);
	return edx_147;
}

// 00405ACE: Register Eq_278 Win32CrtStartup()
Eq_278 Win32CrtStartup()
{
Win32CrtStartup_entry:
	def fp
	def ebp
	def esi
	def edi
	def ebx
	def tLoc14
	def tLoc0C
	def tLoc08
	def bLoc02B4
	def dwLoc0300
	def dwLoc024C
	def dwLoc28
	def dwLoc20
	eax_15 = SHLWAPI.dll!StrSpnA(4224348, 4224344)
	P_858 = SLICE(SCZOP_19, bool, 5)
	branch eax_15 <= 0x0A l00405AF7
	goto l00405AF0
l00405ACE:
l00405AF0:
	eax_559.u0 = 0x00
	SZ_560 = cond(0x00)
	S_861 = (bool) SZ_560
	Z_871 = SLICE(SZ_560, bool, 2)
	O_561 = false
	C_562 = false
	goto l0040602A
l00405AF7:
	esp_14->dwFFFFFFFC = esi
	esp_14->dwFFFFFFF8 = edi
	dwLoc0220_603 = 0x00
	goto l00405B18
l00405B09:
l00405B18:
	dwLoc0220_604 = PHI((dwLoc0220_603, l00405AF7), (dwLoc0220_695, l00405B09))
	branch dwLoc0220_604 >= 0x15 l00405B4F
l00405B29:
	branch dwLoc0220_604 != 0x24 l00405B4A
l00405B3A:
	esp_14->tFFFFFFF4 = (CONTEXT *) 26029
	esp_14->tFFFFFFF0 = (void *) 0x7B87
	GetThreadContext(esp_14->tFFFFFFF0, esp_14->tFFFFFFF4)
l00405B4A:
	dwLoc0220_695 = dwLoc0220_604 + 0x01
	goto l00405B18
l00405B4F:
	si_155 = (word16) fp - 0x14
	esi_16_16_161 = SLICE(&tLoc14, word16, 16)
	eax_39 = fn00404075(fp - 4, &tLoc14, ~0x1002, out cx_881)
	ecx_40 = <invalid>
	esi_879 = SEQ(esi_16_16_161, si_155)
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x46
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x3A
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x5C
	esi_69 = esp_14->tFFFFFFF4
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x4A
	eax_87 = esp_14->tFFFFFFF4
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x48
	ecx_98 = esp_14->tFFFFFFF4
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x44
	edx_110.u0 = g_t408286.u0
	g_t408286.u0 = (ui32) (edx_110 | 0x132E)
	esp_14->tFFFFFFF4 = (CONTEXT *) 0x4B
	edx_119 = esp_14->tFFFFFFF4
	edi_127 = (word32) bLoc02B4
	v23_128 = g_dw4082C2 | edi_127
	g_dw4082C2 = v23_128
l00405B78:
l00405EBE:
	eax_523 = g_dw40826E
	g_dw40826E = eax_523 + 0x01
l00405F9B:
	edx_847 = PHI((edx_459, l00405F96), (edx_297, l0040602E))
	eax_467 = (word32 *) tLoc0C
	branch ebx <= 0x0D7A l00405FC4
l00405FD3:
	Mem486 = PHI((Mem484, l00405FAA), (Mem477, l00405FC4))
	ecx_491 = g_ptr4074D8
	ecx_492 = *ecx_491
	*eax_467 = ecx_492
	SZP_498 = cond(fp - 4 & edi_439)
	P_859 = SLICE(SZP_498, bool, 5)
	eax_504 = g_dw407104
	ecx_505 = g_dw407100
	eax_506 = eax_504 ^ ecx_505
	g_dw407100 = eax_506
	eax_508 = g_ptr407554
	ecx_509 = g_dw407100
	v40_510 = *eax_508 + ecx_509
	*eax_508 = v40_510
	SCZO_512 = cond(v40_510)
	C_841 = SLICE(SCZO_512, bool, 1)
	O_856 = SLICE(SCZO_512, bool, 4)
	S_862 = (bool) SCZO_512
	Z_872 = SLICE(SCZO_512, bool, 2)
	eax_513 = (union Eq_278 *) tLoc0C
	eax_514.u0 = eax_513->u0
l0040602A:
	Z_870 = Z_871
	Top_863 = 0
	S_860 = S_861
	P_857 = P_858
	O_855 = O_561
	esi_852 = PHI((esi, l00405AF0), (esi_444, l00405FD3))
	edx_845 = PHI((edx_17, l00405AF0), (edx_847, l00405FD3))
	edi_844 = PHI((edi, l00405AF0), (edi_439, l00405FD3))
	ecx_843 = PHI((ecx_16, l00405AF0), (ecx_509, l00405FD3))
	eax_842 = PHI((eax_559, l00405AF0), (eax_514, l00405FD3))
	C_840 = PHI((C_562, l00405AF0), (C_841, l00405FD3))
	ebp_566 = ebp
	esp_567 = fp
	return eax_842
l0040603C:
	esp_294->t0004.u0 = 0x00
	ExitProcess(esp_294->t0004.u1)
Win32CrtStartup_exit:
}

// 00406044: FpuStack real64 kfxr_ex__kbfj__(Stack int32 dwArg04, Stack (ptr32 uint32) ptrArg08)
real64 kfxr_ex__kbfj__(int32 dwArg04, uint32 * ptrArg08)
{
	up32 edi;
	up32 dwLoc20;
	g_t408262.u0 = (ui32) ((word32) g_t408262.u1 & g_dw408272);
	g_t40827A.u0 = (ui32) ((word32) g_t40827A.u1 | *g_ptr40837D);
	word16 * ecx_20 = g_ptr408371;
	*ecx_20 = *ecx_20 - g_t4082C6.u1 - (word32) (edi < dwLoc20);
	return <invalid>;
}

// 0040680C: FlagGroup bool fn0040680C(Register ptr32 edx, Stack (ptr32 code) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Register out ptr32 eaxOut, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404551
//      fn004053E4
bool fn0040680C(ptr32 edx, <anonymous> * dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, ptr32 & eaxOut, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	Eq_1929 tLoc44;
	Eq_1930 tLoc40;
	Eq_1931 tLoc34;
	Eq_1932 tLoc2C;
	Eq_1933 tLoc28;
	Eq_1934 tLoc24;
	Eq_1935 tLoc20;
	word32 dwLoc30;
	ui32 dwLoc0108;
	Eq_1938 dwLoc015C;
	int32 dwLoc38;
	Eq_871 dwLoc14;
	bool P;
	word32 esi_30 = ~0x1002;
	struct Eq_1943 * esp_215 = fp - 0x0274;
	word32 dwLoc18_523 = ~0x1003;
	word32 dwLoc1C_524 = ~0x1002;
	ui32 dwLoc10_525 = ~0x1002;
l00406874:
	if (dwLoc1C_524 == esi_30)
	{
		g_dw40826E = 0x1C;
		while (g_dw40826E != 0x00)
		{
			if (g_dw40826E == 0x20)
			{
				struct Eq_2032 * esp_454 = esp_215 - 4;
				esp_454->t0000.u0 = 0x471B;
				esp_454->tFFFFFFFC = dwLoc14;
				GetWindow(esp_454->tFFFFFFFC, esp_454->t0000.u1);
			}
			--g_dw40826E;
		}
		struct Eq_1959 * esp_52 = esp_215 - 4;
		esp_52->ptr0000 = fp - 48;
		esp_52->ptrFFFFFFFC = &tLoc24;
		esp_52->ptrFFFFFFF8 = &tLoc34;
		esp_52->ptrFFFFFFF4 = &tLoc28;
		esp_52->ptrFFFFFFF0 = &tLoc2C;
		esp_52->ptrFFFFFFEC = &tLoc44;
		esp_52->ptrFFFFFFE8 = fp - 56;
		esp_52->ptrFFFFFFE4 = &tLoc40;
		edx = fn004058D0(&tLoc20, dwArg08, esp_52->ptrFFFFFFE4, esp_52->ptrFFFFFFE8, esp_52->ptrFFFFFFEC, esp_52->ptrFFFFFFF0, esp_52->ptrFFFFFFF4, esp_52->ptrFFFFFFF8, esp_52->ptrFFFFFFFC, esp_52->ptr0000);
		esi_30 = ~0x1002;
	}
	if (tLoc28 != esi_30)
	{
		g_ptr4081E6 = 4227534;
		struct Eq_2061 * eax_91 = tLoc20;
		if (eax_91->dw0018 == 0x00 || eax_91->dw0014 == 0x00)
		{
			dwLoc18_523 = esi_30;
			goto l00406AC3;
		}
	}
	if (tLoc2C != esi_30 && (dwLoc10_525 != (dwLoc30 + ~0x252D ^ 13615) && dwLoc18_523 == ~0x1003))
	{
		Eq_2090 ecx_118 = (dwLoc10_525 ^ 13615) + 0x252E;
		if (ecx_118 >= 0x05)
			dwLoc1C_524 = ~0x1003;
		word32 dwLoc68_542;
		for (dwLoc68_542 = 0x1E; dwLoc68_542 != 0x00; --dwLoc68_542)
		{
			if (dwLoc68_542 == 33)
			{
				esp_215->tFFFFFFFC.u0 = 11252;
				esp_215->tFFFFFFF8.u0 = 0x7BF0;
				esp_215->tFFFFFFF4 = (struct HWND__ *) 0x8202;
				EnableScrollBar(esp_215->tFFFFFFF4, esp_215->tFFFFFFF8.u1, esp_215->tFFFFFFFC.u1);
			}
		}
		struct Eq_2100 * eax_130 = tLoc20;
		if (ecx_118 < (eax_130->t0018).u0)
		{
			edx = (word32) *((word32) tLoc24 + ecx_118 * 0x02);
			if (edx <= eax_130->dw0014 - 0x01)
			{
				g_t40824A.u0 = (ui32) ((word32) g_t40824A.u1 | dwLoc0108);
				struct Eq_2178 * esp_184 = esp_215 - 4;
				esp_184->ptr0000 = fp - 8;
				Eq_1938 edx_188 = (tLoc28 ^ 13615) + 0x252E;
				g_dw4081DE = g_dw4081DE - *g_ptr40838D - (word32) (edx_188 < dwLoc015C);
				esp_184->dwFFFFFFFC = (word32) *((word32) (edx_188 *s ecx_118) + dwLoc38) + dwArg08;
				esp_184->dwFFFFFFF8 = dwArg0C;
				byte * eax_204 = g_ptr4083AD;
				*eax_204 |= 0x2E;
				word32 ecx_217;
				byte SCZOP_220;
				dwArg04();
				P = SLICE(SCZOP_220, bool, 5);
l00406AC3:
				dwLoc10_525 = (dwLoc10_525 ^ 13615) + 0x01 ^ 13615;
				goto l00406874;
			}
		}
	}
	Mem430 = Mem431;
	struct Eq_2142 * esp_433 = &esp_215->ptr0000 + 1;
	ptr32 edi_432 = esp_215->ptr0000;
	ptr32 esi_434 = esp_433->ptr0000;
	ptr32 ebx_436 = esp_433->ptr0004;
	eaxOut = 0x00;
	edxOut = edx;
	ebxOut = ebx_436;
	esiOut = esi_434;
	ediOut = edi_432;
	return P;
}

// 00406CB6: void fn00406CB6(Register (ptr32 Eq_2234) eax)
// Called from:
//      Win32CrtStartup
void fn00406CB6(struct Eq_2234 * eax)
{
	g_ptr407554 = (word32 *) ((char *) eax + 4);
	g_dw407548 = eax->dw0008;
	g_dw40754C = eax->dw000C;
	g_dw407550 = eax->dw0010;
}

// 00406CDA: void VoOZMHYX_V(Stack int16 wArg04, Stack (ptr32 real64) ptrArg08)
void VoOZMHYX_V(int16 wArg04, real64 * ptrArg08)
{
	up32 ecx;
	up32 dwLoc2C;
	g_t4082BA.u1 = (word32) ((word32) g_t4082BA.u0 + *g_ptr408339 + (word32) (dwLoc2C < ecx));
	ui32 * edx_16 = g_ptr4083E9;
	*edx_16 &= g_dw4081FE;
	g_t408292.u0 = (ui32) (g_t408292.u0 ^ *g_ptr4083A1);
}

// 00406D1E: Register cu8 JDZRizjr_hUWUGA_IAylml(Stack (ptr32 cu8) ptrArg04, Stack char bArg08)
cu8 JDZRizjr_hUWUGA_IAylml(cu8 * ptrArg04, char bArg08)
{
	Eq_2290 fp;
	up32 ebx;
	g_dw40825A = g_dw40825A + *g_ptr408331 + (word32) (ebx < g_dw40824E);
	g_dw4081FE = SLICE(SEQ(g_dw4081FE, fp - 4) - SEQ((word32) g_t408292.u1, 0x28), word32, 32);
	ui32 * ebx_27 = g_ptr4083D5;
	*ebx_27 -= (word32) g_t408222.u1;
	return <invalid>;
}

// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_278 g_t407068 = // 00407068
	{
		0x004010A8
	};
up32 g_dw407074 = 4208804; // 00407074
union Eq_278 * g_ptr407080 = &g_t407068; // 00407080
up32 * g_ptr407084 = &g_dw407074; // 00407084
struct Eq_382 * g_ptr40708C = null; // 0040708C
word32 g_dw407090 = 0x00; // 00407090
word32 g_dw407098 = ~0x3022; // 00407098
word32 * g_a4070D4[] = // 004070D4
	{
	};
ui32 g_dw4070F0 = 0x00; // 004070F0
ui32 g_dw407100 = 0x00; // 00407100
word32 g_dw407104 = 0x00; // 00407104
word32 g_dw407108 = 0x00; // 00407108
Eq_379 g_t407110 = // 00407110
	{
		&g_ptr40708C,
		&g_dw407108,
		0x00,
	};
struct Eq_379 * g_ptr4072D8 = &g_t407110; // 004072D8
Eq_578 g_t4072EC = 0x07860667; // 004072EC
Eq_278 g_t4072F0 = // 004072F0
	{
		0x05456465
	};
uint32 g_dw4072F4 = 0x05475774; // 004072F4
word32 * g_ptr4072F8 = null; // 004072F8
word32 g_dw407304 = 0x06546406; // 00407304
word32 g_dw407308 = 6624267; // 00407308
word32 g_dw40730C = 15080039; // 0040730C
struct Eq_409 * g_ptr407310 = &g_t403C4F; // 00407310
ptr32 g_ptr407314 = 0x00077718; // 00407314
word32 g_dw407318 = 0x06751718; // 00407318
word32 g_dw40731C = 0x00060718; // 0040731C
word32 g_dw407320 = 0x07655767; // 00407320
word16 g_a407340[] = // 00407340
	{
	};
word32 * g_ptr4074B8 = &g_dw342509; // 004074B8
word32 g_dw4074CC = 488810; // 004074CC
word32 g_dw4074D0 = 0x00077777; // 004074D0
word32 g_dw4074D4 = 0x08764664; // 004074D4
word32 * g_ptr4074D8 = &g_dw42406; // 004074D8
byte g_a407517[10] = // 00407517
	{
		0x00,
		100,
		0x1D,
		0x1C,
		0x1E,
		100,
		0x6B,
		0x62,
		121,
		0x90,
	};
word32 g_dw407548 = 0x00787616; // 00407548
word32 g_dw40754C = 3479004; // 0040754C
word32 g_dw407550 = 0x08974774; // 00407550
word32 * g_ptr407554 = &g_dw76860438; // 00407554
<anonymous> * g_ptr407580 = fn0040680C; // 00407580
ui8 g_a407637[10] = // 00407637
	{
		55,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
word32 g_dw4081CA = 0x001003BA; // 004081CA
Eq_51 g_t4081D2 = // 004081D2
	{
		0x001021A6
	};
up32 g_dw4081D6 = 1051051; // 004081D6
ui32 g_dw4081DA = 0x0010798D; // 004081DA
word32 g_dw4081DE = 0x00100EC9; // 004081DE
uint32 g_dw4081E2 = 1067616; // 004081E2
ptr32 g_ptr4081E6 = 1075178; // 004081E6
ui32 g_dw4081EA = 0x001017CD; // 004081EA
ui32 g_dw4081EE = 0x00104250; // 004081EE
word32 g_dw4081F2 = 1071410; // 004081F2
up32 g_dw4081FA = 0x00106941; // 004081FA
ui32 g_dw4081FE = 0x001047C3; // 004081FE
word32 g_dw408202 = 0x001003B3; // 00408202
word32 g_dw408206 = 1055151; // 00408206
word32 g_dw40820E = 0x0010351A; // 0040820E
ui32 g_dw408212 = 0x00104B48; // 00408212
word32 g_dw408216 = 0x00105F63; // 00408216
word32 g_dw40821A = 0x00104191; // 0040821A
Eq_6 g_t408222 = // 00408222
	{
		1069709
	};
ui32 g_dw408226 = 0x001006D4; // 00408226
word32 g_dw40822A = 0x001025BD; // 0040822A
Eq_236 g_t40822E = // 0040822E
	{
		0x2572
	};
word32 g_dw408232 = 0x001021F6; // 00408232
byte g_b408236 = 181; // 00408236
uint32 g_dw40823A = 0x00102205; // 0040823A
up32 g_dw40823E = 1059355; // 0040823E
byte g_b408242 = ~0x49; // 00408242
word16 g_w408246 = 16767; // 00408246
Eq_192 g_t40824A = // 0040824A
	{
		0x00100FCA
	};
up32 g_dw40824E = 0x001017A2; // 0040824E
Eq_297 g_t408252 = // 00408252
	{
		223
	};
word32 g_dw408256 = 0x00100809; // 00408256
up32 g_dw40825A = 0x00103E5A; // 0040825A
ui32 g_dw40825E = 0x00103AAE; // 0040825E
Eq_44 g_t408262 = // 00408262
	{
		0x001029CB
	};
ui32 g_dw408266 = 0x00102A58; // 00408266
byte g_b40826A = 113; // 0040826A
word32 g_dw40826E = 1077912; // 0040826E
ui32 g_dw408272 = 0x00106BBC; // 00408272
up32 g_dw408276 = 1067704; // 00408276
Eq_1894 g_t40827A = // 0040827A
	{
		0x00101300
	};
CHAR g_t408282 = '\xBF'; // 00408282
Eq_256 g_t408286 = // 00408286
	{
		0x0010670B
	};
word32 g_dw40828A = 0x0010712C; // 0040828A
ui32 g_dw40828E = 0x00102A66; // 0040828E
Eq_2280 g_t408292 = // 00408292
	{
		1071830
	};
ui32 g_dw408296 = 1068130; // 00408296
ui32 g_dw40829A = 0x0010699A; // 0040829A
Eq_826 g_t40829E = // 0040829E
	{
		0x00100D0C
	};
ui32 g_dw4082A2 = 1081173; // 004082A2
ui32 g_dw4082A6 = 0x001068CA; // 004082A6
word16 g_w4082AA = 10474; // 004082AA
byte g_b4082AE = 0xC0; // 004082AE
Eq_16 g_t4082B2 = // 004082B2
	{
		1079181
	};
word32 g_dw4082B6 = 1077097; // 004082B6
Eq_182 g_t4082BA = // 004082BA
	{
		11649
	};
ui32 g_dw4082BE = 0x001070E3; // 004082BE
ui32 g_dw4082C2 = 0x001021A8; // 004082C2
Eq_54 g_t4082C6 = // 004082C6
	{
		0x02C9
	};
word32 * g_ptr408301 = &g_dw4081D6; // 00408301
word32 * g_ptr408309 = &g_dw4081DE; // 00408309
ui32 * g_ptr408311 = &g_dw4081E6; // 00408311
word32 * g_ptr408325 = &g_dw4081FA; // 00408325
word32 * g_ptr408329 = &g_dw4081FE; // 00408329
word32 * g_ptr40832D = &g_dw408202; // 0040832D
word32 * g_ptr408331 = &g_dw408206; // 00408331
word32 * g_ptr408339 = &g_dw40820E; // 00408339
word32 * g_ptr408341 = &g_dw408216; // 00408341
byte * g_ptr408361 = &g_b408236; // 00408361
word32 * g_ptr408369 = &g_dw40823E; // 00408369
byte * g_ptr40836D = &g_b408242; // 0040836D
word16 * g_ptr408371 = &g_w408246; // 00408371
ui32 * g_ptr40837D = &g_dw408252; // 0040837D
word32 * g_ptr408381 = &g_dw408256; // 00408381
byte * g_ptr408385 = &g_b40825A; // 00408385
word32 * g_ptr408389 = &g_dw40825E; // 00408389
word32 * g_ptr40838D = &g_dw408262; // 0040838D
ui32 * g_ptr4083A1 = &g_dw408276; // 004083A1
byte * g_ptr4083AD = &g_b408282; // 004083AD
ui32 * g_ptr4083B1 = &g_dw408286; // 004083B1
word32 * g_ptr4083B5 = &g_dw40828A; // 004083B5
byte * g_ptr4083B9 = &g_b40828E; // 004083B9
word32 * g_ptr4083BD = &g_dw408292; // 004083BD
ui32 * g_ptr4083C5 = &g_dw40829A; // 004083C5
ui32 * g_ptr4083D5 = &g_dw4082AA; // 004083D5
ui32 * g_ptr4083DD = &g_dw4082B2; // 004083DD
word32 * g_ptr4083E1 = &g_dw4082B6; // 004083E1
ui32 * g_ptr4083E9 = &g_dw4082BE; // 004083E9
ui32 * g_ptr4083ED = &g_dw4082C2; // 004083ED
CHAR g_t40843F = 'C'; // 0040843F
WCHAR g_t40852E = 'I'; // 0040852E
WCHAR g_t408548 = 'Y'; // 00408548
WCHAR g_t408559 = 'R'; // 00408559
WCHAR g_t40856E = 'T'; // 0040856E
WCHAR g_t4085BD = 'W'; // 004085BD
// subject_import.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40F08C = 0xF134; // 0040F08C
word32 g_dw40F090 = 0xF140; // 0040F090
word32 g_dw40F094 = 61772; // 0040F094
word32 g_dw40F098 = 0xF15E; // 0040F098
word32 g_dw40F09C = 0xF16C; // 0040F09C
word32 g_dw40F0A0 = 61822; // 0040F0A0
word32 g_dw40F0A4 = 0xF190; // 0040F0A4
word32 g_dw40F0A8 = 61858; // 0040F0A8
word32 g_dw40F0AC = 0xF1B0; // 0040F0AC
word32 g_dw40F0B0 = 61888; // 0040F0B0
word32 g_dw40F0B4 = 0xF1D0; // 0040F0B4
word32 g_dw40F0B8 = 61916; // 0040F0B8
word32 g_dw40F0C0 = 0xF1F4; // 0040F0C0
word32 g_dw40F0C4 = 0xF206; // 0040F0C4
word32 g_dw40F0CC = 0xF21C; // 0040F0CC
word32 g_dw40F0D0 = 0xF22A; // 0040F0D0
word32 g_dw40F0D4 = 62012; // 0040F0D4
word32 g_dw40F0D8 = 0xF252; // 0040F0D8
word32 g_dw40F0DC = 0xF262; // 0040F0DC
word32 g_dw40F0E0 = 62072; // 0040F0E0
word32 g_dw40F0E4 = 0xF28E; // 0040F0E4
word32 g_dw40F0E8 = 62112; // 0040F0E8
word32 g_dw40F0EC = 0xF2BA; // 0040F0EC
word32 g_dw40F0F0 = 0xF2CA; // 0040F0F0
word32 g_dw40F0F4 = 0xF2DE; // 0040F0F4
word32 g_dw40F0FC = 62206; // 0040F0FC
word32 g_dw40F100 = 0xF30A; // 0040F100
word32 g_dw40F108 = 62238; // 0040F108
word32 g_dw40F10C = 62254; // 0040F10C
word32 g_dw40F110 = 62274; // 0040F110
word32 g_dw40F118 = 0xF364; // 0040F118
word32 g_dw40F11C = 62326; // 0040F11C
word32 g_dw40F120 = 62338; // 0040F120
word32 g_dw40F124 = 0xF38E; // 0040F124
word32 g_dw40F128 = 62360; // 0040F128
word32 g_dw40F12C = 62386; // 0040F12C
