// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t10578; // 00410000
<anonymous> * __imp__LocalFree = &g_t1058A; // 00410004
<anonymous> * __imp__HeapDestroy = &g_t10596; // 00410008
<anonymous> * __imp__GetVersionExA = &g_t105A4; // 0041000C
<anonymous> * __imp__GetProcessHeap = &g_t105B4; // 00410010
<anonymous> * __imp__LeaveCriticalSection = &g_t105C6; // 00410014
<anonymous> * __imp__GetVersionExA = &g_t105DE; // 00410018
<anonymous> * __imp__EnterCriticalSection = &g_t105EE; // 0041001C
<anonymous> * __imp__GetVersionExA = &g_t10606; // 00410020
<anonymous> * __imp__LocalFree = &g_t10616; // 00410024
<anonymous> * __imp__QueryPerformanceCounter = &g_t10622; // 00410028
<anonymous> * __imp__LoadLibraryW = &g_t1063C; // 0041002C
<anonymous> * __imp__LeaveCriticalSection = &g_t1064C; // 00410030
<anonymous> * __imp__GetModuleFileNameW = &g_t10664; // 00410034
<anonymous> * __imp__GetModuleFileNameW = &g_t1067A; // 00410038
<anonymous> * __imp__UnhandledExceptionFilter = &g_t10690; // 0041003C
<anonymous> * __imp__MultiByteToWideChar = &g_t106AC; // 00410040
<anonymous> * __imp__FreeLibrary = &g_t106C2; // 00410044
<anonymous> * __imp__HeapFree = &g_t106D0; // 00410048
<anonymous> * __imp__LoadLibraryW = &g_t106DC; // 0041004C
<anonymous> * __imp__GetModuleFileNameW = &g_t106EC; // 00410050
<anonymous> * __imp__VirtualProtect = &g_t10702; // 00410054
<anonymous> * __imp__LoadLibraryA = &g_t10714; // 00410058
<anonymous> * __imp__GetProcAddress = &g_t10724; // 0041005C
<anonymous> * __imp__CreateFileW = &g_t10736; // 00410060
<anonymous> * __imp__HeapAlloc = &g_t10744; // 00410064
<anonymous> * __imp__InterlockedCompareExchange = &g_t10750; // 00410068
<anonymous> * __imp__InitializeCriticalSection = &g_t1076E; // 0041006C
<anonymous> * __imp__Sleep = &g_t1078A; // 00410070
<anonymous> * __imp__CreateFileW = &g_t10792; // 00410074
<anonymous> * __imp__ReadFile = &g_t107A0; // 00410078
<anonymous> * __imp__QueryPerformanceCounter = &g_t107AC; // 0041007C
<anonymous> * __imp__GetModuleHandleW = &g_t107C6; // 00410080
<anonymous> * __imp__ReadFile = &g_t107DA; // 00410084
<anonymous> * __imp__QueryPerformanceCounter = &g_t107E6; // 00410088
<anonymous> * __imp__InterlockedCompareExchange = &g_t10800; // 0041008C
<anonymous> * __imp__GetProcessHeap = &g_t1081E; // 00410090
<anonymous> * __imp__Sleep = &g_t10830; // 00410094
<anonymous> * __imp__DeleteCriticalSection = &g_t10838; // 00410098
<anonymous> * __imp__GetCurrentThreadId = &g_t10850; // 0041009C
<anonymous> * __imp__UnhandledExceptionFilter = &g_t10866; // 004100A0
<anonymous> * __imp__LeaveCriticalSection = &g_t10882; // 004100A4
<anonymous> * __imp__CreateFileW = &g_t1089A; // 004100A8
<anonymous> * __imp__GetProcAddress = &g_t108A8; // 004100AC
<anonymous> * __imp__LoadLibraryW = &g_t108BA; // 004100B0
<anonymous> * __imp__GetCurrentProcess = &g_t108CA; // 004100B4
<anonymous> * __imp__GetTickCount = &g_t108DE; // 004100B8
<anonymous> * __imp__GetCurrentProcessId = &g_t108EE; // 004100BC
<anonymous> * __imp__GetProcessHeap = &g_t10904; // 004100C0
<anonymous> * __imp__InterlockedExchange = &g_t10916; // 004100C4
<anonymous> * __imp__GetProcessHeap = &g_t1092C; // 004100C8
<anonymous> * __imp__HeapFree = &g_t1093E; // 004100CC
<anonymous> * __imp__MultiByteToWideChar = &g_t1094A; // 004100D0
<anonymous> * __imp__GetModuleFileNameW = &g_t10960; // 004100D4
<anonymous> * __imp__GetModuleHandleA = &g_t10976; // 004100D8
<anonymous> * __imp__GetModuleHandleW = &g_t1098A; // 004100DC
<anonymous> * __imp__LoadLibraryA = &g_t1099E; // 004100E0
<anonymous> * __imp__lstrcmpiW = &g_t109AE; // 004100E4
<anonymous> * __imp__HeapFree = &g_t109BA; // 004100E8
<anonymous> * __imp__GetProcAddress = &g_t109C6; // 004100EC
<anonymous> * __imp__LocalFree = &g_t109D8; // 004100F0
<anonymous> * __imp__HeapFree = &g_t109E4; // 004100F4
<anonymous> * __imp__FreeLibrary = &g_t109F0; // 004100F8
<anonymous> * __imp__GetCurrentProcessId = &g_t109FE; // 004100FC
<anonymous> * __imp__SetLastError = &g_t10A14; // 00410100
<anonymous> * __imp__lstrlenA = &g_t10A24; // 00410104
<anonymous> * __imp__GetProcAddress = &g_t10A30; // 00410108
<anonymous> * __imp__GetModuleHandleW = &g_t10A42; // 0041010C
<anonymous> * __imp__Sleep = &g_t10A56; // 00410110
<anonymous> * __imp__LoadLibraryA = &g_t10A5E; // 00410114
<anonymous> * __imp__LocalFree = &g_t10A6E; // 00410118
<anonymous> * __imp__LoadLibraryW = &g_t10A7A; // 0041011C
<anonymous> * __imp__MultiByteToWideChar = &g_t10A8A; // 00410120
<anonymous> * __imp__LoadLibraryA = &g_t10AA0; // 00410124
<anonymous> * __imp__lstrlenA = &g_t10AB0; // 00410128
<anonymous> * __imp__CreateFileW = &g_t10ABC; // 0041012C
<anonymous> * __imp__QueryPerformanceCounter = &g_t10ACA; // 00410130
<anonymous> * __imp__FreeLibrary = &g_t10AE4; // 00410134
<anonymous> * __imp__GetCurrentThreadId = &g_t10AF2; // 00410138
<anonymous> * __imp__EnterCriticalSection = &g_t10B08; // 0041013C
<anonymous> * __imp__InterlockedCompareExchange = &g_t10B20; // 00410140
<anonymous> * __imp__GetVersionExA = &g_t10B3E; // 00410144
<anonymous> * __imp__LoadLibraryA = &g_t10B4E; // 00410148
<anonymous> * __imp__PostQuitMessage = &g_t10B6C; // 00410150
<anonymous> * __imp__IsDlgButtonChecked = &g_t10B7E; // 00410154
<anonymous> * __imp__GetParent = &g_t10B94; // 00410158
<anonymous> * __imp__SetTimer = &g_t10BA0; // 0041015C
<anonymous> * __imp__SetWindowTextW = &g_t10BAC; // 00410160
<anonymous> * __imp__DialogBoxParamW = &g_t10BBE; // 00410164
<anonymous> * __imp__PostMessageW = &g_t10BD0; // 00410168
<anonymous> * __imp__ShowWindow = &g_t10BE0; // 0041016C
<anonymous> * __imp__ReleaseDC = &g_t10BEE; // 00410170
<anonymous> * __imp__SetDlgItemTextW = &g_t10BFA; // 00410174
<anonymous> * __imp__SetDlgItemTextW = &g_t10C0C; // 00410178
<anonymous> * __imp__SendMessageW = &g_t10C1E; // 0041017C
<anonymous> * __imp__DialogBoxParamW = &g_t10C2E; // 00410180
<anonymous> * __imp__IsDlgButtonChecked = &g_t10C40; // 00410184
<anonymous> * __imp__ShowWindow = &g_t10C56; // 00410188
<anonymous> * __imp__DestroyWindow = &g_t10C64; // 0041018C
<anonymous> * __imp__SetWindowLongW = &g_t10C74; // 00410190
<anonymous> * __imp__MessageBoxW = &g_t10C86; // 00410194
<anonymous> * __imp__PeekMessageW = &g_t10C94; // 00410198
<anonymous> * __imp__DestroyWindow = &g_t10CA4; // 0041019C
<anonymous> * __imp__GetWindowRect = &g_t10CB4; // 004101A0
<anonymous> * __imp__ShowWindow = &g_t10CC4; // 004101A4
<anonymous> * __imp__GetSysColor = &g_t10CD2; // 004101A8
<anonymous> * __imp__KillTimer = &g_t10CE0; // 004101AC
<anonymous> * __imp__CharNextW = &g_t10CEC; // 004101B0
<anonymous> * __imp__SetWindowLongW = &g_t10CF8; // 004101B4
<anonymous> * __imp__SetWindowPos = &g_t10D0A; // 004101B8
<anonymous> * __imp__CharNextW = &g_t10D1A; // 004101BC
<anonymous> * __imp__GetSysColor = &g_t10D26; // 004101C0
<anonymous> * __imp__LoadStringW = &g_t10D34; // 004101C4
<anonymous> * __imp__KillTimer = &g_t10D42; // 004101C8
<anonymous> * __imp__PostQuitMessage = &g_t10D4E; // 004101CC
<anonymous> * __imp__GetClientRect = &g_t10D60; // 004101D0
<anonymous> * __imp__GetSysColor = &g_t10D70; // 004101D4
<anonymous> * __imp__GetFocus = &g_t10D7E; // 004101D8
<anonymous> * __imp__DialogBoxParamW = &g_t10D8A; // 004101DC
<anonymous> * __imp__EndPaint = &g_t10D9C; // 004101E0
<anonymous> * __imp__EnableWindow = &g_t10DA8; // 004101E4
<anonymous> * __imp__LoadIconW = &g_t10DB8; // 004101E8
<anonymous> * __imp__BeginPaint = &g_t10DC4; // 004101EC
<anonymous> * __imp__GetParent = &g_t10DD2; // 004101F0
<anonymous> * __imp__GetDC = &g_t10DDE; // 004101F4
<anonymous> * __imp__SetCursor = &g_t10DE6; // 004101F8
<anonymous> * __imp__SetCursor = &g_t10DF2; // 004101FC
<anonymous> * __imp__GetDlgItem = &g_t10DFE; // 00410200
<anonymous> * __imp__DestroyWindow = &g_t10E0C; // 00410204
<anonymous> * __imp__LoadIconW = &g_t10E1C; // 00410208
<anonymous> * __imp__InvalidateRect = &g_t10E28; // 0041020C
<anonymous> * __imp__SetCursor = &g_t10E3A; // 00410210
<anonymous> * __imp__GetDesktopWindow = &g_t10E46; // 00410214
<anonymous> * __imp__KillTimer = &g_t10E5A; // 00410218
<anonymous> * __imp__ShowWindow = &g_t10E66; // 0041021C
<anonymous> * __imp__EndPaint = &g_t10E74; // 00410220
<anonymous> * __imp__GetWindowLongW = &g_t10E80; // 00410224
<anonymous> * __imp__GetSystemMetrics = &g_t10E92; // 00410228
<anonymous> * __imp__GetSysColor = &g_t10EA6; // 0041022C
<anonymous> * __imp__SetWindowTextW = &g_t10EB4; // 00410230
<anonymous> * __imp__TranslateMessage = &g_t10EC6; // 00410234
<anonymous> * __imp__SendDlgItemMessageW = &g_t10EDA; // 00410238
<anonymous> * __imp__SetWindowPos = &g_t10EF0; // 0041023C
<anonymous> * __imp__PostQuitMessage = &g_t10F00; // 00410240
<anonymous> * __imp__ReleaseDC = &g_t10F12; // 00410244
<anonymous> * __imp__SendMessageW = &g_t10F1E; // 00410248
<anonymous> * __imp__SetWindowLongW = &g_t10F2E; // 0041024C
<anonymous> * __imp__EnableWindow = &g_t10F40; // 00410250
<anonymous> * __imp__CreateWindowExW = &g_t10F50; // 00410254
<anonymous> * __imp__GetWindowRect = &g_t10F62; // 00410258
<anonymous> * __imp__CharNextW = &g_t10F72; // 0041025C
<anonymous> * __imp__BeginPaint = &g_t10F7E; // 00410260
<anonymous> * __imp__BeginPaint = &g_t10F8C; // 00410264
<anonymous> * __imp__DestroyWindow = &g_t10F9A; // 00410268
<anonymous> * __imp__SetWindowPos = &g_t10FAA; // 0041026C
<anonymous> * __imp__DestroyWindow = &g_t10FBA; // 00410270
<anonymous> * __imp__PeekMessageW = &g_t10FCA; // 00410274
<anonymous> * __imp__TranslateMessage = &g_t10FDA; // 00410278
<anonymous> * __imp__SetCursor = &g_t10FEE; // 0041027C
<anonymous> * __imp__DispatchMessageW = &g_t10FFA; // 00410280
<anonymous> * __imp__SendDlgItemMessageW = &g_t1100E; // 00410284
<anonymous> * __imp__SetWindowLongW = &g_t11024; // 00410288
<anonymous> * __imp__MessageBoxW = &g_t11036; // 0041028C
<anonymous> * __imp__GetDesktopWindow = &g_t11044; // 00410290
<anonymous> * __imp__GetDesktopWindow = &g_t11058; // 00410294
word32 g_dw4102DC = 66936; // 004102DC
word32 g_dw4102E0 = 66954; // 004102E0
word32 g_dw4102E4 = 66966; // 004102E4
word32 g_dw4102E8 = 66980; // 004102E8
word32 g_dw4102EC = 66996; // 004102EC
word32 g_dw4102F0 = 0x000105C6; // 004102F0
word32 g_dw4102F4 = 0x000105DE; // 004102F4
word32 g_dw4102F8 = 0x000105EE; // 004102F8
word32 g_dw4102FC = 0x00010606; // 004102FC
word32 g_dw410300 = 0x00010616; // 00410300
word32 g_dw410304 = 0x00010622; // 00410304
word32 g_dw410308 = 0x0001063C; // 00410308
word32 g_dw41030C = 0x0001064C; // 0041030C
word32 g_dw410310 = 0x00010664; // 00410310
word32 g_dw410314 = 0x0001067A; // 00410314
word32 g_dw410318 = 0x00010690; // 00410318
word32 g_dw41031C = 67244; // 0041031C
word32 g_dw410320 = 67266; // 00410320
word32 g_dw410324 = 0x000106D0; // 00410324
word32 g_dw410328 = 67292; // 00410328
word32 g_dw41032C = 0x000106EC; // 0041032C
word32 g_dw410330 = 0x00010702; // 00410330
word32 g_dw410334 = 0x00010714; // 00410334
word32 g_dw410338 = 67364; // 00410338
word32 g_dw41033C = 0x00010736; // 0041033C
word32 g_dw410340 = 0x00010744; // 00410340
word32 g_dw410344 = 0x00010750; // 00410344
word32 g_dw410348 = 0x0001076E; // 00410348
word32 g_dw41034C = 67466; // 0041034C
word32 g_dw410350 = 67474; // 00410350
word32 g_dw410354 = 0x000107A0; // 00410354
word32 g_dw410358 = 67500; // 00410358
word32 g_dw41035C = 67526; // 0041035C
word32 g_dw410360 = 67546; // 00410360
word32 g_dw410364 = 67558; // 00410364
word32 g_dw410368 = 0x00010800; // 00410368
word32 g_dw41036C = 0x0001081E; // 0041036C
word32 g_dw410370 = 0x00010830; // 00410370
word32 g_dw410374 = 0x00010838; // 00410374
word32 g_dw410378 = 67664; // 00410378
word32 g_dw41037C = 67686; // 0041037C
word32 g_dw410380 = 0x00010882; // 00410380
word32 g_dw410384 = 67738; // 00410384
word32 g_dw410388 = 0x000108A8; // 00410388
word32 g_dw41038C = 67770; // 0041038C
word32 g_dw410390 = 67786; // 00410390
word32 g_dw410394 = 67806; // 00410394
word32 g_dw410398 = 0x000108EE; // 00410398
word32 g_dw41039C = 0x00010904; // 0041039C
word32 g_dw4103A0 = 0x00010916; // 004103A0
word32 g_dw4103A4 = 67884; // 004103A4
word32 g_dw4103A8 = 0x0001093E; // 004103A8
word32 g_dw4103AC = 0x0001094A; // 004103AC
word32 g_dw4103B0 = 0x00010960; // 004103B0
word32 g_dw4103B4 = 0x00010976; // 004103B4
word32 g_dw4103B8 = 67978; // 004103B8
word32 g_dw4103BC = 0x0001099E; // 004103BC
word32 g_dw4103C0 = 0x000109AE; // 004103C0
word32 g_dw4103C4 = 68026; // 004103C4
word32 g_dw4103C8 = 68038; // 004103C8
word32 g_dw4103CC = 68056; // 004103CC
word32 g_dw4103D0 = 68068; // 004103D0
word32 g_dw4103D4 = 68080; // 004103D4
word32 g_dw4103D8 = 0x000109FE; // 004103D8
word32 g_dw4103DC = 68116; // 004103DC
word32 g_dw4103E0 = 0x00010A24; // 004103E0
word32 g_dw4103E4 = 0x00010A30; // 004103E4
word32 g_dw4103E8 = 68162; // 004103E8
word32 g_dw4103EC = 68182; // 004103EC
word32 g_dw4103F0 = 0x00010A5E; // 004103F0
word32 g_dw4103F4 = 68206; // 004103F4
word32 g_dw4103F8 = 0x00010A7A; // 004103F8
word32 g_dw4103FC = 0x00010A8A; // 004103FC
word32 g_dw410400 = 0x00010AA0; // 00410400
word32 g_dw410404 = 0x00010AB0; // 00410404
word32 g_dw410408 = 68284; // 00410408
word32 g_dw41040C = 0x00010ACA; // 0041040C
word32 g_dw410410 = 0x00010AE4; // 00410410
word32 g_dw410414 = 68338; // 00410414
word32 g_dw410418 = 0x00010B08; // 00410418
word32 g_dw41041C = 0x00010B20; // 0041041C
word32 g_dw410420 = 68414; // 00410420
word32 g_dw410424 = 0x00010B4E; // 00410424
word32 g_dw41042C = 68460; // 0041042C
word32 g_dw410430 = 68478; // 00410430
word32 g_dw410434 = 68500; // 00410434
word32 g_dw410438 = 0x00010BA0; // 00410438
word32 g_dw41043C = 0x00010BAC; // 0041043C
word32 g_dw410440 = 0x00010BBE; // 00410440
word32 g_dw410444 = 0x00010BD0; // 00410444
word32 g_dw410448 = 0x00010BE0; // 00410448
word32 g_dw41044C = 0x00010BEE; // 0041044C
word32 g_dw410450 = 68602; // 00410450
word32 g_dw410454 = 0x00010C0C; // 00410454
word32 g_dw410458 = 68638; // 00410458
word32 g_dw41045C = 68654; // 0041045C
word32 g_dw410460 = 0x00010C40; // 00410460
word32 g_dw410464 = 68694; // 00410464
word32 g_dw410468 = 68708; // 00410468
word32 g_dw41046C = 0x00010C74; // 0041046C
word32 g_dw410470 = 0x00010C86; // 00410470
word32 g_dw410474 = 68756; // 00410474
word32 g_dw410478 = 68772; // 00410478
word32 g_dw41047C = 68788; // 0041047C
word32 g_dw410480 = 0x00010CC4; // 00410480
word32 g_dw410484 = 68818; // 00410484
word32 g_dw410488 = 0x00010CE0; // 00410488
word32 g_dw41048C = 68844; // 0041048C
word32 g_dw410490 = 68856; // 00410490
word32 g_dw410494 = 0x00010D0A; // 00410494
word32 g_dw410498 = 0x00010D1A; // 00410498
word32 g_dw41049C = 0x00010D26; // 0041049C
word32 g_dw4104A0 = 68916; // 004104A0
word32 g_dw4104A4 = 0x00010D42; // 004104A4
word32 g_dw4104A8 = 0x00010D4E; // 004104A8
word32 g_dw4104AC = 0x00010D60; // 004104AC
word32 g_dw4104B0 = 0x00010D70; // 004104B0
word32 g_dw4104B4 = 68990; // 004104B4
word32 g_dw4104B8 = 69002; // 004104B8
word32 g_dw4104BC = 69020; // 004104BC
word32 g_dw4104C0 = 0x00010DA8; // 004104C0
word32 g_dw4104C4 = 0x00010DB8; // 004104C4
word32 g_dw4104C8 = 69060; // 004104C8
word32 g_dw4104CC = 0x00010DD2; // 004104CC
word32 g_dw4104D0 = 0x00010DDE; // 004104D0
word32 g_dw4104D4 = 69094; // 004104D4
word32 g_dw4104D8 = 69106; // 004104D8
word32 g_dw4104DC = 69118; // 004104DC
word32 g_dw4104E0 = 0x00010E0C; // 004104E0
word32 g_dw4104E4 = 0x00010E1C; // 004104E4
word32 g_dw4104E8 = 69160; // 004104E8
word32 g_dw4104EC = 0x00010E3A; // 004104EC
word32 g_dw4104F0 = 69190; // 004104F0
word32 g_dw4104F4 = 0x00010E5A; // 004104F4
word32 g_dw4104F8 = 69222; // 004104F8
word32 g_dw4104FC = 69236; // 004104FC
word32 g_dw410500 = 0x00010E80; // 00410500
word32 g_dw410504 = 69266; // 00410504
word32 g_dw410508 = 69286; // 00410508
word32 g_dw41050C = 69300; // 0041050C
word32 g_dw410510 = 0x00010EC6; // 00410510
word32 g_dw410514 = 69338; // 00410514
word32 g_dw410518 = 0x00010EF0; // 00410518
word32 g_dw41051C = 0x00010F00; // 0041051C
word32 g_dw410520 = 0x00010F12; // 00410520
word32 g_dw410524 = 0x00010F1E; // 00410524
word32 g_dw410528 = 69422; // 00410528
word32 g_dw41052C = 0x00010F40; // 0041052C
word32 g_dw410530 = 0x00010F50; // 00410530
word32 g_dw410534 = 69474; // 00410534
word32 g_dw410538 = 69490; // 00410538
word32 g_dw41053C = 0x00010F7E; // 0041053C
word32 g_dw410540 = 69516; // 00410540
word32 g_dw410544 = 0x00010F9A; // 00410544
word32 g_dw410548 = 0x00010FAA; // 00410548
word32 g_dw41054C = 69562; // 0041054C
word32 g_dw410550 = 0x00010FCA; // 00410550
word32 g_dw410554 = 69594; // 00410554
word32 g_dw410558 = 0x00010FEE; // 00410558
word32 g_dw41055C = 69626; // 0041055C
word32 g_dw410560 = 69646; // 00410560
word32 g_dw410564 = 69668; // 00410564
word32 g_dw410568 = 69686; // 00410568
word32 g_dw41056C = 0x00011044; // 0041056C
word32 g_dw410570 = 0x00011058; // 00410570
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004067F6: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
Win32CrtStartup_entry:
	esp = fp
	Top = null
	cl = cl | 0x59
	C.u0 = false
	ch = ch - 0x6D - C
	SCZO = cond(ch)
	al = al + dl + C
	SCZO = cond(al)
	goto l004067FD
l004062ED:
l0040631B:
l0040634C:
	v107 = edi
	edi = eax
	eax = v107
l00406351:
l00406375:
l004063A6:
	edi = ebx
	&edx.u3->a0000->u0 = (word32) edx - 1468476387
	SCZO = cond(edx)
	v41 = (ecx & 0x01 << 0x06) != 0x00
	ecx = __rcr<word32,byte>(ecx, 0x06, C)
	ah = ah >> cl
	ecx = ecx & eax
	C.u0 = false
	edx = edx - 2372107309 - C
	dl = dl & bh
	C.u0 = false
	eax = eax - 0x446369AE - C
	&ecx.u3->a0000->u0 = (word32) ecx + 0x7BB89D86
	dl = dl >> 0x03
	ah = -ah
	SZO = cond(ah)
	v42 = (eax & 0x01 << 0x20 - 0x0A) != 0x00
	eax = __rol<word32,byte>(eax, 0x0A)
	v43 = (ecx & 0x01 << cl) != 0x00
	ecx = __ror<word32,byte>(ecx, cl)
	C = v43
	dl = al
	v61 = (eax & 0x01 << 0x20 - 0x18) != 0x00
	eax = __rcl<word32,byte>(eax, 0x18, C)
	C = v61
	ch = ch + ah + C
	SZP = cond(dx & cx)
	edx.u0 = 0x9C7D0647
	dh = dh << cl
	SCZO = cond(dh)
	ch = ch + bh + C
	SCZO = cond(ch)
	v62 = (al & 0x01 << cl) != 0x00
	al = __rcr<byte,byte>(al, cl, C)
	dh = dh & al
	SCZO = cond(edi - ~0x03D8D01C)
	goto l004064ED
l004063DE:
	bl = bl + cl
	SCZO = cond(bl)
	edi = edi - 1830918113 - C
	edi = edi << 0x17
	v129 = (dl & 0x01 << 0x08 - 0x11) != 0x00
	dl = __rol<byte,byte>(dl, 0x11)
	SZP = cond(edx & 750166768)
	C.u0 = false
	dh = dh - bh - C
	cl = cl << 22
	SCZO = cond(cl)
	cx = cx - 0x01
	esi = esi + 1672922382 + C
	SCZO = cond(esi)
	bl = bl - dh - C
	cx = cx >> cl
	bl = bl | 0xC4
	SZ = cond(bl)
	O = false
	C.u0 = false
	goto l00406740
l0040641D:
	v114 = (ecx & 0x01 << cl) != 0x00
	ecx = __rcr<word32,byte>(ecx, cl, C)
	C = v114
	v115 = (ebx & 0x01 << 0x04) != 0x00
	ebx = __rcr<word32,byte>(ebx, 0x04, C)
	C = v115
	v116 = (esi & 0x01 << 0x17) != 0x00
	esi = __rcr<word32,byte>(esi, 0x17, C)
	C = cx != 0x00
	cx = -cx
	cx = cx + dx + C
	edx = edx >> cl
	SCZO = cond(esi - 2817961198)
	branch Test(NE,Z) l00406647
l00406430:
	al = *esi.u0
	esi = esi + 1
	ax = edi.u3->b20E850F *16 al
	SCZO = cond(ax)
	v127 = Mem0[eax + 0x00:byte] + al
	*eax = v127
	SCZO = cond(v127)
l00406433:
l00406437:
l00406439:
	*edi = eax
	&edi.u3->a0000->u0 = (word32) edi + 4
	al = al - 0x44
	SCZO = cond(al)
	ecx.u3->t806743A7.u3 = (struct Eq_3692 *) edi
	goto l00406442
l00406441:
l00406442:
	ecx = ecx ^ ~0x5C05F22B
	SZ = cond(ecx)
	O = false
	C.u0 = false
	return
l00406467:
	si = si - 0x01
	esi = esi >> 0x07
	ah = ah | 0x25
	esi = esi >> cl
	ah = ah << cl
	si = si + dx
	edi = edi - 108798090
	di = ~di
	eax = eax | 0xF00C762B
	C.u0 = false
	al = al + bl + C
	v126 = (dx & 0x01 << 0x10 - cl) != 0x00
	dx = __rol<word16,byte>(dx, cl)
	SCZO = cond(esi - 3584002913)
l00406496:
	branch Test(NE,Z) l004067C5
l0040649C:
	esp = esp - 4
	*esp = SCZDOP
	esp = esp - 2
	*esp = ss
	ecx = ecx - 0x01
	branch Test(EQ,Z) && ecx != 0x00 l00406430
l004064A0:
	fn81492E67()
l004064A2:
	ecx = ecx - 0x01
	branch Test(NE,Z) && ecx != 0x00 l004064ED
l004064A8:
	branch Test(ULT,C) l00406506
l004064AA:
	cl.u0 = 0xC1
	eax = eax - 0x6616C6C0 - C
	eax = eax & ebx
	ch = ch << cl
	dl = dl >> cl
	al = al | 88
	esi = esi << 0x10
	eax = eax << 0x10
	SCZO = cond(eax)
	&dl.u3->a0000->u0 = &dl.u3->b0001
	esi = ebx
	al = al ^ ah
	ecx = -ecx
	si = si << cl
	cx = cx + di
	dh = dh << 0x0A
	edi.u0 = 911026005
	al = al & 0x15
	C.u0 = false
	&dl.u3->a0000->u0 = &dl.u3->b0001
	SZO = cond(dl)
	edx = edx - 0x01
	al = al - ah - C
	SCZO = cond(al)
	v88 = (eax & 0x01 << 0x20 - cl) != 0x00
	eax = __rcl<word32,byte>(eax, cl, C)
	al = al >> cl
	SZP = cond(eax & 2802780857)
	dh = dh | ch
	C.u0 = false
	v89 = (cx & 0x01 << 0x10 - cl) != 0x00
	cx = __rcl<word16,byte>(cx, cl, C)
	edi = edi ^ 1932441622
	&ah.u3->a0000->u0 = &ah.u3->b0001
	ecx = ecx | ebx
	cl = cl ^ ah
	O = false
	dx = dx >> cl
	SCZ = cond(dx)
	v90 = (al & 0x01 << 0x0E) != 0x00
	al = __ror<byte,byte>(al, 0x0E)
	C = v90
	goto l00406617
l004064CD:
l004064ED:
	branch Test(NE,Z) l00406467
l004064F6:
	cl = cl & (ecx.u3)->b0001
	v64 = *((word32) ebx + ((word32) ebp - 0x7C0E7E74)) - dh
	&((word32) ebx + ((word32) ebp - 0x7C0E7E74))->u3->a0000->u0 = v64
	SCZO = cond(v64)
l004064FD:
	ecx = ecx - 0x01
	branch ecx != 0x00 l00406496
l00406503:
	cl = cl & ~0x0A
	SZ = cond(cl)
	O = false
	C.u0 = false
l00406506:
	v65 = (bh & 0x01 << cl) != 0x00
	bh = __rcr<byte,byte>(bh, cl, C)
	bx = bx << cl
	cl = ~cl
	ecx = ecx << 0x18
	ecx = ecx >> 0x12
	SCZ = cond(ecx)
	cl = cl + bh + C
	SZP = cond(di & bx)
	&cl.u3->a0000->u0 = &cl.u3->b0001
	ch = ch << 0x19
	cl = cl << cl
	SCZO = cond(ecx - 3201272405)
	branch Test(NE,Z) l004067A9
l0040652B:
	v66 = (*((byte) eax.u0 - 1161571663) & 0x01 << 0x01) != 0x00
	*((byte) eax.u0 - 1161571663) = __ror<word32,byte>(*((byte) eax.u0 - 1161571663), 0x01)
	C = v66
	v72 = *((byte) esi.u0 - 81) ^ 0xB8
	&((byte) esi.u0 - 81)->u3->a0000->u0 = v72
	SZ = cond(*((byte) esi.u0 - 81))
	O = false
	C.u0 = false
	goto l00406535
l00406530:
	edx.u0 = 3098506880
	goto l00406535
l00406531:
l00406535:
	dl = dl | ah
	cl = cl - 226
	SCZO = cond(cl)
	ch = ch + al + C
	dl = dl - ch
	SCZO = cond(dl)
	v73 = (di & 0x01 << 0x10 - cl) != 0x00
	di = __rcl<word16,byte>(di, cl, C)
	edx = edx << 0x1C
	v74 = (dl & 0x01 << 0x08 - 22) != 0x00
	dl = __rol<byte,byte>(dl, 22)
	edi = edi ^ ebx
	C.u0 = false
	esi = esi - eax - C
	dh = -dh
	bl = bl << 0x0F
	bh = bh & cl
	SZ = cond(bh)
	O = false
	C.u0 = false
	goto l004068B0
l0040655C:
l0040657D:
l0040658E:
	bx = bx << cl
	cx = cx - bx
	di = (word16) di + 1
	esi = esi & 57918588
	SZ = cond(esi)
	O = false
	C.u0 = false
	goto l004064FD
l004065A7:
l004065D2:
	SZP = cond(esi & 4072232440)
	ax = ax << cl
	dh = dh | ch
	ecx = ecx >> 0x15
	dh = dh ^ cl
	edi = esi
	dx = dx << cl
	&esi.u3->a0000->u0 = &esi.u3->b0001
	esi = esi ^ 2203968924
	v35 = (cl & 0x01 << 0x07) != 0x00
	cl = __ror<byte,byte>(cl, 0x07)
	&eax.u3->a0000->u0 = (word32) eax + 1151834518
	esi = esi | 0x124F65C4
	SCZO = cond(edx - 0x0684B528)
	branch Test(NE,Z) l004063A6
l0040660F:
	__bound<word32>(ebx, ecx.u3->dwBE49968D)
	ax = __aad(ax)
l00406617:
	edi = edi & edx
	C.u0 = false
	v37 = (dl & 0x01 << 0x08 - 0x13) != 0x00
	dl = __rcl<byte,byte>(dl, 0x13, C)
	al = al - ~0x0A
	esi = esi << 0x04
	v38 = (ch & 0x01 << 0x18) != 0x00
	ch = __ror<byte,byte>(ch, 0x18)
	SZP = cond(edi & 475187315)
	cx = cx - si
	SCZO = cond(cx)
	&ch.u3->a0000->u0 = (bool) C.u0 + ((byte) ch + 70)
	SCZO = cond(esi - 1707259787)
	branch Test(NE,Z) l00406706
l00406643:
	&eax.u3->a0000->u0 = (bool) C.u0 + ((word32) eax - 2116830600)
	SCZO = cond(eax)
l00406647:
	fnC268B7E9()
	ecx = ecx ^ 0x63EBC60F
	&ecx.u3->a0000->u0 = &ecx.u3->b0001
	ax = ax & cx
	edx = edx >> 0x09
	dx = dx & cx
	C.u0 = false
	v40 = (cl & 0x01 << 0x08 - 0x19) != 0x00
	cl = __rcl<byte,byte>(cl, 0x19, C)
	ch = ch << cl
	ch = -ch
	ebx = ebx - 0xC7718D11
	SCZO = cond(ebx)
	dh = dh << cl
	&eax.u3->a0000->u0 = (word32) eax + 1663109504
	SCZO = cond(eax)
	dh = dh - bl - C
	SCZO = cond(dh)
	bh = bh + dl + C
	&ebx.u3->a0000->u0 = (word32) ebx - 0x4EE54C38
	dl = dl >> cl
	bl = bl & al
	&edi.u3->a0000->u0 = (word32) edi - 0x1513929A
	ch = bh
	eax.u0 = 0x03
	SCZO = cond(ebx - 829986226)
	branch Test(NE,Z) l004063DE
	goto l00406934
l00406673:
	al = ah
	return
l0040669B:
	bl = bl - dl
	al.u0 = edx.u3->tFFFFFFFF.u0
	SCZO = cond(eax - 0xC000002E)
	branch Test(EQ,Z) l0040641D
l004066AC:
	ax = ax - si
	dl = dl << 0x1C
	eax = eax << cl
	&eax.u3->a0000->u0 = (byte) eax.u0 - 559784792
	ebx = ebx >> 0x19
	ecx = ecx >> 0x02
	SCZO = cond(ecx)
	ch = ch & 0xB0
	SZ = cond(ch)
	O = false
	C.u0 = false
	goto l00406442
l004066D3:
	edi = edi << 0x11
	SCZO = cond(edi)
	bx = bx + ax + C
	ecx = ecx - edi
	ecx = ecx & 2333485682
	C.u0 = false
	bl = bl - 0x01
	esi = esi + 145714025 + C
	SCZO = cond(esi)
	esi = esi + ebx + C
	bh = bh - 0x01
	SCZO = cond(edx - 3252692327)
	branch Test(NE,Z) l0040693A
l004066FF:
	ebx = *esp
	&esp.u3->a0000->u0 = (word32) esp + 4
	__cli()
	Top->r0000 = Top->r0003 / Top->r0000
	SCZO = cond(al - *edi.u0)
	&edi.u3->a0000->u0 = (byte) edi.u0 + 1
	&v118.u3->a0000->u0 = ebx.u3->tFA13E6D2.u3
	ebx.u3->tFA13E6D2.u3 = (struct Eq_3692 *) esp
	esp = v118
	goto l0040670A
l00406706:
	dh = dh << cl
	SCZO = cond(dh)
	edi = edi + edx + C
	SCZO = cond(edi)
l0040670A:
	&edi.u3->a0000->u0 = (word32) edi - 0x5FCFCFE3
	SCZO = cond(edi)
	&dl.u3->a0000->u0 = (bool) C.u0 + ((byte) dl + 0x00C4)
	dh = dh + ~0x50
	SCZO = cond(dh)
	v44 = (ecx & 0x01 << 0x20 - cl) != 0x00
	ecx = __rcl<word32,byte>(ecx, cl, C)
	v45 = (edi & 0x01 << 0x1A) != 0x00
	edi = __ror<word32,byte>(edi, 0x1A)
	C = v45
	v46 = (ch & 0x01 << 0x0D) != 0x00
	ch = __rcr<byte,byte>(ch, 0x0D, C)
	C = v46
	v47 = (edi & 0x01 << 0x20 - 0x11) != 0x00
	edi = __rcl<word32,byte>(edi, 0x11, C)
	dh = dh | ~0x44
	dl = dl | 0x43
	C.u0 = false
	v48 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	C = v48
	si = si - di - C
	SCZO = cond(esi - 0xD8CE5285)
	branch Test(NE,Z) l00406530
l00406738:
	dh = dh | *((word32) esi + ebx * 0x02)
	C.u0 = false
	v49 = (*ebx & 0x01 << 0x08 - 0x01) != 0x00
	*ebx = __rcl<byte,byte>(*ebx, 0x01, C)
	__out<word32>(0xAA, eax)
	v50 = esi.u3->b0003 << 202
	esi.u3->b0003 = v50
	SCZO = cond(v50)
l00406740:
	ebx = ebx & 4171208311
	C.u0 = false
	v51 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	ecx.u0 = 3191125895
	esi = esi >> 0x1B
	edx = edx ^ edx
	esi = esi >> 0x17
	SCZO = cond(esi)
	v52 = (bh & 0x01 << 0x08 - 22) != 0x00
	bh = __rcl<byte,byte>(bh, 22, C)
	ecx = ecx - esi
	si = si - 0x01
	v53 = (bh & 0x01 << 0x08 - 0x04) != 0x00
	bh = __rol<byte,byte>(bh, 0x04)
	SZP = cond(edi & 0x07698956)
	O = false
	C.u0 = false
	goto l00406851
l00406774:
l00406776:
	v120 = (ecx & 0x01 << 0x20 - 0x07) != 0x00
	ecx = __rcl<word32,byte>(ecx, 0x07, C)
	C = v120
	v121 = (ecx & 0x01 << 11) != 0x00
	ecx = __rcr<word32,byte>(ecx, 11, C)
	&ch.u3->a0000->u0 = (byte) ch + 227
	v122 = (bl & 0x01 << 0x0C) != 0x00
	bl = __ror<byte,byte>(bl, 0x0C)
	C = v122
	v123 = (cl & 0x01 << 0x08 - cl) != 0x00
	cl = __rcl<byte,byte>(cl, cl, C)
	bx = ~bx
	ebx = ebx - 0x01
	edi = edi << 0x1E
	si = si + cx
	ecx = ecx ^ eax
	&ecx.u3->a0000->u0 = (byte) ecx.u0 + 0x0A00FB18
	esi = ~esi
	SCZO = cond(edi - 2987333992)
	branch Test(NE,Z) l00406976
l004067A4:
	esp.u0 = 3239363715
	goto l004067AA
l004067A9:
	ecx = ecx >> 0x04
	SCZO = cond(ecx)
l004067AA:
	v75 = (bl & 0x01 << 0x08 - cl) != 0x00
	bl = __rol<byte,byte>(bl, cl)
	esi = esi - 824430453
	&bh.u3->a0000->u0 = (byte) bh.u0 + 1
	ch = ch ^ dh
	O = false
	C.u0 = false
	v76 = (cl & 0x01 << 0x08 - 0x15) != 0x00
	cl = __rcl<byte,byte>(cl, 0x15, C)
	ecx = ecx >> cl
	ebx = ebx >> 0x12
	SCZ = cond(ebx)
	goto l004069D3
l004067C5:
	v124 = (esi & 0x01 << 0x20 - 0x1C) != 0x00
	esi = __rol<word32,byte>(esi, 0x1C)
	C = v124
	esi = esi + 0x6CA38B3A + C
	ch = ch >> 0x0F
	SZP = cond(di & si)
	C.u0 = false
	al = al - ah - C
	SCZO = cond(al)
	dh = dh - 0x77 - C
	SCZO = cond(dh)
	v125 = (edi & 0x01 << cl) != 0x00
	edi = __rcr<word32,byte>(edi, cl, C)
	edx = edx ^ 0x92A0D726
	di = (word16) di + 1
	SCZO = cond(edx - 983480776)
	branch Test(NE,Z) l004068D7
l004067EF:
	bh = bh - *((byte) ebp.u0 + 336477399) - C
	SCZO = cond(bh)
	__halt()
l004067F6:
l004067FD:
	SZP = cond(ecx & edi)
	bx = bx & dx
	v17 = (esi & 0x01 << 0x05) != 0x00
	esi = __ror<word32,byte>(esi, 0x05)
	ah = ah ^ al
	C.u0 = false
	ch = ch + bh + C
	ecx = ecx & 0x648FAFAF
	dl = dl - ~0x32
	SCZO = cond(dl)
	v21 = (ax & 0x01 << 0x10 - cl) != 0x00
	ax = __rol<word16,byte>(ax, cl)
	v23 = (al & 0x01 << 0x14) != 0x00
	al = __ror<byte,byte>(al, 0x14)
	edi = edi << 0x18
	SCZO = cond(edi)
	al = al - bl - C
	&ah.u3->a0000->u0 = (byte) ah + 226
	SZP = cond(eax & 1975857055)
	v26 = (cx & 0x01 << cl) != 0x00
	cx = __ror<word16,byte>(cx, cl)
	cl = cl - dl
	di = di >> cl
	cl = cl >> 0x02
	al = al & ~0x19
	C.u0 = false
	v30 = (dl & 0x01 << 0x08 - cl) != 0x00
	dl = __rcl<byte,byte>(dl, cl, C)
	SCZO = cond(edi - 0x8AD15CD8)
	branch Test(NE,Z) l004065D2
	goto l0040684D
l0040681D:
l0040684D:
	eax = eax - 3249036131
	SCZO = cond(eax)
l00406851:
	return
l00406853:
	v117 = Mem0[edx + 0x00:word32] + ecx + C
	*edx = v117
	SCZO = cond(v117)
	__fsave(ecx.u3->wD6DB812B)
	&esp.u3->a0000->u0 = &esp.u3->b0001
	SZO = cond(esp)
	branch Test(LE,SZO) l004067FD
l0040685E:
	gs = ax
	ch = ch >> cl
	SCZO = cond(ch)
	bl = bl + ch + C
	SZP = cond(esi & ~0x481B261B)
	C = cl != 0x00
	cl = -cl
	bh = bh - ~0x4C - C
	esi = esi << 0x1D
	cl = cl >> cl
	SCZO = cond(cl)
	ch = cl
	v119 = (ecx & 0x01 << 0x20 - cl) != 0x00
	ecx = __rcl<word32,byte>(ecx, cl, C)
	C = v119
	goto l00406776
l0040687F:
l004068AB:
	branch Test(NO,O) l00406853
l004068AD:
	branch Test(PO,P) l004068DA
l004068AF:
	eax = *esi.u0
	esi = esi + 4
l004068B0:
	v79 = (edx & 0x01 << 0x1C) != 0x00
	edx = __rcr<word32,byte>(edx, 0x1C, C)
	SZP = cond(ecx & edi)
	bh = bh ^ 0x3D
	cl = cl - dh
	v80 = (esi & 0x01 << 0x10) != 0x00
	esi = __ror<word32,byte>(esi, 0x10)
	C = v80
	eax = eax - 2653015061 - C
	SCZO = cond(eax)
	bh = bh >> cl
	SCZ = cond(bh)
	esp = esp - 4
	esp->u0 = 0x00
	eax = *esp
	&esp.u3->a0000->u0 = (word32) esp + 4
	v81 = (bl & 0x01 << cl) != 0x00
	bl = __ror<byte,byte>(bl, cl)
	C = v81
	edi = edi >> 0x1A
	dh = ~dh
	SZP = cond(edx & 2677729725)
	edx = edx >> 0x12
	bh.u0 = 0xE0
	ecx = ecx | ebx
	C.u0 = false
	edx = edx - 1428798471 - C
	edx = edx ^ edx
	C.u0 = false
	v91 = (bl & 0x01 << 0x08 - 0x06) != 0x00
	bl = __rcl<byte,byte>(bl, 0x06, C)
	v92 = (bl & 0x01 << 0x08 - cl) != 0x00
	bl = __rol<byte,byte>(bl, cl)
	edi = edi << 0x0C
	SCZO = cond(edi)
	cl = cl - al - C
	SCZO = cond(cl)
	v105 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rol<byte,byte>(bh, cl)
	ch = ch >> 0x1A
	ebx = ebx ^ 1012277513
	C.u0 = false
	ch = ch + ah + C
	__syscall<byte>(0x2E)
	esi = ebx
	bh = bh & bl
	edi = edi & edx
	esi = esi + 86809901
	bl = bl >> 0x1A
	di = si
	v106 = (bl & 0x01 << 0x08 - cl) != 0x00
	bl = __rol<byte,byte>(bl, cl)
	edi = edi & eax
	SCZO = cond(eax - 824794452)
	branch Test(NE,Z) l0040669B
	goto l0040634C
l004068D7:
	dl = dl + ah + C
	SCZO = cond(dl)
	ch = ch >> 0x07
	SCZ = cond(ch)
	goto l004068DC
l004068DA:
	D = true
	es = *esp
	&esp.u3->a0000->u0 = (word32) esp + 2
l004068DC:
	edx = edx >> 0x07
	SCZ = cond(edx)
	v101 = (ax & 0x01 << cl) != 0x00
	ax = __rcr<word16,byte>(ax, cl, C)
	ch = ch >> cl
	SCZ = cond(ch)
	v102 = (edx & 0x01 << cl) != 0x00
	edx = __rcr<word32,byte>(edx, cl, C)
	SZP = cond(edx & 0xA2A04F34)
	O = false
	v103 = (edi & 0x01 << 0x20 - 0x15) != 0x00
	edi = __rol<word32,byte>(edi, 0x15)
	v104 = (ah & 0x01 << 0x08 - 0x12) != 0x00
	ah = __rol<byte,byte>(ah, 0x12)
	C = v104
	goto l004064A2
l004068FF:
l00406934:
	eax = __in<word32>(dx)
	&edi.u3->a0000->u0 = (word32) edi + 4
	esi.u0 = 3051519321
l0040693A:
	v54 = (ecx & 0x01 << cl) != 0x00
	ecx = __ror<word32,byte>(ecx, cl)
	bh = bh - 0x01
	edi.u0 = 0xE42BB42B
	ebx = ebx + 1326738727
	SCZO = cond(edx - 30093446)
	branch Test(NE,Z) l004069B6
l00406951:
	al = al << 0x13
	ax = ~ax
	bl = bl >> cl
	v55 = (cl & 0x01 << 22) != 0x00
	cl = __ror<byte,byte>(cl, 22)
	C = v55
	&cl.u3->a0000->u0 = (bool) C.u0 + ((byte) cl + 0x00D0)
	edx = edx << 0x17
	SCZO = cond(esi - 1320214007)
	branch Test(NE,Z) l00406673
l0040696E:
	al = al - 0x7B
	SCZO = cond(al)
	v56 = *esi.u0
	*edi = v56
	esi = esi + 1
	&edi.u3->a0000->u0 = &edi.u3->b0001
	branch Test(PO,P) l004069DE
l00406973:
	v58 = *edx.u0 >> 0x7B
	*edx.u0 = v58
	SCZO = cond(v58)
l00406976:
	edi = edi << cl
	ch = ch >> 0x17
	esi = esi & 524769343
	ch = ~ch
	ebx = ebx & 0x6740DFD7
	C.u0 = false
	bl = bl - 0x13 - C
	ch = ch >> cl
	SCZO = cond(ch)
	di = di + bx + C
	eax = gs
	edi = edi >> 0x19
	SCZO = cond(edi)
	v60 = (bh & 0x01 << 0x08 - 0x1D) != 0x00
	bh = __rcl<byte,byte>(bh, 0x1D, C)
	bh = bh & ah
	SZ = cond(bh)
	O = false
	C.u0 = false
l0040699A:
	edi = edi | edx
	C.u0 = false
	bh = bh - cl - C
	SCZO = cond(bh)
	v67 = (cl & 0x01 << 0x08 - cl) != 0x00
	cl = __rcl<byte,byte>(cl, cl, C)
	si = (word16) si + 1
	bl = bl & ah
	C.u0 = false
	v68 = (bl & 0x01 << cl) != 0x00
	bl = __rcr<byte,byte>(bl, cl, C)
	SZP = cond(ch & dl)
	C.u0 = false
	v69 = (edi & 0x01 << cl) != 0x00
	edi = __rcr<word32,byte>(edi, cl, C)
	&cl.u3->a0000->u0 = (byte) cl.u0 + 0x00BE
	SCZO = cond(cl)
	cl = ch
	ch = ~ch
	v77 = (esi & 0x01 << 0x06) != 0x00
	esi = __rcr<word32,byte>(esi, 0x06, C)
	SZP = cond(ecx & 0xA5653E03)
	C.u0 = false
	v78 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	bh = bh | al
	ecx = ecx ^ edi
	C.u0 = false
	edi = edi - 0x067A072D - C
	bx = bx >> cl
	esi = esi << cl
	edi = edi - ebx
	SCZO = cond(edi)
	v83 = (ebx & 0x01 << 0x20 - 0x01) != 0x00
	ebx = __rcl<word32,byte>(ebx, 0x01, C)
	&edx.u3->a0000->u0 = (byte) edx.u0 + 1
	v84 = (bl & 0x01 << 0x08 - cl) != 0x00
	bl = __rol<byte,byte>(bl, cl)
	bl = bl << cl
	v85 = (cl & 0x01 << 0x08 - 0x04) != 0x00
	cl = __rol<byte,byte>(cl, 0x04)
	v86 = (bh & 0x01 << 0x08 - 0x1D) != 0x00
	bh = __rol<byte,byte>(bh, 0x1D)
	bh.u0 = 0x7B
	ecx = ecx | 3701106103
	cx = cx + dx
	&cl.u3->a0000->u0 = (byte) cl.u0 + 1
	ecx = ecx << 0x1D
	v87 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rol<byte,byte>(bh, cl)
	SCZO = cond(edx - 3608601310)
	branch Test(NE,Z) l004066D3
	goto l004068AB
l004069B6:
	bx = -bx
	bl = bl >> cl
	v128 = (bl & 0x01 << 0x14) != 0x00
	bl = __ror<byte,byte>(bl, 0x14)
	ecx = ecx + eax
	bh = bh + cl
	SCZO = cond(bh)
	ch = ch >> 0x1E
	SCZ = cond(ch)
	bl.u0 = 0x77
	SZP = cond(bx & ax)
	ecx = ecx << cl
	SCZO = cond(ecx)
	v130 = (esi & 0x01 << 0x1B) != 0x00
	esi = __ror<word32,byte>(esi, 0x1B)
	v131 = (eax & 0x01 << 0x01) != 0x00
	eax = __ror<word32,byte>(eax, 0x01)
	C = v131
	branch Test(ULT,C) l00406776
	goto l0040658E
l004069CD:
	bh = bh | *((byte) eax.u0 - 0x24100F2D)
	SZ = cond(bh)
	O = false
	C.u0 = false
l004069D3:
	fn0040761C()
l004069D7:
	ecx = ecx - 0x01
	SZO = cond(ecx)
	Top->r0000 = *((byte) edi.u0 + 84) /64 Top->r0000
l004069DA:
	eax = eax | 0xC6A7E460
	SZ = cond(eax)
	O = false
	C.u0 = false
	ecx = ecx - 0x01
	branch Test(EQ,Z) && ecx != 0x00 l0040699A
	goto l004069E3
l004069DE:
	al = __in<byte>(~0x58)
	cl.u0 = ~0x48
	goto l004069E3
l004069E1:
l004069E3:
	SZP = cond(*((byte) esi.u0 + 0x0066) & ebx)
	O = false
	C.u0 = false
	branch Test(NO,O) l004069CD
l004069E9:
	bh.u0 = 113
	edx_eax = *((byte) eax.u0 - 26) *64 eax
	SCZO = cond(edx_eax)
	esp = esp - 2
	*esp = cs
	branch Test(NO,O) l004069D7
l004069F1:
	v95 = esp
	esp = esp - 4
	*esp = eax
	esp = esp - 4
	*esp = ecx
	esp = esp - 4
	*esp = edx
	esp = esp - 4
	*esp = ebx
	esp = esp - 4
	*esp = v95
	esp = esp - 4
	*esp = ebp
	esp = esp - 4
	*esp = esi
	esp = esp - 4
	*esp = edi
	eax = __in<word32>(dx)
	branch Test(GE,SO) l004069DA
l004069F6:
	al = *((word32) ebx + (uint32) al)
	ebp.u0 = 0x666676D0
	esp = esp - 4
	*esp = ebp
	ebp = esp
	esp = esp - 9700
	edx = *esp
	&esp.u3->a0000->u0 = (word32) esp + 4
	v98 = esp
	esp = esp - 4
	*esp = eax
	esp = esp - 4
	*esp = ecx
	esp = esp - 4
	*esp = edx
	esp = esp - 4
	*esp = ebx
	esp = esp - 4
	*esp = v98
	esp = esp - 4
	*esp = ebp
	esp = esp - 4
	*esp = esi
	esp = esp - 4
	*esp = edi
	__syscall<byte>(~0x12)
	v108 = edi
	edi = eax
	eax = v108
	SZP = cond(al & 0xD2)
	ch = ch >> 0x01
	SCZ = cond(ch)
	O = false
	esp = esp - 2
	esp->u0 = ~0x34
	SZP = cond(*((word32) ebx + (edi * 0x02 + 66)) & ah)
	O = false
	C.u0 = false
	ecx = ecx - 0x01
	branch ecx != 0x00 l00406B2F
	goto l00406AE5
l00406A66:
l00406ADB:
l00406AE5:
	return
l00406B2F:
	ebx = *esp
	&esp.u3->a0000->u0 = (word32) esp + 4
	es = *esp
	&esp.u3->a0000->u0 = (word32) esp + 2
	&al.u3->a0000->u0 = (byte) al.u0 + 7
	SCZO = cond(al)
	esi = esi + 0x01
	esp = esp - 4
	esp->u0 = 3880413288
	v109 = ecx.u3->b66FF6548 - 0x66 - C
	ecx.u3->b66FF6548 = v109
	SCZO = cond(di - *((byte) ebp.u0 + 0x66666CD4))
	bh.u0 = 33
	esp = esp - 4
	esp->u0 = 0xF1306868
	eax = eax - 0x01
	__sti()
	v110 = esp
	esp = esp - 4
	*esp = eax
	esp = esp - 4
	*esp = ecx
	esp = esp - 4
	*esp = edx
	esp = esp - 4
	*esp = ebx
	esp = esp - 4
	*esp = v110
	esp = esp - 4
	*esp = ebp
	esp = esp - 4
	*esp = esi
	esp = esp - 4
	*esp = edi
	bp = 0x6031
	v112 = ecx.u3->dw0061 << cl
	ecx.u3->dw0061 = v112
	SCZO = cond(v112)
	es_esi.u2 = ecx.u3->tFFFFFFAF.u2
	return
Win32CrtStartup_exit:
}

// 00407492: define fn00407492
// Called from:
//      fn0040761C
define fn00407492
{
	esp = fp;
	Top = 0;
	SZP = cond(si & dx);
	ah >>= cl;
	SCZ = cond(ah);
	ch = cl;
	ah = ah - ~0x10 - C;
	SCZO.u0 = cond(ah);
	ch = ch + dh + C;
	SCZO.u0 = cond(ch);
	ecx = ~0x4411C746;
	al = (ui8) &(C.u5 + (al + ~0x06) /8 2)->b0000;
	al <<= 0x14;
	SCZO.u0 = cond(al);
	v17 = (ah & 0x01 << cl) != 0x00;
	ah = __rcr<byte,byte>(ah, cl, C);
	v18 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	ah |= dl;
	SZ = cond(ah);
	O = false;
	C.u0 = false;
	dh |= bh;
	al = (byte) ah.u0 + al;
	dh <<= 0x1D;
	edi = edi ^ ebx;
	C.u0 = false;
	al = (ui8) ((bool) C.u0 + (al + ~0x0A));
	C.u0 = false;
	dl = (bool) C.u0 + (dl + dh);
	ecx = ecx ^ ~0x4411CDF0;
	v24 = (eax & 0x01 << 0x20 - 0x15) != 0x00;
	eax = __rol<word32,byte>(eax, 0x15);
	SZP = cond(ax & cx);
	C.u0 = false;
	esi = esi - 3576648263 - C;
	di += cx;
	di += si;
	SCZO.u0 = cond(di);
	v30 = (*edi & 0x01 << 0x08 - 0x81) != 0x00;
	*edi = __rol<byte,byte>(*edi, 0x81);
	SCZO.u1 = esp->u1;
	esp = (union Eq_2047 *) ((char *) esp + 4);
}

// 004074B5: define fn004074B5
// Called from:
//      fn0040761C
define fn004074B5
{
	esp = fp;
	Top = 0;
	v5 = (si & 0x01 << cl) != 0x00;
	si = __ror<word16,byte>(si, cl);
	eax -= 1836841301;
	dl = ~dl;
	al = ~al;
	esi |= 701392731;
	C.u0 = false;
	v15 = (esi & 0x01 << 0x0A) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x0A, C);
	al = al ^ bl;
	ah |= 199;
	esi |= edx;
	si |= bx;
	ax <<= cl;
	SCZO = cond(ax);
	fn00407715();
}

// 004074E3: define fn004074E3
// Called from:
//      fn0040761C
define fn004074E3
{
	esp = fp;
	Top = 0;
	v5 = eax->dw0050;
	esp -= 4;
	*esp = v5;
	esp -= 4;
	*esp = ecx;
	eax = &eax->dw0050 + 0x0C;
	eax = (struct Eq_2209 *) eax->t0000;
	eax += ecx / 84;
	SCZO = cond(eax);
	eax = eax->ptr0010;
	eax += ecx / 84;
	eax->t0000();
	ecx = *esp;
	++esp;
	ebx = *esp;
	++esp;
	v10 = (al & 0x01 << 0x08 - cl) != 0x00;
	al = __rol<byte,byte>(al, cl);
	C = v10;
	ecx >>= 0x13;
	SCZ = cond(ecx);
	fn00407777();
}

// 0040759C: define fn0040759C
// Called from:
//      fn0040761C
define fn0040759C
{
	esp = fp;
	Top = 0;
	al >>= cl;
	*ebx = dl;
	di >>= cl;
	SZP = cond(ah & dl);
	esi >>= cl;
	edi = 2429412969;
	al |= 0x13;
	C.u0 = false;
	--ah;
	edi = edi - 841881333 - C;
	al = al ^ cl;
	C.u0 = false;
	++ebx;
	SZO = cond(ebx);
	v19 = (eax & 0x01 << 0x20 - 0x1D) != 0x00;
	eax = __rcl<word32,byte>(eax, 0x1D, C);
	C = v19;
	fn00407804();
}

// 004075EE: define fn004075EE
// Called from:
//      fn0040761C
define fn004075EE
{
	word32 esi;
	word32 ecx;
	byte bl;
	byte bh;
	word16 di;
	si = (word16) esi;
	word16 ax;
	word16 eax_16_16;
	word32 edx;
	word16 edi_16_16;
	word16 ebx_16_16;
	cl_5 = (byte) ecx;
	Top_3 = 0;
	ecx_6 = ecx << cl_5;
	cl_12 = (byte) ecx_6;
	&ch_17.u3->a0000->u0 = SLICE(ecx_6, byte, 8);
	ecx_16_16_57 = SLICE(ecx_6, word16, 16);
	bl_10 = bl + 0x89 + (byte) (ecx_6 < 0x00);
	bh_13 = bh >> cl_12;
	di_16 = di & si;
	cl_18 = cl_12 - ch_17;
	esi_20 = esi;
	si_28 = (word16) (esi_20 >> 0x01);
	esi_16_16_59 = SLICE(esi_20 >> 0x01, word16, 16);
	ax_24 = __rol<word16,byte>(ax, cl_18);
	eax_26 = SEQ(eax_16_16, ax_24);
	eax_16_16_36 = SLICE(eax_26 - 0x01, word16, 16);
	SZP_30 = cond(si_28 & ax_24 - 0x01);
	P_61 = SLICE(SZP_30, bool, 5);
	edx_32 = edx >> 0x11;
	dx_47 = (word16) (edx >> 0x11);
	ax_33 = ax_24 - 0x01 ^ di_16;
	eax_cl_54 = SEQ(eax_37, cl_18);
	eax_39 = SLICE(eax_cl_54 + ~0x2843D980F4, word32, 8);
	eax_37 = SEQ(eax_16_16_36, ax_33);
	edi_45 = SEQ(edi_16_16, di_16);
	ebx_51 = SEQ(ebx_16_16, bh_13, bl_10);
	eax_41 = -eax_39;
	ch_43 = __ror<byte,byte>(ch_17, (byte) cl_18.u1 + 11);
	edi_46 = edi_45 >> (byte) cl_18.u1 + 11;
	si_48 = si_28 | dx_47;
	O_49 = false;
	ebx_52 = ebx_51 >> 22;
	SCZ_53 = cond(ebx_51 >> 22);
	C_56 = SLICE(SCZ_53, bool, 1);
	ecx_58 = SEQ(ecx_16_16_57, ch_43, (byte) cl_18.u1 + 11);
	esi_60 = SEQ(esi_16_16_59, si_48);
	S_62 = (bool) SCZ_53;
	Z_63 = SLICE(SCZ_53, bool, 2);
}

// 0040761C: define fn0040761C
// Called from:
//      Win32CrtStartup
define fn0040761C
{
	esp = fp;
	Top = 0;
	v4 = (ecx & 0x01 << 0x20 - 0x04) != 0x00;
	ecx = __rcl<word32,byte>(ecx, 0x04, C);
	al |= 0x2E;
	v10 = (eax & 0x01 << 0x20 - 0x09) != 0x00;
	eax = __rol<word32,byte>(eax, 0x09);
	bl |= dl;
	SZP = cond(bx & di);
	C.u0 = false;
	bl = bl - al - C;
	ebx &= edx;
	C.u0 = false;
	cx = cx - si - C;
	v22 = (dh & 0x01 << 0x0C) != 0x00;
	dh = __ror<byte,byte>(dh, 0x0C);
	bl = bl ^ dh;
	SCZO = cond(ecx - 0x5CBC3F6C);
	if (Test(NE,Z))
	{
		esp -= 4;
		*esp = ecx;
		v26 = esp;
		esp -= 4;
		*esp = v26;
		esp -= 4;
		esp->u0 = ~0x40;
		ecx = *esp;
		&esp.u3->a0000->u0 = (word32) esp + 4;
		ecx = ~ecx;
		esp -= 4;
		*esp = ecx;
		eax.u0 = 4225125;
		esp -= 4;
		esp->u0 = ~0x00905A4D;
		edx = *esp;
		&esp.u3->a0000->u0 = (word32) esp + 4;
		edx = ~edx;
		fn00407791();
	}
	else
	{
		esp &= *edx;
		SZ = cond(esp);
		O = false;
		C.u0 = false;
		ax = __aad(ax);
		fn0040764A();
	}
}

// 0040764A: define fn0040764A
// Called from:
//      fn0040761C
//      fn00407804
define fn0040764A
{
	esp = fp;
	Top = 0;
	al >>= 0x04;
	v7 = (al & 0x01 << 0x08 - cl) != 0x00;
	al = __rol<byte,byte>(al, cl);
	esi |= 4292177230;
	SZ = cond(esi);
	O = false;
	C = false;
	fn00407655();
}

// 00407655: define fn00407655
// Called from:
//      fn0040761C
//      fn0040764A
define fn00407655
{
	esp = fp;
	Top = 0;
	esi = esi ^ 2598888659;
	al <<= 0x17;
	eax &= ~0x2681E80B;
	al = ~al;
	SCZO = cond(edi - 0xD4A253F4);
	if (Test(NE,Z))
		fn004076FC();
	else
		fn00407672();
}

// 00407672: define fn00407672
// Called from:
//      fn0040761C
//      fn00407655
define fn00407672
{
	esp = fp;
	Top = 0;
	dh <<= 0x1B;
	SCZO = cond(dh);
	fn004075EE();
}

// 004076FC: define fn004076FC
// Called from:
//      fn0040761C
//      fn00407655
define fn004076FC
{
	esp = fp;
	Top = null;
	eax <<= cl;
	al = al ^ ch;
	C.u0 = false;
	esi = esi + edx + C;
	SCZO = cond(esi);
	ax = ax - cx - C;
	SCZO = cond(edi - 2792324908);
	if (Test(NE,Z))
	{
		v21 = (eax & 0x01 << cl) != 0x00;
		eax = __rcr<word32,byte>(eax, cl, C);
		SCZO = cond(edi - 2834221106);
		dh = (uint8) ((bool) C.u0 + ((byte) dl.u0 + dh));
		SCZO = cond(dh);
		v24 = (edx & 0x01 << 0x20 - cl) != 0x00;
		edx = __rcl<word32,byte>(edx, cl, C);
		ax -= si;
		dh >>= cl;
		dl -= 0x03;
		dl = -dl;
		dl = dl ^ 0xB8;
		dl >>= cl;
		dl.u0 = ebx->u0;
		SCZO = cond(ebx - 756909865);
		if (Test(NE,Z))
		{
			&al.u3->a0000->u0 = (byte) al.u0 + bh;
			SCZO = cond(al);
			while (true)
			{
				esi = (int32) ((bool) C.u0 + (esi + 773002929));
				ah <<= 0x1A;
				ah.u0 = ~0x52;
				edi <<= 0x0C;
				SCZO = cond(edi);
				v35 = (ah & 0x01 << cl) != 0x00;
				ah = __rcr<byte,byte>(ah, cl, C);
				edi >>= 0x18;
				eax <<= cl;
				SCZO = cond(eax);
				esi >>= 0x09;
				SCZ = cond(esi);
				&dl.u3->a0000->u0 = (byte) dl.u0 + 0x0082;
				v36 = (ah & 0x01 << 0x08 - 0x12) != 0x00;
				ah = __rol<byte,byte>(ah, 0x12);
				ax |= si;
				eax >>= 0x10;
				eax -= 3616232934;
				SCZO = cond(eax);
				esi = (int32) ((bool) C.u0 + (esi + 1926530558));
				SCZO = cond(esi);
				v37 = (ah & 0x01 << 0x0E) != 0x00;
				ah = __rcr<byte,byte>(ah, 0x0E, C);
				v38 = (edi & 0x01 << 0x13) != 0x00;
				edi = __ror<word32,byte>(edi, 0x13);
				C = v38;
				eax = eax + ecx + C;
				SCZO = cond(eax);
				v40 = (eax & 0x01 << 0x20 - 0x05) != 0x00;
				eax = __rcl<word32,byte>(eax, 0x05, C);
				v41 = (di & 0x01 << cl) != 0x00;
				di = __ror<word16,byte>(di, cl);
				ah >>= cl;
				&al.u3->a0000->u0 = &al.u3->b0001;
				SCZO = cond(ebx - 2778555475);
				if (Test(NE,Z))
					break;
				edx.u3->bB039D2E8 = 0x02;
			}
			v42 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rol<byte,byte>(ah, cl);
			edi >>= 0x12;
			v43 = (dl & 0x01 << 0x08 - 0x1F) != 0x00;
			dl = __rol<byte,byte>(dl, 0x1F);
			al >>= 0x08;
			SCZ = cond(al);
			al = al + ah + C;
			v44 = (ah & 0x01 << cl) != 0x00;
			ah = __ror<byte,byte>(ah, cl);
			al -= 0x57;
			edi >>= 0x07;
			++esi;
			ah = ah ^ dh;
			si -= ax;
			&al.u3->a0000->u0 = (byte) al + 0x0094;
			dl = dl ^ 117;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			fn00407791();
		}
		else
		{
			v29 = Mem0[edi + eax:byte] & bl;
			Mem0[edi + eax:byte] = v29;
			SZ = cond(Mem0[edi + eax:byte]);
			C.u0 = false;
			dl = dl + dl + C;
			al = __in<byte>(~0x09);
			*Top += (real64) eax.u3->dwD0D394D8;
			ah = -ah;
			al >>= cl;
			SCZ = cond(al);
			v30 = (ah & 0x01 << cl) != 0x00;
			ah = __rcr<byte,byte>(ah, cl, C);
			ah >>= cl;
			v31 = (ah & 0x01 << 0x08 - 0x1C) != 0x00;
			ah = __rol<byte,byte>(ah, 0x1C);
			al = ~al;
			di -= bx;
			SCZO = cond(di);
			fn004074B5();
		}
	}
	else
	{
		ah.u0 = 222;
		if (Test(LE,SZO))
			fn00407791();
		else
			fn00407715();
	}
}

// 00407715: define fn00407715
// Called from:
//      fn004074B5
//      fn0040761C
define fn00407715
{
	esp = fp;
	Top = 0;
	edi <<= 11;
	v9 = (ah & 0x01 << cl) != 0x00;
	ah = __ror<byte,byte>(ah, cl);
	SZP = cond(al & ah);
	ah >>= cl;
	al = al ^ 0x6C;
	++al;
	si += dx;
	eax <<= 0x15;
	ah = ah ^ cl;
	ax += si;
	di <<= cl;
	SCZO = cond(di);
	fn0040759C();
}

// 00407777: define fn00407777
// Called from:
//      fn004074E3
//      fn00407804
define fn00407777
{
	word16 cx;
	ptr32 fp;
	word32 esi;
	byte al;
	cl = (byte) cx;
	ch = SLICE(cx, byte, 8);
	byte dl;
	byte ah;
	word16 bx;
	word16 ecx_16_16;
	word16 eax_16_16;
	word16 ebx_16_16;
	byte dh;
	word16 edx_16_16;
	word32 edi;
	esp_22 = fp;
	Top_23 = 0;
	esi_25 = esi | 0xB6282EC0;
	SZP_28 = cond(al & cl);
	C_29 = false;
	cx_31 = cx;
	v11_32 = (cx_31 & 0x01 << 0x10 - cl) != 0x00;
	cx_33 = __rcl<word16,byte>(cx_31, cl, false);
	C_34 = v11_32;
	al_35 = (bool) v11_32 + (al + ~0x06);
	dl_37 = dl ^ 0x93;
	C_38 = false;
	v15_40 = (ah & 0x80) != 0x00;
	ah_41 = __rcr<byte,byte>(ah, 0x07, false);
	C_42 = v15_40;
	v17_43 = false;
	dl_44 = __rcl<byte,byte>(dl ^ 0x93, 0x10, v15_40);
	C_45 = false;
	cx_47 = (word16) cx_33 + bx;
	SCZO_48 = cond(cx_47);
	ecx_50 = SEQ(ecx_16_16, cx_47);
	eax_52 = SEQ(eax_16_16, ah_41, al_35);
	ebx_54 = SEQ(ebx_16_16, bx);
	fn00407791();
	esp_64 = fp;
}

// 00407791: define fn00407791
// Called from:
//      fn004074E3
//      fn0040761C
//      fn00407777
define fn00407791
{
	word32 ecx;
	word32 esi;
	word32 eax;
	ptr32 fp;
	word32 ebx;
	byte dh;
	al = (byte) eax;
	byte dl;
	word16 edx_16_16;
	ah = SLICE(eax, byte, 8);
	ch = SLICE(ecx, byte, 8);
	word32 edi;
	cl = (byte) ecx;
	ecx_16_16 = SLICE(ecx, word16, 16);
	eax_16_16 = SLICE(eax, word16, 16);
	esi_16_16 = SLICE(esi, word16, 16);
	<unknown> Mem0;
	esp_2 = fp;
	Top_3 = 0;
	ebx_5 = ebx - ~0x05B0;
	bl_32 = (byte) ebx - 0x4F;
	dh_8 = dh & al;
	edx_11 = SEQ(edx_16_16, dh_8, dl);
	dx_23 = SEQ(dh_8, dl);
	eax_94 = eax;
	esi_147 = esi;
	if (edx_11 != 3746710310)
	{
		ah_17 = ah + ch + (byte) (edx_11 < 3746710310);
		ecx_21 = ecx;
		edi_22 = edi - ecx_21;
		cx_24 = (word16) ecx;
		SZP_25 = cond(dx_23 & cx_24);
		P_161 = SLICE(SZP_25, bool, 5);
		dl_29 = __rcr<byte,byte>(dl, 0x05, false);
		cl_31 = __rol<byte,byte>(cl, 0x10);
		dl_33 = (byte) (dl_29.u3 + bl_32 /8 0x66FF6549);
		esp_34 = fp - 4;
		dh_37 = __ror<byte,byte>(dh_8, 0x0D);
		dl_40 = (byte) (dh_37.u3 + dl_33 /8 0x66FF6549);
		ax_42 = SEQ(ah_17 - 0x82, al);
		ax_43 = ax_42 & dx_23;
		eax_45 = SEQ(eax_16_16, ax_43);
		al_69 = (byte) ax_43;
		esi_49 = SEQ(esi_16_16, dx_23);
		edx_24_8_76 = SEQ(edx_16_16, dh_37);
		if (eax_45 != 2638523138)
		{
			SCZO_50 = cond(esi_49 - 788834774);
			C_54.u0 = SLICE(SCZO_50, bool, 1);
			cx_52 = SEQ(ch, cl_31 - 0x01);
			cx_55 = __rcl<word16,byte>(cx_52, cl_31 - 0x01, C_54);
			cl_56 = (byte) cx_55;
			ch_60 = SLICE(cx_55, byte, 8);
			cl_58 = __rol<byte,byte>(cl_56, cl_56);
			ebx_59 = ebx;
			cx_61 = SEQ(ch_60, cl_58);
			cx_62 = cx_61 | dx_23;
			cl_63 = (byte) cx_62;
			dl_64 = dl_40 << cl_63;
			SCZO_65 = cond(dl_64);
			C_67.u0 = SLICE(SCZO_65, bool, 1);
			cx_68 = __rcr<word16,byte>(cx_62, cl_63, C_67);
			ch_74 = SLICE(cx_68, byte, 8);
			cl_139 = (byte) cx_68;
			ah_70 = cl_31 - 0x01 + al_69;
			ch_75 = ~ch_74;
			edx_77 = SEQ(edx_24_8_76, dl_64 - 0xC4);
			SCZO_78 = cond(edx_77 - (struct Eq_3144 *) 3278026383);
			Z_79 = SLICE(SCZO_78, bool, 2);
			eax_80 = SEQ(eax_16_16, ah_70, al_69 & 0x91);
			C_135.u0 = SLICE(SCZO_78, bool, 1);
			ecx_140 = SEQ(ecx_16_16, ch_75, cl_139);
			esi_148 = SEQ(esi_16_16, dx_23);
			O_157 = SLICE(SCZO_78, bool, 4);
			S_165 = (bool) SCZO_78;
			if (edx_77 != (struct Eq_3144 *) 3278026383)
				fn00407492();
			else
			{
				eax_85 = __in<word32>(0xC1);
				edi_22->u0 = (int8) __rol<byte,byte>(edi_22->u0, 0x81);
				C_134.u0 = SLICE(ebx - ~0x05B0, bool, 1);
				O_156 = SLICE(ebx - ~0x05B0, bool, 4);
				S_164 = (bool) ebx - true;
				Z_168 = SLICE(ebx - ~0x05B0, bool, 2);
				esp_89 = fp;
			}
		}
	}
	else
	{
		SZP_95 = cond(eax_94 & ~0x0BE801AE);
		P_160 = SLICE(SZP_95, bool, 5);
		edx_97 = edx_11 ^ ebx->dw05B1;
		Top_102 = 1;
		while (true)
		{
			eax_103 = (eax_110, eax_94);
			if (eax_103->ptr0000 == edx_97)
				break;
			eax_108 = eax_103 - 0x01;
			eax_110 = __align(eax_108, 0x00008000);
		}
		ecx_112 = eax_103;
		cl_117 = (byte) eax_103;
		&eax_113.u3->a0000->u0 = eax_103 + eax_103->dw003C / 64;
		SCZO_115 = cond(ebx - ~0x05B0 - 3933387023);
		Z_116 = SLICE(SCZO_115, bool, 2);
		C_119.u0 = SLICE(SCZO_115, bool, 1);
		O_155 = SLICE(SCZO_115, bool, 4);
		S_163 = (bool) SCZO_115;
		if (ebx != (struct Eq_3156 *) 3933385566)
			fn004074E3();
		else
			edx_97->tFFFFFFDF.u0 = (int8) __rcr<byte,byte>(edx_97->tFFFFFFDF.u0, cl_117, C_119);
	}
}

// 00407804: define fn00407804
// Called from:
//      fn0040759C
define fn00407804
{
	esp = fp;
	Top = 0;
	++di;
	al >>= cl;
	esi -= 3241339236;
	ah = ah ^ dh;
	ah <<= cl;
	SCZO = cond(ah);
	v16 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	SZP = cond(ah & ~0x30);
	--ecx;
	++di;
	al >>= 0x13;
	SCZO = cond(al);
	ah = ~ah;
	v19 = (ah & 0x01 << 0x08 - 0x01) != 0x00;
	ah = __rcl<byte,byte>(ah, 0x01, C);
	al += cl;
	SCZO = cond(al);
	eax &= 2331637025;
	al = al ^ bh;
	ah &= bh;
	C.u0 = false;
	edi = ecx;
	v23 = (al & 0x01 << 0x0A) != 0x00;
	al = __rcr<byte,byte>(al, 0x0A, C);
	si = si ^ bx;
	al -= dh;
	al >>= 0x18;
	ah >>= cl;
	ah &= dh;
	esi >>= cl;
	SCZO = cond(edx - 0xB0557790);
	if (Test(NE,Z))
	{
		&esi.u3->a0000->u0 = (bool) C.u0 + ((word32) esi + 98837448);
		ax >>= cl;
		esi >>= cl;
		al <<= 11;
		SCZO = cond(al);
		eax = eax - 0x500F3430 - C;
		ah.u0 = ~0x62;
		edi -= 727559180;
		SZP = cond(ah & 0x95);
		ah -= 0xAA;
		al += ch;
		SCZO = cond(al);
		fn0040764A();
	}
	else
	{
		&al.u3->a0000->u0 = (bool) C.u0 + ((byte) al + 70);
		int3();
		--edx;
		SZO = cond(edx);
		al.u0 = ebx[(uint32) al].t0000.u0;
		__fldenv(*edi);
		ecx >>= 0x13;
		SCZ = cond(ecx);
		fn00407777();
	}
}

