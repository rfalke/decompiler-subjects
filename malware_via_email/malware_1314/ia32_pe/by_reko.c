// subject_UPX1.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0055A4D0: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	word16 * fp;
	struct Eq_4 * ebp;
	struct Eq_5 * cs;
	word64 rArg0;
	word16 * esp_151 = fp;
	do
	{
		word32 * edi_29 = g_a55B200;
		do
		{
			Eq_10 esp_11 = esp_151 - 4;
			esp_11.u0->t0000.u1 = (DWORD) 0x00;
			esp_11.u0->tFFFFFFFC.u0 = (struct Eq_645 *) esp_11;
			esp_11.u0->tFFFFFFF8.u0 = (struct Eq_645 *) esp_11;
			esp_11.u0->tFFFFFFF4.u0 = (struct Eq_645 *) esp_11;
			esp_11.u0->tFFFFFFF0 = 0x00;
			esp_11.u0->tFFFFFFEC = null;
			DWORD eax_24 = GetTapePosition(*((word32) esp_11 - 20), esp_11.u0->tFFFFFFF0, *((word32) esp_11 - 0x0C), *((word32) esp_11 - 8), *((word32) esp_11 - 4));
			Eq_13 ecx_26 = esp_11.u0->t0000.u1;
			*edi_29 += (word32) eax_24 - 0x40DC2007;
			*edi_29 = __ror<word32,byte>(*edi_29, 0x10);
			Eq_83 edi_34 = (char *) edi_29 + 18;
			edi_29 = edi_34 - 0x0E;
		} while (edi_34 <= 0x0055B68A);
		struct Eq_90 * ebx_51;
		int16 * ecx_52;
		byte * esi_55;
		struct Eq_93 * edi_57;
		word32 eax_49 = fn0055B200((word32) eax_24 - 0x40DC2007, ecx_26, esp_11, &g_t55B67C, ebp, edi_34 - 0x0E, out ecx_52, out ebx_51, out ebp, out esi_55, out edi_57);
		uint32 v15_63 = ebx_51->dw138F172D << 0x60;
		ebx_51->dw138F172D = v15_63;
		uint8 al_78 = (byte) eax_49;
		word24 eax_24_8_91 = SLICE(eax_49, word24, 8);
		byte cl_128 = (byte) ecx_52;
		word16 ecx_16_16_130 = SLICE(ecx_52, word16, 16);
		struct Eq_134 * ebx_66 = esp_11.u0->ptr0004;
		esp_151 = (word32) esp_11 + 8;
		if (OVERFLOW<word32>(v15_63))
			__syscall<byte>(0x04);
		bool v48_166;
		edi_57->b0000 = *esi_55;
		ebx_66->bFFFFFFC1 = ebx_66->bFFFFFFC1 - al_78 - (byte) (v15_63 < 0x00);
		cu8 al_106 = SLICE(SEQ(al_78 + 0x69, al_78) + 15721, byte, 8);
		byte SCZO_87 = cond(al_106);
		Eq_172 CZ_88 = SLICE(SCZO_87, bool, 2);
		up32 eax_92 = SEQ(eax_24_8_91, al_106);
		bool Z_105 = SLICE(SCZO_87, bool, 2);
		bool C_116 = SLICE(CZ_88, bool, 1);
		C_116 = SLICE(CZ_88, bool, 1);
		int16 * ecx_126 = ecx_52;
		if (al_106 <= 0x00)
		{
			if (OVERFLOW<byte>(al_106))
				__syscall<byte>(0x04);
			esp_11.u0->ptr0006 = cs;
			esp_151 = &esp_11.u0->ptr0006;
			v48_166 = Z_105 | SLICE(C_116, bool, 2);
			word32 eax_143 = SEQ(eax_24_8_91, al_106);
			if (al_106 == 0x00)
				__out<word32>(0x2E, eax_143);
		}
		else
		{
			al_106 -= 0x3C;
			v48_166 = eax_92 > 3734358844;
			ecx_126 = SEQ(ecx_16_16_130, 0x8C, cl_128);
		}
		edi_57->b0001 = al_106;
	} while (!v48_166);
	*ecx_126 = (int16) rArg0;
}

// subject_UPX2.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0055B1C4: void fn0055B1C4(Register Eq_13 eax, Register Eq_13 ecx)
// Called from:
//      fn0055B200
void fn0055B1C4(Eq_13 eax, Eq_13 ecx)
{
	bool v13_45;
	ecx.u1[117] = (struct Eq_646) 0x0D;
	if ((eax & 1237755472) == 0x00)
	{
		ui32 eax_14 = eax & 1237755472 & 1237755472;
		if (eax_14 != 0x00)
		{
			fn0055B1E5(ecx);
			return;
		}
		v13_45 = (eax_14 & 1237755472) != 0x00;
	}
	else
		v13_45 = ecx != 0x01;
	if (v13_45)
		fn0055B1ED();
	else
		fn0055B1E0();
}

// 0055B1E0: void fn0055B1E0()
// Called from:
//      fn0055B1C4
void fn0055B1E0()
{
	word32 ecx_17;
	fn0055B1F5(out ecx_17);
}

// 0055B1E5: void fn0055B1E5(Register Eq_13 ecx)
// Called from:
//      fn0055B1C4
void fn0055B1E5(Eq_13 ecx)
{
	if (ecx != 0x01)
	{
		word32 ecx_43;
		fn0055B1F5(out ecx_43);
	}
	else
	{
		word32 ecx_44;
		fn0055B1E8(out ecx_44);
	}
}

// 0055B1E8: Register Eq_13 fn0055B1E8(Register out ptr32 ecxOut)
// Called from:
//      fn0055B1E5
//      fn0055B1F5
Eq_13 fn0055B1E8(ptr32 & ecxOut)
{
	ptr32 ecx_7;
	Eq_13 eax_6 = fn0055B1F5(out ecx_7);
	ecxOut = ecx_7;
	return eax_6;
}

// 0055B1ED: void fn0055B1ED()
// Called from:
//      fn0055B1C4
void fn0055B1ED()
{
}

// 0055B1F5: Register word32 fn0055B1F5(Register out ptr32 ecxOut)
// Called from:
//      fn0055B1E0
//      fn0055B1E5
//      fn0055B1E8
//      fn0055B1ED
//      fn0055B200
word32 fn0055B1F5(ptr32 & ecxOut)
{
	ptr32 ecx_9;
	word32 eax_10 = fn0055B1E8(out ecx_9);
	ecxOut = ecx_9;
	return eax_10;
}

// 0055B200: Register Eq_13 fn0055B200(Register Eq_13 eax, Register Eq_13 ecx, Register Eq_10 edx, Register (ptr32 Eq_4) ebx, Register (ptr32 Eq_4) ebp, Register Eq_13 edi, Register out Eq_13 ecxOut, Register out (ptr32 Eq_4) ebxOut, Register out (ptr32 Eq_4) ebpOut, Register out ptr32 esiOut, Register out Eq_13 ediOut)
// Called from:
//      Win32CrtStartup
//      fn0055B1F5
Eq_13 fn0055B200(Eq_13 eax, Eq_13 ecx, Eq_10 edx, struct Eq_4 * ebx, struct Eq_4 * ebp, Eq_13 edi, union Eq_13 & ecxOut, struct Eq_4 & ebxOut, struct Eq_4 & ebpOut, ptr32 & esiOut, union Eq_13 & ediOut)
{
	ptr32 fp;
	Eq_435 CZ;
	Eq_436 P_148;
	struct Eq_437 * ss;
	ptr32 esi;
	struct Eq_4 * esp_24 = fp - 4;
	if (CZ)
	{
l0055B234:
		edi.u1->dw0000 = ebx + (edi.u1)->dw0000 / 0x0A;
		Eq_13 v29_15 = edx.u0->t0000.u0 - 0x61;
		edx.u0->t0000.u0 = (byte) v29_15;
		ecx = eax;
		struct Eq_4 * esp_26 = ebx;
		word16 ebx_16_16_84 = SLICE(esp_24, word16, 16);
		P_148 = cond(v29_15) | SLICE(P_148, bool, 5);
		word16 bx_153 = (word16) esp_24;
		byte * eax_205 = SEQ(SLICE(ecx, word16, 16), ~0x49, (byte) ecx);
		do
		{
			edx.u0->dw85480F5 = eax.u1 + (edx.u0)->dw85480F5;
			ci8 ah_41 = SLICE(eax_205, byte, 8) + *eax_205;
			struct Eq_502 * esp_45 = esp_26->dw0000;
			word16 eax_16_16_38 = SLICE(eax_205, word16, 16);
			byte al_28 = (byte) eax_205;
			byte SCZOP_58 = cond(ah_41) | SLICE(P_148, bool, 5);
			byte bl_70 = (byte) bx_153;
			byte bh_106 = SLICE(bx_153, byte, 8);
			P_148.u0 = SLICE(P_148, bool, 5);
			byte dl_52 = (byte) edx;
			word24 edx_24_8_135 = SLICE(edx, word24, 8);
			esp_24 = (struct Eq_4 *) &esp_45->ptr0004;
			word32 eax_48 = SEQ(eax_16_16_38, ah_41, al_28);
			ebx = esp_24;
			Eq_526 P_151 = SLICE(SCZOP_58, bool, 5);
			if (ah_41 <= 0x00)
			{
				byte v45_51 = edx.u0->b0037;
				edx.u0->b0037 = dl_52;
				eax = eax_48 + 0x01;
				edx = SEQ(edx_24_8_135, v45_51);
				if (OVERFLOW<word32>(eax_48 + 0x01))
					__syscall<byte>(0x04);
				goto l0055B234;
			}
			word16 * eax_64 = SEQ(eax_16_16_38, SCZOP_58, al_28);
			ptr32 esi_60 = esp_45->ptr0004;
			*eax_64 -= bx_153;
			eax.u1->wFFFFFFE9 = ss;
			eax_205 = SEQ(eax_16_16_38, SCZOP_58 & bl_70, al_28) + (eax.u1)->dw0000;
			esp_26 = (struct Eq_4 *) &esp_45->ptr000A;
			P_148 = cond(eax_205) | P_151;
		} while (eax_205 >= null);
		if (eax_205 >= null)
		{
			esp_45->ptr0006 = eax_205 + 1;
			int3();
			esp_24->dw7B8C40DC = ebp + esp_24->dw7B8C40DC / 0x0A;
			byte al_91 = (byte) eax_205 + 0x02;
			byte ah_92 = SLICE(eax_205 + 2, byte, 8);
			Eq_13 eax_168 = SEQ(SLICE(eax_205 + 2, word24, 8), al_91 - 171 - (byte) __aaa(al_91, ah_92, &al_91, &ah_92));
			ecxOut = eax;
			ebxOut = esp_24;
			ebpOut = ebp - 0x01;
			esiOut = esi_60;
			ediOut = edi;
			return eax_168;
		}
		else
		{
			struct Eq_4 * ebp_98 = esp_45->ptr000A;
			esp_45->ptr000A = esp_24;
			*(byte *) 0xDC200141 |= bl_70;
			struct Eq_4 * ebx_158 = SEQ(ebx_16_16_84, bh_106 ^ bl_70, bl_70);
			Eq_13 ecx_113;
			Eq_13 eax_112 = fn0055B1F5(out ecx_113);
			ecxOut = ecx_113;
			ebxOut = ebx_158;
			ebpOut = ebp_98;
			esiOut = esi_60;
			ediOut = edi;
			return eax_112;
		}
	}
	else
	{
		edi.u1->dw0000 += fp - 4;
		Eq_13 ecx_127;
		Eq_13 eax_126 = fn0055B1F5(out ecx_127);
		ecxOut = ecx_127;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = eax;
		return eax_126;
	}
}

Eq_4 g_t55B67C = // 0055B67C
	{
		0x40DC2001,
		?? /* Can't read word32 at address 7BE1F758 */ ,
	};
word32 g_dw55B6F8 = 1423117; // 0055B6F8
word32 g_dw55B71F = 1423153; // 0055B71F
word32 g_dw55B73E = 0x0015B753; // 0055B73E
word32 g_dw55B768 = 1423227; // 0055B768
word32 g_dw55B789 = 1423260; // 0055B789
