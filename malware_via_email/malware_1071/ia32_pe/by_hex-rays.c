/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// char __usercall sub_40826A@<al>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, double a4@<st1>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_407DE6; // weak
__int16 word_407E66 = 9268; // weak


//----- (0040826A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_40826A@<al>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, double a4@<st1>)
{
  bool v6; // cf
  int v13; // ecx
  int v14; // ecx
  unsigned int v18; // esi
  char *v19; // edx
  unsigned int v20; // ebx
  int v21; // edx
  _DWORD *i; // eax
  int v27; // eax
  unsigned int v31; // edx
  int v32; // esi
  unsigned int v33; // edi
  unsigned int v35; // edx
  unsigned int v37; // edx
  unsigned int v38; // esi
  unsigned int v39; // edi
  int v43; // edi
  int v45; // edx
  unsigned int v46; // eax
  __int16 v49; // dx
  bool v50; // tt
  int v51; // eax
  char v54; // cl
  unsigned int v55; // edx
  unsigned int v61; // esi
  _DWORD *v62; // ecx
  char *v63; // eax
  __int16 v64; // cx
  __int16 v65; // dx
  unsigned __int16 v67; // dx
  unsigned __int32 v68; // eax
  bool v69; // tt
  unsigned int v70; // edx
  int v73; // edi
  int v75; // [esp-2Ch] [ebp-2Ch]
  int v76; // [esp-20h] [ebp-20h] BYREF

  LOWORD(a1) = a1 + 1;
  v73 = a1 ^ (a2 << 9);
  v76 = a1;
  for ( i = (_DWORD *)&loc_407DE6; *i != 9460301; i = (_DWORD *)(((unsigned int)i - 1) & 0xFFFFF000) )
    ;
  v62 = i;
  v63 = (char *)i + i[15];
  v75 = *((_DWORD *)v63 + 20);
  _EAX = (*(int (__stdcall **)(_DWORD *))((char *)v62
                                        + *(_DWORD *)((char *)v62
                                                    + *(_DWORD *)&v63[(_DWORD)(&word_407E66 - 2113267)]
                                                    + 16)))(v62);
  _EBX = 64;
  _ECX = v75 << v75;
  BYTE1(_ECX) = ((unsigned __int16)(v75 << v75) >> 8) - (__CFSHL__(v75, v75) - 64);
  v32 = ((unsigned __int8)((unsigned __int16)(v75 << v75) >> 8) < (unsigned __int8)(__CFSHL__(v75, v75) - 64))
      + a3
      - 1118282550;
  BYTE1(_EAX) <<= v75 << v75;
  v33 = v73 - v32;
  __asm { rcr     dh, cl }
  if ( _EAX != 1003759853 )
  {
LABEL_34:
    LOBYTE(_EDX) = _ECX | _EDX;
    BYTE1(_EAX) = __ROL1__(BYTE1(_EAX), 27);
    LOWORD(v32) = (__int16)v32 >> _ECX;
    v61 = v32 | 0xB997C614;
    LOWORD(v61) = ~(_WORD)v61;
    if ( v33 == 657318687 )
      return _EAX;
    BYTE1(_ECX) += 70;
    __asm { rcr     cx, cl }
    LOBYTE(_EAX) = ~(_EAX & 0x4E);
    _EAX = __ROR4__(_EAX, _ECX);
    v67 = v61 & _EDX;
    if ( _ECX == -645834185 )
    {
      *(_QWORD *)(v61 + 1) = (__int64)a4;
      v68 = __indword(v67);
      JUMPOUT(0x4081F3);
    }
    v64 = __ROL2__(_ECX, _ECX);
    __asm { rcr     al, 0Bh }
    LOBYTE(v65) = v64;
    HIBYTE(v65) = (HIBYTE(v64) << v64) + 40;
    v49 = v65 >> v64 << v64;
    v50 = __CFSHR__(v49, v64);
    LOWORD(_EDX) = __ROR2__(v49, v64);
    v51 = _EAX - (v50 + 1709603803);
    BYTE1(_EDX) += __CFSHR__(v61, 4) + 57;
    LOWORD(v51) = v51 + 1;
    _ESI = __ROL4__(v61 >> 4, v64);
    _EAX = v51 + 1493089151;
    _DH = BYTE1(_EDX) >> 4;
    _CL = 105;
    __asm
    {
      rcl     eax, 15h
      rcl     eax, cl
    }
    LOWORD(_EAX) = _EAX & 0x256;
    __asm { rcr     dh, cl }
    LOBYTE(_EAX) = _EAX + 64;
    if ( _EAX == 1836273286 )
    {
      __asm { outsd }
      JUMPOUT(0x40811D);
    }
    BYTE1(_EDX) = ~BYTE1(_EDX);
    _CL = 84;
    __asm { rcl     cl, cl }
    v6 = __CFSHL__(_EAX, 6);
    LOBYTE(_EAX) = (_BYTE)_EAX << 6;
    LOBYTE(_EDX) = v6 + _EDX + 34;
    _CL &= 0x80u;
    v35 = _EDX - 1553038028;
    LOBYTE(v35) = _EAX | v35;
    __asm { rcr     cl, 3 }
    _EAX = ((_EAX - (__CFSHL__(v35, _CL) - 724426951)) << _CL) ^ 0xDEAF0069;
    LOBYTE(v35) = __ROL1__(((_BYTE)v35 << _CL) + 125, 13) | 0x40;
    v6 = v35 < 0xEEBBA55;
    v35 -= 250329685;
    LOWORD(v35) = v35 - (v6 + (_WORD)_EAX);
    _EDI = 3035;
    _ECX = (unsigned __int16)__ROR2__(64, 64);
    --BYTE1(_ECX);
    v31 = v35 << 9;
    __asm
    {
      rcr     ecx, cl
      rcl     eax, 10h
    }
    BYTE1(_ECX) = 50;
    LOBYTE(v31) = __ROR1__(v31, 28);
    _ECX = __ROL4__(_ECX, 23);
    LOBYTE(_EAX) = -43;
    _EAX = __ROL4__((__PAIR64__(_EAX, v31) - 0x40A93AC875FE376Ai64) >> 32, 29);
    BYTE1(_EAX) = __ROL1__(BYTE1(_EAX), 21);
    __asm { rcl     di, cl }
    if ( _ECX == 1414181575 )
    {
      __asm { iret }
      JUMPOUT(0x407C06);
    }
    v37 = v31 >> 23;
    v39 = v37 & _EDI;
    goto LABEL_26;
  }
  __asm { rcr     byte ptr ds:8007D2C1h, 0D2h }
  HIWORD(v27) = 27905;
  BYTE1(_EDX) -= 83;
  LOWORD(v33) = (__int16)__ROL2__(v33, _ECX) >> _ECX;
  LOBYTE(v27) = ~(((_BYTE)_EDX - 69) << _ECX);
  LOBYTE(_ECX) = _ECX + 57;
  LOWORD(v33) = v33 | 0x40;
  v6 = __CFSHR__(v33, 12);
  _EDI = v33 >> 12;
  BYTE1(v27) = -6;
  __asm { rcr     di, cl }
  _EAX = _EDX + v6 + v27;
  v37 = _EDX - 920889219;
  LOBYTE(_EAX) = 0;
  if ( _ECX != -489652296 )
  {
    _EDX = ~v37;
    __asm
    {
      rcl     ah, 17h
      rcl     di, cl
      rcl     al, 1Ch
    }
    _CL = -(char)_ECX;
    v43 = __ROR4__(_EDI, 4);
    v6 = __CFSHR__(_EDX, _CL);
    LOWORD(_EDX) = (__int16)_EDX >> _CL;
    __asm { rcl     edx, cl }
    HIWORD(_EDX) = 20576;
    BYTE1(_EAX) = _CL + v6 + BYTE1(_EAX) - 1;
    v46 = _EAX + 437254942;
    LOWORD(v46) = v43;
    LOBYTE(_ECX) = __ROL1__(_CL, 8);
    _EAX = __ROL4__(v46, 12);
    LOBYTE(_EDX) = __ROL1__(-45, 23);
    BYTE1(_EDX) = -37;
    LOWORD(_EDX) = ~(_WORD)_EDX;
    __asm
    {
      rcl     edx, 2
      rcl     edx, cl
    }
    LOBYTE(_EDX) = 44;
    LOWORD(v43) = (_WORD)v43 << _ECX << _ECX;
    v6 = __CFSHL__(_EDX, 23);
    _EDX <<= 23;
    BYTE1(_EAX) += _EDX + v6;
    LOWORD(_EDX) = _ECX ^ _EDX;
    v45 = _EDX + 1809776702;
    LOBYTE(_ECX) = ~(_BYTE)_ECX;
    BYTE1(v45) = -BYTE1(v45);
    LOWORD(v45) = v45 - 1;
    v21 = v32 & v45;
    LOBYTE(v21) = (char)v21 >> _ECX;
    v6 = __CFSHR__(BYTE1(v21), _ECX);
    SBYTE1(v21) >>= _ECX;
    _EDX = (_DWORD *)((v21 - (v6 - 37627507)) ^ 0x25E7DA75);
    if ( v43 == -1821567154 )
    {
      *_EDX -= &v76;
      LOBYTE(_EAX) = __inbyte(0x45u);
      __asm { aam     19h }
      goto LABEL_14;
    }
    __asm { rcl     edx, cl }
    _EDX = _EDX << _ECX;
    BYTE1(_EDX) = _ECX;
    _ECX = (_ECX - 1146299893) << 17;
    v33 = v43 + 1735438129;
    LOWORD(_ECX) = _ECX + 1;
    _EAX = -651287095;
    __asm { rcl     al, cl }
    if ( v33 != 999878703 )
    {
      __asm { rcl     cl, 7 }
      _AH = __ROR1__(0, _ECX) ^ 0x39;
      if ( _ECX != 180792907 )
      {
        MEMORY[0x40] = BYTE1(_EDX);
        __asm { rcl     ah, 15h }
        v13 = _ECX - 1;
        LOBYTE(v13) = -89;
        v14 = v13 << 23;
        v6 = __CFADD__((_WORD)v14, 64);
        LOWORD(v14) = v14 + 64;
        _AL = v32 + v6;
        if ( _EDX == 1622317816 )
        {
          if ( v14 == 1 )
          {
            __asm { xlat }
            JUMPOUT(0x407CEA);
          }
          __asm { iret }
          JUMPOUT(0x407CAB);
        }
        _ECX = (unsigned int)~v14 >> 19;
        LOBYTE(_ECX) = __ROL1__(_ECX, 29);
        __asm { rcr     cx, cl }
        JUMPOUT(0x407D87);
      }
      _EAX = *(_DWORD *)_EDX * MEMORY[0x10D0584C];
      goto LABEL_17;
    }
    *(_DWORD *)_EAX += v32;
    __asm { int     0F4h }
    goto LABEL_34;
  }
  v38 = MEMORY[0xAEFB4D8A] ^ v32;
  v39 = _EDI >> 30;
  __asm { rcr     cl, cl }
  if ( _EAX != -545655804 )
  {
LABEL_26:
    BYTE1(v37) = __CFSHL__(v39, 3) + BYTE1(v37) - 13;
    v6 = __CFADD__((_BYTE)_EAX, -111);
    LOBYTE(_EAX) = _EAX - 111;
    v54 = _ECX - (v6 + 93);
    v55 = v37 << v54;
    BYTE1(_EAX) = ~BYTE1(_EAX);
    if ( _EAX == 715715276 )
    {
      _enable();
      JUMPOUT(0x40807F);
    }
    LOWORD(v55) = (_WORD)v55 << v54;
    BYTE1(v55) = 0;
    v6 = _EAX < 0xA0B28DCE;
    _EAX = _EAX + 1598911026;
    LOBYTE(v55) = v55 - (v6 + 95);
    _EDX = (_DWORD *)HIWORD(v55);
LABEL_14:
    LOWORD(_EAX) = _EAX & 0x40;
    BYTE1(_EDX) = 0;
    __asm { rcr     edx, 0Eh }
    BYTE1(_EAX) = ~BYTE1(_EAX);
    __asm { rcl     eax, 17h }
    JUMPOUT(0x408221);
  }
  BYTE1(_EBX) = v37;
  v19 = (char *)(v37 + 545655804);
  v20 = _EBX | 0xB136F9B2;
  _CL = BYTE1(v20);
  v6 = v38 < v39;
  v18 = v38 - v39;
  LOBYTE(v20) = v6 + v20;
  LOBYTE(v19) = (char)v19 >> 7;
  BYTE1(v20) |= (unsigned __int8)v19;
  __asm { rcr     ax, cl }
  if ( v20 == -1828785466 )
    JUMPOUT(0xFAA549B6);
  __asm { rcr     eax, 7 }
  --BYTE1(v19);
  LOBYTE(v19) = (_BYTE)v19 - ((v20 < 0x92FEF2C6) + BYTE1(v20));
  v69 = __CFSHL__(v20, _CL);
  LOWORD(v20) = __ROL2__(v20, _CL);
  LOBYTE(v19) = (_BYTE)v19 + 1;
  v70 = (unsigned int)&v19[v69 + v18];
  LOBYTE(_ECX) = __ROR1__(_CL, _CL);
  LOBYTE(v20) = v20 ^ 0xED;
  if ( v20 == -95102660 )
  {
    __asm { icebp }
    *(_DWORD *)(v70 + 125) -= 103;
    JUMPOUT(0x408228);
  }
LABEL_17:
  LOBYTE(_EAX) = (_BYTE)_EAX << _ECX;
  return _EAX;
}
// 407BD3: positive sp value 1C has been found
// 407CE9: control flows out of bounds to 407CEA
// 407D86: control flows out of bounds to 407D88
// 408002: control flows out of bounds to 408008
// 40807E: control flows out of bounds to 40807F
// 4080C8: control flows out of bounds to 4080CE
// 40811C: control flows out of bounds to 40811D
// 4081F2: control flows out of bounds to 4081F3
// 408226: control flows out of bounds to 408228
// 407C05: control flows out of bounds to 407C06
// 407CAA: control flows out of bounds to 407CAB
// 407C6A: control flows out of bounds to 407D87
// 407D0E: control flows out of bounds to FAA549B6
// 408262: control flows out of bounds to 408221
// 40826A: could not find valid save-restore pair for ebp
// 407BCC: conditional instruction was optimized away because of '%0x8.4==40'
// 408002: conditional instruction was optimized away because of 'edi.4<CEB75C96u'
// 408085: variable '_EDX' is possibly undefined
// 407E66: using guessed type __int16;

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
