// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw425078 = 151717; // 00425078
word32 g_dw42507C = 151735; // 0042507C
word32 g_dw425080 = 0x000250C2; // 00425080
word32 g_dw425084 = 0x000250D8; // 00425084
word32 g_dw425088 = 151787; // 00425088
word32 g_dw425090 = 151815; // 00425090
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	word32 eax;
	word32 edx;
	int32 edi_74;
	fn0040105F(0x01, (word16) edx, 2847393444, eax, out edi_74);
	word32 edi_90;
	return fn0040105F(edi_74, 0x00, 0x00, eax, out edi_90);
}

// 0040105F: Register (ptr32 byte) fn0040105F(Register int32 edi, Stack word16 wArg00, Stack word32 dwArg14, Stack word32 dwArg24, Register out ptr32 ediOut)
// Called from:
//      Win32CrtStartup
byte * fn0040105F(int32 edi, word16 wArg00, word32 dwArg14, word32 dwArg24, ptr32 & ediOut)
{
	byte * fp;
	struct Eq_26 * fs;
	word32 dwArg00;
	ptr32 dwLoc38;
	word16 eax_16_16_29 = SLICE(dwArg00, word16, 16);
	while (true)
	{
		word16 * eax_30 = SEQ(eax_16_16_29, 0x00);
		if (*eax_30 == 23117)
			break;
		eax_16_16_29 = SLICE(eax_30 - 0x00010000, word16, 16);
	}
	word32 eax_74 = SEQ(eax_16_16_29, 0x00);
	struct Eq_45 * ebx_233 = fn00401566(0x3030);
	struct Eq_51 * eax_256 = fs->ptr0018;
	<anonymous> * eax_264 = ebx_233->ptr0004;
	struct Eq_59 * esp_295;
	struct Eq_45 * eax_296;
	struct Eq_45 * edx_297;
	struct Eq_45 * ecx_298;
	eax_264();
	esp_295->ptrFFFFFFFC = edx_297;
	word16 ecx_16_16_1002 = SLICE(ecx_298, word16, 16);
	struct Eq_45 * edx_303 = esp_295->ptrFFFFFFFC;
	word32 edi_305 = eax_256->dw0034;
	if (edi_305 != 0x57)
	{
		byte * eax_310;
		word32 ecx_312;
		ebx_233->ptr0008();
		ediOut = edi_305 - 0x57;
		word16 ecx_16_16_1003 = SLICE(ecx_312, word16, 16);
		return eax_310;
	}
	else
	{
		esp_295->ptrFFFFFFFC = edx_303;
		struct Eq_45 * edx_323 = esp_295->ptrFFFFFFFC;
		esp_295->ptrFFFFFFFC = ebx_233;
		esp_295->ptrFFFFFFF8 = edx_323;
		struct Eq_45 * edx_329 = esp_295->ptrFFFFFFF8;
		esp_295->ptrFFFFFFFC -= 0x04;
		esp_295->ptrFFFFFFF8 = edx_329;
		struct Eq_45 * edi_338 = esp_295->ptrFFFFFFFC;
		esp_295->ptrFFFFFFF8 = esp_295->ptrFFFFFFF8;
		word32 edi_343 = edi_338->dw0000;
		esp_295->ptrFFFFFFF8 = esp_295->ptrFFFFFFF8;
		struct Eq_45 * edx_346 = esp_295->ptrFFFFFFF8;
		esp_295->dw003C = edi_343;
		esp_295->ptrFFFFFFF8 = edx_346;
		struct Eq_45 * edi_353 = esp_295->ptrFFFFFFFC;
		esp_295->ptrFFFFFFFC = esp_295->ptrFFFFFFF8;
		struct Eq_45 * edx_357 = esp_295->ptrFFFFFFFC;
		esp_295->ptrFFFFFFFC = eax_296;
		esp_295->ptrFFFFFFF8 = edx_357;
		struct Eq_45 * edx_363 = esp_295->ptrFFFFFFF8;
		esp_295->ptrFFFFFFF8 = ecx_298;
		esp_295->ptrFFFFFFF4 = esp_295 - 8;
		esp_295->dwFFFFFFF0 = 0x40;
		esp_295->ptrFFFFFFEC = edx_363;
		struct Eq_45 * edx_374 = esp_295->ptrFFFFFFEC;
		esp_295->ptrFFFFFFEC = esp_295->ptr0020;
		esp_295->ptrFFFFFFE8 = edx_374;
		struct Eq_45 * edx_381 = esp_295->ptrFFFFFFE8;
		esp_295->ptrFFFFFFE8 = esp_295->ptr0014;
		esp_295->ptrFFFFFFE4 = edx_381;
		struct Eq_45 * edx_388 = esp_295->ptrFFFFFFE4;
		esp_295->ptrFFFFFFE4 = (struct Eq_45 *) ~0x00;
		esp_295->ptrFFFFFFE0 = edx_388;
		struct Eq_45 * edx_394 = esp_295->ptrFFFFFFE0;
		esp_295->dw0018 = 0x00;
		esp_295->ptrFFFFFFE0 = edx_394;
		word32 ecx_404;
		edi_353->ptr000C();
		word16 ecx_16_16_1004 = SLICE(ecx_404, word16, 16);
		Eq_237 eax_1170 = 0x00;
		do
		{
			byte al_486 = (byte) eax_1174;
			*((word32) eax_1174 + (fp - 300)) = al_486;
			eax_1170 = SEQ(SLICE((word32) eax_1174 + 1, word24, 8), al_486 + 0x01);
			eax_1174 = eax_1170;
		} while (eax_1174 < 0xFF);
		ptr32 ecx_534 = 0x00;
		int32 esi_538 = 0x00;
		Eq_258 ebp_539 = 0x00;
		do
		{
			byte ah_557 = Mem556[fp - 300 + ebp_539:byte];
			int32 edx_592 = (word32) (*((word32) ecx_534 + edi) + (ah_557 + (byte) esi_538));
			++ecx_534;
			if (ecx_534 >= fp - 40)
				ecx_534 = 0x00;
			byte al_618 = *((word32) (fp - 300) + edx_592);
			*((word32) ebp_539 + (fp - 300)) = al_618;
			(fp - 0x0144)[edx_592 + 0x18] = ah_557;
			ebp_539 = (word32) ebp_539 + 1;
			esi_538 = edx_592;
		} while (ebp_539 < 0x0100);
		byte * esi_681 = null;
		byte * eax_686 = null;
		struct Eq_51 * ebp_697 = eax_256;
		byte * edi_702 = fp - (byte *) 40;
		if (eax_256 > null)
		{
			do
			{
				byte * eax_729 = (word32) ((byte) eax_686 + 0x01);
				byte cl_734 = Mem731[fp - 300 + eax_729:byte];
				byte * edx_752 = (word32) ((byte) cl_734.u0 + (byte) esi_681);
				Mem767[fp - 300 + eax_729:byte] = Mem748[fp - 300 + edx_752:byte];
				Mem792[fp - 300 + edx_752:byte] = cl_734;
				esi_681 = edx_752;
				eax_686 = eax_729;
				word32 edx_810 = Mem807[fp - 300 + eax_729:word32];
				byte dl_815 = (byte) cl_734.u0 + (byte) edx_810;
				byte * edx_816 = (word32) dl_815;
				byte cl_830 = Mem823[fp - 0x0140 + (edx_816 + 0x14):byte];
				ui8 ch_837 = *edi_702 ^ cl_830;
				*edi_702 = ch_837;
				++edi_702;
				--ebp_697;
			} while (ebp_697 != null);
		}
		ediOut = dwLoc38;
		return fp - (byte *) 40;
	}
}

// 00401566: Register ptr32 fn00401566(Stack word16 wArg00)
// Called from:
//      fn0040105F
ptr32 fn00401566(word16 wArg00)
{
	word32 dwArg00;
	word16 eax_16_16_102 = SLICE(dwArg00, word16, 16);
	while (true)
	{
		word16 ax_30 = *SEQ(eax_16_16_102, 0x00);
		word32 eax_93 = SEQ(eax_16_16_102, ax_30 + 42421);
		if (ax_30 == 23117)
			break;
		eax_16_16_102 = SLICE(eax_93 - 0x00010000, word16, 16);
	}
	struct Eq_370 * eax_54 = SEQ(eax_16_16_102, 0x00);
	struct Eq_373 * ecx_60 = eax_54 + eax_54->dw003C / 64;
	int32 ecx_66 = ecx_60->dw0080;
	return eax_54 + Mem62[eax_54 + ecx_66:word32] + 0x04;
}

