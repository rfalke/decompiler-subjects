// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__ImageList_Create = &g_t8130; // 00401000
<anonymous> * __imp__InitCommonControlsEx = &g_t8144; // 00401004
<anonymous> * __imp__CreatePropertySheetPageA = &g_t815C; // 00401008
<anonymous> * __imp___stricmp = &g_t8186; // 00401010
<anonymous> * __imp__GlobalUnlock = &g_t819C; // 00401018
<anonymous> * __imp__VerifyVersionInfoW = &g_t81AC; // 0040101C
<anonymous> * __imp__GetSystemDirectoryW = &g_t81C2; // 00401020
<anonymous> * __imp__InterlockedExchangeAdd = &g_t81D8; // 00401024
<anonymous> * __imp__ConnectNamedPipe = &g_t81F2; // 00401028
<anonymous> * __imp__IsValidLocale = &g_t8206; // 0040102C
<anonymous> * __imp__InterlockedExchange = &g_t8216; // 00401030
<anonymous> * __imp__GetCurrentThreadId = &g_t822C; // 00401034
<anonymous> * __imp__ExitProcess = &g_t8242; // 00401038
<anonymous> * __imp__GetCurrentProcessId = &g_t8250; // 0040103C
<anonymous> * __imp__SetCommMask = &g_t8266; // 00401040
<anonymous> * __imp__GetUserDefaultLCID = &g_t8274; // 00401044
<anonymous> * __imp__StrSpnA = &g_t8298; // 0040104C
<anonymous> * __imp__SetBitmapBits = &g_t82AE; // 00401054
<anonymous> * __imp__SetWindowOrgEx = &g_t82BE; // 00401058
<anonymous> * __imp__RectInRegion = &g_t82D0; // 0040105C
<anonymous> * __imp__BitBlt = &g_t82E0; // 00401060
<anonymous> * __imp__SetROP2 = &g_t82EA; // 00401064
<anonymous> * __imp__SetBitmapDimensionEx = &g_t82F4; // 00401068
<anonymous> * __imp__IsWindow = &g_t8316; // 00401070
<anonymous> * __imp__DrawAnimatedRects = &g_t8322; // 00401074
<anonymous> * __imp__MonitorFromRect = &g_t8336; // 00401078
<anonymous> * __imp__ChildWindowFromPointEx = &g_t8348; // 0040107C
<anonymous> * __imp__UnionRect = &g_t8362; // 00401080
<anonymous> * __imp__TrackPopupMenuEx = &g_t836E; // 00401084
<anonymous> * __imp__MapVirtualKeyA = &g_t8382; // 00401088
<anonymous> * __imp__DrawFrameControl = &g_t8394; // 0040108C
<anonymous> * __imp__SetDlgItemTextW = &g_t83A8; // 00401090
<anonymous> * __imp__EndPaint = &g_t83BA; // 00401094
<anonymous> * __imp__IsDialogMessageA = &g_t83C6; // 00401098
<anonymous> * __imp__CreateWindowExA = &g_t83DA; // 0040109C
// 004038A4: Register uint16 aBO_D_h(Stack uint32 dwArg04)
uint16 aBO_D_h(uint32 dwArg04)
{
	word32 * edi_10 = g_ptr40A13D;
	g_t409FD7.u1 = (word32) ((word32) g_t409FD7.u0 + *edi_10);
	word32 * edx_14 = g_ptr40A129;
	*edx_14 -= g_t409F67.u0;
	g_dw409FEF = g_dw409FEF - *g_ptr40A199 - (word32) (g_ptr409F93 < edi_10);
	return <invalid>;
}

// 004038EB: void qv_cxblcr_z_bPXUUW_J_x(Stack int32 dwArg04)
void qv_cxblcr_z_bPXUUW_J_x(int32 dwArg04)
{
	ui32 * ecx_10 = g_ptr40A151;
	ui32 * edx_11 = g_ptr409F7F - *ecx_10;
	g_ptr409F7F = edx_11;
	g_dw409FA7 = g_ptr409F93 + g_dw409FA7 + (word32) (ecx_10 < edx_11);
	g_dw409F1B = g_dw409F1B ^ g_dw40A00F;
}

// 00403933: Register int32 err_woz_x_xs_vKZ(Stack uint32 dwArg04)
int32 err_woz_x_xs_vKZ(uint32 dwArg04)
{
	up32 edx;
	up32 dwLoc08;
	g_dw409F77 &= g_dw409FDB;
	union Eq_83 * edi_13 = g_ptr40A0C5;
	edi_13->u0 = (ui32) (edi_13->u0 | (word32) g_w409FB3);
	g_t409F37.u1 = (word32) ((word32) g_t409F37.u0 - *g_ptr40A1AD - (word32) (edx < dwLoc08));
	return <invalid>;
}

// 00403978: Register uint32 GAEWL_bvqo(Stack uint32 dwArg04)
uint32 GAEWL_bvqo(uint32 dwArg04)
{
	g_dw409F3F = g_dw409F3F ^ g_dw409F5F;
	g_dw409F6F -= *g_ptr40A191;
	g_t409F3B.u0 = (ui32) ((word32) g_t409F3B.u1 | (word32) g_t409F1F.u0);
	return <invalid>;
}

// 004039C6: Register ui32 fn004039C6(Register (ptr32 word32) esi, Register ui32 edi, Stack (ptr32 Eq_134) dwArg04, Stack Eq_135 dwArg08, Register out (ptr32 Eq_136) edxOut)
// Called from:
//      fn00404A85
ui32 fn004039C6(word32 * esi, ui32 edi, struct Eq_134 * dwArg04, Eq_135 dwArg08, struct Eq_136 & edxOut)
{
}

// 00403BAF: Register int32 fn00403BAF(Register (ptr32 word32) ebx, Register (ptr32 word32) esi, Stack Eq_135 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      fn00405E99
int32 fn00403BAF(word32 * ebx, word32 * esi, Eq_135 dwArg04, word32 dwArg08, word32 dwArg0C, ptr32 & edxOut)
{
	word32 dwLoc38;
	void * dwLoc2C;
	int32 ecx_11 = ~0x101E;
	up32 dwLoc14_186;
	for (dwLoc14_186 = 0x00; dwLoc14_186 < 0x18; ++dwLoc14_186)
	{
		if (dwLoc14_186 == 0x23)
		{
			SetBitmapBits((struct HBITMAP__ *) 9941, 9941, dwLoc2C);
			dwLoc14_186 = 9941;
		}
	}
	g_t409FEB.u0 = (ui32) (g_t409FEB.u0 + dwLoc38 + (word32) (esi < ebx));
	int32 eax_127 = 0x0205B383;
	do
	{
		int32 * esi_59 = *((char *) g_a4090CC + (ecx_11 + 1 & 0x03) * 0x04);
		*esi_59 = *esi_59 *s ecx_11 *s ~0x201B;
		ui32 * esi_68 = *((char *) g_a4090CC + (ecx_11 - 1 & 0x03) * 0x04);
		*esi_68 = *esi_68 ^ (eax_127 | ecx_11);
		g_t4092FC.u1 = (HDC) dwArg04;
		switch (ecx_11)
		{
		case ~0x11DE:
			g_dw409300 = dwArg08;
			break;
		case ~0x119E:
			g_dw409304 = dwArg0C;
			break;
		}
		ui32 ecx_105 = ecx_11 ^ 0x3531;
		word32 * eax_120 = *((char *) g_a4090CC + ((ecx_105 + 0x01 ^ 0x3531) & 0x03) * 0x04);
		g_dw409F87 += 4235043;
		*eax_120 += (ecx_105 + 0x01 ^ 0x3531) *s ~0x201F ^ (ecx_105 + 0x01 ^ 0x3531);
		eax_127 = (ecx_105 + 0x01 ^ 0x3531) *s ~0x201C;
		ui32 * esi_130 = *((char *) g_a4090CC + ((ecx_105 + 0x01 ^ 0x3531) - 2 & 0x03) * 0x04);
		*esi_130 |= eax_127;
		ecx_11 = ecx_105 + 0x01 ^ 0x3531;
	} while ((ecx_105 + 0x01 ^ 0x3531) != ~0x112E);
	edxOut = 0x3531;
	return ecx_11;
}

// 00403D7A: void fn00403D7A(Register (ptr32 Eq_516) eax)
// Called from:
//      Win32CrtStartup
void fn00403D7A(struct Eq_516 * eax)
{
	g_dw40954C = (char *) eax + 4;
	g_t409540.u0 = eax->t0008.u0;
	g_dw409544 = eax->dw000C;
	g_dw409548 = eax->dw0010;
}

// 00403D9E: Register int32 __AR__NMK__EOKZm(Stack real32 rArg04)
int32 __AR__NMK__EOKZm(real32 rArg04)
{
	up32 edi;
	word32 * ecx;
	up32 dwLoc08;
	word32 * edi_11 = g_ptr40A12D;
	g_dw409F87 = g_dw409F87 + *edi_11 + (word32) (dwLoc08 < edi);
	word32 * ecx_18 = g_ptr40A0F9;
	*ecx_18 = *ecx_18 - (word32) g_w409F4F - (word32) (ecx < edi_11);
	word32 * edi_23 = g_ptr40A189;
	*edi_23 += g_t409F67.u0;
	return <invalid>;
}

// 00403DDE: Register ui32 fn00403DDE(Register out ptr32 ecxOut)
// Called from:
//      fn00404306
ui32 fn00403DDE(ptr32 & ecxOut)
{
	word32 dwLoc20;
	int32 dwLoc28;
	word16 wLoc20 = (word16) dwLoc20;
	g_dw409FCF = 0x19;
	while (g_dw409FCF != 0x00)
	{
		if (g_dw409FCF == 0x1F)
			IsWindow(32537);
		--g_dw409FCF;
	}
	Mem33 = Mem18;
	Eq_602 eax_35 = g_ptr409078->u0;
	word32 eax_43 = *g_ptr40907C;
	byte * esi_74 = g_ptr40A175;
	*esi_74 = __rcr<byte,byte>(*esi_74, 0x0A, (word32) wLoc20 != 0x00);
	g_t4092E8.u0 = (int32) eax_35;
	g_dw4092EC = eax_43 + (0x04 - g_t4092E8.u0);
	word32 eax_92 = ~0x101F;
	if (g_t4092E8.u0 == 0x00)
		eax_92 = ~0x101E;
	ecxOut = 0x2530;
	return (eax_92 ^ 0x3531) + 0x2530;
}

// 00403F25: void fn00403F25(Register word32 ecx)
// Called from:
//      fn00404306
void fn00403F25(word32 ecx)
{
	struct Eq_658 * fp;
	g_t409F2F.u0 = (ui32) ((word32) g_t409F2F.u1 & (word32) g_t409F3B.u1);
	up32 dwLoc14_136;
	for (dwLoc14_136 = 0x00; dwLoc14_136 < 0x18; ++dwLoc14_136)
	{
		if (dwLoc14_136 == 0x19)
			fp->ptrFFFFFFB8 = 46956;
	}
	byte * edx_41 = g_ptr40A109;
	*edx_41 += 0x78;
	struct Eq_134 * edx_44 = g_ptr4092D0;
	fp->ptrFFFFFFB8 = fp - 0x0C;
	g_dw409F33 &= 0x00409FC7;
	fp->dwFFFFFFB4 = 0x40;
	fp->dwFFFFFFB0 = g_dw4092EC;
	fp->tFFFFFFAC.u0 = g_t4092E8.u0;
	fp->dwFFFFFFA8 = 0x04;
	fp->dwFFFFFFA4 = (char *) &edx_44->dw0040 + 0x00FE;
	ui32 * eax_78 = edx_44->ptr000C;
	fp->dwFFFFFFA0 = *eax_78;
	fp->dwFFFFFF9C = g_dw40957C;
	word32 ecx_89;
	g_ptr409578();
}

// 0040408D: void fn0040408D()
// Called from:
//      fn00404724
void fn0040408D()
{
	up32 dwLoc34;
	ptr32 fp;
	word32 dwLoc1C;
	word16 wLoc34 = (word16) dwLoc34;
	word32 dwLoc14_231;
	for (dwLoc14_231 = 0x15; dwLoc14_231 != 0x00; --dwLoc14_231)
	{
		if (dwLoc14_231 == 0x25)
			MonitorFromRect((RECT *) 0x8976, 16262);
	}
	g_dw409F5B -= *g_ptr40A101;
	ui32 * eax_76 = g_ptr40A0BD;
	ui32 * eax_73 = **g_ptr409038;
	*eax_76 = *eax_76 ^ (word32) g_t409FEB.u1;
	word16 * eax_84 = *eax_73 & 0xFFFF0000;
	g_dw409FAB |= (word32) wLoc34;
	g_t409F53.u1 = (word32) ((word32) g_t409F53.u0 - g_dw40A00F);
	word16 ax_115 = *eax_84 - 0x0230;
	ptr32 esp_172 = fp - 0x4C;
	Eq_597 eax_125 = fp - 16;
	if ((ax_115 ^ 0x0331) != 23340)
	{
		g_dw409FA7 = 0x13;
		while (g_dw409FA7 != 0x00)
		{
			if (g_dw409FA7 == 0x14)
			{
				struct Eq_845 * esp_173 = esp_172 - 4;
				esp_173->dw0000 = dwLoc1C;
				esp_173->tFFFFFFFC.u0 = 4235255;
				esp_173->tFFFFFFF8.u0 = 29921;
				eax_125 = ChildWindowFromPointEx(esp_173->tFFFFFFF8.u0, esp_173->tFFFFFFFC, esp_173->t0004);
				esp_172 = &esp_173->t0004 + 1;
			}
			--g_dw409FA7;
		}
		eax_125.u0->unused -= 0x00010000;
		g_dw409FBB &= 368901488;
	}
	else
		g_ptr409F6B = 0x00409FA3;
}

Eq_248 g_t4042D6 = // 004042D6
	{
		<code>,
		0x40908C05,
	};
// 00404306: Register word32 fn00404306(Register up32 edx, Register word32 esi, Register word32 edi, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404F8F
word32 fn00404306(up32 edx, word32 esi, word32 edi, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	up32 edx;
	word32 esi;
	word32 edi;
	bool P;
	word32 dwLoc20;
	word32 dwLoc50;
	word32 dwLoc10;
	word32 dwLoc1C;
	word32 dwLocA8;
	word32 dwLoc24;
	word32 dwLocC0;
	word32 dwLoc58;
	word32 dwLoc38;
	word32 dwLoc0C;
	word32 dwLoc6C;
	word16 wLocBC;
	word32 dwLoc3C;
	word32 dwLoc2C;
	word32 dwLoc14;
	word32 dwLoc28;
	word32 dwLoc18;
	esp_9 = fp - 0x0154;
	ebx_12 = ~0x101F;
	g_t409F53.u1 = 0x12;
	while (true)
	{
		edx_39 = ϕ(edx, edx_452);
		esp_35 = ϕ(esp_9, esp_450);
		Mem25 = ϕ(Mem24, Mem448);
		if (g_t409F53.u1 == 0x00)
			break;
		if (g_t409F53.u1 == 0x18)
			COMCTL32.dll!ImageList_Create(31581, dwLoc20, dwLoc18, ~0x101F, dwLoc28);
		edx_452 = ϕ(edx_39, edx_440);
		esp_450 = ϕ(esp_35, esp_438);
		Mem444 = ϕ(Mem25, Mem436);
		eax_445.u1 = g_t409F53.u1;
		g_t409F53.u1 = (word32) (eax_445 - 0x01);
	}
	v43_31 = g_dw409FBB | dwLoc6C;
	g_dw409FBB = v43_31;
	esp_36 = esp_35 - 4;
	esp_36->dw0000 = esi;
	esp_59 = esp_36 - 4;
	esp_36->dwFFFFFFFC = edi;
	esi_63 = 0x3531;
	edi_66.u0 = 0x2530;
	eax_71 = fn00403DDE(out ecx_72);
	if (eax_71 != 0x00)
	{
		fn00403F25(ecx_72);
		edx_91.u0 = g_t4092E8.u0;
		ecx_95 = (word32) wLocBC;
		SCZO_97 = cond(ecx_95 << 0x0A);
		C_103 = SLICE(SCZO_97, bool, 1);
		dwLoc1C_501 = 0x01;
		eax_100 = g_dw4092EC;
		ecx_101.u1 = g_t409FD7.u1;
		ecx_104 = __rcr<word32,byte>(ecx_101, 0x05, C_103);
		g_t409FD7.u1 = (word32) ecx_104;
		dwLoc20_502 = ~0x11CE;
		dwLoc24_503 = ~0x101F;
		dwLoc10_504 = ~0x101E;
		dwLoc28_505 = ~0x101F;
		ecx_114 = 0x00;
		dwLoc0C_507 = ~0x101F;
		dwLoc14_508 = ~0x252F;
		ebx_121 = 0x00;
		dwLoc2C_509 = eax_100;
		if (eax_100 != 0x00)
		{
			dwLoc28_851 = ϕ(dwLoc28_847, dwLoc28_505);
			dwLoc14_793 = ϕ(dwLoc14_626, dwLoc14_508);
			dwLoc20_692 = ϕ(dwLoc20_535, dwLoc20_502);
			dwLoc2C_691 = ϕ(dwLoc2C_688, dwLoc2C_509);
			dwLoc24_545 = ϕ(dwLoc24_541, dwLoc24_503);
			dwLoc1C_534 = ϕ(dwLoc1C_530, dwLoc1C_501);
			dwLoc10_529 = ϕ(dwLoc10_525, dwLoc10_504);
			dwLoc0C_511 = ϕ(dwLoc0C_569, dwLoc0C_507);
			esp_457 = ϕ(esp_394, esp_59);
			ebx_179 = ϕ(ebx_377, ebx_121);
			edi_141 = ϕ(edi_197, edi_66);
			edx_135 = ϕ(edx_184, edx_91);
			esi_133 = ϕ(esi_192, esi_63);
			Mem125 = ϕ(Mem375, Mem122);
			eax_126 = g_ptr40A16D;
			v40_129 = *eax_126 & dwLoc3C;
			*eax_126 = v40_129;
			eax_134 = dwLoc0C_511 ^ esi_133;
			v56_476 = PARITY_EVEN(g_dw409F2B & edx_135);
			v41_139 = g_t409F8F.u1 - dwLocA8;
			g_t409F8F.u1 = (word32) v41_139;
			eax_142 = (word32) edi_141 + eax_134;
			dwLoc50_513 = 0x00;
			do
			{
				dwLoc28_850 = ϕ(dwLoc28_847, dwLoc28_851);
				dwLoc14_792 = ϕ(dwLoc14_789, dwLoc14_793);
				dwLoc0C_572 = ϕ(dwLoc0C_569, dwLoc0C_511);
				dwLoc24_544 = ϕ(dwLoc24_541, dwLoc24_545);
				dwLoc1C_533 = ϕ(dwLoc1C_530, dwLoc1C_534);
				dwLoc10_528 = ϕ(dwLoc10_525, dwLoc10_529);
				dwLoc20_519 = ϕ(dwLoc20_535, dwLoc20_692);
				dwLoc2C_516 = ϕ(dwLoc2C_688, dwLoc2C_691);
				dwLoc50_514 = ϕ(dwLoc50_520, dwLoc50_513);
				v55_475 = ϕ(v53_473, v56_476);
				edi_200 = ϕ(edi_197, edi_141);
				esi_195 = ϕ(esi_192, esi_133);
				edx_187 = ϕ(edx_184, edx_135);
				ebx_178 = ϕ(ebx_176, ebx_179);
				eax_175 = ϕ(eax_174, eax_142);
				esp_155 = ϕ(esp_456, esp_457);
				dwLoc50_515 = dwLoc50_514 + 0x01;
				if (dwLoc50_515 == 0x1D)
				{
					esp_156 = esp_155 - 4;
					esp_156->dw0000 = 0x00409F83;
					esp_159 = esp_156 - 4;
					esp_156->dwFFFFFFFC = dwLoc2C_516;
				}
				dwLoc28_847 = dwLoc28_850;
				dwLoc14_789 = dwLoc14_792;
				dwLoc2C_688 = dwLoc2C_516;
				dwLoc0C_569 = dwLoc0C_572;
				dwLoc24_541 = dwLoc24_544;
				dwLoc20_535 = dwLoc20_519;
				dwLoc1C_530 = dwLoc1C_533;
				dwLoc10_525 = dwLoc10_528;
				dwLoc50_520 = dwLoc50_515;
				esp_456 = esp_155;
				v53_473 = v55_475;
				edi_197 = edi_200;
				esi_192 = esi_195;
				edx_184 = edx_187;
				ebx_176 = ebx_178;
				eax_174 = eax_175;
			} while (dwLoc50_520 < 0x1C);
			al_188 = Mem181[eax_174 *s ebx_176 + edx_184:byte];
			eax_196 = dwLoc10_525 ^ esi_192;
			eax_201 = (word32) edi_197 + eax_196;
			if (dwLoc1C_530 == eax_201)
			{
				eax_234 = (word32) al_188;
				al_241 = (byte) eax_234;
				eax_24_8_244 = SLICE(eax_234, word24, 8);
				ecx_236 = g_dw409F33;
				ecx_238 = ecx_236 - dwLocC0 - (word32) (dwLoc1C_530 < esi_192);
				g_dw409F33 = ecx_238;
				ecx_240 = (word32) al_188;
				al_243 = (al_241 ^ 0x61) + 0x33;
				eax_245 = SEQ(eax_24_8_244, al_243);
				eax_246 = eax_245 + ecx_240;
				al_252 = (byte) eax_246;
				ecx_248 = g_dw40A00F;
				ecx_250 = ecx_248 - dwLoc38 - (word32) (dwLoc58 < edi_197);
				g_dw40A00F = ecx_250;
				ecx_255 = (word32) al_252;
				eax_256 = dwLoc0C_569 ^ esi_192;
				eax_257 = (word32) edi_197 + eax_256;
				eax_259 = (word32) *((word32) edx_184 + eax_257 *s ebx_176);
				ecx_260 = ecx_255 - eax_259;
				cl_262 = (byte) ecx_260;
				bLoc05_573 = cl_262;
			}
			else
			{
				eax_204 = g_dw409F43;
				ecx_205 = (word32) g_b409F83;
				eax_206 = eax_204 ^ ecx_205;
				g_dw409F43 = eax_206;
				ecx_209 = (word32) al_188;
				eax_210 = dwLoc20_535 ^ esi_192;
				ecx_211 = ecx_209 - eax_210;
				ecx_212 = ecx_211 - edi_197;
				cl_218 = (byte) ecx_212;
				eax_214 = (word32) g_w409FE7;
				v30_216 = g_dw409FD3 - eax_214 - (word32) (dwLocA8 < edx_184);
				g_dw409FD3 = v30_216;
				cl_222 = (byte) dwLoc24_541;
				cl_224 = (cl_222 ^ 0x31) + 0x30;
				al_226 = __ror<byte,byte>(cl_218, cl_224);
				v57_477 = PARITY_EVEN(g_w409FB3 & edi_197);
				bLoc05_552 = al_226;
			}
			bLoc05_611 = ϕ(bLoc05_573, bLoc05_552);
			v52_472 = ϕ(v53_473, v57_477);
			Mem265 = ϕ(Mem263, Mem233);
			ecx_268 = g_ptr40A161;
			v27_269 = ecx_268->u1 + 0x24;
			ecx_268->u1 = (byte) v27_269;
			eax_273 = dwLoc0C_569 ^ esi_192;
			eax_275 = (word32) edi_197 + eax_273;
			ecx_278 = dwLoc0C_569 ^ esi_192;
			ecx_279 = (word32) edi_197 + ecx_278;
			cl_282 = (byte) *((word32) edx_184 + ecx_279 *s ebx_176);
			v28_283 = *((word32) edx_184 + eax_275 *s ebx_176) ^ cl_282;
			*((word32) edx_184 + eax_275 *s ebx_176) = v28_283;
			eax_287 = dwLoc0C_569 ^ esi_192;
			eax_288 = (word32) edi_197 + eax_287;
			v34_317 = (byte) ((word32) *((word32) edx_184 + eax_288 *s ebx_176) + 1);
			*((word32) edx_184 + eax_288 *s ebx_176) = v34_317;
			eax_322 = dwLoc0C_569 ^ esi_192;
			eax_324 = (word32) edi_197 + eax_322;
			v35_327 = (byte) ((word32) *((word32) edx_184 + eax_324 *s ebx_176) + bLoc05_611);
			*((word32) edx_184 + eax_324 *s ebx_176) = v35_327;
		}
	}
	ecx_895 = ϕ(ecx_338, ecx_72, ecx_114);
	esp_392 = ϕ(esp_394, esp_59, esp_59);
	edi_395 = *esp_392;
	esp_396 = esp_392 + 1;
	esi_397 = *esp_396;
	esiOut = esi_397;
	ediOut = edi_395;
	return ecx_895;
}

// 00404724: void fn00404724(Register word32 ecx, Register word32 esi, Register word32 edi)
// Called from:
//      fn00404BCB
void fn00404724(word32 ecx, word32 esi, word32 edi)
{
	Eq_863 dwLoc18;
	struct Eq_1358 * edx_13 = (struct Eq_1358 *) 0x05;
	do
	{
		g_dw409F87 = 0x00;
		while (g_dw409F87 < 0x15)
		{
			if (g_dw409F87 == 22)
				GetSystemDirectoryW(&g_t40A013, dwLoc18);
			++g_dw409F87;
		}
		if (g_dw409088 != 0x00)
			break;
		edx_13[4232399] = (struct Eq_1358) ((edx_13[4232399] ^ 0x61) + 0x33);
		++edx_13;
	} while (edx_13 < (struct Eq_1358 *) 0x14);
	ui32 * eax_43 = g_ptr4092D0->ptr000C;
	ui32 * edi_101 = null;
	if (*eax_43 == 0x00)
	{
		fn0040408D();
		edi_101 = eax_43;
	}
	ui32 ecx_65 = ~0x101E;
	do
	{
		g_t409F67.u0 = (uint32) ~g_t409F67.u0;
		ui32 ecx_77 = ecx_65 ^ 0x3531;
		struct Eq_1415 * eax_82 = ecx_77 * 0x02 + 0x4A60;
		eax_82->w4094BC = (eax_82->w4094B4 ^ 0x0331) + 0x0230;
		ecx_65 = ecx_77 + 0x01 ^ 0x3531;
	} while (ecx_65 != ~0x101D);
	if (edi_101 == null)
		return;
	up32 dwLoc28_267;
	for (dwLoc28_267 = 0x00; dwLoc28_267 < 0x1F; ++dwLoc28_267)
	{
		if (dwLoc28_267 == 0x2D)
			COMCTL32.dll!InitCommonControlsEx(25277);
	}
}

// 00404917: void fn00404917(Register (ptr32 Eq_1454) ebp, Register (ptr32 uint32) esi, Register uint32 edi)
// Called from:
//      Win32CrtStartup
void fn00404917(struct Eq_1454 * ebp, uint32 * esi, uint32 edi)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				uint32 ecx_16 = *esi;
				if (ecx_16 > edi)
					*esi = ecx_16 - 0x01;
				else if (ecx_16 == 0x00)
					*esi = edi;
				else
				{
					g_dw409F43 = 0x00;
					while (g_dw409F43 < 0x17)
					{
						if (g_dw409F43 == 0x26)
							TrackPopupMenuEx((struct HMENU__ *) 0x11FC, ebp->tFFFFFFE8, 0x616F, 20280, ebp->tFFFFFFF0.u0, ebp->tFFFFFFD8);
						++g_dw409F43;
					}
					*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_16;
				}
			} while (*esi != edi);
		}
	} while ((word32) InterlockedExchangeAdd(&g_t4092E4, 0x00760677) + 0x00760677 != g_t4092E4);
}

// 004049DB: Register Eq_523 fn004049DB(Register (ptr32 Eq_1538) ebp, Register (ptr32 Eq_523) esi, Register Eq_523 edi)
// Called from:
//      Win32CrtStartup
Eq_523 fn004049DB(struct Eq_1538 * ebp, union Eq_523 * esi, Eq_523 edi)
{
	Eq_523 ecx;
	esi->u0 = 0x01;
	InterlockedExchange(&g_t4092E4, 0x00760677);
	while (esi->u0 != edi)
	{
		ecx.u0 = esi->u0;
		if (ecx < edi)
		{
			if (ecx == 0x00)
				goto l00404A71;
			g_dw409FAB = 0x00;
			while (g_dw409FAB < 0x14)
			{
				if (g_dw409FAB == 0x24)
					RectInRegion(ebp->tFFFFFFEC, (RECT *) 33236);
				++g_dw409FAB;
			}
			esi->u0 = (word32) ecx + ((uint32) ((uint64) edi /u 0x0101) + 1);
		}
		else if (ecx == 0x00)
		{
l00404A71:
			esi->u0 = (uint32) edi;
		}
		else
		{
			esi->u0 = (uint32) (ecx - 0x01);
			--ecx;
		}
	}
	return ecx;
}

// 00404A85: Register word32 fn00404A85(Register word32 ecx, Register word32 edx, Register (ptr32 word32) esi, Register ui32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00405E99
word32 fn00404A85(word32 ecx, word32 edx, word32 * esi, ui32 edi, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	struct Eq_1616 * fp;
	int32 dwLoc28;
	Eq_135 eax_9 = g_t4092FC.u1;
	Eq_1620 dwLoc20_179 = 0x00;
	while (dwLoc20_179 < 22)
	{
		if (dwLoc20_179 == 0x24)
			BitBlt(eax_9, ~0x101F, 28972, 0x110F, dwLoc28, 0x872A, dwLoc20_179, ~0x101F, 0x6683);
		dwLoc20_179 = (word32) dwLoc20_179 + 1;
	}
	word32 edx_51;
	if (fn004039C6(esi, edi, g_ptr4092D0, eax_9, out edx_51) != 0x00)
	{
		ptr32 edi_119 = fp->ptrFFFFFF98;
		ptr32 esi_124 = fp->ptrFFFFFF9C;
		ebxOut = fp->ptrFFFFFFA0;
		esiOut = esi_124;
		ediOut = edi_119;
		return 0x01;
	}
}

// 00404BCB: Register word32 fn00404BCB(Register word32 ecx, Register word32 esi, Register word32 edi, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00405CF0
word32 fn00404BCB(word32 ecx, word32 esi, word32 edi, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	Eq_1675 dwLoc18;
	__align_stack<word32>(fp - 4);
	fn00404724(ecx, esi, edi);
	struct Eq_1685 * ebp_121 = fp - 4;
	up32 dwLoc08_505 = 0x00;
	do
	{
		dwLoc08_505 = dwLoc08_571 + 0x01;
		if (dwLoc08_505 == 0x27)
			CreatePropertySheetPageA(dwLoc18);
		struct Eq_1689 * esp_100 = fp - 0x50;
		dwLoc08_571 = dwLoc08_505;
	} while (dwLoc08_571 < 0x1A);
	word32 esi_117 = 0x3531;
	word32 edi_120 = 0x2530;
	while (g_dw409088 == 0x00)
	{
		struct Eq_134 * eax_96 = g_ptr4092D0;
		ui32 * ecx_97 = eax_96->ptr000C;
		if (*ecx_97 != 0x00)
		{
			struct Eq_1726 * esp_101 = esp_100 - 4;
			esp_101->dw0000 = 4232476;
			esp_101->dwFFFFFFFC = 0x01;
			esp_101->ptrFFFFFFF8 = &eax_96->dw0040 + 4;
			esp_101->dwFFFFFFF4 = *ecx_97;
			esp_101->dwFFFFFFF0 = g_dw40957C;
			word32 ebx_570;
			g_t4094E4.u0 = (ui32) fn0040666F(out ebx_570, out ebp_121, out esi_117, out edi_120);
			struct Eq_1765 * esp_122 = (struct Eq_1765 *) <invalid>;
			esp_100 = (struct Eq_1689 *) (&esp_122->dwFFFFFFFC + 6);
		}
		int32 eax_186;
		if (g_t4094E4.u0 != 0x00)
		{
			esp_100[5] = (struct Eq_1689) 0x00;
			Eq_22 ecx_139 = ~0x101E;
			while (true)
			{
				word32 eax_143 = *esp_100[8].dw0000;
				struct Eq_1786 * esp_144 = esp_100 - 4;
				esp_144->ptr0000 = (char *) 0x61;
				g_t409FDF.u0 = (ui32) (g_t409FDF.u0 | g_dw409FF3);
				esp_100 = (struct Eq_1689 *) ((char *) &esp_144->ptr0000 + 4);
				if ((uint32) ((uint64) eax_143 % esp_144->ptr0000) > 0x8A || ecx_139 == ~0x102E)
					break;
				g_dw409FA7 = g_dw409FA7 + ebp_121->dwFFFFFFF8 + (word32) (ecx_139 < g_t409F67.u0);
				uint32 ebx_171 = ecx_139 ^ esi_117;
				uint32 edx_178 = (uint32) ((uint64) (ebx_171 + 0x2530) % ((esp_144->dw0020 ^ esi_117) + edi_120));
				esp_144->ptr0000 = &g_b409524;
				esp_144->ptrFFFFFFFC = &g_b409534;
				esp_144->ptr0014 = edx_178 << 0x03;
				eax_186 = _stricmp(esp_144->ptrFFFFFFFC, esp_144->ptr0000);
				esp_100 = (struct Eq_1689 *) ((char *) &esp_144->ptr0000 + 4);
				if (eax_186 != 0x00)
				{
					ebp_121->tFFFFFFF4 = (void *) 0x43C6;
					if (ebp_121->tFFFFFFF4 <= (void *) 0x33C6)
						goto l00404F31;
					esp_144->ptr0000 = esp_144->ptr0014->ptr409490;
					esp_144->ptrFFFFFFFC = &g_b4094BC;
					esp_144->dwFFFFFFF8 = 0x00409338;
					esp_144->dwFFFFFFF4 = 0x03;
					esp_144->dwFFFFFFF0 = 4232424;
					esp_144->tFFFFFFEC.u0 = g_t4094E4.u0;
					esp_144->dwFFFFFFE8 = g_dw40957C;
					fn0040666F(out ebx_171, out ebp_121, out esi_117, out edi_120);
					struct Eq_1765 * esp_223 = (struct Eq_1765 *) <invalid>;
					esp_100 = (struct Eq_1689 *) (&esp_223->dwFFFFFFFC + 8);
				}
				esp_100[6] = (struct Eq_1689) ~0x24DF;
				ui32 eax_231 = ~0x11EE;
				do
				{
					if (eax_231 == ~0x11CB)
					{
						g_dw409F4B = 0x00;
						while (g_dw409F4B < 22)
						{
							if (g_dw409F4B == 0x24)
							{
								struct Eq_2101 * esp_396 = esp_100 - 4;
								esp_396->t0000 = (struct _OVERLAPPED *) 32474;
								esp_396->tFFFFFFFC = ebp_121->tFFFFFFF4;
								ConnectNamedPipe(esp_396->tFFFFFFFC, esp_396->t0000);
							}
							++g_dw409F4B;
						}
						g_dw40950C = fn00000000(*g_ptr4092D0->ptr000C, 0x00409630);
						esp_100 = esp_308;
					}
					else if (eax_231 == ~0x11DE)
					{
						ebp_121->tFFFFFFE4.u1 = (word32) (ebp_121->tFFFFFFE4.u1 - 0x4CC6 - (word32) (g_dw409F9B < ebx_171));
						word32 eax_249 = *g_ptr409114;
						struct Eq_2035 * esp_251 = esp_100 - 4;
						esp_251->dw0000 = 0x004094D4;
						esp_251->dwFFFFFFFC = eax_249;
						esp_251->dwFFFFFFF8 = 0x02;
						esp_251->dwFFFFFFF4 = 0x0040919C;
						esp_251->dwFFFFFFF0 = eax_249;
						esp_251->dwFFFFFFEC = g_dw40957C;
						Eq_1723 eax_264 = fn0040666F(out ebx_171, out ebp_121, out esi_117, out edi_120);
						ebp_121->tFFFFFFE8.u1 = (HDC) (ebp_121->tFFFFFFE8.u1 - (word32) (ebp_121->tFFFFFFE4).u0);
						struct Eq_1765 * esp_271 = (struct Eq_1765 *) <invalid>;
						esp_271->t002C.u0 = (ui32) eax_264;
						esp_100 = (struct Eq_1689 *) (&esp_271->dwFFFFFFFC + 7);
					}
					word32 eax_317 = esp_100[6];
					--ebp_121->dwFFFFFFF8;
					eax_231 = eax_317 - 0x01 ^ esi_117;
					ui32 ecx_327 = eax_231 ^ esi_117;
					esp_100[6] = (struct Eq_1689) ecx_327;
				} while (ecx_327 + edi_120 != 0x00);
				ebp_121->dwFFFFFFF0 = 0x10E04B91;
				if (ebp_121->dwFFFFFFF0 >= 0x10E05B91)
				{
					g_dw409F7B |= 0x46;
					ebp_121->tFFFFFFE8.u1 = (HDC) ((word32) ebp_121->tFFFFFFE8.u0 + g_dw409F3F);
				}
				esp_100[6] = (struct Eq_1689) ((uint32) ((uint64) ((esp_100[3] ^ esi_117) + edi_120) % ((esp_100[7] ^ esi_117) + edi_120)) << 0x03);
				struct Eq_2158 * esp_366 = esp_100 - 4;
				esp_366->dw0000 = (word32) esp_100[6];
				esp_366->ptrFFFFFFFC = esp_366->ptr0014;
				word32 ebx_373 = fn00405182(esp_366->ptrFFFFFFFC, out ebp_121, out esi_117, out edi_120);
				ebp_121->tFFFFFFE8.u1 = (HDC) (ebp_121->tFFFFFFE8.u1 | *g_ptr40A0E9);
				struct Eq_1765 * esp_378 = (struct Eq_1765 *) <invalid>;
				esp_100 = (struct Eq_1689 *) (&esp_378->dwFFFFFFFC + 3);
				ecx_139 = ebx_373 + 1 ^ esi_117;
			}
		}
		eax_186 = esp_100[3] ^ esi_117;
l00404F31:
		ui32 eax_421 = eax_186 + 0x01 ^ esi_117;
		esp_100[3] = (struct Eq_1689) eax_421;
		if (eax_421 == ~0x11EE)
			break;
	}
	g_dw409F9B = 0x17;
	while (g_dw409F9B != 0x00)
	{
		if (g_dw409F9B == 0x1C)
		{
			struct Eq_1835 * esp_447 = esp_100 - 4;
			esp_447->t0000 = ebp_121->tFFFFFFF4;
			esp_447->tFFFFFFFC.u1 = ebp_121->tFFFFFFE8.u1;
			SetROP2(esp_447->tFFFFFFFC.u1, esp_447->t0000);
		}
		--g_dw409F9B;
	}
	struct Eq_1809 * esp_432 = esp_100 + 1;
	ptr32 edi_431 = esp_100->dw0000;
	ptr32 esi_435 = esp_432->ptr0000;
	ptr32 ebp_442 = ebp_121->ptr0000;
	ebxOut = esp_432->ptr0004;
	ebpOut = ebp_442;
	esiOut = esi_435;
	ediOut = edi_431;
	return 0x01;
}

// 00404F8F: Register word32 fn00404F8F(Register word32 ecx, Register word32 edx, Register up32 edi, Stack (ptr32 Eq_1765) dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C, Stack (ptr32 Eq_1765) dwArg10)
// Called from:
//      fn00404A85
//      fn00404F8F
word32 fn00404F8F(word32 ecx, word32 edx, up32 edi, struct Eq_1765 * dwArg00, word32 dwArg04, word32 dwArg08, <anonymous> * dwArg0C, struct Eq_1765 * dwArg10)
{
	ptr32 fp;
	word32 dwLoc90;
	word32 * esp_148;
	if (dwArg10 != (struct Eq_1765 *) 549991)
	{
		if (dwArg10 != (struct Eq_1765 *) 0x00031A14)
		{
			word32 dwLoc40_248;
			for (dwLoc40_248 = 0x1C; dwLoc40_248 != 0x00; --dwLoc40_248)
			{
				if (dwLoc40_248 == 0x1E)
					MapVirtualKeyA(0x7F99, 20026);
			}
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_1765 * stackArg0 = (struct Eq_1765 *) <invalid>;
		struct Eq_1765 * stackArg16 = (struct Eq_1765 *) <invalid>;
		fn00404F8F(ecx, edx_152, edi, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg16);
		esp_148 = fp - 28;
	}
	else
	{
		g_dw409F8B -= 0x00409FF3;
		g_dw409F8B |= 0x00409F4F;
		g_dw409F8B -= 0x00409F8F;
		dwArg0C();
	}
	word32 * ecx_174 = g_ptr40A121;
	*ecx_174 -= dwLoc90;
	g_dw409F23 = g_dw409F23 - 30833 - (word32) (edi < g_dw4090F8);
	word32 esi_204 = *esp_148;
	g_ptr409F93 -= 25582;
	return esi_204;
}

// 00405182: Register word32 fn00405182(Stack (ptr32 Eq_2169) dwArg04, Register out (ptr32 Eq_2177) ebpOut, Register out ptr32 esiOut, Register out Eq_1723 ediOut)
// Called from:
//      fn00404BCB
word32 fn00405182(struct Eq_2169 * dwArg04, struct Eq_2177 & ebpOut, ptr32 & esiOut, union Eq_1723 & ediOut)
{
	word32 dwLoc74;
	bool P;
	int32 dwLocF4;
	Eq_863 dwLoc18;
	Eq_863 dwLoc1C;
	int32 dwLoc14;
	word16 wLoc74 = (word16) dwLoc74;
	Eq_137 eax_10 = dwArg04->t409494;
	up32 dwLoc58_549 = 0x00;
	do
	{
		dwLoc58_549 = dwLoc58_853 + 0x01;
		if (dwLoc58_549 == 0x1F)
			eax_10 = DrawFrameControl(26225, (struct tagRECT *) 34342, dwLoc1C, dwLoc18);
		dwLoc58_853 = dwLoc58_549;
	} while (dwLoc58_853 < 0x19);
	ui32 * ecx_73 = g_ptr40A151;
	*ecx_73 = *ecx_73 ^ 0x103D;
	g_a409338[((eax_10 ^ 0x3531) + 0x2530) * 0x02] = 0x00;
	word32 * ecx_100 = g_ptr40A18D;
	*ecx_100 += 10800;
	g_t409FC3.u0 = (ui32) ((word32) g_t409FC3.u1 ^ 0x245E);
	Eq_2368 ebx_139 = (word32) wLoc74;
	g_w409FE7 -= ebx_139;
	g_dw409F87 = 0x00;
	do
	{
		++g_dw409F87;
		if (g_dw409F87 == 0x18)
			SetBitmapDimensionEx((struct HBITMAP__ *) 28402, 29005, dwLoc14, &g_dw409F1B);
	} while (g_dw409F87 < 22);
	byte * ebx_252 = g_ptr40A1B1;
	*ebx_252 += 0x6A;
	g_t409FEB.u0 = (ui32) (g_t409FEB.u0 ^ dwLoc74);
	g_t409F3B.u0 = (ui32) (g_t409F3B.u0 + 4235115);
	g_t409F3B.u0 = (ui32) (g_t409F3B.u0 | 0x00409F47);
	g_t409F3B.u0 = (ui32) (g_t409F3B.u0 + 0x00409F2B);
	word32 ebx_401;
	word32 ebp_406;
	word32 esi_850;
	word32 edi_851;
	fn0040666F(out ebx_401, out ebp_406, out esi_850, out edi_851);
	struct Eq_1765 * esp_407 = (struct Eq_1765 *) <invalid>;
	esp_407->dwFFFFFFFC = ebx_401;
	esp_407->dwFFFFFFF8 = 0x01;
	esp_407->dwFFFFFFF4 = ebp_406 - 80;
	g_t409FC7.u0 = (ui32) (g_t409FC7.u0 ^ *g_ptr40A171);
	esp_407->dwFFFFFFF0 = *g_ptr4092D0->ptr000C;
	esp_407->dwFFFFFFEC = g_dw40957C;
	struct Eq_1765 * esp_442 = (struct Eq_1765 *) <invalid>;
	word32 esi_437;
	word32 edi_440;
	struct Eq_2472 * ebp_441;
	word32 ebx_852;
	if (fn0040666F(out ebx_852, out ebp_441, out esi_437, out edi_440) != (((ebp_441->ptr000C)->dw409494 ^ esi_437) + 0x4A60) + ((ebp_441->ptr0008)->dw409494 ^ esi_437))
	{
		g_ptr409F93 = null;
		do
		{
			g_ptr409F93 = (word32 *) ((char *) g_ptr409F93 + 1);
			if (g_ptr409F93 == (word32 *) 0x26)
			{
				esp_442->t0028.u0 = 0x344A;
				esp_442->t0024 = ebp_441->tFFFFFFE8;
				IsValidLocale(esp_442->t0024, esp_442->t0028.u1);
			}
		} while (g_ptr409F93 < (word32 *) 0x1D);
		word32 eax_482 = ebp_441->dwFFFFFFFC;
		ui32 * ecx_483 = g_ptr4094D0;
		ebp_441->dwFFFFFF2C = 0x7FFFFFEB;
		if (ebp_441->dwFFFFFF2C != 0x7FFFFFEB)
		{
			ebp_441->dwFFFFFF68 -= ebp_441->dwFFFFFF64;
			ebp_441->dwFFFFFEE4 = ebp_441->dwFFFFFEE4 ^ ebp_441->dwFFFFFEE0;
		}
		*ecx_483 = (eax_482 ^ esi_437) + edi_440;
		ebp_441->dwFFFFFE94 |= *g_ptr40A145;
		*g_ptr4092D0->ptr000C = (ebp_441->dwFFFFFFFC ^ esi_437) + edi_440;
	}
	Eq_1723 edi_527 = esp_442->t002C.u0;
	ptr32 esi_529 = esp_442->ptr0030;
	word32 ebx_531 = esp_442->dw0034;
	ebpOut = ebp_441->ptr0000;
	esiOut = esi_529;
	ediOut = edi_527;
	return ebx_531;
}

// 004056BA: Register Eq_137 fn004056BA(Register Eq_137 eax, Register up32 esi, Register out (ptr32 Eq_2612) ebpOut)
// Called from:
//      fn0040666F
Eq_137 fn004056BA(Eq_137 eax, up32 esi, struct Eq_2612 & ebpOut)
{
	struct Eq_2612 * ebp;
	word32 dwLoc70;
	Eq_2615 dwLoc10;
	word32 dwLoc24;
	word32 dwLoc4C;
	byte bLoc48;
	Eq_597 dwLoc14;
	up32 dwLoc30_365;
	for (dwLoc30_365 = 0x00; dwLoc30_365 < 0x17; ++dwLoc30_365)
	{
		if (dwLoc30_365 == 0x19)
			eax = SetDlgItemTextW(22204, dwLoc10, &g_t40A1B5);
	}
	g_dw40A00F = g_dw40A00F + dwLoc70 + (word32) (esi < g_dw409FFF);
	if (dwLoc10 != null)
	{
		*eax->u0.top = dwLoc10 + dwLoc10->dw003C / 28;
		Eq_597 edx_65 = eax->u0.t0018.u0;
		g_t409F53.u1 = (word32) __ror<word32,byte>((word32) g_t409F53.u0, 0x01);
		if (dwLoc24 != 0x00)
		{
			*eax->u0.bottom = dwLoc10 + dwLoc24 / 28;
			Eq_2675 ecx_83 = eax->u0.bottom;
			g_dw40A00B += dwLoc4C;
			struct Eq_2672 * ecx_87 = *ecx_83.ptr0000;
			up32 dwLoc44_385 = 0x00;
			do
			{
				dwLoc44_385 = dwLoc44_612 + 0x01;
				if (dwLoc44_385 == 0x24)
					eax = EndPaint(edx_65, (PAINTSTRUCT *) 0x4B07);
				dwLoc44_612 = dwLoc44_385;
			} while (dwLoc44_612 < 0x1D);
			up32 ecx_184;
			up32 ecx_136 = ecx_87->dw0018;
			up32 ecx_153 = ecx_87->dw0014;
			g_dw409FDB -= *g_ptr40A0C1;
			g_dw409FFB -= 0x00409F2B;
			g_dw409FFB &= 0x00409F9B;
			word32 edx_140 = (word32) bLoc48;
			int32 ecx_177 = ecx_87->dw0020;
			if (ecx_153 > ecx_136)
				ecx_184 = ecx_153;
			else
				ecx_184 = ecx_136;
			edx_65.u0->unused = (int32) ecx_184;
			g_dw409FB7 = 0x00;
			do
			{
				++g_dw409FB7;
				if (g_dw409FB7 == 0x1A)
					eax = IsDialogMessageA(dwLoc14, dwLoc10);
			} while (g_dw409FB7 < 0x13);
			word32 ecx_244 = ecx_87->dw0024;
			g_t409F67.u0 = (uint32) ((word32) g_t409F67.u1 | edx_140 + 0x01);
			*eax->u0.dw0014 = dwLoc10 + ecx_244 / 28;
			int32 ecx_277 = ecx_87->dw001C;
			*eax->u0.right = dwLoc10 + ecx_277 / 28;
			(*((char *) eax + 16))->u0.left = dwLoc10 + ecx_177 / 28;
			(*((char *) eax + 28))->u0.left = (LONG) (struct tagMSG *) ~0x101A;
			(*((char *) eax + 32))->u0.left = (LONG) (struct tagMSG *) ~0x101A;
			LPMSG * eax_311 = *((char *) eax + 36);
			g_t409FDF.u0 = (ui32) 0x00409F3B;
			g_t409FDF.u0 = (ui32) (g_t409FDF.u0 & 0x00409F97);
			*eax_311 = (LPMSG *) (struct tagMSG *) ~0x101C;
		}
	}
	ebpOut = ebp;
	return null;
}

// 00405A58: Register Eq_286 Win32CrtStartup()
Eq_286 Win32CrtStartup()
{
	ptr32 fp;
	word32 esi;
	word32 edi;
	Eq_2827 tLoc14;
	Eq_2828 tLoc0C;
	Eq_2829 tLoc08;
	int32 dwLoc1C;
	int32 dwLoc2C;
	Eq_286 dwLoc20;
	if (SHLWAPI.dll!StrSpnA(4232532, 0x00409550) <= 0x0A)
	{
		esp_14->dwFFFFFFFC = esi;
		esp_14->dwFFFFFFF8 = edi;
		g_dw409FBF = 0x00;
		do
		{
			++g_dw409FBF;
			if (g_dw409FBF == 33)
			{
				esp_14->tFFFFFFF4 = (void *) 0x3BDD;
				esp_14->tFFFFFFF0 = (struct HINSTANCE__ *) 0x1B92;
				esp_14->tFFFFFFEC = (struct HMENU__ *) 22116;
				esp_14->tFFFFFFE8.u0 = 0x2BBB;
				esp_14->dwFFFFFFE4 = dwLoc1C;
				esp_14->dwFFFFFFE0 = dwLoc2C;
				esp_14->tFFFFFFDC.u0 = (int32) dwLoc20;
				esp_14->dwFFFFFFD8 = 0x47AD;
				esp_14->tFFFFFFD4.u0 = 11850;
				esp_14->tFFFFFFD0 = (Eq_2892) &g_t40A1D8;
				esp_14->tFFFFFFCC = (Eq_2892) &g_t40A25E;
				esp_14->tFFFFFFC8.u0 = (int32) dwLoc20;
				CreateWindowExA(esp_14->tFFFFFFC8.u1, esp_14->tFFFFFFCC, esp_14->tFFFFFFD0, esp_14->tFFFFFFD4.u1, esp_14->dwFFFFFFD8, esp_14->tFFFFFFDC.u0, esp_14->dwFFFFFFE0, esp_14->dwFFFFFFE4, esp_14->tFFFFFFE8.u0, esp_14->tFFFFFFEC, esp_14->tFFFFFFF0, esp_14->tFFFFFFF4);
			}
		} while (g_dw409FBF < 0x1D);
		fn00404917(fp - 4, &tLoc14, ~0x101E);
		fn004049DB(fp - 4, &tLoc0C, fp - 16);
		fn004049DB(fp - 4, &g_t409540, 0x00);
		fn00404917(fp - 4, &g_dw409544, 0x00);
		fn004049DB(fp - 4, &g_dw409548, 0x00);
		fn004049DB(fp - 4, &g_dw40954C, 0x00);
		tLoc08 = (Eq_2829) fp;
		fn004049DB(fp - 4, &tLoc08, 0x06586466);
		tLoc08 = (Eq_2829) (fp - 4);
		struct Eq_516 * eax_145 = tLoc08;
		g_dw409F6F &= 0x00409F27;
		g_dw409F6F += 4235123;
		fn00403D7A(eax_145);
		fn004049DB(fp - 4, &g_dw4094C4, g_t409540.u0);
		g_dw409FAB += g_dw409F9F;
	}
	else
	{
		g_dw409F97 &= 4235131;
		return 0x00;
	}
}

// 00405CF0: Register word32 fn00405CF0(Register word32 ecx, Register word32 esi, Register word32 edi)
// Called from:
//      Win32CrtStartup
word32 fn00405CF0(word32 ecx, word32 esi, word32 edi)
{
	int32 dwLoc34;
	g_ptr4094B0 = null;
	struct Eq_1765 * esp_55 = (struct Eq_1765 *) <invalid>;
	word32 ebx_49;
	word32 esi_52;
	struct Eq_3048 * ebp_53;
	word32 edi_54;
	if (fn00404BCB(ecx, esi, edi, out ebx_49, out ebp_53, out esi_52, out edi_54) != 0x00)
	{
		esp_55->dwFFFFFFFC = ebx_49;
		esp_55->dwFFFFFFF8 = esi_52;
		esp_55->dwFFFFFFF4 = edi_54;
		ui32 edi_145 = ~0x111B;
		word32 * ebx_138 = &ebp_53->dw0000 + 1;
		word32 * esi_148 = (word32 *) 0x3531;
		do
		{
			g_dw409310 = g_dw4094C4;
			g_dw409314 = g_dw4094C8;
			g_dw409318 = g_dw4094CC;
			if (edi_145 == ~0x101C)
			{
				g_dw409F43 = 0x00;
				while (g_dw409F43 < 0x13)
				{
					if (g_dw409F43 == 0x1A)
						GetUserDefaultLCID();
					++g_dw409F43;
				}
				word32 * eax_113 = g_ptr4094B0;
				ebp_53->dwFFFFFFEC = 0x2283;
				if (ebp_53->dwFFFFFFEC < 0x1283)
				{
					ebp_53->dwFFFFFFE4 &= 0x3100;
					up32 v23_123 = ebp_53->dwFFFFFFDC - (word32) ebp_53->wFFFFFFD8;
					ebp_53->dwFFFFFFDC = v23_123;
					ebp_53->dwFFFFFFEC = ebp_53->dwFFFFFFEC + *g_ptr40A189 + (word32) (v23_123 < 0x00);
				}
				*eax_113 += g_dw4090F8;
			}
			else if (edi_145 == ~0x11DE)
			{
				g_ptr40930C = ebp_53 - 8;
				*g_ptr4094D0 = fn00405E99(ebx_138, esi_148, edi_145, esp_55->dwFFFFFFF0, out ebx_138, out esi_148, out edi_145);
			}
			g_ptr4094B0 = ebx_138;
			edi_145 = (edi_145 ^ esi_148) - (ebp_53->dwFFFFFFF4 ^ esi_148) - 0x2530 ^ esi_148;
		} while (edi_145 != ~0x101F);
	}
	return ebp_53->dw0000;
}

// 00405E99: Register word32 fn00405E99(Register (ptr32 word32) ebx, Register (ptr32 word32) esi, Register ui32 edi, Stack ui32 dwArg00, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out Eq_3126 ediOut)
// Called from:
//      fn00405CF0
word32 fn00405E99(word32 * ebx, word32 * esi, ui32 edi, ui32 dwArg00, ptr32 & ebxOut, ptr32 & esiOut, union Eq_3126 & ediOut)
{
	word32 * fp;
	Eq_597 dwLoc24;
	g_dw409F23 = 0x12;
	while (g_dw409F23 != 0x00)
	{
		if (g_dw409F23 == 0x1D)
			IsWindow(dwLoc24);
		--g_dw409F23;
	}
	word32 dwLoc08_167;
	g_dw4090E4 = g_dw409310;
	g_dw4090E8 = g_dw409314;
	g_dw4090EC = g_dw409318;
	word32 edx_61;
	ptr32 ebx_68;
	Eq_3126 edi_70;
	ptr32 esi_72;
	if (fn00404A85(fn00403BAF(ebx, esi, fp - 8, *g_ptr40930C, g_dw4092F4, out edx_61), edx_61, esi, edi, out ebx_68, out esi_72, out edi_70) != 0x00)
	{
		g_dw409090 += 0x00677577;
		dwLoc08_167 = 0x00;
	}
	else
	{
		word32 * eax_82 = g_ptr4092D0->ptr003C;
		dwLoc08_167 = *eax_82;
	}
	g_ptr4092F0 = fp;
	g_t409F53.u1 = (word32) (g_t409F53.u1 ^ 0x93EE);
	*g_ptr4092F0 = dwArg00 + g_dw4090F8;
	ebxOut = ebx_68;
	esiOut = esi_72;
	ediOut = edi_70;
	return dwLoc08_167;
}

// 0040666F: Register word32 fn0040666F(Register out Eq_1755 ebxOut, Register out (ptr32 Eq_1756) ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404BCB
//      fn00405182
word32 fn0040666F(union Eq_1755 & ebxOut, struct Eq_1756 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	struct Eq_3282 * ebp_26 = fp - 4;
	struct Eq_3285 * esp_18 = fp - 0x02D4;
l004066A2:
	word32 eax_230;
	Eq_137 eax_102 = ebp_26->t0008;
	ebp_26->tFFFFFFCC = eax_102;
	if (ebp_26->tFFFFFFB8 == (union <anonymous> *) ~0x101E)
	{
		g_dw40A00F = 0x00;
		do
		{
			++g_dw40A00F;
			if (g_dw40A00F == 0x14)
			{
				struct Eq_3298 * esp_45 = esp_18 - 4;
				esp_45->dw0000 = 25623;
				esp_45->tFFFFFFFC.u0 = 0x00409F2B;
				esp_45->tFFFFFFF8.u0 = 18221;
				ChildWindowFromPointEx(esp_45->tFFFFFFF8.u0, esp_45->tFFFFFFFC, esp_45->t0004);
				esp_18 = (struct Eq_3285 *) (&esp_45->t0004 + 1);
			}
		} while (g_dw40A00F < 0x12);
		ebp_26->dwFFFFFF7C = ebp_26->dw000C;
		ebp_26->ptrFFFFFF80 = ebp_26 - 76;
		ebp_26->ptrFFFFFF84 = ebp_26 - 40;
		ebp_26->ptrFFFFFF88 = ebp_26 - 16;
		ebp_26->ptrFFFFFF8C = ebp_26 - 48;
		ebp_26->ptrFFFFFF90 = ebp_26 - 36;
		ebp_26->ptrFFFFFF94 = ebp_26 - 44;
		ebp_26->ptrFFFFFF98 = ebp_26 - 20;
		ebp_26->ptrFFFFFF9C = ebp_26 - 24;
		ebp_26->ptrFFFFFFA0 = ebp_26 - 0x0044;
		eax_102 = fn004056BA(ebp_26 - 0x84, 0x3531, out ebp_26);
		if (eax_102 == null)
			goto l00406B89;
	}
	if (ebp_26->dwFFFFFFE8 != ~0x101E)
	{
		eax_102 = ebp_26->tFFFFFFF0;
		if (eax_102->u0.t0018.u0 == 0x00 || (eax_102->u0).dw0014 == 0x00)
		{
			ebp_26->tFFFFFFA4 = (union <anonymous> *) ~0x101E;
			goto l004069F1;
		}
	}
	if (ebp_26->dwFFFFFFEC != ~0x101E)
	{
		ebp_26->dwFFFFFF38 = 0x0947D051;
		if (ebp_26->dwFFFFFF38 >= 155705425)
		{
l004067AC:
			if (ebp_26->tFFFFFFA4 == eax_102)
			{
				g_dw409FB7 = 0x00;
				do
				{
					++g_dw409FB7;
					if (g_dw409FB7 == 0x27)
					{
						struct Eq_3394 * esp_142 = esp_18 - 4;
						esp_142->t0000 = (Eq_3397) &g_t409F27;
						esp_142->dwFFFFFFFC = 0x4556;
						esp_142->dwFFFFFFF8 = 0x4432;
						esp_142->tFFFFFFF4.u1 = (HDC) 21313;
						eax_102 = SetWindowOrgEx(esp_142->tFFFFFFF4.u1, esp_142->dwFFFFFFF8, esp_142->dwFFFFFFFC, esp_142->t0000);
					}
				} while (g_dw409FB7 < 0x18);
				Eq_3488 ecx_170 = (ebp_26->dwFFFFFFF4 ^ 0x3531) + 0x2530;
				if (ecx_170 > 0x06)
					ebp_26->tFFFFFFB8 = eax_102;
				ebp_26->tFFFFFFCC = (Eq_137) ((char *) ebp_26->tFFFFFFCC + 0x00007522);
				if (ecx_170 < (((ebp_26->tFFFFFFF0)->u0).t0018).u0)
				{
					g_t40A003.u1 = (word32) ((word32) g_t40A003.u0 + ebp_26->dwFFFFFF34);
					ebp_26->ptrFFFFFFF8 = ebp_26 - 64;
					ebp_26->ptrFFFFFFF8->u0 = (int32) (ecx_170 * 0x02);
					ebp_26->ptrFFFFFFF8 = ebp_26 - 4;
					union Eq_3549 * eax_201 = ebp_26->dwFFFFFFC0 + ebp_26->dwFFFFFFDC;
					g_dw409F4B -= g_dw409FFB;
					ebp_26->ptrFFFFFFF8->u1 = eax_201->u1;
					word16 ax_211 = ebp_26->wFFFFFFFC;
					g_dw409F63 += ebp_26->dwFFFFFF24;
					up32 edx_216 = ebp_26->tFFFFFFF0->u0.dw0014;
					g_dw409F43 = g_dw409F43 + 0x00409F7F + (word32) (g_dw409F8B > ~0x101E);
					if (((word32) ax_211 - 0x2530 ^ 0x3531 ^ 0x3531) + 0x2530 <= edx_216 - 0x01)
					{
						up32 v33_247;
						ebp_26->ptrFFFFFEC4 = ebp_26 - 0x0130;
						ui32 * eax_236 = ebp_26->ptrFFFFFEC4;
						*eax_236 |= (word32) ebp_26->bFFFFFEBC;
						ebp_26->tFFFFFFCC = (Eq_137) ((char *) ebp_26->tFFFFFFCC - 0x00007522);
						word32 eax_243 = ebp_26->dwFFFFFFBC;
						if (ebp_26->dwFFFFFEF8 > 0x7B22)
							ebp_26->dwFFFFFF4C = ebp_26->dwFFFFFF4C + ebp_26->dwFFFFFF48 + (word32) (ebp_26->dwFFFFFEF8 < 0x7B22);
						else
						{
							v33_247 = ebp_26->dwFFFFFE78 + 0x21B0;
							ebp_26->dwFFFFFE78 = v33_247;
						}
						ebp_26->tFFFFFE9C.u1 = (word32) ((word32) ebp_26->tFFFFFE9C.u0 - ebp_26->dwFFFFFE98 - (word32) (v33_247 < 0x00));
						ebp_26->dwFFFFFFE4 = 0x00;
						ebp_26->ptrFFFFFFA8 = (word32) *((word32) (((eax_243 ^ 0x3531) + 0x2530) *s ecx_170) + ebp_26->dwFFFFFFDC);
						ebp_26->ptrFFFFFFF8 = ebp_26 - 60;
						ebp_26->dwFFFFFEFC = 23833;
						if (ebp_26->dwFFFFFEFC < 19737)
						{
							uint32 eax_281 = ebp_26->dwFFFFFEF8;
							ebp_26->dwFFFFFEF8 = eax_281 << 0x0D;
							g_t409F67.u0 = (uint32) (g_t409F67.u0 - 32731 - (word32) (eax_281 << 0x0D < 0x00));
							ebp_26->dwFFFFFE24 |= ebp_26->dwFFFFFE1C;
						}
						ebp_26->ptrFFFFFFF8->u0 = (int32) (((ebp_26->dwFFFFFFE8 ^ 0x3531) + 0x2530) *s ecx_170);
						ebp_26->ptrFFFFFFF8 = ebp_26 - 56;
						union Eq_3549 * ecx_313 = ebp_26->ptrFFFFFFF8;
						ecx_313->u0 = (int32) *((word32) ebp_26->ptrFFFFFFC4 + ebp_26->dwFFFFFFD0);
						ebp_26->dwFFFFFE28 += g_dw409FF7;
						ebp_26->ptrFFFFFFF8 = ebp_26->dwFFFFFFC8 + ebp_26->dw000C;
						esp_18->dwFFFFFFFC = ebp_26 - 28;
						g_dw40A00B -= ebp_26->dwFFFFFDC8;
						esp_18->dwFFFFFFF8 = ebp_26->ptrFFFFFFF8;
						Eq_137 eax_336 = ebp_26->tFFFFFFCC;
						esp_18->dwFFFFFFF4 = ebp_26->dw0010;
						word32 edx_356;
						eax_336();
						if (ebp_26->dwFFFFFFE4 != 0x01)
						{
l004069F1:
							ebp_26->dwFFFFFF78 = 0x00;
							while (ebp_26->dwFFFFFF78 < 0x1F)
							{
								if (ebp_26->dwFFFFFF78 == 0x2F)
								{
									struct Eq_3449 * esp_525 = esp_18 - 4;
									esp_525->t0000 = ebp_26->tFFFFFFF0;
									esp_525->ptrFFFFFFFC = (RECT *) 0x20A0;
									esp_525->tFFFFFFF8 = (Eq_2320) &g_dw409F5F;
									UnionRect(esp_525->tFFFFFFF8, esp_525->ptrFFFFFFFC, esp_525->t0000);
								}
								++ebp_26->dwFFFFFF78;
							}
							ebp_26->dwFFFFFFF4 = (ebp_26->dwFFFFFFF4 ^ 0x3531) + 0x01 ^ 0x3531;
							goto l004066A2;
						}
						ebp_26->ptrFFFFFFA8 = ebp_26->ptrFFFFFFD8[ebp_26->ptrFFFFFFA8] + ebp_26->dw000C;
						ebp_26->ptrFFFFFFE0 = null;
						if (ebp_26->dw0014 != 0x00)
						{
							Eq_137 eax_376 = (ebp_26->dwFFFFFFEC ^ 0x3531) + 0x2530;
							ebp_26->ptrFFFFFFAC = null;
							ebp_26->tFFFFFFB8 = eax_376;
							Eq_137 eax_379 = ebp_26->tFFFFFFB8;
							ebp_26->dwFFFFFF50 = 0x002FB400;
							if (ebp_26->dwFFFFFF50 <= 0x002FA400)
								goto l00406B81;
							ebp_26->ptrFFFFFFF8 = eax_379 *s ebp_26->dw0014;
							ebp_26->ptrFFFFFFE0 = esp_18;
							ui32 * eax_386 = g_ptr40A145;
							*eax_386 = *eax_386 ^ g_dw409FFB;
							struct Eq_3285 * eax_391 = esp_18;
							int32 ecx_398 = ebp_26->tFFFFFFB8 *s ebp_26->dw0014;
							do
							{
								--eax_391;
								--ecx_398;
							} while (ecx_398 != 0x00);
							ebp_26->dwFFFFFF74 &= ebp_26->dwFFFFFF68;
							ebp_26->ptrFFFFFFAC = eax_391;
							ebp_26->dwFFFFFF0C = ebp_26->dwFFFFFF0C + (word32) ebp_26->wFFFFFF04 + 0x01;
							ebp_26->dwFFFFFFF4 = 0x00;
							union Eq_83 * ecx_426 = g_ptr40A0C5;
							ecx_426->u1 = (byte) (ecx_426->u1 + 0x57 + (byte) (g_dw409F23 > 0x2530));
							word32 * eax_431 = &ebp_26->dw0014;
							do
							{
								word32 ecx_434 = ebp_26->dwFFFFFFEC;
								struct Eq_3285 * ebx_435 = ebp_26->ptrFFFFFFAC;
								g_dw409F5F -= (word32) g_t409F67.u1;
								++eax_431;
								word32 edx_449 = *eax_431;
								++ebp_26->dwFFFFFFF4;
								ebx_435[((ecx_434 ^ 0x3531) + 0x2530) *s ebp_26->dwFFFFFFF4 / 8] = (struct Eq_3285) edx_449;
							} while (ebp_26->dwFFFFFFF4 != ebp_26->dw0014);
						}
						else
							ebp_26->ptrFFFFFFE0 = null;
						word32 eax_467;
						word32 ecx_468;
						word32 edx_469;
						ebp_26->ptrFFFFFFA8();
						ebp_26->dwFFFFFFB0 = eax_467;
						esp_18 = ebp_26->ptrFFFFFFE0;
l00406B81:
						eax_230 = ebp_26->dwFFFFFFB0;
l00406B8B:
						struct Eq_4111 * esp_489 = &esp_18->dw0000 + 1;
						ptr32 edi_488 = esp_18->dw0000;
						ptr32 esi_490 = esp_489->ptr0000;
						struct Eq_1756 * ebp_496 = ebp_26->ptr0000;
						ebxOut.u0 = esp_489->t0004.u0;
						ebpOut = ebp_496;
						esiOut = esi_490;
						ediOut = edi_488;
						return eax_230;
					}
				}
			}
			goto l00406B89;
		}
		if (ebp_26->dwFFFFFFF4 != (ebp_26->dwFFFFFFD4 + ~0x252F ^ 0x3531))
		{
			eax_102 = (union <anonymous> *) ~0x101F;
			goto l004067AC;
		}
	}
l00406B89:
	eax_230 = 0x00;
	goto l00406B8B;
}

// 00406C73: Register int16 WDS_D_Ikxn_ZP_(Stack uint32 dwArg04, Stack (ptr32 bool) ptrArg08)
int16 WDS_D_Ikxn_ZP_(uint32 dwArg04, bool * ptrArg08)
{
	ptr32 fp;
	ptr32 ebx;
	ptr32 dwLoc08;
	g_dw409F77 = g_dw409F77 + g_dw409F57 + (word32) (ebx < dwLoc08);
	g_t409F8F.u1 = (word32) ((word32) g_t409F8F.u0 + g_ptr40A161->u2 + (word32) (ebx < fp - 4));
	ui32 * edx_22 = g_ptr40A105;
	*edx_22 = *edx_22 ^ (word32) g_t409FAF.u1;
	return <invalid>;
}

// 00406CBC: Register (ptr32 cu8) PRTptodxbmblwu_kti(Stack cu8 bArg04)
cu8 * PRTptodxbmblwu_kti(cu8 bArg04)
{
	g_dw409FF7 -= *g_ptr40A181;
	g_t409FEB.u0 = (ui32) (g_t409FEB.u0 - *g_ptr40A18D);
	g_t409FCB.u0 = (ui32) ((word32) g_t409FCB.u1 | *g_ptr40A0E9);
	return (cu8 *) <invalid>;
}

// 00406D05: Register int32 Tdqkjh_g_hqcqjh__CRHXU(Stack (ptr32 char) ptrArg04, Stack (ptr32 real32) ptrArg08)
int32 Tdqkjh_g_hqcqjh__CRHXU(char * ptrArg04, real32 * ptrArg08)
{
	ui32 * edi_10 = g_ptr40A10D;
	*edi_10 = *edi_10 ^ (word32) g_t409FC7.u1;
	g_t409F67.u0 = (uint32) (g_t409F67.u0 & *g_ptr40A191);
	g_dw409F5B += *g_ptr40A1A9;
	return <invalid>;
}

// 00406D46: Register bool _df_eLGQD__Yaavzfmm(Stack int16 wArg04)
bool _df_eLGQD__Yaavzfmm(int16 wArg04)
{
	Eq_126 eax;
	g_dw409F8B = g_ptr409F7F + g_dw409F8B + (word32) (eax < g_t409F1F.u1);
	word32 * edi_16 = g_ptr40A0E1;
	*edi_16 -= g_dw40A00F;
	g_t409F37.u1 = (word32) (g_t409F37.u1 & g_ptr40A161->u2);
	return <invalid>;
}

// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 * g_ptr409028 = &g_dw401018; // 00409028
ui32 ** g_ptr409034 = &g_ptr409028; // 00409034
ui32 *** g_ptr409038 = &g_ptr409034; // 00409038
Eq_602 g_t409060 = // 00409060
	{
		0x004010A4
	};
word32 g_dw40906C = 4208800; // 0040906C
union Eq_602 * g_ptr409078 = &g_t409060; // 00409078
word32 * g_ptr40907C = &g_dw40906C; // 0040907C
struct Eq_136 * g_ptr409084 = null; // 00409084
word32 g_dw409088 = 0x00; // 00409088
word32 g_dw409090 = ~0x303E; // 00409090
word32 * g_a4090CC[] = // 004090CC
	{
	};
word32 g_dw4090E4 = 0x00; // 004090E4
word32 g_dw4090E8 = 0x00; // 004090E8
word32 g_dw4090EC = 0x00; // 004090EC
word32 g_dw4090F0 = 0x00; // 004090F0
word32 g_dw4090F4 = 0x00; // 004090F4
up32 g_dw4090F8 = 0x00; // 004090F8
word32 g_dw4090FC = 0x00; // 004090FC
word32 g_dw409100 = 0x00; // 00409100
Eq_134 g_t409108 = // 00409108
	{
		&g_ptr409084,
		&g_dw409100,
		&g_dw4090F0,
		&g_dw4090F4,
		0x00,
	};
word32 * g_ptr409114 = &g_dw409100; // 00409114
struct Eq_134 * g_ptr4092D0 = &g_t409108; // 004092D0
Eq_1465 g_t4092E4 = 0x07860677; // 004092E4
Eq_602 g_t4092E8 = // 004092E8
	{
		88433785
	};
int32 g_dw4092EC = 0x05475768; // 004092EC
word32 * g_ptr4092F0 = null; // 004092F0
word32 g_dw4092F4 = 4200503; // 004092F4
Eq_135 g_t4092FC = // 004092FC
	{
		25622
	};
word32 g_dw409300 = 6624275; // 00409300
word32 g_dw409304 = 15080055; // 00409304
struct Eq_248 * g_ptr409308 = &g_t4042D6; // 00409308
word32 * g_ptr40930C = &g_dw77704; // 0040930C
word32 g_dw409310 = 0x06751704; // 00409310
word32 g_dw409314 = 0x00060704; // 00409314
word32 g_dw409318 = 0x07655777; // 00409318
word16 g_a409338[] = // 00409338
	{
	};
word32 * g_ptr4094B0 = &g_dw342515; // 004094B0
char g_b4094BC = 'v'; // 004094BC
word32 g_dw4094C4 = 488818; // 004094C4
word32 g_dw4094C8 = 0x00077767; // 004094C8
word32 g_dw4094CC = 141969016; // 004094CC
ui32 * g_ptr4094D0 = &g_dw42416; // 004094D0
ui8 g_a4094D4[16] = // 004094D4
	{
		117,
		0x53,
		0x20,
		0x7C,
		0x5E,
		0x5D,
		0x51,
		111,
		0x50,
		0x50,
		0x5E,
		0x53,
		33,
		33,
		0xAC,
		0x00,
	};
Eq_1723 g_t4094E4 = // 004094E4
	{
		0x00
	};
word32 g_dw40950C = 0x00; // 0040950C
char g_b409524 = 'K'; // 00409524
char g_b409534 = 'J'; // 00409534
Eq_523 g_t409540 = // 00409540
	{
		0x00787606
	};
word32 g_dw409544 = 0x003515C0; // 00409544
word32 g_dw409548 = 144131944; // 00409548
word32 g_dw40954C = 0x76860424; // 0040954C
<anonymous> * g_ptr409578 = fn0040666F; // 00409578
word32 g_dw40957C = 0x00405FFB; // 0040957C
ui32 g_dw409F1B = 0x00104A06; // 00409F1B
Eq_126 g_t409F1F = // 00409F1F
	{
		3183
	};
up32 g_dw409F23 = 0x00107DBD; // 00409F23
struct tagPOINT g_t409F27 = // 00409F27
	{
		1072231,
		1070108,
	};
ui32 g_dw409F2B = 1070108; // 00409F2B
Eq_660 g_t409F2F = // 00409F2F
	{
		1077137
	};
ui32 g_dw409F33 = 0x00101C63; // 00409F33
Eq_92 g_t409F37 = // 00409F37
	{
		17291
	};
Eq_123 g_t409F3B = // 00409F3B
	{
		0x001003AD
	};
ui32 g_dw409F3F = 0x0010272B; // 00409F3F
uint32 g_dw409F43 = 1065717; // 00409F43
up32 g_dw409F4B = 0x00103638; // 00409F4B
word16 g_w409F4F = 0x324A; // 00409F4F
Eq_802 g_t409F53 = // 00409F53
	{
		0x6D98
	};
ui32 g_dw409F57 = 0x00100650; // 00409F57
word32 g_dw409F5B = 0x001010B1; // 00409F5B
word32 g_dw409F5F = 0x001016A2; // 00409F5F
word32 g_dw409F63 = 0x00106D80; // 00409F63
Eq_22 g_t409F67 = // 00409F67
	{
		0x00106706
	};
ptr32 g_ptr409F6B = 0x00101784; // 00409F6B
ui32 g_dw409F6F = 0x00102883; // 00409F6F
ui32 g_dw409F77 = 0x00103C00; // 00409F77
ui32 g_dw409F7B = 0x001007D8; // 00409F7B
ui32 * g_ptr409F7F = &g_dw100F08; // 00409F7F
byte g_b409F83 = 66; // 00409F83
up32 g_dw409F87 = 0x00104B60; // 00409F87
uint32 g_dw409F8B = 0x00105610; // 00409F8B
Eq_1272 g_t409F8F = // 00409F8F
	{
		0x92
	};
word32 * g_ptr409F93 = &g_dw10024A; // 00409F93
ui32 g_dw409F97 = 0x0010669F; // 00409F97
uint32 g_dw409F9B = 1078680; // 00409F9B
word32 g_dw409F9F = 0x00103374; // 00409F9F
word32 g_dw409FA7 = 0x001008DB; // 00409FA7
uint32 g_dw409FAB = 0x00104DDE; // 00409FAB
Eq_227 g_t409FAF = // 00409FAF
	{
		0x00101EF0
	};
cui16 g_w409FB3 = 27225; // 00409FB3
up32 g_dw409FB7 = 0x00102F72; // 00409FB7
ui32 g_dw409FBB = 0x0010009E; // 00409FBB
up32 g_dw409FBF = 1058915; // 00409FBF
Eq_2361 g_t409FC3 = // 00409FC3
	{
		1059112
	};
Eq_2447 g_t409FC7 = // 00409FC7
	{
		0x001020CF
	};
Eq_4187 g_t409FCB = // 00409FCB
	{
		0x00106563
	};
up32 g_dw409FCF = 0x001008BC; // 00409FCF
word32 g_dw409FD3 = 0x00103064; // 00409FD3
Eq_8 g_t409FD7 = // 00409FD7
	{
		0x84
	};
ui32 g_dw409FDB = 1072715; // 00409FDB
Eq_1794 g_t409FDF = // 00409FDF
	{
		0x00103632
	};
word32 g_dw409FE3 = 1050553; // 00409FE3
word16 g_w409FE7 = 0x7799; // 00409FE7
Eq_388 g_t409FEB = // 00409FEB
	{
		0x00106A0A
	};
word32 g_dw409FEF = 0x00103E37; // 00409FEF
ui32 g_dw409FF3 = 0x00102A27; // 00409FF3
word32 g_dw409FF7 = 0x00102C24; // 00409FF7
ui32 g_dw409FFB = 0x00101731; // 00409FFB
up32 g_dw409FFF = 0x00107BA7; // 00409FFF
Eq_3536 g_t40A003 = // 0040A003
	{
		13151
	};
word32 g_dw40A007 = 0x00101B1A; // 0040A007
word32 g_dw40A00B = 1064113; // 0040A00B
up32 g_dw40A00F = 1080646; // 0040A00F
WCHAR g_t40A013 = 'p'; // 0040A013
ui32 * g_ptr40A0BD = &g_dw409F1F; // 0040A0BD
ui32 * g_ptr40A0C1 = &g_dw409F23; // 0040A0C1
union Eq_83 * g_ptr40A0C5 = &g_t409F27; // 0040A0C5
word32 * g_ptr40A0E1 = &g_dw409F43; // 0040A0E1
ui32 * g_ptr40A0E9 = &g_dw409F4B; // 0040A0E9
word32 * g_ptr40A0F9 = &g_dw409F5B; // 0040A0F9
ui32 * g_ptr40A0FD = &g_dw409F5F; // 0040A0FD
word32 * g_ptr40A101 = &g_dw409F63; // 0040A101
ui32 * g_ptr40A105 = &g_dw409F67; // 0040A105
byte * g_ptr40A109 = &g_b409F6B; // 0040A109
ui32 * g_ptr40A10D = &g_dw409F6F; // 0040A10D
word32 * g_ptr40A121 = &g_dw409F83; // 0040A121
word32 * g_ptr40A129 = &g_dw409F8B; // 0040A129
word32 * g_ptr40A12D = &g_dw409F8F; // 0040A12D
word32 * g_ptr40A13D = &g_dw409F9F; // 0040A13D
ui32 * g_ptr40A145 = &g_dw409FA7; // 0040A145
ui32 * g_ptr40A151 = &g_dw409FB3; // 0040A151
union Eq_1138 * g_ptr40A161 = &g_t409FC3; // 0040A161
ui32 * g_ptr40A16D = &g_dw409FCF; // 0040A16D
word32 * g_ptr40A171 = &g_dw409FD3; // 0040A171
byte * g_ptr40A175 = &g_b409FD7; // 0040A175
word32 * g_ptr40A181 = &g_dw409FE3; // 0040A181
word32 * g_ptr40A189 = &g_dw409FEB; // 0040A189
word32 * g_ptr40A18D = &g_dw409FEF; // 0040A18D
ui32 * g_ptr40A191 = &g_dw409FF3; // 0040A191
word32 * g_ptr40A199 = &g_dw409FFB; // 0040A199
word32 * g_ptr40A1A5 = &g_dw40A007; // 0040A1A5
word32 * g_ptr40A1A9 = &g_dw40A00B; // 0040A1A9
word32 * g_ptr40A1AD = &g_dw40A00F; // 0040A1AD
byte * g_ptr40A1B1 = &g_b40A013; // 0040A1B1
WCHAR g_t40A1B5 = 'S'; // 0040A1B5
CHAR g_t40A1D8 = 'I'; // 0040A1D8
CHAR g_t40A25E = 'U'; // 0040A25E
// subject_import.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40808C = 0x8130; // 0040808C
word32 g_dw408090 = 0x8144; // 00408090
word32 g_dw408094 = 33116; // 00408094
word32 g_dw40809C = 0x8186; // 0040809C
word32 g_dw4080A4 = 33180; // 004080A4
word32 g_dw4080A8 = 33196; // 004080A8
word32 g_dw4080AC = 33218; // 004080AC
word32 g_dw4080B0 = 0x81D8; // 004080B0
word32 g_dw4080B4 = 33266; // 004080B4
word32 g_dw4080B8 = 0x8206; // 004080B8
word32 g_dw4080BC = 33302; // 004080BC
word32 g_dw4080C0 = 33324; // 004080C0
word32 g_dw4080C4 = 33346; // 004080C4
word32 g_dw4080C8 = 33360; // 004080C8
word32 g_dw4080CC = 33382; // 004080CC
word32 g_dw4080D0 = 33396; // 004080D0
word32 g_dw4080D8 = 33432; // 004080D8
word32 g_dw4080E0 = 33454; // 004080E0
word32 g_dw4080E4 = 33470; // 004080E4
word32 g_dw4080E8 = 33488; // 004080E8
word32 g_dw4080EC = 0x82E0; // 004080EC
word32 g_dw4080F0 = 33514; // 004080F0
word32 g_dw4080F4 = 33524; // 004080F4
word32 g_dw4080FC = 33558; // 004080FC
word32 g_dw408100 = 0x8322; // 00408100
word32 g_dw408104 = 0x8336; // 00408104
word32 g_dw408108 = 0x8348; // 00408108
word32 g_dw40810C = 33634; // 0040810C
word32 g_dw408110 = 33646; // 00408110
word32 g_dw408114 = 33666; // 00408114
word32 g_dw408118 = 33684; // 00408118
word32 g_dw40811C = 0x83A8; // 0040811C
word32 g_dw408120 = 33722; // 00408120
word32 g_dw408124 = 33734; // 00408124
word32 g_dw408128 = 33754; // 00408128
