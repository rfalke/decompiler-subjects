/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __stdcall sub_401000(_DWORD *a1, SIZE_T a2, DWORD a3, DWORD a4);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// void __userpurge start(DWORD dwByteCount@<ecx>, DWORD ebx0@<ebx>, BYTE *esi0@<esi>, int a1, int a2, int a3, int a4);
void __stdcall sub_401348(int a1);
void __stdcall sub_401353(int a1);
void __stdcall sub_4013B2(int a1);
// NTSTATUS __stdcall NtSetIoCompletion(HANDLE IoCompletionPortHandle, PVOID CompletionKey, PVOID CompletionContext, NTSTATUS CompletionStatus, ULONG CompletionInformation);
// NTSTATUS __stdcall RtlAdjustPrivilege(ULONG Privilege, BOOLEAN NewValue, BOOLEAN ForThread, PBOOLEAN OldValue);
// NTSTATUS __stdcall NtQuerySemaphore(HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG Length, PULONG ReturnLength);
// DWORD __stdcall TraceDumpExA(DWORD dwTraceID, DWORD dwFlags, LPBYTE lpbBytes, DWORD dwByteCount, DWORD dwGroupSize, BOOL bAddressPrefix, LPCSTR lpszPrefix);
// DWORD __stdcall TraceDumpExW(DWORD dwTraceID, DWORD dwFlags, LPBYTE lpbBytes, DWORD dwByteCount, DWORD dwGroupSize, BOOL bAddressPrefix, LPCWSTR lpszPrefix);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_486000; // weak


//----- (00401000) --------------------------------------------------------
void __stdcall sub_401000(_DWORD *a1, SIZE_T a2, DWORD a3, DWORD a4)
{
  char v4; // cf
  _DWORD *v5; // eax
  int v6; // ecx

  if ( RtlAdjustPrivilege(0, 0, 0, 0) == -1073741727 )
  {
    if ( a3 )
    {
      *a1 = 0;
      sub_4013B2((int)a1);
      *v5 += v6 + v4;
      JUMPOUT(0x4012AA);
    }
  }
  else
  {
    VirtualAlloc(a1, a2, a3, a4);
  }
}
// 4010F5: control flows out of bounds to 4012AA
// 4010C7: variable 'v6' is possibly undefined
// 4010C7: variable 'v4' is possibly undefined
// 4010C7: variable 'v5' is possibly undefined

//----- (00401101) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __userpurge start(DWORD dwByteCount@<ecx>, DWORD ebx0@<ebx>, BYTE *esi0@<esi>, int a1, int a2, int a3, int a4)
{
  unsigned int v7; // eax
  DWORD v8; // ecx
  unsigned int i; // [esp+0h] [ebp-1ACh]
  char v10[16]; // [esp+4h] [ebp-1A8h] BYREF
  _DWORD v11[61]; // [esp+14h] [ebp-198h] BYREF
  LPCSTR *v12; // [esp+108h] [ebp-A4h]
  DWORD v13; // [esp+10Ch] [ebp-A0h]
  LPBYTE v14; // [esp+110h] [ebp-9Ch]
  DWORD v15; // [esp+114h] [ebp-98h]
  DWORD v16; // [esp+118h] [ebp-94h]
  BOOL v17; // [esp+11Ch] [ebp-90h]
  LPCWSTR v18; // [esp+120h] [ebp-8Ch]
  DWORD v19; // [esp+124h] [ebp-88h]
  DWORD v20; // [esp+128h] [ebp-84h]
  LPBYTE v21; // [esp+12Ch] [ebp-80h]
  DWORD v22; // [esp+130h] [ebp-7Ch]
  DWORD v23; // [esp+134h] [ebp-78h]
  BOOL v24; // [esp+138h] [ebp-74h]
  LPCSTR v25; // [esp+13Ch] [ebp-70h]
  DWORD v26; // [esp+140h] [ebp-6Ch]
  DWORD v27; // [esp+144h] [ebp-68h]
  LPBYTE v28; // [esp+148h] [ebp-64h]
  DWORD v29; // [esp+14Ch] [ebp-60h]
  DWORD v30; // [esp+150h] [ebp-5Ch]
  BOOL v31; // [esp+154h] [ebp-58h]
  LPCWSTR v32; // [esp+158h] [ebp-54h]
  DWORD v33; // [esp+15Ch] [ebp-50h]
  DWORD v34; // [esp+160h] [ebp-4Ch]
  LPBYTE v35; // [esp+164h] [ebp-48h]
  DWORD v36; // [esp+168h] [ebp-44h]
  DWORD v37; // [esp+16Ch] [ebp-40h]
  BOOL SemaphoreHandle; // [esp+170h] [ebp-3Ch] BYREF
  LPCSTR IoCompletionPortHandle[4]; // [esp+174h] [ebp-38h] BYREF
  LPCSTR *v40; // [esp+184h] [ebp-28h]
  SIZE_T dwSize; // [esp+188h] [ebp-24h] BYREF
  BOOL v42; // [esp+18Ch] [ebp-20h]
  const WCHAR *v43; // [esp+190h] [ebp-1Ch]
  DWORD v44; // [esp+194h] [ebp-18h]
  DWORD v45; // [esp+198h] [ebp-14h]
  char *v46; // [esp+19Ch] [ebp-10h]
  DWORD v47; // [esp+1A0h] [ebp-Ch]
  DWORD v48; // [esp+1A4h] [ebp-8h]
  BOOL v49; // [esp+1A8h] [ebp-4h]
  LPCSTR vars0; // [esp+1ACh] [ebp+0h] BYREF

  v15 = dwByteCount;
  v14 = esi0;
  v47 = 0;
  v13 = ebx0;
  v12 = &vars0;
  IoCompletionPortHandle[0] = 0;
  if ( NtSetIoCompletion(
         IoCompletionPortHandle,
         IoCompletionPortHandle,
         IoCompletionPortHandle,
         (NTSTATUS)IoCompletionPortHandle,
         (ULONG)IoCompletionPortHandle) == -1073741816 )
  {
    SemaphoreHandle = 0;
    v7 = NtQuerySemaphore(
           &SemaphoreHandle,
           (SEMAPHORE_INFORMATION_CLASS)&SemaphoreHandle,
           &SemaphoreHandle,
           (ULONG)&SemaphoreHandle,
           (PULONG)&SemaphoreHandle) ^ 0xC0000003;
    if ( v7 && v7 != 1 )
      sub_401000(v12, v13, (DWORD)v14, v15);
    if ( TraceDumpExA(0, 0, 0, 0, 0, 0, 0) == 87 )
    {
      v35 = 0;
      v47 += 2146436741;
      v8 = v47;
      v47 -= 2146436741;
      v44 = v47;
      v49 &= v47;
      v47 += v47 - (2142152325 - v8);
      v46 = v10;
      v40 = (LPCSTR *)&unk_486000;
      v43 = (const WCHAR *)v11;
      v49 -= 48;
      v49 = ~v49;
      ++v49;
      v15 = 4743168;
      v14 = (LPBYTE)v49;
      v13 = v47;
      sub_401353((int)v10);
      dwSize = *(_DWORD *)v46 + *((_DWORD *)v46 + 1);
      v44 = 0;
      v48 = (DWORD)VirtualAlloc(0, (SIZE_T)&dwSize, 0x3000u, 0x40u);
      v42 = 0x400000;
      for ( i = 0; i < *((_DWORD *)v46 + 2); ++i )
      {
        v12 = v40;
        v11[60] = *((_DWORD *)v43 + 1);
        v11[59] = *(_DWORD *)v43 + v42;
        sub_401348(v44 + v48);
        v44 += *((_DWORD *)v43 + 1);
        v43 += 4;
      }
      JUMPOUT(0x401361);
    }
  }
  else
  {
    TraceDumpExW((DWORD)v12, v13, v14, v15, v16, v17, v18);
    TraceDumpExA(v19, v20, v21, v22, v23, v24, v25);
    TraceDumpExW(v26, v27, v28, v29, v30, v31, v32);
    TraceDumpExA(v33, v34, v35, v36, v37, SemaphoreHandle, IoCompletionPortHandle[0]);
    TraceDumpExW(
      (DWORD)IoCompletionPortHandle[1],
      (DWORD)IoCompletionPortHandle[2],
      (LPBYTE)IoCompletionPortHandle[3],
      (DWORD)v40,
      dwSize,
      v42,
      v43);
    TraceDumpExA(v44, v45, (LPBYTE)v46, v47, v48, v49, vars0);
  }
  sub_401000((_DWORD *)a1, a2, a3, a4);
}
// 401161: positive sp value 94 has been found
// 401049: control flows out of bounds to 40104C
// 4012D4: control flows out of bounds to 401361
// 40125D: bad sp value at call

//----- (00401348) --------------------------------------------------------
void __stdcall sub_401348(int a1)
{
  JUMPOUT(0x401000);
}
// 40134D: control flows out of bounds to 401000

//----- (00401353) --------------------------------------------------------
void __stdcall sub_401353(int a1)
{
  JUMPOUT(0x401000);
}
// 40135B: control flows out of bounds to 401000

//----- (004013B2) --------------------------------------------------------
void __stdcall sub_4013B2(int a1)
{
  ;
}

// nfuncs=6 queued=5 decompiled=5 lumina nreq=0 worse=0 better=0
// ALL OK, 5 function(s) have been successfully decompiled
