// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
fn00401000_entry:
l00401000:
fn00401000_exit:
}

// 00401101: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 esp_43;
	word32 ebp_44;
	word32 edx_45;
	byte SZO_46;
	byte C_47;
	byte SCZO_48;
	word32 esi_49;
	word32 edi_50;
	word32 ecx_51;
	word32 ebx_52;
	word32 eax_53;
	byte Z_54;
	byte dl_55;
	byte cl_56;
	byte al_57;
	NTDLL.dll!NtSetIoCompletion();
	if (eax_53 != 0xC0000008)
	{
		word32 esp_517;
		word32 ebp_518;
		word32 edx_519;
		byte SZO_520;
		byte C_521;
		byte SCZO_522;
		word32 esi_523;
		word32 edi_524;
		word32 ecx_525;
		word32 ebx_526;
		word32 eax_527;
		byte Z_528;
		byte dl_529;
		byte cl_530;
		byte al_531;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_532;
		word32 ebp_533;
		word32 edx_534;
		byte SZO_535;
		byte C_536;
		byte SCZO_537;
		word32 esi_538;
		word32 edi_539;
		word32 ecx_540;
		word32 ebx_541;
		word32 eax_542;
		byte Z_543;
		byte dl_544;
		byte cl_545;
		byte al_546;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_547;
		word32 ebp_548;
		word32 edx_549;
		byte SZO_550;
		byte C_551;
		byte SCZO_552;
		word32 esi_553;
		word32 edi_554;
		word32 ecx_555;
		word32 ebx_556;
		word32 eax_557;
		byte Z_558;
		byte dl_559;
		byte cl_560;
		byte al_561;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_562;
		word32 ebp_563;
		word32 edx_564;
		byte SZO_565;
		byte C_566;
		byte SCZO_567;
		word32 esi_568;
		word32 edi_569;
		word32 ecx_570;
		word32 ebx_571;
		word32 eax_572;
		byte Z_573;
		byte dl_574;
		byte cl_575;
		byte al_576;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_577;
		word32 ebp_578;
		word32 edx_579;
		byte SZO_580;
		byte C_581;
		byte SCZO_582;
		word32 esi_583;
		word32 edi_584;
		word32 ecx_585;
		word32 ebx_586;
		word32 eax_587;
		byte Z_588;
		byte dl_589;
		byte cl_590;
		byte al_591;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_592;
		word32 ebp_593;
		word32 edx_594;
		byte SZO_595;
		byte C_596;
		byte SCZO_597;
		word32 esi_598;
		word32 edi_599;
		word32 ecx_600;
		word32 ebx_601;
		Eq_2 eax_602;
		byte Z_603;
		byte dl_604;
		byte cl_605;
		byte al_606;
		RTUTILS.dll!TraceDumpExA();
		fn00401000();
		return eax_602;
	}
	else
	{
		*(esp_43 - 0x04) = fp - 0x40;
		*(esp_43 - 0x08) = fp - 0x40;
		*(esp_43 - 0x0C) = fp - 0x40;
		*(esp_43 - 0x10) = fp - 0x40;
		*(esp_43 - 0x14) = fp - 0x40;
		word32 ebp_112;
		word32 edx_113;
		byte SZO_114;
		byte C_115;
		byte SCZO_116;
		word32 esi_117;
		word32 edi_118;
		word32 ecx_119;
		word32 ebx_120;
		word32 eax_121;
		byte Z_122;
		byte dl_123;
		byte cl_124;
		byte al_125;
		word32 esp_111;
		NTDLL.dll!NtQuerySemaphore();
		if ((eax_121 ^ 0xC0000003) != 0x00 && (eax_121 ^ 0xC0000003) != 0x01)
		{
			fn00401000();
			esp_111 = esp_111 + 0x04;
		}
		word32 * esp_132 = esp_111 - 0x04;
		*esp_132 = 0x00;
		*(esp_132 - 0x04) = 0x00;
		*(esp_132 - 0x08) = 0x00;
		*(esp_132 - 0x0C) = 0x00;
		*(esp_132 - 0x10) = 0x00;
		*(esp_132 - 0x14) = 0x00;
		*(esp_132 - 0x18) = 0x00;
		ptr32 esp_146;
		ptr32 ebp_147;
		word32 edx_148;
		byte SZO_149;
		byte C_150;
		byte SCZO_151;
		word32 esi_152;
		int32 edi_153;
		word32 ecx_154;
		word32 ebx_155;
		ui32 eax_156;
		byte Z_157;
		byte dl_158;
		byte cl_159;
		byte al_160;
		RTUTILS.dll!TraceDumpExA();
		if (eax_156 != 0x57)
		{
			fn00401000();
			return eax_156 - 0x57;
		}
		else
		{
			word32 v16_172 = 0x00 - (0x800FF9D2 - eax_156);
			ui32 v17_178 = v16_172 + ((dwLoc4C & (fp - (ui32 *) 0x40 & 0x00) + (eax_156 - 0x57)) + 2272615812 ^ 0x077AA4FF);
			Mem183[fp - 0x04 + -0x18:word32] = v17_178;
			word32 v20_204 = (dwLoc14 & 0x00) + ((fp - 0x04) + -((edi_153 *s 0x00 ^ 0x02A8) + ~0xFF));
			*(esp_146 - 0x04) = 0x00486000;
			ui32 edi_222 = ~((dwLoc08 & v17_178) + -((v20_204 - ~0x0F) *s 0x00 | 0x30));
			*(esp_146 - 0x08) = edi_222 - ~0x00;
			Eq_308 esi_192 = v17_178 - ((v16_172 + 0x8051597B ^ ~0x00) + 0x01) + dwLoc1C;
			*(esp_146 - 0x0C) = (LPVOID *) esi_192;
			*(esp_146 - 0x10) = fp - (ui32 *) 0x01AC;
			fn00401353(ebp_147);
			*(esp_146 - 0x0C) = 0x40;
			*(esp_146 - 0x10) = 0x3000;
			*(esp_146 - 0x14) = fp - (ui32 *) 0x28;
			*(esp_146 - 0x18) = 0x00;
			Eq_2 eax_262 = VirtualAlloc(*(esp_146 - 0x18), *(esp_146 - 0x14), *(esp_146 - 0x10), *(esp_146 - 0x0C));
			struct Eq_386 * dwLoc20_213 = v20_204 - ~0x0F;
			int32 dwLoc08_225 = edi_222 - ~0x00;
			Eq_390 dwLoc1C_252 = dwLoc1C & 0x00;
			ptr32 esp_264 = esp_146 - 0x08;
			Eq_2 dwLoc0C_265 = eax_262;
			ptr32 ecx_266 = 0x00;
			uint32 dwLoc01B0_274 = dwLoc01B0 & 0x00;
			if (0x00 == 0x00)
			{
				while (dwLoc01B0_274 < v20_204->dw0008)
				{
					word32 * esp_440 = esp_264 - 0x04;
					*esp_440 = 0x00486000;
					*(esp_440 - 0x04) = dwLoc20_213->t0004;
					*(esp_440 - 0x08) = dwLoc20_213->dw0000 + 0x00400000;
					Mem455[esp_440 - 0x0C + 0x00:word32] = eax_262 + dwLoc1C_252;
					fn00401348(ebp_147);
					esp_264 = esp_440 - 0x0C;
					dwLoc1C_252 = (Eq_390) ((char *) dwLoc1C_252 + dwLoc20_213->t0004);
					dwLoc01B0_274 = dwLoc01B0_274 + 0x01;
					dwLoc20_213 = dwLoc20_213 + 0x01;
				}
				word32 * esp_470 = esp_264 - 0x04;
				*esp_470 = 0x00400000;
				*(esp_470 - 0x04) = v14;
				word32 eax_476 = eax_262 + -~0x152F;
				ui32 edi_497 = *((char *) (v20_204 + (eax_476 & 0x00) / 0x0C) + 0x04) + ((eax_476 & 0x00) - v16) / 0x0C;
				*(esp_470 - 0x08) = edi_497;
				ui32 edi_501 = edi_497 & 0x00 | v13;
				*(esp_470 - 0x0C) = edi_501;
				*(esp_470 - 0x10) = edi_501 + 0x0B90;
				*(esp_470 - 0x14) = (union Eq_2 *) v13;
				return v13;
			}
			else
			{
l004012AA:
				*(esp_146 - 0x0C) = ecx_266;
				Eq_2 v43_308 = dwLoc0C_265 & 0x00 | dwLoc0C_265 - esi_192;
				dwLoc0C_265 = v43_308;
				if (v43_308 < dwArg0C)
				{
					ui32 ecx_363 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg10[dwLoc08_225].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] & 0xFF ^ ~0x00;
					Eq_2 ecx_373 = (word32) v43_308 + (ecx_363 + 0x01 & 0x00 ^ dwArg04);
					word32 ecx_384 = DPB(Mem297[ecx_373 + 0x00:word32], (byte) ((~(-esi_192 - 0x01 | ~Mem297[dwArg08 + v43_308:word32]) & 0xFF) + (ecx_363 + 0x01)), 0);
					*(esp_146 - 0x0C) = 0x00;
					*ecx_373 = *(esp_146 - 0x0C);
					*(esp_146 - 0x0C) = (union Eq_2 *) ecx_373;
					*ecx_373 = (byte) fn004013B2() + ((word32) (*ecx_373) + -ecx_384);
					*ecx_373 = (*ecx_373 ^ ~0x00) + 0x01;
					int32 esi_413 = dwLoc08_225 + 0x01;
					eax_262 = ecx_373;
					ecx_266 = esp_146 - 0x08;
					dwLoc08_225 = esi_413;
					if (esi_413 == 0x00)
						dwLoc08_225 = esi_413 & 0x00;
					if (dwLoc08_225 != 0x07C0)
						goto l004012AA;
				}
				return eax_262;
			}
		}
	}
}

// 00401348: void fn00401348(Register ptr32 ebp)
void fn00401348(ptr32 ebp)
{
	if (true)
	{
		fn00401000();
		return;
	}
	else
	{
		fn00401353(ebp);
		return;
	}
}

// 00401353: void fn00401353(Register ptr32 ebp)
void fn00401353(ptr32 ebp)
{
	if (true)
	{
		fn00401000();
		return;
	}
	else
	{
		word32 eax_28 = *(ebp - 0x08) + -~0x152F;
		*(ebp - 0x14) = *(ebp - 0x14) & 0x00;
		*(ebp - 0x14) = *(ebp - 0x14) + eax_28;
		*(ebp - 0x08) = -*(ebp - 0x08);
		return;
	}
}

// 004013B2: FlagGroup bool fn004013B2()
bool fn004013B2()
{
	return false;
}

