// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * ebp_15 = null;
	Eq_2 eax_22 = AddUsersToEncryptedFile(null, null);
	if (eax_22 != 0x00)
	{
		VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x1C);
		struct Eq_37 * eax_47 = null;
		do
		{
			if (ebp_15 == null)
				ebp_15 = null;
			eax_47[4199880] = (struct Eq_37) (ebp_15[0x00404000] ^ eax_47[4199880] ^ 202);
			eax_47 = eax_47 + 0x01;
			ebp_15 = ebp_15 + 0x01;
		} while (eax_47 < (struct Eq_37 *) 0x1440);
		uint32 ecx_230 = 0x00;
		struct Eq_62 * edi_234 = &globals->t4028C8;
		uint32 dwLoc24_228 = 0x00;
		if (true)
		{
			do
			{
				Eq_80 eax_236 = edi_234->t0004;
				cui16 * esi_243 = (char *) &edi_234->t0004 + 0x04;
				if (eax_236 - 0x08 >> 0x01 > 0x00)
				{
					uint32 dwLoc28_258 = eax_236 - 0x08 >> 0x01;
					do
					{
						if ((*esi_243 & 0xF000) == 0x3000)
						{
							struct Eq_196 * eax_285 = ((word32) *esi_243 & 0x0FFF) + edi_234->dw0000;
							eax_285->dw401348 = eax_285->dw401348 + 0xF0401348;
						}
						uint32 v20_275 = dwLoc28_258 - 0x01;
						esi_243 = esi_243 + 0x01;
						dwLoc28_258 = v20_275;
					} while (v20_275 != 0x00);
					ecx_230 = dwLoc24_228;
				}
				ecx_230 = (word32) edi_234->t0004 + ecx_230;
				dwLoc24_228 = ecx_230;
				edi_234 = edi_234 + Mem71[edi_234 + 0x04:word32];
			} while (ecx_230 < ~0x00);
		}
		struct Eq_67 * esp_98 = fp - 0x40;
		struct Eq_70 * esi_101 = &globals->t4020B4;
		esi_127 = esi_101;
		esp_129 = esp_98;
		if (globals->dw4020C4 != 0x00)
		{
			do
			{
				struct Eq_70 * esi_127;
				struct Eq_67 * esp_129;
				esp_129 = esp_129 - 0x04;
				esp_129->dw0000 = esi_127->dw000C + 0x00401348;
				Eq_143 eax_135 = LoadLibraryA(esp_129->dw0000);
				if (eax_135 != null)
				{
					struct Eq_163 * edi_155 = esi_127->dw0000;
					if (edi_155 == null)
						edi_155 = esi_127->dw0010;
					Eq_169 eax_161 = edi_155->t401348;
					union Eq_173 * edi_162 = &edi_155->t401348;
					word32 * esi_163 = esi_127->dw0010 + 0x00401348;
					bool S_166 = cond(eax_161);
					if (eax_161 != 0x00)
					{
						do
						{
							Eq_226 eax_199;
							if (!S_166)
							{
								LPCSTR * esp_212 = esp_129 - 0x04;
								*esp_212 = (LPCSTR *) (word32) *edi_162;
								*(esp_212 - 0x04) = (HMODULE *) eax_135;
								eax_199 = GetProcAddress(*(esp_212 - 0x04), *esp_212);
							}
							else
							{
								LPCSTR * esp_221 = esp_129 - 0x04;
								*esp_221 = (word32) eax_161 + 4199242;
								*(esp_221 - 0x04) = (HMODULE *) eax_135;
								eax_199 = GetProcAddress(*(esp_221 - 0x04), *esp_221);
							}
							*esi_163 = (word32) eax_199;
							edi_162 = (union Eq_173 *) ((char *) edi_162 + 0x04);
							eax_161 = *edi_162;
							esp_129 = esp_129 - 0x08;
							esi_163 = esi_163 + 0x01;
							S_166 = cond(eax_161);
						} while (eax_161 != 0x00);
					}
					esi_127 = (struct Eq_70 *) esp_129[0x03];
				}
				esi_127 = esi_127 + 0x01;
				esp_129[0x03] = (struct Eq_67) esi_127;
			} while (esi_127->dw0010 != 0x00);
		}
		ptr32 esp_105;
		byte SCZO_106;
		word32 ebx_107;
		word32 ebp_108;
		word32 esi_109;
		word32 edi_110;
		byte SZO_111;
		byte C_112;
		word32 eax_113;
		byte Z_114;
		word32 edx_115;
		byte cl_116;
		word32 ecx_117;
		byte CZ_118;
		word16 dx_119;
		byte S_120;
		globals->t401DA8();
		*(esp_105 - 0x04) = 0x00;
		ExitProcess(*(esp_105 - 0x04));
	}
	else
		return eax_22;
}

