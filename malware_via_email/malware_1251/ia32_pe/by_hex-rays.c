/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_DWORD __far start(); // weak
// int __usercall sub_409557@<eax>(__int16 a1@<ax>, char _CL@<cl>, int _EBX@<ebx>, __int64 a4@<esi:edi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4093F9; // weak


//----- (00408033) --------------------------------------------------------
#error "40860B: cannot convert to microcode (funcsize=501)"

//----- (00409557) --------------------------------------------------------
int __usercall sub_409557@<eax>(__int16 a1@<ax>, char _CL@<cl>, int _EBX@<ebx>, __int64 a4@<esi:edi>)
{
  int v4; // edx
  unsigned int v6; // ett
  bool v7; // of
  int v9; // edx
  char v10; // cl
  bool v12; // cf
  int v13; // eax
  bool v14; // tt
  int v15; // edx
  __int64 v16; // rdi
  int v17; // eax
  int v22; // eax
  int v23; // ecx
  bool v24; // cf
  int v25; // eax
  int v26; // edx
  char v28; // of
  char *v29; // eax
  int v30; // ecx
  unsigned int v31; // ecx
  int v32; // edx
  bool v33; // cf
  _DWORD *v35; // ecx
  int v45; // [esp-14h] [ebp-14h]
  int v46; // [esp-10h] [ebp-10h]

  __asm { rcl     ebx, 0Bh }
  _DX = (__int16)(a1 ^ 0xDF9D) >> _CL;
  __asm { rcl     al, cl }
  v35 = (_DWORD *)&loc_4093F9;
  for ( _EAX = 1; _EAX; _EAX = (unsigned __int8)BYTE1(*v35) + (unsigned __int8)*v35 + HIWORD(*v35) - 311 )
  {
    v35 = (_DWORD *)(((unsigned int)v35 - 1) >> 15 << 15);
    if ( !__SETP__(v35, 0) && __SETP__(v35, 0) )
    {
      __asm { aas }
      v35 = _EAX;
    }
  }
  v29 = (char *)v35 + v35[15];
  v46 = *((_DWORD *)v29 + 20);
  v17 = (*(int (__cdecl **)(_DWORD *))((char *)v35 + *(_DWORD *)((char *)v35 + *((_DWORD *)v29 + 32) + 16)))(v35);
  _CL = v45;
  LODWORD(a4) = v46;
  __asm { rcr     dl, cl }
  LOWORD(v17) = WORD2(a4) & v17;
  BYTE1(v17) += 109;
  LOWORD(v17) = _EDX | v17;
  LOBYTE(_EDX) = _EDX - 31;
  LOBYTE(v17) = ~(_BYTE)v17;
  _ECX = v45 + 1049056166;
  v16 = a4 - 0x62C88418FFFFFA06i64;
  HIDWORD(v16) |= _EDX;
  _EAX = __ROL4__(v17, v45 - 90);
  __asm { rcr     ecx, 6 }
  BYTE1(_EAX) = -BYTE1(_EAX);
  BYTE1(_EDX) = 0;
  __asm { rcl     eax, 1Ch }
  v26 = __ROR4__(_EDX, 8);
  BYTE1(v26) = __ROR1__(BYTE1(v26), _ECX);
  BYTE1(_ECX) = __ROL1__(BYTE1(_ECX), 26);
  LODWORD(v16) = v16 - 1530;
  if ( !v28 && v28 )
  {
    __debugbreak();
    JUMPOUT(0x40932E);
  }
  v12 = __CFADD__(__CFSHR__(_ECX, 3), (_BYTE)v26);
  LOBYTE(v26) = __CFSHR__(_ECX, 3) + v26;
  v12 |= __CFADD__((_BYTE)v26, -109);
  LOBYTE(v26) = v26 - 109;
  BYTE1(_ECX) |= BYTE1(v26) - (v12 + 96);
  BYTE1(_EAX) &= _EAX;
  WORD2(v16) += _EAX;
  LOBYTE(_EAX) = -(char)_EAX;
  _EAX = _EAX - (((_BYTE)_EAX != 0) - 1389617113);
  _ECX = _ECX + 957827790;
  BYTE1(v26) = 0;
  v15 = ~v26;
  --WORD2(v16);
  LOWORD(v15) = __ROL2__(v15, _ECX);
  _EBX = 2837;
  v12 = __CFADD__(__CFSHL__(-BYTE1(_ECX), 24), BYTE1(v15));
  BYTE1(v15) += __CFSHL__(-BYTE1(_ECX), 24);
  v12 |= __CFADD__((_BYTE)_EAX, BYTE1(v15));
  BYTE1(v15) += _EAX;
  __asm { rcl     al, cl }
  LOBYTE(v15) = _EAX;
  v9 = v16 + v12 + v15;
  LOBYTE(_EAX) = __ROL1__(_EAX, 7);
  BYTE1(_EAX) = __ROL1__(__ROL1__(BYTE1(_EAX), _ECX), _ECX) - 120;
  LOWORD(_EAX) = v9 & _EAX;
  LOWORD(_ECX) = 186;
  do
  {
    BYTE1(v9) |= 0xEDu;
    LOBYTE(_ECX) = (unsigned __int8)_ECX >> _ECX;
    v32 = __CFSHR__(_EAX, _ECX) + v9 - 380697363;
    LOBYTE(_EAX) = ((unsigned __int8)_EAX >> _ECX) & 0x15;
    _ECX = _ECX - 1;
    v33 = __CFSHR__(_ECX, 15);
    LOBYTE(_ECX) = (char)_ECX >> 7;
    if ( !v33 && v33 )
    {
      *(_BYTE *)v16 = _EAX;
      JUMPOUT(0x4093EF);
    }
    __asm { rcr     ecx, cl }
    BYTE1(v32) -= v32;
    __asm { rcl     cl, 8 }
    v4 = -v32;
    v12 = __CFADD__(v4 != 0, BYTE1(_EAX));
    BYTE1(_EAX) += v4 != 0;
    v12 |= __CFADD__(BYTE1(_EAX), 11);
    BYTE1(_EAX) += 11;
    v6 = v12 + HIDWORD(v16);
    v12 = _EAX < v6;
    _EAX -= v6;
    v7 = __OFADD__(v12, (_BYTE)_ECX);
    LOBYTE(_ECX) = v12 + _ECX;
    v7 |= __OFADD__(-100, (_BYTE)_ECX);
    LOBYTE(_ECX) = _ECX - 100;
    if ( v7 || !v7 )
    {
      LOBYTE(_EAX) = (char)_EAX >> _ECX;
      v25 = __ROR4__(_EAX + 1, 30);
      v30 = _ECX | 0x3A02DA06;
      LOBYTE(v25) = v25 - 1;
      LOBYTE(v30) = 0;
      v31 = (HIDWORD(v16) | 0xD3CC50B6) ^ 0x293FFAF0 | v30;
      v12 = __CFSHL__(BYTE1(v25), 25);
      BYTE1(v25) = 0;
      v23 = ((int)(v31 - 1834167949) >> 23) - (v12 + 1320175461);
      v24 = __CFSHL__(v25, v23);
      LOBYTE(v25) = (_BYTE)v25 << v23;
      if ( v23 < 0 == v24 && v23 < 0 != v24 )
      {
        *(_DWORD *)v16 = v25;
        JUMPOUT(0x4092FB);
      }
      JUMPOUT(0x409531);
    }
    if ( !(((_ECX & 0x80u) != 0) ^ v7 | ((_BYTE)_ECX == 0)) )
      JUMPOUT(0x409113);
    if ( ((_ECX & 0x80u) != 0) != v7 )
      JUMPOUT(0x40912E);
    LOBYTE(v4) = *(_BYTE *)v16;
    v9 = v4 + 1;
  }
  while ( HIDWORD(v16) != -1181848484 );
  v10 = _ECX ^ 0x5C;
  LOBYTE(_EBX) = 21 << v10;
  LOWORD(_EAX) = (_DWORD)v16 << v10;
  v13 = __ROR4__(_EAX, 28);
  v14 = __CFSHL__(v13, 25);
  LOBYTE(v13) = __ROL1__(v13, 25);
  v12 = v14;
  if ( !v14 && v12 )
    JUMPOUT(0x409132);
  __asm { rcr     ebx, 19h }
  v22 = v13 << 11;
  BYTE1(v22) = __ROR1__(SBYTE1(v22) >> v10, 21);
  return __ROL4__(v22 + 1, 26);
}
// 40912C: control flows out of bounds to 409132
// 4091D6: control flows out of bounds to 4091D8
// 40927D: control flows out of bounds to 40927E
// 4092F9: control flows out of bounds to 4092FB
// 40932D: control flows out of bounds to 40932E
// 4093ED: control flows out of bounds to 4093EF
// 409467: control flows out of bounds to 409469
// 409494: control flows out of bounds to 409495
// 409243: control flows out of bounds to 4094BD
// 4090F9: control flows out of bounds to 409113
// 4090FB: control flows out of bounds to 40912E
// 4092E9: control flows out of bounds to 409531
// 40951F: control flows out of bounds to 409397
// 409226: conditional instruction was optimized away because of 'eax.4!=0'
// 40938E: conditional instruction was optimized away because of 'ecx.4>=0'
// 40931E: variable 'v28' is possibly undefined
// 4091E0: variable 'v45' is possibly undefined
// 40946F: variable '_EDX' is possibly undefined

// nfuncs=2 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 2 function(s)"
