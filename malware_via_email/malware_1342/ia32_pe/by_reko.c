// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__CreatePropertySheetPageA = &g_t9144; // 00401000
<anonymous> * __imp__CreateStatusWindowW = &g_t9160; // 00401004
<anonymous> * __imp__PropertySheetA = &g_t9176; // 00401008
<anonymous> * __imp__ImageList_AddMasked = &g_t9188; // 0040100C
<anonymous> * __imp__GetCurrentThreadId = &g_t91AC; // 00401014
<anonymous> * __imp__FormatMessageA = &g_t91C2; // 00401018
<anonymous> * __imp__GetCurrentProcessId = &g_t91D4; // 0040101C
<anonymous> * __imp__CreateWaitableTimerW = &g_t91EA; // 00401020
<anonymous> * __imp__InterlockedExchangeAdd = &g_t9202; // 00401024
<anonymous> * __imp__GetComputerNameW = &g_t921C; // 00401028
<anonymous> * __imp__ExitProcess = &g_t9230; // 0040102C
<anonymous> * __imp__TerminateThread = &g_t923E; // 00401030
<anonymous> * __imp__LockFile = &g_t9250; // 00401034
<anonymous> * __imp__SetLocalTime = &g_t925C; // 00401038
<anonymous> * __imp__TransactNamedPipe = &g_t926C; // 0040103C
<anonymous> * __imp__InterlockedExchange = &g_t9280; // 00401040
<anonymous> * __imp__memset = &g_t92A4; // 00401048
<anonymous> * __imp___stricmp = &g_t92AE; // 0040104C
<anonymous> * __imp__SetDIBits = &g_t92C4; // 00401054
<anonymous> * __imp__GetClipBox = &g_t92D0; // 00401058
<anonymous> * __imp__CreateHatchBrush = &g_t92DE; // 0040105C
<anonymous> * __imp__CreateHalftonePalette = &g_t92F2; // 00401060
<anonymous> * __imp__CreateDCW = &g_t930A; // 00401064
<anonymous> * __imp__RestoreDC = &g_t9316; // 00401068
<anonymous> * __imp__PathMakePrettyW = &g_t932C; // 00401070
<anonymous> * __imp__StrSpnA = &g_t933E; // 00401074
<anonymous> * __imp__SystemParametersInfoW = &g_t9354; // 0040107C
<anonymous> * __imp__DestroyCaret = &g_t936C; // 00401080
<anonymous> * __imp__SetWindowRgn = &g_t937C; // 00401084
<anonymous> * __imp__DefWindowProcA = &g_t938C; // 00401088
<anonymous> * __imp__DestroyCursor = &g_t939E; // 0040108C
<anonymous> * __imp__SetScrollRange = &g_t93AE; // 00401090
<anonymous> * __imp__DialogBoxIndirectParamA = &g_t93C0; // 00401094
<anonymous> * __imp__SendDlgItemMessageA = &g_t93DA; // 00401098
<anonymous> * __imp__SendMessageA = &g_t93F0; // 0040109C
<anonymous> * __imp__GetMessageExtraInfo = &g_t9400; // 004010A0
<anonymous> * __imp__SetMenuDefaultItem = &g_t9416; // 004010A4
<anonymous> * __imp__SetMenuItemBitmaps = &g_t942C; // 004010A8
<anonymous> * __imp__ShowCursor = &g_t9442; // 004010AC
<anonymous> * __imp__IsMenu = &g_t9450; // 004010B0
// 004038B8: Register (ptr32 uint32) HKrXZROZ_Mf_noYJLG(Stack uint32 dwArg04, Stack real32 rArg08)
uint32 * HKrXZROZ_Mf_noYJLG(uint32 dwArg04, real32 rArg08)
{
	uint32 eax;
	up32 ebx;
	up32 ecx_14 = g_dw40AB76 + g_dw40ABD6 + (word32) (g_dw40AB16 < eax);
	g_dw40AB76 = ecx_14;
	ui32 * edi_17 = g_ptr40AD02;
	*edi_17 |= g_t40ABA2.u0;
	g_dw40AB56 = g_dw40AB56 - *g_ptr40AC6E - (word32) (ebx < ecx_14);
	return (uint32 *) <invalid>;
}

// 00403900: void _riGFEGY_WGXY_qbsOD_(Stack char bArg04)
void _riGFEGY_WGXY_qbsOD_(char bArg04)
{
	Eq_45 edi;
	g_dw40AB9E = g_dw40AB9E + g_t40AB6E.u1 + (word32) (g_t40AAF6.u0 < edi);
	ui32 * ebx_17 = g_ptr40AD52;
	*ebx_17 &= g_dw40AB32;
	word32 * edi_21 = g_ptr40ACC2;
	*edi_21 -= g_dw40AB6A;
}

// 00403940: Register (ptr32 void) JVPFYysga_h(Stack int32 dwArg04, Stack (ptr32 real32) ptrArg08)
void * JVPFYysga_h(int32 dwArg04, real32 * ptrArg08)
{
	g_t40AAF2.u0 = (ui32) (g_t40AAF2.u0 ^ *g_ptr40AD32);
	g_dw40ABBA &= (word32) g_t40ABDA.u0;
	ui32 * ecx_17 = g_ptr40AC7A;
	*ecx_17 |= g_dw40ABDE;
	return (void *) <invalid>;
}

// 00403981: Register uint16 Q_B_GTvmg_bvsmX(Stack uint32 dwArg04)
uint16 Q_B_GTvmg_bvsmX(uint32 dwArg04)
{
	g_dw40AB66 += g_dw40AB72;
	g_t40AB12.u0 = (ui32) (g_t40AB12.u0 ^ *g_ptr40AD02);
	g_t40AB46.u0 = (ui32) ((word32) g_t40AB46.u1 & *g_ptr40ACF2);
	return <invalid>;
}

Eq_254 g_t4039CA = // 004039CA
	{
		<code>,
		0x40A09405,
	};
// 004039FA: Register ui32 fn004039FA(Register Eq_45 edx, Register word32 esi, Register ui32 edi, Stack (ptr32 Eq_144) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn00404EEB
ui32 fn004039FA(Eq_45 edx, word32 esi, ui32 edi, struct Eq_144 * dwArg04, word32 * dwArg08)
{
	ptr32 fp;
	word32 esi;
	ui32 edi;
	Eq_45 edx;
	word32 dwLoc20;
	word32 dwLoc24;
	struct Eq_144 * dwArg04;
	nArg04_368 = (word24) dwArg04;
	word32 dwLoc38;
	word32 dwLoc18;
	word32 dwLoc44;
	byte bLoc48;
	word32 * dwArg08;
	word32 dwLoc3C;
	&dwLoc14_255.u0->bmiHeader.biSize = 0x1B;
	while (true)
	{
		dwLoc14_256 = ϕ(dwLoc14_255, dwLoc14_309);
		esp_28 = fp - 0x5C;
		if (dwLoc14_256 == 0x00)
			break;
		if (dwLoc14_256 == 0x1D)
			CreatePropertySheetPageA((PROPSHEETPAGEA_V4 *) 23155);
		dwLoc14_309 = dwLoc14_256 - 0x01;
	}
	while (true)
	{
		dwLoc14_289 = ϕ(dwLoc14_256, dwLoc14_290);
		edx_191 = ϕ(edx, edx_193);
		esi_183 = ϕ(esi, esi_184);
		edi_179 = ϕ(edi, edi_180);
		esp_162 = ϕ(esp_28, esp_160);
		esp_163 = esp_162 - 4;
		esp_163->t0000.u0 = 0x2454;
		esp_163->tFFFFFFFC.u0 = 33958;
		esp_163->tFFFFFFF8.u0 = (BOOL) dwLoc14_289;
		SetDIBits(esp_163->tFFFFFFF8.u3, esp_163->tFFFFFFFC.u0, esp_163->t0000.u0, esp_163->t0004.u0, esp_163->ptr0008, esp_163->ptr000C, esp_163->t0010.u0);
		esp_172 = (char *) &esp_163->t0010 + 4;
		do
		{
			dwLoc14_334 = ϕ(dwLoc14_289, dwLoc14_290);
			esp_211 = ϕ(esp_172, esp_151);
			edx_190 = ϕ(edx_191, edx_193);
			esi_182 = ϕ(esi_183, esi_184);
			edi_178 = ϕ(edi_179, edi_180);
			Mem173 = ϕ(Mem170, Mem148);
			if (g_dw40AB0E >= 0x1C)
			{
				eax_181 = edi_178 ^ ~0x101E;
				eax_185 = eax_181 + esi_182;
				g_dw40A104 = eax_185;
				eax_188 = ~0x101D;
				esi_216 = ϕ(esi_182, esi_45);
				edi_206 = ϕ(edi_178, edi_39);
				eax_205 = ϕ(eax_188, eax_70);
				Mem197 = ϕ(Mem187, Mem69);
				edx_189 = ϕ(edx_190, edx);
				v31_200 = g_dw40AB72 - 4238242 - (word32) (edx_189 < g_t40AAF6.u0);
				g_dw40AB72 = v31_200;
				v32_202 = g_dw40AB72 ^ 0x0040AB12;
				g_dw40AB72 = v32_202;
				eax_209 = eax_205 ^ edi_206;
				eax_219 = eax_209 + esi_216;
				return eax_219;
			}
			dwLoc14_290 = ϕ(dwLoc14_274, dwLoc14_334);
			edx_193 = ϕ(edx_194, edx_190);
			esi_184 = ϕ(esi_45, esi_182);
			edi_180 = ϕ(edi_39, edi_178);
			esp_151 = ϕ(esp_246, esp_211);
			Mem145 = ϕ(Mem141, Mem173);
			eax_146 = g_dw40AB0E;
			g_dw40AB0E = eax_146 + 0x01;
		} while (g_dw40AB0E != 0x2A);
		esp_152 = esp_151 - 4;
		esp_152->dw0000 = 0x2920;
		esp_152->dwFFFFFFFC = 0x3A69;
		esp_152->dwFFFFFFF8 = 0x72870000;
		esp_160 = esp_152 - 0x0C;
		esp_152->dwFFFFFFF4 = 0x75A5;
	}
}

// 00403C31: Register word32 fn00403C31(Stack (ptr32 word32) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Register out (ptr32 ui32) edxOut)
// Called from:
//      fn00404D4D
word32 fn00403C31(word32 * dwArg04, word32 dwArg08, word32 dwArg0C, ui32 & edxOut)
{
	Eq_413 dwLoc2C;
	g_dw40AB42 = 22;
	Eq_148 eax_105 = ~0x101E;
	while (g_dw40AB42 != 0x00)
	{
		if (g_dw40AB42 == 0x26)
			eax_105 = SystemParametersInfoW(23276, 6300, dwLoc2C, 30379);
		--g_dw40AB42;
	}
	do
	{
		int32 * edx_51 = *((char *) g_a40A0D4 + ((word32) eax_105 + 1 & 0x03) * 0x04);
		int32 edi_53 = *edx_51 *s eax_105;
		g_dw40ABBA += 0x0040AB0E;
		g_dw40ABBA = g_dw40ABBA ^ 4238118;
		g_dw40ABBA += 0x0040AAFA;
		*edx_51 = edi_53 *s ~0x201B;
		g_t40ABA2.u0 = (ui32) (g_t40ABA2.u0 & 0x0040AB5E);
		g_t40ABA2.u0 = (ui32) (g_t40ABA2.u0 + 4238230);
		g_t40ABA2.u0 = (ui32) (g_t40ABA2.u0 + 0x0040AB22);
		ui32 * edx_75 = *((char *) g_a40A0D4 + (eax_105 - 1 & 0x03) * 0x04);
		*edx_75 = *edx_75 ^ (eax_105 *s ~0x201C | eax_105);
		g_ptr40A304 = dwArg04;
		switch (eax_105)
		{
		case ~0x11DE:
			g_dw40A308 = dwArg08;
			break;
		case ~0x119E:
			g_dw40A30C = dwArg0C;
			break;
		}
		g_dw40AB56 += 0x2272;
		ui32 eax_101 = eax_105 ^ 0x3530;
		word32 * edx_117 = *((char *) g_a40A0D4 + ((eax_101 + 0x01 ^ 0x3530) & 0x03) * 0x04);
		*edx_117 += (eax_101 + 0x01 ^ 0x3530) *s ~0x201D ^ (eax_101 + 0x01 ^ 0x3530);
		ui32 * edx_125 = *((char *) g_a40A0D4 + ((eax_101 + 0x01 ^ 0x3530) - 2 & 0x03) * 0x04);
		*edx_125 |= (eax_101 + 0x01 ^ 0x3530) *s ~0x201A;
		eax_105 = eax_101 + 0x01 ^ 0x3530;
	} while ((eax_101 + 0x01 ^ 0x3530) != ~0x112E);
	edxOut = edx_125;
	return 0x3530;
}

// 00403E03: void fn00403E03(Register (ptr32 Eq_572) eax)
// Called from:
//      Win32CrtStartup
void fn00403E03(struct Eq_572 * eax)
{
	g_dw40A554 = (char *) eax + 4;
	g_t40A548.u0 = eax->t0008.u0;
	g_dw40A54C = eax->dw000C;
	g_t40A550.u0 = eax->t0010.u0;
}

// 00403E27: Register Eq_579 fn00403E27(Register (ptr32 Eq_593) ebp, Register (ptr32 Eq_579) esi, Register Eq_579 edi, Register out ptr32 ebxOut)
// Called from:
//      Win32CrtStartup
Eq_579 fn00403E27(struct Eq_593 * ebp, union Eq_579 * esi, Eq_579 edi, ptr32 & ebxOut)
{
	ptr32 ebx;
	Eq_579 ecx;
	esi->u0 = 0x01;
	InterlockedExchange(&g_t40A2EC, 0x00760677);
	while (esi->u0 != edi)
	{
		ecx.u0 = esi->u0;
		if (ecx < edi)
		{
			if (ecx == 0x00)
				goto l00403EDA;
			g_dw40AB22 = 0x00;
			do
			{
				++g_dw40AB22;
				if (g_dw40AB22 == 0x24)
				{
					COMCTL32.dll!CreateStatusWindowW(0x4558, 0x0040AF0F, 6888, ebp->dwFFFFFFF4);
					ecx = ecx_66;
				}
			} while (g_dw40AB22 < 0x1E);
			esi->u0 = (word32) ecx + ((uint32) ((uint64) edi /u 0x0101) + 1);
		}
		else if (ecx == 0x00)
		{
l00403EDA:
			esi->u0 = (uint32) edi;
		}
		else
		{
			esi->u0 = (uint32) (ecx - 0x01);
			--ecx;
		}
	}
	ebxOut = ebx;
	return ecx;
}

// 00403EEE: Register word32 fn00403EEE(Register out ptr32 ecxOut)
// Called from:
//      fn004047C6
word32 fn00403EEE(ptr32 & ecxOut)
{
	g_dw40AB0A = 0x00;
	while (g_dw40AB0A < 0x14)
	{
		if (g_dw40AB0A == 0x18)
			DestroyCaret();
		++g_dw40AB0A;
	}
}

// 00404004: void fn00404004()
// Called from:
//      fn004047C6
void fn00404004()
{
	Eq_148 dwLoc1C;
	Eq_148 dwLoc2C;
	word32 dwLoc3C;
	word32 dwLoc20;
	word32 dwLoc18;
	byte bLoc44;
	word32 dwLoc38;
	Eq_184 dwLoc24;
	word16 wLoc1C = (word16) dwLoc1C;
	word16 wLoc1A = SLICE(dwLoc1C, word16, 16);
	g_dw40ABD2 = 0x00;
	while (g_dw40ABD2 < 0x19)
	{
		if (g_dw40ABD2 == 0x23)
			FormatMessageA(0x48BC, dwLoc24, 0x2D2B, dwLoc2C, 0x0040ABA6, dwLoc1C, dwLoc1C);
		++g_dw40ABD2;
	}
	g_dw40ABBE -= 4238242;
	g_dw40ABBE = g_dw40ABBE ^ 4238238;
	g_dw40ABBE -= 0x0040AAF2;
	struct Eq_144 * edx_56 = g_ptr40A2D8;
	ui32 v23_69 = dwLoc18 ^ *g_ptr40AD12;
	Mem103 = Mem86;
	ui32 * eax_105 = edx_56->ptr000C;
	ui32 v27_106 = *eax_105;
	<anonymous> * v28_110 = g_ptr40A584;
	g_t40AB12.u0 = (ui32) 0x0040AB8A;
	g_t40AB12.u0 = (ui32) (g_t40AB12.u0 & 4238262);
	g_t40AB12.u0 = (ui32) (g_t40AB12.u0 - 4238286);
	g_ptr40A580();
}

// 0040419E: Register (ptr32 word16) fn0040419E()
// Called from:
//      fn00404AB9
word16 * fn0040419E()
{
	ui32 dwLoc44;
	g_dw40AB86 = 0x1C;
	while (g_dw40AB86 != 0x00)
	{
		if (g_dw40AB86 == 0x1E)
			GetClipBox(0x30CE, &g_dw40AB56);
		--g_dw40AB86;
	}
	byte * edx_47 = g_ptr40ACE6;
	*edx_47 += 99;
	g_dw40AB8E &= dwLoc44;
	ui32 *** eax_72 = g_ptr40A040;
	word16 * eax_104 = ***eax_72 & 0xFFFF0000;
	g_t40AAF6.u0 = (uint32) 0x0040AB1A;
	g_t40AAF6.u0 = (uint32) (g_t40AAF6.u0 & 0x0040ABD2);
	word16 * dwLoc10_214 = eax_104;
	word16 ax_126 = *eax_104 - 0x022F;
	while ((ax_126 ^ 0x0330) != 23342)
	{
		g_t40AB46.u0 = (ui32) ((word32) g_t40AB46.u2 - 0x15D5);
		word16 * v31_139 = dwLoc10_214 - 0x00010000;
		dwLoc10_214 = v31_139;
		ax_126 = *v31_139 - 0x022F;
	}
	return dwLoc10_214;
}

// 00404365: FlagGroup bool fn00404365(Stack (ptr32 Eq_863) dwArg04, Stack (ptr32 Eq_864) dwArg08, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00405060
bool fn00404365(struct Eq_863 * dwArg04, struct Eq_864 * dwArg08, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_868 fp;
	word32 dwLocD8;
	ui32 dwLoc90;
	byte bLocB4;
	word32 dwLoc74;
	Eq_873 dwLoc28;
	Eq_874 eax_10 = dwArg04->t40A49C;
	up32 dwLoc58_438;
	for (dwLoc58_438 = 0x00; dwLoc58_438 < 0x12; ++dwLoc58_438)
	{
		if (dwLoc58_438 == 0x1E)
			eax_10 = PropertySheetA(dwLoc28);
	}
	ui32 * edx_77 = g_ptr40AD56;
	*edx_77 = *edx_77 ^ 0x1116;
	g_a40A340[((eax_10 ^ 0x3530) + 0x252F) * 0x02] = 0x00;
	word32 * eax_88 = g_ptr40AD16;
	*eax_88 += dwLocD8;
	byte * ebx_97 = g_ptr40AD1A;
	*ebx_97 += 118;
	g_dw40AB4E &= dwLoc90;
	g_dw40AB52 = g_dw40AB52 + 0x0040AB0A + (word32) (g_dw40AB2E > 0x3530);
	g_dw40AB52 &= 4238202;
	g_dw40AAEE |= (word32) bLocB4;
	g_dw40AB3A = g_dw40AB3A ^ dwLoc74;
	g_dw40AB6A = 0x00;
	ptr32 esp_249 = fp - 0x01FC;
	while (g_dw40AB6A < 0x11)
	{
		if (g_dw40AB6A == 0x18)
		{
			COMCTL32.dll!ImageList_AddMasked(314971077, ~0x0116011E, ~0x011702E7);
			esp_249 = esp_392;
		}
		++g_dw40AB6A;
	}
	ui32 * eax_237 = g_ptr40AD62;
	*eax_237 |= 31545;
	struct Eq_988 * esp_250 = esp_249 - 4;
	esp_250->dw0000 = dwArg08->dw40A498;
	esp_250->ptrFFFFFFFC = 0x0040A340;
	esp_250->dwFFFFFFF8 = 0x03;
	esp_250->tFFFFFFF4.u0 = (void *) (fp - 48);
	esp_250->dwFFFFFFF0 = *g_ptr40A2D8->ptr000C;
	esp_250->ptrFFFFFFEC = g_ptr40A584;
	word32 ebx_275;
	word32 edi_667;
	word32 edx_665;
	word32 eax_663;
	word32 esi_666;
	word32 ecx_664;
	fn0040672B(esp_250->ptrFFFFFFEC, esp_250->dwFFFFFFF0, esp_250->tFFFFFFF4.u0, esp_250->dwFFFFFFF8, out eax_663, out ecx_664, out edx_665, out ebx_275, out esi_666, out edi_667);
	esp_250->dwFFFFFFE8 = ebx_275;
	esp_250->dwFFFFFFE4 = 0x01;
	esp_250->tFFFFFFE0.u0 = (void *) (fp - 84);
	if (fp <= 0x686E)
		g_dw40ABB6 = g_dw40ABB6 - (word32) g_t40ABA2.u1 - (word32) (fp < 0x686E);
	byte * eax_306 = g_ptr40AC6A;
	*eax_306 |= 0x19;
	esp_250->dwFFFFFFDC = *g_ptr40A2D8->ptr000C;
	esp_250->ptrFFFFFFD8 = g_ptr40A584;
	ui32 eax_321;
	word32 esi_323;
	word32 edi_325;
	word32 edx_669;
	word32 ebx_670;
	word32 ecx_668;
	bool P_331 = fn0040672B(esp_250->ptrFFFFFFD8, esp_250->dwFFFFFFDC, esp_250->tFFFFFFE0.u0, esp_250->dwFFFFFFE4, out eax_321, out ecx_668, out edx_669, out ebx_670, out esi_323, out edi_325);
	g_t40ABDA.u1 = 4238238;
	g_t40ABDA.u1 = (ptr32) (g_t40ABDA.u1 + 0x0040AB66 + (word32) (g_ptr40AB4A < dwArg08));
	if (eax_321 != ((dwArg08->dw40A49C ^ esi_323) + 0x4A5E) + (dwArg04->t40A49C ^ esi_323))
	{
		*g_ptr40A4D8 = (esi_323 ^ ~0x101E) + edi_325;
		*g_ptr40A2D8->ptr000C = (esi_323 ^ ~0x101E) + edi_325;
	}
	ptr32 edi_371 = esp_250->ptr0004;
	ptr32 esi_373 = esp_250->ptr0008;
	ebxOut = esp_250->ptr000C;
	esiOut = esi_373;
	ediOut = edi_371;
	return P_331;
}

// 004047C6: Register Eq_148 fn004047C6()
// Called from:
//      fn00405435
Eq_148 fn004047C6()
{
	word32 dwLoc84;
	Eq_1195 dwLoc14;
	int32 dwLoc2C;
	g_t40ABDA.u1 = (ptr32) 0x00;
	do
	{
		g_t40ABDA.u1 = (ptr32) (g_t40ABDA.u1 + 0x01);
		if (g_t40ABDA.u1 == 0x23)
			CreateHatchBrush(dwLoc2C, dwLoc14);
	} while (g_t40ABDA.u1 < 0x1D);
	byte * edi_77 = g_ptr40ACCE;
	*edi_77 |= 0x53;
	Eq_148 ecx_110;
	if (fn00403EEE(out ecx_110) == 0x00)
		return ecx_110;
	fn00404004();
	&ecx_110.u0->bmiHeader.biSize = g_t40A2F4.u0;
	g_dw40AB42 -= dwLoc84;
	if (ecx_110 == 0x00)
		return ecx_110;
	up32 dwLoc44_393 = 0x00;
	do
	{
		dwLoc44_393 = dwLoc44_544 + 0x01;
		if (dwLoc44_393 == 22)
			SetWindowRgn(0x3B44, (struct HRGN__ *) 0x7CDD, ecx_110);
		dwLoc44_544 = dwLoc44_393;
	} while (dwLoc44_544 < 0x0F);
	g_dw40AB1A |= 0x0040AB16;
}

// 00404AB9: FlagGroup bool fn00404AB9(Register up32 ecx, Register Eq_1266 edi, Register out ptr32 edxOut, Register out ptr32 ediOut)
// Called from:
//      fn00405060
bool fn00404AB9(up32 ecx, Eq_1266 edi, ptr32 & edxOut, ptr32 & ediOut)
{
	int32 dwLoc54;
	up32 dwLoc4C;
	ui32 dwLoc38;
	Eq_148 dwLoc20;
	struct Eq_1273 * edx_13 = (struct Eq_1273 *) 0x05;
	while (g_dw40A090 == 0x00)
	{
		g_dw40ABCE = 0x00;
		while (g_dw40ABCE < 0x12)
		{
			if (g_dw40ABCE == 0x14)
				CreateHalftonePalette(dwLoc20);
			++g_dw40ABCE;
		}
		edx_13[0x0040A4D7] = (struct Eq_1273) ((edx_13[0x0040A4D7] ^ 0x60) + 0x32);
		++edx_13;
		if (edx_13 >= (struct Eq_1273 *) 0x14)
			break;
	}
	if (*g_ptr40A2D8->ptr000C == 0x00)
		fn0040419E();
	ui16 ax_110 = g_w40A4BC ^ 0x0330;
	g_dw40AB6A += *g_ptr40AC82;
	if (!OVERFLOW<word32>(dwLoc4C - 0x1EA6))
		g_dw40AB9E = g_ptr40AB4A + g_dw40AB9E / 0x0040A4A0 + (word32) (dwLoc4C < 0x1EA6) / 0x0040A4A0;
	else
	{
		byte * esi_125 = g_ptr40ACBA;
		*esi_125 |= 0x7B;
	}
	g_dw40ABA6 &= dwLoc38;
	g_w40A4C4 = ax_110 + 0x022F;
}

// 00404C90: Register Eq_1367 fn00404C90(Register (ptr32 Eq_1368) ebp, Register (ptr32 uint32) esi, Register uint32 edi)
// Called from:
//      Win32CrtStartup
Eq_1367 fn00404C90(struct Eq_1368 * ebp, uint32 * esi, uint32 edi)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				uint32 ecx_16 = *esi;
				if (ecx_16 > edi)
					*esi = ecx_16 - 0x01;
				else if (ecx_16 == 0x00)
					*esi = edi;
				else
				{
					g_dw40ABBA = 0x11;
					while (g_dw40ABBA != 0x00)
					{
						if (g_dw40ABBA == 0x19)
							DefWindowProcA(ebp->tFFFFFFEC.u0, ebp->tFFFFFFE8.u0, ebp->tFFFFFFF4, 0x6CA2);
						--g_dw40ABBA;
					}
					uint8 * ebx_30 = g_ptr40ACA6;
					*ebx_30 >>= 0x01;
					*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_16;
				}
			} while (*esi != edi);
		}
		LONG eax_83 = InterlockedExchangeAdd(&g_t40A2EC, 0x00760677);
	} while ((word32) eax_83 + 0x00760677 != g_t40A2EC);
	return (word32) eax_83 + 0x00760677;
}

// 00404D4D: Register word32 fn00404D4D(Register ptr32 ebx, Register word32 esi, Register ui32 edi, Stack word32 dwArg00, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out Eq_1467 ediOut)
// Called from:
//      fn00405F2F
word32 fn00404D4D(ptr32 ebx, word32 esi, ui32 edi, word32 dwArg00, ptr32 & ebxOut, ptr32 & esiOut, union Eq_1467 & ediOut)
{
	word32 * fp;
	Eq_1469 dwLoc28;
	up32 dwLoc1C_190;
	for (dwLoc1C_190 = 0x00; dwLoc1C_190 < 0x1E; ++dwLoc1C_190)
	{
		if (dwLoc1C_190 == 0x26)
			CreateWaitableTimerW(dwLoc28, 0x00, &g_t40AEBC);
	}
	word32 dwLoc08_201;
	g_dw40A0EC = g_dw40A318;
	g_dw40A0F0 = g_dw40A31C;
	g_dw40A0F4 = g_dw40A320;
	Eq_45 edx_73;
	ptr32 ebx_82;
	Eq_1467 edi_84;
	ptr32 esi_86;
	if (fn00404EEB(fn00403C31(fp - 8, *g_ptr40A314, g_dw40A2FC, out edx_73), edx_73, ebx, esi, edi, out ebx_82, out esi_86, out edi_84) != 0x00)
	{
		g_dw40A098 += 0x00677577;
		dwLoc08_201 = 0x00;
	}
	else
	{
		Mem108 = Mem96;
		struct Eq_144 * eax_109 = g_ptr40A2D8;
		g_t40AAF2.u0 = (ui32) ((word32) g_t40AAF2.u1 - 0x01);
		word32 eax_115 = *eax_109->ptr003C;
		g_dw40ABDE = ~g_dw40ABDE;
		dwLoc08_201 = eax_115;
	}
	g_ptr40A2F8 = fp;
	*g_ptr40A2F8 = dwArg00 + g_t40A100.u0;
	ebxOut = ebx_82;
	esiOut = esi_86;
	ediOut = edi_84;
	return dwLoc08_201;
}

// 00404EEB: Register word32 fn00404EEB(Register word32 ecx, Register Eq_45 edx, Register ptr32 ebx, Register word32 esi, Register ui32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404D4D
word32 fn00404EEB(word32 ecx, Eq_45 edx, ptr32 ebx, word32 esi, ui32 edi, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 * eax_9 = g_ptr40A304;
	g_dw40AB42 = 0x00;
	do
	{
		++g_dw40AB42;
		if (g_dw40AB42 == 0x20)
			CreateDCW(&g_t40AEAC, &g_t40AE94, &g_t40AE85, (DEVMODEW *) 0x1DDC);
	} while (g_dw40AB42 < 0x17);
	fn004039FA(edx, esi, edi, g_ptr40A2D8, eax_9);
}

// 00405060: Register word32 fn00405060(Register up32 ecx, Register word32 ebx, Register Eq_1266 edi)
// Called from:
//      fn00405F2F
word32 fn00405060(up32 ecx, word32 ebx, Eq_1266 edi)
{
	ptr32 fp;
	word32 ebx;
	Eq_1266 edi;
	up32 ecx;
	word32 dwLoc0C;
	word32 dwLoc10;
	__align_stack<word32>(fp - 4);
	P_33 = fn00404AB9(ecx, edi, out edx_657, out edi_26);
	dwLoc08_540 = 0x00;
	do
	{
		dwLoc08_541 = ϕ(dwLoc08_540, dwLoc08_542);
		esi_42 = dwLoc08_541 + 0x01;
		dwLoc08_542 = dwLoc08_541 + 0x01;
		if (dwLoc08_542 == 0x26)
			DestroyCursor((struct HICON__ *) 20602);
		esp_57 = fp - 0x44;
	} while (dwLoc08_541 < 0x1E);
	dwLoc14_546.u0 = 0x0180;
	dwLoc14_640 = ϕ(dwLoc14_546, dwLoc14_569);
	dwLoc10_601 = ϕ(dwLoc10, dwLoc10_605);
	dwLoc08_594 = ϕ(dwLoc08_542, dwLoc08_595);
	dwLoc0C_582 = ϕ(dwLoc0C, dwLoc0C_587);
	edi_481 = ϕ(edi_26, edi_380);
	esp_478 = ϕ(esp_57, esp_388);
	v45_531 = ϕ(P_33, P_387);
	Mem473 = ϕ(Mem59, Mem376);
	esi_393 = ϕ(esi_42, esi_382);
	ebx_389 = ϕ(ebx, ebx_378);
	ecx_392 = ebx_389 + 1;
	ecx_395 = ecx_392 ^ esi_393;
	while (true)
	{
		dwLoc14_639 = ϕ(dwLoc14_640, dwLoc14_637);
		dwLoc10_554 = ϕ(dwLoc10_601, dwLoc10_607);
		dwLoc08_549 = ϕ(dwLoc08_594, dwLoc08_597);
		dwLoc0C_548 = ϕ(dwLoc0C_582, dwLoc0C_590);
		bLoc0C_551 = (byte) dwLoc0C_548;
		edi_172 = ϕ(edi_481, edi_484);
		esi_167 = ϕ(esi_393, esi_479);
		ecx_161 = ϕ(ecx_395, ecx_119);
		esp_146 = ϕ(esp_478, esp_117);
		v44_530 = ϕ(v45_531, v46_532);
		Mem121 = ϕ(Mem473, Mem118);
		if (!v44_530)
		{
			eax_130 = (word32) g_w40ABC6;
			ebx_131 = (word32) bLoc0C_551;
			ebx_132 = ebx_131 & eax_130;
			dwLoc0C_552 = ebx_132;
		}
		else
		{
			ebx_124 = g_dw40AB9A;
			eax_127 = dwLoc08_549 - ebx_124 - (word32) (dwLoc0C_548 < 0x4FCF);
			dwLoc08_550 = eax_127;
		}
		dwLoc0C_588 = ϕ(dwLoc0C_552, dwLoc0C_548);
		bLoc0C_612 = (byte) dwLoc0C_588;
		dwLoc08_563 = ϕ(dwLoc08_549, dwLoc08_550);
		Mem138 = ϕ(Mem136, Mem129);
		ebx_140 = (word32) g_t40AB6E.u0;
		eax_143 = dwLoc10_554 + ebx_140 + (word32) (eax_127 < 0x00);
		dwLoc10_555 = eax_143;
		eax_147 = esp_146->ptr0020;
		eax_148 = *eax_147;
		esp_149 = esp_146 - 4;
		esp_149->ptr0000 = (char *) 0x61;
		ebx_152 = esp_149->ptr0000;
		esp_153 = (struct Eq_1615 *) ((char *) &esp_149->ptr0000 + 4);
		edx_eax_154 = (uint64) eax_148;
		edx_156 = (uint32) (edx_eax_154 % ebx_152);
		if (edx_156 <= 0x8A && ecx_161 != ~0x102E)
			break;
		do
		{
			dwLoc14_635 = ϕ(dwLoc14_637, dwLoc14_639, dwLoc14_639);
			dwLoc10_609 = ϕ(dwLoc10_607, dwLoc10_555, dwLoc10_555);
			dwLoc08_599 = ϕ(dwLoc08_597, dwLoc08_563, dwLoc08_563);
			dwLoc0C_592 = ϕ(dwLoc0C_590, dwLoc0C_588, dwLoc0C_588);
			esi_523 = ϕ(esi_479, esi_167, esi_167);
			esp_521 = ϕ(esp_117, esp_153, esp_153);
			edi_487 = ϕ(edi_484, edi_172, edi_172);
			g_dw40ABD6 = 0x1F;
			while (true)
			{
				esp_417 = esp_521;
				Mem414 = ϕ(Mem413, Mem469);
				if (g_dw40ABD6 == 0x00)
					break;
				if (g_dw40ABD6 == 0x2B)
				{
					esp_459 = esp_521 - 4;
					esp_459->t0000.u0 = (void *) dwLoc14_635;
					esp_459->tFFFFFFFC = (Eq_1931) &g_t40ABAA;
					GetComputerNameW(esp_459->tFFFFFFFC, esp_459->t0000.u3);
				}
				Mem465 = ϕ(Mem414, Mem462);
				eax_466 = g_dw40ABD6;
				g_dw40ABD6 = eax_466 - 0x01;
			}
			eax_418 = esp_521->dw000C;
			eax_420 = eax_418 ^ esi_523;
			eax_422 = eax_420 + 0x01 ^ esi_523;
			esp_521->dw000C = eax_422;
			if (eax_422 == ~0x11EE)
			{
l0040540C:
				Mem427 = ϕ(Mem72, Mem423);
				esi_437 = g_ptr40ACA2;
				v32_439 = *esi_437 - 20124;
				*esi_437 = v32_439;
				eax_447 = 0x01;
				return eax_447;
			}
			dwLoc14_637 = dwLoc14_635;
			dwLoc10_607 = dwLoc10_609;
			dwLoc08_597 = dwLoc08_599;
			dwLoc0C_590 = dwLoc0C_592;
			edi_485 = edi_487;
			esi_480 = esi_523;
			esp_82 = esp_417;
			Mem72 = Mem423;
			eax_73 = g_dw40A090;
			if (eax_73 != 0x00)
				goto l0040540C;
			eax_78 = g_ptr40A2D8;
			ecx_79 = eax_78->ptr000C;
			if (*ecx_79 != 0x00)
			{
				esp_83 = esp_82 - 4;
				esp_83->dw0000 = 0x0040A524;
				esp_83->dwFFFFFFFC = 0x01;
				esp_83->tFFFFFFF8.u0 = (void *) ((char *) &eax_78->ptr003C + 20);
				v19_91 = *ecx_79;
				esp_83->dwFFFFFFF4 = v19_91;
				v20_94 = g_ptr40A584;
				esp_83->ptrFFFFFFF0 = v20_94;
				fn0040672B(esp_83->ptrFFFFFFF0, esp_83->dwFFFFFFF4, esp_83->tFFFFFFF8.u0, esp_83->dwFFFFFFFC, out eax_97, out ecx_658, out edx_659, out ebx_660, out esi_99, out edi_101);
				g_dw40A4EC = eax_97;
			}
			edi_484 = ϕ(edi_485, edi_101);
			esi_479 = ϕ(esi_480, esi_99);
			esp_117 = esp_82;
			Mem111 = ϕ(Mem72, Mem110);
			eax_112 = g_dw40A4EC;
			v46_532 = !PARITY_EVEN(eax_112);
		} while (eax_112 == 0x00);
		esp_82->dw0014 = 0x00;
		ecx_119 = ~0x101E;
	}
	ecx_165 = esp_149->dw0020;
	ecx_168 = ecx_165 ^ esi_167;
	ebx_169 = ecx_161 ^ esi_167;
	ecx_173 = ecx_168 + edi_172;
	v26_175 = g_dw40ABA6 & 0x0040ABD2;
	g_dw40ABA6 = v26_175;
	v27_179 = g_dw40ABA6 - 0x0040AB6E;
	g_dw40ABA6 = v27_179;
	edx_eax_182 = (uint64) (ebx_169 + 0x252F);
	edx_184 = (uint32) (edx_eax_182 % ecx_173);
	esp_149->ptr0000 = &g_b40A52C;
	esp_188 = esp_149 - 4;
	esp_149->ptrFFFFFFFC = &g_b40A53C;
	esp_149->ptr0014 = edx_184 << 0x03;
	eax_192 = _stricmp(esp_149->ptrFFFFFFFC, esp_149->ptr0000);
	ecx_198 = esp_149->ptr0000;
	if (eax_192 != 0x00)
	{
		eax_204 = esp_149->ptr0014;
		v29_205 = eax_204->ptr40A498;
		esp_149->ptr0000 = v29_205;
		esp_149->ptrFFFFFFFC = (char *) &g_w40A4C4;
		esp_149->dwFFFFFFF8 = 0x0040A340;
		esp_149->dwFFFFFFF4 = 0x03;
		esp_149->tFFFFFFF0.u0 = 0x0040A4F0;
		v30_216 = g_dw40A4EC;
		esp_149->dwFFFFFFEC = v30_216;
		v31_219 = g_ptr40A584;
		esp_149->ptrFFFFFFE8 = v31_219;
		fn0040672B(esp_149->ptrFFFFFFE8, esp_149->dwFFFFFFEC, esp_149->tFFFFFFF0.u0, esp_149->dwFFFFFFF4, out eax_661, out ecx_225, out edx_662, out ebx_663, out esi_224, out edi_226);
	}
	edi_520 = ϕ(edi_172, edi_226);
	esi_518 = ϕ(esi_167, esi_224);
	ecx_500 = ϕ(ecx_198, ecx_225);
	esp_238 = esp_146;
	eax_237 = ~0x11EE;
	esp_146->dw0018 = ~0x24DE;
	dwLoc08_565 = dwLoc08_563;
	bLoc0C_558 = bLoc0C_612;
	ecx_499 = ecx_500;
	edi_337 = edi_520;
	esi_313 = esi_518;
	esp_248 = esp_238;
	Mem245 = Mem239;
	eax_240 = eax_237;
	switch (eax_240)
	{
	case ~0x11C9:
		g_dw40AB82 = 0x00;
		while (true)
		{
			Mem281 = ϕ(Mem277, Mem412);
			if (g_dw40AB82 >= 0x1B)
				break;
			if (g_dw40AB82 == 0x1D)
			{
				esp_402 = esp_248 - 4;
				esp_402->dw0000 = eax_143;
				esp_402->tFFFFFFFC.u0 = 0x3015;
				RestoreDC(esp_402->tFFFFFFFC.u3, esp_402->dw0000);
			}
			Mem408 = ϕ(Mem281, Mem405);
			eax_409 = g_dw40AB82;
			g_dw40AB82 = eax_409 + 0x01;
		}
		eax_284 = g_ptr40A2D8;
		eax_285 = eax_284->ptr000C;
		esp_287 = esp_248 - 4;
		esp_287->dw0000 = 0x0040A638;
		v36_289 = *eax_285;
		esp_287->dwFFFFFFFC = v36_289;
		eax_292 = g_ptr40AC9E;
		eax_293 = *eax_292;
		v37_294 = g_dw40AB2A - eax_293;
		g_dw40AB2A = v37_294;
		eax_297 = esp_287->ptr0018;
		eax_297();
		g_dw40A514 = eax_305;
		break;
	case ~0x11DE:
		eax_246 = g_ptr40A11C;
		eax_247 = *eax_246;
		esp_249 = esp_248 - 4;
		esp_249->dw0000 = 0x0040A4DC;
		esp_249->dwFFFFFFFC = eax_247;
		esp_249->dwFFFFFFF8 = 0x02;
		esp_249->tFFFFFFF4.u0 = 0x0040A1A4;
		esp_249->dwFFFFFFF0 = eax_247;
		v35_259 = g_ptr40A584;
		esp_249->ptrFFFFFFEC = v35_259;
		fn0040672B(esp_249->ptrFFFFFFEC, esp_249->dwFFFFFFF0, esp_249->tFFFFFFF4.u0, esp_249->dwFFFFFFF8, out eax_262, out ecx_664, out edx_665, out ebx_666, out esi_264, out edi_266);
		esp_273 = (struct Eq_1615 *) (&esp_249->dw0000 + 1);
		esp_249->dw0018 = eax_262;
		break;
	}
	edi_336 = ϕ(edi_337, edi_266, edi_337);
	esp_322 = ϕ(esp_248, esp_273, esp_304);
	esi_312 = ϕ(esi_313, esi_264, esi_313);
	Mem311 = ϕ(Mem245, Mem275, Mem310);
	eax_318 = (word32) bLoc0C_558;
	ecx_319 = (word32) g_w40AB96;
	eax_320 = eax_318 + ecx_319;
	dwLoc0C_560 = eax_320;
	eax_323 = esp_322->dw0018;
	eax_325 = eax_323 - 0x01 ^ esi_312;
	ecx_329 = eax_325;
}

// 00405435: Register word32 fn00405435(Register word32 ecx, Stack word32 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C, Stack word32 dwArg10)
// Called from:
//      fn00404EEB
//      fn00405435
word32 fn00405435(word32 ecx, word32 dwArg00, word32 dwArg04, word32 dwArg08, <anonymous> * dwArg0C, word32 dwArg10)
{
	ptr32 fp;
	Eq_242 dwLoc8C;
	int32 dwLoc18;
	int32 dwLoc24;
	Eq_1254 dwLoc28;
	word32 * esp_153;
	if (dwArg10 != 549991)
	{
		if (dwArg10 != 0x00031A16)
		{
			up32 dwLoc40_220;
			for (dwLoc40_220 = 0x00; dwLoc40_220 < 0x10; ++dwLoc40_220)
			{
				if (dwLoc40_220 == 0x13)
				{
					SetScrollRange(dwLoc28, 15244, dwLoc24, dwLoc18, 0x00);
					dwLoc18 = dwLoc24;
				}
			}
			ecx = 0x00;
			if (*g_ptr40A2D8->ptr000C != 0x00)
			{
				ecx = 0x00;
				if (g_dw40A090 == 0x00)
					ecx = fn004047C6();
			}
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		word32 stackArg0 = <invalid>;
		word32 stackArg16 = <invalid>;
		fn00405435(ecx, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg16);
		esp_153 = fp - 0x0C;
	}
	else
		dwArg0C();
	g_dw40ABD6 -= 0x39AA;
	word32 * ecx_167 = g_ptr40ACDA;
	*ecx_167 = *ecx_167 - 13668 - (word32) (g_t40A100.u0 < dwLoc8C);
	return *esp_153;
}

// 0040564B: Register Eq_148 fn0040564B(Register Eq_148 eax, Register up32 ebx, Register up32 edi, Register out Eq_148 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0040672B
Eq_148 fn0040564B(Eq_148 eax, up32 ebx, up32 edi, union Eq_148 & ecxOut, ptr32 & edxOut)
{
	ptr32 fp;
	Eq_148 dwLoc10;
	up32 dwLoc7C;
	Eq_148 dwLoc24;
	word32 dwLocC4;
	Eq_148 dwLoc20;
	up32 dwLoc30_330;
	for (dwLoc30_330 = 0x00; dwLoc30_330 < 0x1F; ++dwLoc30_330)
	{
		if (dwLoc30_330 == 0x27)
			eax = LockFile(dwLoc20, dwLoc10, 22414, dwLoc20, 0x8757);
	}
	ptr32 edx_29 = eax.u0->bmiHeader.biSize;
	Eq_148 ecx_31 = dwLoc10;
	if (dwLoc10 != 0x00)
	{
		Mem40[Mem30[eax + 4:word32] + 0x00:word32] = dwLoc10 + Mem30[dwLoc10 + 60:word32];
		byte * edx_50 = g_ptr40AC7E;
		*edx_50 = *edx_50 + 0x47 + (byte) (ebx < dwLoc7C);
		up32 * edx_54 = eax.u0->bmiHeader.biXPelsPerMeter;
		edx_29 = fp - 36;
		ecx_31 = dwLoc24;
		if (dwLoc24 != 0x00)
		{
			up32 ecx_128;
			Mem67[Mem58[eax + 0x0C:word32] + 0x00:word32] = dwLoc24 + dwLoc10;
			struct Eq_2502 ** ecx_68 = *((word32) eax + 0x0C);
			g_dw40AB1A += *g_ptr40ACFE;
			struct Eq_2502 * ecx_74 = *ecx_68;
			up32 ecx_88 = ecx_74->dw0018;
			g_t40AB8A.u1 = (up32) ((word32) g_t40AB8A.u0 + dwLocC4);
			g_dw40AB9E = g_dw40AB9E - 11752 - (word32) (edi < dwLoc30_330);
			up32 ecx_109 = ecx_74->dw0014;
			if (ecx_109 > ecx_88)
				ecx_128 = ecx_109;
			else
				ecx_128 = ecx_88;
			g_dw40AB52 &= 0x0040AB0E;
			ui64 v36_v35_327 = SEQ(g_dw40AB52, g_dw40AB52) + 0x40AB120040AB62;
			g_dw40AB52 = (word32) v36_v35_327;
			g_dw40AB52 = SLICE(v36_v35_327, word32, 32);
			*edx_54 = ecx_128;
			up32 dwLoc44_360 = 0x00;
			do
			{
				dwLoc44_360 = dwLoc44_602 + 0x01;
				if (dwLoc44_360 == 0x2B)
					eax = SetLocalTime((SYSTEMTIME *) 23636);
				dwLoc44_602 = dwLoc44_360;
			} while (dwLoc44_602 < 0x1C);
			word32 * ecx_196 = g_ptr40AD1E;
			word32 ecx_192 = ecx_74->dw0024;
			*ecx_196 -= 0x1909;
			*eax.u0->bmiHeader.biSizeImage = dwLoc10.u0 + ecx_192 / 44;
			uint8 * edx_207 = g_ptr40AC92;
			*edx_207 >>= 0x01;
		}
	}
	ecxOut = ecx_31;
	edxOut = edx_29;
	return 0x00;
}

// 004059B2: Register Eq_148 Win32CrtStartup()
Eq_148 Win32CrtStartup()
{
	ptr32 fp;
	word32 esi;
	word32 edi;
	Eq_2616 tLoc14;
	Eq_2617 tLoc0C;
	Eq_2618 tLoc08;
	ui32 dwLoc025C;
	word32 dwLoc03D4;
	up32 dwLoc02AC;
	ui32 dwLoc0294;
	up32 dwLoc0348;
	Eq_1266 dwLoc2C;
	Eq_1254 dwLoc20;
	Eq_148 dwLoc18;
	Eq_148 dwLoc28;
	Eq_148 dwLoc10;
	Eq_148 dwLoc24;
	if (SHLWAPI.dll!StrSpnA(4236636, 4236632) > 0x0A)
		return 0x00;
	esp_14->dwFFFFFFFC = esi;
	esp_14->dwFFFFFFF8 = edi;
	word32 dwLoc0220_596;
	for (dwLoc0220_596 = 0x11; dwLoc0220_596 != 0x00; --dwLoc0220_596)
	{
		if (dwLoc0220_596 == 0x18)
		{
			esp_14->tFFFFFFF4.u0 = 0x3899;
			esp_14->tFFFFFFF0.u0 = 0x8BFF;
			esp_14->tFFFFFFEC.u0 = tLoc14.u0;
			esp_14->tFFFFFFE8.u0 = 7721;
			esp_14->tFFFFFFE4.u0 = (BOOL) dwLoc24;
			DialogBoxIndirectParamA(esp_14->tFFFFFFE4.u3, esp_14->tFFFFFFE8.u6, esp_14->tFFFFFFEC.u2, esp_14->tFFFFFFF0.u1, esp_14->tFFFFFFF4.u0);
		}
	}
	fn00404C90(fp - 4, &tLoc14, ~0x101E);
	esp_14->tFFFFFFF4.u0 = 0x46;
	esp_14->tFFFFFFF4.u0 = 0x3A;
	esp_14->tFFFFFFF4.u0 = 0x5C;
	Eq_148 esi_61 = esp_14->tFFFFFFF4.u0;
	esp_14->tFFFFFFF4.u0 = 0x4A;
	ui32 * ecx_66 = g_ptr40ACAA;
	*ecx_66 |= dwLoc025C;
	g_t40ABAE.u1 = (word32) ((word32) g_t40ABAE.u0 - dwLoc03D4);
	esp_14->tFFFFFFF4.u0 = 0x48;
	Eq_148 ecx_108 = esp_14->tFFFFFFF4.u0;
	esp_14->tFFFFFFF4.u0 = 0x44;
	ui32 * edx_112 = g_ptr40AC6E;
	*edx_112 &= (word32) g_b40ABCA;
	esp_14->tFFFFFFF4.u0 = 0x4B;
	word16 dx_580 = esp_14->w000C;
	g_dw40AAEE &= 0x0040AAFA;
	g_dw40ABBE &= dwLoc0294;
	esp_14->tFFFFFFF4.u0 = 0x44;
	byte * edi_166 = g_ptr40ACAE;
	*edi_166 += 0x2D;
	esp_14->tFFFFFFF4.u0 = 0x2E;
	esp_14->tFFFFFFF4.u0 = 0x44;
	esp_14->tFFFFFFF4.u0 = 0x4C;
	g_dw40AB4E = 0x00;
	word16 di_578 = (word16) esi_61;
	while (true)
	{
		word16 cx_261 = (word16) ecx_108;
		if (g_dw40AB4E >= 22)
			break;
		if (g_dw40AB4E == 0x1D)
		{
			esp_14->tFFFFFFF0.u0 = (void *) dwLoc20;
			esp_14->tFFFFFFEC.u0 = 0x0040AB66;
			esp_14->tFFFFFFE8.u0 = (BOOL) dwLoc18;
			esp_14->tFFFFFFE4.u0 = 0x0040AB82;
			esp_14->tFFFFFFE0.u0 = (BOOL) dwLoc24;
			esp_14->tFFFFFFDC.u0 = (BOOL) dwLoc28;
			esp_14->tFFFFFFD8.u0 = (BOOL) dwLoc10;
			TransactNamedPipe(esp_14->tFFFFFFD8.u6, esp_14->tFFFFFFDC.u6, esp_14->tFFFFFFE0.u0, esp_14->tFFFFFFE4.u6, esp_14->tFFFFFFE8.u0, esp_14->tFFFFFFEC.u3, esp_14->tFFFFFFF0.u4);
		}
		++g_dw40AB4E;
	}
	esp_14->tFFFFFFF4.u0 = 464;
	esp_14->tFFFFFFF0.u0 = 0x00;
	memset(esp_14->tFFFFFFEC, esp_14->tFFFFFFF0.u0, esp_14->tFFFFFFF4.u0);
	if (SHLWAPI.dll!PathMakePrettyW(di_578, (word16) ecx_108, dx_580, cx_261, fp - 484, fp - 0x021C) != 0x00)
	{
		word32 ebx_883;
		fn00403E27(fp - 4, &tLoc0C, fp - 16, out ebx_883);
		word32 ebx_884;
		fn00403E27(fp - 4, &g_t40A548, 0x00, out ebx_884);
		fn00404C90(fp - 4, &g_dw40A54C, 0x00);
		word32 ebx_885;
		fn00403E27(fp - 4, &g_t40A550, 0x00, out ebx_885);
		word32 ebx_886;
		fn00403E27(fp - 4, &g_dw40A554, 0x00, out ebx_886);
	}
	tLoc08 = (Eq_2618) fp;
	word32 ebx_881;
	fn00403E27(fp - 4, &tLoc08, 0x06586468, out ebx_881);
	tLoc08 = (Eq_2618) (fp - 4);
	fn00403E03(tLoc08);
	byte * esi_362 = g_ptr40AD5A;
	Eq_579 edi_358 = g_t40A548.u0;
	*esi_362 -= 122;
	word32 ebx_882;
	fn00403E27(fp - 4, &g_dw40A4CC, edi_358, out ebx_882);
	Mem393 = Mem375;
	fn00404C90(fp - 4, &g_dw40A4D0, g_dw40A54C);
	word32 ebx_887;
	fn00403E27(fp - 4, &g_dw40A4D4, g_t40A550.u0, out ebx_887);
	word32 ebx_416;
	up32 ecx_417 = fn00403E27(fp - 4, &g_ptr40A4D8, tLoc0C.u0, out ebx_416);
	Eq_148 eax_423 = GetCurrentProcessId();
	Eq_1266 edi_426 = esp_274->t0000;
	g_dw40ABBE = g_dw40ABBE - 4238294 - (word32) (ecx_417 < dwLoc0348);
	if (eax_423 != 0x00)
		fn00405F2F(ecx_417, ebx_416, edi_426);
	else if (GetCurrentThreadId() != 0x00)
	{
		esp_274->t0004.u0 = 0x00;
		ExitProcess(esp_274->t0004.u0);
	}
	*tLoc0C = (Eq_2617) *g_ptr40A4D8;
	Eq_242 eax_461 = g_dw40A104 ^ g_t40A100.u0;
	up32 dwLoc0264_673 = 0x00;
	do
	{
		dwLoc0264_673 = dwLoc0264_888 + 0x01;
		if (dwLoc0264_673 == 0x1E)
		{
			esp_274->t0004.u0 = 34445;
			esp_274->t0000 = dwLoc2C;
			esp_274->tFFFFFFFC.u0 = 33818;
			esp_274->dwFFFFFFF8 = 0x31CE;
			esp_274->tFFFFFFF4.u0 = (void *) dwLoc20;
			eax_461 = SendDlgItemMessageA(esp_274->tFFFFFFF4.u2, esp_274->dwFFFFFFF8, esp_274->tFFFFFFFC.u0, esp_274->t0000, esp_274->t0004.u0);
		}
		dwLoc0264_888 = dwLoc0264_673;
	} while (dwLoc0264_888 < 0x12);
	g_t40A100.u0 = (uint32) eax_461;
}

// 00405F2F: void fn00405F2F(Register up32 ecx, Register word32 ebx, Register Eq_1266 edi)
// Called from:
//      Win32CrtStartup
void fn00405F2F(up32 ecx, word32 ebx, Eq_1266 edi)
{
	ptr32 fp;
	word32 dwLoc50;
	Eq_1254 dwLoc24;
	g_t40ABA2.u0 = (ui32) (g_t40ABA2.u0 & g_dw40ABEA);
	g_ptr40A4B8 = 0x00;
	if (fn00405060(ecx, ebx, edi) != 0x00)
	{
		ui32 edi_114 = ~0x1119;
		ptr32 ebx_109 = fp;
		word32 esi_116 = 0x3530;
		do
		{
			ptr32 eax_101;
			g_dw40A318 = g_dw40A4CC;
			g_dw40A31C = g_dw40A4D0;
			word32 eax_59 = g_dw40A4D4;
			g_ptr40AB02 = 4238222;
			g_dw40A320 = eax_59;
			if (edi_114 == ~0x101C)
			{
				up32 dwLoc18_190;
				for (dwLoc18_190 = 0x00; dwLoc18_190 < 0x17; ++dwLoc18_190)
				{
					if (dwLoc18_190 == 0x25)
					{
						SendMessageA(dwLoc24, 33790, 12190, ~0x101D);
						dwLoc50 = ~0x101D;
					}
				}
				eax_101 = g_ptr40A4B8;
			}
			else
			{
				if (edi_114 == ~0x11DE)
				{
					g_ptr40A314 = fp - 0x0C;
					*g_ptr40A4D8 = fn00404D4D(ebx_109, esi_116, edi_114, dwLoc50, out ebx_109, out esi_116, out edi_114);
				}
				g_ptr40A4B8 = ebx_109;
				eax_101 = ~0x101D;
				edi_114 = edi_114 ^ esi_116;
			}
			edi_114 = edi_114 - (eax_101 ^ esi_116) - 0x252F ^ esi_116;
		} while (edi_114 != ~0x101D);
	}
}

<anonymous> g_t4060BA = <code>; // 004060BA
// 0040672B: FlagGroup bool fn0040672B(Stack (ptr32 code) dwArg04, Stack ui32 dwArg08, Stack Eq_734 dwArg0C, Stack word32 dwArg10, Register out ptr32 eaxOut, Register out Eq_1037 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404365
//      fn00405060
bool fn0040672B(<anonymous> * dwArg04, ui32 dwArg08, Eq_734 dwArg0C, word32 dwArg10, ptr32 & eaxOut, union Eq_1037 & ecxOut, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	bool P;
	Eq_148 dwLoc1C;
	struct Eq_3206 * dwLoc14;
	Eq_184 dwLoc18;
	word32 dwLoc30;
	int32 dwLocB4;
	Eq_148 dwLoc28;
	word16 wLoc08;
	word32 dwLocD0;
	ptr32 dwLoc40;
	int32 dwLoc34;
	word32 dwLoc3C;
	Eq_734 dwLoc2C;
	Eq_148 dwLoc24;
	Eq_1037 ecx;
	ptr32 edx;
	g_ptr40ABB2 = 0x0040AB76;
	struct Eq_3223 * esp_17 = fp - 0x022C;
	word32 dwLoc60_642 = ~0x101D;
	word32 dwLoc4C_643 = ~0x101E;
	Eq_148 dwLoc10_644 = ~0x101E;
l0040675D:
	if (dwLoc4C_643 == ~0x101E)
	{
		up32 dwLoc8C_648;
		for (dwLoc8C_648 = 0x00; dwLoc8C_648 < 0x14; ++dwLoc8C_648)
		{
			if (dwLoc8C_648 == 0x1F)
			{
				union Eq_148 * esp_562 = esp_17 - 4;
				esp_562->u0 = (BOOL) dwLoc24;
				IsMenu(esp_562->u3);
			}
		}
		word32 eax_65 = fn0040564B(fp - 0x88, ~0x101E, 0x252F, out ecx, out edx);
		P = SLICE(cond(eax_65), bool, 5);
		if (eax_65 == 0x00)
			goto l00406C97;
	}
	ptr32 edx_297;
	if (dwLoc1C != ~0x101E && ((dwLoc14->t0018).u0 == 0x00 || dwLoc14->dw0014 == 0x00))
	{
		dwLoc60_642 = ~0x101E;
		goto l00406ACF;
	}
	if (dwLoc18 != ~0x101E && (dwLoc10_644 != (dwLoc30 + 4294957777 ^ 0x3530) && dwLoc60_642 == ~0x101D))
	{
		ecx = (dwLoc10_644 ^ 0x3530) + 0x252F;
		if (ecx > 0x06)
			dwLoc4C_643 = ~0x101D;
		if (ecx < (dwLoc14->t0018).u0)
		{
			word32 dwLocA8_703;
			for (dwLocA8_703 = 0x19; dwLocA8_703 != 0x00; --dwLocA8_703)
			{
				if (dwLocA8_703 == 0x20)
				{
					esp_17->tFFFFFFFC.u0 = (BOOL) dwLoc24;
					esp_17->tFFFFFFF8.u0 = 36602;
					esp_17->tFFFFFFF4.u0 = 0x0040AB3A;
					esp_17->tFFFFFFF0.u0 = (BOOL) dwLoc10_644;
					esp_17->tFFFFFFEC.u0 = (BOOL) dwLoc1C;
					esp_17->tFFFFFFE8.u0 = 33267;
					esp_17->tFFFFFFE4.u0 = 34436;
					FormatMessageA(esp_17->tFFFFFFE4.u0, esp_17->tFFFFFFE8, esp_17->tFFFFFFEC.u0, esp_17->tFFFFFFF0.u0, esp_17->tFFFFFFF4, esp_17->tFFFFFFF8.u0, esp_17->tFFFFFFFC.u6);
				}
			}
			up32 edx_175 = dwLoc14->dw0014;
			edx = edx_175 - 0x01;
			if (((word32) wLoc08 - 0x252F ^ 0x3530 ^ 0x3530) + 0x252F <= edx_175 - 0x01)
			{
				g_dw40ABEA += dwLocD0;
				g_dw40ABD2 = 0x18;
				word32 * eax_259 = fp - 60;
				while (g_dw40ABD2 != 0x00)
				{
					if (g_dw40ABD2 == 0x1A)
					{
						esp_17->tFFFFFFFC.u0 = 0x490B;
						esp_17->tFFFFFFF8.u0 = (BOOL) dwLoc28;
						esp_17->tFFFFFFF4.u0 = (void *) dwLoc2C;
						esp_17->tFFFFFFF0.u0 = (BOOL) dwLoc10_644;
						esp_17->tFFFFFFEC.u0 = (BOOL) dwLoc28;
						esp_17->tFFFFFFE8.u0 = (HBITMAP) dwLoc18;
						esp_17->tFFFFFFE4.u0 = 0x5043;
						eax_259 = SetDIBits(esp_17->tFFFFFFE4.u3, esp_17->tFFFFFFE8.u0, esp_17->tFFFFFFEC.u0, esp_17->tFFFFFFF0.u0, esp_17->tFFFFFFF4, esp_17->tFFFFFFF8.u6, esp_17->tFFFFFFFC.u0);
					}
					--g_dw40ABD2;
				}
				g_dw40AB86 = g_dw40AB86 ^ 0x0040AB5A;
				*eax_259 = *((word32) dwLoc40 + dwLoc34);
				esp_17->tFFFFFFFC.u0 = (BOOL) (fp - 32);
				esp_17->tFFFFFFF8.u0 = (BOOL) (dwLoc3C + dwArg08);
				esp_17->tFFFFFFF4.u0 = (void *) dwArg0C;
				byte SCZOP_299;
				dwArg04();
				P = SLICE(SCZOP_299, bool, 5);
				edx = edx_297;
l00406ACF:
				dwLoc10_644 = (dwLoc10_644 ^ 0x3530) + 0x01 ^ 0x3530;
				goto l0040675D;
			}
		}
	}
l00406C97:
	g_dw40AB86 = 0x00;
	while (g_dw40AB86 < 0x19)
	{
		if (g_dw40AB86 == 0x1F)
		{
			struct Eq_3304 * esp_204 = esp_17 - 4;
			esp_204->t0000 = (Eq_1524) &g_t40AEE4;
			esp_204->tFFFFFFFC.u0 = (BOOL) dwLoc10_644;
			esp_204->tFFFFFFF8 = (struct _SECURITY_ATTRIBUTES *) 0x8CE8;
			CreateWaitableTimerW(esp_204->tFFFFFFF8, esp_204->tFFFFFFFC.u0, esp_204->t0000);
		}
		++g_dw40AB86;
	}
	Mem478 = Mem194;
	struct Eq_3530 * esp_480 = &esp_17->ptr0000 + 1;
	ptr32 edi_479 = esp_17->ptr0000;
	ptr32 esi_481 = esp_480->ptr0000;
	ptr32 ebx_483 = esp_480->ptr0004;
	eaxOut = 0x00;
	ecxOut = ecx;
	edxOut = edx;
	ebxOut = ebx_483;
	esiOut = esi_481;
	ediOut = edi_479;
	return P;
}

// 00406D5A: Register (ptr32 void) __he_qt(Stack uint32 dwArg04)
void * __he_qt(uint32 dwArg04)
{
	up32 ecx;
	g_dw40AB36 = g_dw40AB36 + g_dw40AB1E + (word32) (ecx < g_dw40AB0E);
	g_dw40ABD6 -= *g_ptr40AD22;
	g_t40ABC2.u0 = (uint32) ((word32) g_t40ABC2.u1 - *g_ptr40AD4E);
	return (void *) <invalid>;
}

// 00406DAD: void RF_Egdnkvdiiuncf(Stack uint32 dwArg04, Stack (ptr32 int16) ptrArg08)
void RF_Egdnkvdiiuncf(uint32 dwArg04, int16 * ptrArg08)
{
	up32 edi;
	up32 dwLoc08;
	g_t40ABC2.u0 = (uint32) (g_t40ABC2.u0 - g_t40AAFA.u1);
	g_dw40AB86 += (word32) g_t40AAF6.u2;
	g_dw40AB92 = g_dw40AB92 + *g_ptr40AD42 + (word32) (dwLoc08 < edi);
}

// 00406DF7: Register (ptr32 cu8) kJAZuY_hvjqel_v_wuvzz(Stack uint32 dwArg04, Stack uint16 wArg08)
cu8 * kJAZuY_hvjqel_v_wuvzz(uint32 dwArg04, uint16 wArg08)
{
	ui32 * ebx_9 = g_ptr40ACEA;
	*ebx_9 |= g_t40AB46.u0;
	Eq_3568 edx_16 = (word32) g_t40ABC2.u1 | g_dw40AB16;
	g_t40ABC2.u0 = (uint32) edx_16;
	g_dw40AB5E = g_dw40AB5E - *g_ptr40AC9A - (word32) (g_t40ABE6.u0 < edx_16);
	return (cu8 *) <invalid>;
}

// 00406E3E: Register uint32 xcfq_xwotK(Stack (ptr32 uint32) ptrArg04)
uint32 xcfq_xwotK(uint32 * ptrArg04)
{
	Eq_2530 dwLoc08;
	Eq_2530 ecx_11 = (word32) g_t40AB8A.u0 - *g_ptr40ACF2;
	g_t40AB8A.u1 = (up32) ecx_11;
	g_t40ABE2.u1 = (word32) ((word32) g_t40ABE2.u0 + g_t40AB6E.u1 + (word32) (dwLoc08 < ecx_11));
	g_t40AB12.u0 = (ui32) (g_t40AB12.u0 & *g_ptr40ACA2);
	return <invalid>;
}

// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 * g_ptr40A030 = &g_dw401014; // 0040A030
ui32 ** g_ptr40A03C = &g_ptr40A030; // 0040A03C
ui32 *** g_ptr40A040 = &g_ptr40A03C; // 0040A040
word32 g_dw40A08C = 0x00; // 0040A08C
word32 g_dw40A090 = 0x00; // 0040A090
word32 g_dw40A098 = ~0x303E; // 0040A098
word32 * g_a40A0D4[] = // 0040A0D4
	{
	};
word32 g_dw40A0EC = 0x00; // 0040A0EC
word32 g_dw40A0F0 = 0x00; // 0040A0F0
word32 g_dw40A0F4 = 0x00; // 0040A0F4
word32 g_dw40A0FC = 0x00; // 0040A0FC
Eq_242 g_t40A100 = // 0040A100
	{
		0x00
	};
ui32 g_dw40A104 = 0x00; // 0040A104
ui32 g_dw40A108 = 0x00; // 0040A108
Eq_144 g_t40A110 = // 0040A110
	{
		&g_dw40A08C,
		&g_dw40A108,
		&g_dw40A0FC,
	};
ui32 * g_ptr40A11C = &g_dw40A108; // 0040A11C
struct Eq_144 * g_ptr40A2D8 = &g_t40A110; // 0040A2D8
Eq_1380 g_t40A2EC = 0x07860677; // 0040A2EC
Eq_148 g_t40A2F4 = // 0040A2F4
	{
		&g_t547576A
	};
word32 * g_ptr40A2F8 = null; // 0040A2F8
word32 g_dw40A2FC = 0x0040184B; // 0040A2FC
word32 * g_ptr40A304 = &g_dw6546418; // 0040A304
word32 g_dw40A308 = 6624275; // 0040A308
word32 g_dw40A30C = 15080055; // 0040A30C
struct Eq_254 * g_ptr40A310 = &g_t4039CA; // 0040A310
word32 * g_ptr40A314 = &g_dw77706; // 0040A314
word32 g_dw40A318 = 0x06751706; // 0040A318
word32 g_dw40A31C = 0x00060706; // 0040A31C
word32 g_dw40A320 = 0x07655777; // 0040A320
word16 g_a40A340[] = // 0040A340
	{
	};
ptr32 g_ptr40A4B8 = 0x00342515; // 0040A4B8
word16 g_w40A4BC = 65222; // 0040A4BC
ui16 g_w40A4C4 = 0x6078; // 0040A4C4
word32 g_dw40A4CC = 0x00077574; // 0040A4CC
word32 g_dw40A4D0 = 0x00077767; // 0040A4D0
word32 g_dw40A4D4 = 141969018; // 0040A4D4
ui32 * g_ptr40A4D8 = &g_dw42418; // 0040A4D8
ui8 g_a40A4DC[16] = // 0040A4DC
	{
		117,
		0x53,
		0x22,
		0x7E,
		0x20,
		0x5D,
		0x51,
		111,
		0x52,
		0x52,
		0x20,
		0x53,
		33,
		33,
		~0x51,
		0x00,
	};
ui32 g_dw40A4EC = 0x00; // 0040A4EC
word32 g_dw40A514 = 0x00; // 0040A514
char g_b40A52C = 'K'; // 0040A52C
char g_b40A53C = 'J'; // 0040A53C
Eq_579 g_t40A548 = // 0040A548
	{
		0x00787608
	};
uint32 g_dw40A54C = 3478978; // 0040A54C
Eq_579 g_t40A550 = // 0040A550
	{
		144131946
	};
word32 g_dw40A554 = 0x76860426; // 0040A554
<anonymous> * g_ptr40A580 = fn0040672B; // 0040A580
<anonymous> * g_ptr40A584 = &g_t4060BA; // 0040A584
ui32 g_dw40AAEE = 0x0010374A; // 0040AAEE
Eq_85 g_t40AAF2 = // 0040AAF2
	{
		0x00103253
	};
Eq_45 g_t40AAF6 = // 0040AAF6
	{
		1064747
	};
Eq_3584 g_t40AAFA = // 0040AAFA
	{
		55
	};
ui32 g_dw40AAFE = 0x0010520A; // 0040AAFE
ptr32 g_ptr40AB02 = 1066658; // 0040AB02
word32 g_dw40AB06 = 1077205; // 0040AB06
up32 g_dw40AB0A = 1056181; // 0040AB0A
up32 g_dw40AB0E = 0x00101C5A; // 0040AB0E
Eq_122 g_t40AB12 = // 0040AB12
	{
		1063310
	};
uint32 g_dw40AB16 = 0x001040B4; // 0040AB16
ui32 g_dw40AB1A = 0x0010506F; // 0040AB1A
word32 g_dw40AB1E = 1060202; // 0040AB1E
up32 g_dw40AB22 = 0x00103EDE; // 0040AB22
ui32 g_dw40AB26 = 0x00106A85; // 0040AB26
word32 g_dw40AB2A = 0x00107BFB; // 0040AB2A
up32 g_dw40AB2E = 1060110; // 0040AB2E
ui32 g_dw40AB32 = 0x00104165; // 0040AB32
word32 g_dw40AB36 = 1066463; // 0040AB36
ui32 g_dw40AB3A = 0x00100B61; // 0040AB3A
byte g_b40AB3E = ~0x4C; // 0040AB3E
up32 g_dw40AB42 = 1080101; // 0040AB42
Eq_130 g_t40AB46 = // 0040AB46
	{
		1053383
	};
struct Eq_864 * g_ptr40AB4A = &g_t10346A; // 0040AB4A
uint32 g_dw40AB4E = 0x00101698; // 0040AB4E
uint32 g_dw40AB52 = 1071291; // 0040AB52
ui32 g_dw40AB56 = 0x00105E80; // 0040AB56
word32 g_dw40AB5E = 1068091; // 0040AB5E
word32 g_dw40AB66 = 0x00107BA0; // 0040AB66
up32 g_dw40AB6A = 0x0010207C; // 0040AB6A
Eq_49 g_t40AB6E = // 0040AB6E
	{
		0x1511
	};
ui32 g_dw40AB72 = 1077706; // 0040AB72
up32 g_dw40AB76 = 1065065; // 0040AB76
word32 g_dw40AB7A = 0x0010299E; // 0040AB7A
up32 g_dw40AB82 = 1060709; // 0040AB82
uint32 g_dw40AB86 = 1081173; // 0040AB86
Eq_2530 g_t40AB8A = // 0040AB8A
	{
		~0x24
	};
ui32 g_dw40AB8E = 1050099; // 0040AB8E
word32 g_dw40AB92 = 0x00102A9F; // 0040AB92
word16 g_w40AB96 = 0x6DF3; // 0040AB96
word32 g_dw40AB9A = 0x00102960; // 0040AB9A
word32 g_dw40AB9E = 1071757; // 0040AB9E
Eq_26 g_t40ABA2 = // 0040ABA2
	{
		0x00100197
	};
ui32 g_dw40ABA6 = 1076722; // 0040ABA6
WCHAR g_t40ABAA = '\xE9'; // 0040ABAA
Eq_2736 g_t40ABAE = // 0040ABAE
	{
		~0x60
	};
ptr32 g_ptr40ABB2 = 0x0010659B; // 0040ABB2
word32 g_dw40ABB6 = 0x00106C7B; // 0040ABB6
ui32 g_dw40ABBA = 0x00107FCC; // 0040ABBA
ui32 g_dw40ABBE = 1064888; // 0040ABBE
Eq_3568 g_t40ABC2 = // 0040ABC2
	{
		0x00107D49
	};
word16 g_w40ABC6 = 19397; // 0040ABC6
byte g_b40ABCA = 0x39; // 0040ABCA
up32 g_dw40ABCE = 1063640; // 0040ABCE
up32 g_dw40ABD2 = 0x001031F4; // 0040ABD2
word32 g_dw40ABD6 = 0x00100AE3; // 0040ABD6
Eq_96 g_t40ABDA = // 0040ABDA
	{
		0xC0
	};
ui32 g_dw40ABDE = 0x00105AE0; // 0040ABDE
Eq_3652 g_t40ABE2 = // 0040ABE2
	{
		0x4A
	};
Eq_3568 g_t40ABE6 = // 0040ABE6
	{
		0x00101FE0
	};
ui32 g_dw40ABEA = 0x00100613; // 0040ABEA
byte * g_ptr40AC6A = &g_b40AAEE; // 0040AC6A
ui32 * g_ptr40AC6E = &g_dw40AAF2; // 0040AC6E
ui32 * g_ptr40AC7A = &g_dw40AAFE; // 0040AC7A
byte * g_ptr40AC7E = &g_b40AB02; // 0040AC7E
word32 * g_ptr40AC82 = &g_dw40AB06; // 0040AC82
uint8 * g_ptr40AC92 = &g_b40AB16; // 0040AC92
word32 * g_ptr40AC9A = &g_dw40AB1E; // 0040AC9A
word32 * g_ptr40AC9E = &g_dw40AB22; // 0040AC9E
ui32 * g_ptr40ACA2 = &g_dw40AB26; // 0040ACA2
uint8 * g_ptr40ACA6 = &g_b40AB2A; // 0040ACA6
ui32 * g_ptr40ACAA = &g_dw40AB2E; // 0040ACAA
byte * g_ptr40ACAE = &g_b40AB32; // 0040ACAE
byte * g_ptr40ACBA = &g_b40AB3E; // 0040ACBA
word32 * g_ptr40ACC2 = &g_dw40AB46; // 0040ACC2
byte * g_ptr40ACCE = &g_b40AB52; // 0040ACCE
word32 * g_ptr40ACDA = &g_dw40AB5E; // 0040ACDA
byte * g_ptr40ACE6 = &g_b40AB6A; // 0040ACE6
ui32 * g_ptr40ACEA = &g_dw40AB6E; // 0040ACEA
ui32 * g_ptr40ACF2 = &g_dw40AB76; // 0040ACF2
word32 * g_ptr40ACFE = &g_dw40AB82; // 0040ACFE
ui32 * g_ptr40AD02 = &g_dw40AB86; // 0040AD02
word32 * g_ptr40AD12 = &g_dw40AB96; // 0040AD12
word32 * g_ptr40AD16 = &g_dw40AB9A; // 0040AD16
byte * g_ptr40AD1A = &g_b40AB9E; // 0040AD1A
word32 * g_ptr40AD1E = &g_dw40ABA2; // 0040AD1E
word32 * g_ptr40AD22 = &g_dw40ABA6; // 0040AD22
word32 * g_ptr40AD32 = &g_dw40ABB6; // 0040AD32
word32 * g_ptr40AD42 = &g_dw40ABC6; // 0040AD42
word32 * g_ptr40AD4E = &g_dw40ABD2; // 0040AD4E
ui32 * g_ptr40AD52 = &g_dw40ABD6; // 0040AD52
ui32 * g_ptr40AD56 = &g_dw40ABDA; // 0040AD56
byte * g_ptr40AD5A = &g_b40ABDE; // 0040AD5A
ui32 * g_ptr40AD62 = &g_dw40ABE6; // 0040AD62
WCHAR g_t40AE85 = 'C'; // 0040AE85
WCHAR g_t40AE94 = 'G'; // 0040AE94
WCHAR g_t40AEAC = 'F'; // 0040AEAC
WCHAR g_t40AEBC = 'K'; // 0040AEBC
WCHAR g_t40AEE4 = 'S'; // 0040AEE4
// subject_import.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40908C = 0x9144; // 0040908C
word32 g_dw409090 = 0x9160; // 00409090
word32 g_dw409094 = 37238; // 00409094
word32 g_dw409098 = 0x9188; // 00409098
word32 g_dw4090A0 = 37292; // 004090A0
word32 g_dw4090A4 = 37314; // 004090A4
word32 g_dw4090A8 = 37332; // 004090A8
word32 g_dw4090AC = 37354; // 004090AC
word32 g_dw4090B0 = 0x9202; // 004090B0
word32 g_dw4090B4 = 37404; // 004090B4
word32 g_dw4090B8 = 0x9230; // 004090B8
word32 g_dw4090BC = 37438; // 004090BC
word32 g_dw4090C0 = 0x9250; // 004090C0
word32 g_dw4090C4 = 0x925C; // 004090C4
word32 g_dw4090C8 = 37484; // 004090C8
word32 g_dw4090CC = 0x9280; // 004090CC
word32 g_dw4090D4 = 0x92A4; // 004090D4
word32 g_dw4090D8 = 37550; // 004090D8
word32 g_dw4090E0 = 37572; // 004090E0
word32 g_dw4090E4 = 0x92D0; // 004090E4
word32 g_dw4090E8 = 0x92DE; // 004090E8
word32 g_dw4090EC = 0x92F2; // 004090EC
word32 g_dw4090F0 = 0x930A; // 004090F0
word32 g_dw4090F4 = 0x9316; // 004090F4
word32 g_dw4090FC = 37676; // 004090FC
word32 g_dw409100 = 0x933E; // 00409100
word32 g_dw409108 = 37716; // 00409108
word32 g_dw40910C = 37740; // 0040910C
word32 g_dw409110 = 37756; // 00409110
word32 g_dw409114 = 37772; // 00409114
word32 g_dw409118 = 0x939E; // 00409118
word32 g_dw40911C = 0x93AE; // 0040911C
word32 g_dw409120 = 0x93C0; // 00409120
word32 g_dw409124 = 0x93DA; // 00409124
word32 g_dw409128 = 0x93F0; // 00409128
word32 g_dw40912C = 0x9400; // 0040912C
word32 g_dw409130 = 0x9416; // 00409130
word32 g_dw409134 = 37932; // 00409134
word32 g_dw409138 = 0x9442; // 00409138
word32 g_dw40913C = 0x9450; // 0040913C
