// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw449054 = 0x00049074; // 00449054
word32 g_dw449058 = 0x00049080; // 00449058
word32 g_dw44905C = 0x00049096; // 0044905C
<anonymous> * __imp__AbortDoc = &g_t49074; // 00449064
<anonymous> * __imp__ColorCorrectPalette = &g_t49080; // 00449068
<anonymous> * __imp__GetObjectA = &g_t49096; // 0044906C
word32 g_dw4490A4 = 299228; // 004490A4
word32 g_dw4490A8 = 299242; // 004490A8
word32 g_dw4490AC = 299270; // 004490AC
word32 g_dw4490B0 = 0x00049114; // 004490B0
word32 g_dw4490B4 = 299302; // 004490B4
word32 g_dw4490B8 = 299318; // 004490B8
<anonymous> * __imp__CreateFileA = &g_t490DC; // 004490C0
<anonymous> * __imp__EnumSystemLanguageGroupsA = &g_t490EA; // 004490C4
<anonymous> * __imp__GetFileSize = &g_t49106; // 004490C8
<anonymous> * __imp__GetProcAddress = &g_t49114; // 004490CC
<anonymous> * __imp__LoadLibraryA = &g_t49126; // 004490D0
<anonymous> * __imp__WriteFile = &g_t49136; // 004490D4
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

BOOL g_t401000(LGRPID tArg04, LPSTR tArg08, LPSTR tArg0C, DWORD tArg10, LONG_PTR tArg14) = ??/* Unexpected function type (fn BOOL (LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR)) */ ; // 00401000
// 004010DA: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	byte SCZDOP;
	word32 ebx;
	Eq_6 eax;
	Eq_2 esi;
	ptr32 edi;
	struct Eq_9 * ss;
	Eq_6 SCZDOP_12 = cond(fp - 0x20) | SCZDOP;
	byte bl_33 = (byte) ebx;
	word16 ebx_16_16_95 = SLICE(ebx, word16, 16);
	Eq_6 SCZDOP_173 = SCZDOP_12;
	Eq_20 v55_174 = fp - 0x24;
	Eq_6 edx_31 = eax;
	ptr32 esp_35 = fp - 0x24;
	while (true)
	{
		struct Eq_39 * esp_38 = esp_35 - 4;
		esp_38->t0000 = 0x02;
		esp_38->tFFFFFFFC = (Eq_157) &g_t401000;
		EnumSystemLanguageGroupsA(esp_38->tFFFFFFFC, esp_38->t0000, esp_38->t0004.u1);
		Eq_73 ecx_45 = edx_31 * 0x02 + 441754833;
		esp_38->t0004.u1 = (LONG_PTR) SCZDOP_173;
		edx_31.u1 = esp_38->t0004.u1;
		word16 ax_52 = esp_38->w0008;
		esp_38->t0004.u1 = (LONG_PTR) 432040460;
		word16 eax_16_16_58 = SLICE(&esp_38->w0008, word16, 16);
		Eq_86 CP_78 = SLICE(SCZDOP_173, bool, 5);
		Eq_42 DP_172 = SLICE(SCZDOP_173, bool, 5);
		byte ch_60 = SLICE(ecx_45, byte, 8);
		uint16 dx_102 = (word16) edx_31;
		byte al_103 = (byte) ax_52;
		struct Eq_28 * eax_59 = SEQ(eax_16_16_58, ax_52);
		int32 ebx_96 = SEQ(ebx_16_16_95, 0xA4, bl_33);
		word24 ebx_24_8_109 = SEQ(ebx_16_16_95, 0xA4);
		if (!v55_174)
			break;
		byte v33_61 = eax_59->b000C + ch_60;
		eax_59->b000C = v33_61;
		byte SCZO_63 = cond(v33_61);
		esp_35 = (char *) &esp_38->t0004 + 1;
		SCZDOP_173 = SCZO_63 | DP_172;
		v55_174 = SCZO_63 | DP_172;
	}
	esp_38->t0000 = esi;
	__frstor(*edx_31);
	esp_38->ptrFFFFFFFE = ss;
	byte bl_97 = *((word32) edi + ebx_96);
	__out<byte>(dx_102, al_103);
	word32 v29_105 = Mem99[edx_31 + 0x00:word32] + ecx_45;
	*edx_31 = v29_105;
	word32 * ebx_110 = SEQ(ebx_24_8_109, bl_97);
	ui32 eax_126 = SEQ(eax_16_16_58, cond(esi - 0x01) | CP_78, al_103);
	if (OVERFLOW<word32>(v29_105))
	{
		__lock();
		__halt();
	}
	else if (v29_105 < 0x00)
	{
		((word32) ecx_45 + (eax_126 * 0x04 + 76))->u1 = *((word32) ecx_45 + (eax_126 * 0x04 + 76)) ^ ebx_110;
		esp_38->ptrFFFFFFFA = esp_38 - 0x02;
		if (OVERFLOW<word32>(edx_31 - 0x01))
			__syscall<byte>(0x04);
		esp_38->dwFFFFFFF6 = eax_126;
		esp_38->ptrFFFFFFF2 = ebx_110;
		ecx_45.u2->bFFFFFFDD = ~0x58;
		*(byte *) 0x66ABD0FD = al_103;
		*ebx_110 += ~0x29;
		return fn66F3_C025(3868956798);
	}
}

