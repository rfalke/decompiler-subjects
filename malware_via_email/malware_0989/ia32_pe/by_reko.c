// subject_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b3E3000 = ~0x30; // 003E3000
uint32 g_dw3EAA0B = 0x7A08; // 003EAA0B
Eq_32 g_t3EAA10 = null; // 003EAA10
Eq_32 g_t3EAA14 = null; // 003EAA14
Eq_33 g_t3EAA18 = null; // 003EAA18
Eq_3 g_t3EAA1C = // 003EAA1C
	{
		null
	};
// subject_data_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw413E1D = 0x00; // 00413E1D
word32 g_dw413E21 = 0x00; // 00413E21
word32 g_dw413E25 = 0x00; // 00413E25
word32 g_dw413E29 = 0x00; // 00413E29
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t20E4; // 003E2000
<anonymous> * __imp__GetModuleFileNameA = &g_t20F6; // 003E2004
<anonymous> * __imp__GetModuleFileNameW = &g_t210C; // 003E2008
<anonymous> * __imp__GetProcAddress = &g_t2122; // 003E200C
<anonymous> * __imp__LoadLibraryA = &g_t2134; // 003E2010
<anonymous> * __imp__GetModuleHandleA = &g_t2144; // 003E2014
<anonymous> * __imp__ReadFile = &g_t2158; // 003E2018
<anonymous> * __imp__WriteFile = &g_t2164; // 003E201C
<anonymous> * __imp__CloseHandle = &g_t2170; // 003E2020
<anonymous> * __imp__CreateThread = &g_t217E; // 003E2024
<anonymous> * __imp__CreatePipe = &g_t218E; // 003E2028
<anonymous> * __imp__ExitProcess = &g_t219C; // 003E202C
<anonymous> * __imp__HeapAlloc = &g_t21AA; // 003E2030
<anonymous> * __imp__GetProcessHeap = &g_t21B6; // 003E2034
<anonymous> * __imp__HeapReAlloc = &g_t21C8; // 003E2038
<anonymous> * __imp__HeapFree = &g_t21D6; // 003E203C
byte g_b3E2050 = 0x47; // 003E2050
byte g_b3E2064 = 0x47; // 003E2064
word32 g_dw3E20A0 = 0x20E4; // 003E20A0
word32 g_dw3E20A4 = 8438; // 003E20A4
word32 g_dw3E20A8 = 0x210C; // 003E20A8
word32 g_dw3E20AC = 0x2122; // 003E20AC
word32 g_dw3E20B0 = 8500; // 003E20B0
word32 g_dw3E20B4 = 0x2144; // 003E20B4
word32 g_dw3E20B8 = 0x2158; // 003E20B8
word32 g_dw3E20BC = 8548; // 003E20BC
word32 g_dw3E20C0 = 0x2170; // 003E20C0
word32 g_dw3E20C4 = 0x217E; // 003E20C4
word32 g_dw3E20C8 = 0x218E; // 003E20C8
word32 g_dw3E20CC = 0x219C; // 003E20CC
word32 g_dw3E20D0 = 0x21AA; // 003E20D0
word32 g_dw3E20D4 = 0x21B6; // 003E20D4
word32 g_dw3E20D8 = 8648; // 003E20D8
word32 g_dw3E20DC = 8662; // 003E20DC
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack Eq_3 dwArg04)
// Called from:
//      fn003E141D
word32 fn003E1000(Eq_3 dwArg04)
{
	return dwArg04 + Mem21[dwArg04 + 60:word32];
}

// 003E101D: void fn003E101D(Register word32 ecx, Stack (ptr32 byte) dwArg04, Stack Eq_3 dwArg08, Stack Eq_11 dwArg0C)
// Called from:
//      fn003E141D
void fn003E101D(word32 ecx, byte * dwArg04, Eq_3 dwArg08, Eq_11 dwArg0C)
{
	Eq_12 tLoc08;
	tLoc08 = (Eq_12) ecx;
	fn003E1A03(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, &tLoc08);
}

int32 g_t3E1050() = ??/* Unexpected function type (fn int32 ()) */ ; // 003E1050
int32 g_t3E1080() = ??/* Unexpected function type (fn int32 ()) */ ; // 003E1080
// 003E10AF: Register Eq_32 fn003E10AF(Stack Eq_33 dwArg04, Stack Eq_34 dwArg08)
// Called from:
//      fn003E1121
Eq_32 fn003E10AF(Eq_33 dwArg04, Eq_34 dwArg08)
{
	Eq_32 eax_61;
	Eq_32 eax_17 = GetProcAddress(dwArg04, dwArg08);
	if (fn003E1A71(dwArg08, &g_b3E2050) == 0x00)
	{
		g_t3EAA10 = eax_17;
		eax_61 = (Eq_32) &g_t3E1050;
	}
	else if (fn003E1A71(dwArg08, &g_b3E2064) == 0x00)
	{
		g_t3EAA14 = eax_17;
		eax_61 = (Eq_32) &g_t3E1080;
	}
	else
		eax_61 = eax_17;
	return eax_61;
}

// 003E110E: Register byte fn003E110E(Stack ui32 dwArg04)
// Called from:
//      fn003E1121
byte fn003E110E(ui32 dwArg04)
{
	return (byte) ((dwArg04 & 0x80000000) != 0x00);
}

// 003E1121: void fn003E1121(Stack (ptr32 Eq_68) dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn003E141D
void fn003E1121(struct Eq_68 * dwArg04, Eq_3 dwArg08)
{
	g_t3EAA18 = GetModuleHandleA(null);
	g_t3EAA1C.u0 = (struct Eq_642 *) dwArg08;
	struct Eq_79 * dwLoc08_245 = dwArg08.u0 + dwArg04->dw0080;
	while (dwLoc08_245->dw000C != 0x00)
	{
		union Eq_84 * dwLoc10_253;
		Eq_33 eax_62 = LoadLibraryA(dwArg08.u0 + dwLoc08_245->dw000C);
		if (dwLoc08_245->dw0004 == 0x00)
			dwLoc10_253 = (union Eq_84 *) (dwArg08.u0 + dwLoc08_245->dw0010);
		else
			dwLoc10_253 = (union Eq_84 *) (dwArg08.u0 + dwLoc08_245->dw0000);
		word32 * dwLoc18_257 = dwArg08.u0 + dwLoc08_245->dw0010;
		while (dwLoc10_253->u1 != 0x00)
		{
			Eq_32 dwLoc14_264;
			if ((word32) fn003E110E(dwLoc10_253->u1) != 0x00)
				dwLoc14_264 = GetProcAddress(eax_62, (word32) dwLoc10_253->u0);
			else
				dwLoc14_264 = fn003E10AF(eax_62, dwArg08.u0 + dwLoc10_253->u1 + 2);
			*dwLoc18_257 = (word32) dwLoc14_264;
			++dwLoc18_257;
			dwLoc10_253 = (union Eq_84 *) ((char *) dwLoc10_253 + 4);
		}
		++dwLoc08_245;
	}
}

// 003E1250: void fn003E1250(Register ptr32 ecx, Stack Eq_160 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn003E12BD
void fn003E1250(ptr32 ecx, Eq_160 dwArg04, Eq_3 dwArg08, word32 dwArg0C)
{
	Eq_12 tLoc08;
	tLoc08 = (Eq_12) ecx;
	tLoc08 = (Eq_12) 0x00;
	do
		;
	while (ReadFile(dwArg04, dwArg08, dwArg0C - tLoc08, &tLoc08, null) != 0x00 && tLoc08 != dwArg0C);
}

// 003E1286: void fn003E1286(Stack Eq_160 dwArg04, Stack Eq_196 dwArg08, Stack Eq_12 dwArg0C)
// Called from:
//      fn003E12BD
void fn003E1286(Eq_160 dwArg04, Eq_196 dwArg08, Eq_12 dwArg0C)
{
	ptr32 fp;
	do
		;
	while (WriteFile(dwArg04, dwArg08, dwArg0C, fp - 8, null) != 0x00 && dwArg0C != 0x00);
}

// 003E12BD: void fn003E12BD(Stack (ptr32 Eq_214) dwArg04, Stack ptr32 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fn003E141D
void fn003E12BD(struct Eq_214 * dwArg04, ptr32 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_113;
	for (dwLoc08_113 = 0x00; dwLoc08_113 < dwArg0C; dwLoc08_113 += 0x02)
	{
		fn003E1286(dwArg04->t0004, dwArg08 + dwLoc08_113 * 0x04, 0x08);
		fn003E1250(dwArg08, dwArg04->t0000, dwArg08 + dwLoc08_113 * 0x04, 0x08);
	}
}

DWORD g_t3E1313(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 003E1313
// 003E1400: void fn003E1400(Stack (ptr32 Eq_242) dwArg04)
// Called from:
//      fn003E141D
void fn003E1400(struct Eq_242 * dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
}

// 003E141D: Register word32 fn003E141D()
// Called from:
//      Win32CrtStartup
word32 fn003E141D()
{
	ptr32 fp;
	Eq_259 tLoc44;
	Eq_260 tLoc38;
	Eq_12 tLoc2C;
	struct Eq_262 * v8_18 = fn003E1620()->ptr0030;
	if ((word32) v8_18->b0002 == 0x00)
	{
		g_dw413E1D = 0x53;
		g_dw413E1D += 4696;
		g_dw413E21 = 0x1454;
		g_dw413E25 = 0x7407;
		g_dw413E29 = 0x0ABE;
		g_dw413E29 += 10838;
		if (CreatePipe(&tLoc44, (char *) &tLoc38 + 4, null, 0x10) != 0x00 && CreatePipe(&tLoc38, (char *) (&tLoc44) + 4, null, 0x10) != 0x00)
		{
			Eq_160 eax_88 = CreateThread(null, 0x00, &g_t3E1313, &tLoc44, 0x00, &tLoc2C);
			fn003E12BD(&tLoc38, fp - 36, 0x08);
			fn003E12BD(&tLoc38, 0x003E3000, g_dw3EAA0B >> 0x02);
			fn003E1400(&tLoc38);
			fn003E1400(&tLoc44);
			CloseHandle(eax_88);
			struct Eq_68 * eax_164 = fn003E1000(0x003E3000);
			if (eax_164 != null)
			{
				Eq_3 v26_180 = eax_164->t0034.u0;
				fn003E101D(0x003E3000, &g_b3E3000, v26_180, eax_164->t0054);
				fn003E1630(eax_164, 0x003E3000, v26_180);
				struct Eq_68 * eax_223 = fn003E1000(v26_180);
				if (eax_223 != null)
				{
					fn003E1121(eax_223, v26_180);
					fn003E17C2(eax_223, v26_180);
					v8_18->t0008.u0 = (struct Eq_642 *) v26_180;
					<anonymous> * ecx_279 = v26_180.u0 + eax_164->dw0028;
					ecx_279();
				}
			}
		}
	}
	return 0x00;
}

// 003E1604: Register Eq_12 Win32CrtStartup()
Eq_12 Win32CrtStartup()
{
	ExitProcess(fn003E141D());
}

// 003E1620: Register word32 fn003E1620()
// Called from:
//      fn003E141D
word32 fn003E1620()
{
	struct Eq_424 * fs;
	return fs->dw0018;
}

// 003E1630: void fn003E1630(Stack (ptr32 Eq_68) dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C)
// Called from:
//      fn003E141D
void fn003E1630(struct Eq_68 * dwArg04, word32 dwArg08, Eq_3 dwArg0C)
{
	word16 ax_21 = dwArg04->w0006;
	word16 wLoc14_137;
	for (wLoc14_137 = 0x00; (word32) wLoc14_137 < (word32) ax_21; ++wLoc14_137)
	{
		Eq_11 dwLoc2C_147;
		Eq_11 v18_51 = (&dwArg04->dw0080 + 30)[((word32) wLoc14_137 *s 0x28 + 8) / 0x0084];
		Eq_11 v19_60 = (&dwArg04->dw0080 + 30)[((word32) wLoc14_137 *s 0x28 + 16) / 0x0084];
		if (v18_51 < v19_60)
			dwLoc2C_147 = v18_51;
		else
			dwLoc2C_147 = v19_60;
		fn003E1A03(dwArg0C + Mem90[(CONVERT(wLoc14_137, word16, word32) *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem100[(CONVERT(wLoc14_137, word16, word32) *s 0x28 + 20) + (dwArg04 + 0xF8):word32], dwLoc2C_147);
	}
}

// 003E16FD: Register ui32 fn003E16FD(Stack ui32 dwArg04)
// Called from:
//      fn003E17C2
ui32 fn003E16FD(ui32 dwArg04)
{
	ui32 dwLoc08_156 = 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_156 = 0x0200;
	ui32 dwLoc08_161;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_161 = dwLoc08_156 | 0x40;
			else
				dwLoc08_161 = dwLoc08_156 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_161 = dwLoc08_156 | 0x80;
		else
			dwLoc08_161 = dwLoc08_156 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_161 = dwLoc08_156 | 0x04;
		else
			dwLoc08_161 = dwLoc08_156 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_161 = dwLoc08_156 | 0x08;
	else
		dwLoc08_161 = dwLoc08_156 | 0x01;
	return dwLoc08_161;
}

// 003E17C2: void fn003E17C2(Stack (ptr32 Eq_68) dwArg04, Stack Eq_3 dwArg08)
// Called from:
//      fn003E141D
void fn003E17C2(struct Eq_68 * dwArg04, Eq_3 dwArg08)
{
	ptr32 fp;
	word16 ax_21 = dwArg04->w0006;
	word16 wLoc14_116;
	for (wLoc14_116 = 0x00; (word32) wLoc14_116 < (word32) ax_21; ++wLoc14_116)
		VirtualProtect(dwArg08 + Mem31[(CONVERT(wLoc14_116, word16, word32) *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], Mem50[CONVERT(wLoc14_116, word16, word32) *s 0x28 + 8 + (dwArg04 + 0xF8):word32], fn003E16FD(Mem67[CONVERT(wLoc14_116, word16, word32) *s 0x28 + 36 + (dwArg04 + 0xF8):word32]), fp - 24);
}

// 003E1A03: void fn003E1A03(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Stack Eq_11 dwArg0C)
// Called from:
//      fn003E101D
//      fn003E1630
void fn003E1A03(Eq_3 dwArg04, byte * dwArg08, Eq_11 dwArg0C)
{
	while (true)
	{
		--dwArg0C;
		if (dwArg0C == 0x00)
			break;
		dwArg04.u0->b0000 = *dwArg08;
		&dwArg04.u0->b0000 = (word32) dwArg04 + 1;
		++dwArg08;
	}
}

// 003E1A71: Register Eq_598 fn003E1A71(Stack Eq_34 dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn003E10AF
Eq_598 fn003E1A71(Eq_34 dwArg04, byte * dwArg08)
{
	while (true)
	{
		Eq_598 eax_31 = *dwArg04 - *dwArg08;
		Eq_598 dwLoc08_85 = eax_31;
		if (eax_31 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = (Eq_34) (dwArg04 + 1);
		++dwArg08;
	}
	if (eax_31 < 0x00)
		dwLoc08_85.u0 = ~0x00;
	else if (eax_31 > 0x00)
		dwLoc08_85.u0 = 0x01;
	return dwLoc08_85;
}

