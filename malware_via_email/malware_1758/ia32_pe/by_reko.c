// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t116AC; // 00411000
<anonymous> * __imp__lstrcmpiW = &g_t116BE; // 00411004
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t116CA; // 00411008
<anonymous> * __imp__GetModuleHandleA = &g_t116E6; // 0041100C
<anonymous> * __imp__SetLastError = &g_t116FA; // 00411010
<anonymous> * __imp__CreateEventW = &g_t1170A; // 00411014
<anonymous> * __imp__GetLastError = &g_t1171A; // 00411018
<anonymous> * __imp__GetProcessHeap = &g_t1172A; // 0041101C
<anonymous> * __imp__MultiByteToWideChar = &g_t1173C; // 00411020
<anonymous> * __imp__GetModuleFileNameW = &g_t11752; // 00411024
<anonymous> * __imp__GetModuleHandleW = &g_t11768; // 00411028
<anonymous> * __imp__LoadLibraryA = &g_t1177C; // 0041102C
<anonymous> * __imp__InterlockedDecrement = &g_t1178C; // 00411030
<anonymous> * __imp__CloseHandle = &g_t117A4; // 00411034
<anonymous> * __imp__EnterCriticalSection = &g_t117B2; // 00411038
<anonymous> * __imp__GetCurrentThreadId = &g_t117CA; // 0041103C
<anonymous> * __imp__HeapFree = &g_t117E0; // 00411040
<anonymous> * __imp__GetCurrentProcess = &g_t117EC; // 00411044
<anonymous> * __imp__InterlockedDecrement = &g_t11800; // 00411048
<anonymous> * __imp__CloseHandle = &g_t11818; // 0041104C
<anonymous> * __imp__GetLastError = &g_t11826; // 00411050
<anonymous> * __imp__GetCurrentThreadId = &g_t11836; // 00411054
<anonymous> * __imp__VirtualProtect = &g_t1184C; // 00411058
<anonymous> * __imp__GetProcAddress = &g_t1185E; // 0041105C
<anonymous> * __imp__UnhandledExceptionFilter = &g_t11870; // 00411060
<anonymous> * __imp__ReadFile = &g_t1188C; // 00411064
<anonymous> * __imp__GetModuleHandleW = &g_t11898; // 00411068
<anonymous> * __imp__GetVersionExA = &g_t118AC; // 0041106C
<anonymous> * __imp__GetModuleFileNameA = &g_t118BC; // 00411070
<anonymous> * __imp__LoadLibraryA = &g_t118D2; // 00411074
<anonymous> * __imp__GetModuleFileNameA = &g_t118E2; // 00411078
<anonymous> * __imp__LocalAlloc = &g_t118F8; // 0041107C
<anonymous> * __imp__GetModuleFileNameW = &g_t11906; // 00411080
<anonymous> * __imp__GetProcAddress = &g_t1191C; // 00411084
<anonymous> * __imp__ReadFile = &g_t1192E; // 00411088
<anonymous> * __imp__LoadLibraryA = &g_t1193A; // 0041108C
<anonymous> * __imp__LocalAlloc = &g_t1194A; // 00411090
<anonymous> * __imp__CreateFileW = &g_t11958; // 00411094
<anonymous> * __imp__DeleteCriticalSection = &g_t11966; // 00411098
<anonymous> * __imp__GetCurrentThreadId = &g_t1197E; // 0041109C
<anonymous> * __imp__GetModuleFileNameA = &g_t11994; // 004110A0
<anonymous> * __imp__QueryPerformanceCounter = &g_t119AA; // 004110A4
<anonymous> * __imp__CloseHandle = &g_t119C4; // 004110A8
<anonymous> * __imp__GetModuleFileNameA = &g_t119D2; // 004110AC
<anonymous> * __imp__GetProcAddress = &g_t119E8; // 004110B0
<anonymous> * __imp__GetModuleHandleW = &g_t119FA; // 004110B4
<anonymous> * __imp__GetCurrentThreadId = &g_t11A0E; // 004110B8
<anonymous> * __imp__InitializeCriticalSection = &g_t11A24; // 004110BC
<anonymous> * __imp__CreateEventW = &g_t11A40; // 004110C0
<anonymous> * __imp__CreateThread = &g_t11A50; // 004110C4
<anonymous> * __imp__lstrlenA = &g_t11A60; // 004110C8
<anonymous> * __imp__VirtualProtect = &g_t11A6C; // 004110CC
<anonymous> * __imp__HeapDestroy = &g_t11A7E; // 004110D0
<anonymous> * __imp__InitializeCriticalSection = &g_t11A8C; // 004110D4
<anonymous> * __imp__LocalAlloc = &g_t11AA8; // 004110D8
<anonymous> * __imp__ReadFile = &g_t11AB6; // 004110DC
<anonymous> * __imp__VirtualProtect = &g_t11AC2; // 004110E0
<anonymous> * __imp__VirtualProtect = &g_t11AD4; // 004110E4
<anonymous> * __imp__InitializeCriticalSection = &g_t11AE6; // 004110E8
<anonymous> * __imp__LoadLibraryW = &g_t11B02; // 004110EC
<anonymous> * __imp__InitializeCriticalSection = &g_t11B12; // 004110F0
<anonymous> * __imp__InterlockedExchange = &g_t11B2E; // 004110F4
<anonymous> * __imp__GetModuleFileNameA = &g_t11B44; // 004110F8
<anonymous> * __imp__GetTickCount = &g_t11B5A; // 004110FC
<anonymous> * __imp__HeapAlloc = &g_t11B6A; // 00411100
<anonymous> * __imp__CreateEventW = &g_t11B76; // 00411104
<anonymous> * __imp__BitBlt = &g_t11B94; // 0041110C
<anonymous> * __imp__SetBkColor = &g_t11B9E; // 00411110
<anonymous> * __imp__CreateDIBitmap = &g_t11BAC; // 00411114
<anonymous> * __imp__CreateFontA = &g_t11BBE; // 00411118
<anonymous> * __imp__PatBlt = &g_t11BCC; // 0041111C
<anonymous> * __imp__CreateBitmap = &g_t11BD6; // 00411120
<anonymous> * __imp__StretchBlt = &g_t11BE6; // 00411124
<anonymous> * __imp__GetBkMode = &g_t11BF4; // 00411128
<anonymous> * __imp__SetWindowOrgEx = &g_t11C00; // 0041112C
<anonymous> * __imp__CreateRectRgn = &g_t11C12; // 00411130
<anonymous> * __imp__CreateBitmap = &g_t11C22; // 00411134
<anonymous> * __imp__GetBkMode = &g_t11C32; // 00411138
<anonymous> * __imp__GetWindowExtEx = &g_t11C3E; // 0041113C
<anonymous> * __imp__BitBlt = &g_t11C50; // 00411140
<anonymous> * __imp__SetWindowExtEx = &g_t11C5A; // 00411144
<anonymous> * __imp__CombineRgn = &g_t11C6C; // 00411148
<anonymous> * __imp__GetBkColor = &g_t11C7A; // 0041114C
<anonymous> * __imp__SetPixel = &g_t11C88; // 00411150
<anonymous> * __imp__CreateCompatibleDC = &g_t11C94; // 00411154
<anonymous> * __imp__Ellipse = &g_t11CAA; // 00411158
<anonymous> * __imp__RoundRect = &g_t11CB4; // 0041115C
<anonymous> * __imp__CreateBitmapIndirect = &g_t11CC0; // 00411160
<anonymous> * __imp__GetBkMode = &g_t11CD8; // 00411164
<anonymous> * __imp__CreateDIBSection = &g_t11CE4; // 00411168
<anonymous> * __imp__SetTextColor = &g_t11CF8; // 0041116C
<anonymous> * __imp__CreateBitmapIndirect = &g_t11D08; // 00411170
<anonymous> * __imp__GetBkColor = &g_t11D20; // 00411174
<anonymous> * __imp__SelectObject = &g_t11D2E; // 00411178
<anonymous> * __imp__GetCurrentObject = &g_t11D3E; // 0041117C
<anonymous> * __imp__LineTo = &g_t11D52; // 00411180
<anonymous> * __imp__SetBkMode = &g_t11D5C; // 00411184
<anonymous> * __imp__CreateBitmapIndirect = &g_t11D68; // 00411188
<anonymous> * __imp__BitBlt = &g_t11D80; // 0041118C
<anonymous> * __imp__CreateFontIndirectA = &g_t11D8A; // 00411190
<anonymous> * __imp__SetWindowExtEx = &g_t11DA0; // 00411194
<anonymous> * __imp__SetBrushOrgEx = &g_t11DB2; // 00411198
<anonymous> * __imp__CreatePen = &g_t11DC2; // 0041119C
<anonymous> * __imp__GetBkMode = &g_t11DCE; // 004111A0
<anonymous> * __imp__CombineRgn = &g_t11DDA; // 004111A4
<anonymous> * __imp__SetPixel = &g_t11DE8; // 004111A8
<anonymous> * __imp__LineTo = &g_t11DF4; // 004111AC
<anonymous> * __imp__RoundRect = &g_t11DFE; // 004111B0
<anonymous> * __imp__GetCurrentObject = &g_t11E0A; // 004111B4
<anonymous> * __imp__GetCurrentObject = &g_t11E1E; // 004111B8
<anonymous> * __imp__Rectangle = &g_t11E32; // 004111BC
<anonymous> * __imp__CreateFontIndirectA = &g_t11E3E; // 004111C0
<anonymous> * __imp__CreatePen = &g_t11E54; // 004111C4
<anonymous> * __imp__GetWindowExtEx = &g_t11E60; // 004111C8
<anonymous> * __imp__GetBkColor = &g_t11E72; // 004111CC
<anonymous> * __imp__RoundRect = &g_t11E80; // 004111D0
<anonymous> * __imp__SetTextColor = &g_t11E8C; // 004111D4
<anonymous> * __imp__Ellipse = &g_t11E9C; // 004111D8
<anonymous> * __imp__RoundRect = &g_t11EA6; // 004111DC
<anonymous> * __imp__CreateBitmapIndirect = &g_t11EB2; // 004111E0
<anonymous> * __imp__CreateFontIndirectA = &g_t11ECA; // 004111E4
<anonymous> * __imp__MoveToEx = &g_t11EE0; // 004111E8
<anonymous> * __imp__SetTextColor = &g_t11EEC; // 004111EC
<anonymous> * __imp__CreateFontIndirectA = &g_t11EFC; // 004111F0
<anonymous> * __imp__SelectObject = &g_t11F12; // 004111F4
<anonymous> * __imp__GetBkColor = &g_t11F22; // 004111F8
<anonymous> * __imp__CreateRectRgn = &g_t11F30; // 004111FC
<anonymous> * __imp__CreateRectRgn = &g_t11F40; // 00411200
<anonymous> * __imp__PatBlt = &g_t11F50; // 00411204
<anonymous> * __imp__GetBkMode = &g_t11F5A; // 00411208
<anonymous> * __imp__TranslateMessage = &g_t11F70; // 00411210
<anonymous> * __imp__CharNextW = &g_t11F84; // 00411214
<anonymous> * __imp__PostMessageW = &g_t11F90; // 00411218
<anonymous> * __imp__GetWindowLongW = &g_t11FA0; // 0041121C
<anonymous> * __imp__SetWindowTextW = &g_t11FB2; // 00411220
<anonymous> * __imp__SetWindowPos = &g_t11FC4; // 00411224
<anonymous> * __imp__KillTimer = &g_t11FD4; // 00411228
<anonymous> * __imp__GetSystemMetrics = &g_t11FE0; // 0041122C
<anonymous> * __imp__BeginPaint = &g_t11FF4; // 00411230
<anonymous> * __imp__IsDlgButtonChecked = &g_t12002; // 00411234
<anonymous> * __imp__GetWindowRect = &g_t12018; // 00411238
<anonymous> * __imp__TranslateMessage = &g_t12028; // 0041123C
<anonymous> * __imp__ShowWindow = &g_t1203C; // 00411240
<anonymous> * __imp__wsprintfA = &g_t1204A; // 00411244
<anonymous> * __imp__SetForegroundWindow = &g_t12056; // 00411248
<anonymous> * __imp__LoadIconW = &g_t1206C; // 0041124C
<anonymous> * __imp__SetTimer = &g_t12078; // 00411250
<anonymous> * __imp__IsWindow = &g_t12084; // 00411254
<anonymous> * __imp__GetDesktopWindow = &g_t12090; // 00411258
<anonymous> * __imp__SetWindowPos = &g_t120A4; // 0041125C
<anonymous> * __imp__LoadStringW = &g_t120B4; // 00411260
<anonymous> * __imp__GetDlgItem = &g_t120C2; // 00411264
<anonymous> * __imp__SendDlgItemMessageW = &g_t120D0; // 00411268
<anonymous> * __imp__CreateWindowExW = &g_t120E6; // 0041126C
<anonymous> * __imp__SetWindowTextW = &g_t120F8; // 00411270
<anonymous> * __imp__ReleaseDC = &g_t1210A; // 00411274
<anonymous> * __imp__GetClientRect = &g_t12116; // 00411278
<anonymous> * __imp__TranslateMessage = &g_t12126; // 0041127C
<anonymous> * __imp__LoadIconW = &g_t1213A; // 00411280
<anonymous> * __imp__LoadStringW = &g_t12146; // 00411284
<anonymous> * __imp__EnableWindow = &g_t12154; // 00411288
<anonymous> * __imp__EnableWindow = &g_t12164; // 0041128C
<anonymous> * __imp__CreateWindowExW = &g_t12174; // 00411290
<anonymous> * __imp__CreateWindowExW = &g_t12186; // 00411294
<anonymous> * __imp__LoadCursorW = &g_t12198; // 00411298
<anonymous> * __imp__IsDlgButtonChecked = &g_t121A6; // 0041129C
<anonymous> * __imp__EndDialog = &g_t121BC; // 004112A0
<anonymous> * __imp__SendDlgItemMessageW = &g_t121C8; // 004112A4
<anonymous> * __imp__SetFocus = &g_t121DE; // 004112A8
<anonymous> * __imp__CreateWindowExW = &g_t121EA; // 004112AC
<anonymous> * __imp__EndPaint = &g_t121FC; // 004112B0
<anonymous> * __imp__PeekMessageW = &g_t12208; // 004112B4
<anonymous> * __imp__GetWindowLongW = &g_t12218; // 004112B8
<anonymous> * __imp__SendDlgItemMessageW = &g_t1222A; // 004112BC
<anonymous> * __imp__KillTimer = &g_t12240; // 004112C0
<anonymous> * __imp__SetFocus = &g_t1224C; // 004112C4
<anonymous> * __imp__DefWindowProcW = &g_t12258; // 004112C8
<anonymous> * __imp__KillTimer = &g_t1226A; // 004112CC
<anonymous> * __imp__SetCursor = &g_t12276; // 004112D0
<anonymous> * __imp__InvalidateRect = &g_t12282; // 004112D4
<anonymous> * __imp__IsWindow = &g_t12294; // 004112D8
<anonymous> * __imp__SetCursor = &g_t122A0; // 004112DC
<anonymous> * __imp__DialogBoxParamW = &g_t122AC; // 004112E0
<anonymous> * __imp__BeginPaint = &g_t122BE; // 004112E4
<anonymous> * __imp__SetWindowTextW = &g_t122CC; // 004112E8
<anonymous> * __imp__CharNextW = &g_t122DE; // 004112EC
<anonymous> * __imp__DispatchMessageW = &g_t122EA; // 004112F0
<anonymous> * __imp__DestroyWindow = &g_t122FE; // 004112F4
<anonymous> * __imp__LoadIconW = &g_t1230E; // 004112F8
<anonymous> * __imp__CharNextW = &g_t1231A; // 004112FC
<anonymous> * __imp__SetForegroundWindow = &g_t12326; // 00411300
<anonymous> * __imp__BeginPaint = &g_t1233C; // 00411304
<anonymous> * __imp__DestroyWindow = &g_t1234A; // 00411308
<anonymous> * __imp__TranslateMessage = &g_t1235A; // 0041130C
<anonymous> * __imp__GetParent = &g_t1236E; // 00411310
<anonymous> * __imp__GetDlgItem = &g_t1237A; // 00411314
<anonymous> * __imp__SetDlgItemTextW = &g_t12388; // 00411318
<anonymous> * __imp__GetWindowRect = &g_t1239A; // 0041131C
<anonymous> * __imp__InvalidateRect = &g_t123AA; // 00411320
<anonymous> * __imp__SetWindowTextW = &g_t123BC; // 00411324
word32 g_dw411380 = 0x000116AC; // 00411380
word32 g_dw411384 = 0x000116BE; // 00411384
word32 g_dw411388 = 0x000116CA; // 00411388
word32 g_dw41138C = 0x000116E6; // 0041138C
word32 g_dw411390 = 0x000116FA; // 00411390
word32 g_dw411394 = 0x0001170A; // 00411394
word32 g_dw411398 = 0x0001171A; // 00411398
word32 g_dw41139C = 0x0001172A; // 0041139C
word32 g_dw4113A0 = 0x0001173C; // 004113A0
word32 g_dw4113A4 = 0x00011752; // 004113A4
word32 g_dw4113A8 = 0x00011768; // 004113A8
word32 g_dw4113AC = 0x0001177C; // 004113AC
word32 g_dw4113B0 = 0x0001178C; // 004113B0
word32 g_dw4113B4 = 0x000117A4; // 004113B4
word32 g_dw4113B8 = 0x000117B2; // 004113B8
word32 g_dw4113BC = 0x000117CA; // 004113BC
word32 g_dw4113C0 = 0x000117E0; // 004113C0
word32 g_dw4113C4 = 0x000117EC; // 004113C4
word32 g_dw4113C8 = 0x00011800; // 004113C8
word32 g_dw4113CC = 0x00011818; // 004113CC
word32 g_dw4113D0 = 71718; // 004113D0
word32 g_dw4113D4 = 0x00011836; // 004113D4
word32 g_dw4113D8 = 0x0001184C; // 004113D8
word32 g_dw4113DC = 71774; // 004113DC
word32 g_dw4113E0 = 0x00011870; // 004113E0
word32 g_dw4113E4 = 0x0001188C; // 004113E4
word32 g_dw4113E8 = 0x00011898; // 004113E8
word32 g_dw4113EC = 0x000118AC; // 004113EC
word32 g_dw4113F0 = 0x000118BC; // 004113F0
word32 g_dw4113F4 = 0x000118D2; // 004113F4
word32 g_dw4113F8 = 0x000118E2; // 004113F8
word32 g_dw4113FC = 0x000118F8; // 004113FC
word32 g_dw411400 = 0x00011906; // 00411400
word32 g_dw411404 = 0x0001191C; // 00411404
word32 g_dw411408 = 0x0001192E; // 00411408
word32 g_dw41140C = 0x0001193A; // 0041140C
word32 g_dw411410 = 0x0001194A; // 00411410
word32 g_dw411414 = 0x00011958; // 00411414
word32 g_dw411418 = 0x00011966; // 00411418
word32 g_dw41141C = 0x0001197E; // 0041141C
word32 g_dw411420 = 0x00011994; // 00411420
word32 g_dw411424 = 0x000119AA; // 00411424
word32 g_dw411428 = 0x000119C4; // 00411428
word32 g_dw41142C = 0x000119D2; // 0041142C
word32 g_dw411430 = 0x000119E8; // 00411430
word32 g_dw411434 = 0x000119FA; // 00411434
word32 g_dw411438 = 0x00011A0E; // 00411438
word32 g_dw41143C = 72228; // 0041143C
word32 g_dw411440 = 0x00011A40; // 00411440
word32 g_dw411444 = 72272; // 00411444
word32 g_dw411448 = 72288; // 00411448
word32 g_dw41144C = 0x00011A6C; // 0041144C
word32 g_dw411450 = 0x00011A7E; // 00411450
word32 g_dw411454 = 72332; // 00411454
word32 g_dw411458 = 0x00011AA8; // 00411458
word32 g_dw41145C = 0x00011AB6; // 0041145C
word32 g_dw411460 = 0x00011AC2; // 00411460
word32 g_dw411464 = 0x00011AD4; // 00411464
word32 g_dw411468 = 72422; // 00411468
word32 g_dw41146C = 0x00011B02; // 0041146C
word32 g_dw411470 = 0x00011B12; // 00411470
word32 g_dw411474 = 0x00011B2E; // 00411474
word32 g_dw411478 = 0x00011B44; // 00411478
word32 g_dw41147C = 0x00011B5A; // 0041147C
word32 g_dw411480 = 0x00011B6A; // 00411480
word32 g_dw411484 = 0x00011B76; // 00411484
word32 g_dw41148C = 0x00011B94; // 0041148C
word32 g_dw411490 = 0x00011B9E; // 00411490
word32 g_dw411494 = 0x00011BAC; // 00411494
word32 g_dw411498 = 0x00011BBE; // 00411498
word32 g_dw41149C = 0x00011BCC; // 0041149C
word32 g_dw4114A0 = 72662; // 004114A0
word32 g_dw4114A4 = 0x00011BE6; // 004114A4
word32 g_dw4114A8 = 0x00011BF4; // 004114A8
word32 g_dw4114AC = 0x00011C00; // 004114AC
word32 g_dw4114B0 = 72722; // 004114B0
word32 g_dw4114B4 = 0x00011C22; // 004114B4
word32 g_dw4114B8 = 0x00011C32; // 004114B8
word32 g_dw4114BC = 72766; // 004114BC
word32 g_dw4114C0 = 0x00011C50; // 004114C0
word32 g_dw4114C4 = 0x00011C5A; // 004114C4
word32 g_dw4114C8 = 0x00011C6C; // 004114C8
word32 g_dw4114CC = 0x00011C7A; // 004114CC
word32 g_dw4114D0 = 0x00011C88; // 004114D0
word32 g_dw4114D4 = 0x00011C94; // 004114D4
word32 g_dw4114D8 = 0x00011CAA; // 004114D8
word32 g_dw4114DC = 0x00011CB4; // 004114DC
word32 g_dw4114E0 = 0x00011CC0; // 004114E0
word32 g_dw4114E4 = 0x00011CD8; // 004114E4
word32 g_dw4114E8 = 0x00011CE4; // 004114E8
word32 g_dw4114EC = 0x00011CF8; // 004114EC
word32 g_dw4114F0 = 0x00011D08; // 004114F0
word32 g_dw4114F4 = 72992; // 004114F4
word32 g_dw4114F8 = 0x00011D2E; // 004114F8
word32 g_dw4114FC = 0x00011D3E; // 004114FC
word32 g_dw411500 = 0x00011D52; // 00411500
word32 g_dw411504 = 0x00011D5C; // 00411504
word32 g_dw411508 = 0x00011D68; // 00411508
word32 g_dw41150C = 0x00011D80; // 0041150C
word32 g_dw411510 = 0x00011D8A; // 00411510
word32 g_dw411514 = 0x00011DA0; // 00411514
word32 g_dw411518 = 0x00011DB2; // 00411518
word32 g_dw41151C = 0x00011DC2; // 0041151C
word32 g_dw411520 = 0x00011DCE; // 00411520
word32 g_dw411524 = 0x00011DDA; // 00411524
word32 g_dw411528 = 0x00011DE8; // 00411528
word32 g_dw41152C = 0x00011DF4; // 0041152C
word32 g_dw411530 = 0x00011DFE; // 00411530
word32 g_dw411534 = 0x00011E0A; // 00411534
word32 g_dw411538 = 0x00011E1E; // 00411538
word32 g_dw41153C = 0x00011E32; // 0041153C
word32 g_dw411540 = 0x00011E3E; // 00411540
word32 g_dw411544 = 73300; // 00411544
word32 g_dw411548 = 0x00011E60; // 00411548
word32 g_dw41154C = 73330; // 0041154C
word32 g_dw411550 = 73344; // 00411550
word32 g_dw411554 = 0x00011E8C; // 00411554
word32 g_dw411558 = 73372; // 00411558
word32 g_dw41155C = 0x00011EA6; // 0041155C
word32 g_dw411560 = 0x00011EB2; // 00411560
word32 g_dw411564 = 0x00011ECA; // 00411564
word32 g_dw411568 = 0x00011EE0; // 00411568
word32 g_dw41156C = 0x00011EEC; // 0041156C
word32 g_dw411570 = 0x00011EFC; // 00411570
word32 g_dw411574 = 0x00011F12; // 00411574
word32 g_dw411578 = 0x00011F22; // 00411578
word32 g_dw41157C = 0x00011F30; // 0041157C
word32 g_dw411580 = 0x00011F40; // 00411580
word32 g_dw411584 = 0x00011F50; // 00411584
word32 g_dw411588 = 0x00011F5A; // 00411588
word32 g_dw411590 = 0x00011F70; // 00411590
word32 g_dw411594 = 0x00011F84; // 00411594
word32 g_dw411598 = 0x00011F90; // 00411598
word32 g_dw41159C = 0x00011FA0; // 0041159C
word32 g_dw4115A0 = 0x00011FB2; // 004115A0
word32 g_dw4115A4 = 0x00011FC4; // 004115A4
word32 g_dw4115A8 = 0x00011FD4; // 004115A8
word32 g_dw4115AC = 0x00011FE0; // 004115AC
word32 g_dw4115B0 = 0x00011FF4; // 004115B0
word32 g_dw4115B4 = 0x00012002; // 004115B4
word32 g_dw4115B8 = 0x00012018; // 004115B8
word32 g_dw4115BC = 0x00012028; // 004115BC
word32 g_dw4115C0 = 73788; // 004115C0
word32 g_dw4115C4 = 0x0001204A; // 004115C4
word32 g_dw4115C8 = 0x00012056; // 004115C8
word32 g_dw4115CC = 73836; // 004115CC
word32 g_dw4115D0 = 73848; // 004115D0
word32 g_dw4115D4 = 0x00012084; // 004115D4
word32 g_dw4115D8 = 0x00012090; // 004115D8
word32 g_dw4115DC = 0x000120A4; // 004115DC
word32 g_dw4115E0 = 0x000120B4; // 004115E0
word32 g_dw4115E4 = 0x000120C2; // 004115E4
word32 g_dw4115E8 = 0x000120D0; // 004115E8
word32 g_dw4115EC = 0x000120E6; // 004115EC
word32 g_dw4115F0 = 73976; // 004115F0
word32 g_dw4115F4 = 0x0001210A; // 004115F4
word32 g_dw4115F8 = 0x00012116; // 004115F8
word32 g_dw4115FC = 0x00012126; // 004115FC
word32 g_dw411600 = 0x0001213A; // 00411600
word32 g_dw411604 = 0x00012146; // 00411604
word32 g_dw411608 = 0x00012154; // 00411608
word32 g_dw41160C = 0x00012164; // 0041160C
word32 g_dw411610 = 0x00012174; // 00411610
word32 g_dw411614 = 0x00012186; // 00411614
word32 g_dw411618 = 0x00012198; // 00411618
word32 g_dw41161C = 0x000121A6; // 0041161C
word32 g_dw411620 = 0x000121BC; // 00411620
word32 g_dw411624 = 0x000121C8; // 00411624
word32 g_dw411628 = 0x000121DE; // 00411628
word32 g_dw41162C = 0x000121EA; // 0041162C
word32 g_dw411630 = 0x000121FC; // 00411630
word32 g_dw411634 = 0x00012208; // 00411634
word32 g_dw411638 = 0x00012218; // 00411638
word32 g_dw41163C = 0x0001222A; // 0041163C
word32 g_dw411640 = 0x00012240; // 00411640
word32 g_dw411644 = 0x0001224C; // 00411644
word32 g_dw411648 = 0x00012258; // 00411648
word32 g_dw41164C = 0x0001226A; // 0041164C
word32 g_dw411650 = 0x00012276; // 00411650
word32 g_dw411654 = 0x00012282; // 00411654
word32 g_dw411658 = 0x00012294; // 00411658
word32 g_dw41165C = 74400; // 0041165C
word32 g_dw411660 = 0x000122AC; // 00411660
word32 g_dw411664 = 0x000122BE; // 00411664
word32 g_dw411668 = 74444; // 00411668
word32 g_dw41166C = 0x000122DE; // 0041166C
word32 g_dw411670 = 74474; // 00411670
word32 g_dw411674 = 74494; // 00411674
word32 g_dw411678 = 0x0001230E; // 00411678
word32 g_dw41167C = 0x0001231A; // 0041167C
word32 g_dw411680 = 0x00012326; // 00411680
word32 g_dw411684 = 0x0001233C; // 00411684
word32 g_dw411688 = 74570; // 00411688
word32 g_dw41168C = 0x0001235A; // 0041168C
word32 g_dw411690 = 74606; // 00411690
word32 g_dw411694 = 0x0001237A; // 00411694
word32 g_dw411698 = 0x00012388; // 00411698
word32 g_dw41169C = 0x0001239A; // 0041169C
word32 g_dw4116A0 = 74666; // 004116A0
word32 g_dw4116A4 = 74684; // 004116A4
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040C146: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
Win32CrtStartup_entry:
	esp = fp
	Top = null
	&ch.u4->u0 = &(C.u4 + ((byte) ch + 0x00CE) /8 6)->u0
	&SCZO.u4->u0 = cond(ch)
	dh = ch
	ah = ah + cl + C
	&SCZO.u4->u0 = cond(ah)
	bl = bl + dh + C
	ebx = ebx >> cl
	&SCZO.u4->u0 = cond(ebx)
	ebx = ebx - ecx - C
	dh.u0 = 0x7E
	bh = bh << cl
	&SCZO.u4->u0 = cond(bh)
	branch Test(PE,P) l0040C8F3
	goto l0040C15D
l0040BEEC:
l0040BF42:
	eax = eax | esi
	bl = al
	v51 = (ebx & 0x01 << cl) != 0x00
	ebx = __ror<word32,byte>(ebx, cl)
	al = al | bh
	ah = ah >> cl
	&SCZO.u4->u0 = cond(ah)
	v52 = (eax & 0x01 << cl) != 0x00
	eax = __rcr<word32,byte>(eax, cl, C)
	bh = bh & al
	C.u0 = false
	&bh.u4->u0 = (bool) C.u0 + ((byte) bh + 0x00B4)
	&SCZO.u4->u0 = cond(bh)
	&ebx.u4->u0 = (word32) ebx + 1
	v53 = (cl & 0x01 << 0x08 - cl) != 0x00
	cl = __rcl<byte,byte>(cl, cl, C)
	C = v53
	eax = eax + esi + C
	al = al ^ 0xA0
	SZ = cond(al)
	O = false
	C.u0 = false
	ch = ch | 0x69
	SZ = cond(ch)
	O = false
	C.u0 = false
l0040BF64:
	ecx = ecx - esi
	&SCZO.u4->u0 = cond(ecx)
	&cl.u4->u0 = (bool) C.u0 + ((byte) cl + 73)
	ch = dh
	ecx = ecx + edx
	ecx = ecx - 0x01
	cl = cl | dl
	SZ = cond(cl)
	O = false
	v81 = (ebx & 0x01 << cl) != 0x00
	ebx = __ror<word32,byte>(ebx, cl)
	C = v81
	fn0040D515()
	&esp.u4->u0 = (word32) esp - 5536
	goto l0040C944
l0040BF77:
	ah = ah & ~0x48
	dl = dl + cl
	al = al << cl
	ebx = ebx << cl
	&SCZO.u4->u0 = cond(ebx)
	esi = ebx
	&dh.u4->u0 = (byte) dh + 1
	SZO = cond(dh)
	ah = ah << cl
	&SCZO.u4->u0 = cond(ah)
	goto l0040BF86
l0040BF83:
	dl.u0 = 228
	goto l0040BF86
l0040BF84:
l0040BF86:
	branch Test(OV,O) l0040BF91
l0040BF88:
	edx = edx
	ebx = ebx
	branch Test(NO,O) l0040BF91
l0040BF8E:
	edi.u0 = 4161495967
	goto l0040BF93
l0040BF91:
	edi = edi | eax
	SZ = cond(edi)
	O = false
	C.u0 = false
l0040BF93:
	&SCZO.u4->u0 = cond(ecx - 50820)
	branch Test(EQ,Z) l0040BFE0
l0040BF9B:
	&edi.u4->u0 = (byte) edi.u0 + 1
	ebx = ebx + edx + C
	v147 = (esi & 0x01 << cl) != 0x00
	esi = __ror<word32,byte>(esi, cl)
	al = al | 0x12
	C.u0 = false
	bl = bl - 0x01
	SZO = cond(bl)
	dh = dh ^ bl
	eax = eax | edi
	C.u0 = false
	bl = bl - cl - C
	&ah.u4->u0 = (byte) ah + 1
	esi = esi - 0x01
	bh = bh ^ ah
	v148 = (esi & 0x01 << 0x20 - cl) != 0x00
	esi = __rol<word32,byte>(esi, cl)
	ecx = ecx - edi
	ecx = ecx | edi
	ecx = ecx | edx
	dl = dl ^ 0x08
	SZ = cond(dl)
	O = false
	C.u0 = false
	ebx = esi
	goto l0040C03D
l0040BFAE:
l0040BFB1:
	v43 = (al & 0x01 << cl) != 0x00
	al = __ror<byte,byte>(al, cl)
	C = v43
	edi = edi + ebx + C
	ecx = ecx | esi
	C.u0 = false
	edi = edi + eax + C
	cl = cl + al
	bl = bl ^ 0x06
	eax = eax >> cl
	eax = eax - ecx
	ch = ch - 0x0C
	cl = cl + ah
	&SCZO.u4->u0 = cond(cl)
	branch Test(OV,O) l0040BF42
l0040BFCE:
	edx = edx
	ebx = ebx
	branch Test(NO,O) l0040BF42
l0040BFD8:
	branch Test(SG,S) l0040BF83
l0040BFDA:
	esi = esi - 0x01
	SZO = cond(esi)
	ah.u0 = 131
	branch ecx == 0x00 l0040BFB1
l0040BFDE:
	v166 = (ah & 0x01 << 0x08 - cl) != 0x00
	ah = __rol<byte,byte>(ah, cl)
	C = v166
l0040BFDF:
	es_esp = *edx.u0
l0040BFE0:
	edx = edx << cl
	ebx = ebx << cl
	&SCZO.u4->u0 = cond(ebx)
	ebx = ebx >> cl
	SCZ = cond(ebx)
	v45 = (ecx & 0x01 << cl) != 0x00
	ecx = __ror<word32,byte>(ecx, cl)
	C = v45
	v54 = (eax & 0x01 << 0x20 - cl) != 0x00
	eax = __rcl<word32,byte>(eax, cl, C)
	C = v54
	goto l0040C6DA
l0040BFF2:
	al = al + bl
	edi = edi | eax
	bh = dh
	edi = edi & edx
	C.u0 = false
	edi = edi - esi - C
	ebx = ebx << cl
	&SCZO.u4->u0 = cond(ebx)
	branch Test(LT,SO) l0040C6FD
l0040C004:
	edx = edx
	ebx = ebx
	branch Test(GE,SO) l0040C6FD
l0040C00E:
	&ecx.u4->u0 = (word32) ecx + 1
	SZO = cond(ecx)
	__out<word32>(dx, eax)
	branch Test(GE,SO) l0040BFDE
l0040C012:
	v162 = *ebx.u7 - 3474704907 - C
	*ebx.u7 = v162
	&SCZO.u4->u0 = cond(v162)
	goto l0040C018
l0040C014:
l0040C018:
	eax = eax - ebx
	v128 = (dl & 0x01 << 0x08 - cl) != 0x00
	dl = __rol<byte,byte>(dl, cl)
	C = v128
	ebx = ebx + edi + C
	ecx = __pextrw<word64>(mm2, 0x04)
	v130 = (ah & 0x01 << 0x08 - cl) != 0x00
	ah = __rol<byte,byte>(ah, cl)
	C = v130
	v131 = (bl & 0x01 << 0x08 - cl) != 0x00
	bl = __rcl<byte,byte>(bl, cl, C)
	C = v131
	v132 = (dl & 0x01 << 0x08 - cl) != 0x00
	dl = __rcl<byte,byte>(dl, cl, C)
	al = al << cl
	&SCZO.u4->u0 = cond(al)
	branch Test(PE,P) l0040BF77
l0040C030:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040BF77
l0040C03A:
l0040C03D:
	bh = bh & 0xC2
	dl = dl & 0x33
	v151 = (esi & 0x01 << cl) != 0x00
	esi = __ror<word32,byte>(esi, cl)
	C = v151
	v152 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rcl<word32,byte>(edi, cl, C)
	al = al | 0x35
	dh = dh ^ al
	ecx = ecx & esi
	C.u0 = false
	cl = cl - 131 - C
	ch = ch << cl
	&SCZO.u4->u0 = cond(ch)
l0040C052:
	ch = ch - 0x01
	SZO = cond(ch)
	v153 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rcl<byte,byte>(dh, cl, C)
	C = v153
	branch Test(EQ,Z) l0040C3AB
l0040C05D:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C3AB
l0040C067:
	ds_ecx = *((char *) esi.u7 + esi * 0x02)
	esp = esp - 2
	*esp.u7 = es
	branch Test(EQ,Z) l0040C052
l0040C06D:
	edi = edi ^ eax
	eax = eax >> cl
	SCZ = cond(eax)
	bh = bh - cl - C
	bh = bh - ch
	&SCZO.u4->u0 = cond(bh)
	v72 = (edi & 0x01 << cl) != 0x00
	edi = __rcr<word32,byte>(edi, cl, C)
	&bh.u4->u0 = (byte) bh + 4
	&SCZO.u4->u0 = cond(bh)
	ebx = ecx
	al = al - ~0x25 - C
	v73 = (esi & 0x01 << cl) != 0x00
	esi = __ror<word32,byte>(esi, cl)
	dl.u0 = 252
	dh = dh | ch
	dh = dh & 0x80
	SZ = cond(dh)
	O = false
	C.u0 = false
	branch Test(LE,SZO) l0040C6A9
l0040C08E:
	edx = edx
	ebx = ebx
	branch Test(GT,SZO) l0040C6A9
l0040C098:
	eax = __in<word32>(114)
l0040C09C:
	&bh.u4->u0 = (byte) bh + 1
	dh.u0 = 0x7C
	v184 = (ebx & 0x01 << cl) != 0x00
	ebx = __ror<word32,byte>(ebx, cl)
	C = v184
	dl = dl + ah + C
	&SCZO.u4->u0 = cond(dl)
	v185 = (esi & 0x01 << 0x20 - cl) != 0x00
	esi = __rcl<word32,byte>(esi, cl, C)
	ecx = fs->t0030
	dh = dh & ah
	SZ = cond(dh)
	O = false
	C.u0 = false
	goto l0040C0E3
l0040C0B5:
	bh = bh >> cl
	cl = cl ^ ah
	bh = bh | cl
	C.u0 = false
	&bl.u4->u0 = (bool) C.u0 + ((byte) bl.u0 + 38)
	cl = cl - bl
	&SCZO.u4->u0 = cond(cl)
	&ch.u4->u0 = (bool) C.u0 + ((byte) ch.u0 + 141)
	v110 = (esi & 0x01 << 0x20 - cl) != 0x00
	esi = __rol<word32,byte>(esi, cl)
	bh = bh ^ ah
	ecx = ecx ^ ebx
	bh = cl
	ecx = ecx - eax
	&SCZO.u4->u0 = cond(ecx)
	branch Test(EQ,Z) l0040C535
l0040C0D3:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C535
l0040C0DD:
	branch Test(SG,S) l0040C11B
l0040C0DF:
	ecx.u0 = 0x8B99B298
l0040C0E3:
	bl = bl ^ ah
	v111 = (edi & 0x01 << cl) != 0x00
	edi = __ror<word32,byte>(edi, cl)
	C = v111
	v112 = (ebx & 0x01 << cl) != 0x00
	ebx = __rcr<word32,byte>(ebx, cl, C)
	C = v112
	esi = esi + edx + C
	edx = edx ^ ecx
	C.u0 = false
	edi = edi - 0x01
	v113 = (dh & 0x01 << cl) != 0x00
	dh = __rcr<byte,byte>(dh, cl, C)
	bh = bh ^ bl
	eax = eax - ecx
	&SCZO.u4->u0 = cond(eax)
	goto l0040C31B
l0040C102:
	bl = bl >> cl
	ah = ah >> cl
	bh = bh | 0x59
	C.u0 = false
	ecx = ecx - eax - C
	&SCZO.u4->u0 = cond(ecx)
	al = al + dh + C
	&al.u4->u0 = (byte) al + 41
	ebx = ebx ^ eax
	ebx = ebx + 0x01
	al = al ^ bl
	al = al & dh
	SZ = cond(al)
	O = false
	C.u0 = false
l0040C11B:
	ch = ch + al
	&SCZO.u4->u0 = cond(ch)
	ebx = ebx | ecx
	SZ = cond(ebx)
	O = false
	C.u0 = false
	goto l0040C259
l0040C123:
	ch = ch - 0x01
	edi = edi + eax + C
	dh = dh - 0x93
	&SCZO.u4->u0 = cond(dh)
	v149 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	ecx = ecx - 0x01
	bh = bh & 0x40
	eax = eax & ebx
	cl = cl - ch
	eax = eax & edi
	dh = dh | ch
	C.u0 = false
	&ecx.u4->u0 = (byte) ecx.u0 + 1
	&bh.u4->u0 = (byte) bh + 1
	SZO = cond(bh)
	v150 = (ebx & 0x01 << cl) != 0x00
	ebx = __rcr<word32,byte>(ebx, cl, C)
	C = v150
	&ah.u4->u0 = (bool) C.u0 + ((byte) ah + 0x0069)
	eax.u0 = 0x03
	edx = edx << cl
	&SCZO.u4->u0 = cond(edx)
	esi = esi - eax - C
	v156 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rol<byte,byte>(bh, cl)
	cl = cl & 0xAC
	edi = edi >> cl
	&SCZO.u4->u0 = cond(edi)
	v157 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rol<byte,byte>(ch, cl)
	v158 = (ch & 0x01 << cl) != 0x00
	ch = __ror<byte,byte>(ch, cl)
	C = v158
	goto l0040C285
l0040C146:
l0040C15D:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040C8F3
l0040C167:
	edi = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	__out<word32>(0xA9, eax)
l0040C16A:
	ecx = ecx + edi
	bh = bh >> cl
	eax = eax << cl
	ecx = ecx + esi
	&SCZO.u4->u0 = cond(ecx)
	ebx = ebx + eax + C
	ch = ch + bl
	bh = bh - 0x8A
	ecx = ecx << cl
	bl = bl >> cl
	&SCZO.u4->u0 = cond(bl)
	v19 = (al & 0x01 << 0x08 - cl) != 0x00
	al = __rol<byte,byte>(al, cl)
	C = v19
	goto l0040C4D0
l0040C189:
l0040C1A2:
l0040C1BA:
	edx = edx
	ebx = ebx
	branch Test(NO,O) l0040C786
l0040C1C4:
	v168 = (ebp - 67)[edi].b0000 - dl
	(ebp - 67)[edi].b0000 = v168
	&SCZO.u4->u0 = cond(v168)
	esp = ebp
	ebp = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
l0040C1CA:
	v82 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rol<word32,byte>(edi, cl)
	edx = edx ^ edx
	ch = ch << cl
	bl = bl >> cl
	cl = cl | 0x29
	C.u0 = false
	bh = bh + ch + C
	&SCZO.u4->u0 = cond(bh)
	v83 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rol<word32,byte>(edi, cl)
	C = v83
	ch.u0 = 0x1F
	esi = esi & edx
	C.u0 = false
	cl = cl - 100 - C
	&SCZO.u4->u0 = cond(cl)
	ecx = ecx + 0x01
	bl = bl - ah - C
	&SCZO.u4->u0 = cond(bl)
	ch = ch | 161
	C.u0 = false
	bl = bl + ah + C
	&SCZO.u4->u0 = cond(bl)
	goto l0040C2EF
l0040C1E1:
l0040C1F5:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C102
l0040C1FF:
	*(union Eq_3 *) 0xB0970776 = al
	v59 = *ebx.u7
	*ebx.u7 = esi
	esi = v59
	goto l0040C206
l0040C205:
l0040C206:
	ch = ch + dl
	&SCZO.u4->u0 = cond(ch)
l0040C208:
	v35 = (esi & 0x01 << 0x20 - cl) != 0x00
	esi = __rol<word32,byte>(esi, cl)
	C = v35
	ch = ch - dh - C
	&SCZO.u4->u0 = cond(ch)
l0040C20D:
	cl = cl + bh + C
	&SCZO.u4->u0 = cond(cl)
	v36 = (ah & 0x01 << cl) != 0x00
	ah = __rcr<byte,byte>(ah, cl, C)
	C = v36
	bh = bh - 0x1E - C
	bh = bh & 0x5C
	&cl.u4->u0 = (byte) cl + 0x00FB
	&SCZO.u4->u0 = cond(cl)
	v37 = (bl & 0x01 << cl) != 0x00
	bl = __rcr<byte,byte>(bl, cl, C)
	C = v37
	branch Test(SG,S) l0040C40B
l0040C222:
	edx = edx
	ebx = ebx
	branch Test(NS,S) l0040C40B
l0040C22C:
	esp = esp - 4
	*esp.u7 = ecx
	v39 = *((byte) edx.u0 + (ecx * 0x04 - 755510279))
	*((byte) edx.u0 + (ecx * 0x04 - 755510279)) = ebx
	ebx = v39
l0040C231:
	goto l0040C208
l0040C236:
	__cli()
	eax = eax - 0x01
	ch = bl
	ecx = ecx >> cl
	SCZ = cond(ecx)
	ch = ch + ah + C
	esi = esi << cl
	v89 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rol<word32,byte>(ebx, cl)
	C = v89
	eax = eax - ebx - C
	&SCZO.u4->u0 = cond(eax)
	branch Test(ULT,C) l0040C58F
l0040C24A:
	edx = edx
	ebx = ebx
	branch Test(UGE,C) l0040C58F
l0040C254:
	branch Test(NE,Z) l0040C2D3
l0040C256:
	__cli()
	eax = __in<word32>(11)
	goto l0040C259
l0040C258:
l0040C259:
	edi = edi + 0x01
	v74 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rcl<word32,byte>(edi, cl, C)
	eax = eax | esi
	ecx = ebx
	ebx = ebx & esi
	&ah.u4->u0 = (byte) ah.u0 + 1
	edi = edi | eax
	v75 = (al & 0x01 << cl) != 0x00
	al = __ror<byte,byte>(al, cl)
	ah.u0 = ~0x61
	ecx = ecx << cl
	&SCZO.u4->u0 = cond(ecx)
	v76 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	C = v76
	branch Test(PE,P) l0040C16A
l0040C275:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040C16A
l0040C27F:
	&esi.u4->u0 = (word32) ecx + 30
	__out<byte>(dx, al)
	&esi.u4->u0 = (word32) esi + 1
	al = al | 0x44
	SZ = cond(al)
	O = false
	C.u0 = false
l0040C285:
	edi = edi << cl
	edi = edi << cl
	&SCZO.u4->u0 = cond(edi)
	esi = esi + ebx + C
	esi = esi & ebx
	C.u0 = false
	v78 = (bl & 0x01 << cl) != 0x00
	bl = __rcr<byte,byte>(bl, cl, C)
	bl = bl - al
	&SCZO.u4->u0 = cond(bl)
	v79 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	edi = edi << cl
	&SCZO.u4->u0 = cond(edi)
	&dl.u4->u0 = (byte) dl.u0 + 1
	SZO = cond(dl)
	v80 = (cl & 0x01 << cl) != 0x00
	cl = __rcr<byte,byte>(cl, cl, C)
	bl = bl >> cl
	ebx = ebx >> cl
	SCZ = cond(ebx)
	branch Test(PE,P) l0040C1CA
l0040C2A3:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040C1CA
l0040C2AD:
	al = *esi.u7
	&esi.u4->u0 = (word32) esi + 1
	ebp = ebp - 3538367171 - C
	&SCZO.u4->u0 = cond(ebp)
l0040C2B0:
	ecx = ecx - 0x01
	branch Test(EQ,Z) && ecx != 0x00 l0040C236
l0040C2B6:
	eax = eax - *ecx.u7 - C
	v84 = Mem0[eax + 0x00:byte] + al
	*eax.u0 = v84
	&SCZO.u4->u0 = cond(v84)
	edx = edx
	goto l0040C2D3
l0040C2CD:
l0040C2D3:
	ebx = ebx
	branch Test(NE,Z) l0040C3EC
l0040C2DB:
	esp = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	v85 = ecx.u6->bFFFFFF8A - ah
	ecx.u6->bFFFFFF8A = v85
	esi = esi ^ (ebp.u6)->dw80F2231F
	SZ = cond(esi)
	O = false
	C.u0 = false
	__fldenv(*((word32) ecx + (eax * 0x02 + 26)))
	Top->r0000 = Top->r0000 + *((byte) eax.u0 - 0x23ED5E33)
	goto l0040C2EF
l0040C2E0:
l0040C2E5:
l0040C2E7:
l0040C2E9:
l0040C2EA:
l0040C2EF:
	bl = bl - 0x01
	edi = edi - eax - C
	&SCZO.u4->u0 = cond(edi)
	gs = ax
	ebx = ebx - (struct Eq_1321 *) 0x01
	edi = edi << cl
	bl = bl & dl
	bh = bh ^ al
	v104 = (bh & 0x01 << cl) != 0x00
	bh = __ror<byte,byte>(bh, cl)
	esi = esi | edi
	v105 = (ch & 0x01 << cl) != 0x00
	ch = __ror<byte,byte>(ch, cl)
	C = v105
	v106 = (ch & 0x01 << cl) != 0x00
	ch = __rcr<byte,byte>(ch, cl, C)
	v107 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rol<word32,byte>(edi, cl)
	C = v107
	ecx = ecx + ebx + C
	&SCZO.u4->u0 = cond(ecx)
	v108 = (ecx & 0x01 << cl) != 0x00
	ecx = __rcr<word32,byte>(ecx, cl, C)
	C = v108
	edi = edi + ebx + C
	&SCZO.u4->u0 = cond(edi)
	branch Test(PE,P) l0040C0B5
	goto l0040C454
l0040C2FC:
	edx = edx + 0x01
	ch.u0 = ~0x08
	bl = bl << cl
	bl = bl ^ ~0x60
	cl = cl - bh
	&SCZO.u4->u0 = cond(cl)
	edi = edi - eax - C
	&SCZO.u4->u0 = cond(edi)
	branch Test(ULT,C) l0040C875
	goto l0040C30E
l0040C309:
	v60 = edi.u6->t0005.u0 & 0x00
	edi.u6->t0005.u0 = (byte) v60
	SZ = cond(edi.u6->t0005.u0)
	v61 = (byte) &(cl.u4 + (ebx.u6)->bF1B8DD2 /8 6)->u0
	ebx.u6->bF1B8DD2 = v61
	&SCZO.u4->u0 = cond(v61)
	v62 = ebp.u6->t0005.u1 - 0x00 - C
	ebp.u6->t0005.u1 = (word32) v62
	v63 = (byte) &(ch.u4 + (edi.u6)->b840FDADF /8 6)->u0
	edi.u6->b840FDADF = v63
	&SCZO.u4->u0 = cond(v63)
	goto l0040C31B
l0040C30E:
	edx = edx
	ebx = ebx
	branch Test(UGE,C) l0040C875
l0040C318:
	&SCZO.u4->u0 = cond(eax - *edi.u0)
	edi = edi + 4
l0040C31B:
	D = true
	v65 = Mem0[eax + 0x00:word32] + eax
	*eax.u0 = v65
	dl = dl + dl
	&SCZO.u4->u0 = cond(dl)
	ax = __aad(ax)
	ax = __aad(ax)
	return
l0040C34E:
l0040C369:
	v46 = (eax & 0x01 << cl) != 0x00
	eax = __rcr<word32,byte>(eax, cl, C)
	bh = bh + ah
	&SCZO.u4->u0 = cond(bh)
	&al.u4->u0 = (byte) al + 1
	v47 = (edi & 0x01 << cl) != 0x00
	edi = __rcr<word32,byte>(edi, cl, C)
	C = v47
	v48 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rcl<byte,byte>(bh, cl, C)
	ebx = ebx | edx
	SZ = cond(ebx)
	O = false
	C.u0 = false
	branch Test(LE,SZO) l0040C06D
l0040C37B:
	edx = edx
	ebx = ebx
	branch Test(GT,SZO) l0040C06D
l0040C385:
	ch = ch & dl
	SZ = cond(ch)
	O = false
	C.u0 = false
	branch Test(NS,S) l0040C309
l0040C388:
l0040C389:
	__syscall<byte>(0x69)
l0040C38B:
	al = al - dl - C
	bh = bh - 0xC2
	&SCZO.u4->u0 = cond(bh)
	ebx = ebx - (struct Eq_656 *) 0x01
	v49 = (cl & 0x01 << cl) != 0x00
	cl = __rcr<byte,byte>(cl, cl, C)
	bh = bh << cl
	ch = ch + dh
	v50 = (edi & 0x01 << cl) != 0x00
	edi = __ror<word32,byte>(edi, cl)
	ch = ch >> cl
	&al.u4->u0 = (byte) al + 0x0098
	&SCZO.u4->u0 = cond(al)
	edi = edi + 0x01
	SZO = cond(edi)
	edi = edi - 0x01
	ebx = ebx + eax
	ecx = ebx
	edi = edi | ebx
	C.u0 = false
	v58 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	C = v58
	bh = bh - ~0x05 - C
	&SCZO.u4->u0 = cond(bh)
	edi = edi - esi - C
	&SCZO.u4->u0 = cond(edi)
	branch Test(EQ,Z) l0040C102
	goto l0040C1F5
l0040C3AB:
	cl.u0 = 0x93
	al = al - bh
	&SCZO.u4->u0 = cond(al)
	v163 = (cl & 0x01 << 0x08 - cl) != 0x00
	cl = __rcl<byte,byte>(cl, cl, C)
	v164 = (eax & 0x01 << cl) != 0x00
	eax = __ror<word32,byte>(eax, cl)
	v165 = (ch & 0x01 << cl) != 0x00
	ch = __ror<byte,byte>(ch, cl)
	eax = eax >> cl
	dh = dh << cl
	edi = edi >> cl
	esi = esi >> cl
	dl = dl ^ 0x70
	SZ = cond(dl)
	O = false
	C.u0 = false
	v167 = (ah & 0x01 << cl) != 0x00
	ah = __ror<byte,byte>(ah, cl)
	C = v167
	esi = esi - edi - C
	eax = eax & edx
	ah = ah >> cl
	ecx = ecx << cl
	bl = bl ^ ~0x02
	ch = ch - 0x49
	edx = edx + ecx
	&SCZO.u4->u0 = cond(edx)
	branch Test(OV,O) l0040C786
	goto l0040C1BA
l0040C3CA:
	ch = ch ^ cl
	&cl.u4->u0 = (byte) cl + 1
	esi = edi
	&dh.u4->u0 = (byte) dh + 226
	ecx = ecx - esi
	esi = esi & edi
	SZ = cond(esi)
	O = false
	C.u0 = false
	branch Test(LT,SO) l0040C5DC
l0040C3DD:
	edx = edx
	ebx = ebx
	branch Test(GE,SO) l0040C5DC
l0040C3E7:
	al = al | 0x27
	v175 = ebx.u6->dwBFC6808F & esi
	ebx.u6->dwBFC6808F = v175
	SZ = cond(ebx.u6->dwBFC6808F)
	O = false
	C.u0 = false
	goto l0040C3EF
l0040C3EC:
	&dh.u4->u0 = (byte) dh.u0 + 191
	&SCZO.u4->u0 = cond(dh)
l0040C3EF:
	bl = bl ^ dl
	SZ = cond(bl)
	O = false
	C.u0 = false
l0040C3F1:
	edi = edi - edx
	edi = edi << cl
	&SCZO.u4->u0 = cond(edi)
	v101 = (bh & 0x01 << cl) != 0x00
	bh = __rcr<byte,byte>(bh, cl, C)
	C = v101
	&edi.u4->u0 = (word32) edi + 1
	SZO = cond(edi)
	branch Test(EQ,Z) l0040C642
l0040C3FE:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C642
l0040C408:
	v102 = *esi.u7
	*edi.u0 = v102
	&esi.u4->u0 = (word32) esi + 1
	edi = edi + 1
	branch Test(NO,O) l0040C409_then
	fn3B53CCD2()
	return
l0040C409_then:
l0040C40B:
	edx = edx + 0x593B1308
	&ecx.u4->u0 = (char *) ecx.u4 + 1
	&SCZO.u4->u0 = cond(edx - 2326557454)
	branch Test(NE,Z) l0040C20D
	goto l0040C41E
l0040C410:
	ecx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	ecx = ecx + 0x01
	&SCZO.u4->u0 = cond(edx - 2326557454)
	branch Test(NE,Z) l0040C20D
l0040C41E:
	edi = edi - ebx
	bl = ah
	ch = ch << cl
	cl = cl - bl
	ah = ah << cl
	eax = eax ^ edi
	SZ = cond(eax)
	O = false
	C.u0 = false
	edi = edi - esi
	&SCZO.u4->u0 = cond(edi)
	bl = cl
	ah = bl
	v40 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	C = v40
	v41 = (ecx & 0x01 << 0x20 - cl) != 0x00
	ecx = __rcl<word32,byte>(ecx, cl, C)
	cl = cl - ah
	&SCZO.u4->u0 = cond(cl)
	edi = edi + eax + C
	&SCZO.u4->u0 = cond(edi)
	v42 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	ah = ah >> cl
	SCZ = cond(ah)
	goto l0040BFB1
l0040C435:
l0040C454:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040C0B5
l0040C45E:
	*(union Eq_3 *) 3339803235 = al
	__out<byte>(0xD2, al)
l0040C464:
	edx.u0->u0 = 0x1AEE2ACE
l0040C486:
	eax = eax - esi - C
	v182 = (edx & 0x01 << 0x20 - cl) != 0x00
	edx = __rol<word32,byte>(edx, cl)
	C = v182
	edx = edx - edi - C
	bh = bh ^ 0xB4
	ch = ch ^ 0xD0
	al = al | 0x8B
	C.u0 = false
	v183 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	edi = edi >> cl
	cl = cl ^ 212
	C.u0 = false
	bh = bh + bl + C
	edi = edi >> cl
	bh = bh & 0x90
	SZ = cond(bh)
	O = false
	C.u0 = false
	mm2 = mm0
	goto l0040C560
l0040C4B0:
	v179 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rcl<byte,byte>(bh, cl, C)
	bh = bh & dh
	C.u0 = false
	ebx = ebx + edx + C
	&SCZO.u4->u0 = cond(ebx)
	v180 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rcl<byte,byte>(dh, cl, C)
	bl = bl ^ ~0x41
	mm0 = (word64) eax
	al = al << cl
	&bh.u4->u0 = (byte) bh + 11
	&SCZO.u4->u0 = cond(bh)
	branch Test(OV,O) l0040C486
l0040C4C5:
	edx = edx
	ebx = ebx
	branch Test(NO,O) l0040C486
l0040C4CB:
	eax = eax & 0xF61E3188
	SZ = cond(eax)
	O = false
	C.u0 = false
l0040C4D0:
	v27 = (edi & 0x01 << cl) != 0x00
	edi = __rcr<word32,byte>(edi, cl, C)
	C = v27
	cl = cl - 0x01
	edi = edi - 0x01
	v28 = (eax & 0x01 << 0x20 - cl) != 0x00
	eax = __rcl<word32,byte>(eax, cl, C)
	edi = edi ^ esi
	edi = edi ^ esi
	ch = ch & 0x49
	ecx = ecx | eax
	SZ = cond(ecx)
	O = false
	C.u0 = false
	branch Test(EQ,Z) l0040C369
l0040C4E6:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C369
l0040C4F0:
	&esp.u4->u0 = (word32) esp + 1
	ds_esp.u1 = esi.u6->tFAD3C359.u1
	ah = ah ^ ~0x0C
	bh = bh - 0x01
	v31 = (al & 0x01 << cl) != 0x00
	al = __ror<byte,byte>(al, cl)
	edi = edi - 0x01
	v32 = (eax & 0x01 << 0x20 - cl) != 0x00
	eax = __rol<word32,byte>(eax, cl)
	C = v32
	cl = cl + bh + C
	al = al - ~0x51
	&SCZO.u4->u0 = cond(al)
	dh = bl
	v33 = (ecx & 0x01 << cl) != 0x00
	ecx = __ror<word32,byte>(ecx, cl)
	C = v33
	branch Test(ULT,C) l0040C516
l0040C50C:
	edx = edx
	ebx = ebx
	branch Test(UGE,C) l0040C516
l0040C512:
	edi = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	esi = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	ebp = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	&esp.u4->u0 = (word32) esp + 4
	ebx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	edx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	ecx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	eax = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	&ecx.u4->u0 = ebp.u6->tD2F02BDB.u4
	__out<byte>(211, al)
	goto l0040C51A
l0040C516:
	esi = esi - eax
	dh = dh << cl
	&SCZO.u4->u0 = cond(dh)
	goto l0040C51A
l0040C519:
l0040C51A:
	SCZO = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	return
l0040C535:
	edi = edi - ecx
	v123 = (ecx & 0x01 << 0x20 - cl) != 0x00
	ecx = __rol<word32,byte>(ecx, cl)
	ebx = edx
	&ch.u4->u0 = (byte) ch + 1
	v124 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rol<word32,byte>(ebx, cl)
	v125 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rol<byte,byte>(bh, cl)
	C = v125
	ebx = ebx - edi - C
	esi = esi >> cl
	ecx = ecx - esi
	&SCZO.u4->u0 = cond(ecx)
	eax = gs
	bh = bh - 0x01
	SZO = cond(bh)
	branch Test(EQ,Z) l0040C73F
l0040C551:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C73F
l0040C55B:
	__syscall<byte>(115)
	*(union Eq_3 *) 4174618165 = al
l0040C560:
	al = al | cl
	bh = bh >> cl
	v126 = (dh & 0x01 << cl) != 0x00
	dh = __ror<byte,byte>(dh, cl)
	C = v126
	&dl.u4->u0 = (bool) C.u0 + ((byte) dl + 92)
	&SCZO.u4->u0 = cond(dl)
	v127 = (ah & 0x01 << cl) != 0x00
	ah = __rcr<byte,byte>(ah, cl, C)
	C = v127
	ecx = ecx | edx
	C.u0 = false
	ecx = ecx - edi - C
	&SCZO.u4->u0 = cond(ecx)
	goto l0040C018
l0040C578:
l0040C58F:
	&bh.u4->u0 = (byte) bh + 1
	cl = cl ^ dl
	C.u0 = false
	v95 = (bl & 0x01 << cl) != 0x00
	bl = __rcr<byte,byte>(bl, cl, C)
	C = v95
	ch = ch - al - C
	bh = bh - dh
	bl.u0 = 0x60
	v96 = (bh & 0x01 << cl) != 0x00
	bh = __ror<byte,byte>(bh, cl)
	al = bh
	&ecx.u4->u0 = (word32) ecx + 1
	bh = bh << cl
	dl = dl ^ ~0x08
	O = false
	bh = bh >> cl
	SCZ = cond(bh)
	branch Test(SG,S) l0040C8D7
l0040C5AD:
	edx = edx
	ebx = ebx
	branch Test(NS,S) l0040C8D7
l0040C5B7:
	esp = ebp
	ebp = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	edi.u0 = 4141057294
l0040C5BB:
	cl = cl - al - C
	ch = dh
	v97 = (bl & 0x01 << 0x08 - cl) != 0x00
	bl = __rol<byte,byte>(bl, cl)
	C = v97
	&bl.u4->u0 = (bool) C.u0 + ((byte) bl.u0 + 0x00CB)
	&SCZO.u4->u0 = cond(bl)
	v98 = (ebx & 0x01 << cl) != 0x00
	ebx = __ror<word32,byte>(ebx, cl)
	C = v98
	branch Test(PE,P) l0040C2FC
l0040C5CE:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040C2FC
l0040C5D8:
	v99 = *esi.u7
	*edi.u0 = v99
	&esi.u4->u0 = (word32) esi + 4
	edi = edi + 4
	edi = edi - (struct Eq_1313 *) 0x01
	SZO = cond(edi)
	__out<byte>(0xA8, al)
l0040C5DC:
	bl = bl - cl
	ecx = ecx - ebx
	ebx = ebx | edi
	cl = al
	bh = bh | dl
	C.u0 = false
	v100 = (ah & 0x01 << 0x08 - cl) != 0x00
	ah = __rcl<byte,byte>(ah, cl, C)
	dl = dl & ~0x2A
	SZ = cond(dl)
	O = false
	C.u0 = false
	goto l0040C231
l0040C5F5:
l0040C60A:
	edx = edx
	ebx = ebx
	branch Test(GE,SO) l0040C09C
l0040C614:
	edi = edi + Mem0[eax + -23:word32] + C
	Z = __arpl(bx, bx, &bx)
	bh.u0 = ~0x25
	&bh.u4->u0 = (byte) bh.u0 + 1
	edi = edi - edx
	v70 = (cl & 0x01 << cl) != 0x00
	cl = __ror<byte,byte>(cl, cl)
	edi = edi | esi
	ch = ch << cl
	&SCZO.u4->u0 = cond(ch)
	ch = cl
	ch = ch - cl - C
	ebx = ebx | ecx
	C.u0 = false
	v71 = (bh & 0x01 << 0x08 - cl) != 0x00
	bh = __rcl<byte,byte>(bh, cl, C)
	edi = edi & edx
	SZ = cond(edi)
	O = false
	C.u0 = false
	branch Test(LT,SO) l0040BF64
l0040C635:
	edx = edx
	ebx = ebx
	branch Test(GE,SO) l0040BF64
l0040C63F:
	C.u0 = false
	al = *esi.u7
	&esi.u4->u0 = (word32) esi + 1
	(*edx.u0)()
	return
l0040C642:
	cl = cl & bl
	SZ = cond(cl)
	O = false
	C.u0 = false
	goto Win32CrtStartup_exit
l0040C668:
l0040C687:
l0040C6A9:
	v176 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	ecx = ecx >> cl
	SCZ = cond(ecx)
	eax.u0 = 0xEDE2C684
	dl = dl - 22 - C
	v177 = (edi & 0x01 << cl) != 0x00
	edi = __ror<word32,byte>(edi, cl)
	edx = edx >> cl
	cl = cl ^ ch
	esi = esi + edx
	edx = edx << cl
	edi = edi >> cl
	&SCZO.u4->u0 = cond(edi)
	branch Test(LE,SZO) l0040C4B0
l0040C6C7:
	edx = edx
	ebx = ebx
	branch Test(GT,SZO) l0040C4B0
l0040C6D1:
	ch = ch - ((ecx.u6)->tFFFFFFE3).u0 - C
	&SCZO.u4->u0 = cond(ch)
	ds_eax.u1 = edi.u6->tD0D3FC3B.u1
	goto l0040C6DA
l0040C6D8:
l0040C6DA:
	ebx = ebx + ecx
	bl = bl - 199
	eax = fs->t0018
	dh = dh | 177
	dl = dl - ch
	&SCZO.u4->u0 = cond(dl)
	v56 = (edx & 0x01 << 0x20 - cl) != 0x00
	edx = __rcl<word32,byte>(edx, cl, C)
	dl = dl >> cl
	SCZ = cond(dl)
	cl = cl - bl - C
	&SCZO.u4->u0 = cond(cl)
	cl = cl + al + C
	&SCZO.u4->u0 = cond(cl)
	v57 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rol<byte,byte>(dh, cl)
	C = v57
	ebx = ebx & edx
	ch = ch - 0x01
	ebx = ebx - edi
	&eax.u4->u0 = eax.u6->t0030.u4
	bl = bl - 0x26
	esi = esi - eax
	&SCZO.u4->u0 = cond(esi)
	v67 = (cl & 0x01 << 0x08 - cl) != 0x00
	cl = __rol<byte,byte>(cl, cl)
	C = v67
	dl = dl | 0x24
	bl = bl & 0x89
	cl = cl >> cl
	ebx = ebx >> cl
	&bh.u4->u0 = (byte) bh + 211
	&SCZO.u4->u0 = cond(bh)
	esi = esi - ebx - C
	&SCZO.u4->u0 = cond(esi)
	branch Test(LT,SO) l0040C09C
	goto l0040C60A
l0040C6FD:
	dh = dh & 171
	ch = ch + dl
	dh = dh << cl
	&SCZO.u4->u0 = cond(dh)
	return
l0040C73F:
	bh = bh << cl
	v133 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rol<word32,byte>(ebx, cl)
	ch = ch & dl
	bl.u0 = 0xA2
	esi = esi >> cl
	SCZ = cond(esi)
	cl = cl - dl - C
	&SCZO.u4->u0 = cond(cl)
	v134 = (ecx & 0x01 << 0x20 - cl) != 0x00
	ecx = __rcl<word32,byte>(ecx, cl, C)
	bh = bh ^ 0x60
	ecx = ecx - 0x01
	v135 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rol<word32,byte>(edi, cl)
	ch = ch - 0x01
	SZO = cond(ch)
	v136 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rol<word32,byte>(ebx, cl)
	C = v136
	branch Test(PE,P) l0040C5BB
l0040C75F:
	edx = edx
	ebx = ebx
	branch Test(PO,P) l0040C5BB
l0040C769:
	dl.u0 = 252
	v137 = (word32) ((word48) *((byte) eax.u0 - 552376126) + 1)
	&((byte) eax.u0 - 552376126)->u4->u0 = v137
	esi = esi - ecx
	bl = bl << cl
	v138 = (dh & 0x01 << cl) != 0x00
	dh = __ror<byte,byte>(dh, cl)
	bh = bh - 0x01
	bl = bl >> cl
	edx = edx ^ edx
	SZ = cond(edx)
	O = false
	C.u0 = false
	bh = bh >> cl
	SCZ = cond(bh)
	v139 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rcl<word32,byte>(edi, cl, C)
	C = v139
	v140 = (ch & 0x01 << cl) != 0x00
	ch = __rcr<byte,byte>(ch, cl, C)
	C = v140
	ch.u0 = ~0x42
	ebx = ebx - 0x01
	v141 = (ch & 0x01 << cl) != 0x00
	ch = __rcr<byte,byte>(ch, cl, C)
	ebx = ebx & eax
	esi = esi ^ edi
	__syscall<byte>(0x2E)
	bh = bh - ch
	&SCZO.u4->u0 = cond(bh)
	ch.u0 = ~0x24
	v142 = (bh & 0x01 << cl) != 0x00
	bh = __rcr<byte,byte>(bh, cl, C)
	C = v142
	ecx = ecx >> cl
	&SCZO.u4->u0 = cond(ecx)
	v143 = (esi & 0x01 << cl) != 0x00
	esi = __rcr<word32,byte>(esi, cl, C)
	edi = eax
	cl = cl & bl
	bh = bh << cl
	&SCZO.u4->u0 = cond(bh)
	ecx = ecx + esi + C
	ecx = ecx | edi
	&SCZO.u4->u0 = cond(edx - ~0x00)
	branch Test(EQ,Z) l0040C7F3
	goto l0040C92E
l0040C786:
	ebx = ebx << cl
	&cl.u4->u0 = (byte) cl.u0 + 1
	ebx = ebx ^ edi
	cl = cl >> cl
	eax = eax | ebx
	&ch.u4->u0 = (byte) ch.u0 + 0x00F3
	eax = eax - ecx
	&SCZO.u4->u0 = cond(eax)
	branch Test(EQ,Z) l0040C3CA
l0040C79B:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C3CA
l0040C7A5:
	branch Test(NO,O) l0040C80E
l0040C7A7:
	esp.u0 = 2158022802
	v171 = (esi & 0x01 << 0x80) != 0x00
	esi = __rcr<word32,byte>(esi, 0x80, C)
	C = v171
	v172 = (*eax.u0 & 0x01 << cl) != 0x00
	*eax.u0 = __ror<word32,byte>(*eax.u0, cl)
	C = v172
	goto l0040C7B1
l0040C7AB:
	&cl.u4->u0 = (byte) cl + 222
	&SCZO.u4->u0 = cond(cl)
	&bl.u4->u0 = (bool) C.u0 + ((byte) bl.u0 + 8)
	&SCZO.u4->u0 = cond(bl)
	goto l0040C7B1
l0040C7AC:
l0040C7AE:
l0040C7AF:
l0040C7B1:
	ah = ah ^ ch
	al = al & dh
	C.u0 = false
	ebx = ebx + ecx + C
	&SCZO.u4->u0 = cond(ebx)
	dl = ah
	branch Test(ULE,CZ) l0040C2B0
l0040C7BF:
	edx = edx
	ebx = ebx
	branch Test(UGT,CZ) l0040C2B0
l0040C7C9:
	v173 = ecx
	ecx = eax
	eax = v173
	branch Test(LE,SZO) l0040C7F9
l0040C7CC:
	SCZDOP = *esp.u0
	&esp.u4->u0 = (byte) esp.u0 + 4
	eax = *(union Eq_3 *) 0x1B4A00E6
	goto l0040C7D2
l0040C7D0:
	edx = edx - 0x01
	esi = esi - ecx - C
	&SCZO.u4->u0 = cond(esi)
l0040C7D2:
	v144 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rcl<byte,byte>(dh, cl, C)
	edx = edx << cl
	edi = edi ^ ebx
	ah = ah >> cl
	&SCZO.u4->u0 = cond(ah)
	branch Test(LT,SO) l0040C123
l0040C7E1:
	edx = edx
	ebx = ebx
	branch Test(GE,SO) l0040C123
l0040C7EB:
	SZP = cond(*edi.u0 & edx)
	O = false
	C.u0 = false
	ds = *esp.u7
	&esp.u4->u0 = (word32) esp + 2
l0040C7EE:
	al = *((byte) edx.u0 - 1)
	goto l0040C7F5
l0040C7F3:
	al.u0 = 0x2E
l0040C7F5:
	&SCZO.u4->u0 = cond(eax - 0xC000002E)
l0040C7F9:
	branch Test(EQ,Z) l0040C8AB
l0040C801:
	v159 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	C = v159
	v160 = (ch & 0x01 << 0x08 - cl) != 0x00
	ch = __rcl<byte,byte>(ch, cl, C)
	C = v160
	branch Test(LE,SZO) l0040BFF2
l0040C80B:
	edx = edx
	ebx = ebx
l0040C80E:
	branch Test(GT,SZO) l0040BFF2
l0040C815:
	bh = bh - 242 - C
	__lock()
	&SCZO.u4->u0 = cond(*esi.u7 - *edi.u7)
	&esi.u4->u0 = (word32) esi + 4
	&edi.u4->u0 = (word32) edi + 4
	branch Test(NS,S) l0040C84E
	goto l0040C81C
l0040C81B:
l0040C81C:
	eax = eax | edi
	C.u0 = false
	bl = bl - cl - C
	&ah.u4->u0 = (byte) ah + 1
	esi = esi - 0x01
	bh = bh ^ ah
	v161 = (esi & 0x01 << 0x20 - cl) != 0x00
	esi = __rol<word32,byte>(esi, cl)
	ecx = ecx - edi
	ecx = ecx | edi
	ecx = ecx | edx
	dl = dl ^ 0x08
	SZ = cond(dl)
	O = false
	C.u0 = false
	ebx = esi
	goto l0040C03D
l0040C83B:
	v169 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rcl<word32,byte>(edi, cl, C)
	ch = ch >> cl
	ch = ch ^ bh
	edi = edi >> cl
	&SCZO.u4->u0 = cond(edx - 20011817)
	branch Test(NE,Z) l0040C3F1
	goto l0040C84F
l0040C84E:
l0040C84F:
	ah = ah - 0x01
	bl = bl ^ al
	edi = edi + ebx
	&SCZO.u4->u0 = cond(edi)
	ah = ah - bl - C
	&SCZO.u4->u0 = cond(ah)
	&dh.u4->u0 = (bool) C.u0 + ((byte) dh + 0x00F1)
	&SCZO.u4->u0 = cond(dh)
	edi = ebx
	ebx = ebx + edx + C
	&SCZO.u4->u0 = cond(ebx)
	branch Test(SG,S) l0040C7AB
l0040C864:
	edx = edx
	ebx = ebx
	branch Test(NS,S) l0040C7AB
l0040C86E:
	v170 = esp
	esp = esp - 4
	*esp.u7 = eax
	esp = esp - 4
	*esp.u7 = ecx
	esp = esp - 4
	*esp.u7 = edx
	esp = esp - 4
	*esp.u7 = ebx
	esp = esp - 4
	*esp.u7 = v170
	esp = esp - 4
	*esp.u7 = ebp
	esp = esp - 4
	*esp.u7 = esi
	esp = esp - 4
	*esp.u7 = edi
	Top->r0000 = Top->r0000 * (esi.u6)->r86D86E5F
	goto l0040C875
l0040C871:
	edi = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	__out<byte>(dx, al)
	&esi.u4->u0 = (word32) esi + 1
	Top->r0000 = Top->r0000 + (real64) (esi.u6)->rC1FEFBD2
	goto l0040C879
l0040C875:
	bl = bl >> cl
	SCZ = cond(bl)
	&cl.u4->u0 = (byte) cl + 1
	SZO = cond(cl)
l0040C879:
	ch = ch & ~0x42
	edi = edi + eax
	v116 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rol<word32,byte>(edi, cl)
	ebx = ebx & eax
	esi = esi - 0x01
	cl = cl ^ al
	bl = bl - 0x01
	esi = esi ^ ecx
	SZ = cond(esi)
	O = false
	C.u0 = false
	branch Test(ULT,C) l0040C83B
l0040C88B:
	edx = edx
	ebx = ebx
	branch Test(UGE,C) l0040C83B
l0040C891:
	al = __in<byte>(0x51)
	eax = eax ^ eax
	v117 = (al & 0x01 << cl) != 0x00
	al = __ror<byte,byte>(al, cl)
	edi = edi - 0x01
	v118 = (eax & 0x01 << 0x20 - cl) != 0x00
	eax = __rol<word32,byte>(eax, cl)
	C = v118
	cl = cl + bh + C
	al = al - ~0x51
	&SCZO.u4->u0 = cond(al)
l0040C89F:
	dh = bl
	v119 = (ecx & 0x01 << cl) != 0x00
	ecx = __ror<word32,byte>(ecx, cl)
	esi = esi - eax
	dh = dh << cl
	&SCZO.u4->u0 = cond(dh)
	v120 = (edi & 0x01 << cl) != 0x00
	edi = __ror<word32,byte>(edi, cl)
	C = v120
	v121 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rcl<byte,byte>(dh, cl, C)
	C = v121
l0040C8AB:
	bl.u0 = 0x9C
	v122 = (dl & 0x01 << cl) != 0x00
	dl = __ror<byte,byte>(dl, cl)
	C = v122
	branch Test(EQ,Z) l0040C7D0
l0040C8B5:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C7D0
l0040C8BF:
	branch Test(UGT,CZ) l0040C871
l0040C8C1:
	ecx = ecx - 0x01
	branch ecx != 0x00 l0040C89F
l0040C8C3:
	cl = cl + bh + C
	cl = cl ^ ah
	C.u0 = false
	dh = dh - ah - C
	dh = dh | cl
	ah = ah - 0x01
	al = al | ah
	SZ = cond(al)
	O = false
	C.u0 = false
	return
l0040C8D7:
	edi = edi - (struct Eq_1268 *) 0x01
	dl = dl + al + C
	al = al >> cl
	cl = cl - bl
	dh = dh >> cl
	ebx = ebx >> cl
	ch = ch & bl
	ch = ch ^ al
	C.u0 = false
	&ch.u4->u0 = (byte) ch.u0 + 1
	SZO = cond(ch)
	ch = ch - 0x60
	ebx = ebx & edx
	C.u0 = false
	al = al + cl + C
	v109 = (ebx & 0x01 << cl) != 0x00
	ebx = __ror<word32,byte>(ebx, cl)
	C = v109
	&ah.u4->u0 = (byte) ah.u0 + 1
	bh = bh + cl + C
	&SCZO.u4->u0 = cond(bh)
	edx = edx + ebx + C
	&SCZO.u4->u0 = cond(edx)
	goto l0040C464
l0040C8F3:
	v21 = (edi & 0x01 << cl) != 0x00
	edi = __ror<word32,byte>(edi, cl)
	&ebx.u4->u0 = (word32) ebx + 1
	edx.u0 = 0x6CB504B6
	ch = ch - ah
	edi = eax
	ebx = ebx - esi
	ebx = ebx - 0x01
	eax = eax ^ edi
	bl = ah
	al = al - dh
	bh = bh | dl
	O = false
	ch = ch >> cl
	SCZ = cond(ch)
	esi = esi ^ ebx
	SZ = cond(esi)
	O = false
	C.u0 = false
	goto l0040C206
l0040C917:
l0040C92E:
	branch Test(EQ,Z) l0040C7EE
l0040C934:
	edx = edx
	ebx = ebx
	branch Test(NE,Z) l0040C7EE
l0040C93E:
	Top->r0000 = Top->r0000 - (ebp.u6)->rCEE8CF04
	goto l0040C944
l0040C942:
l0040C944:
	v86 = *((byte) edx.u0 - 122) >> cl
	&((byte) edx.u0 - 122)->u4->u0 = v86
	esi = esi | *((ui32 *) 4056049208)
	SZ = cond(esi)
	O = false
	C.u0 = false
	branch Test(GE,CZ) l0040C952
l0040C950_1:
	Top->r0000 = Top->r0001
l0040C952:
	al = *(union Eq_3 *) 0x34D4B4A0
	*((byte) eax.u0 + 0x0022) = ebp
	al = *(union Eq_3 *) 2233873139
	*edi.u7 = eax
	v90 = *((byte) eax.u0 + 956677792) & 0x3F69322B
	&((byte) eax.u0 + 956677792)->u4->u0 = v90
	SZ = cond(*((byte) eax.u0 + 956677792))
	eax = eax | 824241985
	edi = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	esi = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	ebp = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	&esp.u4->u0 = (word32) esp + 4
	ebx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	edx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	ecx = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	eax = *esp.u7
	&esp.u4->u0 = (word32) esp + 4
	edi.u0 = 0x3F693263
	eax = eax | 0xA001C285
	al = *(union Eq_3 *) 0x3F22FA32
	eax = eax | 0xA0014185
	C.u0 = false
	al = *(union Eq_3 *) ~0x066BD169
	dh = dh + Mem0[edx + 0x00:byte] + C
	bh = bh & *esi.u7
	C.u0 = true
	esi = esi - ((ecx.u6)->tFFFFFFF9).u1 - C
	dh = dh & ((ecx.u6)->tFFFFFFF9).u0
	SZ = cond(dh)
	O = false
	C.u0 = false
	ah = SCZOP
	__lock()
	*(union Eq_3 *) 0xC011C2A0 = al
	v92 = *((byte) eax.u0 + 1104446880) & esp
	&((byte) eax.u0 + 1104446880)->u4->u0 = v92
	SZ = cond(*((byte) eax.u0 + 1104446880))
	O = false
	C.u0 = false
	al = *(union Eq_3 *) 0x154702A0
	esp = esp - 4
	*esp.u7 = ebp
	v93 = (*((byte) edx.u0 - 0x6B4B6E6B) & 0x01 << 0xA4) != 0x00
	*((byte) edx.u0 - 0x6B4B6E6B) = __rcr<byte,byte>(*((byte) edx.u0 - 0x6B4B6E6B), 0xA4, C)
	C = v93
	v94 = *esi.u7
	*edi.u0 = v94
	&esi.u4->u0 = (word32) esi + 4
	edi = edi + 4
	fn95A0_A001()
	return
Win32CrtStartup_exit:
}

// 0040D47F: define fn0040D47F
// Called from:
//      fn0040DD51
define fn0040D47F
{
	esp = fp;
	Top = 0;
	bh <<= cl;
	SCZO = cond(bh);
	bh = bh + al + C;
	++bh;
	++ebx;
	bl <<= cl;
	--ecx;
	esi -= eax;
	SCZO = cond(esi);
	fn0040D566();
}

// 0040D497: define fn0040D497
// Called from:
//      fn0040DBF1
//      fn0040DC08
//      fn0040DD51
define fn0040D497
{
	esp = fp;
	Top = 0;
	v6 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	dl = cl;
	dh <<= cl;
	bh >>= cl;
	dl -= bh;
	edx = edx ^ edi;
	dl -= ~0x24;
	SCZO = cond(dl);
	edi = edi - esi - C;
	bl |= 0xC1;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	edx = *esp;
	++esp;
	if (Test(GT,SZO))
	{
		edx = edx;
		ebx = ebx;
		if (Test(LE,SZO))
		{
			v20 = eax.u6->dwC2AA296D >> 0x01;
			eax.u6->dwC2AA296D = v20;
			SCZO = cond(v20);
			v21 = *ebx.u7 - ~0x2F - C;
			*ebx.u7 = v21;
			dl = dl ^ 0x22;
			bl &= ~0x28;
			C.u0 = false;
			--edi;
			&dl.u4->u0 = (byte) dl + 1;
			SZO = cond(dl);
			v22 = (eax & 0x01 << 0x20 - cl) != 0x00;
			eax = __rcl<word32,byte>(eax, cl, C);
			C = v22;
			ch -= bl;
			SCZO = cond(ch);
			v24 = (eax & 0x01 << 0x20 - cl) != 0x00;
			eax = __rcl<word32,byte>(eax, cl, C);
			C = v24;
			return;
		}
	}
	bh -= 212;
	bh <<= cl;
	bh += cl;
	ebx = ebx ^ eax;
	bh = bh ^ cl;
	&bh.u4->u0 = (byte) bh.u1 + 0x0055;
	SCZO = cond(bh);
	&bh.u4->u0 = (byte) bh + 1;
	ebx = ebx - esi - C;
	esi >>= cl;
	esi >>= cl;
	SCZO = cond(esi);
	v25 = (ebx & 0x01 << cl) != 0x00;
	ebx = __rcr<word32,byte>(ebx, cl, C);
	C = v25;
	if (Test(OV,O))
		fn0040DB83();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(NO,O))
			fn0040DB83();
		else
		{
			gs = (struct Eq_3010 *) *ecx;
			v28 = edi;
			edi = eax;
			eax = v28;
			--bl;
			bh <<= cl;
			&eax.u4->u0 = (word32) eax + 1;
			--bl;
			bl <<= cl;
			bh -= 0x5C;
			SCZO = cond(bh);
			v29 = (bh & 0x01 << cl) != 0x00;
			bh = __ror<byte,byte>(bh, cl);
			C = v29;
			fn0040D47F();
		}
	}
}

// 0040D4C3: define fn0040D4C3
// Called from:
//      fn0040D515
define fn0040D4C3
{
	esp = fp;
	Top = 0;
	edx = edx - eax - C;
	dl = dl ^ 0x22;
	bl &= ~0x28;
	C.u0 = false;
	--edi;
	++dl;
	SZO = cond(dl);
	v15 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	C = v15;
	ch -= bl;
	SCZO = cond(ch);
	v17 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	C = v17;
}

// 0040D4F6: define fn0040D4F6
// Called from:
//      fn0040D7DD
//      fn0040D9B4
define fn0040D4F6
{
	word32 ebx;
	word32 edx;
	word32 ecx;
	word32 esi;
	word32 edi;
	Top_3 = 0;
	ebx_6 = ebx ^ edx;
	ebx_8 = ebx_6 + ecx;
	cl_11 = ~(byte) ecx;
	ecx_16_16_43 = SLICE(ecx, word16, 16) ^ 0xE6C4;
	ebx_13 = __rcr<word32,byte>(ebx_8, cl_11, false);
	ebx_16_16_19 = SLICE(ebx_13, word16, 16);
	bl_20 = (byte) ebx_13;
	ebx_21 = SEQ(ebx_16_16_19, 0x4C, bl_20);
	ebx_23 = __ror<word32,byte>(ebx_21, cl_11);
	bh_24 = SLICE(ebx_23, byte, 8);
	bl_27 = (byte) ebx_23;
	ebx_16_16_41 = SLICE(ebx_23, word16, 16);
	fn0040D94D();
	ebx_42 = SEQ(ebx_16_16_41, bh_30, bl_31);
	ecx_44 = SEQ(ecx_16_16_43, ch_32, cl_33);
}

// 0040D515: define fn0040D515
// Called from:
//      Win32CrtStartup
define fn0040D515
{
	esp = fp;
	Top = 0;
	&ebx.u4->u0 = &(ebx.u4 + ecx / 6)->u0;
	SCZO = cond(ebx);
	cl = cl - ~0x62 - C;
	ch >>= cl;
	edi >>= cl;
	SCZ = cond(edi);
	--eax;
	v14 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rcl<byte,byte>(ah, cl, C);
	dl = dl ^ bl;
	&bh.u4->u0 = (byte) bh + 1;
	bl >>= cl;
	SCZO = cond(bl);
	esp -= 4;
	*esp = ecx;
	v21 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	C = v21;
	if (Test(PO,P))
	{
		edx = edx;
		ebx = ebx;
		if (Test(PE,P))
		{
			ch = ~0x62;
			edi = 3729339641;
			cl = cl ^ 0x56;
			C.u0 = false;
			edi = edi - eax - C;
			bl += al;
			SCZO = cond(bl);
			cl = cl - al - C;
			ch -= 131;
			edi = edi ^ esi;
			SZ = cond(edi);
			O = false;
			C.u0 = false;
			if (Test(UGE,C))
			{
				edx = edx;
				ebx = ebx;
				if (Test(ULT,C))
				{
					eax = 2336880468;
					ax = ax ^ 55947;
					SZ = cond(ax);
					O = false;
					C.u0 = false;
					fn0040D566();
					return;
				}
			}
			bh <<= cl;
			SCZO = cond(bh);
			fn0040DB59();
			return;
		}
	}
	v32 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	C = v32;
	fn0040DE0B();
}

// 0040D566: define fn0040D566
// Called from:
//      fn0040D47F
//      fn0040D515
define fn0040D566
{
	esp = fp;
	Top = 0;
	ebx = edx;
	bh = bh + bl + C;
	bh |= 0x9C;
	C.u0 = false;
	bl = (bool) C.u0 + (bl + 222);
	SCZO = cond(bl);
	v13 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	v15 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	C = v15;
	ebx = ebx - edi - C;
	SCZO = cond(ebx);
	edi = ecx;
	if (Test(PE,P))
		fn0040DA65();
	else
		fn0040D57E();
}

// 0040D57E: define fn0040D57E
// Called from:
//      fn0040D515
//      fn0040D566
define fn0040D57E
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(PO,P))
		fn0040DA65();
	else
	{
		--eax;
		SZP = cond(ebp->dw0022 & eax);
		O = false;
		C.u0 = false;
		C = !C;
		ecx = (bool) C.u0 + ((word32) ecx.u0 + eax);
		ch |= 200;
		++ch;
		++dh;
		++dl;
		ah &= bl;
		SZ = cond(ah);
		O = false;
		C.u0 = false;
		dh = dl;
		eax <<= cl;
		SCZO = cond(eax);
		ch = ch - bh - C;
		SCZO = cond(ch);
		ecx.u0 = esp->u0;
		esp = (union Eq_3349 *) ((char *) esp + 4);
		bh = bh - cl - C;
		ebx |= edx;
		O = false;
		esi >>= cl;
		dl >>= cl;
		SCZ = cond(dl);
		if (Test(LE,SZO))
			fn0040DD51();
		else
		{
			edx = edx;
			ebx = ebx;
			if (Test(GT,SZO))
				fn0040DD51();
			else
			{
				__out<byte>(0x39, al);
				es.u1 = esp->u1;
				esp = (union Eq_3349 *) ((char *) esp + 2);
				fn0040DB51();
			}
		}
	}
}

// 0040D630: define fn0040D630
// Called from:
//      fn0040DB59
define fn0040D630
{
	esp = fp;
	Top = 0;
	esi = &(C.u4 + (esi + ecx) / 6)->u0;
	SCZO = cond(esi);
	v10 = (bh & 0x01 << cl) != 0x00;
	bh = __rcr<byte,byte>(bh, cl, C);
	C = v10;
	edx = esi;
	v13 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v13;
	dl = dl + bh + C;
	v16 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	bh -= dh;
	SCZO = cond(bh);
	if (Test(UGE,C))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULT,C))
		{
			ebx = 0xDB803330;
			fn0040D653();
			return;
		}
	}
	eax->bD3D382C7 = 11;
	v20 = (edi->u0 & 0x01 << 133) != 0x00;
	edi->u0 = (int8) __ror<byte,byte>(edi->u0, 133);
	C = v20;
	v21 = bh;
	bh = dh;
	dh = v21;
}

// 0040D651: define fn0040D651
// Called from:
//      fn0040D6FE
//      fn0040DD10
define fn0040D651
{
	esp = fp;
	Top = 0;
	bl = bl - 0xA3 - C;
	SCZO = cond(bl);
	fn0040D653();
}

// 0040D653: define fn0040D653
// Called from:
//      fn0040D651
//      fn0040DB59
define fn0040D653
{
	ptr32 fp;
	word32 eax;
	al_50 = (byte) eax;
	eax_24_8_60 = SLICE(eax, word24, 8);
	ah_65 = SLICE(eax, byte, 8);
	eax_16_16_68 = SLICE(eax, word16, 16);
	word32 ebp;
	byte ebx[];
	byte cl;
	word32 esi;
	word24 ecx_24_8;
	word16 dx;
	word16 edx_16_16;
	esp_40 = fp;
	Top_41 = 0;
	*(word32 *) ~0x2C3C016F = eax;
	esp_44 = fp - 4;
	dwLoc04_102 = ebp;
	ebp_47 = fp - 4;
	esp_48 = fp - -0x000028E2;
	al_51 = ebx[(uint32) al_50];
	al_53 = al_51 | cl;
	ecx_56 = SEQ(ecx_24_8, cl);
	esi_57 = esi ^ ecx_56;
	ebx_58 = ebx << cl;
	bl_66 = (byte) ebx_58;
	ebx_24_8_67 = SLICE(ebx_58, word24, 8);
	SCZO_59 = cond(ebx_58);
	eax_61 = SEQ(eax_24_8_60, al_53);
	C_63 = SLICE(SCZO_59, bool, 1);
	edi_62 = eax_61;
	edx_81 = SEQ(edx_16_16, dx);
	if (ebx_58 < 0x00)
	{
		fn0040D8B3();
		edx_110 = SEQ(edx_16_16, dh_69, dl_70);
	}
	else
		fn0040D66B();
}

// 0040D66B: define fn0040D66B
// Called from:
//      fn0040D651
//      fn0040D653
define fn0040D66B
{
	word32 edx;
	word32 ebx;
	bool C;
	word32 ecx;
	byte ah;
	word32 esi;
	word32 edi;
	byte al;
	word16 eax_16_16;
	Top_3 = 0;
	dx_9 = (word16) edx;
	edx_16_16_36 = SLICE(edx, word16, 16);
	bl_12 = (byte) ebx;
	ebx_24_8_15 = SLICE(ebx, word24, 8);
	if (C)
	{
		fn0040D8B3();
		edx_37 = SEQ(edx_16_16_36, dh_18, dl_19);
	}
	else
	{
		__in<word32>(dx_9);
		__halt();
	}
}

// 0040D6C8: define fn0040D6C8
// Called from:
//      fn0040DA65
//      fn0040DA87
define fn0040D6C8
{
	word32 ecx;
	ptr32 fp;
	byte dl;
	cl = (byte) ecx;
	bool C;
	word32 eax;
	word24 edx_24_8;
	byte bh;
	byte bl;
	word16 ebx_16_16;
	word32 edi;
	word32 esi;
	word32 ebp;
	bool P;
	dl_9 = __rcr<byte,byte>(dl + 0x01, cl, C);
	eax_11 = eax + 0x08;
	edx_13 = SEQ(edx_24_8, dl_9);
	edx_14 = edx_13 >> cl;
	edx_16 = __rol<word32,byte>(edx_14, cl);
	dl_29 = (byte) edx_16;
	edx_16_16_30 = SLICE(edx_16, word16, 16);
	bh_19 = (bh ^ ~0x28) & 0x23;
	ecx_25 = ecx;
	ebx_28 = SEQ(ebx_16_16, bh_19, bl);
	if (bh_19 < 0x00)
		fn0040D925();
	else
	{
		dl_45 = (byte) edx_16;
		edx_16_16_46 = SLICE(edx_16, word16, 16);
		edx_24_8_64 = SLICE(edx_16, word24, 8);
		ebx_44 = ebx_28;
		if (bh_19 >= 0x00)
			fn0040D925();
		else
		{
			ecx_24_8_66 = SLICE(ecx_25 + 0x01, word24, 8);
			*edx_16.u7 = __ror<byte,byte>(*edx_16.u7, ~0x29);
			fn0040DAD8();
			C_78 = SLICE(SCZOP_75, bool, 1);
			O_87 = SLICE(SCZOP_75, bool, 4);
			P_89 = SLICE(SCZOP_75, bool, 5);
			S_92 = (bool) SCZOP_75;
			Z_95 = SLICE(SCZOP_75, bool, 2);
		}
	}
}

// 0040D6EC: define fn0040D6EC
// Called from:
//      fn0040D736
//      fn0040DD51
define fn0040D6EC
{
	ptr32 fp;
	fn0040DA65();
	C_10 = SLICE(SCZO_9, bool, 1);
	O_11 = SLICE(SCZO_9, bool, 4);
	S_12 = (bool) SCZO_9;
	Z_13 = SLICE(SCZO_9, bool, 2);
	Top_5 = 0;
}

// 0040D6FE: define fn0040D6FE
// Called from:
//      fn0040D515
define fn0040D6FE
{
	esp = fp;
	Top = 0;
	esi >>= cl;
	ecx >>= cl;
	ecx >>= cl;
	SCZO = cond(ecx);
	if (Test(LE,SZO))
		fn0040DEE0();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(GT,SZO))
			fn0040DEE0();
		else
		{
			esp -= 2;
			*esp = (struct Eq_3798 **) cs;
			fnD2906503();
		}
	}
}

// 0040D719: define fn0040D719
// Called from:
//      fn0040D515
//      fn0040DAD8
define fn0040D719
{
	byte dl;
	byte cl;
	bool C;
	byte bl;
	byte ch;
	byte ah;
	word32 esi;
	byte bh;
	byte dh;
	Top_3 = 0;
	dl_8 = __rcr<byte,byte>(dl, cl, C);
	bl_10 = bl << cl;
	ch_12 = ch & 0x2E;
	bl_13 = bl_10 << cl;
	ah_15 = ah >> cl;
	esi_17 = esi >> cl;
	bh_20 = bh + dh;
	esi_21 = esi_17 << cl;
	ah_24 = (int8) (&(dl_8.u4 + ah_15 /8 6)->u0 + (byte) (esi_21 < 0x00));
	SCZO_25 = cond(ah_24);
	C_26 = SLICE(SCZO_25, bool, 1);
	O_27 = SLICE(SCZO_25, bool, 4);
	S_28 = (bool) SCZO_25;
	Z_29 = SLICE(SCZO_25, bool, 2);
	fn0040D4C3();
}

// 0040D736: define fn0040D736
// Called from:
//      fn0040D94D
//      fn0040DAD8
define fn0040D736
{
	ui40 eax_dh;
	byte bl;
	byte cl;
	byte bh;
	word16 ebx_16_16;
	bl_6 = bl << cl;
	ebx_bh_74 = SEQ(ebx_12, bh);
	eax_dh_75 = eax_dh;
	ebx_bh_76 = ebx_bh_74 - eax_dh_75;
	bh_9 = (byte) ebx_bh_76;
	ebx_15 = SLICE(ebx_bh_76, word32, 8);
	ebx_12 = SEQ(ebx_16_16, bh_9, bl_6);
	bh_16 = SLICE(ebx_15, byte, 8);
	bl_30 = (byte) ebx_15;
	ebx_16_16_35 = SLICE(ebx_15, word16, 16);
	ebx_45 = SEQ(ebx_16_16_35, bh_16 + 0x5B, bl_30);
	if (bh_16 <= 0xA5)
	{
		fn0040DBB3();
		C_78 = SLICE(SCZOP_42, bool, 1);
		O_89 = SLICE(SCZOP_42, bool, 4);
		P_94 = SLICE(SCZOP_42, bool, 5);
		S_99 = (bool) SCZOP_42;
		Z_105 = SLICE(SCZOP_42, bool, 2);
		ebx_84 = SEQ(ebx_16_16_35, bh_16 + 0x5B, bl_30);
	}
	else
	{
		ebx_46 = ebx_45;
		if (bh_16 > 0xA5)
		{
			fn0040DBB3();
			C_79 = SLICE(SCZOP_58, bool, 1);
			O_90 = SLICE(SCZOP_58, bool, 4);
			P_95 = SLICE(SCZOP_58, bool, 5);
			S_100 = (bool) SCZOP_58;
			Z_106 = SLICE(SCZOP_58, bool, 2);
		}
		else if (bh_16 >= 0xA5)
		{
			fn0040D6EC();
			C_81 = SLICE(SCZOP_67, bool, 1);
			O_92 = SLICE(SCZOP_67, bool, 4);
			P_97 = SLICE(SCZOP_67, bool, 5);
			S_102 = (bool) SCZOP_67;
			Z_108 = SLICE(SCZOP_67, bool, 2);
		}
		else
		{
			fn0040DBB3();
			C_80 = SLICE(SCZOP_73, bool, 1);
			O_91 = SLICE(SCZOP_73, bool, 4);
			P_96 = SLICE(SCZOP_73, bool, 5);
			S_101 = (bool) SCZOP_73;
			Z_107 = SLICE(SCZOP_73, bool, 2);
		}
	}
}

// 0040D7DD: define fn0040D7DD
// Called from:
//      fn0040D515
//      fn0040DD3A
define fn0040D7DD
{
	byte ch;
	byte cl;
	word32 esi;
	word16 ecx_16_16;
	word32 edx;
	dl_30 = (byte) edx;
	edx_16_16_31 = SLICE(edx, word16, 16);
	word32 edi;
	dh_17 = SLICE(edx, byte, 8);
	Top_3 = 0;
	ch_6 = ch << cl;
	SCZO_7 = cond(ch_6);
	C_11.u0 = SLICE(SCZO_7, bool, 1);
	bh_18 = SLICE(esi, byte, 8);
	ch_12 = __rcr<byte,byte>(ch_6, cl, C_11);
	ecx_14 = SEQ(ecx_16_16, ch_12, cl);
	ecx_16 = ecx_14 & edx;
	ecx_16_16_23 = SLICE(ecx_16, word16, 16);
	cl_24 = (byte) ecx_16;
	dh_19 = dh_17 + bh_18;
	ecx_25 = SEQ(ecx_16_16_23, 0x3D, cl_24);
	edi_26 = edi & ecx_25;
	fn0040D9B4();
}

// 0040D8B3: define fn0040D8B3
// Called from:
//      fn0040D651
//      fn0040D653
//      fn0040D6FE
//      fn0040DB59
define fn0040D8B3
{
	word16 dx;
	word32 ecx;
	byte ah;
	byte bl;
	word32 esi;
	cl = (byte) ecx;
	word32 edi;
	word24 ebx_24_8;
	ebx_16_16_40 = SLICE(ebx_24_8, word16, 8);
	byte al;
	word16 eax_16_16;
	bh_16 = (byte) ebx_24_8;
	Top_3 = 0;
	esi_11 = __ror<word32,byte>(esi, cl);
	ebx_14 = SEQ(ebx_24_8, bl - 0x01);
	edi_15 = edi ^ ebx_14;
	ecx_19 = ecx;
	ecx_20 = ecx_19 - 0x01;
	ch_25 = SLICE(ecx_19 - 0x01, byte, 8);
	dh_dl_37 = dx;
	dh_dl_38 = dh_dl_37 - SEQ(ch_25, 0x5D);
	dl_22 = (byte) dh_dl_38;
	dh_27 = SLICE(dh_dl_38, byte, 8);
	bl_28 = bl - 0x01 & 0x08;
	eax_32 = SEQ(eax_16_16, ah + 110, al);
	eax_33 = eax_32 - edi_15;
	SCZO_34 = cond(eax_33);
	C_39 = SLICE(SCZO_34, bool, 1);
	SZO_36 = cond(bh_16 - 252);
	ebx_41 = SEQ(ebx_16_16_40, bh_16 - 252, bl_28);
	O_42 = SLICE(SZO_36, bool, 4);
	S_43 = (bool) SZO_36;
	Z_44 = SLICE(SZO_36, bool, 2);
	fn0040DB51();
}

// 0040D925: define fn0040D925
// Called from:
//      fn0040D6C8
//      fn0040DDE6
define fn0040D925
{
	word32 ecx;
	word32 ebx;
	word32 eax;
	al_10 = (byte) eax;
	cl = (byte) ecx;
	byte dl;
	word16 edx_16_16;
	word32 edi;
	word32 esi;
	<unknown> Mem0;
	word32 ebp;
	Top_3 = 0;
	ebx_6 = ebx - eax;
	bh_7 = SLICE(ebx_6, byte, 8);
	bl_21 = (byte) ebx_6;
	ebx_16_16_34 = SLICE(ebx_6, word16, 16);
	bh_9 = bh_7 << cl;
	edx_14 = SEQ(edx_16_16, al_10, dl);
	edx_16 = __rol<word32,byte>(edx_14, cl);
	dl_24 = (byte) edx_16;
	edx_24_8_31 = SLICE(edx_16, word24, 8);
	edi_19 = edi & esi;
	bl_23 = __rcr<byte,byte>(bl_21, cl, false);
	eax_27 = *eax;
	al_60 = (byte) eax_27;
	edi_28 = edi_19 << cl;
	edx_32 = SEQ(edx_24_8_31, dl_24 + 0x01);
	ebx_35 = SEQ(ebx_16_16_34, bh_9, bl_23);
	ecx_43 = ecx;
	if (edi_28 >= 0x00)
	{
		ebx_36 = ebx_35;
		if (edi_28 < 0x00)
		{
			edx_65 = edx_32 - 0x01;
			v23_66 = *esi;
			*(edi_19 << cl) = v23_66;
			esi_68 = esi + 1;
			edi_69 = edi_28 + 4;
			v27_89 = (byte) (&(bl_23.u4 + ebp->b32F2D399 /8 6)->u0 + (byte) (edi_28 < 0x00));
			ebp->b32F2D399 = v27_89;
			SCZO_91 = cond(v27_89);
			C_101 = SLICE(SCZO_91, bool, 1);
			O_119 = SLICE(SCZO_91, bool, 4);
			S_121 = (bool) SCZO_91;
			Z_126 = SLICE(SCZO_91, bool, 2);
			fn0040D94D();
			return;
		}
	}
	dh_48 = (byte) edx_24_8_31;
	edx_16_16_112 = SLICE(edx_24_8_31, word16, 8);
	ebx_44 = ebx_35 - ecx_43;
	&bh_50.u4->u0 = SLICE(ebx_44, byte, 8);
	bl_56 = (byte) ebx_44;
	ebx_16_16_107 = SLICE(ebx_44, word16, 16);
	edi_47 = esi;
	bh_53 = __rol<byte,byte>(bh_50, cl);
	esi_55 = esi << cl;
	bh_61 = bh_53 & 0x96 | al_60;
	SZ_62 = cond(bh_61);
	S_122 = (bool) SZ_62;
	Z_127 = SLICE(SZ_62, bool, 2);
	O_63 = false;
	C_64 = false;
	ebx_108 = SEQ(ebx_16_16_107, bh_61, bl_56 - ~0x60);
	edx_114 = SEQ(edx_16_16_112, dh_48 - 0x8C, dl_24 + 0x01);
	fn0040DD86();
}

// 0040D94D: define fn0040D94D
// Called from:
//      fn0040D4F6
//      fn0040D6C8
define fn0040D94D
{
	byte cl;
	byte bl;
	word32 esi;
	word32 edi;
	byte bh;
	esi_22 = __rol<word32,byte>(esi, cl);
	edi_24 = edi << cl;
	bl_25 = bl >> cl;
	bh_28 = bh ^ 0x14;
	fn0040D736();
	C_43 = SLICE(SCZO_40, bool, 1);
	O_44 = SLICE(SCZO_40, bool, 4);
	S_45 = (bool) SCZO_40;
	Z_46 = SLICE(SCZO_40, bool, 2);
	Top_39 = 0;
}

// 0040D993: define fn0040D993
// Called from:
//      fn0040DB59
//      fn0040DBB3
define fn0040D993
{
	ptr32 fp;
	byte bh;
	byte cl;
	byte bl;
	word32 edi;
	byte dl;
	word32 esi;
	word24 edx_24_8;
	bool P;
	bh_20 = bh >> cl;
	v7_22 = (bl & 0x01 << cl) != 0x00;
	bl_23 = __ror<byte,byte>(bl, cl);
	edi_27 = __rcr<word32,byte>(edi, cl, v7_22);
	v15_30 = (bh_20 & 0x01 << cl) != 0x00;
	bh_31 = __ror<byte,byte>(bh_20, cl);
	edx_35 = SEQ(edx_24_8, dl ^ 0x13);
	esi_36 = esi - edx_35 - v15_30;
	if (P)
	{
		fn0040DAD8();
		C_54 = SLICE(SCZOP_43, bool, 1);
		O_62 = SLICE(SCZOP_43, bool, 4);
		P_65 = SLICE(SCZOP_43, bool, 5);
		S_68 = (bool) SCZOP_43;
		Z_72 = SLICE(SCZOP_43, bool, 2);
	}
	else
	{
		fn0040D9A6();
		C_55 = SLICE(SCZOP_48, bool, 1);
		O_63 = SLICE(SCZOP_48, bool, 4);
		P_66 = SLICE(SCZOP_48, bool, 5);
		S_69 = (bool) SCZOP_48;
		Z_73 = SLICE(SCZOP_48, bool, 2);
	}
}

// 0040D9A6: define fn0040D9A6
// Called from:
//      fn0040D993
//      fn0040DAD8
define fn0040D9A6
{
	ptr32 fp;
	fn0040DAD8();
	C_28 = SLICE(SCZOP_23, bool, 1);
	O_29 = SLICE(SCZOP_23, bool, 4);
	P_30 = SLICE(SCZOP_23, bool, 5);
	S_31 = (bool) SCZOP_23;
	Z_32 = SLICE(SCZOP_23, bool, 2);
	Top_21 = 0;
}

// 0040D9B4: define fn0040D9B4
// Called from:
//      fn0040D515
//      fn0040D7DD
define fn0040D9B4
{
	word32 esi;
	byte cl;
	byte dl;
	byte dh;
	word32 edi;
	word16 edx_16_16;
	Top_17 = 0;
	bh_21 = SLICE(esi, byte, 8);
	bl_24 = (byte) esi;
	ebx_16_16_51 = SLICE(esi, word16, 16);
	SCZO_23 = cond(bh_21 - ~0x32);
	C_27.u0 = SLICE(SCZO_23, bool, 1);
	bl_28 = __rcr<byte,byte>(bl_24, cl, C_27);
	esi_33 = __rol<word32,byte>(esi + 0x01, ~0x34);
	edx_40 = SEQ(edx_16_16, dh - 0xCC, dl | 0xAC);
	edi_41 = edi & edx_40;
	bh_44 = __rcr<byte,byte>(bh_21 - ~0x32, ~0x34, false);
	dl_45 = (dl | 0xAC) << ~0x34;
	dh_47 = dh - 0xCC & 0x32;
	ebx_52 = SEQ(ebx_16_16_51, bh_44, bl_28);
	edx_53 = SEQ(edx_16_16, dh_47, dl_45);
	fn0040D4F6();
}

// 0040DA65: define fn0040DA65
// Called from:
//      fn0040D515
//      fn0040D566
//      fn0040D6EC
//      fn0040DBB3
//      fn0040DC18
define fn0040DA65
{
	word32 edx;
	word32 esi;
	byte cl;
	word32 ebx;
	ebx_16_16_21 = SLICE(ebx, word16, 16);
	dh = SLICE(edx, byte, 8);
	word32 eax;
	bl_9 = (byte) ebx;
	bh_15 = SLICE(ebx, byte, 8);
	esi_6 = esi >> cl;
	esi_8 = esi_6 + ebx;
	SCZO_11 = cond(bl_9 - 0x68);
	C_13.u0 = SLICE(SCZO_11, bool, 1);
	esi_14 = __rcl<word32,byte>(esi_8, cl, C_13);
	bh_17 = bh_15 ^ dh;
	esi_18 = esi_14 << cl;
	ebx_22 = SEQ(ebx_16_16_21, bh_17, bl_9 - 0x68);
	if (esi_18 < 0x00)
	{
		fn0040D6C8();
		C_54 = SLICE(SCZOP_28, bool, 1);
		O_64 = SLICE(SCZOP_28, bool, 4);
		P_68 = SLICE(SCZOP_28, bool, 5);
		S_72 = (bool) SCZOP_28;
		Z_77 = SLICE(SCZOP_28, bool, 2);
	}
	else if (esi_18 >= 0x00)
	{
		fn0040D6C8();
		C_55 = SLICE(SCZOP_42, bool, 1);
		O_65 = SLICE(SCZOP_42, bool, 4);
		P_69 = SLICE(SCZOP_42, bool, 5);
		S_73 = (bool) SCZOP_42;
		Z_78 = SLICE(SCZOP_42, bool, 2);
	}
	else
	{
		*(word32 *) 0x13A1A108 = eax;
		fn0040DA87();
		C_56 = SLICE(SCZOP_50, bool, 1);
		O_66 = SLICE(SCZOP_50, bool, 4);
		P_70 = SLICE(SCZOP_50, bool, 5);
		S_74 = (bool) SCZOP_50;
		Z_79 = SLICE(SCZOP_50, bool, 2);
	}
}

// 0040DA87: define fn0040DA87
// Called from:
//      fn0040DA65
//      fn0040DD51
//      fn0040DDE6
define fn0040DA87
{
	word40 dh_esi;
	ptr32 fp;
	byte cl;
	byte bh;
	word32 edi;
	word16 ebx_16_16;
	v24_44 = dh_esi >> cl;
	dh_20 = SLICE(v24_44, byte, 32);
	esi_25 = (word32) v24_44;
	edi_27 = edi << cl;
	ebx_29 = SEQ(ebx_16_16, bh | 0x35, 77);
	ebx_30 = ebx_29 | esi_25;
	bl_34 = (byte) ebx_30;
	bh_35 = SLICE(ebx_30, byte, 8);
	ebx_16_16_36 = SLICE(ebx_30, word16, 16);
	fn0040D6C8();
	C_45 = SLICE(SCZO_41, bool, 1);
	O_46 = SLICE(SCZO_41, bool, 4);
	S_47 = (bool) SCZO_41;
	Z_48 = SLICE(SCZO_41, bool, 2);
	Top_40 = 0;
}

// 0040DAD8: define fn0040DAD8
// Called from:
//      fn0040D6C8
//      fn0040D736
//      fn0040D993
//      fn0040D9A6
define fn0040DAD8
{
	ptr32 fp;
	byte bl;
	byte bh;
	byte cl;
	word32 edi;
	byte ch;
	word32 esi;
	word32 eax;
	al_69 = (byte) eax;
	ah_74 = SLICE(eax, byte, 8);
	eax_16_16_341 = SLICE(eax, word16, 16);
	byte dl;
	word16 ebx_16_16;
	word16 ecx_16_16;
	word24 edx_24_8;
	selector es;
	word32 ebp;
	real64 rArg0;
	bool P;
	bh_10 = __rcr<byte,byte>(bh, cl, false);
	edi_12 = edi >> cl;
	bh_14 = __ror<byte,byte>(bh_10, cl);
	bh_16 = bh_14 - ch;
	esi_21 = esi + eax + (word32) (bh_16 < 0x00);
	dl_24 = __ror<byte,byte>(dl, 0x1D);
	ebx_27 = SEQ(ebx_16_16, bh_16, bl | 0xAA);
	ebx_28 = ebx_27 - eax;
	bl_33 = (byte) ebx_28;
	bh_44 = SLICE(ebx_28, byte, 8);
	ebx_16_16_49 = SLICE(ebx_28, word16, 16);
	ecx_24_8_40 = SEQ(ecx_16_16, ch);
	v21_30 = (edi_12 & 0x01 << 0x20 - cl) != 0x00;
	edi_31 = __rol<word32,byte>(edi_12, cl);
	bl_34 = bl_33 - 0x68 - v21_30;
	SCZO_35 = cond(bl_34);
	C_37.u0 = SLICE(SCZO_35, bool, 1);
	bl_38 = __rcr<byte,byte>(bl_34, cl, C_37);
	ecx_41 = SEQ(ecx_24_8_40, cl);
	esi_42 = esi_21 + ecx_41;
	bl_43 = bl_38 >> cl;
	v25_46 = (bl_43 & 0x01 << 0x08 - cl) != 0x00;
	bl_47 = __rol<byte,byte>(bl_43, cl);
	ebx_50 = SEQ(ebx_16_16_49, bh_44 - 0x01, bl_47);
	ebx_51 = ebx_50 - ecx_41 - v25_46;
	bh_53 = SLICE(ebx_51, byte, 8);
	bl_61 = (byte) ebx_51;
	ebx_16_16_62 = SLICE(ebx_51, word16, 16);
	esi_52 = esi_42 & ebx_51;
	bh_54 = (byte) dl_24.u1 + bh_53;
	bh_dl_354 = SEQ(bh_54, dl_24);
	bh_59 = SLICE(bh_dl_354 + 11726, byte, 8);
	edi_60 = edi_31 << cl;
	ebx_63 = SEQ(ebx_16_16_62, bh_59, bl_61);
	edx_65 = SEQ(edx_24_8, (byte) dl_24.u1 + 0x00CE);
	ebx_66 = ebx_63 ^ edx_65;
	ebx_16_16_79 = SLICE(ebx_66, word16, 16);
	bl_80 = (byte) ebx_66;
	esi_71 = esi_52 << cl;
	bh_76 = al_69 + 0x86 - ah_74 - (byte) (al_69 < 122);
	ecx_77 = SEQ(ecx_24_8_40, cl);
	edi_78 = edi_60 | ecx_77;
	ebx_81 = SEQ(ebx_16_16_79, bh_76, bl_80);
	ebx_82 = ebx_81 >> cl;
	bl_84 = (byte) ebx_82;
	ebx_24_8_90 = SLICE(ebx_82, word24, 8);
	dl_83 = -((byte) dl_24.u1 + 0x00CE);
	bl_85 = bl_84 << cl;
	edx_88 = SEQ(edx_24_8, dl_83);
	ebx_91 = SEQ(ebx_24_8_90, bl_85);
	if (bl_85 < 0x00 || bl_85 >= 0x00)
	{
		bh_102 = (byte) ebx_24_8_90;
		ebx_16_16_112 = SLICE(ebx_24_8_90, word16, 8);
		esi_95 = esi_71 | ebx_91;
		esi_97 = esi_95 - edx_88;
		edi_101 = __ror<word32,byte>(edi_78, cl);
		bh_104 = __ror<byte,byte>(bh_102, cl);
		bl_107 = __rol<byte,byte>(bl_85, cl);
		bl_109 = bl_107 - dl_83;
		ebx_126 = SEQ(ebx_16_16_112, bh_104, bl_109);
		if (bl_109 == 0x00)
		{
			fn0040DC18();
			esp_119 = fp;
			C_372 = SLICE(SCZOP_124, bool, 1);
			O_395 = SLICE(SCZOP_124, bool, 4);
			P_404 = SLICE(SCZOP_124, bool, 5);
			S_408 = (bool) SCZOP_124;
			Z_413 = SLICE(SCZOP_124, bool, 2);
			ebx_382 = SEQ(ebx_16_16_112, bh_104, bl_109);
		}
		else
		{
			dl_131 = dl_83;
			edx_24_8_132 = edx_24_8;
			ebx_127 = ebx_126;
			bl_128 = bl_109;
			bh_129 = bh_104;
			ebx_16_16_130 = ebx_16_16_112;
			if (bl_109 != 0x00)
			{
				fn0040DC18();
				esp_133 = fp;
				C_373 = SLICE(SCZOP_138, bool, 1);
				O_396 = SLICE(SCZOP_138, bool, 4);
				P_405 = SLICE(SCZOP_138, bool, 5);
				S_409 = (bool) SCZOP_138;
				Z_414 = SLICE(SCZOP_138, bool, 2);
			}
			else
			{
				al_140 = al_69 + 0x86 + (byte) (bl_109 < 0x00);
				SCZO_141 = cond(al_140);
				C_338.u0 = SLICE(SCZO_141, bool, 1);
				esp_143 = fp - 4;
				do
				{
					Mem347 = ϕ(Mem237, Mem237, Mem144);
					eax_16_16_207 = ϕ(eax_16_16_340, eax_16_16_340, eax_16_16_341);
					ebx_16_16_186 = ϕ(ebx_16_16_284, ebx_16_16_325, ebx_16_16_130);
					esi_174 = ϕ(esi_226, esi_226, esi_97);
					ah_173 = ϕ(ah_339, ah_339, ah_74);
					bh_168 = ϕ(bh_279, bh_324, bh_129);
					ecx_16_16_164 = ϕ(ecx_16_16_288, ecx_16_16_288, ecx_16_16);
					bl_161 = ϕ(bl_280, bl_323, bl_128);
					al_158 = ϕ(al_266, al_266, al_140);
					ch_154 = ϕ(ch_286, ch_286, ch);
					edx_24_8_151 = ϕ(edx_24_8_296, edx_24_8_327, edx_24_8_132);
					dh_155 = (byte) edx_24_8_151;
					edi_150 = ϕ(edi_219, edi_219, edi_101);
					C_148 = ϕ(C_337, C_337, C_338);
					cl_146 = ϕ(cl_225, cl_225, cl);
					dl_145 = ϕ(dl_293, dl_326, dl_131);
					dl_149 = __rcl<byte,byte>(dl_145, cl_146, C_148);
					edx_152 = SEQ(edx_24_8_151, dl_149);
					edi_153 = edi_150 | edx_152;
					ch_156 = ch_154 ^ dh_155;
					al_160 = __rcl<byte,byte>(al_158, cl_146, false);
					bl_162 = (byte) &(dl_149.u4 + bl_161 /8 6)->u0;
					ecx_165 = SEQ(ecx_16_16_164, ch_156, cl_146);
					ecx_166 = ecx_165 >> cl_146;
					ch_167 = SLICE(ecx_166, byte, 8);
					cl_172 = (byte) ecx_166;
					ecx_16_16_345 = SLICE(ecx_166, word16, 16);
					ch_169 = ch_167 - bh_168;
					if (OVERFLOW<byte>(ch_169))
					{
						fn0040D719();
						eax_375 = SEQ(eax_16_16_207, ah_175, al_160 & 118);
						ebx_378 = SEQ(ebx_16_16_186, bh_176, bl_177);
						ecx_384 = SEQ(ecx_16_16_345, ch_178, cl_172);
						edx_388 = SEQ(edx_24_8_151, dl_179);
						return;
					}
					dh_192 = (byte) edx_24_8_151;
					eax_208 = SEQ(eax_16_16_207, ah_173, al_160 & 118);
					if (!OVERFLOW<byte>(ch_169))
					{
						fn0040D719();
						eax_376 = SEQ(eax_16_16_207, ah_193, al_160 & 118);
						ebx_380 = SEQ(ebx_16_16_186, bh_194, bl_195);
						ecx_385 = SEQ(ecx_16_16_345, ch_196, cl_172);
						edx_390 = SEQ(edx_24_8_151, dl_197);
						return;
					}
					edi_204 = -edi_153;
					al_266 = dl_149;
					ah_339 = (byte) edx_24_8_151;
					eax_16_16_340 = SLICE(edx_24_8_151, word16, 8);
					while (true)
					{
						Mem237 = ϕ(Mem347, Mem247);
						edx_24_8_300 = SLICE(eax_208, word24, 8);
						esi_224 = ϕ(esi_174, esi_226);
						cl_225 = cl_172;
						ch_286 = ch_169;
						ecx_16_16_288 = ecx_16_16_345;
						edi_218 = ϕ(edi_204, edi_219);
						edi_219 = edi_218 - 2042100085;
						esi_226 = esi_224 << cl_172;
						ebx_235 = SEQ(ecx_16_16_345, ch_169 + 0x0D, cl_172);
						if (ch_169 < ~0x0C)
							break;
						edx_24_8_297 = SLICE(eax_208, word24, 8);
						if (ch_169 >= ~0x0C)
							break;
						if (ch_169 >= ~0x0C)
						{
							dh_250 = ah_173 ^ edx_152->b0077;
							edx_24_8_299 = SEQ(eax_16_16_207, dh_250);
							break;
						}
						v53_238 = (byte) &(cl_172.u4 + ebx_235->bF1B8DD2 /8 6)->u0;
						ebx_235->bF1B8DD2 = v53_238;
						v54_240 = *(esi_224 << cl_172) ^ 0xF7000001;
						*(esi_224 << cl_172) = v54_240;
						eax_208->wD7D2F3D3 = (int16) rArg0;
					}
					edx_24_8_296 = ϕ(edx_24_8_297, edx_24_8_299, edx_24_8_300);
					dl_293 = al_160 & 118;
					bh_254 = ch_167 - bh_168 + 0x0D;
					bh_257 = bh_254 << cl_172;
					ebx_262 = SEQ(ecx_16_16_345, bh_257, cl_172);
					bh_273 = SLICE(ebx_262 + 0x01, byte, 8);
					ebx_16_16_284 = SLICE(ebx_262 + 0x01, word16, 16);
					bl_267 = (byte) cl_172 + 1 - dl_149;
					bl_270 = bl_267 + 0xC2 + (byte) (bl_267 < 0x00);
					bl_271 = bl_270 << cl_172;
					bh_275 = bh_273 + 0xAA + (byte) (bl_271 < 0x00);
					SCZO_276 = cond(bh_275);
					C_278.u0 = SLICE(SCZO_276, bool, 1);
					bh_279 = __rcl<byte,byte>(bh_275, cl_172, C_278);
					bl_280 = bl_271 | 0x07;
					SCZO_282 = cond(edi_219 - 0x8648068B);
					eax_292 = SEQ(edx_24_8_151, dl_149);
					C_337.u0 = SLICE(SCZO_282, bool, 1);
					if (edi_219 != 0x8648068B)
					{
						fn0040D736();
						esp_305 = fp;
						C_371 = SLICE(SCZOP_310, bool, 1);
						O_394 = SLICE(SCZOP_310, bool, 4);
						P_403 = SLICE(SCZOP_310, bool, 5);
						S_407 = (bool) SCZOP_310;
						Z_412 = SLICE(SCZOP_310, bool, 2);
						ebx_381 = SEQ(ebx_16_16_284, bh_279, bl_271 | 0x07);
						return;
					}
					if (edi_219 < 0x8648068B)
						continue;
					dl_326 = al_160 & 118;
					edx_24_8_327 = edx_24_8_296;
					bl_323 = bl_271 | 0x07;
					bh_324 = bh_279;
					ebx_16_16_325 = ebx_16_16_284;
				} while (edi_219 >= 0x8648068B);
				fn13C5_F2CD();
			}
		}
	}
	else
		fn0040DC29();
}

// 0040DB51: define fn0040DB51
// Called from:
//      fn0040D515
//      fn0040D6FE
define fn0040DB51
{
	esp = fp;
	Top = 0;
	--edx;
	edx = (word32) ((bool) C + (edx + eax));
	bh &= 0x80;
	edx -= esi;
	SCZO = cond(edx);
	fn0040DB59();
}

// 0040DB59: define fn0040DB59
// Called from:
//      fn0040D515
//      fn0040DB51
//      fn0040DB83
define fn0040DB59
{
	esp = fp;
	Top = 0;
	al -= 0x08;
	ecx >>= 0x0F;
	ebx += eax;
	SCZO = cond(ebx);
	v12 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v12;
	&dh.u4->u0 = &(C.u4 + ((byte) dh.u1 + 0x009C) /8 6)->u0;
	dl &= bl;
	esi |= ebx;
	C.u0 = false;
	esi = esi + ebx + C;
	SCZO = cond(esi);
	if (Test(GT,SZO))
	{
		edx = edx;
		ebx = ebx;
		if (Test(LE,SZO))
		{
			SZP = cond(*edx.u7 & ~0x522105F7);
			dl |= dl;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			fn0040DB83();
			return;
		}
	}
	v23 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rol<word32,byte>(eax, cl);
	eax >>= cl;
	SCZO = cond(eax);
	edx = edx + ebx + C;
	--edx;
	v24 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	bh = ah;
	ecx <<= 0x0F;
	SCZO = cond(ecx);
	al = al - 151 - C;
	bl >>= cl;
	dl -= ch;
	SCZO = cond(dl);
	eax &= edx;
	edx <<= cl;
	SCZO = cond(edx);
	v28 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	C = v28;
	v29 = (al & 0x01 << cl) != 0x00;
	al = __rcr<byte,byte>(al, cl, C);
	C = v29;
	v30 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rcl<byte,byte>(dl, cl, C);
	C = v30;
	&bh.u4->u0 = (bool) C.u0 + ((byte) bh + 88);
	ah -= al;
	edi <<= cl;
	SCZO = cond(edi);
	v31 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	&dh.u4->u0 = &(dh.u4 + ch /8 6)->u0;
	SCZO = cond(dh);
	&v32.u4->u0 = ecx->t0000.u4;
	esp -= 4;
	*esp.u7 = v32;
	dl = dl - 0x29 - C;
	SCZO = cond(dl);
	edi = eax;
	if (Test(NE,Z))
	{
		edx = edx;
		ebx = ebx;
		if (Test(EQ,Z))
		{
			esp -= 2;
			*esp.u7 = ss;
			dl.u0 = 0xD2;
			dl <<= cl;
			SCZO = cond(dl);
			v35 = (cl & 0x01 << cl) != 0x00;
			cl = __rcr<byte,byte>(cl, cl, C);
			&bh.u4->u0 = (byte) bh + 0x007E;
			esp -= 4;
			*esp.u7 = eax;
			bh = bh ^ 0x0D;
			SZ = cond(bh);
			O = false;
			C.u0 = false;
			if (Test(UGT,CZ))
			{
				edx = edx;
				ebx = ebx;
				if (Test(ULE,CZ))
				{
					SZP = cond(dl & bh);
					O = false;
					C.u0 = false;
					esp = *esp.u7;
					&esp.u4->u0 = (word32) esp + 4;
					__out<word32>(dx, eax);
					&esi.u4->u0 = (word32) esi + 4;
					esp -= 4;
					*esp.u7 = SCZDOP;
					C = !C;
					edx = ss;
					fn0040D630();
					return;
				}
			}
			v41 = (bl & 0x01 << 0x08 - cl) != 0x00;
			bl = __rcl<byte,byte>(bl, cl, C);
			dl += bh;
			SCZO = cond(dl);
			fn0040DD3A();
			return;
		}
	}
	&dh.u4->u0 = (byte) dh + 1;
	dl |= 0xB8;
	v45 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	esi += ecx;
	ebx += esi;
	bh.u0 = ~0x62;
	dh = dh ^ dl;
	C.u0 = false;
	bl = bl - 0x29 - C;
	bl >>= cl;
	bh &= ~0x18;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
	eax = *esp.u7;
	&esp.u4->u0 = (word32) esp + 4;
	bh -= ah;
	esi = eax;
	bh |= ah;
	C.u0 = false;
	bh = bh - 0x05 - C;
	SCZO = cond(bh);
	bl = bl - ~0x44 - C;
	ebx = ebx ^ esi;
	&dl.u4->u0 = (byte) dl.u0 + 1;
	bl <<= cl;
	SCZO = cond(bl);
	v46 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v46;
	if (Test(UGE,C))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULT,C))
		{
			C = __daa(al, &al);
			al = al ^ 0x12;
			v47 = ebp;
			ebp = eax;
			eax.u0 = ~0x29E51715;
			ebx += ecx;
			v49 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			&bl.u4->u0 = (byte) bl + 0x00DD;
			dh |= bl;
			SZ = cond(dh);
			O = false;
			v50 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rol<byte,byte>(bh, cl);
			C = v50;
			fn0040DDE6();
			return;
		}
	}
	&edx.u4->u0 = (word32) al;
	v51 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	--esi;
	ebx |= eax;
	C.u0 = false;
	--bh;
	--ebx;
	&bh.u4->u0 = (bool) C.u0 + ((byte) bh.u0 + 0x009A);
	&bl.u4->u0 = (byte) bl.u1 + 212;
	bl = bl ^ 0x78;
	C.u0 = false;
	--edi;
	SZO = cond(edi);
	v52 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rcl<word32,byte>(esi, cl, C);
	C = v52;
	&esi.u4->u0 = (word32) esi + 1;
	&bh.u4->u0 = (byte) bh + 244;
	&ebx.u4->u0 = (word32) ah;
	edi = edx;
	esi += eax;
	esi += edi;
	SCZO = cond(esi);
	edi >>= cl;
	edi <<= cl;
	eax >>= 0x10;
	SCZO = cond(eax);
	v54 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	edi <<= cl;
	v55 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	C = v55;
	++edi;
	esi = esi + edi + C;
	eax += edx;
	v56 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	C = v56;
	--dh;
	SZO = cond(dh);
	v57 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rcl<byte,byte>(dl, cl, C);
	v58 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	C = v58;
	dh = dh - cl - C;
	esi &= edx;
	esi >>= cl;
	&dl.u4->u0 = (byte) dl + 0x00CD;
	edx -= eax;
	dl >>= cl;
	eax += ebx;
	SCZO = cond(eax);
	v59 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	ebx += eax;
	bl |= bh;
	C.u0 = false;
	&dh.u4->u0 = (bool) C.u0 + ((byte) dh + 39);
	SCZO = cond(dh);
	if (Test(GT,SZO))
	{
		edx = edx;
		ebx = ebx;
		if (Test(LE,SZO))
		{
			al = __in<byte>(dx);
			ebp -= ~0x1C;
			SCZO = cond(ebp);
			__out<byte>(dx, al);
			++esi;
			edi = *esp.u7;
			&esp.u4->u0 = (word32) esp + 4;
			fn0040D8B3();
			return;
		}
	}
	dl <<= cl;
	bh <<= cl;
	bl |= 0x33;
	edi >>= cl;
	SCZ = cond(edi);
	v60 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	dl |= 0xD2;
	&dh.u4->u0 = (byte) dh + 72;
	eax = eax ^ ~0x0137;
	edx <<= cl;
	dl = dl ^ 0x95;
	ebx >>= cl;
	bl -= 202;
	bh = bh ^ dh;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
	dh <<= cl;
	bh &= 0x1A;
	&ebx.u4->u0 = (word32) ebx + 1;
	esi -= eax;
	dh |= 0xAA;
	C.u0 = false;
	&bl.u4->u0 = (byte) bl + 1;
	dl = dl - dh - C;
	SCZO = cond(dl);
	v61 = (ebx & 0x01 << cl) != 0x00;
	ebx = __rcr<word32,byte>(ebx, cl, C);
	dl |= cl;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	eax = ~eax;
	if (Test(LT,SO))
		fn0040D630();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(GE,SO))
			fn0040D630();
		else
		{
			edx.u0 = ~0x07FC8C24;
			fn0040D993();
		}
	}
}

// 0040DB83: define fn0040DB83
// Called from:
//      fn0040DB59
//      fn0040DD51
define fn0040DB83
{
	esp = fp;
	Top = 0;
	bl >>= cl;
	SCZO = cond(bl);
	v8 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	edx += ecx;
	ebx = (struct Eq_5729 *) ((char *) ebx + 1);
	&bh.u4->u0 = (byte) bh + 1;
	esi <<= cl;
	SCZO = cond(esi);
	bl = bl - ch - C;
	v17 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	bh = bh ^ al;
	C.u0 = false;
	v21 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	bl |= 0xA2;
	C.u0 = false;
	ebx = edx;
	esi = esi + eax + C;
	SCZO = cond(esi);
	if (Test(UGE,C))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULT,C))
		{
			if (Test(NE,Z))
			{
				fn0040DC22();
				return;
			}
			else
			{
				v25 = *ecx - ebp - C;
				*ecx = v25;
				SCZO = cond(*esi.u7 - *edi.u7);
				&esi.u4->u0 = (word32) esi + 4;
				&edi.u4->u0 = (word32) edi + 4;
				*edi.u7 = al;
				&edi.u4->u0 = (word32) edi + 1;
				fn0040DBB3();
				return;
			}
		}
	}
	v26 = ebx->dw1BEBD302 - 0x01;
	ebx->dw1BEBD302 = v26;
	SZO = cond(v26);
}

// 0040DBB3: define fn0040DBB3
// Called from:
//      fn0040D736
//      fn0040DD51
define fn0040DBB3
{
	ptr32 fp;
	fn0040DA65();
	C_86 = SLICE(SCZOP_71, bool, 1);
	O_87 = SLICE(SCZOP_71, bool, 4);
	P_88 = SLICE(SCZOP_71, bool, 5);
	S_89 = (bool) SCZOP_71;
	Z_90 = SLICE(SCZOP_71, bool, 2);
	Top_67 = 0;
}

// 0040DBF1: define fn0040DBF1
// Called from:
//      fn0040DD51
//      fn0040DD86
define fn0040DBF1
{
	esp = fp;
	Top = 0;
	dl <<= cl;
	v7 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	esi -= edi;
	SCZO = cond(esi);
	v12 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	C = v12;
	bh = (byte) &(C.u4 + (bh + al) /8 6)->u0;
	v16 = eax->dw0010;
	esp -= 4;
	*esp = v16;
	bl >>= cl;
	dl <<= cl;
	SCZO = cond(dl);
	if (Test(ULT,C))
		fn0040D497();
	else
		fn0040DC08();
}

// 0040DC08: define fn0040DC08
// Called from:
//      fn0040DBF1
//      fn0040DD51
define fn0040DC08
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(UGE,C))
		fn0040D497();
	else
	{
		al = ebx[(uint32) al];
		ax = __aad(ax);
		esp -= 4;
		esp->u1 = (word32) SCZDOP;
		SCZO = cond(esi - *edx);
		fn0040DC18();
	}
}

// 0040DC18: define fn0040DC18
// Called from:
//      fn0040DAD8
//      fn0040DD51
define fn0040DC18
{
	fn0040DA65();
	C_15 = SLICE(SCZO_11, bool, 1);
	O_16 = SLICE(SCZO_11, bool, 4);
	S_17 = (bool) SCZO_11;
	Z_18 = SLICE(SCZO_11, bool, 2);
	Top_8 = 0;
}

// 0040DC22: define fn0040DC22
// Called from:
//      fn0040DC18
//      fn0040DD51
define fn0040DC22
{
	word32 ebx;
	<unknown> Mem0;
	word32 ebp;
	byte cl;
	ebx->t8B3D70F2.u0 = (int8) __ror<byte,byte>(ebx->t8B3D70F2.u0, 0x01);
	fn0040DC29();
}

// 0040DC29: define fn0040DC29
// Called from:
//      fn0040DAD8
//      fn0040DC22
define fn0040DC29
{
	word32 ebp;
	<unknown> Mem0;
	byte cl;
	ebp->t4A37711B.u0 = (int8) __ror<byte,byte>(ebp->t4A37711B.u0, cl);
	fn0040DC2F();
}

// 0040DC2F: define fn0040DC2F
// Called from:
//      fn0040DAD8
//      fn0040DC29
define fn0040DC2F
{
}

// 0040DCBB: define fn0040DCBB
// Called from:
//      fn0040DDE6
define fn0040DCBB
{
	esp = fp;
	Top = 0;
	dh = (byte) &(C.u4 + (dh + 0xE0) /8 6)->u0;
	esi = edi;
	dl >>= cl;
	ebx >>= cl;
	SCZO = cond(ebx);
	v14 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	C = v14;
	eax += 0x0078;
	if (Test(ULT,C))
		fn0040DA87();
	else
	{
		edx = edx;
		ebx = ebx;
		fn0040DCD3();
	}
}

// 0040DCD3: define fn0040DCD3
// Called from:
//      fn0040DD51
//      fn0040DDE6
define fn0040DCD3
{
	esp = fp;
	Top = 0;
	do
	{
		if (Test(UGE,C))
		{
			fn0040DA87();
			return;
		}
		v8 = esi->b32421AC5 ^ dl;
		esi->b32421AC5 = v8;
		SZ = cond(esi->b32421AC5);
		O = false;
		C.u0 = false;
		ecx = ecx ^ 0x05566345;
		bl <<= cl;
		SCZO = cond(bl);
		al = al - ~0x25 - C;
		ebx <<= cl;
		SCZO = cond(ebx);
		edx = edx + ecx + C;
		v19 = (dh & 0x01 << 0x08 - cl) != 0x00;
		dh = __rol<byte,byte>(dh, cl);
		C = v19;
		v20 = (edx & 0x01 << cl) != 0x00;
		edx = __rcr<word32,byte>(edx, cl, C);
		ah >>= cl;
		--edx;
		edx >>= cl;
		SCZO = cond(edx);
		if (Test(OV,O))
		{
l0040DBD1:
			v28 = (dl & 0x01 << 0x08 - cl) != 0x00;
			dl = __rol<byte,byte>(dl, cl);
			edx >>= cl;
			SCZ = cond(edx);
			esp -= 4;
			*esp = (struct Eq_6058 **) ecx;
			bh = bh - bl - C;
			SCZO = cond(bh);
			v31 = (edx & 0x01 << cl) != 0x00;
			edx = __rcr<word32,byte>(edx, cl, C);
			C = v31;
			edx = edx - eax - C;
			ebx <<= cl;
			SCZO = cond(ebx);
			if (Test(ULE,CZ))
			{
				fn0040D6EC();
				return;
			}
			edx = edx;
			ebx = ebx;
			if (Test(UGT,CZ))
			{
				fn0040D6EC();
				return;
			}
			else
			{
				eax -= (struct Eq_6182 *) ~0x1D2D5411;
				SCZO = cond(eax);
				fn0040DBF1();
				return;
			}
		}
		edx = edx;
		ebx = ebx;
		if (Test(NO,O))
			goto l0040DBD1;
		if (Test(ULT,C))
		{
			eax = (struct Eq_6058 *) *esp;
			esp = (struct Eq_6058 **) ((char *) esp + 4);
			if (Test(PE,P))
			{
				fn0040DD51();
				return;
			}
			else
			{
				ebx -= ecx->dw0022;
				SCZO = cond(ebx);
				fn0040DD10();
				return;
			}
		}
		edi->ptr0000 = edi;
		v26 = Mem0[eax + 0x00:word32] + eax;
		eax->t0000.u4 = (Eq_3 (*)[]) v26;
		v27 = (byte) &(dh.u4 + (edx.u6)->b0054 /8 6)->u0;
		edx.u6->b0054 = v27;
		SCZO = cond(v27);
	} while (Test(OV,O));
	edx = edx + edx + C;
	SCZO = cond(edx);
	fn0040DB83();
}

// 0040DD0E: define fn0040DD0E
// Called from:
//      fn0040D6FE
define fn0040DD0E
{
	esp = fp;
	Top = 0;
	ecx = *esp;
	++esp;
	dl &= al;
	SZ = cond(dl);
	O = false;
	C = false;
	fn0040DD10();
}

// 0040DD10: define fn0040DD10
// Called from:
//      fn0040DD0E
//      fn0040DD51
define fn0040DD10
{
	esp = fp;
	Top = 0;
	v5 = *ebx << 0x01;
	*ebx = v5;
	SCZO = cond(v5);
	__lock();
	dh = (ui8) ((bool) C + (dh + 122));
	dh = dh ^ 166;
	C.u0 = false;
	edx = (ui32) ((bool) C.u0 + (edx + ecx));
	edx += eax;
	ah += bl;
	eax |= edx;
	dl >>= cl;
	SCZO = cond(dl);
	if (Test(ULE,CZ))
		fn0040D651();
	else
		fn0040DD29();
}

// 0040DD29: define fn0040DD29
// Called from:
//      fn0040DD0E
//      fn0040DD10
define fn0040DD29
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(UGT,CZ))
		fn0040D651();
	else
	{
		D = false;
		edx = (word32) ((bool) C + (edx + 0xD702D3D2));
		SCZO = cond(edx);
		fn0040DD3A();
	}
}

// 0040DD3A: define fn0040DD3A
// Called from:
//      fn0040D6FE
//      fn0040DB59
define fn0040DD3A
{
	esp = fp;
	Top = 0;
	&dh.u4->u0 = &(dh.u4 + bh /8 6)->u0;
	v8 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	++edx;
	dl |= ah;
	C.u0 = false;
	v17 = (dh & 0x01 << cl) != 0x00;
	dh = __rcr<byte,byte>(dh, cl, C);
	C = v17;
	ch = (bool) C.u0 + (ch + ah);
	eax += ~0x01B1;
	SCZO = cond(eax);
	if (Test(PE,P))
		fn0040D7DD();
	else
		fn0040DD51();
}

// 0040DD51: define fn0040DD51
// Called from:
//      fn0040D515
//      fn0040DCD3
//      fn0040DD3A
define fn0040DD51
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(PO,P))
		fn0040D7DD();
	else
	{
		ah = ~0x15;
		ebp = esi->dwFFFFFFE3 *s 0x23;
		SCZO = cond(ebp);
		while (true)
		{
			ah += 0xD8;
			bl >>= cl;
			ah <<= cl;
			al >>= cl;
			SCZ = cond(al);
			v17 = (dl & 0x01 << 0x08 - cl) != 0x00;
			dl = __rcl<byte,byte>(dl, cl, C);
			C = v17;
			bh = (byte) &(C.u4 + (bh + 0x47) /8 6)->u0;
			SCZO = cond(bh);
			if (Test(ULT,C))
				break;
			edx = edx;
			ebx = ebx;
			if (Test(UGE,C))
				break;
			if (Test(LE,SZO))
				;
			v21 = edx->a23E36E6B[ebp].dw0000;
			esp -= 4;
			*esp = v21;
		}
		dl = dl ^ dh;
		SZ = cond(dl);
		O = false;
		C.u0 = false;
		fn0040DCD3();
	}
}

// 0040DD86: define fn0040DD86
// Called from:
//      fn0040D515
define fn0040DD86
{
	esp = fp;
	Top = 0;
	eax += ecx;
	edi += edx;
	v10 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	C = v10;
	edx = eax;
	bh = bh - dl - C;
	bh -= ah;
	SCZO = cond(bh);
	fn0040DBF1();
}

// 0040DDE6: define fn0040DDE6
// Called from:
//      fn0040DB59
define fn0040DDE6
{
	esp = fp;
	Top = null;
	esi = esi ^ ebx;
	dh <<= cl;
	dl = dl ^ dh;
	edi >>= cl;
	eax += eax->dw003C / 64;
	SCZO = cond(eax);
	esi = esi + eax + C;
	SCZO = cond(esi);
	v16 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	C = v16;
	if (Test(NO,O))
	{
		edx = edx;
		ebx = ebx;
		if (Test(OV,O))
		{
			__wait();
			esp -= 4;
			esp->u4 = (Eq_3 (*)[]) edi;
			&SCZDOP.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			Top->r0002 = Top->r0000;
			fn0040DE0B();
			return;
		}
	}
	bh = bh ^ 0x00;
	v21 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	C = v21;
	&dh.u4->u0 = (byte) dh + 1;
	v24 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v24;
	v25 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	C = v25;
	esi = esi - eax - C;
	SCZO = cond(esi);
	&esi.u4->u0 = (word32) esi + 1;
	dh = dh - ~0x00 - C;
	SCZO = cond(dh);
	&edx.u4->u0 = &eax->dw003C + 5;
	edi = edi - eax - C;
	esi <<= cl;
	SCZO = cond(esi);
	bh -= 44;
	bl &= cl;
	bh = bh ^ dl;
	v26 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	C = v26;
	v27 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	edi <<= cl;
	SCZO = cond(edi);
	bh.u0 = ~0x19;
	v28 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	v29 = *edx.u7;
	esp -= 4;
	esp->u4 = (Eq_3 (*)[]) v29;
	v30 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	C = v30;
	v31 = (dh & 0x01 << cl) != 0x00;
	dh = __rcr<byte,byte>(dh, cl, C);
	C = v31;
	v32 = (dh & 0x01 << cl) != 0x00;
	dh = __rcr<byte,byte>(dh, cl, C);
	v33 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	C = v33;
	dl >>= cl;
	SCZ = cond(dl);
	&bh.u4->u0 = &(C.u4 + ((byte) bh.u0 + 65) /8 6)->u0;
	dh = ch;
	v35 = (ebx & 0x01 << cl) != 0x00;
	ebx = __ror<word32,byte>(ebx, cl);
	--dl;
	v36 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	v37 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	esp -= 4;
	esp->u4 = (Eq_3 (*)[]) ecx;
	ebx += eax;
	bh >>= cl;
	SCZ = cond(bh);
	&dl.u4->u0 = &(C.u4 + ((byte) dl.u0 + 64) /8 6)->u0;
	SCZO = cond(dl);
	if (Test(LT,SO))
		fn0040DCBB();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(GE,SO))
			fn0040DCBB();
		else
		{
			esp -= 2;
			*esp = (union Eq_3 *) ss;
			Top->r0000 = Top->r0007 / Top->r0000;
			v41 = ecx.u6->bFFFFFFF7 & cl;
			ecx.u6->bFFFFFFF7 = v41;
			SZ = cond(ecx.u6->bFFFFFFF7);
			O = false;
			C.u0 = false;
			fn0040D925();
		}
	}
}

// 0040DE0B: define fn0040DE0B
// Called from:
//      fn0040D515
//      fn0040DDE6
define fn0040DE0B
{
	esp = fp;
	Top = 0;
	&SCZO.u1->t0000.u0 = esp.u1->t0000.u1;
	&esp.u1->t0000.u0 = (word32) esp + 4;
}

// 0040DEE0: define fn0040DEE0
// Called from:
//      fn0040D6FE
define fn0040DEE0
{
	esp = fp;
	Top = 0;
	v6 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	C = v6;
	v8 = (cl & 0x01 << cl) != 0x00;
	cl = __rcr<byte,byte>(cl, cl, C);
	v10 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	ebx += ecx;
	--edx;
	ebx &= ecx;
	dl <<= cl;
	ch -= 0x8E;
	SCZO = cond(ch);
	bh = (byte) &(C.u4 + (bh + 0x7F) /8 6)->u0;
	bh |= 0x77;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040DD0E();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(EQ,Z))
			return;
		fn0040DD0E();
	}
}

