/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall start(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6, int a7, char a8);
// void __usercall sub_4010D0(int a1@<ecx>, int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>);
// void __usercall sub_4013D7(int a1@<eax>, int a2@<ecx>);
int sub_40168E();
int nullsub_1(void); // weak


//----- (00401005) --------------------------------------------------------
void __usercall start(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6, int a7, char a8)
{
  int v8; // ecx

  sub_4010D0(0, a1, a2, a3, a4);
  sub_4010D0(v8, a1, a2, a3, a4);
}
// 4010CC: variable 'v8' is possibly undefined

//----- (004010D0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __usercall sub_4010D0(int a1@<ecx>, int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>)
{
  __int64 v5; // rax
  int v6; // eax
  int v7; // eax
  unsigned int v8; // eax
  _DWORD v9[2]; // [esp-4h] [ebp-2Ch] BYREF
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+8h] [ebp-20h]
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  __int64 v17; // [esp+20h] [ebp-8h]

  LODWORD(v17) = a3;
  WORD1(v5) = HIWORD(v17);
  HIWORD(v16) = 0;
  LOWORD(v5) = 0;
  LOWORD(a1) = *(_WORD *)v5;
  LOWORD(v5) = 0;
  HIDWORD(v5) = v5 + 24624;
  LOWORD(v5) = 0;
  LODWORD(v5) = v5 + 27769;
  v17 = v5;
  v16 = HIDWORD(v5);
  v15 = a5;
  v14 = a2;
  v13 = a4;
  v12 = 0;
  v11 = 0;
  v10 = 16711681;
  v9[1] = a4 - (a1 + 42418) + 2;
  v9[0] = 16711686;
  v6 = sub_40168E();
  (*(void (__cdecl **)(int, _DWORD *, int))(a2 + 24))(v6, v9, v13);
  v10 = (*(int (**)(void))(a2 + 28))() + 6;
  v9[0] = (*(int (__cdecl **)(int))a2)(v10);
  v15 = 0;
  v7 = (*(int (__cdecl **)(int, _DWORD))(a2 - 4 + 16))(v14, v17);
  v8 = __readfsdword(v7 + 47) + v7;
  v15 += *(_DWORD *)(v8 + 3);
  HIDWORD(v17) ^= *(_DWORD *)(v8 + 3);
  sub_4013D7(v10, v14);
}
// 401121: positive sp value 4 has been found
// 4010D0: could not find valid save-restore pair for esi
// 40122D: bad sp value at call

//----- (004013D7) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_4013D7(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // cl
  int v5; // ebp
  int v6; // edi
  unsigned int i; // eax
  int v8; // eax
  unsigned __int16 v9; // cx
  int v10; // edx
  int v11; // edx
  unsigned int v12; // edi
  __int16 v13; // bx
  unsigned int v14; // eax
  int v15; // ebp
  int v16; // eax
  int j; // edi
  int v18; // ebx
  _BYTE *v19; // edx
  int v20; // esi
  _DWORD v21[3]; // [esp-30h] [ebp-144h]
  int v22; // [esp-24h] [ebp-138h]
  int v23; // [esp-20h] [ebp-134h]
  _BYTE v24[28]; // [esp-1Ch] [ebp-130h] BYREF
  unsigned int v26; // [esp+F4h] [ebp-20h]
  int v27; // [esp+F8h] [ebp-1Ch]
  int v28; // [esp+110h] [ebp-4h]
  void *retaddr; // [esp+114h] [ebp+0h]

  v22 = a1;
  v23 = a2;
  for ( i = 0; i < 0x100; ++i )
    v24[i] = i;
  v6 = v21[2];
  if ( (_BYTE)retaddr != 121 )
  {
    v6 = v28;
    do
    {
      (*(void (**)(void))(v6 + 24))();
      (*(void (**)(void))(v6 + 24))();
      (*(void (**)(void))(v6 + 24))();
      (*(void (**)(void))(v6 + 24))();
      (*(void (**)(void))(v6 + 24))();
      (*(void (**)(void))(v6 + 24))();
      (*(void (**)(void))(v6 + 24))();
      v8 = (*(int (**)(void))(v6 + 16))() + 1;
    }
    while ( (unsigned __int16)v8 < v9 );
  }
  v21[0] = v6;
  v12 = v26;
  v14 = 0;
  v2 = 0;
  v15 = 0;
  while ( 1 )
  {
    LOBYTE(v13) = v24[v15];
    v10 = v2 + (unsigned __int8)v13 + *(unsigned __int8 *)(v23 + v14);
    BYTE1(v10) = 0;
    ++v14;
    v2 = v10;
    if ( v14 >= v12 )
      v14 = 0;
    v24[v15++] = v24[v10];
    v19 = &v24[v10 - v14];
    HIBYTE(v13) = v19[v14 + 1];
    *(_WORD *)&v19[v14] = v13;
    if ( BYTE1(v15) == 1 )
    {
      v20 = 0;
      v16 = 0;
      v5 = v27;
      for ( j = v22; v5; --v5 )
      {
        ++v16;
        BYTE1(v16) = 0;
        v4 = v24[v16];
        v18 = v20 + v4;
        BYTE1(v18) = 0;
        v3 = *((_BYTE *)&v21[5] + v18);
        v24[v16] = v3;
        *((_BYTE *)&v21[5] + v18) = v4;
        v11 = v3;
        LOBYTE(v11) = v4 + v3;
        v20 = v18;
        *(_WORD *)(j++ - 1) ^= *(_WORD *)((char *)&v21[5] + v11) << 8;
      }
      __asm { retn }
    }
  }
}
// 401658: positive sp value 30 has been found
// 40167D: variable 'v9' is possibly undefined

//----- (0040168E) --------------------------------------------------------
int sub_40168E()
{
  _WORD *v1; // eax
  void *retaddr; // [esp+0h] [ebp+0h]

  HIWORD(v1) = HIWORD(retaddr);
  while ( 1 )
  {
    LOWORD(v1) = 0;
    LOWORD(v1) = *v1 - 23115;
    if ( (_WORD)v1 == 2 )
      break;
    v1 -= 0x8000;
  }
  return nullsub_1();
}
// 401775: using guessed type int nullsub_1(void);

// nfuncs=5 queued=4 decompiled=4 lumina nreq=0 worse=0 better=0
// ALL OK, 4 function(s) have been successfully decompiled
