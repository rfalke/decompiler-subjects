/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall nullsub_1(_DWORD, _DWORD); // weak
// char __usercall sub_40DD5F@<al>(unsigned int _EAX@<eax>, int@<edx>, int _ECX@<ecx>, int@<ebx>, int@<edi>, unsigned int@<esi>);


//----- (0040C2FF) --------------------------------------------------------
#error "40C2FF: stack frame is too big (funcsize=0)"

//----- (0040DD5F) --------------------------------------------------------
char __usercall sub_40DD5F@<al>(
        unsigned int _EAX@<eax>,
        int a2@<edx>,
        int _ECX@<ecx>,
        int a4@<ebx>,
        int a5@<edi>,
        unsigned int a6@<esi>)
{
  int v6; // eax
  unsigned int v7; // ebx
  int v9; // ebx
  char v10; // cc
  int v13; // esi
  unsigned int v15; // esi
  int v18; // edx
  bool v19; // cc
  int v22; // esi
  bool v23; // tt
  int v27; // ecx
  unsigned int v30; // esi
  unsigned int v32; // ebx
  int v34; // esi
  unsigned int v36; // eax
  unsigned int v38; // eax
  int v39; // ebx
  char v45; // dl
  bool v48; // tt
  bool v49; // cf
  int v50; // eax
  int v51; // esi
  unsigned __int64 v52; // kr00_8
  unsigned int v54; // esi
  unsigned int v55; // eax
  unsigned int v56; // edx
  int v57; // edx
  int v60; // eax
  int v62; // ebx
  unsigned int v63; // edi
  bool v65; // pf
  unsigned int v66; // ebx
  int v67; // eax
  int v68; // ecx
  bool v69; // tt
  int v70; // ebx
  int v72; // esi
  bool v73; // tt
  bool v74; // cf
  int v75; // edx
  char v76; // tt
  int v78; // edi
  unsigned int v80; // eax
  bool v81; // cf
  char v82; // of
  bool v83; // tt
  unsigned int v84; // esi
  int v85; // eax
  bool v87; // tt
  unsigned int v89; // edi
  int v90; // eax
  int v91; // ebx
  int v93; // eax
  int v94; // ebx
  char v95; // cl
  int v96; // edx
  bool v97; // tt
  int v99; // ebx
  int v100; // edx
  int v101; // ebx
  int v107; // ebx
  bool v108; // of
  int v109; // ebx
  int v110; // esi
  int v111; // ebx
  int v113; // ebx
  int v116; // [esp-10h] [ebp-10h]
  int v117; // [esp-Ch] [ebp-Ch]

  v9 = a4 << _ECX;
  LOBYTE(a2) = _ECX + a2;
  LOBYTE(_EAX) = (unsigned __int8)_EAX >> _ECX;
  _EDX = a5 & a2;
  LOBYTE(_EDX) = -12;
  BYTE1(_ECX) = 119;
  BYTE1(_EAX) |= 0x48u;
  BYTE1(v9) = (BYTE1(v9) & 0x98) - ((a6 < _EAX) + BYTE1(_EDX));
  BYTE1(_EAX) = 32;
  __asm { rcr     eax, cl }
  BYTE1(_EDX) = (BYTE1(v9) | (BYTE1(_EDX) + 1)) + 89;
  __asm { rcr     dl, cl }
  _EDX = _EDX - 2;
  __asm { rcl     ah, cl }
  LOBYTE(v9) = 88;
  BYTE1(_EDX) = (BYTE1(_EDX) << _ECX) - 1;
  _ECX = _ECX >> _ECX;
  v10 = ((char)(BYTE1(_ECX) - 32) < 0) ^ __OFADD__(-32, BYTE1(_ECX)) | (BYTE1(_ECX) == 32);
  BYTE1(_ECX) -= 32;
  __asm { rcr     dl, cl }
  if ( v10 || !v10 )
    JUMPOUT(0x40DA88);
  v13 = -741296625 * *(_DWORD *)(v9 - 33368724);
  __outbyte(_EDX, _EAX);
  v32 = BYTE1(_EAX);
  _EDI = _EDX << _ECX;
  v34 = __ROR4__(BYTE1(_EAX) | (v13 - _EAX), _ECX);
  __asm { rcr     edi, cl }
  v36 = HIWORD(_EAX);
  _EDI = __ROR4__((_EDI - 1) >> _ECX, _ECX);
  v51 = _EDI | _ECX | v34;
  __asm { rcr     edi, cl }
  v52 = __PAIR64__(_EDI, v51) - __PAIR64__(_ECX, v36);
  v54 = v51 - v36 - _EDX;
  v55 = _EDX + v36;
  v56 = _EDX >> _ECX;
  v49 = __CFADD__(BYTE1(v32), BYTE1(v56));
  BYTE1(v56) += BYTE1(v32);
  v72 = v55 + v49 + v54;
  LOBYTE(v56) = (v56 & 0x42) + 1;
  v75 = v72 | v56;
  v49 = (unsigned __int8)v75 < BYTE1(v55);
  LOBYTE(v75) = v75 - BYTE1(v55);
  v73 = v49;
  v49 = __CFADD__(v49, (_BYTE)v75);
  LOBYTE(v75) = v73 + v75;
  v49 |= __CFADD__((_BYTE)v32, (_BYTE)v75);
  LOBYTE(v75) = v32 + v75;
  v76 = v49 - 8;
  v74 = BYTE1(v75) < (unsigned __int8)(v49 - 8);
  BYTE1(v75) -= v76;
  if ( !__SETP__(BYTE1(v75), 0) && __SETP__(BYTE1(v75), 0) )
  {
    _EDX = __ROL4__(__ROR4__(v75, _ECX), _ECX);
    __asm { rcr     dh, cl }
    LOBYTE(_EDX) = __CFSHL__(v32, _ECX) + _EDX - 112;
    v78 = ((int)((v55 + HIDWORD(v52)) << _ECX) >> _ECX) - _EDX;
    __asm { rcl     edx, cl }
    v57 = _EDX << _ECX;
    LOBYTE(v57) = _ECX | v57;
    _EDX = v72 | v57;
    BYTE1(_EDX) >>= _ECX;
    __asm { rcl     dh, cl }
    _CL = _ECX + 1;
    LOBYTE(_EDX) = _EDX ^ 0xAD;
    __asm { rcr     dl, cl }
    v60 = v78 + v55 - (v74 + 1457127201);
    v95 = v60 + _CL;
    BYTE1(_EDX) <<= v95;
    BYTE1(v60) &= 0x67u;
    LOBYTE(v60) = (_BYTE)v60 << (v95 << v95);
    v113 = v60;
    LOBYTE(_EDX) = v60;
    _ECX = v60;
    __asm { rcl     dl, cl }
    LOBYTE(_ECX) = v60 - 80;
    BYTE1(v60) = __ROR1__(BYTE1(v60) << v60, v60 - 80);
    LOBYTE(v60) = v60 - 106;
    LOBYTE(v113) = (char)v113 >> _ECX;
    _EBX = (v113 - 1) >> _ECX;
    __asm { rcr     ebx, cl }
    v27 = _ECX << _ECX;
    LOBYTE(_EDX) = _EBX | _EDX;
    v67 = _EDX & v60;
    v69 = __CFSHL__(v27, v27);
    v68 = __ROL4__(v27, v27);
    v70 = v67 + v69 + _EBX;
    --v67;
    _ECX = v68 << v68;
    v49 = __CFSHL__(BYTE1(_ECX), _ECX);
    BYTE1(_ECX) = *(_BYTE *)(v72 - 2781);
    LOBYTE(_EDX) = _EDX - (v49 + 17);
    BYTE1(v67) = BYTE1(_EDX);
    LOBYTE(v67) = v67 + 26;
    v97 = __CFSHR__(_EDX, _ECX);
    v96 = __ROR4__(_EDX, _ECX);
    _EBX = v70 - 1 - (v97 + v96);
    LOBYTE(v96) = BYTE1(_ECX) ^ v96;
    __asm { rcr     bh, cl }
    v99 = __ROL4__(_EBX, _ECX);
    v49 = __CFSHL__(v96, _ECX);
    v100 = v96 << _ECX;
    LOBYTE(v99) = v49 + v99 - 79;
    LOBYTE(v100) = v100 + 104;
    v101 = v100 + __CFADD__(BYTE1(_ECX), 62) + v99;
    BYTE1(v100) |= 0x51u;
    _EAX = (v67 >> _ECX) + 1;
    __asm { rcl     eax, cl }
    _EAX = v101 + _EAX;
    --v100;
    LOBYTE(v100) = BYTE1(v101) ^ v100;
    BYTE1(v100) += 68;
    _EDX = __ROL4__(v100, _ECX);
    BYTE1(_EAX) = (SBYTE1(_EAX) >> _ECX) + 98;
    BYTE1(_EDX) >>= _ECX;
    LOBYTE(_EDX) = _EDX ^ 0xC1 | 0xD5;
    LOBYTE(_EAX) = (unsigned __int8)(_EAX - 1) >> _ECX;
    __asm
    {
      rcr     edx, cl
      rcl     eax, cl
      rcl     dl, cl
    }
    JUMPOUT(0x40DC14);
  }
  v38 = v32 + v55;
  LOBYTE(v75) = __ROR1__(v75, _ECX);
  v39 = v32 >> _ECX;
  v49 = __CFSHR__(v39, _ECX);
  _EBX = v39 >> _ECX;
  _EDI = v72;
  _EDX = v75 - (v49 + v38);
  v80 = v38 ^ 0xFFFFFEC8;
  LOBYTE(_EDX) = (char)(BYTE1(_ECX) | _EDX) >> _ECX;
  LOBYTE(_EBX) = (unsigned __int8)((((_BYTE)_EBX + 107) & 0xDF) << _ECX) >> _ECX;
  v83 = __CFSHL__(BYTE1(_EDX), _ECX);
  BYTE1(_EDX) = __ROL1__(BYTE1(_EDX), _ECX);
  v81 = v83;
  if ( v82 || !v82 )
  {
    BYTE1(_EBX) -= _EDX;
    _EDX = _EBX;
    BYTE1(_EDX) = BYTE1(_EBX) - (__CFADD__((_BYTE)_EBX, (_BYTE)_EBX) + BYTE1(_ECX));
    BYTE1(_EBX) = BYTE1(_ECX);
    v89 = __ROL4__(v72, _ECX) - 1;
    LOBYTE(_EDX) = (unsigned __int8)_EDX >> _ECX;
    LOBYTE(_EBX) = -1;
    v90 = ~v80;
    v91 = _EDX ^ v89 & _EBX;
    __asm { rcr     dl, cl }
    LOBYTE(v91) = v91 - BYTE1(v91);
    LOBYTE(_EDX) = BYTE1(v90);
    v62 = v91 << _ECX;
    v63 = v89 >> _ECX;
    _ESI = (v72 >> _ECX) - 1;
    v65 = __SETP__(v90 + v62, 0);
    v66 = v90 + v62;
    if ( __SETP__(v66, 0) || !v65 )
      JUMPOUT(0x40D8B6);
    *(_BYTE *)v66 |= 0xC0u;
    LOBYTE(v90) = (v90 ^ 0x3F | 0x5A) + 1;
    v6 = v90 << _ECX;
    v7 = (__PAIR64__(v66 >> _ECX, v63) - __PAIR64__(_EDX, __CFSHR__(v66, _ECX) + (v66 >> _ECX))) >> 32;
    BYTE1(v7) |= v7;
    LOBYTE(_EDX) = 53;
    LOBYTE(v7) = v6 & v7;
    v45 = __ROL4__(_EDX, _ECX);
    _CL = _ECX - 1;
    _EBX = v7 >> _CL;
    v49 = __CFADD__(_ESI, _EBX);
    LOBYTE(_EBX) = _ESI + _EBX;
    v48 = v49;
    v49 = __CFADD__(v49, (_BYTE)_EBX);
    LOBYTE(_EBX) = v48 + _EBX;
    v49 |= __CFADD__(v45, (_BYTE)_EBX);
    LOBYTE(_EBX) = v45 + _EBX;
    LOBYTE(v6) = v49 + v6 - 1 + 17;
    __asm { rcr     bl, cl }
    v49 = __CFSHR__(v6, _CL);
    v50 = v6 >> _CL;
    if ( v49 || v50 == 0 || !v49 && v50 != 0 )
    {
      __asm { rcl     esi, cl }
      JUMPOUT(0x40D508);
    }
  }
  else
  {
    v84 = v80;
    v85 = *(_DWORD *)v80;
    *(_BYTE *)(v84 - 84) += v81 + 2;
    _ECX = _ECX - 1;
    __asm { rcl     dl, cl }
    v117 = _ECX;
    _EDX = _EDX >> _ECX;
    v87 = __CFSHR__(BYTE1(_EBX), _ECX);
    BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ECX);
    __asm { rcl     ebx, cl }
    BYTE1(_EDX) ^= 0xBu;
    LOBYTE(_EDX) = _EDX - (v87 + _ECX) - BYTE1(_ECX) - BYTE1(v85);
    __asm
    {
      rcl     dh, cl
      rcr     edi, cl
    }
    LOBYTE(_EBX) = ((_BYTE)_EBX << _ECX) - (__CFSHL__(_EBX, _ECX) + _EDX);
    BYTE1(_EBX) = BYTE1(_EBX) + 1 - (__CFSHL__(_EBX, _ECX) - 118);
    BYTE1(_EDX) = (BYTE1(_EDX) ^ 0x41) + 1;
    LOBYTE(_EBX) = __ROL1__(_EBX, _ECX) - 29;
    v110 = _EDX & (_EDI + (_ECX << _ECX));
    v111 = _EDI + _EBX;
    LOBYTE(v111) = v111 - BYTE1(_ECX);
    BYTE1(v111) = _EDX & (BYTE1(v111) + 53);
    BYTE1(_EDX) = __ROL1__(BYTE1(_EDX) + 1, _ECX);
    __asm { rcl     edx, cl }
    v93 = *(_DWORD *)(v85 + 128);
    BYTE1(_EDX) = ((BYTE1(_EDX) - 63) << _ECX) + 25;
    v49 = __CFADD__(BYTE1(_ECX), (_BYTE)v111);
    LOBYTE(v111) = BYTE1(_ECX) + v111;
    v94 = v111 - (v49 + _ECX);
    LOBYTE(_EDX) = ((unsigned __int8)_EDX >> _ECX) - (__CFSHR__(_EDX, _ECX) + BYTE1(_ECX));
    v30 = v93 | ((unsigned int)(v110 >> _ECX) >> _ECX);
    _EAX = _ECX + v93;
    _EDI = _ECX & (_EDI << _ECX);
    BYTE1(v94) = (v94 ^ (BYTE1(v94) << _ECX)) - (__CFSHL__(_EDI + (_EDX << _ECX), _ECX) + BYTE1(_ECX)) + 1;
    v116 = *(_DWORD *)(_EAX + 16);
    _EBX = v30 ^ v94;
    LOBYTE(_EBX) = __ROL1__(_EBX, _ECX);
    __asm { rcl     edi, cl }
    v15 = v30 >> _ECX;
    while ( 1 )
    {
      v23 = __CFSHR__(v15, _ECX);
      v22 = __ROR4__(v15, _ECX);
      BYTE1(_EBX) -= v23 + v116;
      LOBYTE(_EBX) = BYTE1(_EBX) | _EBX;
      BYTE1(_EBX) <<= _ECX;
      __asm { rcr     bh, cl }
      _EDI = _EDI - _EAX + 1;
      LOBYTE(_EBX) = _EBX | 0x23;
      LOBYTE(_EBX) = BYTE1(_ECX) ^ _EBX;
      _EDX = _ECX + v116;
      BYTE1(_EBX) = _EAX;
      v107 = _EBX << _ECX;
      BYTE1(v107) = _ECX ^ 0x62;
      v109 = v107 + 2;
      v49 = __CFSHL__(BYTE1(v109), _ECX);
      BYTE1(v109) <<= _ECX;
      v108 = __OFSUB__((_BYTE)v109, v49 + _ECX + v116);
      LOBYTE(v109) = v109 - (v49 + _ECX + v116);
      v50 = *(_DWORD *)(_ECX + v116);
      if ( !v108 && v108 )
        break;
      BYTE1(v109) += 103;
      _EBX = v109 + 1;
      __asm { rcr     edx, cl }
      BYTE1(_EBX) ^= BYTE1(_ECX);
      v15 = __ROR4__(v22, _ECX);
      __asm { rcl     bh, cl }
      _EAX = ((int (__cdecl *)(int))v50)(v117);
      v19 = BYTE1(_ECX) <= (unsigned __int8)(__CFSHL__(v18, _ECX) + _EBX);
      BYTE1(_ECX) -= __CFSHL__(v18, _ECX) + _EBX;
      __asm { rcl     ch, cl }
      if ( v19 || !v19 )
        JUMPOUT(0x40DA60);
      __asm { aam     52h ; 'R' }
    }
    __asm { fiadd   word ptr [edi-19h] }
    LOBYTE(v50) = v50 + 46;
  }
  return v50;
}
// 40D4AC: control flows out of bounds to 40D4AF
// 40D6C2: control flows out of bounds to 40D6C8
// 40D715: inconsistent fpu stack
// 40D814: control flows out of bounds to 40D817
// 40D8E3: control flows out of bounds to 40D8E4
// 40DD5A: control flows out of bounds to 40DD5B
// 40D473: control flows out of bounds to 40D5D1
// 40D699: control flows out of bounds to 40DC14
// 40D49A: control flows out of bounds to 40DCBA
// 40D4F4: control flows out of bounds to 40DA88
// 40D546: control flows out of bounds to 40DA60
// 40D5EA: control flows out of bounds to 40DAC7
// 40D5FA: control flows out of bounds to 40D5BB
// 40D8AB: control flows out of bounds to 40D8B6
// 40D8D0: control flows out of bounds to 40DD8E
// 40DA71: control flows out of bounds to 40D6C7
// 40DBC2: control flows out of bounds to 40DBAA
// 40DD4A: control flows out of bounds to 40D508
// 40D4A4: conditional instruction was optimized away because edi.4!=0
// 40D577: conditional instruction was optimized away because bl.1>=23
// 40D59A: conditional instruction was optimized away because esi.4!=0
// 40D5C4: conditional instruction was optimized away because dl.1!=0
// 40D80E: conditional instruction was optimized away because bh.1!=0
// 40D905: conditional instruction was optimized away because al.1>=0
// 40DA55: conditional instruction was optimized away because ebx.4>=0
// 40DBBE: conditional instruction was optimized away because ebx.4!=0
// 40D538: variable '_ECX' is possibly undefined
// 40D53E: variable 'v117' is possibly undefined
// 40D540: variable 'v18' is possibly undefined
// 40D9A2: variable 'v82' is possibly undefined
// 40D762: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

// nfuncs=3 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 2 function(s)"
