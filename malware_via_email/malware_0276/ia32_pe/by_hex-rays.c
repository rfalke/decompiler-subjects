/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall start(int a1@<eax>, char *a2@<edx>, int a3@<ecx>, unsigned int a4@<ebp>);

//-------------------------------------------------------------------------
// Data declarations

int dword_10009000 = -295331; // weak


//----- (1000DD10) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall start(int a1@<eax>, char *a2@<edx>, int a3@<ecx>, unsigned int a4@<ebp>)
{
  int *v4; // esi
  int *v5; // edi
  char v6; // al
  bool v7; // cf
  int v8; // ebx
  int v9; // ebx
  int v10; // ett
  unsigned int v11; // eax
  bool v12; // cf
  int v13; // ebx
  int v14; // ebx
  int v15; // ett
  bool v16; // zf
  int v17; // ebx
  int v18; // ett
  unsigned int v19; // eax
  unsigned int v20; // eax
  int v21; // eax
  bool v22; // cf
  int v23; // ebx
  int v24; // ebx
  int v25; // ett
  BOOL v26; // ecx
  bool v27; // cf
  int v28; // ebx
  int v29; // ett
  int v30; // ecx
  int v31; // ecx
  bool v32; // cf
  int v33; // ebx
  int v34; // ebx
  int v35; // ett
  bool v36; // zf
  int v37; // ebx
  int v38; // ett
  unsigned int v39; // ecx
  char v40; // al
  int v41; // eax
  bool v42; // cc
  int v43; // esi
  int *v44; // edi
  int v45; // ecx
  char v46; // al
  int *v47; // eax
  int v48; // eax
  int v49; // eax
  char v50; // t1
  char v51; // bl
  void (__cdecl *v52)(int, int, int, int *); // ebp
  int v53; // edi
  int v54[4]; // [esp+10h] [ebp-90h] BYREF
  int *v55; // [esp+20h] [ebp-80h] BYREF
  _DWORD v56[8]; // [esp+24h] [ebp-7Ch] BYREF
  int v57; // [esp+44h] [ebp-5Ch] BYREF

  v56[4] = &v57;
  v56[2] = a3;
  v56[1] = a2;
  v56[0] = a1;
  v4 = &dword_10009000;
  v5 = &dword_10009000 - 0x2000;
  v55 = &dword_10009000 - 0x2000;
  while ( 1 )
  {
    v9 = *v4;
    v7 = (unsigned int)v4++ < 0xFFFFFFFC;
    v10 = v7 + v9;
    v7 = __CFADD__(v7, v9) | __CFADD__(v9, v10);
    v8 = v9 + v10;
    do
    {
      if ( v7 )
      {
        v6 = *(_BYTE *)v4;
        v4 = (int *)((char *)v4 + 1);
        *(_BYTE *)v5 = v6;
        v5 = (int *)((char *)v5 + 1);
      }
      else
      {
        v11 = 1;
        while ( 1 )
        {
          v12 = __CFADD__(v8, v8);
          v13 = 2 * v8;
          if ( !v13 )
          {
            v14 = *v4;
            v7 = (unsigned int)v4++ < 0xFFFFFFFC;
            v15 = v7 + v14;
            v12 = __CFADD__(v7, v14) | __CFADD__(v14, v15);
            v13 = v14 + v15;
          }
          v11 += v12 + v11;
          v7 = __CFADD__(v13, v13);
          v16 = 2 * v13 == 0;
          v8 = 2 * v13;
          if ( v7 )
          {
            if ( !v16 )
              break;
            v17 = *v4;
            v7 = (unsigned int)v4++ < 0xFFFFFFFC;
            v18 = v7 + v17;
            v7 = __CFADD__(v7, v17) | __CFADD__(v17, v18);
            v8 = v17 + v18;
            if ( v7 )
              break;
          }
        }
        v7 = v11 < 3;
        v19 = v11 - 3;
        if ( !v7 )
        {
          v20 = v19 << 8;
          LOBYTE(v20) = *(_BYTE *)v4;
          v4 = (int *)((char *)v4 + 1);
          v21 = ~v20;
          if ( !v21 )
          {
            v43 = (int)v55;
            v44 = v55;
            v45 = 7;
            while ( 1 )
            {
              v46 = *(_BYTE *)v44;
              v44 = (int *)((char *)v44 + 1);
              LOBYTE(v47) = v46 + 24;
              while ( (unsigned __int8)v47 <= 1u )
              {
                v48 = *v44;
                LOBYTE(v48) = BYTE1(*v44);
                BYTE1(v48) = *v44;
                v49 = __ROL4__(v48, 16);
                v50 = v49;
                LOBYTE(v49) = BYTE1(v49);
                BYTE1(v49) = v50;
                v51 = *((_BYTE *)v44 + 4) + 24;
                v47 = (int *)(v43 + v49 - (_DWORD)v44);
                *v44 = (int)v47;
                v44 = (int *)((char *)v44 + 5);
                LOBYTE(v47) = v51;
                if ( !--v45 )
                {
                  v52 = *(void (__cdecl **)(int, int, int, int *))(v43 + 53296);
                  v53 = v43 - 4096;
                  v55 = v47;
                  ((void (__fastcall *)(_DWORD, char *, int, int, int, int **))v52)(0, a2, v43 - 4096, 4096, 4, &v55);
                  *(_BYTE *)(v53 + 495) &= 0x7Fu;
                  *(_BYTE *)(v53 + 535) &= 0x7Fu;
                  v52(v43 - 4096, 4096, v54[0], v54);
                  do
                    v55 = 0;
                  while ( &v55 != &v56[-32] );
                  JUMPOUT(0x10001000);
                }
              }
            }
          }
          a4 = v21;
        }
        v22 = __CFADD__(v8, v8);
        v23 = 2 * v8;
        if ( !v23 )
        {
          v24 = *v4;
          v7 = (unsigned int)v4++ < 0xFFFFFFFC;
          v25 = v7 + v24;
          v22 = __CFADD__(v7, v24) | __CFADD__(v24, v25);
          v23 = v24 + v25;
        }
        v26 = v22;
        v27 = __CFADD__(v23, v23);
        v8 = 2 * v23;
        if ( !v8 )
        {
          v28 = *v4;
          v7 = (unsigned int)v4++ < 0xFFFFFFFC;
          v29 = v7 + v28;
          v27 = __CFADD__(v7, v28) | __CFADD__(v28, v29);
          v8 = v28 + v29;
        }
        v30 = v26 + v27 + v26;
        if ( !v30 )
        {
          v31 = 1;
          while ( 1 )
          {
            v32 = __CFADD__(v8, v8);
            v33 = 2 * v8;
            if ( !v33 )
            {
              v34 = *v4;
              v7 = (unsigned int)v4++ < 0xFFFFFFFC;
              v35 = v7 + v34;
              v32 = __CFADD__(v7, v34) | __CFADD__(v34, v35);
              v33 = v34 + v35;
            }
            v31 += v32 + v31;
            v7 = __CFADD__(v33, v33);
            v36 = 2 * v33 == 0;
            v8 = 2 * v33;
            if ( v7 )
            {
              if ( !v36 )
                break;
              v37 = *v4;
              v7 = (unsigned int)v4++ < 0xFFFFFFFC;
              v38 = v7 + v37;
              v7 = __CFADD__(v7, v37) | __CFADD__(v37, v38);
              v8 = v37 + v38;
              if ( v7 )
                break;
            }
          }
          v30 = v31 + 2;
        }
        v39 = (a4 < 0xFFFFF300) + v30 + 1;
        a2 = (char *)v5 + a4;
        if ( a4 <= 0xFFFFFFFC )
        {
          do
          {
            v41 = *(_DWORD *)a2;
            a2 += 4;
            *v5++ = v41;
            v42 = v39 <= 4;
            v39 -= 4;
          }
          while ( !v42 );
          v5 = (int *)((char *)v5 + v39);
        }
        else
        {
          do
          {
            v40 = *a2++;
            *(_BYTE *)v5 = v40;
            v5 = (int *)((char *)v5 + 1);
            --v39;
          }
          while ( v39 );
        }
      }
      v7 = __CFADD__(v8, v8);
      v8 *= 2;
    }
    while ( v8 );
  }
}
// 1000DE44: positive sp value 5C has been found
// 1000DE44: control flows out of bounds to 10001000
// 10009000: using guessed type int dword_10009000;

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
