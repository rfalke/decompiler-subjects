/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// double __usercall start@<st0>(int@<eax>, int@<edx>, int _ECX@<ecx>, int@<ebx>, int@<edi>, int@<esi>, double result@<st0>);


//----- (00408525) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
double __usercall start@<st0>(
        int a1@<eax>,
        int a2@<edx>,
        int _ECX@<ecx>,
        int a4@<ebx>,
        int a5@<edi>,
        int a6@<esi>,
        double result@<st0>)
{
  int v8; // eax
  char v10; // bh
  BOOL v16; // ett
  int v19; // ebx
  int v24; // edi
  bool v26; // cf
  bool v27; // pf
  bool v30; // cc
  int v31; // ebx
  unsigned int v34; // esi
  unsigned int v35; // ett
  bool v36; // cf
  unsigned int v37; // ebx
  char v43; // tt
  bool v57; // cf
  int v58; // eax
  int v64; // esi
  bool v66; // cc
  int v67; // esi
  int v68; // ebx
  bool v69; // sf
  _DWORD *v70; // edi
  int v73; // eax
  _BOOL2 v74; // tt
  int v75; // edi
  int v78; // edi
  int v79; // esi
  int v80; // ebx
  int v81; // eax
  int v83; // eax
  int v84; // ecx
  int v85; // ebx
  int v86; // eax
  char v88; // of
  unsigned int v89; // ebx
  int v91; // esi
  int v92; // edi
  bool v93; // cf
  bool v94; // of
  unsigned int v95; // ecx
  unsigned int v96; // ett
  __int16 v97; // bx
  char v99; // cc
  __int16 v100; // bx
  bool v101; // tt
  bool v105; // tt
  int v107; // [esp-24h] [ebp-24h]
  unsigned int v108; // [esp-20h] [ebp-20h]
  int v109; // [esp-1Ch] [ebp-1Ch]
  int v110; // [esp-18h] [ebp-18h]
  int v111; // [esp-8h] [ebp-8h]
  _DWORD *v112; // [esp-4h] [ebp-4h]

  _ESI = a2 ^ (a6 >> 28);
  _EBX = __ROR4__(a4, _ECX);
  v105 = __CFSHR__(a2, _ECX);
  _DX = __ROR4__(a2, _ECX);
  __asm { rcr     esi, 14h }
  BYTE1(a1) = _DX + v105 + BYTE1(a1) - 1;
  v36 = __CFSHL__(BYTE1(a1), _ECX);
  BYTE1(a1) <<= _ECX;
  HIWORD(_EAX) = ((unsigned int)(a1 + 1) >> 1 >> 16) | (v36 << 15);
  LOWORD(_EAX) = a5;
  __asm { rcr     dx, cl }
  BYTE1(_ECX) |= _ECX;
  LOWORD(_ESI) = -(__int16)_ESI;
  _ECX = _ESI ^ _ECX;
  __asm { rcr     ch, cl }
  LOBYTE(_ECX) = ~(_BYTE)_ECX;
  __asm { rcr     bl, cl }
  BYTE1(_EBX) = 48;
  __asm { rcr     eax, cl }
  LOWORD(_EAX) = (__int16)_EAX >> _ECX;
  if ( __SETP__(_EAX, 0) || !__SETP__(_EAX, 0) )
  {
    LOBYTE(_EBX) = 0;
    _ECX = __CFSHR__(_ECX, 2) + __ROR4__(_ECX, 2) - 1913705897;
    __asm { rcl     ebx, 1 }
    BYTE1(_ECX) |= 0xF7u;
    LOBYTE(_EBX) = _EBX ^ 0x8C;
    v36 = __CFSHR__(_EAX, 27);
    v73 = _EAX >> 27;
    v74 = v36;
    v36 = __CFADD__(v36, (_WORD)v73);
    LOWORD(v73) = v74 + v73;
    v36 |= __CFADD__((_WORD)_EBX, (_WORD)v73);
    LOWORD(v73) = _EBX + v73;
    LOBYTE(_ECX) = v36 + _ECX - 29;
    LOWORD(_ESI) = ~(_WORD)_ESI;
    v75 = v73 & a5;
    LOBYTE(_EBX) = __ROR1__(_EBX, 28);
    __asm { rcl     ch, cl }
    _EBX = _EBX << _ECX << _ECX;
    __asm { rcr     bh, 1Bh }
    v83 = v73 - 1487612539 + 1;
    LOBYTE(v74) = __CFSHL__(v83, 20);
    LOBYTE(v83) = __ROL1__(v83, 20);
    v84 = -1449371086;
    BYTE1(v83) += HIBYTE(_DX) + v74;
    v86 = -v83;
    BYTE1(_EBX) = 0;
    v85 = __ROL4__(_EBX, 17);
    LOBYTE(v86) = BYTE1(v85) + v86;
    v78 = v75 | 0x5C58A755;
    LOBYTE(v86) = -(char)v86;
    v79 = _ESI << 27;
    LOWORD(v85) = 0;
    BYTE1(v86) = __ROL1__(0, 50);
    LOWORD(v86) = v79 & v86;
    v80 = v85 + 484145194;
    v81 = __ROR4__(v86, 16);
    if ( !__SETP__(v80, 0) && __SETP__(v80, 0) )
      JUMPOUT(0x408416);
    LOBYTE(v84) = 91;
    LOWORD(v81) = v84;
    LOWORD(v80) = 0;
    v8 = v80 ^ v81;
    BYTE1(v80) = BYTE1(v79);
    LOBYTE(v84) = -17;
    _EAX = v80 ^ v8 | 0xA871830;
    _ESI = v79 | 0xEAA8CD36;
    LOWORD(v78) = ((_WORD)v78 + 1) << 15;
    --BYTE1(v80);
    v37 = v78 ^ v80;
    __asm { rcl     esi, 19h }
    LOWORD(_EAX) = 0;
    _ESI >>= 5;
    __asm { rcl     eax, 1Dh }
    _ECX = v84 << 15;
    --BYTE1(_ECX);
    BYTE1(v37) = __ROL1__(__ROR1__(BYTE1(v37), 23), _ECX);
    LOBYTE(v37) = 0;
    v36 = (unsigned __int16)_ESI < (unsigned __int16)(__CFSHL__(-1, 15) + (_WORD)v37);
    LOWORD(_ESI) = _ESI - (__CFSHL__(-1, 15) + (_WORD)v37);
    v35 = v36 - 1842217310;
    v36 = _ESI < v35;
    v34 = _ESI - v35;
    LOBYTE(v35) = v36 + BYTE1(_EAX);
    v36 = BYTE1(v37) < (unsigned __int8)(v36 + BYTE1(_EAX));
    BYTE1(v37) -= v35;
    LOBYTE(v37) = -(char)_EAX;
    BYTE1(_ECX) = __ROR1__(BYTE1(_ECX), 5);
    BYTE1(v37) = (v36 + BYTE1(v37) + 0x80) | 0xFA;
    _ESI = __ROL4__(v34 + 622324097, _ECX);
    v89 = v37 >> 9;
    __asm { rcr     esi, 0Ah }
    if ( !v88 && v88 )
      JUMPOUT(0x408477);
    BYTE1(_ECX) |= 0xE5u;
    LOBYTE(_ECX) = (char)_ECX >> _ECX;
    v67 = _ECX;
    __asm { rcl     ch, cl }
    BYTE1(v89) |= HIBYTE(_DX);
    __asm { rcr     ch, 1Ah }
    v31 = _EAX + v89;
    LOWORD(v31) = (unsigned __int8)((char)v31 >> 7);
    LOBYTE(_ECX) = ((unsigned __int8)((((unsigned __int8)_DX & (unsigned __int8)_ECX) << 7) - 1) < 0x22u)
                 + (((unsigned __int8)_DX & (unsigned __int8)_ECX) << 7)
                 - 35;
    v68 = v31 + 2113294702;
    LOWORD(v67) = (_WORD)v67 << _ECX;
    LOBYTE(v68) = _ECX & v68;
    _EBX = __ROL4__(v68, 24);
    BYTE1(_ECX) = __ROL1__(BYTE1(_ECX), 17) | 0xB1;
    _ECX = __ROR4__(_ECX, 11);
    LOBYTE(_EBX) = 0;
    v30 = v67 < -677766819;
    _ESI = v67 + 677766819;
    v107 = 84107686;
    if ( !v30 && v30 )
      JUMPOUT(0x4080CE);
  }
  else
  {
    result = result / *(double *)_EAX;
    v107 = _EBX;
  }
  _EAX = (v107 ^ 0x45CD6E) - 88517832;
  BYTE1(_EBX) = __ROL1__(BYTE1(_ECX), 3);
  v91 = _ESI >> 13;
  LOWORD(_EBX) = __ROL2__(_EBX, _ECX);
  v92 = _EBX;
  v36 = __CFSHR__(BYTE1(_ECX), 18);
  BYTE1(_ECX) = 0;
  v96 = v36 - 1642886;
  v93 = _ECX < v96;
  v94 = __OFSUB__(_ECX, v96);
  v95 = _ECX - v96;
  if ( !v94 && v94 )
  {
    _EAX = v108;
    _EDX = v109;
    _ECX = v110;
    _EDI = v111;
    _ESI = v112;
    if ( !v93 )
      JUMPOUT(0x40851C);
    v19 = *(_DWORD *)(v111 + 74);
LABEL_50:
    LOBYTE(v19) = __ROR1__(v19, 24);
    v97 = _ECX ^ v19;
    LOBYTE(v97) = (unsigned __int8)v97 >> _ECX;
    __asm { rcr     ecx, 0Dh }
    LOWORD(_ESI) = v97 | ((_WORD)_ESI - 1);
    v99 = ((__int16)(v97 + 1) < 0) ^ __OFADD__(1, v97);
    v100 = v97 + 1;
    if ( v99 || !v99 )
    {
      _CL = BYTE1(_ECX) + 89 + __ROL1__(_ECX, _ECX);
      _SI = (_WORD)_ESI - 8230;
      __asm { rcr     si, cl }
      JUMPOUT(0x40854D);
    }
    _EDX += *(_DWORD *)((char *)_ESI + 316194855);
    v24 = __ROR4__(_EDI, _ECX) << _ECX;
    v101 = __CFSHR__(_ECX, 28);
    _ECX = __ROR4__(_ECX, 28);
    BYTE1(_ECX) -= (__CFADD__(v101, HIBYTE(v100)) | __CFADD__((_BYTE)v100, v101 + HIBYTE(v100))) + _EAX;
    _EBX = -818322997;
    BYTE1(_EBX) = __ROR1__(97, 28) - 1;
    LOBYTE(_EAX) = (_BYTE)_EAX << _ECX;
    v26 = __CFADD__((_BYTE)_EAX, BYTE1(_EDX));
    BYTE1(_EDX) += _EAX;
    goto LABEL_53;
  }
  _EDX = 0;
  v36 = (unsigned __int8)_EBX < BYTE1(_EBX);
  LOBYTE(_EBX) = _EBX - BYTE1(_EBX);
  LOBYTE(v95) = v95 - (v36 + 32);
  v64 = ~v91;
  _ECX = v95 >> 5;
  BYTE1(_EBX) = ~BYTE1(_EBX);
  __asm { rcr     ecx, 6 }
  v66 = _ECX <= _EBX;
  _ECX = _ECX - _EBX;
  if ( !v66 && v66 )
    JUMPOUT(0x40831F);
  __asm
  {
    rcl     ebx, cl
    int     2Eh; DOS 2+ internal - EXECUTE COMMAND
  }
  _ESI = ~v64;
  _EBX = _EBX ^ 0xF3683980;
  LOWORD(_ECX) = (unsigned __int8)~(_BYTE)_ECX;
  BYTE1(_EBX) -= 26;
  v57 = __CFSHL__(v92, _ECX);
  v24 = v92 << _ECX;
  if ( !v57 && v24 != 0 && (v57 || v24 == 0) )
  {
    v58 = _ESI;
    MEMORY[0] = ~MEMORY[0];
    LOBYTE(_EBX) = __ROL1__(_EBX, _ECX);
    __asm { rcr     bh, 15h }
    _BH -= 42;
    LOBYTE(_CX) = (_BYTE)_ECX << _ECX;
    _ESI = -148567870;
    __asm { rcl     bh, cl }
    _EDI = v24 | 0x523F73C5;
    __asm
    {
      rcl     ch, 0Ah
      rcr     bl, cl
    }
    v43 = v58 & 1;
    _EAX = __ROR4__(v58, 1);
    if ( !v43 )
    {
      __asm
      {
        rcr     cl, cl
        rcl     edi, cl
      }
      JUMPOUT(0x4081B8);
    }
    HIWORD(_EBX) = HIWORD(_EBX) ^ 0x7060;
    LOWORD(_ECX) = _EDI ^ _CX;
    BYTE1(_EBX) = BYTE1(_EDI);
    LOBYTE(_EBX) = (char)_EDI >> _ECX;
    if ( !__CFSHR__(_EDI, _ECX) && (char)_EDI >> _ECX != 0 && (__CFSHR__(_EDI, _ECX) || (char)_EDI >> _ECX == 0) )
    {
      *(_DWORD *)_EDI = _EAX;
      __asm { outsd }
      __outbyte(0, _EAX);
      __asm { xlat }
      JUMPOUT(0x4083E1);
    }
    _EBX = _EBX << 9;
    _ECX = __ROR4__(_ECX, 14);
    _ESI = _EAX - 148567870;
    LOBYTE(_ECX) = _EBX + _ECX;
    __asm
    {
      rcr     esi, cl
      rcr     bl, cl
    }
    LOBYTE(_ECX) = (_BYTE)_ECX << _ECX;
    LOBYTE(_EBX) = _EBX ^ 0xD;
    LOWORD(_EBX) = __ROL2__(_EBX, _ECX);
    _EBX |= 0x9ACA730A;
    BYTE1(_EBX) &= 0x15u;
    BYTE1(_ECX) = __ROL1__(BYTE1(_ECX), 9);
    LOWORD(_ECX) = _ECX + 1;
    v36 = __CFADD__(_EBX, -1990987975);
    _EBX -= 1990987975;
    _EAX = __GS__;
    v16 = v36;
    v36 = __CFADD__(v36, _EBX);
    v19 = v16 + _EBX;
    v36 |= __CFADD__(v19, 1670550054);
    LOWORD(v19) = v19 - 28122;
    BYTE1(v19) += BYTE1(_ECX) + v36;
    _ESI = (_DWORD *)(_ESI ^ 0x38E12552);
    LOBYTE(_ECX) = _ECX + 116;
    LOBYTE(v19) = __ROL1__(v19, _ECX);
    BYTE1(_ECX) = 59;
    LOBYTE(_ECX) = _ECX - 109;
    LOBYTE(v19) = (_BYTE)v19 << _ECX;
    goto LABEL_50;
  }
  SBYTE1(_EBX) >>= 7;
  LOBYTE(_EBX) = (unsigned __int8)_EBX >> 4;
  LOBYTE(_ECX) = 0;
  __asm
  {
    rcl     ecx, 13h
    rcr     esi, cl
  }
  LOWORD(v24) = (unsigned __int16)v24 >> _ECX;
  LOBYTE(_EAX) = MEMORY[0xFFFFFFFF];
  v26 = _EAX < 0xC000002E;
  v27 = __SETP__(_EAX + 1073741778, 0);
  if ( _EAX == -1073741778 )
  {
LABEL_53:
    __asm { rcr     ax, cl }
    BYTE1(_EAX) += _EBX + v26;
    v36 = __CFADD__((_WORD)_ECX, (_WORD)v24);
    LOWORD(v24) = _ECX + v24;
    ++BYTE1(_EBX);
    v70 = (_DWORD *)(v36 + v24 - 1924864150);
    v69 = (int)v70 < 0;
    LOWORD(v70) = _ECX;
    __asm { rcl     eax, 14h }
    LOWORD(_EBX) = __ROR2__(_EBX, _ECX);
    if ( !v69 && v69 )
    {
      __asm { insb }
      __readeflags();
      *v70 = *_ESI;
      JUMPOUT(0x408374);
    }
    _EAX = _EAX >> 17;
    v10 = _ECX + __CFADD__(_EDX, v70) + ((unsigned __int16)((int)(_ECX ^ _EBX) >> _ECX) >> 8);
    __asm { rcl     ah, cl }
    BYTE1(_EDX) = 0;
    if ( __SETP__(_ECX, 0) || !__SETP__(_ECX, 0) )
    {
      __asm
      {
        rcl     eax, 15h
        rcr     esi, 16h
      }
      JUMPOUT(0x40822E);
    }
    _BH = v10 - *(_BYTE *)(_ECX + 57);
    __asm
    {
      insd
      rcl     bh, cl
    }
    return result;
  }
  __asm { rcr     ah, cl }
  if ( !v27 && v27 )
    __asm { retf }
  return result;
}
// 4084D1: positive sp value 20 has been found
// 407F09: control flows out of bounds to 407F0B
// 4080CC: control flows out of bounds to 4080CE
// 4081B6: control flows out of bounds to 4081B8
// 408252: control flows out of bounds to 408253
// 40831D: control flows out of bounds to 40831F
// 408373: control flows out of bounds to 408374
// 4083E0: control flows out of bounds to 4083E1
// 408415: control flows out of bounds to 408416
// 408476: control flows out of bounds to 408477
// 408592: control flows out of bounds to 408597
// 407F64: control flows out of bounds to 407F65
// 408565: control flows out of bounds to 408279
// 4081EA: control flows out of bounds to 40854D
// 408387: control flows out of bounds to 408152
// 40858A: control flows out of bounds to 40822E
// 407FB8: control flows out of bounds to 407F5D
// 4084D1: control flows out of bounds to 40851C
// 408540: conditional instruction was optimized away because ah.1>=0
// 407F03: conditional instruction was optimized away because bh.1 is in (1..15)
// 408146: conditional instruction was optimized away because edi.4>=0
// 4080CC: conditional instruction was optimized away because cc.1==0
// 408465: variable 'v88' is possibly undefined
// 4084D0: variable 'v108' is possibly undefined
// 4084D0: variable 'v109' is possibly undefined
// 4084D0: variable 'v110' is possibly undefined
// 4084D0: variable 'v111' is possibly undefined
// 4084D0: variable 'v112' is possibly undefined

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
