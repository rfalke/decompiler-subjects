// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010C4: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	real64 rArg0_10;
	word32 edi_11 = fn004010D4(eax, cx, edx, ebx, ebp, edi, rArg0, rArg5, out rArg0_10);
	byte v5_15 = Mem0[eax + 0x00:byte] + al;
	Mem16[eax + 0x00:byte] = v5_15;
	byte al_19 = al - (v5_15 <u 0x00);
	Mem28[edx + 3244744192:byte] = Mem16[edx + 3244744192:byte] + (byte) ((~0x6F - (fp + 0x08)) - (al_19 <u 0x00));
	word32 eax_20 = DPB(eax, al_19, 0);
	fn004010D6(eax_20, edx, ebx, ebp, edi_11, dwArg08);
	return eax_20;
}

// 004010D4: Register word32 fn004010D4(Register word32 eax, Register word16 cx, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 edi, FpuStack real64 rArg0, FpuStack real64 rArg5, FpuStack out ptr32 rArg0Out)
word32 fn004010D4(word32 eax, word16 cx, word32 edx, word32 ebx, word32 ebp, word32 edi, real64 rArg0, real64 rArg5, ptr32 & rArg0Out)
{
	__rol(cx, 0x04);
	return fn004010D6(eax, edx, ebx, ebp, edi, dwArg00);
}

// 004010D6: Register word32 fn004010D6(Register word32 eax, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 edi, Stack word32 dwArg00)
word32 fn004010D6(word32 eax, word32 edx, word32 ebx, word32 ebp, word32 edi, word32 dwArg00)
{
	ptr32 fp;
	word32 edx;
	word32 ebx;
	<type-error> Mem0;
	word32 edi;
	word32 dwArg00;
	real64 rArg0;
	word32 eax;
	word32 ebp;
	real64 rArg5;
	esp_1 = fp;
	v3_5 = (edx[ebx * 0x02] & 0x04000000) != 0x00;
	edx[ebx * 0x02] = __rol(edx[ebx * 0x02], 0x66);
	edi_8 = edi - ~0x3E;
	edi_10 = dwArg00;
	edi_11 = edi_10 - ~0x07;
	di_12 = (word16) edi_11;
	ecx_13 = 0x00;
	ecx_14 = ~0x6F;
	cl_15 = (byte) ecx_14;
	cx_16 = (word16) ecx_14;
	SCZO_17 = cond(Mem6[edi_11 + 0x00:byte] - cl_15);
	Z_18 = SCZO_17;
	if (Mem6[edi_11 + 0x00:byte] == cl_15)
	{
		rArg0_24 = fn0040110D(eax, cx_16, ebp, di_12, rArg0, rArg5);
		return edi_11;
	}
	else
		return edi_11;
}

// 0040110D: FpuStack real64 fn0040110D(Register word32 eax, Register word16 cx, Register word32 ebp, Register word16 di, FpuStack real64 rArg0, FpuStack real64 rArg5)
real64 fn0040110D(word32 eax, word16 cx, word32 ebp, word16 di, real64 rArg0, real64 rArg5)
{
	fn00401123(eax, cx, ebp, di, dwLoc04, dwArg00);
}

// 00401123: void fn00401123(Register word32 eax, Register word16 cx, Register word32 ebp, Register word16 di, Stack word32 dwArg00, Stack word32 dwArg04)
void fn00401123(word32 eax, word16 cx, word32 ebp, word16 di, word32 dwArg00, word32 dwArg04)
{
	word32 eax_19 = DPB(1215832, (word16) (fp + 0x04), 0);
	word32 edx_30 = Mem0[0x004010BF:word32];
	word32 edi_23 = Mem0[eax_19 + 0x00:word32];
	word32 ecx_28 = -DPB(ecx + 3631729173, (word16) (ecx + 3631729173) - 0x5D, 0);
	word16 ax_33 = (word16) (eax_19 & edx_30);
	do
	{
		edi_23 = edi_23 + 0x01;
		word32 esi_49 = ~Mem0[edi_23 + 0x00:word32] + edx_30;
		ecx_28 = ~ecx_28;
		ax_33 = __ror(ax_33 + 0x7F, 0x01);
	} while (esi_49 != 0x01);
	__rol(ecx_28, 0x01);
	word32 eax_67 = Mem0[edi_23 - 0x05 + 0x00:word32];
	__ror((edx_30 ^ ebp) + 4001110173, 0x02);
	word32 ecx_106 = fp + 0x04;
	word32 eax_101 = dwArg04;
	word32 edi_88 = Mem0[4198441:word32];
	do
	{
		word32 esi_98 = Mem0[eax_101 + 0x00:word32];
		__rol(ecx_106, 0x06);
		eax_101 = eax_101 - ~0x00;
		ecx_106 = esi_98 ^ edi_88;
	} while (ecx_106 != 0x00);
	word32 edi_115 = edi_88 ^ eax_67;
	word16 cx_140 = (word16) ((eax_67 + 2856355484 ^ DPB(edi_115, (word16) edi_115 | ~0x35, 0)) + Mem0[fs:0x00:word32]);
	Mem141[fs:0x00:word32] = fp - 0x04;
	__rol(cx_140, 0x07);
}

