/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
char __cdecl start(int a1, char a2);
char __stdcall sub_401169(int a1, char *a2, _BYTE *a3);
// unsigned int __usercall sub_401186@<eax>(int a1@<ebp>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401192; // weak


//----- (00401010) --------------------------------------------------------
char __cdecl start(int a1, char a2)
{
  unsigned int v2; // eax
  SIZE_T v3; // ecx
  _DWORD *v4; // ebx
  int v5; // eax
  signed int v6; // ecx
  bool v7; // cc
  char *v8; // ebx
  _DWORD *v9; // esi
  _BYTE *v10; // eax
  signed int v12; // [esp+0h] [ebp-1Ch]
  int v13; // [esp+4h] [ebp-18h] BYREF
  LPVOID lpAddress; // [esp+8h] [ebp-14h]
  SIZE_T dwSize; // [esp+Ch] [ebp-10h]
  int v16; // [esp+10h] [ebp-Ch]
  int v17; // [esp+14h] [ebp-8h]
  DWORD flOldProtect; // [esp+18h] [ebp-4h] BYREF
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  sub_401186((int)&savedregs);
  lpAddress = (LPVOID)0x2000;
  v16 = 108735118;
  v17 = 257297872;
  v2 = ((v12 - 7) << 13) + ((4460560 - (v12 << 15)) & 0xFFFF0000);
  *(int *)((char *)&v13 + v12) = *(_DWORD *)(((unsigned int)(v12 << 15) >> 2) + v2 - 65420);
  lpAddress = (LPVOID)(v2 + 32904 - ((v12 << 12) & 0x1FFFFFFF));
  VirtualProtect(lpAddress, dwSize, 4u, &flOldProtect);
  v3 = dwSize;
  v4 = lpAddress;
  v5 = v12 + v16;
  for ( flOldProtect = 1; ; flOldProtect = -flOldProtect )
  {
    *v4 ^= v5;
    v6 = v3 + 4;
    v7 = v6 < v12;
    v3 = v6 - v12;
    if ( v7 )
      break;
    v5 += flOldProtect + v17;
    v4 = (_DWORD *)((char *)v4 - v12 + 12);
  }
  v8 = (char *)lpAddress + *(_DWORD *)((char *)lpAddress - v12 + 68);
  v13 = (unsigned __int8)v8[6];
  flOldProtect = (DWORD)VirtualAlloc(*((LPVOID *)v8 + 13), *((_DWORD *)v8 + 20), 0x3000u, 0x40u);
  sub_401169(*(_DWORD *)&v8[-v12 + 92], (char *)lpAddress, (_BYTE *)flOldProtect);
  v9 = v8 + 248;
  do
  {
    sub_401169(v9[4], (char *)lpAddress + v9[5], (_BYTE *)(v9[3] + flOldProtect));
    v9 += 10;
    --v13;
  }
  while ( v13 );
  *(_DWORD *)(&a2 - v12) = flOldProtect + *(_DWORD *)&v8[v12 + 32];
  v10 = (_BYTE *)flOldProtect;
  do
    v10 += 4;
  while ( *(_DWORD *)v10 != v12 - 1430532907 );
  return sub_401169(64 - v12, (char *)&loc_401192 + v12 + 2, v10);
}
// 40103D: variable 'v12' is possibly undefined

//----- (00401169) --------------------------------------------------------
char __stdcall sub_401169(int a1, char *a2, _BYTE *a3)
{
  char result; // al

  do
  {
    result = *a2;
    *a3++ = *a2++;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00401186) --------------------------------------------------------
unsigned int __usercall sub_401186@<eax>(int a1@<ebp>)
{
  unsigned int result; // eax

  result = ((unsigned int)MEMORY[0x7FFE0300]() >> 27) & 0xF;
  *(_DWORD *)(a1 - 28) = result;
  return result;
}
// 7FFE0300: using guessed type int (*)(void);

// nfuncs=3 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled
