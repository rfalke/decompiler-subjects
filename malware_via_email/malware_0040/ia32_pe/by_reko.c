// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40602C = 24744; // 0040602C
word32 g_dw406030 = 0x60B8; // 00406030
word32 g_dw406034 = 0x60CC; // 00406034
word32 g_dw406038 = 0x60DC; // 00406038
word32 g_dw40603C = 24824; // 0040603C
word32 g_dw406040 = 0x6110; // 00406040
word32 g_dw406044 = 24868; // 00406044
word32 g_dw406048 = 24888; // 00406048
word32 g_dw40604C = 0x614C; // 0040604C
word32 g_dw406050 = 24924; // 00406050
word32 g_dw406054 = 24944; // 00406054
word32 g_dw406058 = 24964; // 00406058
word32 g_dw40605C = 24988; // 0040605C
word32 g_dw406060 = 25000; // 00406060
<anonymous> * __imp__CloseHandle = &g_t60A8; // 0040606C
<anonymous> * __imp__CreateProcessA = &g_t60B8; // 00406070
<anonymous> * __imp__ExitProcess = &g_t60CC; // 00406074
<anonymous> * __imp__GetEnvironmentVariableA = &g_t60DC; // 00406078
<anonymous> * __imp__GetModuleFileNameA = &g_t60F8; // 0040607C
<anonymous> * __imp__GetShortPathNameA = &g_t6110; // 00406080
<anonymous> * __imp__GetThreadContext = &g_t6124; // 00406084
<anonymous> * __imp__ReadProcessMemory = &g_t6138; // 00406088
<anonymous> * __imp__ResumeThread = &g_t614C; // 0040608C
<anonymous> * __imp__SetThreadContext = &g_t615C; // 00406090
<anonymous> * __imp__VirtualAllocEx = &g_t6170; // 00406094
<anonymous> * __imp__WriteProcessMemory = &g_t6184; // 00406098
<anonymous> * __imp__lstrcatA = &g_t619C; // 0040609C
<anonymous> * __imp__lstrcpyA = &g_t61A8; // 004060A0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_4 * ebx;
	struct Eq_5 * edx;
	struct Eq_6 * edi;
	struct Eq_7 * esi;
	byte * ecx;
	struct Eq_9 * es;
	word32 dwLoc20;
	struct Eq_11 * ebp_18;
	word32 eax_17 = fn00401078(fp - 4, out ebp_18);
	ptr32 ebp_43 = fn0040111D((byte) eax_17, SLICE(eax_17, word24, 8), ecx, edx, ebx, ebp_18, esi, edi, es, (word16) dwLoc20);
	struct Eq_38 * esp_49 = (struct Eq_38 *) <invalid>;
	esp_49->dw0004 = 0x062E;
	esp_49->dw0000 = 0x0040111D;
	word32 ebp_70;
	fn00401078(ebp_43, out ebp_70);
	return 0x00;
}

// 00401078: Register (ptr32 (arr byte)) fn00401078(Register ptr32 ebp, Register out ptr32 ebpOut)
// Called from:
//      Win32CrtStartup
byte (* fn00401078)[](ptr32 ebp, ptr32 & ebpOut)
{
	Eq_54 tLoc04;
	tLoc04.ptr0000 = ebp;
	ptr32 ebp_12;
	byte (* eax_11)[] = fn004010D4(&tLoc04, out ebp_12);
	ebpOut = ebp_12;
	return eax_11;
}

// 004010B4: Register (ptr32 (arr byte)) fn004010B4(Register (ptr32 (arr byte)) eax, Register (ptr32 Eq_63) ebp, Register out ptr32 ebpOut)
// Called from:
//      fn004010D4
//      fn0040111D
byte (* fn004010B4)[](byte (* eax)[], struct Eq_63 * ebp, ptr32 & ebpOut)
{
	if ((eax - 0x01 & 0x03) != 0x00)
	{
		word32 ebp_64;
		byte (* eax_27)[] = fn004010D4((char *) &ebp->ptr0000 + 1, out ebp_64);
		ebpOut = <invalid>;
		return eax_27;
	}
	else
	{
		byte (* eax_31)[] = fn004010BE();
		ebpOut = <invalid>;
		return eax_31;
	}
}

// 004010BE: Register (ptr32 (arr byte)) fn004010BE()
// Called from:
//      fn004010B4
//      fn004010D4
byte (* fn004010BE)[]()
{
	byte (* eax)[];
	byte * ecx;
	struct Eq_5 * edx;
	struct Eq_92 * ebx;
	return fn004010C5(eax, ecx, edx, ebx);
}

// 004010C5: Register (ptr32 (arr byte)) fn004010C5(Register (ptr32 (arr byte)) eax, Register (ptr32 byte) ecx, Register (ptr32 Eq_5) edx, Register (ptr32 Eq_92) ebx)
// Called from:
//      fn004010BE
//      fn0040111D
byte (* fn004010C5)[](byte (* eax)[], byte * ecx, struct Eq_5 * edx, struct Eq_92 * ebx)
{
	struct Eq_63 * ebp;
	ebx->dw558BFC45 = __ror<word32,byte>(ebx->dw558BFC45, 0x08);
	Mem23[ecx + 0x00:byte] = Mem15[edx + eax:byte] + 188;
	word32 ebp_41;
	return fn004010D4(ebp, out ebp_41);
}

// 004010D4: Register (ptr32 (arr byte)) fn004010D4(Register (ptr32 Eq_63) ebp, Register out (ptr32 Eq_63) ebpOut)
// Called from:
//      fn00401078
//      fn004010B4
//      fn004010BE
//      fn004010C5
byte (* fn004010D4)[](struct Eq_63 * ebp, struct Eq_63 & ebpOut)
{
	byte (* eax)[];
	do
	{
		if (ebp->ptrFFFFFFFC > (byte (*)[]) 0x03)
			Mem17[Mem5[ebp + 8:word32] + Mem5[ebp + -4:word32]:byte] = Mem5[Mem5[ebp + -4:word32] + Mem5[ebp + 8:word32]:byte] - 212;
		if ((ebp->ptrFFFFFFFC & 0x01) == 0x00)
			Mem36[Mem19[ebp + 8:word32] + Mem19[ebp + -4:word32]:byte] = Mem19[Mem19[ebp + -4:word32] + Mem19[ebp + 8:word32]:byte] - Mem19[ebp + 0x04:byte];
		ebp->ptrFFFFFFFC = (byte (*)[]) (ebp->ptrFFFFFFFC + 1);
		byte (* eax_43)[] = ebp->ptrFFFFFFFC;
		if (eax_43 >= ebp->ptr000C)
		{
			ebpOut = ebp->ptr0000;
			return eax_43;
		}
		if (ebp->ptrFFFFFFFC > (byte (*)[]) 0x01)
			Mem62[Mem41[ebp + 8:word32] + Mem41[ebp + -4:word32]:byte] = Mem41[Mem41[ebp + 8:word32] + Mem41[ebp + -4:word32]:byte] ^ 0x99;
	} while (ebp->ptrFFFFFFFC <= (byte (*)[]) 0x01);
	word32 ebp_123;
	byte (* eax_78)[] = fn004010B4(eax, ebp, out ebp_123);
	ebpOut = ebp;
	return eax_78;
}

// 0040111D: Register (ptr32 Eq_11) fn0040111D(Register byte al, Register word24 eax_24_8, Register (ptr32 byte) ecx, Register (ptr32 Eq_5) edx, Register (ptr32 Eq_4) ebx, Register (ptr32 Eq_11) ebp, Register (ptr32 Eq_7) esi, Register (ptr32 Eq_6) edi, Register (ptr16 Eq_9) es, Stack word16 wArg00)
// Called from:
//      Win32CrtStartup
struct Eq_11 * fn0040111D(byte al, word24 eax_24_8, byte * ecx, struct Eq_5 * edx, struct Eq_4 * ebx, struct Eq_11 * ebp, struct Eq_7 * esi, struct Eq_6 * edi, struct Eq_9 * es, word16 wArg00)
{
	ptr32 fp;
	struct Eq_229 * cs;
	Eq_230 SCZDOP;
	word32 dwArg00;
	byte cl_20 = (byte) ecx;
	word24 ecx_24_8_24 = SLICE(ecx, word24, 8);
	byte dl = (byte) edx;
	byte dh = SLICE(edx, byte, 8);
	byte ah_76 = (byte) eax_24_8;
	word16 wArg00_210 = (word16) dwArg00;
	esi->ptr0018 = edi;
	char al_17 = al + dl;
	word32 * ebp_130 = (char *) &ebp->dwE08FF9C0 + 0x1F700641;
	byte (* eax_61)[] = SEQ(eax_24_8, al_17);
	uint16 dx_93 = (word16) edx;
	if (al_17 >= 0x00)
	{
		struct Eq_258 * ecx_25 = SEQ(ecx_24_8_24, cl_20 + esi->bC48ECCCD);
		ecx_25->bFFFFFF88 |= dh;
		__lock();
		int32 v31_34 = ecx_25->dw3EE64DF7 + 0x01;
		ecx_25->dw3EE64DF7 = v31_34;
		uint16 dx_43 = (word16) edx - 0x01;
		if (v31_34 > 0x00)
		{
			__in<word32>(dx_43);
			ebp->dwE08FF9C0 &= 0x9A47414A;
		}
	}
	ptr32 esp_119 = fp - 2;
	word32 * eax_112 = SEQ(eax_24_8, al_17);
	struct Eq_4 * ebx_107 = ebx;
	word32 dwLoc02_211 = SEQ(wArg00_210, cs);
	if (al_17 > 0x00)
	{
		if (al_17 <= 0x00)
		{
			struct Eq_11 * ebp_63;
			fn004010B4(eax_61, (char *) &ebp->dwE08FF9C0 + 0x1F700641, out ebp_63);
			return ebp_63;
		}
		if (al_17 > 0x00)
		{
l0040117F:
			edi->dw0000 = esi->dw0000;
			return ebp_130 - 0x01;
		}
		byte (* eax_85)[] = SEQ(eax_24_8, al_17 + 0x4B);
		if (al_17 < 181)
		{
			fn004010C5(eax_85, ecx, edx, ebx - 0x01);
			return (char *) &ebp->dwE08FF9C0 + 0x1F700641;
		}
		struct Eq_385 * eax_96 = (int32) SEQ(ah_76, __in<byte>(dx_93));
		ecx = edx->dw006A *s 0x7BC02508;
		eax_96->dw004A = dwLoc02_211;
		esp_119 = fp + 2;
		ebx_107 = ebx - 0x02;
		eax_112 = SEQ(SLICE(eax_96, word24, 8), (byte) eax_96 + 0x6B);
		SCZDOP = SLICE(cond(edi->b001A & 0x26), bool, 5) | SCZDOP;
	}
	up32 ecx_117 = ecx + *eax_112;
	struct Eq_304 * esp_120 = esp_119 - 4;
	esp_120->t0000.u1 = (word32) (cond(ecx_117) | SLICE(SCZDOP, bool, 5));
	ebx_107->bF34A8C8F = __rcr<byte,byte>(ebx_107->bF34A8C8F, 0x47, SLICE(cond((byte) esi - 0x41 - (byte) (ecx_117 < 0x00)), bool, 1));
	esp_120->ptrFFFFFFFE = es;
	ebp->dw47FDA85 |= ~0x74;
	__in<word32>(3093);
	struct Eq_351 * ebx_158 = ebx_107 - 0x01;
	ebx_158->bAD4AA88F >>= 0x02;
	ebp_130 = eax_112;
	esi = (struct Eq_7 *) ((char *) &ebp->dwE08FF9C0 + 0x1F700641);
	edi = &edi->dw0000 + 1;
	goto l0040117F;
}

