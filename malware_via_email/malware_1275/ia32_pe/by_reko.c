// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_tB6C8; // 0040B000
<anonymous> * __imp__LocalFree = &g_tB6DA; // 0040B004
<anonymous> * __imp__HeapDestroy = &g_tB6E6; // 0040B008
<anonymous> * __imp__HeapAlloc = &g_tB6F4; // 0040B00C
<anonymous> * __imp__HeapAlloc = &g_tB700; // 0040B010
<anonymous> * __imp__Sleep = &g_tB70C; // 0040B014
<anonymous> * __imp__LoadLibraryW = &g_tB714; // 0040B018
<anonymous> * __imp__ReadFile = &g_tB724; // 0040B01C
<anonymous> * __imp__UnhandledExceptionFilter = &g_tB730; // 0040B020
<anonymous> * __imp__InterlockedDecrement = &g_tB74C; // 0040B024
<anonymous> * __imp__VirtualProtect = &g_tB764; // 0040B028
<anonymous> * __imp__GetModuleFileNameA = &g_tB776; // 0040B02C
<anonymous> * __imp__GetCurrentThreadId = &g_tB78C; // 0040B030
<anonymous> * __imp__LeaveCriticalSection = &g_tB7A2; // 0040B034
<anonymous> * __imp__CreateEventW = &g_tB7BA; // 0040B038
<anonymous> * __imp__InitializeCriticalSection = &g_tB7CA; // 0040B03C
<anonymous> * __imp__MultiByteToWideChar = &g_tB7E6; // 0040B040
<anonymous> * __imp__LoadLibraryW = &g_tB7FC; // 0040B044
<anonymous> * __imp__LeaveCriticalSection = &g_tB80C; // 0040B048
<anonymous> * __imp__LocalFree = &g_tB824; // 0040B04C
<anonymous> * __imp__SetLastError = &g_tB830; // 0040B050
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tB840; // 0040B054
<anonymous> * __imp__VirtualProtect = &g_tB85C; // 0040B058
<anonymous> * __imp__GetLastError = &g_tB86E; // 0040B05C
<anonymous> * __imp__LoadLibraryA = &g_tB87E; // 0040B060
<anonymous> * __imp__VirtualAlloc = &g_tB88E; // 0040B064
<anonymous> * __imp__GetTickCount = &g_tB89E; // 0040B068
<anonymous> * __imp__MultiByteToWideChar = &g_tB8AE; // 0040B06C
<anonymous> * __imp__CreateEventW = &g_tB8C4; // 0040B070
<anonymous> * __imp__HeapFree = &g_tB8D4; // 0040B074
<anonymous> * __imp__VirtualAlloc = &g_tB8E0; // 0040B078
<anonymous> * __imp__InterlockedDecrement = &g_tB8F0; // 0040B07C
<anonymous> * __imp__LoadLibraryA = &g_tB908; // 0040B080
<anonymous> * __imp__LocalFree = &g_tB918; // 0040B084
<anonymous> * __imp__LocalAlloc = &g_tB924; // 0040B088
<anonymous> * __imp__ReadFile = &g_tB932; // 0040B08C
<anonymous> * __imp__GetModuleHandleA = &g_tB93E; // 0040B090
<anonymous> * __imp__Sleep = &g_tB952; // 0040B094
<anonymous> * __imp__GetProcAddress = &g_tB95A; // 0040B098
<anonymous> * __imp__InitializeCriticalSection = &g_tB96C; // 0040B09C
<anonymous> * __imp__QueryPerformanceCounter = &g_tB988; // 0040B0A0
<anonymous> * __imp__CreateEventW = &g_tB9A2; // 0040B0A4
<anonymous> * __imp__LocalFree = &g_tB9B2; // 0040B0A8
<anonymous> * __imp__LoadLibraryW = &g_tB9BE; // 0040B0AC
<anonymous> * __imp__GetCurrentProcessId = &g_tB9CE; // 0040B0B0
<anonymous> * __imp__lstrlenA = &g_tB9E4; // 0040B0B4
<anonymous> * __imp__LocalAlloc = &g_tB9F0; // 0040B0B8
<anonymous> * __imp__LoadLibraryW = &g_tB9FE; // 0040B0BC
<anonymous> * __imp__CreateFileW = &g_tBA0E; // 0040B0C0
<anonymous> * __imp__DeleteCriticalSection = &g_tBA1C; // 0040B0C4
<anonymous> * __imp__ClearEventLogA = &g_tBA42; // 0040B0CC
<anonymous> * __imp__LsaLookupSids = &g_tBA54; // 0040B0D0
<anonymous> * __imp__GetNamedSecurityInfoExA = &g_tBA64; // 0040B0D4
<anonymous> * __imp__LsaStorePrivateData = &g_tBA7E; // 0040B0D8
<anonymous> * __imp__CryptGetKeyParam = &g_tBA94; // 0040B0DC
<anonymous> * __imp__LsaQueryDomainInformationPolicy = &g_tBAA8; // 0040B0E0
<anonymous> * __imp__EqualPrefixSid = &g_tBACA; // 0040B0E4
<anonymous> * __imp__AccessCheckByTypeResultListAndAuditAlarmW = &g_tBADC; // 0040B0E8
<anonymous> * __imp__AllocateAndInitializeSid = &g_tBB08; // 0040B0EC
<anonymous> * __imp__DecryptFileA = &g_tBB24; // 0040B0F0
<anonymous> * __imp__SystemFunction032 = &g_tBB34; // 0040B0F4
<anonymous> * __imp__LsaSetSecret = &g_tBB48; // 0040B0F8
<anonymous> * __imp__SystemFunction003 = &g_tBB58; // 0040B0FC
<anonymous> * __imp__ConvertSecurityDescriptorToAccessW = &g_tBB6C; // 0040B100
<anonymous> * __imp__MakeAbsoluteSD = &g_tBB92; // 0040B104
<anonymous> * __imp__SetNamedSecurityInfoExA = &g_tBBA4; // 0040B108
<anonymous> * __imp__CryptSignHashA = &g_tBBBE; // 0040B10C
<anonymous> * __imp__SetSecurityInfoExA = &g_tBBD0; // 0040B110
<anonymous> * __imp__BuildImpersonateExplicitAccessWithNameW = &g_tBBE6; // 0040B114
<anonymous> * __imp__GetTraceEnableFlags = &g_tBC10; // 0040B118
<anonymous> * __imp__MakeSelfRelativeSD = &g_tBC26; // 0040B11C
<anonymous> * __imp__OpenEncryptedFileRawA = &g_tBC3C; // 0040B120
<anonymous> * __imp__RegQueryMultipleValuesA = &g_tBC54; // 0040B124
<anonymous> * __imp__LookupPrivilegeDisplayNameW = &g_tBC6E; // 0040B128
<anonymous> * __imp__GetLengthSid = &g_tBC8C; // 0040B12C
<anonymous> * __imp__NotifyBootConfigStatus = &g_tBC9C; // 0040B130
<anonymous> * __imp__CryptAcquireContextW = &g_tBCB6; // 0040B134
<anonymous> * __imp__SystemFunction020 = &g_tBCCE; // 0040B138
<anonymous> * __imp__ReportEventA = &g_tBCE2; // 0040B13C
<anonymous> * __imp__RegOpenUserClassesRoot = &g_tBCF2; // 0040B140
<anonymous> * __imp__StartServiceCtrlDispatcherA = &g_tBD0C; // 0040B144
<anonymous> * __imp__InitializeSid = &g_tBD2A; // 0040B148
<anonymous> * __imp__ElfReportEventA = &g_tBD3A; // 0040B14C
<anonymous> * __imp__WmiSetSingleItemA = &g_tBD4C; // 0040B150
<anonymous> * __imp__ImpersonateNamedPipeClient = &g_tBD60; // 0040B154
<anonymous> * __imp__ElfOldestRecord = &g_tBD7E; // 0040B158
<anonymous> * __imp__SetFileSecurityA = &g_tBD90; // 0040B15C
<anonymous> * __imp__RegDeleteKeyW = &g_tBDA4; // 0040B160
<anonymous> * __imp__WmiExecuteMethodA = &g_tBDB4; // 0040B164
<anonymous> * __imp__SetTokenInformation = &g_tBDC8; // 0040B168
<anonymous> * __imp__SetAclInformation = &g_tBDDE; // 0040B16C
<anonymous> * __imp__RegSetValueA = &g_tBDF2; // 0040B170
<anonymous> * __imp__AddAccessAllowedAceEx = &g_tBE02; // 0040B174
<anonymous> * __imp__AccessCheckByTypeResultListAndAuditAlarmA = &g_tBE1A; // 0040B178
<anonymous> * __imp__GetSecurityInfoExW = &g_tBE46; // 0040B17C
<anonymous> * __imp__CancelOverlappedAccess = &g_tBE5C; // 0040B180
<anonymous> * __imp__CloseEncryptedFileRaw = &g_tBE76; // 0040B184
<anonymous> * __imp__GetDC = &g_tBE9C; // 0040B18C
<anonymous> * __imp__GetClientRect = &g_tBEA4; // 0040B190
<anonymous> * __imp__LoadStringW = &g_tBEB4; // 0040B194
<anonymous> * __imp__MessageBoxW = &g_tBEC2; // 0040B198
<anonymous> * __imp__BeginPaint = &g_tBED0; // 0040B19C
<anonymous> * __imp__LoadStringW = &g_tBEDE; // 0040B1A0
<anonymous> * __imp__SetFocus = &g_tBEEC; // 0040B1A4
<anonymous> * __imp__DispatchMessageW = &g_tBEF8; // 0040B1A8
<anonymous> * __imp__GetParent = &g_tBF0C; // 0040B1AC
<anonymous> * __imp__DialogBoxParamW = &g_tBF18; // 0040B1B0
<anonymous> * __imp__SendMessageW = &g_tBF2A; // 0040B1B4
<anonymous> * __imp__wsprintfA = &g_tBF3A; // 0040B1B8
<anonymous> * __imp__BeginPaint = &g_tBF46; // 0040B1BC
<anonymous> * __imp__InvalidateRect = &g_tBF54; // 0040B1C0
<anonymous> * __imp__DefWindowProcW = &g_tBF66; // 0040B1C4
<anonymous> * __imp__EndDialog = &g_tBF78; // 0040B1C8
<anonymous> * __imp__LoadStringW = &g_tBF84; // 0040B1CC
<anonymous> * __imp__SetWindowTextW = &g_tBF92; // 0040B1D0
<anonymous> * __imp__GetWindowRect = &g_tBFA4; // 0040B1D4
<anonymous> * __imp__wsprintfA = &g_tBFB4; // 0040B1D8
<anonymous> * __imp__wsprintfA = &g_tBFC0; // 0040B1DC
<anonymous> * __imp__GetDlgItem = &g_tBFCC; // 0040B1E0
<anonymous> * __imp__GetParent = &g_tBFDA; // 0040B1E4
<anonymous> * __imp__GetDlgItem = &g_tBFE6; // 0040B1E8
<anonymous> * __imp__SetForegroundWindow = &g_tBFF4; // 0040B1EC
<anonymous> * __imp__DestroyWindow = &g_tC00A; // 0040B1F0
<anonymous> * __imp__wsprintfA = &g_tC01A; // 0040B1F4
<anonymous> * __imp__GetSysColor = &g_tC026; // 0040B1F8
<anonymous> * __imp__DispatchMessageW = &g_tC034; // 0040B1FC
<anonymous> * __imp__EndPaint = &g_tC048; // 0040B200
<anonymous> * __imp__LoadIconW = &g_tC054; // 0040B204
<anonymous> * __imp__GetWindowRect = &g_tC060; // 0040B208
<anonymous> * __imp__KillTimer = &g_tC070; // 0040B20C
<anonymous> * __imp__DispatchMessageW = &g_tC07C; // 0040B210
<anonymous> * __imp__IsDlgButtonChecked = &g_tC090; // 0040B214
<anonymous> * __imp__SendDlgItemMessageW = &g_tC0A6; // 0040B218
<anonymous> * __imp__PeekMessageW = &g_tC0BC; // 0040B21C
<anonymous> * __imp__GetFocus = &g_tC0CC; // 0040B220
<anonymous> * __imp__SetWindowPos = &g_tC0D8; // 0040B224
<anonymous> * __imp__CharNextW = &g_tC0E8; // 0040B228
<anonymous> * __imp__DialogBoxParamW = &g_tC0F4; // 0040B22C
<anonymous> * __imp__TranslateMessage = &g_tC106; // 0040B230
<anonymous> * __imp__BeginPaint = &g_tC11A; // 0040B234
<anonymous> * __imp__TranslateMessage = &g_tC128; // 0040B238
<anonymous> * __imp__GetWindowLongW = &g_tC13C; // 0040B23C
<anonymous> * __imp__GetWindowRect = &g_tC14E; // 0040B240
<anonymous> * __imp__GetSysColor = &g_tC15E; // 0040B244
<anonymous> * __imp__GetFocus = &g_tC16C; // 0040B248
<anonymous> * __imp__EnableWindow = &g_tC178; // 0040B24C
<anonymous> * __imp__SetBrushOrgEx = &g_tC194; // 0040B254
<anonymous> * __imp__LineTo = &g_tC1A4; // 0040B258
<anonymous> * __imp__GetBkMode = &g_tC1AE; // 0040B25C
<anonymous> * __imp__Polygon = &g_tC1BA; // 0040B260
<anonymous> * __imp__SelectObject = &g_tC1C4; // 0040B264
<anonymous> * __imp__GetBkColor = &g_tC1D4; // 0040B268
<anonymous> * __imp__SelectObject = &g_tC1E2; // 0040B26C
<anonymous> * __imp__CreateBitmapIndirect = &g_tC1F2; // 0040B270
<anonymous> * __imp__SetPixel = &g_tC20A; // 0040B274
<anonymous> * __imp__SetWindowOrgEx = &g_tC216; // 0040B278
<anonymous> * __imp__GetWindowOrgEx = &g_tC228; // 0040B27C
<anonymous> * __imp__CreateBitmap = &g_tC23A; // 0040B280
<anonymous> * __imp__BitBlt = &g_tC24A; // 0040B284
<anonymous> * __imp__GetBkColor = &g_tC254; // 0040B288
<anonymous> * __imp__CreateFontIndirectA = &g_tC262; // 0040B28C
<anonymous> * __imp__PatBlt = &g_tC278; // 0040B290
<anonymous> * __imp__CreateBitmap = &g_tC282; // 0040B294
<anonymous> * __imp__StretchBlt = &g_tC292; // 0040B298
<anonymous> * __imp__SetPixel = &g_tC2A0; // 0040B29C
<anonymous> * __imp__SetTextColor = &g_tC2AC; // 0040B2A0
<anonymous> * __imp__SetPixel = &g_tC2BC; // 0040B2A4
<anonymous> * __imp__BitBlt = &g_tC2C8; // 0040B2A8
<anonymous> * __imp__CreateDIBitmap = &g_tC2D2; // 0040B2AC
<anonymous> * __imp__GetBkColor = &g_tC2E4; // 0040B2B0
<anonymous> * __imp__BitBlt = &g_tC2F2; // 0040B2B4
<anonymous> * __imp__SelectObject = &g_tC2FC; // 0040B2B8
<anonymous> * __imp__CreateBitmap = &g_tC30C; // 0040B2BC
<anonymous> * __imp__CreateBitmapIndirect = &g_tC31C; // 0040B2C0
<anonymous> * __imp__RoundRect = &g_tC334; // 0040B2C4
<anonymous> * __imp__RoundRect = &g_tC340; // 0040B2C8
<anonymous> * __imp__GetBkColor = &g_tC34C; // 0040B2CC
<anonymous> * __imp__CreateBitmapIndirect = &g_tC35A; // 0040B2D0
<anonymous> * __imp__Polygon = &g_tC372; // 0040B2D4
<anonymous> * __imp__CreateDIBSection = &g_tC37C; // 0040B2D8
<anonymous> * __imp__SetWindowExtEx = &g_tC390; // 0040B2DC
<anonymous> * __imp__CombineRgn = &g_tC3A2; // 0040B2E0
<anonymous> * __imp__GetBrushOrgEx = &g_tC3B0; // 0040B2E4
<anonymous> * __imp__SetPixel = &g_tC3C0; // 0040B2E8
<anonymous> * __imp__GetBrushOrgEx = &g_tC3CC; // 0040B2EC
<anonymous> * __imp__CreateBitmapIndirect = &g_tC3DC; // 0040B2F0
<anonymous> * __imp__CreateBitmap = &g_tC3F4; // 0040B2F4
<anonymous> * __imp__Rectangle = &g_tC404; // 0040B2F8
<anonymous> * __imp__CreateCompatibleDC = &g_tC410; // 0040B2FC
<anonymous> * __imp__MoveToEx = &g_tC426; // 0040B300
<anonymous> * __imp__BitBlt = &g_tC432; // 0040B304
<anonymous> * __imp__SetBrushOrgEx = &g_tC43C; // 0040B308
<anonymous> * __imp__PatBlt = &g_tC44C; // 0040B30C
<anonymous> * __imp__SetTextColor = &g_tC456; // 0040B310
<anonymous> * __imp__SelectObject = &g_tC466; // 0040B314
<anonymous> * __imp__BitBlt = &g_tC476; // 0040B318
<anonymous> * __imp__CreateRectRgn = &g_tC480; // 0040B31C
<anonymous> * __imp__SetBrushOrgEx = &g_tC490; // 0040B320
<anonymous> * __imp__GetPixel = &g_tC4A0; // 0040B324
<anonymous> * __imp__CreateCompatibleDC = &g_tC4AC; // 0040B328
word32 g_dw40B398 = 0xB6C8; // 0040B398
word32 g_dw40B39C = 0xB6DA; // 0040B39C
word32 g_dw40B3A0 = 0xB6E6; // 0040B3A0
word32 g_dw40B3A4 = 46836; // 0040B3A4
word32 g_dw40B3A8 = 0xB700; // 0040B3A8
word32 g_dw40B3AC = 0xB70C; // 0040B3AC
word32 g_dw40B3B0 = 46868; // 0040B3B0
word32 g_dw40B3B4 = 46884; // 0040B3B4
word32 g_dw40B3B8 = 0xB730; // 0040B3B8
word32 g_dw40B3BC = 46924; // 0040B3BC
word32 g_dw40B3C0 = 46948; // 0040B3C0
word32 g_dw40B3C4 = 46966; // 0040B3C4
word32 g_dw40B3C8 = 46988; // 0040B3C8
word32 g_dw40B3CC = 47010; // 0040B3CC
word32 g_dw40B3D0 = 0xB7BA; // 0040B3D0
word32 g_dw40B3D4 = 47050; // 0040B3D4
word32 g_dw40B3D8 = 47078; // 0040B3D8
word32 g_dw40B3DC = 47100; // 0040B3DC
word32 g_dw40B3E0 = 0xB80C; // 0040B3E0
word32 g_dw40B3E4 = 47140; // 0040B3E4
word32 g_dw40B3E8 = 0xB830; // 0040B3E8
word32 g_dw40B3EC = 0xB840; // 0040B3EC
word32 g_dw40B3F0 = 0xB85C; // 0040B3F0
word32 g_dw40B3F4 = 47214; // 0040B3F4
word32 g_dw40B3F8 = 0xB87E; // 0040B3F8
word32 g_dw40B3FC = 0xB88E; // 0040B3FC
word32 g_dw40B400 = 47262; // 0040B400
word32 g_dw40B404 = 47278; // 0040B404
word32 g_dw40B408 = 47300; // 0040B408
word32 g_dw40B40C = 0xB8D4; // 0040B40C
word32 g_dw40B410 = 0xB8E0; // 0040B410
word32 g_dw40B414 = 47344; // 0040B414
word32 g_dw40B418 = 0xB908; // 0040B418
word32 g_dw40B41C = 47384; // 0040B41C
word32 g_dw40B420 = 0xB924; // 0040B420
word32 g_dw40B424 = 47410; // 0040B424
word32 g_dw40B428 = 47422; // 0040B428
word32 g_dw40B42C = 47442; // 0040B42C
word32 g_dw40B430 = 47450; // 0040B430
word32 g_dw40B434 = 47468; // 0040B434
word32 g_dw40B438 = 0xB988; // 0040B438
word32 g_dw40B43C = 47522; // 0040B43C
word32 g_dw40B440 = 0xB9B2; // 0040B440
word32 g_dw40B444 = 0xB9BE; // 0040B444
word32 g_dw40B448 = 47566; // 0040B448
word32 g_dw40B44C = 47588; // 0040B44C
word32 g_dw40B450 = 0xB9F0; // 0040B450
word32 g_dw40B454 = 47614; // 0040B454
word32 g_dw40B458 = 0xBA0E; // 0040B458
word32 g_dw40B45C = 47644; // 0040B45C
word32 g_dw40B464 = 0xBA42; // 0040B464
word32 g_dw40B468 = 47700; // 0040B468
word32 g_dw40B46C = 47716; // 0040B46C
word32 g_dw40B470 = 47742; // 0040B470
word32 g_dw40B474 = 47764; // 0040B474
word32 g_dw40B478 = 47784; // 0040B478
word32 g_dw40B47C = 0xBACA; // 0040B47C
word32 g_dw40B480 = 0xBADC; // 0040B480
word32 g_dw40B484 = 0xBB08; // 0040B484
word32 g_dw40B488 = 0xBB24; // 0040B488
word32 g_dw40B48C = 0xBB34; // 0040B48C
word32 g_dw40B490 = 47944; // 0040B490
word32 g_dw40B494 = 0xBB58; // 0040B494
word32 g_dw40B498 = 0xBB6C; // 0040B498
word32 g_dw40B49C = 0xBB92; // 0040B49C
word32 g_dw40B4A0 = 0xBBA4; // 0040B4A0
word32 g_dw40B4A4 = 0xBBBE; // 0040B4A4
word32 g_dw40B4A8 = 0xBBD0; // 0040B4A8
word32 g_dw40B4AC = 0xBBE6; // 0040B4AC
word32 g_dw40B4B0 = 48144; // 0040B4B0
word32 g_dw40B4B4 = 48166; // 0040B4B4
word32 g_dw40B4B8 = 48188; // 0040B4B8
word32 g_dw40B4BC = 48212; // 0040B4BC
word32 g_dw40B4C0 = 48238; // 0040B4C0
word32 g_dw40B4C4 = 0xBC8C; // 0040B4C4
word32 g_dw40B4C8 = 48284; // 0040B4C8
word32 g_dw40B4CC = 0xBCB6; // 0040B4CC
word32 g_dw40B4D0 = 48334; // 0040B4D0
word32 g_dw40B4D4 = 48354; // 0040B4D4
word32 g_dw40B4D8 = 0xBCF2; // 0040B4D8
word32 g_dw40B4DC = 0xBD0C; // 0040B4DC
word32 g_dw40B4E0 = 48426; // 0040B4E0
word32 g_dw40B4E4 = 48442; // 0040B4E4
word32 g_dw40B4E8 = 48460; // 0040B4E8
word32 g_dw40B4EC = 48480; // 0040B4EC
word32 g_dw40B4F0 = 0xBD7E; // 0040B4F0
word32 g_dw40B4F4 = 0xBD90; // 0040B4F4
word32 g_dw40B4F8 = 48548; // 0040B4F8
word32 g_dw40B4FC = 0xBDB4; // 0040B4FC
word32 g_dw40B500 = 48584; // 0040B500
word32 g_dw40B504 = 0xBDDE; // 0040B504
word32 g_dw40B508 = 48626; // 0040B508
word32 g_dw40B50C = 0xBE02; // 0040B50C
word32 g_dw40B510 = 48666; // 0040B510
word32 g_dw40B514 = 0xBE46; // 0040B514
word32 g_dw40B518 = 0xBE5C; // 0040B518
word32 g_dw40B51C = 48758; // 0040B51C
word32 g_dw40B524 = 0xBE9C; // 0040B524
word32 g_dw40B528 = 48804; // 0040B528
word32 g_dw40B52C = 0xBEB4; // 0040B52C
word32 g_dw40B530 = 48834; // 0040B530
word32 g_dw40B534 = 48848; // 0040B534
word32 g_dw40B538 = 0xBEDE; // 0040B538
word32 g_dw40B53C = 0xBEEC; // 0040B53C
word32 g_dw40B540 = 48888; // 0040B540
word32 g_dw40B544 = 0xBF0C; // 0040B544
word32 g_dw40B548 = 0xBF18; // 0040B548
word32 g_dw40B54C = 48938; // 0040B54C
word32 g_dw40B550 = 48954; // 0040B550
word32 g_dw40B554 = 48966; // 0040B554
word32 g_dw40B558 = 48980; // 0040B558
word32 g_dw40B55C = 48998; // 0040B55C
word32 g_dw40B560 = 0xBF78; // 0040B560
word32 g_dw40B564 = 0xBF84; // 0040B564
word32 g_dw40B568 = 49042; // 0040B568
word32 g_dw40B56C = 49060; // 0040B56C
word32 g_dw40B570 = 0xBFB4; // 0040B570
word32 g_dw40B574 = 0xBFC0; // 0040B574
word32 g_dw40B578 = 0xBFCC; // 0040B578
word32 g_dw40B57C = 49114; // 0040B57C
word32 g_dw40B580 = 0xBFE6; // 0040B580
word32 g_dw40B584 = 0xBFF4; // 0040B584
word32 g_dw40B588 = 0xC00A; // 0040B588
word32 g_dw40B58C = 0xC01A; // 0040B58C
word32 g_dw40B590 = 0xC026; // 0040B590
word32 g_dw40B594 = 0xC034; // 0040B594
word32 g_dw40B598 = 49224; // 0040B598
word32 g_dw40B59C = 0xC054; // 0040B59C
word32 g_dw40B5A0 = 0xC060; // 0040B5A0
word32 g_dw40B5A4 = 0xC070; // 0040B5A4
word32 g_dw40B5A8 = 0xC07C; // 0040B5A8
word32 g_dw40B5AC = 0xC090; // 0040B5AC
word32 g_dw40B5B0 = 0xC0A6; // 0040B5B0
word32 g_dw40B5B4 = 0xC0BC; // 0040B5B4
word32 g_dw40B5B8 = 0xC0CC; // 0040B5B8
word32 g_dw40B5BC = 0xC0D8; // 0040B5BC
word32 g_dw40B5C0 = 0xC0E8; // 0040B5C0
word32 g_dw40B5C4 = 0xC0F4; // 0040B5C4
word32 g_dw40B5C8 = 49414; // 0040B5C8
word32 g_dw40B5CC = 49434; // 0040B5CC
word32 g_dw40B5D0 = 49448; // 0040B5D0
word32 g_dw40B5D4 = 0xC13C; // 0040B5D4
word32 g_dw40B5D8 = 49486; // 0040B5D8
word32 g_dw40B5DC = 0xC15E; // 0040B5DC
word32 g_dw40B5E0 = 0xC16C; // 0040B5E0
word32 g_dw40B5E4 = 0xC178; // 0040B5E4
word32 g_dw40B5EC = 49556; // 0040B5EC
word32 g_dw40B5F0 = 0xC1A4; // 0040B5F0
word32 g_dw40B5F4 = 0xC1AE; // 0040B5F4
word32 g_dw40B5F8 = 49594; // 0040B5F8
word32 g_dw40B5FC = 0xC1C4; // 0040B5FC
word32 g_dw40B600 = 0xC1D4; // 0040B600
word32 g_dw40B604 = 49634; // 0040B604
word32 g_dw40B608 = 0xC1F2; // 0040B608
word32 g_dw40B60C = 0xC20A; // 0040B60C
word32 g_dw40B610 = 49686; // 0040B610
word32 g_dw40B614 = 0xC228; // 0040B614
word32 g_dw40B618 = 49722; // 0040B618
word32 g_dw40B61C = 0xC24A; // 0040B61C
word32 g_dw40B620 = 49748; // 0040B620
word32 g_dw40B624 = 0xC262; // 0040B624
word32 g_dw40B628 = 49784; // 0040B628
word32 g_dw40B62C = 49794; // 0040B62C
word32 g_dw40B630 = 0xC292; // 0040B630
word32 g_dw40B634 = 0xC2A0; // 0040B634
word32 g_dw40B638 = 0xC2AC; // 0040B638
word32 g_dw40B63C = 0xC2BC; // 0040B63C
word32 g_dw40B640 = 0xC2C8; // 0040B640
word32 g_dw40B644 = 0xC2D2; // 0040B644
word32 g_dw40B648 = 49892; // 0040B648
word32 g_dw40B64C = 0xC2F2; // 0040B64C
word32 g_dw40B650 = 0xC2FC; // 0040B650
word32 g_dw40B654 = 0xC30C; // 0040B654
word32 g_dw40B658 = 49948; // 0040B658
word32 g_dw40B65C = 0xC334; // 0040B65C
word32 g_dw40B660 = 49984; // 0040B660
word32 g_dw40B664 = 49996; // 0040B664
word32 g_dw40B668 = 50010; // 0040B668
word32 g_dw40B66C = 50034; // 0040B66C
word32 g_dw40B670 = 50044; // 0040B670
word32 g_dw40B674 = 0xC390; // 0040B674
word32 g_dw40B678 = 50082; // 0040B678
word32 g_dw40B67C = 0xC3B0; // 0040B67C
word32 g_dw40B680 = 0xC3C0; // 0040B680
word32 g_dw40B684 = 0xC3CC; // 0040B684
word32 g_dw40B688 = 0xC3DC; // 0040B688
word32 g_dw40B68C = 0xC3F4; // 0040B68C
word32 g_dw40B690 = 0xC404; // 0040B690
word32 g_dw40B694 = 0xC410; // 0040B694
word32 g_dw40B698 = 0xC426; // 0040B698
word32 g_dw40B69C = 50226; // 0040B69C
word32 g_dw40B6A0 = 0xC43C; // 0040B6A0
word32 g_dw40B6A4 = 0xC44C; // 0040B6A4
word32 g_dw40B6A8 = 50262; // 0040B6A8
word32 g_dw40B6AC = 0xC466; // 0040B6AC
word32 g_dw40B6B0 = 0xC476; // 0040B6B0
word32 g_dw40B6B4 = 0xC480; // 0040B6B4
word32 g_dw40B6B8 = 0xC490; // 0040B6B8
word32 g_dw40B6BC = 0xC4A0; // 0040B6BC
word32 g_dw40B6C0 = 0xC4AC; // 0040B6C0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00408024: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
	esi = esi + edx + C;
	v9 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	esi -= 2683413834;
	SCZO = cond(esi);
	v11 = (cl & 0x01 << cl) != 0x00;
	cl = __rcr<byte,byte>(cl, cl, C);
	eax.u0 = 87760490;
	bh.u0 = 88;
	SZP = cond(dh & ah);
	O = false;
	C.u0 = false;
	edx <<= 0x17;
	SCZO = cond(edx);
l00408180:
	dx >>= cl;
	bl <<= cl;
	cl >>= 0x0E;
	ecx &= 0x748139D7;
	edi &= ~0x311D2C22;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
l00408071:
	ah = (byte) ah + 0x00FA;
	SCZO = cond(ah);
	dl = (bool) C.u0 + ((byte) dl + 229);
	SCZO = cond(dl);
	v23 = (eax & 0x01 << 0x20 - 22) != 0x00;
	eax = __rcl<word32,byte>(eax, 22, C);
	cl.u0 = ~0x12;
	eax >>= 0x1D;
	SCZO = cond(eax);
	&edx.u3->u0 = (bool) C.u0 + ((word32) edx + 535038013);
	SCZO = cond(edx);
	al = al + ah + C;
	--cl;
	ah &= dl;
	bh.u0 = 0xB0;
	v26 = (ah & 0x01 << 0x1D) != 0x00;
	ah = __ror<byte,byte>(ah, 0x1D);
	al = (byte) al + 1;
	C = cl != 0x00;
	cl = -cl;
	SZO = cond(cl);
	while (true)
	{
		eax = eax - 0x0CA422FF - C;
		ah >>= 0x1C;
		C = cl != 0x00;
		cl = -cl;
		SZO = cond(cl);
l004085C7:
		di += cx;
		bh <<= 0x01;
		ecx >>= 0x08;
		dh = (byte) dh.u0 + 1;
		edi.u0 = 2160300616;
		al >>= cl;
		SZP = cond(bl & 0x1D);
		O = false;
		C.u0 = false;
		cl <<= cl;
		ah &= bl;
		al <<= 0x19;
		SZP = cond(ch & al);
		edx |= 417119495;
		ebx <<= cl;
		SCZO = cond(ebx);
		v32 = (eax & 0x01 << 0x0C) != 0x00;
		eax = __rcr<word32,byte>(eax, 0x0C, C);
		bx |= si;
		SCZO = cond(ecx - 0x5454302E);
		if (Test(EQ,Z))
		{
			ebx.u0 = 2626611648;
			C.u0 = true;
			*edi = eax;
			&edi.u3->u0 = (word32) edi + 4;
l0040836E:
			if (Test(NE,Z))
				al.u0 = edx.u4->tFFFFFFFF.u0;
			else
				al.u0 = 0x2E;
			SCZO = cond(eax - 0xC000002E);
			if (Test(NE,Z))
			{
				edx -= 809991357;
				SCZO = cond(edx - ~0x444A6EC1);
				if (Test(NE,Z))
				{
					bl = bl + bh + C;
					dl &= ch;
					edx >>= 22;
					SZP = cond(ch & 0x26);
					O = false;
					C.u0 = false;
					esi.u0 = 3279789848;
					return;
				}
				v40 = *edi;
				*edi = eax;
				eax = *esi.u0;
				&esi.u3->u0 = (word16) esi.u0 + 4;
				al |= ecx.u4->bD2AA2FF6;
				SZ = cond(al);
				O = false;
				C.u0 = false;
				goto l0040839A;
			}
			v115 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rcl<byte,byte>(dh, cl, C);
			dl = dl ^ ~0x04;
			C = dx != 0x00;
			dx = -dx;
			SZO = cond(dx);
l00407F30:
			ecx = ecx - 0x0CCAA70B - C;
			SCZO = cond(ecx);
			do
			{
				esi >>= 0x1E;
				v57 = (edi & 0x01 << 0x20 - 0x03) != 0x00;
				edi = __rol<word32,byte>(edi, 0x03);
				edx |= eax;
				ch <<= cl;
				bh = al;
				eax <<= 0x05;
				edi <<= cl;
				v58 = (dl & 0x01 << 0x08 - cl) != 0x00;
				dl = __rol<byte,byte>(dl, cl);
				C = v58;
				ebx = ebx - (struct Eq_930 *) 2043094009 - C;
				edi <<= 0x1B;
				SCZO = cond(edi);
				ebx <<= 0x02;
				SCZO = cond(ebx);
l00407F53:
				SCZO = cond(ebx - (struct Eq_1057 *) 130169711);
				if (Test(NE,Z))
				{
					edx >>= 0x0F;
					dh -= 0x5D;
					SCZO = cond(dh);
					goto l00408444;
				}
				Mem0[esp + 87 + edx:word32] = esi;
			} while (Test(PO,P));
		}
		else
		{
			ax = cx;
			bl = (byte) bl + 1;
			ch -= 0x20;
			dl >>= 0x02;
			dh <<= cl;
			ch >>= 0x12;
			dh |= al;
			C.u0 = false;
			ecx = ecx - edi - C;
			SCZO = cond(edx - 0x57572F51);
			if (Test(EQ,Z))
			{
				eax = *(union Eq_3 *) ~0x1031670B;
				al = *((word16) ebx.u0 + (uint32) al);
				while (true)
				{
					cl = ~cl;
					v38 = (bl & 0x01 << 0x08 - 0x19) != 0x00;
					bl = __rol<byte,byte>(bl, 0x19);
					cx >>= cl;
					SCZ = cond(cx);
					v39 = (eax & 0x01 << 0x01) != 0x00;
					eax = __ror<word32,byte>(eax, 0x01);
					C = v39;
					if (Test(UGE,C))
						break;
l00408234:
					cl >>= cl;
					SCZO = cond(eax - 3746237565);
					if (Test(EQ,Z))
					{
						esp -= 2;
						*esp = cs;
						al = (byte) al + 28;
						SCZO = cond(al);
						v44 = *esi;
						*edi = v44;
						&esi.u3->u0 = (word32) esi + 4;
						&edi.u3->u0 = (word32) edi + 4;
					}
					else
					{
						cl <<= 0x03;
						SZP = cond(cl & ch);
						v59 = (ch & 0x01 << cl) != 0x00;
						ch = __ror<byte,byte>(ch, cl);
						C = v59;
						v60 = (cl & 0x01 << 0x05) != 0x00;
						cl = __rcr<byte,byte>(cl, 0x05, C);
						edi <<= 0x02;
						SCZO = cond(edi);
						v61 = (cl & 0x01 << 0x08 - 0x09) != 0x00;
						cl = __rcl<byte,byte>(cl, 0x09, C);
						di <<= cl;
						bl |= dh;
						C.u0 = false;
						ch = ch - dl - C;
						esi <<= 0x0D;
						SCZO = cond(esi);
						bl >>= cl;
						SCZ = cond(bl);
						bl <<= cl;
						&esi.u3->u0 = (word32) esi + 0x7CF7D41C;
						bl >>= cl;
						ch.u0 = 0x69;
						edi -= ecx;
						cl = (byte) cl + 1;
						ch <<= 0x1C;
						--ecx;
						SCZO = cond(esi - 0x8A83C63E);
						if (Test(EQ,Z))
						{
							al = al ^ ~0x51;
							SZ = cond(al);
							O = false;
							C.u0 = false;
							goto l00408729;
						}
l0040866B:
						edi |= 0x0ECF27CF;
						C.u0 = false;
						eax = gs;
						v49 = (ecx & 0x01 << 0x20 - 0x1A) != 0x00;
						ecx = __rcl<word32,byte>(ecx, 0x1A, C);
						bh = -bh;
						ebx = ebx ^ 4080428510;
						bl -= ~0x12;
						v50 = (cl & 0x01 << 0x08 - cl) != 0x00;
						cl = __rol<byte,byte>(cl, cl);
						--bh;
						cx >>= cl;
						esi |= ebx;
						cx >>= cl;
						&edi.u3->u0 = (word16) edi.u0 - 99409956;
						SCZO = cond(edi);
						v62 = (edi & 0x01 << 0x20 - 0x10) != 0x00;
						edi = __rol<word32,byte>(edi, 0x10);
						ch >>= 0x0F;
						ecx = ecx ^ edi;
						bl |= ~0x10;
						ebx <<= 0x19;
						SCZO = cond(ebx);
						v63 = (esi & 0x01 << 0x04) != 0x00;
						esi = __rcr<word32,byte>(esi, 0x04, C);
						ebx <<= 0x0A;
						SCZO = cond(ebx);
						ch = ch - al - C;
						ebx <<= 0x08;
						ch = cl;
						bl = (byte) bl + 0x00C1;
						bl |= bh;
						cl = (byte) cl + 1;
						SCZO = cond(esi - 590052992);
						if (Test(EQ,Z))
						{
							--edx;
							SZO = cond(edx);
							edx = *esp;
							&esp.u3->u0 = (word32) esp + 4;
							cl.u0 = 0x61;
							goto l00408071;
						}
						&edx.u3->u0 = (word32) edx + 1;
						esi &= 254182201;
						--ecx;
						ch >>= cl;
						bl = bl ^ cl;
						C.u0 = false;
						bh = bh - ah - C;
						v65 = (ebx & 0x01 << 0x14) != 0x00;
						ebx = __ror<word32,byte>(ebx, 0x14);
						SCZO = cond(ebx - (struct Eq_878 *) 0x944AD6A8);
						if (Test(EQ,Z))
						{
							v66 = (*((word16) ebx.u0 - 905587180) & 0x01 << 0x20 - 0x66) != 0x00;
							*((word16) ebx.u0 - 905587180) = __rol<word32,byte>(*((word16) ebx.u0 - 905587180), 0x66);
							C = v66;
							goto l004080C8;
						}
						bl = bl + ch + C;
						C = cl != 0x00;
						cl = -cl;
						v74 = (edi & 0x01 << 0x08) != 0x00;
						edi = __rcr<word32,byte>(edi, 0x08, C);
						edi &= 4247213494;
						bl |= cl;
						cx -= di;
						cx += di;
						SCZO = cond(cx);
					}
					v45 = (ch & 0x01 << 0x08 - cl) != 0x00;
					ch = __rcl<byte,byte>(ch, cl, C);
					SZP = cond(edi & 3351312429);
					edi <<= cl;
					bl >>= cl;
					bx >>= cl;
					SCZO = cond(bx);
					cl = cl - ~0x0E - C;
					edi >>= 0x14;
					SCZO = cond(edi);
					bl = bl + bh + C;
					SCZO = cond(bl);
					while (true)
					{
						C = di != 0x00;
						di = -di;
						v51 = (cl & 0x01 << 0x08 - 0x0E) != 0x00;
						cl = __rcl<byte,byte>(cl, 0x0E, C);
						ecx = ecx ^ 110557740;
						SCZO = cond(edx - 0x01329196);
						if (Test(NE,Z))
							break;
						eax &= 2569399942;
						SCZO = cond(edx - 752583700);
						if (Test(NE,Z))
						{
							eax >>= 0x01;
							bh -= bl;
							dl &= ch;
							--bh;
							dl >>= cl;
							dh = dl;
							di >>= cl;
							ebx <<= 0x0C;
							bx = -bx;
							ch <<= 0x1B;
							ch &= 0x66;
							SZ = cond(ch);
							O = false;
							C.u0 = false;
							return;
						}
						__out<byte>(dx, al);
						__out<word32>(0xB0, eax);
						al = al - ah - C;
						SCZO = cond(al);
						if (Test(PE,P))
						{
							__cli();
							&eax.u3->u0 = (bool) C.u0 + ((word16) eax.u0 - 847189366);
							*Top /= (real64) *ebx.u0;
							v54 = esi.u4->bFFFFFF85 << cl;
							esi.u4->bFFFFFF85 = v54;
							v55 = (*((word32) ecx + (edi * 0x08 - 374146431)) & 0x01 << 0x20 - 0x82) != 0x00;
							*((word32) ecx + (edi * 0x08 - 374146431)) = __rol<word32,byte>(*((word32) ecx + (edi * 0x08 - 374146431)), 0x82);
							al &= 0x90;
							SZ = cond(al);
							O = false;
							C.u0 = false;
							if (Test(NE,Z))
								goto l00408563;
							if (Test(NS,S))
							{
								eax = eax - ecx - C;
								SCZO = cond(eax);
								goto l00407F53;
							}
							else
							{
								v56 = edi;
								edi = eax;
								eax = v56;
								SCZO = cond(ecx.u4->dw0016 - edx);
								goto l00407F30;
							}
						}
						v98 = Mem0[eax + 0x00:byte] + al;
						*eax.u0 = v98;
						v99 = Mem0[eax + 0x00:byte] + al;
						*eax.u0 = v99;
						v100 = (byte) ah + (ebp.u4)->bFFFFFFC5;
						ebp.u4->bFFFFFFC5 = v100;
						esp -= 4;
						*esp = ebp;
						v101 = esi.u4->b0012 ^ al;
						esi.u4->b0012 = v101;
						SZ = cond(esi.u4->b0012);
						O = false;
						C.u0 = false;
					}
					bh -= dh;
					v104 = (cx & 0x01 << cl) != 0x00;
					cx = __ror<word16,byte>(cx, cl);
					C = v104;
					v105 = (ebx & 0x01 << 0x14) != 0x00;
					ebx = __rcr<word32,byte>(ebx, 0x14, C);
					C = v105;
					v106 = (si & 0x01 << cl) != 0x00;
					si = __rcr<word16,byte>(si, cl, C);
					cx += si;
					SCZO = cond(cx);
					ebx = ebx + 786685306 + C;
					SCZO = cond(ebx - (struct Eq_645 *) 431546617);
					if (Test(EQ,Z))
						;
				}
				ecx &= ebx;
				cl >>= cl;
				ebx &= edi;
				SZP = cond(bl & bh);
				O = false;
				C.u0 = false;
				bl = bl - 0x99 - C;
				cl += ch;
				SCZO = cond(cl);
				cl = ~cl;
				di = ax;
				cl = cl - 0x3A - C;
				edi >>= 11;
				SCZ = cond(edi);
				ch = ch + cl + C;
				--ebx;
				bl >>= cl;
				SCZO = cond(ebx - 3982086907);
				if (Test(NE,Z))
				{
					bh <<= 0x19;
					SCZO = cond(bh);
					v111 = (bl & 0x01 << 0x08 - 0x10) != 0x00;
					bl = __rcl<byte,byte>(bl, 0x10, C);
					ch = (byte) ch + 0x00C9;
					SCZO = cond(ch);
					cl = cl + ch + C;
					v112 = (ebx & 0x01 << cl) != 0x00;
					ebx = __ror<word32,byte>(ebx, cl);
					C = v112;
					cl = cl - bh - C;
					SCZO = cond(cl);
					v113 = (edi & 0x01 << 0x20 - cl) != 0x00;
					edi = __rcl<word32,byte>(edi, cl, C);
					esi -= 3432005001;
					SCZO = cond(esi);
					ch = ch + dl + C;
					v114 = (ch & 0x01 << cl) != 0x00;
					ch = __ror<byte,byte>(ch, cl);
					C = v114;
					--bh;
					SZO = cond(bh);
l00408729:
					fn00409579();
					ebx = edi *s 0x10;
					SCZO = cond(ebx);
					if (Test(SG,S))
					{
						&ecx.u3->u0 = (word32) ecx + 1;
						SZO = cond(ecx);
						do
							;
						while (Test(NS,S));
						if (Test(UGE,C))
						{
							dh = (bool) C.u0 + ((byte) dh + ((ecx.u4)->tF5795444).u0);
							ecx = ecx ^ 1338392853;
							v70 = *ecx << 0x01;
							*ecx = v70;
							SCZO = cond(v70);
							do
							{
								v71 = (ecx & 0x01 << 0x20 - 0x59) != 0x00;
								ecx = __rol<word32,byte>(ecx, 0x59);
								C = v71;
								&eax.u3->u0 = (bool) C.u0 + ((word32) eax - 1049298544);
								v72 = *ecx | dh;
								*ecx = v72;
								SZ = cond(*ecx);
								O = false;
								C.u0 = false;
							} while (Test(NS,S));
							edi = *esp;
							esp += 4;
							if (Test(UGE,C))
							{
								v73 = (ecx & 0x01 << 0x20 - 121) != 0x00;
								ecx = __rol<word32,byte>(ecx, 121);
								C.u0 = false;
							}
						}
						else
						{
							ecx = ecx ^ 0x7A998476;
							SZ = cond(ecx);
							O = false;
							C.u0 = false;
							return;
						}
					}
				}
				else
				{
					__lock();
					int3();
					al = __in<byte>(0x4F);
					goto l004084CA;
				}
			}
			eax -= 0x22FCC242;
			SCZO = cond(eax);
			ah = ah - 114 - C;
			edx = edx ^ eax;
			v116 = (edi & 0x01 << 0x20 - cl) != 0x00;
			edi = __rol<word32,byte>(edi, cl);
			--cl;
			bh = bh ^ bl;
			C.u0 = false;
			dl = dl - bh - C;
			cl = (byte) cl.u0 + 1;
			&edx.u3->u0 = (word32) edx + 1614027713;
			cl >>= 0x10;
			ah <<= 0x17;
			SCZO = cond(ah);
			v117 = (edx & 0x01 << 0x20 - 0x1E) != 0x00;
			edx = __rcl<word32,byte>(edx, 0x1E, C);
			C = v117;
		}
		edx |= 1786189857;
		SZP = cond(dx & si);
		ebx -= (struct Eq_940 *) 909979873;
		ah = ah ^ dh;
		SZ = cond(ah);
		O = false;
		C.u0 = false;
		bh.u0 = 0xD2;
		dl >>= 0x02;
		SCZO = cond(dl);
		v68 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rcl<byte,byte>(bl, cl, C);
		C = v68;
		&eax.u3->u0 = (bool) C.u0 + ((word32) eax + 0x45DBEF75);
		SZP = cond(bl & bh);
		cl |= bh;
		bl >>= cl;
		ebx &= 2103328400;
		C.u0 = false;
		cl = cl - 202 - C;
		SCZO = cond(cl);
		v69 = (eax & 0x01 << 0x12) != 0x00;
		eax = __rcr<word32,byte>(eax, 0x12, C);
		bl = (byte) bl + 0x007F;
		SCZO = cond(bl);
l004086D3:
		ebx += 220666860;
		bh |= 151;
		SZP = cond(ecx & 0x7944282E);
		C.u0 = false;
		bx = ~bx;
		&ecx.u3->u0 = (bool) C.u0 + ((word32) ecx - 1056666085);
		SCZO = cond(ecx);
		while (true)
		{
			cl <<= 0x1A;
			SCZO = cond(cl);
			bl = bl - 0x86 - C;
			dl >>= 0x0E;
			SZP = cond(ax & di);
			O = false;
			C.u0 = false;
			ecx <<= 0x1B;
			SCZO = cond(ecx);
			cl = cl - ah - C;
			v81 = (cl & 0x01 << 0x05) != 0x00;
			cl = __ror<byte,byte>(cl, 0x05);
			dx &= bx;
			ax |= cx;
			&eax.u3->u0 = (word16) eax.u0 - 0x3CBD8CAA;
			&di.u3->u0 = (word16) di + 1;
			bl = -bl;
			dh = dh ^ bl;
			C.u0 = false;
			v82 = (edx & 0x01 << 0x20 - cl) != 0x00;
			edx = __rcl<word32,byte>(edx, cl, C);
			ecx += edx;
			--cx;
			--bx;
			SCZO = cond(edi - 2903799580);
			if (Test(EQ,Z))
			{
				eax.u0 = ~0x02092DEF;
				esp = ebp;
				ebp = *esp;
				esp += 4;
l00408563:
				bh -= cl;
				di -= cx;
				cl <<= 0x07;
				SCZO = cond(cl);
				v96 = (bh & 0x01 << cl) != 0x00;
				bh = __rcr<byte,byte>(bh, cl, C);
				C = v96;
				v97 = (si & 0x01 << cl) != 0x00;
				si = __rcr<word16,byte>(si, cl, C);
				C = v97;
				bl = bl - dh - C;
				cl += dh;
				ch <<= 0x1A;
				SCZO = cond(ch);
				--bl;
				__syscall<byte>(0x2E);
				ch = ~ch;
				&bx.u3->u0 = (word16) bx + 1;
				SZO = cond(bx);
				ebx -= (struct Eq_1689 *) ~0x4990039D;
				SCZO = cond(ebx);
				bh = bh - 0x69 - C;
				cl = bl;
				cl >>= cl;
				SCZ = cond(cl);
				cl = cl - 0xC9 - C;
				bl <<= cl;
				bh <<= 0x10;
				ch -= dl;
				SCZO = cond(ch);
				ch = ch + bh + C;
				bl <<= cl;
				SCZO = cond(edx - ~0x00);
				goto l0040836E;
			}
			dl |= 0x06;
			ecx |= 1163087757;
			bl -= 0x89;
			bx &= ax;
			ebx <<= 0x17;
			v88 = (dl & 0x01 << 0x08 - cl) != 0x00;
			dl = __rol<byte,byte>(dl, cl);
			bh.u0 = 0x38;
			SZP = cond(cl & bl);
			dl <<= 0x10;
			SCZO = cond(dl);
			edx = edx + ecx + C;
			--cl;
			SCZO = cond(esi - 0xA3B5A263);
			if (Test(EQ,Z))
			{
				esp -= (struct Eq_1562 *) 2;
				*esp = es;
				C = __daa(al, &al);
				ds_edi.u1 = ebp.u4->t0069.u1;
				goto l004086D3;
			}
			SZP = cond(edi & ecx);
			C.u0 = false;
			v93 = (edi & 0x01 << 0x06) != 0x00;
			edi = __rcr<word32,byte>(edi, 0x06, C);
			edx <<= 0x1B;
			dh >>= 0x1C;
			ebx |= 0x3D722762;
			C.u0 = false;
			v94 = (ecx & 0x01 << 0x20 - cl) != 0x00;
			ecx = __rcl<word32,byte>(ecx, cl, C);
			cl &= 155;
			C.u0 = false;
			ch = (bool) C.u0 + ((byte) ch.u0 + 76);
			bx += ax;
			bh = (byte) bh.u0 + 1;
			SCZO = cond(ebx - (struct Eq_1558 *) 0x0F721D00);
			if (Test(EQ,Z))
			{
				fnE201A718();
				return;
			}
			edi &= esi;
			ebx = ebx ^ 3643226926;
			C.u0 = false;
			bl = bl + dl + C;
			bh |= ah;
			C.u0 = false;
			ch = ch + dl + C;
			edx = -edx;
			ch |= bl;
			C.u0 = false;
			dx = si;
			ebx = ebx + 4258230836 + C;
			ch = ch ^ 0xF0;
			dh >>= 0x14;
			SCZ = cond(dh);
			v95 = (ecx & 0x01 << 0x20 - 0x01) != 0x00;
			ecx = __rcl<word32,byte>(ecx, 0x01, C);
			C = ah != 0x00;
			ah = -ah;
			SZO = cond(ah);
			dh |= al;
			edi = edi ^ 0x5BF20F10;
			eax = fs->t0030;
			bl += bh;
			bh <<= cl;
			bh |= cl;
			edx <<= 0x09;
			SCZO = cond(ebx - (struct Eq_1685 *) 0x9093303C);
			if (Test(EQ,Z))
			{
				esp -= (struct Eq_1763 *) 4;
				*esp = ebx;
				edx = *((word32) edx + esi * 0x04) *s ~0x3E;
				SCZO = cond(edx);
				goto l00408180;
			}
			edi = ~edi;
			ecx -= 0x01C0D9A9;
			SCZO = cond(edx - 427331516);
			esi = esi - 1570105070 - C;
			dl = (byte) dl + 1;
			dl += ah;
			dh = dh ^ al;
			C.u0 = false;
			v103 = (ch & 0x01 << 0x08 - cl) != 0x00;
			ch = __rcl<byte,byte>(ch, cl, C);
			eax = *((word16) eax.u0 + 144);
			SCZO = cond(ebx - (struct Eq_1759 *) 994918658);
			if (Test(EQ,Z))
			{
				al = al - ~0x45 - C;
				SCZO = cond(al);
				&edx.u3->u0 = (word32) edx + 1;
				esp -= (struct Eq_1833 *) 4;
				*esp = esi;
				--edi;
				SZO = cond(edi);
				goto l004085C7;
			}
			SZP = cond(dh & ~0x06);
			v107 = (ch & 0x01 << cl) != 0x00;
			ch = __ror<byte,byte>(ch, cl);
			si <<= cl;
			bl <<= cl;
			SCZO = cond(bl);
			cx = cx - ax - C;
			esi = esi ^ eax;
			dh <<= 0x1C;
			SCZO = cond(dh);
			&edi.u3->u0 = (bool) C.u0 + ((word32) edi - 0x5B118C85);
			cl.u0 = 177;
			dh = dh ^ ~0x61;
			SZ = cond(dh);
			O = false;
			eax = *eax.u0;
			v108 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			C = v108;
l004080C8:
			SZP = cond(esi & edx);
			ch &= 0x02;
			dl.u0 = 0xA9;
			edx >>= cl;
			v67 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rol<byte,byte>(bh, cl);
			SCZO = cond(esi - 495123123);
			--dx;
			SZO = cond(dx);
			eax = *((word16) eax.u0 + 8);
			v75 = (dx & 0x01 << cl) != 0x00;
			dx = __ror<word16,byte>(dx, cl);
			ecx = ~ecx;
			cl <<= 0x1E;
			SCZO = cond(cl);
			&ecx.u3->u0 = (bool) C.u0 + ((word32) ecx - 0x56662DF5);
			SZP = cond(esi & 0x4CB1A00C);
			C.u0 = false;
			bl = bl - 0x3F - C;
			ch >>= 0x1B;
			v76 = (dl & 0x01 << 0x13) != 0x00;
			dl = __ror<byte,byte>(dl, 0x13);
			esi |= 0x18D1DCD1;
			SCZO = cond(edi - 2129465755);
			if (Test(NE,Z))
				break;
			__out<byte>(~0x13, al);
			SZP = cond(ecx & 0xEE800FEA);
			O = false;
			C.u0 = false;
			ebp = *esp;
			esp += 4;
l00408444:
			dl = (byte) dl.u0 + 1;
			esi -= 592395288;
			SCZO = cond(esi);
			cl = cl + ch + C;
			SCZO = cond(cl);
			v77 = (bx & 0x01 << 0x10 - cl) != 0x00;
			bx = __rcl<word16,byte>(bx, cl, C);
			C = v77;
			al = ch;
			v78 = (ecx & 0x01 << 0x10) != 0x00;
			ecx = __rcr<word32,byte>(ecx, 0x10, C);
			C = v78;
			eax.u0 = 0x03;
			edx = edx ^ 1354017130;
			&esi.u3->u0 = (word32) esi + 0x71586681;
			--si;
			dl |= bl;
			dh.u0 = 0x5F;
			dl.u0 = 0x35;
			dh &= cl;
			SZ = cond(dh);
			O = false;
			C.u0 = false;
			edi <<= cl;
			esi.u0 = 1999196535;
			v86 = (ch & 0x01 << 0x08 - 0x0F) != 0x00;
			ch = __rol<byte,byte>(ch, 0x0F);
			--dx;
			v87 = (ebx & 0x01 << 0x03) != 0x00;
			ebx = __ror<word32,byte>(ebx, 0x03);
			C = v87;
			cx = cx + di + C;
			SCZO = cond(cx);
			--cl;
			v91 = (ch & 0x01 << 0x08 - 0x07) != 0x00;
			ch = __rol<byte,byte>(ch, 0x07);
			v92 = (dh & 0x01 << cl) != 0x00;
			dh = __ror<byte,byte>(dh, cl);
			edi >>= 0x13;
			--bx;
			cl <<= 0x09;
			di -= bx;
			SCZO = cond(di);
l004084CA:
			bl -= ~0x09;
			esi >>= 0x17;
			SCZO = cond(esi);
			v41 = (ecx & 0x01 << 0x0C) != 0x00;
			ecx = __rcr<word32,byte>(ecx, 0x0C, C);
			dl = dl ^ ah;
			edx = edx ^ edx;
			SZ = cond(edx);
			O = false;
			C.u0 = false;
			v42 = (edi & 0x01 << cl) != 0x00;
			edi = __rcr<word32,byte>(edi, cl, C);
			C = v42;
			edi = esi;
			di = cx;
			v46 = (bh & 0x01 << 0x08 - 0x17) != 0x00;
			bh = __rcl<byte,byte>(bh, 0x17, C);
			bh += cl;
			bh = (byte) bh.u0 + 0x0077;
			cl <<= 0x1C;
			ecx >>= cl;
			ecx >>= cl;
			di = di ^ dx;
			bx = bx ^ cx;
			C.u0 = false;
			esi = esi + eax + C;
			SCZO = cond(ecx - 0xB8947898);
			if (Test(NE,Z))
			{
				gs = ax;
				esi = esi ^ 1790777459;
				edi.u0 = 2798470804;
				ch = ~ch;
				C = ch != 0x00;
				ch = -ch;
				v109 = (ch & 0x01 << 0x08 - 0x0C) != 0x00;
				ch = __rcl<byte,byte>(ch, 0x0C, C);
				C = v109;
				bh = bh + cl + C;
				SCZO = cond(bh);
				ebx = ebx - eax - C;
				esi &= edx;
				SZ = cond(esi);
				O = false;
				v110 = (ch & 0x01 << 0x08 - 0x02) != 0x00;
				ch = __rol<byte,byte>(ch, 0x02);
				C = v110;
				goto l00408234;
			}
			al = (byte) al + 76;
			SCZO = cond(al);
			if (Test(NS,S))
			{
				eax = *esp;
				&esp.u3->u0 = (word32) esp + 4;
				goto l0040866B;
			}
			al = (byte) al + 0x00C1;
			SCZO = cond(al);
		}
		v79 = (esi & 0x01 << 0x20 - 0x05) != 0x00;
		esi = __rcl<word32,byte>(esi, 0x05, C);
		eax &= ~0x11111111;
		cl <<= 0x1E;
		cl <<= cl;
		SCZO = cond(cl);
		si = si + di + C;
		edi = edi ^ ~0x25D5E950;
		edi = edi ^ 2510771892;
		bh &= bl;
		ch >>= 0x01;
		SCZO = cond(ecx - 1970844842);
		if (Test(EQ,Z))
		{
			al = __in<byte>(dx);
			&edi.u3->u0 = (word32) edi + 1;
			v80 = esp;
			esp -= (struct Eq_1402 *) 4;
			*esp = v80;
			&edi.u3->u0 = (word32) edi + 1;
			SZO = cond(edi);
			return;
		}
		v83 = (cx & 0x01 << 0x10 - cl) != 0x00;
		cx = __rcl<word16,byte>(cx, cl, C);
		eax -= ~0x11111111;
		SCZO = cond(eax);
		bh = bh - 0xAA - C;
		ecx -= 231399272;
		v84 = (si & 0x01 << 0x10 - cl) != 0x00;
		si = __rol<word16,byte>(si, cl);
		C = v84;
		v85 = (ecx & 0x01 << 0x20 - 0x17) != 0x00;
		ecx = __rcl<word32,byte>(ecx, 0x17, C);
		ebx >>= 0x11;
		&edi.u3->u0 = (word32) edi + 1249841246;
		esi = -esi;
		dx += bx;
		SCZO = cond(edi - 4268843940);
		if (Test(NE,Z))
		{
l0040839A:
			*edx = esp;
			fn66D0_2B66();
			return;
		}
		ecx = ecx + Mem0[esi + -7:word32] + C;
		SCZO = cond(ecx);
	}
}

// 00409259: define fn00409259
// Called from:
//      fn00409275
define fn00409259
{
	byte bl;
	byte ah;
	bool C;
	Top_3 = 0;
	bl_7 = bl + ah + (byte) C;
	SCZO_8 = cond(bl_7);
	C_9 = SLICE(SCZO_8, bool, 1);
	O_10 = SLICE(SCZO_8, bool, 4);
	S_11 = (bool) SCZO_8;
	Z_12 = SLICE(SCZO_8, bool, 2);
}

// 00409275: define fn00409275
// Called from:
//      fn00409746
define fn00409275
{
	word32 edx;
	word32 ebx;
	byte cl;
	bool C;
	byte ah;
	dl = (byte) edx;
	byte al;
	word16 eax_16_16;
	Top_3 = 0;
	v5_6 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx_8 = __rcl<word32,byte>(ebx, cl, C);
	bl_12 = (byte) ebx_8;
	ebx_24_8_22 = SLICE(ebx_8, word24, 8);
	ah_11 = (bool) v5_6 + (ah + 0x15);
	bl_14 = bl_12 ^ dl;
	eax_18 = SEQ(eax_16_16, ah_11, al);
	edx_20 = edx;
	eax_21 = eax_18 & edx_20;
	ebx_23 = SEQ(ebx_24_8_22, bl_14 & 122);
	ah_27 = SLICE(eax_21, byte, 8);
	al_35 = (byte) eax_21;
	eax_16_16_46 = SLICE(eax_21, word16, 16);
	ebx_24 = ebx_23 >> cl;
	bh_28 = SLICE(ebx_24, byte, 8);
	bl_40 = (byte) ebx_24;
	ebx_24_8_48 = SLICE(ebx_24, word24, 8);
	ah_29 = ah_27 ^ bh_28;
	v19_32 = (cl & 0x01 << cl) != 0x00;
	cl_33 = __ror<byte,byte>(cl, cl);
	al_37 = __rcl<byte,byte>(al_35, cl_33, v19_32);
	edx_39 = 0x0E44DFB4;
	fn00409259();
	eax_47 = SEQ(eax_16_16_46, ah_29, al_37);
	ebx_49 = SEQ(ebx_24_8_48, bl_41);
}

// 00409297: define fn00409297
// Called from:
//      fn004092BE
define fn00409297
{
	esp = fp;
	Top = 0;
	bx += dx;
	SCZO = cond(bx);
	edi = edi - 1745873461 - C;
	dl <<= cl;
	dh >>= cl;
	SCZ = cond(dh);
	v13 = (esi & 0x01 << 0x20 - 0x10) != 0x00;
	esi = __rcl<word32,byte>(esi, 0x10, C);
	++dx;
	SCZO = cond(ecx - 370061850);
	if (Test(NE,Z))
		fn0040974C();
	else
	{
		ecx = 0x06860857;
		SCZDOP.u1 = esp->u1;
		esp = (union Eq_2064 *) ((char *) esp + 4);
		__cli();
		fn004092BE();
	}
}

// 004092BE: define fn004092BE
// Called from:
//      fn00409297
//      fn00409579
//      fn004095A3
define fn004092BE
{
	esp = fp;
	Top = 0;
	*ecx = dh;
	di >>= cl;
	SCZO = cond(di);
	bl = bl - 0x6A - C;
	SZP = cond(bl & dh);
	di = -di;
	ebx &= esi;
	di -= ax;
	bl >>= 0x1A;
	SCZO = cond(edi - 4196195017);
	if (Test(NE,Z))
	{
		bh += ch;
		ebx -= 82540654;
		bl += 252;
		ebx += 1428467086;
		v23 = (esi & 0x01 << 0x09) != 0x00;
		esi = __ror<word32,byte>(esi, 0x09);
		esi -= edi;
		SZP = cond(edi & 0x0AC6B6BF);
		++ecx;
		&esi.u3->u0 = (word32) esi - 706377171;
		SCZO = cond(edi - 925885650);
		if (Test(NE,Z))
			fn00409399();
		else
		{
			v24 = edi;
			edi = eax;
			eax = v24;
			fn5724_B31C();
			fn0040952B();
		}
	}
	else
		ebp->ptr66FC3D30();
}

// 00409337: define fn00409337
// Called from:
//      fn00409579
define fn00409337
{
	esp = fp;
	Top = 0;
	bx <<= cl;
	SCZO = cond(bx);
	++ah;
	SZO = cond(ah);
	esp -= 4;
	esp->ptr0000 = ecx;
	v10 = esp;
	esp -= 4;
	esp->ptr0000 = v10;
	esp -= 4;
	esp->ptr0000 = (struct Eq_2151 *) ~0x40;
	ecx = esp->ptr0000;
	esp = (struct Eq_2151 *) ((char *) &esp->ptr0000 + 4);
	ecx = ~ecx;
	esp -= 4;
	esp->ptr0000 = ecx;
	fn0040948D();
	SCZO = cond(ecx - ~0x14F64299);
	if (Test(NE,Z))
		fn0040948D();
	else
		fn00409356();
}

// 00409356: define fn00409356
// Called from:
//      fn00409337
//      fn00409754
define fn00409356
{
	word32 eax;
	ptr32 fp;
	word32 ecx;
	byte bh;
	byte bl;
	ah = SLICE(eax, byte, 8);
	word32 esi;
	word32 edx;
	word16 ebx_16_16;
	<unknown> Mem0;
	edi_5 = ecx *s 282050902;
	bl_11 = bl ^ ah;
	SCZO_13 = cond(esi - 2480606063);
	eax_22 = eax;
	C_24.u0 = SLICE(SCZO_13, bool, 1);
	if (esi != 2480606063)
	{
		fn00409754();
		C_86 = SLICE(SCZOP_19, bool, 1);
		O_100 = SLICE(SCZOP_19, bool, 4);
		P_102 = SLICE(SCZOP_19, bool, 5);
		S_106 = (bool) SCZOP_19;
		Z_110 = SLICE(SCZOP_19, bool, 2);
		al_82 = (byte) eax_18;
		eax_16_16_83 = SLICE(eax_18, word16, 16);
		ebx_89 = SEQ(ebx_16_16, bh, bl_11);
	}
	else
	{
		eax_25 = __rcl<word32,byte>(eax_22, 0x03, C_24);
		ah_28 = SLICE(eax_25, byte, 8);
		al_30 = (byte) eax_25;
		eax_16_16_44 = SLICE(eax_25, word16, 16);
		ecx_27 = (ecx ^ 2995925517) + 0xC462D999;
		cl_33 = (byte) ecx_27;
		ah_29 = -ah_28;
		SZP_34 = cond(cl_33 & bh);
		P_104 = SLICE(SZP_34, bool, 5);
		ecx_37 = __rcr<word32,byte>(ecx_27, cl_33, false);
		cl_43 = (byte) ecx_37;
		ecx_24_8_91 = SLICE(ecx_37, word24, 8);
		ebx_42 = SEQ(ebx_16_16, bh, bl_11);
		eax_79 = SEQ(eax_16_16_44, ah_29 | ~0x08, al_30 >> 0x14);
		if (ecx_37 != 0x0C77F50C)
		{
			fn00409275();
			ecx_92 = SEQ(ecx_24_8_91, cl_45);
		}
		else
		{
			esi_55 = esi + 4;
			edi_56 = ecx *s 282050902 + 4;
			while (true)
			{
				eax_64 = ϕ(eax_79, eax_81);
				eax_24_8_80 = SLICE(eax_64, word24, 8);
				esi_59 = ϕ(esi_55, esi_77);
				ecx_57 = ϕ(ecx_37, ecx_78);
				cl_58 = (byte) ecx_57;
				ch_63 = SLICE(ecx_57, byte, 8);
				ecx_16_16_65 = SLICE(ecx_57, word16, 16);
				if (ecx_57 == 0x00)
					break;
				al_76 = *esi_59;
				esi_77 = esi_59 + 1;
				ecx_78 = ecx_57 - 0x01;
				eax_81 = SEQ(eax_24_8_80, al_76);
			}
			fn00409399();
		}
	}
}

// 00409399: define fn00409399
// Called from:
//      fn004092BE
//      fn00409746
define fn00409399
{
	byte cl;
	word32 esi;
	byte bh;
	word16 ebx_16_16;
	word32 edi;
	byte ch;
	word32 eax;
	word16 ecx_16_16;
	Top_3 = 0;
	si_10 = (word16) esi | ~0x7044;
	bx_12 = SEQ(bh, 0x89);
	esi_16_16_40 = SLICE(esi, word16, 16) | 0x7B71;
	si_13 = si_10 ^ bx_12;
	bh_14 = bh << cl;
	bx_19 = si_13 + 0x9389 + (word16) (bh_14 < 0x00);
	ebx_21 = SEQ(ebx_16_16, bx_19);
	ebx_23 = ebx_21 & edi;
	bh_27 = SLICE(ebx_23, byte, 8);
	ebx_16_16_43 = SLICE(ebx_23, word16, 16);
	bh_28 = bh_27 << cl;
	bh_30 = bh_28 ^ ch;
	esi_41 = SEQ(esi_16_16_40, si_13);
	ebx_24_8_44 = SEQ(ebx_16_16_43, bh_30);
	ecx_24_8_47 = SEQ(ecx_16_16, ch);
	eax_35 = eax - 0x01;
	ah_38 = SLICE(eax - 0x01, byte, 8);
	edi_37 = 1672866290 >> cl;
	esi_42 = esi_41 ^ 0x291585A5;
	ebx_45 = SEQ(ebx_24_8_44, ah_38);
	ecx_48 = SEQ(ecx_24_8_47, cl);
	ebx_49 = ebx_45 ^ ecx_48;
	bl_50 = (byte) ebx_49;
	bh_53 = SLICE(ebx_49, byte, 8);
	ebx_16_16_59 = SLICE(ebx_49, word16, 16);
	bl_51 = bl_50 >> cl;
	SCZ_52 = cond(bl_51);
	C_55.u0 = SLICE(SCZ_52, bool, 1);
	bh_56 = __rcl<byte,byte>(bh_53, cl, C_55);
	edi_58 = __ror<word32,byte>(edi_37, 0x12);
	ebx_60 = SEQ(ebx_16_16_59, bh_56, bl_51);
	ebx_61 = ebx_60 >> cl;
	bh_63 = SLICE(ebx_61, byte, 8);
	bl_68 = (byte) ebx_61;
	ebx_16_16_69 = SLICE(ebx_61, word16, 16);
	SZ_65 = cond(bh_63 & 0x2B);
	S_71 = (bool) SZ_65;
	Z_72 = SLICE(SZ_65, bool, 2);
	O_66 = false;
	C_67 = false;
	ebx_70 = SEQ(ebx_16_16_69, bh_63 & 0x2B, bl_68);
	fn0040952B();
}

// 0040948D: define fn0040948D
// Called from:
//      fn00409337
//      fn00409746
define fn0040948D
{
	esp = fp;
	Top = 0;
	ecx = (struct Eq_2490 *) *esp;
	esp = (struct Eq_2490 **) ((char *) esp + 4);
	eax = (struct Eq_2490 *) 0x01;
	while (true)
	{
		eax |= eax;
		SZ = cond(eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
			break;
		--ecx;
		SCZO = cond(ecx - 1700709453);
		if (Test(EQ,Z))
		{
			ah = 0x6D;
			v16 = ebx->b0013 & bl;
			ebx->b0013 = v16;
			SZ = cond(ebx->b0013);
			O = false;
			v18 = (cl & 0x01 << 0x08 - cl) != 0x00;
			cl = __rol<byte,byte>(cl, cl);
			C = v18;
			fnE20224BF();
			return;
		}
		ecx >>= 0x0F;
		SCZO = cond(ecx);
		ecx <<= 0x0F;
		SCZO = cond(ecx);
		v19 = ecx->ptr0000;
		esp -= 4;
		*esp = (struct Eq_2490 **) v19;
		eax = (struct Eq_2490 *) *esp;
		esp = (struct Eq_2490 **) ((char *) esp + 4);
		edx = (word32) al;
		ebx = (word32) ah;
		eax >>= 0x10;
		eax += edx / 84;
		SCZO = cond(eax);
		eax += ebx;
		eax = eax ^ ~0x0137;
		SZ = cond(eax);
		O = false;
		C = false;
		eax = ~eax;
	}
	eax = ecx;
	eax += eax->dw003C / 84;
	SCZO = cond(eax);
	v11 = eax->ptr0050;
	esp -= 4;
	*esp = (struct Eq_2490 **) v11;
	fn00409719();
}

// 0040952B: define fn0040952B
// Called from:
//      fn004092BE
//      fn00409719
//      fn00409746
define fn0040952B
{
	esp = fp;
	Top = 0;
	al = -al;
	&ebx.u3->u0 = (word32) ebx + 1;
	SZP = cond(ebx & 3127372635);
	C.u0 = false;
	v13 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	di |= dx;
	v18 = (eax & 0x01 << 0x20 - 0x1B) != 0x00;
	eax = __rol<word32,byte>(eax, 0x1B);
	v19 = (ebx & 0x01 << 0x1A) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x1A);
	--al;
	SCZO = cond(ecx - 477749848);
	if (Test(NE,Z))
	{
		v32 = (al & 0x01 << 0x11) != 0x00;
		al = __ror<byte,byte>(al, 0x11);
		ecx -= ~0x0A85;
		bx = bx ^ di;
		v35 = (edx & 0x01 << 0x20 - 0x1D) != 0x00;
		edx = __rol<word32,byte>(edx, 0x1D);
		di >>= cl;
		SCZO = cond(di);
		v37 = (ah & 0x01 << 0x08 - cl) != 0x00;
		ah = __rcl<byte,byte>(ah, cl, C);
		bh >>= 11;
		SZP = cond(ebx & 678865072);
		++edi;
		dh <<= cl;
		SCZO = cond(dh);
		edx |= esi;
		v39 = (ebx & 0x01 << cl) != 0x00;
		ebx = __ror<word32,byte>(ebx, cl);
		C = v39;
		dl = dl - bl - C;
		SCZO = cond(dl);
		esp -= 4;
		esp->u0 = (word32) ecx;
		v40 = (bh & 0x01 << 0x06) != 0x00;
		bh = __rcr<byte,byte>(bh, 0x06, C);
		SCZO = cond(eax - 0x0CF472B2);
		if (Test(EQ,Z))
		{
			esi -= *esi;
			SCZO = cond(esi);
			__syscall<byte>(0x68);
			ss.u1 = esp->u1;
			esp = (union Eq_2648 *) ((char *) esp + 2);
		}
		dl |= al;
		dl |= dh;
		si = dx;
		al >>= 0x07;
		esi -= 0x131C1907;
		++bx;
		bl >>= 0x0E;
		dh <<= cl;
		SCZO = cond(ebx - 3639536566);
		if (Test(NE,Z))
		{
			v63 = (al & 0x01 << 0x08 - cl) != 0x00;
			al = __rcl<byte,byte>(al, cl, C);
			ecx.u0 = (word32) ecx.u0 - 0x0A86;
			SCZO = cond(ecx);
			v64 = (ebx & 0x01 << 0x20 - 0x1B) != 0x00;
			ebx = __rcl<word32,byte>(ebx, 0x1B, C);
			ah = ah ^ 77;
			dx <<= cl;
			dl = al;
			dh = bl;
			SZP = cond(bl & dl);
			SCZO = cond(edi - 0x77802603);
			SCZO = cond(ebx - 3158733330);
			SZP = cond(esi & 704676466);
			O = false;
			C.u0 = false;
			fn00409746();
		}
		else
		{
			ax = __aam(al);
			v43 = esi;
			esi = eax;
			eax = v43;
			edx = edx + Mem0[esi + 0x808D516A:word32] + C;
			SCZO = cond(edx);
			fn00409719();
		}
	}
	else
	{
		C = __daa(al, &al);
		&esi.u3->u0 = (word32) esi + 1;
		__out<byte>(dx, al);
		ebx -= 0x1D6844DD;
		--bh;
		bh <<= cl;
		SCZO = cond(bh);
		v26 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rcl<byte,byte>(bl, cl, C);
		C = v26;
		v27 = (bl & 0x01 << 0x11) != 0x00;
		bl = __rcr<byte,byte>(bl, 0x11, C);
		bh &= dl;
		si = -si;
		SCZO = cond(ecx - 2710142575);
		if (Test(NE,Z))
			fn004095A3();
		else
		{
			eax = __in<word32>(dx);
			edi += 4;
			esp -= 2;
			esp->u1 = (struct Eq_3921 *) ds;
		}
	}
}

// 00409579: define fn00409579
// Called from:
//      Win32CrtStartup
define fn00409579
{
	esp = fp;
	Top = 0;
	bl = -bl;
	dl >>= 0x10;
	v9 = (edx & 0x01 << 0x20 - 0x12) != 0x00;
	edx = __rol<word32,byte>(edx, 0x12);
	edi >>= cl;
	v13 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	C = v13;
	v15 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rcl<byte,byte>(ch, cl, C);
	ah <<= 0x01;
	al = (byte) cl + al;
	ax |= di;
	SCZO = cond(esi - 0xE403AE1F);
	if (Test(NE,Z))
		fn00409337();
	else
	{
		ebp = &(C.u5 + (ebp + edi) / 4)->u0;
		SCZO = cond(ebp);
		bh.u0 = 0x61;
		C = __das(al, &al);
		fn004095A3();
	}
}

// 004095A3: define fn004095A3
// Called from:
//      fn004092BE
//      fn00409579
define fn004095A3
{
	esp = fp;
	Top = 0;
	bh <<= 0x02;
	bl <<= cl;
	ebx -= 2020754579;
	edi += 1018448941;
	bh <<= cl;
	esi = esi ^ 2304247303;
	bl = ~bl;
	bh <<= 0x0E;
	SCZO = cond(bh);
	fn004092BE();
}

// 00409719: define fn00409719
// Called from:
//      fn0040948D
//      fn0040952B
define fn00409719
{
	esp = fp;
	Top = 0;
	esp -= 4;
	*esp = ecx;
	eax.u1 = (word32) eax + 0x0080;
	eax = *eax.u1;
	eax.u1 = (char *) eax.u1 + ecx;
	SCZO = cond(eax);
	eax.u1 = eax.u2->t0010.u1;
	eax.u1 = (char *) eax.u1 + ecx;
	(*eax.u1)();
	ecx = *esp;
	++esp;
	ecx = *esp;
	++esp;
	esi = esi - 0x510CE22C - C;
	SCZO = cond(ebx - 3855991464);
	if (Test(NE,Z))
		fn0040952B();
	else
		fn00409746();
}

// 00409746: define fn00409746
// Called from:
//      fn0040952B
//      fn00409719
define fn00409746
{
	esp = fp;
	Top = 0;
	fn0040952B();
}

// 0040974C: define fn0040974C
// Called from:
//      fn00409297
//      fn00409746
define fn0040974C
{
	ptr32 fp;
	byte bh;
	bool C;
	byte bl;
	word16 di;
	word16 ebx_16_16;
	word32 edx;
	dl_42 = (byte) edx;
	dh_44 = SLICE(edx, byte, 8);
	edx_16_16_48 = SLICE(edx, word16, 16);
	word16 edi_16_16;
	byte ah;
	word32 ecx;
	word32 esi;
	byte al;
	word16 eax_16_16;
	esp_25 = fp;
	Top_26 = 0;
	v4_28 = false;
	bh_30 = __rcr<byte,byte>(bh, 11, C);
	bx_32 = SEQ(bh_30, bl);
	SZP_34 = cond(bx_32 & di);
	ebx_36 = SEQ(ebx_16_16, bh_30, bl);
	ebx_38 = ebx_36 + edx;
	SCZO_39 = cond(ebx_38);
	edi_41 = SEQ(edi_16_16, di);
	fn00409754();
	esp_57 = fp;
}

// 00409754: define fn00409754
// Called from:
//      fn00409356
//      fn00409746
//      fn0040974C
define fn00409754
{
	word32 edi;
	ptr32 fp;
	byte dl;
	byte ah;
	di = (word16) edi;
	byte dh;
	word32 ecx;
	cl_53 = (byte) ecx;
	ch_99 = SLICE(ecx, byte, 8);
	ecx_16_16_279 = SLICE(ecx, word16, 16);
	<unknown> Mem0;
	word32 esi;
	byte al;
	word16 edx_16_16;
	word16 eax_16_16;
	bool D;
	word32 ebp;
	bool P;
	esp_2 = fp;
	dl_6 = dl - ah;
	dx_14 = SEQ(dh, dl_6);
	dx_15 = dx_14 | di;
	dl_21 = (byte) dx_15;
	edi_26 = edi;
	eax_24_8_105 = SEQ(eax_16_16, ah);
	dh_31 = ecx->b0000;
	edi_45 = edi_26 << 0x12 ^ 0x6CB12931;
	edi_48 = __rcr<word32,byte>(edi_45, 11, false);
	di_68 = (word16) edi_48 | 0x4741;
	edi_16_16_84 = SLICE(edi_48, word16, 16) | ~0x449A;
	esi_54 = esi >> 0x03 >> cl_53;
	di_69 = -di_68;
	bl_90 = 0x1D;
	ebx_16_16_101 = ~0x7449;
	bh_74 = __rol<byte,byte>(0xA9, cl_53);
	bh_75 = bh_74 << cl_53;
	edi_85 = SEQ(edi_16_16_84, di_69);
	dx_88 = SEQ(dh_31 - 0x34, dl_21 + 0x01);
	edx_93 = SEQ(edx_16_16, dh_31 - 0x34, dl_21 + 0x01);
	eax_106 = SEQ(eax_24_8_105, al);
	dl_314 = dl_21 + 0x01;
	if (ecx != (struct Eq_3177 *) 0x9BE3E380)
	{
		SCZO_80 = cond(esi_54 >> 0x19);
		C_82.u0 = SLICE(SCZO_80, bool, 1);
		bh_83 = __rcr<byte,byte>(bh_75 ^ 0x22, cl_53, C_82);
		esi_86 = (esi_54 >> 0x19) - edi_85;
		si_87 = (word16) esi_86;
		esi_16_16_320 = SLICE(esi_86, word16, 16);
		si_89 = si_87 + dx_88;
		ebx_102 = SEQ(~0x7449, bh_83, 0x1E);
		if (edx_93 != (byte *) 3797481767)
		{
			C_96 = si_89 != 0x00;
			si_97 = -si_89;
			SZO_98 = cond(si_97);
			esi_321 = SEQ(esi_16_16_320, si_97);
			O_327 = SLICE(SZO_98, bool, 4);
			S_340 = (bool) SZO_98;
			Z_347 = SLICE(SZO_98, bool, 2);
		}
		else
		{
			ebx_16_16_253 = SLICE(ebx_102 - 0x01, word16, 16);
			bl_277 = 0x1D;
			bh_278 = SLICE(ebx_102 - 0x01, byte, 8);
			esp_107 = fp - (eax_106->aD8122BE7)[eax_106];
			ecx_24_8_280 = SLICE(ecx, word24, 8);
			ecx_16_16_308 = SLICE(ecx_24_8_280, word16, 8);
			while (true)
			{
				D_292 = ϕ(D_209, D);
				ch_263 = (byte) ecx_24_8_280;
				dh_157 = dh_31 - 0x34;
				edi_116 = ϕ(edi_117, edi_85);
				bh_113 = ϕ(bh_115, bh_278);
				bl_111 = ϕ(bl_211, bl_277);
				ax_144 = (word16) eax_106;
				eax_16_16_159 = eax_16_16;
				esi_110 = eax_106;
				bl_112 = -bl_111;
				bh_115 = bh_113 >> cl_53;
				edi_117 = edi_116 >> 0x08;
				bl_120 = (bl_112 | 0x60) + al;
				if (edx_93 != (byte *) 1303610808)
					break;
				D_209 = true;
				if (edx_93 < (byte *) 1303610808)
				{
					ax_242 = SEQ(ah, al & 0x12);
					goto l004096A8;
				}
				bl_211 = bl_120 + al + (byte) (edx_93 < (byte *) 1303610808);
			}
			esi_128 = eax_106 - 1814361233;
			edi_129 = edi_117 << cl_53;
			bh_bh_281 = SEQ(bh_131, 0x07);
			bh_bh_282 = bh_bh_281 + SEQ(ah, 117);
			bh_131 = (byte) bh_bh_282;
			bh_135 = SLICE(bh_bh_282, byte, 8);
			ebx_138 = SEQ(~0x11EA, bh_135, 131);
			bx_143 = (word16) ebx_138 | 0x484C;
			SZP_141 = cond(ah & ~0x30);
			P_333 = SLICE(SZP_141, bool, 5);
			edi_142 = edi_129 >> 0x0A;
			bx_145 = bx_143 | ax_144;
			bl_147 = (byte) bx_145;
			bh_160 = SLICE(bx_145, byte, 8);
			bl_149 = bl_147 + (dl_21 + 0x01);
			bl_151 = __rol<byte,byte>(bl_149, 0x08);
			ebx_177 = SEQ(~0x4A, bh_160, bl_151);
			ebx_24_8_304 = SEQ(~0x4A, bh_160);
			if (edx_93 != (byte *) 573407036)
			{
				edi_155 = __ror<word32,byte>(edi_129 >> 0x0A, 0x10);
				fn00409356();
				esp_168 = fp;
				C_288 = SLICE(SCZDOP_173, bool, 1);
				D_294 = SLICE(SCZDOP_173, bool, 3);
				O_329 = SLICE(SCZDOP_173, bool, 4);
				P_335 = SLICE(SCZDOP_173, bool, 5);
				S_342 = (bool) SCZDOP_173;
				Z_349 = SLICE(SCZDOP_173, bool, 2);
				ebx_305 = SEQ(ebx_24_8_304, bl_151);
			}
			else
			{
				esp_107->ptrFFFFFFFC = esp_107;
				ebp_178 = *ebx_177 *s 0x66;
				ebx_179 = ebx_177 << cl_53;
				bl_198 = (byte) ebx_179;
				ebx_16_16_200 = SLICE(ebx_179, word16, 16);
				esp_107->ptrFFFFFFF8 = ecx;
				esp_107->ptrFFFFFFF4 = esp_107 - 8;
				esp_107->ptrFFFFFFF0 = (struct Eq_3177 *) ~0x40;
				ecx_191 = esp_107->ptrFFFFFFF0;
				ecx_193 = ~ecx_191;
				esp_194 = fp;
				esp_107->ptrFFFFFFF0 = ecx_193;
				fn0040948D();
				SCZO_196 = cond(ecx_193 - (struct Eq_3177 *) ~0x14F64299);
				Z_197 = SLICE(SCZO_196, bool, 2);
				C_286 = SLICE(SCZO_196, bool, 1);
				eax_296 = SEQ(eax_16_16, ah + 0x01, al);
				O_326 = SLICE(SCZO_196, bool, 4);
				S_339 = (bool) SCZO_196;
				if (ecx_193 != (struct Eq_3177 *) ~0x14F64299)
					fn0040948D();
				else
				{
					fn00409356();
					esp_203 = fp;
					C_287 = SLICE(SCZDOP_208, bool, 1);
					D_293 = SLICE(SCZDOP_208, bool, 3);
					O_328 = SLICE(SCZDOP_208, bool, 4);
					P_334 = SLICE(SCZDOP_208, bool, 5);
					S_341 = (bool) SCZDOP_208;
					Z_348 = SLICE(SCZDOP_208, bool, 2);
				}
			}
		}
	}
	else
	{
		esi_222 = (struct Eq_3177 *) 0x7212FB82;
		esp_224 = 2188560119;
		v30_225 = *edx_93 + ch_99;
		*edx_93 = v30_225;
		eax_229 = (struct Eq_3177 *) 1371224323;
		ax_243 = 0x3903;
		eax_16_16_266 = 0x51BB;
		bh_231 = __rol<byte,byte>(bh_75 << 0x02, 0x15);
		dl_232 = dl_21 + 0x01 & 0x0A;
		edi_233 = edi_85 - 0x9C1C160F;
		SCZO_234 = cond(edi_85 - 0x9C1C160F);
		C_236.u0 = SLICE(SCZO_234, bool, 1);
		dh_237 = __rcl<byte,byte>(dh_31 - 0x34, cl_53, C_236);
		dh_238 = (byte) dh_237 + 1;
		SCZO_239 = cond(edi_85 - 0x9C1C160F - 0x1A0F2CF7);
		Z_240 = SLICE(SCZO_239, bool, 2);
		C_285 = SLICE(SCZO_239, bool, 1);
		ebx_302 = SEQ(~0x7449, bh_231, 0x1D);
		edx_312 = SEQ(edx_16_16, (byte) dh_237 + 1, dl_232);
		O_325 = SLICE(SCZO_239, bool, 4);
		S_337 = (bool) SCZO_239;
		if (edi_85 != 0xB62B4306)
		{
l004096A8:
			esp_323 = fp;
			esi_319 = ϕ(esi_110, esi_222);
			dl_313 = ϕ(dl_314, dl_232);
			ecx_16_16_307 = ϕ(ecx_16_16_308, ecx_16_16_279);
			D_291 = ϕ(D_209, D);
			eax_16_16_265 = ϕ(eax_16_16_159, eax_16_16_266);
			ch_262 = ϕ(ch_263, ch_99);
			dh_261 = ϕ(dh_157, dh_238);
			ebx_16_16_251 = ϕ(ebx_16_16_253, ebx_16_16_101);
			bl_250 = ϕ(bl_120, bl_90);
			bh_247 = ϕ(bh_115, bh_231);
			edi_245 = ϕ(edi_117, edi_233);
			ax_241 = ϕ(ax_242, ax_243);
			ax_244 = __aad(ax_241);
			edi_246 = -edi_245;
			bh_249 = __ror<byte,byte>(bh_247, 0x07);
			ebx_254 = SEQ(ebx_16_16_251, bh_249, bl_250);
			SZP_255 = cond(ebx_254 & 3613959931);
			P_332 = SLICE(SZP_255, bool, 5);
			v36_258 = (bh_249 & 0x01 << 0x08 - cl_53) != 0x00;
			bh_259 = __rcl<byte,byte>(bh_249, cl_53, false);
			dh_264 = dh_261 - ch_262 - v36_258;
			eax_267 = SEQ(eax_16_16_265, ax_244);
			eax_268 = eax_267 ^ 1371222571;
			bh_269 = bh_259 >> cl_53;
			bx_270 = SEQ(bh_269, bl_250);
			cx_271 = SEQ(ch_262, cl_53);
			bx_272 = bx_270 & cx_271;
			SZ_273 = cond(bx_272);
			S_338 = (bool) SZ_273;
			Z_346 = SLICE(SZ_273, bool, 2);
			O_274 = false;
			C_275 = false;
			ebx_303 = SEQ(ebx_16_16_251, bx_272);
			ecx_309 = SEQ(ecx_16_16_307, ch_262, cl_53);
			edx_317 = SEQ(edx_16_16, dh_264, dl_313);
			fn00409297();
		}
		else
			esi_276 = ecx;
	}
}

