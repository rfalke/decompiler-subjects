// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
fn00401000_entry:
l00401000:
fn00401000_exit:
}

// 004010FC: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_38;
	word32 ebp_39;
	word32 edx_40;
	byte SZO_41;
	byte C_42;
	byte SCZO_43;
	word32 esi_44;
	word32 edi_45;
	word32 ecx_46;
	word32 ebx_47;
	word32 eax_48;
	byte Z_49;
	byte bl_50;
	byte al_51;
	byte cl_52;
	NTDLL.dll!NtSetSystemInformation();
	if (eax_48 != 0xC0000003)
	{
		word32 esp_521;
		word32 ebp_522;
		word32 edx_523;
		byte SZO_524;
		byte C_525;
		byte SCZO_526;
		word32 esi_527;
		word32 edi_528;
		word32 ecx_529;
		word32 ebx_530;
		word32 eax_531;
		byte Z_532;
		byte bl_533;
		byte al_534;
		byte cl_535;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_536;
		word32 ebp_537;
		word32 edx_538;
		byte SZO_539;
		byte C_540;
		byte SCZO_541;
		word32 esi_542;
		word32 edi_543;
		word32 ecx_544;
		word32 ebx_545;
		word32 eax_546;
		byte Z_547;
		byte bl_548;
		byte al_549;
		byte cl_550;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_551;
		word32 ebp_552;
		word32 edx_553;
		byte SZO_554;
		byte C_555;
		byte SCZO_556;
		word32 esi_557;
		word32 edi_558;
		word32 ecx_559;
		word32 ebx_560;
		word32 eax_561;
		byte Z_562;
		byte bl_563;
		byte al_564;
		byte cl_565;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_566;
		word32 ebp_567;
		word32 edx_568;
		byte SZO_569;
		byte C_570;
		byte SCZO_571;
		word32 esi_572;
		word32 edi_573;
		word32 ecx_574;
		word32 ebx_575;
		word32 eax_576;
		byte Z_577;
		byte bl_578;
		byte al_579;
		byte cl_580;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_581;
		word32 ebp_582;
		word32 edx_583;
		byte SZO_584;
		byte C_585;
		byte SCZO_586;
		word32 esi_587;
		word32 edi_588;
		word32 ecx_589;
		word32 ebx_590;
		word32 eax_591;
		byte Z_592;
		byte bl_593;
		byte al_594;
		byte cl_595;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_596;
		word32 ebp_597;
		word32 edx_598;
		byte SZO_599;
		byte C_600;
		byte SCZO_601;
		word32 esi_602;
		word32 edi_603;
		word32 ecx_604;
		word32 ebx_605;
		Eq_2 eax_606;
		byte Z_607;
		byte bl_608;
		byte al_609;
		byte cl_610;
		RTUTILS.dll!TraceDumpExA();
		fn00401000();
		return eax_606;
	}
	else
	{
		*(esp_38 - 0x04) = fp - 0x40;
		*(esp_38 - 0x08) = fp - 0x40;
		*(esp_38 - 0x0C) = fp - 0x40;
		*(esp_38 - 0x10) = fp - 0x40;
		*(esp_38 - 0x14) = fp - 0x40;
		word32 ebp_107;
		word32 edx_108;
		byte SZO_109;
		byte C_110;
		byte SCZO_111;
		word32 esi_112;
		word32 edi_113;
		word32 ecx_114;
		word32 ebx_115;
		word32 eax_116;
		byte Z_117;
		byte bl_118;
		byte al_119;
		byte cl_120;
		word32 esp_106;
		NTDLL.dll!NtQuerySemaphore();
		if ((eax_116 ^ 0xC0000003) != 0x00 && (eax_116 ^ 0xC0000003) != 0x01)
		{
			fn00401000();
			esp_106 = esp_106 + 0x04;
		}
		word32 * esp_131 = esp_106 - 0x04;
		*esp_131 = 0x00;
		*(esp_131 - 0x04) = 0x00;
		*(esp_131 - 0x08) = 0x00;
		*(esp_131 - 0x0C) = 0x00;
		*(esp_131 - 0x10) = 0x00;
		*(esp_131 - 0x14) = 0x00;
		*(esp_131 - 0x18) = 0x00;
		ptr32 esp_145;
		ptr32 ebp_146;
		ui32 edx_147;
		byte SZO_148;
		byte C_149;
		byte SCZO_150;
		word32 esi_151;
		word32 edi_152;
		word32 ecx_153;
		word32 ebx_154;
		ui32 eax_155;
		byte Z_156;
		byte bl_157;
		byte al_158;
		byte cl_159;
		RTUTILS.dll!TraceDumpExA();
		if (eax_155 != 0x57)
		{
			fn00401000();
			return eax_155 - 0x57;
		}
		else
		{
			ui32 v16_171 = (esi & 0x00) - (0x800FF9D2 - eax_155);
			ui32 v17_177 = v16_171 + ((dwLoc4C & (edx_147 & 0x00) + (eax_155 - 0x57)) + 2272615812 ^ 0x077AA4FF);
			fp - 0x04 + -0x18 = v17_177;
			Eq_269 edx_191 = v17_177 - ((v16_171 + 2153232763 ^ ~0x00) + 0x01) + dwLoc1C;
			DWORD v20_203 = (dwLoc14 & 0x00) + ((fp - 0x04) + -((edx_191 *s 0x00 ^ 0x02A8) + ~0xFF));
			*(esp_145 - 0x04) = 0x00480000;
			word32 edx_222 = ~((dwLoc08 & v17_177) + (~((v20_203 - (struct <anonymous> *) ~0x0F) *s 0x00 | 0x30) + 0x01));
			*(esp_145 - 0x08) = edx_222 - ~0x00;
			*(esp_145 - 0x0C) = (LPVOID *) edx_191;
			*(esp_145 - 0x10) = fp - 0x01AC;
			word32 * ecx_239 = fn00401353(ebp_146);
			*(esp_145 - 0x0C) = 0x40;
			*(esp_145 - 0x10) = 0x3000;
			*(esp_145 - 0x14) = fp - 0x28;
			*(esp_145 - 0x18) = 0x00;
			Eq_362 eax_264 = VirtualAlloc(*(esp_145 - 0x18), *(esp_145 - 0x14), *(esp_145 - 0x10), *(esp_145 - 0x0C));
			Eq_389 dwLoc20_212 = v20_203 - (struct <anonymous> *) ~0x0F;
			int32 dwLoc08_225 = edx_222 - ~0x00;
			Eq_393 dwLoc1C_254 = dwLoc1C & 0x00;
			ptr32 esp_265 = esp_145 - 0x08;
			Eq_362 dwLoc0C_266 = eax_264;
			Eq_2 eax_267 = 0x00;
			uint32 dwLoc01B0_275 = dwLoc01B0 & 0x00;
			if (0x00 == 0x00)
			{
				while (dwLoc01B0_275 < *((word32) v20_203 + 0x08))
				{
					word32 * esp_444 = esp_265 - 0x04;
					*esp_444 = 0x00480000;
					*(esp_444 - 0x04) = (word32) *((word32) dwLoc20_212 + 0x04);
					*(esp_444 - 0x08) = (word32) *dwLoc20_212 + 0x00400000;
					Mem459[esp_444 - 0x0C + 0x00:word32] = eax_264 + dwLoc1C_254;
					fn00401348(ebp_146);
					esp_265 = esp_444 - 0x0C;
					dwLoc1C_254 = dwLoc1C_254 + Mem459[dwLoc20_212 + 0x04:word32];
					dwLoc01B0_275 = dwLoc01B0_275 + 0x01;
					dwLoc20_212 = (word32) dwLoc20_212 + 0x08;
				}
				word32 * esp_474 = esp_265 - 0x04;
				*esp_474 = 0x00400000;
				*(esp_474 - 0x04) = v14;
				ui32 esi_501 = (word32) *((word32) v20_203 + 0x04) + (0x00 - v15);
				*(esp_474 - 0x08) = esi_501;
				ui32 esi_505 = esi_501 & 0x00 | v13;
				*(esp_474 - 0x0C) = esi_505;
				*(esp_474 - 0x10) = esi_505 + 0x4A;
				*(esp_474 - 0x14) = v13;
				return v20_203;
			}
			else
			{
l004012AA:
				*(esp_145 - 0x0C) = (uint32) eax_267;
				Eq_418 edx_305 = dwLoc0C_266 - edx_191;
				Eq_362 v43_310 = dwLoc0C_266 & ecx_239 *s 0x00 | edx_305;
				dwLoc0C_266 = v43_310;
				if (v43_310 < dwArg0C)
				{
					ui32 eax_366 = dwArg10 + dwLoc08_225 & 0xFF ^ ~0x00;
					word32 * eax_376 = (char *) v43_310 + (eax_366 + 0x01 & 0x00 ^ dwArg04);
					word32 eax_387 = DPB(Mem299[eax_376 + 0x00:word32], (byte) ((~(-edx_191 - 0x01 | ~Mem299[dwArg08 + v43_310:word32]) & 0xFF) + (eax_366 + 0x01)), 0);
					*(esp_145 - 0x0C) = 0x00;
					*eax_376 = *(esp_145 - 0x0C);
					*(esp_145 - 0x0C) = eax_376;
					*eax_376 = (word32) ((byte) fn004013AF() + (*eax_376 + -eax_387));
					*eax_376 = (*eax_376 ^ ~0x00) + 0x01;
					int32 edx_415 = (edx_305 & 0x00) + dwLoc08_225;
					ecx_239 = eax_376;
					eax_267 = esp_145 - 0x08;
					dwLoc08_225 = edx_415 + 0x01;
					if (edx_415 == 0x00)
						dwLoc08_225 = edx_415 + 0x01 & 0x00;
					if (dwLoc08_225 != 0x14000000)
						goto l004012AA;
				}
				return eax_267;
			}
		}
	}
}

// 00401348: void fn00401348(Register ptr32 ebp)
void fn00401348(ptr32 ebp)
{
	if (true)
	{
		fn00401000();
		return;
	}
	else
	{
		fn00401353(ebp);
		return;
	}
}

// 00401353: Register word32 fn00401353(Register ptr32 ebp)
word32 fn00401353(ptr32 ebp)
{
	if (true)
	{
		fn00401000();
		return ecx;
	}
	else
	{
		word32 ecx_28 = -~0x152F;
		word32 edi_29 = *(ebp - 0x08) + ecx_28;
		*(ebp - 0x14) = *(ebp - 0x14) & 0x00;
		*(ebp - 0x14) = *(ebp - 0x14) + edi_29;
		*(ebp - 0x08) = -*(ebp - 0x08);
		return ecx_28;
	}
}

// 004013AF: FlagGroup bool fn004013AF()
bool fn004013AF()
{
	return false;
}

