/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int *__userpurge sub_401000@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// int *__userpurge start@<eax>(DWORD dwByteCount@<ecx>, DWORD a2@<ebx>, BYTE *a3@<esi>, int a4, int a5, int a6, int a7);
void __stdcall sub_401348(int a1);
void __stdcall sub_401353(int a1);
void __stdcall sub_4013AF(int a1);
// NTSTATUS __stdcall NtSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);
// NTSTATUS __stdcall NtQuerySemaphore(HANDLE SemaphoreHandle, SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass, PVOID SemaphoreInformation, ULONG Length, PULONG ReturnLength);
// DWORD __stdcall TraceDumpExW(DWORD dwTraceID, DWORD dwFlags, LPBYTE lpbBytes, DWORD dwByteCount, DWORD dwGroupSize, BOOL bAddressPrefix, LPCWSTR lpszPrefix);
// DWORD __stdcall TraceDumpExA(DWORD dwTraceID, DWORD dwFlags, LPBYTE lpbBytes, DWORD dwByteCount, DWORD dwGroupSize, BOOL bAddressPrefix, LPCSTR lpszPrefix);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_47FFFF; // weak


//----- (00401000) --------------------------------------------------------
int *__userpurge sub_401000@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5)
{
  int *result; // eax
  _DWORD *v6; // ecx
  char v7; // cf
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // [esp+0h] [ebp-14h] BYREF
  int v11; // [esp+4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-Ch]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v14 = 0;
  v13 = 0;
  v11 = a1;
  v10 = a1;
  v12 = -1;
  result = 0;
  if ( a4 )
  {
    v10 = -1;
    v11 = v13 + a2;
    v6 = (_DWORD *)(v13 + a2);
    *v6 = 0;
    sub_4013AF((int)v6);
    *v9 += v8 + v7;
    result = &v10;
    v10 = (v10 ^ *v9) + 1;
    if ( ++v14 == 1 )
      v14 = 0;
    if ( v14 != 335544320 )
      JUMPOUT(0x4012AA);
  }
  return result;
}
// 4010F0: control flows out of bounds to 4012AA
// 401000: could not find valid save-restore pair for edi
// 4010C1: variable 'v8' is possibly undefined
// 4010C1: variable 'v7' is possibly undefined
// 4010C1: variable 'v9' is possibly undefined

//----- (004010FC) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
int *__userpurge start@<eax>(DWORD dwByteCount@<ecx>, DWORD a2@<ebx>, BYTE *a3@<esi>, int a4, int a5, int a6, int a7)
{
  int v7; // eax
  unsigned int v9; // eax
  int v10; // eax
  DWORD v11; // edi
  unsigned int i; // [esp+0h] [ebp-1ACh]
  char v13[16]; // [esp+4h] [ebp-1A8h] BYREF
  _DWORD v14[61]; // [esp+14h] [ebp-198h] BYREF
  LPCSTR *v15; // [esp+108h] [ebp-A4h]
  DWORD v16; // [esp+10Ch] [ebp-A0h]
  LPBYTE v17; // [esp+110h] [ebp-9Ch]
  DWORD v18; // [esp+114h] [ebp-98h]
  DWORD v19; // [esp+118h] [ebp-94h]
  BOOL v20; // [esp+11Ch] [ebp-90h]
  LPCWSTR v21; // [esp+120h] [ebp-8Ch]
  DWORD v22; // [esp+124h] [ebp-88h]
  DWORD v23; // [esp+128h] [ebp-84h]
  LPBYTE v24; // [esp+12Ch] [ebp-80h]
  DWORD v25; // [esp+130h] [ebp-7Ch]
  DWORD v26; // [esp+134h] [ebp-78h]
  BOOL v27; // [esp+138h] [ebp-74h]
  LPCSTR v28; // [esp+13Ch] [ebp-70h]
  DWORD v29; // [esp+140h] [ebp-6Ch]
  DWORD v30; // [esp+144h] [ebp-68h]
  LPBYTE v31; // [esp+148h] [ebp-64h]
  DWORD v32; // [esp+14Ch] [ebp-60h]
  DWORD v33; // [esp+150h] [ebp-5Ch]
  BOOL v34; // [esp+154h] [ebp-58h]
  LPCWSTR v35; // [esp+158h] [ebp-54h]
  DWORD v36; // [esp+15Ch] [ebp-50h]
  DWORD v37; // [esp+160h] [ebp-4Ch]
  LPBYTE v38; // [esp+164h] [ebp-48h]
  DWORD v39; // [esp+168h] [ebp-44h]
  DWORD v40; // [esp+16Ch] [ebp-40h]
  BOOL SemaphoreHandle; // [esp+170h] [ebp-3Ch] BYREF
  LPCSTR v42; // [esp+174h] [ebp-38h]
  DWORD v43; // [esp+178h] [ebp-34h]
  DWORD v44; // [esp+17Ch] [ebp-30h]
  LPBYTE v45; // [esp+180h] [ebp-2Ch]
  LPCSTR *v46; // [esp+184h] [ebp-28h]
  SIZE_T dwSize; // [esp+188h] [ebp-24h] BYREF
  BOOL v48; // [esp+18Ch] [ebp-20h]
  const WCHAR *v49; // [esp+190h] [ebp-1Ch]
  DWORD v50; // [esp+194h] [ebp-18h]
  DWORD v51; // [esp+198h] [ebp-14h]
  char *v52; // [esp+19Ch] [ebp-10h]
  DWORD v53; // [esp+1A0h] [ebp-Ch]
  DWORD v54; // [esp+1A4h] [ebp-8h]
  BOOL v55; // [esp+1A8h] [ebp-4h]
  LPCSTR vars0; // [esp+1ACh] [ebp+0h] BYREF

  v18 = dwByteCount;
  v17 = a3;
  v53 = 0;
  v16 = a2;
  v15 = &vars0;
  v42 = 0;
  if ( NtSetSystemInformation(SystemBasicInformation, 0, 0) == -1073741821 )
  {
    SemaphoreHandle = 0;
    v9 = NtQuerySemaphore(
           &SemaphoreHandle,
           (SEMAPHORE_INFORMATION_CLASS)&SemaphoreHandle,
           &SemaphoreHandle,
           (ULONG)&SemaphoreHandle,
           (PULONG)&SemaphoreHandle) ^ 0xC0000003;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( v10 )
        sub_401000(v10, (int)v15, v16, (int)v17, v18);
    }
    v7 = TraceDumpExA(0, 0, 0, 0, 0, 0, 0) - 87;
    if ( !v7 )
    {
      v38 = 0;
      v53 += 2146436741;
      v11 = v53;
      v53 -= 2146436741;
      v50 = v53;
      v55 &= v53;
      v53 += v53 - (2141734533 - v11);
      v52 = v13;
      v46 = (LPCSTR *)((char *)&unk_47FFFF + 1);
      v49 = (const WCHAR *)v14;
      v55 -= 48;
      v55 = ~v55;
      ++v55;
      v18 = (DWORD)&unk_47FFFF + 1;
      v17 = (LPBYTE)v55;
      v16 = v53;
      sub_401353((int)v13);
      dwSize = *(_DWORD *)v52 + *((_DWORD *)v52 + 1);
      v50 = 0;
      v54 = (DWORD)VirtualAlloc(0, (SIZE_T)&dwSize, 0x3000u, 0x40u);
      v48 = 0x400000;
      for ( i = 0; i < *((_DWORD *)v52 + 2); ++i )
      {
        v15 = v46;
        v14[60] = *((_DWORD *)v49 + 1);
        v14[59] = *(_DWORD *)v49 + v48;
        sub_401348(v50 + v54);
        v50 += *((_DWORD *)v49 + 1);
        v49 += 4;
      }
      JUMPOUT(0x401361);
    }
  }
  else
  {
    TraceDumpExW((DWORD)v15, v16, v17, v18, v19, v20, v21);
    TraceDumpExA(v22, v23, v24, v25, v26, v27, v28);
    TraceDumpExW(v29, v30, v31, v32, v33, v34, v35);
    TraceDumpExA(v36, v37, v38, v39, v40, SemaphoreHandle, v42);
    TraceDumpExW(v43, v44, v45, (DWORD)v46, dwSize, v48, v49);
    v7 = TraceDumpExA(v50, v51, (LPBYTE)v52, v53, v54, v55, vars0);
  }
  return sub_401000(v7, a4, a5, a6, a7);
}
// 40115E: positive sp value 94 has been found
// 401040: control flows out of bounds to 401043
// 4012D4: control flows out of bounds to 401361
// 40125D: bad sp value at call

//----- (00401348) --------------------------------------------------------
void __stdcall sub_401348(int a1)
{
  JUMPOUT(0x401000);
}
// 40134D: control flows out of bounds to 401000

//----- (00401353) --------------------------------------------------------
void __stdcall sub_401353(int a1)
{
  JUMPOUT(0x401000);
}
// 40135B: control flows out of bounds to 401000

//----- (004013AF) --------------------------------------------------------
void __stdcall sub_4013AF(int a1)
{
  ;
}

// nfuncs=6 queued=5 decompiled=5 lumina nreq=0 worse=0 better=0
// ALL OK, 5 function(s) have been successfully decompiled
