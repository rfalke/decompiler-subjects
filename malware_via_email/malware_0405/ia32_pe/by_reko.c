// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__AreAllAccessesGranted = &g_t42D6; // 00404000
<anonymous> * __imp__FreeLibrary = &g_t4172; // 00404008
<anonymous> * __imp__GetModuleHandleA = &g_t4180; // 0040400C
<anonymous> * __imp__GetCurrentProcess = &g_t4194; // 00404010
<anonymous> * __imp__VirtualProtect = &g_t41A8; // 00404014
<anonymous> * __imp__GetModuleFileNameW = &g_t41BA; // 00404018
<anonymous> * __imp__DeleteCriticalSection = &g_t41D0; // 0040401C
<anonymous> * __imp__CreateFileW = &g_t41E8; // 00404020
<anonymous> * __imp__GetCurrentThreadId = &g_t41F6; // 00404024
<anonymous> * __imp__ExitProcess = &g_t420C; // 00404028
<anonymous> * __imp__GetModuleFileNameA = &g_t415C; // 0040402C
<anonymous> * __imp__GetCurrentProcessId = &g_t4228; // 00404030
<anonymous> * __imp__CreateThread = &g_t423E; // 00404034
<anonymous> * __imp__GetLastError = &g_t424E; // 00404038
<anonymous> * __imp__GetProcAddress = &g_t425E; // 0040403C
<anonymous> * __imp__GetModuleHandleW = &g_t4270; // 00404040
<anonymous> * __imp__EnterCriticalSection = &g_t4284; // 00404044
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t429C; // 00404048
<anonymous> * __imp__LoadLibraryA = &g_t42B8; // 0040404C
<anonymous> * __imp__CloseHandle = &g_t421A; // 00404050
<anonymous> * __imp__CreateEventW = &g_t414C; // 00404054
<anonymous> * __imp__StrStrIA = &g_t4306; // 0040405C
<anonymous> * __imp__StrChrA = &g_t42FC; // 00404060
word32 g_dw4040E4 = 17110; // 004040E4
word32 g_dw4040EC = 0x4172; // 004040EC
word32 g_dw4040F0 = 0x4180; // 004040F0
word32 g_dw4040F4 = 0x4194; // 004040F4
word32 g_dw4040F8 = 16808; // 004040F8
word32 g_dw4040FC = 16826; // 004040FC
word32 g_dw404100 = 0x41D0; // 00404100
word32 g_dw404104 = 0x41E8; // 00404104
word32 g_dw404108 = 16886; // 00404108
word32 g_dw40410C = 0x420C; // 0040410C
word32 g_dw404110 = 0x415C; // 00404110
word32 g_dw404114 = 0x4228; // 00404114
word32 g_dw404118 = 0x423E; // 00404118
word32 g_dw40411C = 0x424E; // 0040411C
word32 g_dw404120 = 16990; // 00404120
word32 g_dw404124 = 0x4270; // 00404124
word32 g_dw404128 = 0x4284; // 00404128
word32 g_dw40412C = 0x429C; // 0040412C
word32 g_dw404130 = 17080; // 00404130
word32 g_dw404134 = 16922; // 00404134
word32 g_dw404138 = 16716; // 00404138
word32 g_dw404140 = 0x4306; // 00404140
word32 g_dw404144 = 17148; // 00404144
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = 0;
	esp -= 0x10;
	esp -= 4;
	esp->t0000.u0 = (DWORD) esi;
	esi = esi ^ esi;
	SZ = cond(esi);
	O = false;
	C = false;
	esp -= 4;
	esp->t0000.u0 = (DWORD) esi;
	esp -= 4;
	esp->t0000.u0 = (DWORD) 0x00404068;
	SHLWAPI.dll!StrChrA();
	SZP = cond(eax & eax);
	O = false;
	C = false;
	if (Test(EQ,Z))
	{
		esp -= 4;
		esp->t0000.u0 = (DWORD) eax;
		esp -= 4;
		esp->t0000.u0 = (DWORD) 0x00404070;
		SHLWAPI.dll!StrStrIA();
		SZP = cond(eax & eax);
		O = false;
		C = false;
		if (Test(EQ,Z))
		{
			esp -= 4;
			esp->t0000.u0 = (DWORD) ebx;
			esp -= 4;
			esp->t0000.u0 = (DWORD) ebp;
			esp -= 4;
			esp->t0000.u0 = (DWORD) edi;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x0040407C;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00404084;
			eax = LoadLibraryA(esp->t0000.u0);
			esp = (struct Eq_3 *) &esp->t0004.u0;
			esp -= 4;
			esp->t0000.u0 = (DWORD) eax;
			eax = GetProcAddress(esp->t0000.u0, esp->t0004.u1);
			esp = (struct Eq_3 *) &esp->t0008.u0;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00;
			eax();
			edi = eax;
			edi += 0x1C;
			esp -= 4;
			esp->t0000.u0 = (DWORD) ~0x00;
			esp -= 4;
			esp->t0000.u0 = (DWORD) ~0x00;
			eax = AreAllAccessesGranted(esp->t0000.u0, esp->t0004.u2);
			esp = (struct Eq_3 *) &esp->t0008.u0;
			SZP = cond(eax & eax);
			O = false;
			C = false;
			if (Test(EQ,Z))
			{
				edi = edi ^ 0x0E;
				SZ = cond(edi);
				O = false;
				C = false;
			}
			eax = esp + 16;
			esp -= 4;
			esp->t0000.u0 = (DWORD) eax;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x40;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x3000;
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00401000;
			eax = VirtualProtect(esp->t0000.u0, esp->t0004.u2, esp->t0008.u2, esp->t000C);
			esp = (struct Eq_3 *) ((char *) &esp->t000C + 4);
			eax = eax ^ eax;
			SZ = cond(eax);
			O = false;
			C = false;
			do
			{
				SCZO = cond(esi - edi);
				if (Test(EQ,Z))
				{
					esi = esi ^ esi;
					SZ = cond(esi);
					O = false;
					C = false;
				}
				cl = (ui8) *((word32) esi + 0x00405000);
				cl = cl ^ *((word32) eax + 4203384);
				++esi;
				cl = cl ^ 0x5A;
				SCZO = cond(esi - edi);
				Mem0[eax + 4203384:byte] = cl;
				if (Test(EQ,Z))
				{
					esi = esi ^ esi;
					SZ = cond(esi);
					O = false;
					C = false;
				}
				dl = (ui8) *((word32) esi + 0x00405000);
				dl = dl ^ *((word32) eax + 4203385);
				++esi;
				dl = dl ^ 0x5A;
				SCZO = cond(esi - edi);
				Mem0[eax + 0x00402379:byte] = dl;
				if (Test(EQ,Z))
				{
					esi = esi ^ esi;
					SZ = cond(esi);
					O = false;
					C = false;
				}
				cl = (ui8) *((word32) esi + 0x00405000);
				cl = cl ^ *((word32) eax + 4203386);
				++esi;
				cl = cl ^ 0x5A;
				SCZO = cond(esi - edi);
				Mem0[eax + 0x0040237A:byte] = cl;
				if (Test(EQ,Z))
				{
					esi = esi ^ esi;
					SZ = cond(esi);
					O = false;
					C = false;
				}
				dl = (ui8) *((word32) esi + 0x00405000);
				dl = dl ^ *((word32) eax + 4203387);
				++esi;
				dl = dl ^ 0x5A;
				SCZO = cond(esi - edi);
				Mem0[eax + 0x0040237B:byte] = dl;
				if (Test(EQ,Z))
				{
					esi = esi ^ esi;
					SZ = cond(esi);
					O = false;
					C = false;
				}
				cl = (ui8) *((word32) esi + 0x00405000);
				cl = cl ^ *((word32) eax + 4203388);
				++esi;
				cl = cl ^ 0x5A;
				SCZO = cond(esi - edi);
				Mem0[eax + 4203388:byte] = cl;
				if (Test(EQ,Z))
				{
					esi = esi ^ esi;
					SZ = cond(esi);
					O = false;
					C = false;
				}
				dl = (ui8) *((word32) esi + 0x00405000);
				dl = dl ^ *((word32) eax + 4203389);
				eax += 0x06;
				dl = dl ^ 0x5A;
				Mem0[eax + 4203383:byte] = dl;
				++esi;
				SCZO = cond(eax - 0x1440);
			} while (Test(ULT,C));
			esi.u0 = 4208248;
			ebx += edx;
			ebp.u0 = 4203384;
			ebp -= 0x0280;
			esp->t0014.u1 = (BOOL) ebp;
			ecx += ecx * 0x04;
			ecx = ecx ^ ecx;
			SZ = cond(ecx);
			O = false;
			C = false;
			edi.u0 = (word16) ebp.u0 - 0x10000000;
			esp->t0018.u1 = (BOOL) ecx;
			ecx = ecx;
			do
			{
				eax = *((word16) esi.u0 + 4);
				eax -= 0x08;
				eax >>= 0x01;
				ebx += edi;
				SZP = cond(eax & eax);
				O = false;
				C = false;
				edx.u0 = (word16) esi.u0 + 8;
				if (Test(GT,SZO))
				{
					ebx = eax;
					do
					{
						eax = CONVERT(Mem0[edx + 0x00:word16], word16, word32);
						ecx = eax;
						ecx &= 0xF000;
						SCZO = cond(ecx - 0x3000);
						if (Test(EQ,Z))
						{
							eax &= 0x0FFF;
							eax += Mem0[esi + 0x00:word32];
							eax += ebp;
							v20 = (word32) ((word16) edi.u0 + (eax.u4)->unused);
							eax.u4->unused = v20;
							SCZO = cond(v20);
						}
						edx.u0 = (word16) edx.u0 + 2;
						--ebx;
						SCZO = cond(ebx);
					} while (Test(NE,Z));
					ecx.u1 = esp->t0018.u1;
				}
				ecx += Mem0[esi + 4:word32];
				esp->t0018.u1 = (BOOL) ecx;
				edx.u0 = (word16) esi.u0 + edx * 0x08;
				esi += Mem0[esi + 4:word32];
				SCZO = cond(ecx - 232);
			} while (Test(ULT,C));
			edi.u0 = (word16) ebp.u0 + 3444;
			esp->t0018.u1 = (BOOL) edi;
			ecx += ecx * 0x04;
			SCZO = cond(*((word16) edi.u0 + 16) - 0x00);
			if (Test(NE,Z))
			{
				ecx = ecx;
				do
				{
					edx = *((word32) edi.u1 + 0x0C);
					edx += ebp;
					esp -= 4;
					esp->t0000.u0 = (DWORD) edx;
					eax = LoadLibraryA(esp->t0000.u0);
					esp = (struct Eq_3 *) &esp->t0004.u0;
					ecx = eax;
					esp->t001C.u1 = (BOOL) ecx;
					ebx += ebx * 0x04;
					SZP = cond(ecx & ecx);
					O = false;
					C = false;
					if (Test(NE,Z))
					{
						eax = *edi.u0;
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(EQ,Z))
							eax = *((word16) edi.u0 + 16);
						ebp += eax;
						esi = ebx + esi * 0x08;
						edi = *((word16) edi.u0 + 16);
						eax = *ebp.u0;
						edi.u0 = (word16) edi.u0 + (esp->t0014).u1;
						SZP = cond(eax & eax);
						O = false;
						C = false;
						if (Test(NE,Z))
						{
							while (true)
							{
								SZP = cond(eax & eax);
								O = false;
								C = false;
								if (Test(SG,S))
								{
									eax = CONVERT(Mem0[ebp + 0x00:word16], word16, word32);
									esp -= 4;
									esp->t0000.u0 = (DWORD) eax;
									esp -= 4;
									esp->t0000.u0 = (DWORD) ecx;
									eax = GetProcAddress(esp->t0000.u0, esp->t0004.u1);
									esp = (struct Eq_3 *) &esp->t0008.u0;
									ebx += ecx;
								}
								else
								{
									esi += esi * 0x08;
									edx.u1 = esp->t0014.u1;
									eax = eax + 2 + edx;
									esp -= 4;
									esp->t0000.u0 = (DWORD) eax;
									esp -= 4;
									esp->t0000.u0 = (DWORD) ecx;
									eax = GetProcAddress(esp->t0000.u0, esp->t0004.u1);
									esp = (struct Eq_3 *) &esp->t0008.u0;
								}
								ebp += 0x04;
								*edi.u1 = eax;
								eax = *ebp.u1;
								edi += 0x04;
								SZP = cond(eax & eax);
								O = false;
								C = false;
								if (Test(EQ,Z))
									break;
								ecx.u1 = esp->t001C.u1;
							}
						}
						ebp.u1 = esp->t0014.u1;
						edi.u1 = esp->t0018.u1;
					}
					edi.u0 = (word16) edi.u0 + 20;
					SCZO = cond(*((word16) edi.u0 + 16) - 0x00);
					esp->t0018.u1 = (BOOL) edi;
				} while (Test(NE,Z));
			}
			ecx.u0 = 4205400;
			fn00402B58();
			esp -= 4;
			esp->t0000.u0 = (DWORD) 0x00;
			ExitProcess(esp->t0000.u0);
		}
	}
	eax = eax ^ eax;
	esi = Mem0[esp + 0x00:word32];
	esp = (struct Eq_3 *) &esp->t0004.u0;
	esp = (struct Eq_3 *) ((char *) &esp->t000C + 4);
	SCZO = cond(esp);
	return;
}

// 00402A93: define fn00402A93
// Called from:
//      fn00402AF9
define fn00402A93
{
	esp = fp;
	Top = 0;
	dh += *((word32) (edx - 2) + ecx);
	++ebx;
	esi = esi ^ edi->dw0011;
	SZ = cond(esi);
	O = false;
	C = false;
	fn00402A9B();
}

// 00402A9B: define fn00402A9B
// Called from:
//      fn00402A93
//      fn00402AF9
//      fn00402AFB
define fn00402A9B
{
	esp = fp;
	Top = 0;
	if (Test(PE,P))
	{
		es = (struct Eq_699 *) *esp;
		esp = (struct Eq_699 **) 1133030890;
		*(struct Eq_699 ***) 27265 = eax;
		fn00402AFB();
	}
	else
	{
		edi = edi - ((edx->aB43F8351))[ebp].dw0000 - C;
		SCZO = cond(edi);
		v12 = esp;
		esp = eax;
		eax = v12;
	}
}

// 00402AF9: define fn00402AF9
// Called from:
//      fn00402B58
define fn00402AF9
{
	esp = fp;
	Top = 0;
	v5 = edx->dw002D - 0xE8A99704;
	edx->dw002D = v5;
	SCZO = cond(v5);
	fn00402AFB();
}

// 00402AFB: define fn00402AFB
// Called from:
//      fn00402A9B
//      fn00402AF9
define fn00402AFB
{
	esp = fp;
	Top = 0;
	eax -= 0xE8A99704;
	C = __das(al, &al);
	eax |= 4262715666;
	SZ = cond(eax);
	O = false;
	C = false;
	if (Test(PO,P))
		fn00402A9B();
	else
		fn00402B08();
}

// 00402B08: define fn00402B08
// Called from:
//      fn00402AF9
//      fn00402AFB
define fn00402B08
{
	esp = fp;
	Top = 0;
	if (Test(EQ,Z))
		fn00402A93();
	else
	{
		__lock();
		al = al - 0x14 - C;
		bh |= *((word32) (ebp + 1662269061) + eax);
		SZ = cond(bh);
		O = false;
		C.u0 = false;
		__out<word32>(dx, eax);
		fn6C0C_EE95();
		--ecx;
		if (Test(NE,Z) && ecx != 0x00)
			fn00402B7C();
		else
		{
			v17 = *edi >> 0x01;
			*edi = v17;
			__out<byte>(~0x07, al);
			esp -= 2;
			*esp = (struct Eq_836 **) cs;
			eax = eax ^ 2133681423;
			ax = __aam(al);
			dl |= ah;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			fn00402B2B();
		}
	}
}

// 00402B2B: define fn00402B2B
// Called from:
//      fn00402B08
//      fn00402B7C
define fn00402B2B
{
	ptr32 fp;
	byte dl;
	word32 ecx;
	ch_34 = SLICE(ecx, byte, 8);
	<unknown> Mem0;
	word32 esi;
	byte bh;
	word24 edx_24_8;
	byte bl;
	word16 ebx_16_16;
	word32 ebp;
	word16 eax_16_16;
	word32 dwArg00;
	bool D;
	selector ds;
	byte ah;
	word32 edi;
	bool P;
	esp_24 = fp;
	Top_25 = 0;
	SCZO_29 = cond(dl - ecx->b005E);
	C_35 = SLICE(SCZO_29, bool, 1);
	al_31 = *esi;
	esi_32 = esi + 1;
	bh_36 = bh - ch_34 - (byte) (dl < ecx->b005E);
	SCZO_37 = cond(bh_36);
	Z_39 = SLICE(SCZO_37, bool, 2);
	C_71 = SLICE(SCZO_37, bool, 1);
	O_87 = SLICE(SCZO_37, bool, 4);
	S_91 = (bool) SCZO_37;
	ecx_38 = ecx - 0x01;
	edx_41 = SEQ(edx_24_8, dl);
	cl_42 = (byte) ecx - 0x01;
	ecx_24_8_43 = SLICE(ecx - 0x01, word24, 8);
	ebx_46 = SEQ(ebx_16_16, bh_36, bl);
	eax_78 = SEQ(eax_16_16, ah, al_31);
	if (bh_36 == 0x00 || ecx == (struct Eq_859 *) 0x01)
		return;
	fn00402B9D();
}

// 00402B58: define fn00402B58
// Called from:
//      Win32CrtStartup
define fn00402B58
{
	esp = fp;
	Top = null;
	*Top -= (real64) ebx->dw6ED3EB2C;
	eax = (int32) ax;
	es_edi.u1 = (edx - 83)[ebx].t0000.u1;
	__cli();
	do
	{
		++edx;
		al = al ^ 188;
		C.u0 = false;
		bh = bh - ch - C;
		SCZO = cond(bh);
		--ecx;
		if (Test(NE,Z) && ecx != 0x00)
		{
			es = (struct Eq_989 *) *esp;
			esp = (struct Eq_989 **) ((char *) esp + 2);
			v22 = edi->dwBBF66AF8 - eax - C;
			edi->dwBBF66AF8 = v22;
			SCZO = cond(v22);
			fn00402BDB();
			return;
		}
		esp -= 4;
		*esp = (struct Eq_989 **) edi;
		eax = (struct Eq_989 *) *esp;
		esp = (struct Eq_989 **) ((char *) esp + 4);
		--ecx;
		if (Test(EQ,Z) && ecx != 0x00)
		{
			fn00402AF9();
			return;
		}
		C = __das(al, &al);
	} while (Test(NE,Z));
}

// 00402B7C: define fn00402B7C
// Called from:
//      fn00402AF9
define fn00402B7C
{
	esp = fp;
	Top = 0;
	al = (bool) C + (al + 0x1A);
	SCZO = cond(al);
	C.u0 = false;
	__cli();
	esp -= 4;
	esp->u1 = (struct Eq_1682 *) edx;
	(char *) &esi.u1->ptrDA49E3E1 + 632691743 = esp->u1;
	esp = (union Eq_1080 *) ((char *) esp + 4);
	if (Test(PO,P))
		fn00402BFB();
	else
	{
		v10 = ebx;
		ebx = eax;
		eax = v10;
		__wait();
		esp -= 4;
		esp->u1 = (struct Eq_1682 *) 0x2D;
		gs = edx.u1->ptrDA49E3E1;
		esp -= 4;
		esp->u1 = (struct Eq_1682 *) SCZDOP;
		if (Test(LT,SO))
			fn00402B2B();
		else
		{
			eax = ecx->dw808D8047 *s 0x1F;
			ch |= *((word32) edx + (edx * 0x04 + 1924947798));
			SZ = cond(ch);
			O = false;
			C.u0 = false;
			fn00402BA0();
		}
	}
}

// 00402B9D: define fn00402B9D
// Called from:
//      fn00402B08
//      fn00402B2B
define fn00402B9D
{
	word32 edx;
	byte cl;
	byte al;
	word24 ecx_24_8;
	word32 ebx;
	word32 ebp;
	word16 eax_16_16;
	word32 dwArg00;
	Top_3 = 0;
	fn00402BA0();
}

// 00402BA0: define fn00402BA0
// Called from:
//      fn00402B7C
//      fn00402B9D
define fn00402BA0
{
	ptr32 fp;
	word32 edx;
	dx_47 = (word16) edx;
	<unknown> Mem0;
	bool P;
	byte cl;
	byte al;
	word24 ecx_24_8;
	word32 ebx;
	word32 edi;
	word32 ebp;
	word16 eax_16_16;
	selector ds;
	Top_40 = 0;
	v4_43 = *edx;
	*edx = fp;
	esp_45 = v4_43;
	if (P)
		fn00402BE1();
	else
	{
		ecx_52 = SEQ(ecx_24_8, cl << 0x1C);
		SCZO_53 = cond(al - ecx_52->bFFFFFF92);
		__wait();
		SCZOP_55 = SCZO_53 | P;
		ax_57 = SEQ(SCZOP_55, al);
		eax_24_8_74 = SEQ(eax_16_16, SCZOP_55);
		if (P)
			fn00402C2C();
		else
		{
			fn00402BB0();
			esp_82 = fp;
		}
	}
}

// 00402BB0: define fn00402BB0
// Called from:
//      fn00402B9D
//      fn00402BA0
define fn00402BB0
{
	ptr32 fp;
	word32 edx;
	word32 ebx;
	bool C;
	byte al;
	word32 ecx[];
	word24 eax_24_8;
	word32 edi;
	word32 ebp;
	selector psegArg00;
	ah_25 = (byte) eax_24_8;
	Top_3 = 0;
	edx_9 = edx - ebx->dwB18104D4 - (word32) C;
	dx_10 = (word16) edx_9;
	__out<byte>(dx_10, al);
	al_15 = *edx;
	ds_17 = psegArg00;
	esp_18 = fp + 2;
	eax_21 = SEQ(eax_24_8, al_15);
	v16_22 = ecx[eax_21 / 4] + edx_9;
	ecx[eax_21 / 4] = v16_22;
	ax_26 = SEQ(ah_25, al_15);
	fn00402C2C();
}

// 00402BDB: define fn00402BDB
// Called from:
//      fn00402AF9
//      fn00402B58
define fn00402BDB
{
	esp = fp;
	Top = null;
	v7 = edi->dwBBF66AF8 - eax - C;
	edi->dwBBF66AF8 = v7;
	SCZO = cond(v7);
	fn00402BE1();
}

// 00402BE1: define fn00402BE1
// Called from:
//      fn00402BA0
//      fn00402BDB
define fn00402BE1
{
	word16 dx;
	__in<byte>(dx);
	fn00402BF8();
}

// 00402BF8: define fn00402BF8
// Called from:
//      fn00402B08
//      fn00402BDB
//      fn00402BE1
define fn00402BF8
{
	fn00402BFB();
}

// 00402BFB: define fn00402BFB
// Called from:
//      fn00402B7C
//      fn00402BF8
define fn00402BFB
{
	__halt();
}

// 00402C2C: define fn00402C2C
// Called from:
//      fn00402B9D
//      fn00402BA0
define fn00402C2C
{
	word16 ax;
	word32 ebx;
	ptr32 fp;
	word32 edi;
	<unknown> Mem0;
	bl = (byte) ebx;
	bool C;
	bool P;
	word32 ebp;
	esp_2 = fp;
	v8_8 = edi->bBA8F36FA + bl + (byte) C;
	edi->bBA8F36FA = v8_8;
	ebx_124 = ebx;
	ax_145 = ax;
l00402C2D:
	ax_146 = ϕ(ax_145, edx_eax_75);
	edi_125 = ϕ(edi, edi_97);
	ebx_122 = ϕ(ebx_124, ebx_48);
	esp_121 = ϕ(esp_2, esp_78);
	v41_132 = ϕ(P, v42_133);
	ax_143 = ax_146;
	while (true)
	{
		ax_144 = ϕ(ax_143, ax_90);
		edi_33 = ϕ(edi_125, edi_89);
		ebx_32 = ϕ(ebx_122, ebx_48);
		esp_24 = ϕ(esp_121, esp_78);
		v40_131 = ϕ(v41_132, v42_133);
		esi_11 = 3225677776;
		__sti();
		ax_18 = ax_144;
		if (v40_131)
			break;
		__syscall<byte>(113);
		eax_19 = (int32) ax_18;
		al_20 = (byte) eax_19;
		eax_16_16_26 = SLICE(eax_19, word16, 16);
		ax_21 = __aam(al_20);
		al_22 = (byte) ax_21;
		ah_27 = SLICE(ax_21, byte, 8);
		__cli();
		__lock();
		esp_25 = esp_24 - 4;
		eax_28 = SEQ(eax_16_16_26, ah_27, al_22 + 188);
		*esp_25 = eax_28;
		(*ebx_32)();
		C_136 = SLICE(SCZDOP_41, bool, 1);
		O_137 = SLICE(SCZDOP_41, bool, 4);
		S_138 = (bool) SCZDOP_41;
		Z_139 = SLICE(SCZDOP_41, bool, 2);
		Top_37 = 0;
		P_47 = SLICE(SCZDOP_41, bool, 5);
		edx_eax_42 = (int64) eax_38;
		dx_44 = SLICE(edx_eax_42, word16, 32);
		edx_54 = SLICE(edx_eax_42, word32, 32);
		D_43 = false;
		eax_45 = __in<word32>(dx_44);
		edi_46 = (word32 *) (&edi_33->bBA8F36FA + 1165019402);
		__sti();
		if (P_47)
		{
			fn00402BDB();
			return;
		}
		ebx_48 = (<anonymous> **) 81041521;
		eax_49 = eax_45 + 1366751932;
		esp_50 = 1787158386;
		if (eax_45 <= 2456464117)
		{
			edx_eax_59 = (int64) (eax_45 + 1366751932);
			dx_61 = SLICE(edx_eax_59, word16, 32);
			eax_62 = __in<word32>(dx_61);
			al_66 = (byte) eax_62;
			eax_16_16_68 = SLICE(eax_62, word16, 16);
			__cli();
			if (P_47)
				fn00402BF8();
			ax_67 = __aam(al_66);
			eax_69 = SEQ(eax_16_16_68, ax_67);
			eax_70 = eax_69 + 0x51C0FABC;
			esp_72 = 1787119986;
		}
		else
		{
			ecx_53 = ecx_40 - 0x01;
			v43_134 = !PARITY_EVEN(edx_54->dw003D & ebp);
		}
		ecx_91 = ϕ(ecx_40, ecx_53);
		v42_133 = ϕ(P_47, v43_134);
		esp_77 = ϕ(esp_72, esp_50);
		eax_74 = ϕ(eax_70, eax_49);
		__out<word32>(0x12, eax_74);
		edx_eax_75.u0 = (int64) eax_74;
		eax_83 = (word32) edx_eax_75;
		edx_87 = SLICE(edx_eax_75, word32, 32);
		dl_99 = SLICE(edx_eax_75, byte, 32);
		esp_78 = esp_77 - 4;
		*esp_78 = 81041521;
		__cli();
		if (!v42_133)
		{
			edi_97 = (struct Eq_1418 *) (edi_46 + 1);
			if (OVERFLOW<word32>(eax_83 - *edi_46))
			{
				v24_100 = *eax_83 & dl_99;
				*eax_83 = v24_100;
				goto l00402C2D;
			}
		}
		al_85 = (byte) eax_83 - 222;
		edx_87[eax_83 - (byte *) 2347003358] = 81041521;
		edi_89 = (edx_87 - 5)[edx_87].dw0000 *s ~0x6C;
		ax_90 = __aam(al_85);
		v27_92 = ecx_91->dwAC5E4362 - 0xFA9F1020;
		ecx_91->dwAC5E4362 = v27_92;
	}
}

