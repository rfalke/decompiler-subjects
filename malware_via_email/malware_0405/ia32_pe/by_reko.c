// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_13;
	byte SCZO_14;
	word32 esi_15;
	byte SZO_16;
	byte C_17;
	word32 eax_18;
	byte Z_19;
	word32 ebx_20;
	word32 ebp_21;
	word32 edi_22;
	byte cl_23;
	byte dl_24;
	word32 edx_25;
	word32 ecx_26;
	byte S_27;
	SHLWAPI.dll!StrChrA();
	if (eax_18 == 0x00)
	{
		*(esp_13 - 0x04) = eax_18;
		*(esp_13 - 0x08) = 0x00404070;
		ptr32 esp_53;
		byte SCZO_54;
		word32 esi_55;
		byte SZO_56;
		byte C_57;
		word32 eax_58;
		byte Z_59;
		word32 ebx_60;
		word32 ebp_61;
		word32 edi_62;
		byte cl_63;
		byte dl_64;
		word32 edx_65;
		word32 ecx_66;
		byte S_67;
		SHLWAPI.dll!StrStrIA();
		if (eax_58 == 0x00)
		{
			*(esp_53 - 0x04) = ebx_60;
			*(esp_53 - 0x08) = ebp_61;
			*(esp_53 - 0x0C) = edi_62;
			*(esp_53 - 0x10) = 0x0040407C;
			*(esp_53 - 0x14) = 0x00404084;
			*(esp_53 - 0x18) = (HMODULE *) LoadLibraryA(*(esp_53 - 0x14));
			Eq_91 eax_84 = GetProcAddress(*(esp_53 - 0x18), *(esp_53 - 0x14));
			*(esp_53 - 0x1C) = 0x00;
			*(esp_53 - 0x20) = 0x00;
			*(esp_53 - 0x24) = 0x00;
			*(esp_53 - 0x28) = 0x00;
			*(esp_53 - 44) = 0x00;
			int32 eax_100 = eax_84();
			*(esp_53 - 0x30) = ~0x00;
			*(esp_53 - 0x34) = ~0x00;
			struct Eq_150 * edi_111 = eax_100 + 0x1C;
			if (AreAllAccessesGranted(*(esp_53 - 0x34), *(esp_53 - 0x30)) == 0x00)
				edi_111 = eax_100 + 0x1C ^ 0x0E;
			*(esp_53 - 0x38) = esp_53 - 0x24;
			*(esp_53 - 0x3C) = 0x40;
			*(esp_53 - 0x40) = 0x3000;
			*(esp_53 - 0x44) = 0x00401000;
			VirtualProtect(*(esp_53 - 0x44), *(esp_53 - 0x40), *(esp_53 - 0x3C), *(esp_53 - 0x38));
			struct Eq_220 * esp_128 = esp_53 - 0x44;
			struct Eq_222 * eax_131 = null;
			do
			{
				struct Eq_150 * esi_141;
				if (esi_141 == edi_111)
					esi_141 = null;
				eax_131[700564] = (struct Eq_222) (esi_141[0x00405000] ^ eax_131[700564] ^ 0x5A);
				struct Eq_150 * esi_149 = esi_141 + 0x01;
				if (esi_149 == edi_111)
					esi_149 = null;
				eax_131->b402379 = esi_149[0x00405000] ^ eax_131->b402379 ^ 0x5A;
				struct Eq_150 * esi_159 = esi_149 + 0x01;
				if (esi_159 == edi_111)
					esi_159 = null;
				eax_131->b40237A = esi_159[0x00405000] ^ eax_131->b40237A ^ 0x5A;
				struct Eq_150 * esi_169 = esi_159 + 0x01;
				if (esi_169 == edi_111)
					esi_169 = null;
				eax_131->b40237B = esi_169[0x00405000] ^ eax_131->b40237B ^ 0x5A;
				struct Eq_150 * esi_179 = esi_169 + 0x01;
				if (esi_179 == edi_111)
					esi_179 = null;
				eax_131->b40237C = esi_179[0x00405000] ^ eax_131->b40237C ^ 0x5A;
				struct Eq_150 * esi_189 = esi_179 + 0x01;
				if (esi_189 == edi_111)
					esi_189 = null;
				eax_131 = eax_131 + 0x01;
				eax_131->b402377 = esi_189[0x00405000] ^ eax_131->b40237D ^ 0x5A;
				esi_141 = esi_189 + 0x01;
			} while (eax_131 < (struct Eq_222 *) 0x1440);
			*(esp_53 - 0x30) = 4202744;
			*(esp_53 - 44) = 0x00;
			struct Eq_345 * esi_206 = &globals->t403678;
			word32 ebp_209 = 4202744;
			uint32 ecx_217 = 0x00;
			do
			{
				Eq_353 eax_225 = esi_206->t0004;
				word16 * edx_231 = (char *) &esi_206->t0004 + 0x04;
				if (eax_225 - 0x08 >> 0x01 > 0x00)
				{
					uint32 ebx_375 = eax_225 - 0x08 >> 0x01;
					do
					{
						ui32 eax_379 = (word32) *edx_231;
						if ((eax_379 & 0xF000) == 0x3000)
						{
							struct Eq_379 * eax_393 = (eax_379 & 0x0FFF) + esi_206->dw0000;
							eax_393->dw4020F8 = eax_393->dw4020F8 + 0xF04020F8;
						}
						edx_231 = edx_231 + 0x01;
						ebx_375 = ebx_375 - 0x01;
					} while (ebx_375 != 0x00);
					ecx_217 = *(esp_53 - 44);
				}
				ecx_217 = (word32) esi_206->t0004 + ecx_217;
				*(esp_53 - 44) = ecx_217;
				esi_206 = esi_206 + Mem241[esi_206 + 0x04:word32];
			} while (ecx_217 < 232);
			*(esp_53 - 44) = 0x00402E6C;
			struct Eq_409 * edi_246 = &globals->t402E6C;
			if (globals->dw402E7C != 0x00)
			{
				edi_272 = edi_246;
				ebp_273 = ebp_209;
				esp_276 = esp_128;
				do
				{
					struct Eq_409 * edi_272;
					word32 ebp_273;
					struct Eq_220 * esp_276;
					esp_276 = esp_276 - 0x04 + 0x14;
					esp_276->dw0000 = edi_272->dw000C + ebp_273;
					Eq_85 eax_282 = LoadLibraryA(esp_276->dw0000);
					esp_276->dw001C = (word32) eax_282;
					Eq_85 ecx_283 = eax_282;
					if (eax_282 != null)
					{
						word32 eax_306 = edi_272->dw0000;
						if (eax_306 == 0x00)
							eax_306 = edi_272->dw0010;
						word32 * ebp_311 = ebp_273 + eax_306;
						int32 eax_314 = *ebp_311;
						word32 * edi_315 = edi_272->dw0010 + esp_276->dw0014;
						if (eax_314 != 0x00)
						{
							while (true)
							{
								Eq_91 eax_347;
								if (eax_314 < 0x00)
								{
									LPCSTR * esp_360 = esp_276 - 0x04;
									*esp_360 = (LPCSTR *) (word32) *ebp_311;
									*(esp_360 - 0x04) = (HMODULE *) ecx_283;
									eax_347 = GetProcAddress(*(esp_360 - 0x04), *esp_360);
								}
								else
								{
									LPCSTR * esp_369 = esp_276 - 0x04;
									*esp_369 = (LPCSTR *) (eax_314 + 0x02 + esp_276->dw0000);
									*(esp_369 - 0x04) = (HMODULE *) ecx_283;
									eax_347 = GetProcAddress(*(esp_369 - 0x04), *esp_369);
								}
								*edi_315 = (word32) eax_347;
								ebp_311 = ebp_311 + 0x01;
								esp_276 = esp_276 - 0x08;
								eax_314 = *ebp_311;
								edi_315 = edi_315 + 0x01;
								if (eax_314 == 0x00)
									break;
								ecx_283 = (Eq_85) esp_276->dw001C;
							}
						}
						ebp_273 = esp_276->dw0014;
						edi_272 = (struct Eq_409 *) esp_276[0x03];
					}
					edi_272 = edi_272 + 0x01;
					esp_276[0x03] = (struct Eq_220) edi_272;
				} while (edi_272->dw0010 != 0x00);
			}
			ptr32 esp_253;
			byte SCZO_254;
			word32 esi_255;
			byte SZO_256;
			byte C_257;
			word32 eax_258;
			byte Z_259;
			word32 ebx_260;
			word32 ebp_261;
			word32 edi_262;
			byte cl_263;
			byte dl_264;
			word32 edx_265;
			word32 ecx_266;
			byte S_267;
			globals->t402B58();
			*(esp_253 - 0x04) = 0x00;
			ExitProcess(*(esp_253 - 0x04));
		}
	}
	return 0x00;
}

