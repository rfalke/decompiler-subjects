// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetMessageW = &g_tF138; // 00401000
<anonymous> * __imp__LookupIconIdFromDirectory = &g_tF146; // 00401004
<anonymous> * __imp__mouse_event = &g_tF162; // 00401008
<anonymous> * __imp__DrawIcon = &g_tF170; // 0040100C
<anonymous> * __imp__AppendMenuA = &g_tF17C; // 00401010
<anonymous> * __imp__UnloadKeyboardLayout = &g_tF18A; // 00401014
<anonymous> * __imp__CreateCursor = &g_tF1A2; // 00401018
<anonymous> * __imp__GetKeyboardType = &g_tF1B2; // 0040101C
<anonymous> * __imp__OpenIcon = &g_tF1C4; // 00401020
<anonymous> * __imp__SetClassLongW = &g_tF1D0; // 00401024
<anonymous> * __imp__wvsprintfA = &g_tF1E0; // 00401028
<anonymous> * __imp__CreateCaret = &g_tF1EE; // 0040102C
<anonymous> * __imp__PathMakePrettyW = &g_tF208; // 00401034
<anonymous> * __imp__StrSpnA = &g_tF21A; // 00401038
<anonymous> * __imp__RemoveDirectoryA = &g_tF230; // 00401040
<anonymous> * __imp__GetCommState = &g_tF244; // 00401044
<anonymous> * __imp__GetWindowsDirectoryA = &g_tF254; // 00401048
<anonymous> * __imp__ExitProcess = &g_tF26C; // 0040104C
<anonymous> * __imp__InterlockedExchange = &g_tF27A; // 00401050
<anonymous> * __imp__GetCurrentThreadId = &g_tF290; // 00401054
<anonymous> * __imp__OpenFileMappingW = &g_tF2A6; // 00401058
<anonymous> * __imp__LockResource = &g_tF2BA; // 0040105C
<anonymous> * __imp__AreFileApisANSI = &g_tF2CA; // 00401060
<anonymous> * __imp__InterlockedExchangeAdd = &g_tF2DC; // 00401064
<anonymous> * __imp__GetCurrentProcessId = &g_tF2F6; // 00401068
<anonymous> * __imp__ReplaceTextW = &g_tF31A; // 00401070
<anonymous> * __imp__ChooseColorW = &g_tF32A; // 00401074
<anonymous> * __imp__PrintDlgExW = &g_tF33A; // 00401078
<anonymous> * __imp__GetOpenFileNameW = &g_tF348; // 0040107C
<anonymous> * __imp__memset = &g_tF36A; // 00401084
<anonymous> * __imp___stricmp = &g_tF374; // 00401088
<anonymous> * __imp__EndPath = &g_tF38A; // 00401090
<anonymous> * __imp__SetPaletteEntries = &g_tF394; // 00401094
<anonymous> * __imp__CreateDCW = &g_tF3A8; // 00401098
<anonymous> * __imp__SetBkMode = &g_tF3B4; // 0040109C
<anonymous> * __imp__GetTextExtentExPointW = &g_tF3C0; // 004010A0
<anonymous> * __imp__SetPixel = &g_tF3D8; // 004010A4
<anonymous> g_t4017D8 = <code>; // 004017D8
// 004038AC: void qznlacy(Stack (ptr32 uint32) ptrArg04)
void qznlacy(uint32 * ptrArg04)
{
	g_t40805C.u0 = (ui32) (g_t40805C.u0 & *g_ptr40813A);
	g_dw408000 += *g_ptr40816A;
	g_t408038.u0 = (ui32) ((word32) g_t408038.u1 | g_t407FC0.u0);
}

// 004038F3: Register int32 x_gYC_SVW_BZcpszCXd(Stack (ptr32 bool) ptrArg04)
int32 x_gYC_SVW_BZcpszCXd(bool * ptrArg04)
{
	up32 dwLoc20;
	up32 edi_9 = (word32) g_t40800C.u1;
	ui32 * ecx_10 = g_ptr408136;
	*ecx_10 = *ecx_10 ^ edi_9;
	g_t408098.u0 = (up32) ((word32) g_t408098.u1 + *g_ptr408152 + (word32) (dwLoc20 < edi_9));
	ui32 * ebx_21 = g_ptr40813E;
	*ebx_21 = *ebx_21 ^ g_t407FC0.u0;
	return <invalid>;
}

// 00403932: void _MP__ipwIML_WGzqh_(Stack int32 dwArg04, Stack (ptr32 int32) ptrArg08)
void _MP__ipwIML_WGzqh_(int32 dwArg04, int32 * ptrArg08)
{
	uint32 esi;
	up32 ebx;
	up32 ecx;
	g_dw408074 = g_dw408074 + *g_ptr4080DE + (word32) (esi < g_dw408068);
	word32 * edx_16 = g_ptr4080F6;
	*edx_16 += (word32) g_t407FD8.u0;
	g_t408038.u0 = (ui32) (g_t408038.u0 - g_t408090.u1 - (word32) (ebx < ecx));
}

// 0040397B: Register (ptr32 char) RTXjyh_h_o_t_hET_Z(Stack (ptr32 int32) ptrArg04)
char * RTXjyh_h_o_t_hET_Z(int32 * ptrArg04)
{
	g_t407FC8.u0 = (ui32) ((word32) g_t407FC8.u1 & g_t408084.u0);
	g_t407FC0.u0 = (ui32) ((word32) g_t407FC0.u1 & *g_ptr4080D6);
	g_t408024.u0 = (ui32) ((word32) g_t408024.u1 ^ *g_ptr4081C6);
	return (char *) <invalid>;
}

// 004039C4: Register int16 gri__vazkAELP__nI___Z(Stack int16 wArg04)
int16 gri__vazkAELP__nI___Z(int16 wArg04)
{
	g_dw40806C |= *g_ptr4081B2;
	Eq_150 edi_13 = g_t40809C.u0;
	g_t40800C.u0 = (ui32) (g_t40800C.u0 | edi_13);
	g_dw4080A0 = g_dw4080A0 - *g_ptr40810E - (word32) (g_t408054.u0 < edi_13);
	return <invalid>;
}

// 00403A10: Register int32 WWcb_tysgYEF(Stack cu8 bArg04)
int32 WWcb_tysgYEF(cu8 bArg04)
{
	g_dw408028 |= *g_ptr4080D2;
	g_dw40804C &= *g_ptr40819E;
	g_t408080.u0 = (ui32) ((word32) g_t408080.u1 & g_t408070.u0);
	return <invalid>;
}

// 00403A57: Register (ptr32 uint32) _sotycly_kwgceopzn_crf(Stack (ptr32 int16) ptrArg04)
uint32 * _sotycly_kwgceopzn_crf(int16 * ptrArg04)
{
	up32 ecx;
	up32 dwLoc1C;
	g_dw40806C = g_dw40806C - (word32) g_t408070.u2 - (word32) (ecx < dwLoc1C);
	ui32 * ecx_17 = g_ptr40819E;
	*ecx_17 -= g_dw407FAC;
	word32 * esi_20 = g_ptr408102;
	*esi_20 -= g_dw408034;
	return (uint32 *) <invalid>;
}

// 00403A95: Register int16 ___P___U_VBXU_VKy(Stack (ptr32 int32) ptrArg04, Stack int32 dwArg08)
int16 ___P___U_VBXU_VKy(int32 * ptrArg04, int32 dwArg08)
{
	g_t408070.u0 = (ui32) ((word32) g_t408070.u1 + g_dw40801C);
	ui32 * ebx_14 = g_ptr4080D2;
	*ebx_14 |= g_t408050.u0;
	ui32 * edx_18 = g_ptr408126;
	*edx_18 = *edx_18 ^ g_dw408048;
	return <invalid>;
}

// 00403AD0: void fn00403AD0(Register (ptr32 Eq_266) eax)
// Called from:
//      Win32CrtStartup
void fn00403AD0(struct Eq_266 * eax)
{
	g_ptr407554 = (word32 *) ((char *) eax + 4);
	g_dw407548 = eax->dw0008;
	g_dw40754C = eax->dw000C;
	g_dw407550 = eax->dw0010;
}

// 00403AF4: Register (ptr32 void) hb___hg_NVCNBjqh(Stack char bArg04)
void * hb___hg_NVCNBjqh(char bArg04)
{
	Eq_288 edx;
	ui32 * esi_10 = g_ptr408132;
	*esi_10 += g_dw4080A4;
	Eq_288 esi_15 = (word32) g_t408018.u1 + (word32) g_t40807C.u0;
	g_t408018.u0 = (uint32) esi_15;
	word32 * ebx_19 = g_ptr4080DA;
	*ebx_19 = *ebx_19 - g_t408070.u0 - (word32) (edx < esi_15);
	return (void *) <invalid>;
}

// 00403B32: Register (ptr32 uint32) zrFTwfs_lb(Stack uint16 wArg04)
uint32 * zrFTwfs_lb(uint16 wArg04)
{
	Eq_46 ecx;
	uint32 esi;
	uint32 edi_9 = (word32) g_t408024.u1;
	ui32 * edx_10 = g_ptr4081CA;
	*edx_10 &= edi_9;
	g_dw407FEC = g_dw407FEC - g_ptr4081B6->u2 - (word32) (g_t408098.u0 < ecx);
	g_t407FFC.u1 = (word32) ((word32) g_t407FFC.u0 - g_dw407FF4 - (word32) (esi < edi_9));
	return (uint32 *) <invalid>;
}

// 00403B7C: Register uint16 _g_a_n_jm_q_sx(Stack uint32 dwArg04, Stack int16 wArg08)
uint16 _g_a_n_jm_q_sx(uint32 dwArg04, int16 wArg08)
{
	uint32 eax;
	g_t408064.u0 = (uint32) ((word32) g_t408064.u2 | g_dw408060);
	word32 * ebx_16 = g_ptr408116;
	*ebx_16 = *ebx_16 - g_t407FE4.u0 - (word32) (g_dw408068 < eax);
	g_dw408020 -= *g_ptr40811E;
	return <invalid>;
}

// 00403BC3: Register (ptr32 word16) fn00403BC3()
// Called from:
//      fn00404EC0
word16 * fn00403BC3()
{
	Eq_404 dwLoc08;
	Eq_405 dwLoc20;
	g_t408064.u0 = 0x00;
	Eq_404 eax_10 = dwLoc08;
	do
	{
		g_t408064.u0 = (uint32) (g_t408064.u0 + 0x01);
		if (g_t408064.u0 == 0x24)
			eax_10 = GetMessageW(&g_t407FD4, 0x6C11, 0x1FDD, dwLoc20);
	} while (g_t408064.u0 < 0x1E);
	union Eq_434 * edx_76 = g_ptr40815E;
	edx_76->u0 = (ui32) (edx_76->u0 ^ 0x190C);
	g_dw407FE8 |= 4227020;
	ui32 eax_74 = (eax_10 ^ dwLoc08) + 0x01 << 0x04;
	ui32 * eax_114 = **g_ptr407040;
	word16 * eax_140 = 0x01 - (eax_74 << 0x0C) - 1 & *eax_114;
	word16 * dwLoc10_294 = eax_140;
	word16 ax_149 = *eax_140 - 0x022E;
	while ((ax_149 ^ 0x032F) != 23344)
	{
		word16 * v33_170 = dwLoc10_294 - (eax_74 << 0x0C);
		g_t408044.u0 = 0x00;
		dwLoc10_294 = v33_170;
		do
		{
			g_t408044.u0 = (up32) (g_t408044.u0 + 0x01);
			if (g_t408044.u0 == 0x18)
				EndPath((struct HDC__ *) 0x8CF2);
		} while (g_t408044.u0 < 0x10);
		ax_149 = *v33_170 - 0x022E;
	}
	return dwLoc10_294;
}

Eq_638 g_t403DB3 = // 00403DB3
	{
		<code>,
		0x40709405,
	};
// 00403DE3: Register ui32 fn00403DE3(Stack (ptr32 Eq_511) dwArg04, Stack (ptr32 word32) dwArg08, Register out (ptr32 Eq_513) edxOut)
// Called from:
//      fn004053C3
ui32 fn00403DE3(struct Eq_511 * dwArg04, word32 * dwArg08, struct Eq_513 & edxOut)
{
	byte bLoc20;
	word32 dwLoc1C;
	word32 dwLoc28;
	Eq_404 dwLoc18;
	struct Eq_513 * edx;
	word24 nArg04_247 = (word24) dwArg04;
	up32 dwLoc14_203 = 0x00;
	do
	{
		dwLoc14_203 = dwLoc14_285 + 0x01;
		if (dwLoc14_203 == 0x1E)
			LookupIconIdFromDirectory((BYTE *) 5957, dwLoc18);
		dwLoc14_285 = dwLoc14_203;
	} while (dwLoc14_285 < 0x1B);
	word32 eax_179;
	union Eq_348 * esi_68 = g_ptr4081B6;
	word32 ecx_51 = g_dw4070F0;
	esi_68->u0 = (byte) (esi_68->u0 - 0x3B);
	if (ecx_51 != 0x01)
	{
		word32 ecx_82 = 14319 - dwLoc1C - (word32) (g_dw408008 > ~0x1002);
		if (*dwArg04->ptr0038 != 0x00)
		{
			ui32 * eax_94 = g_ptr408132;
			struct Eq_511 * ecx_93 = g_ptr4072D8;
			*eax_94 |= g_dw407FAC;
			edx = (struct Eq_513 *) *ecx_93->ptr0008;
			word32 eax_102 = edx[(edx->ptr003C + 40) / 64];
			g_t408054.u0 = (uint32) (g_t408054.u0 & 0x00408018);
			g_t408054.u0 = (uint32) (g_t408054.u0 + 0x004080A0);
			g_t408054.u0 = (uint32) (g_t408054.u0 | 0x00407FC8);
			word32 eax_111 = edx + eax_102 / 64;
			if (ecx_93->dw0040 != 0x00)
			{
				word32 * ecx_116 = g_ptr4080E2;
				*ecx_116 -= dwLoc14_203;
				struct Eq_638 * edx_121 = g_ptr407310;
				edx_121->t0000 = (<anonymous>) 233;
				struct Eq_638 * ecx_131 = g_ptr407310;
				g_t408038.u0 = (ui32) 0x0040804C;
				g_t408038.u0 = (ui32) (g_t408038.u0 & 0x00407FFC);
				ecx_131->dw0001 = eax_111 - ~0x2528 - ecx_131 - 0x252E;
				struct Eq_513 ** eax_148 = g_ptr4072D8->ptr0008;
				word32 eax_156;
				g_ptr407310();
				*dwArg08 = eax_156;
			}
			g_t40807C.u1 = (word32) (g_t40807C.u1 & 0x00407FC0);
			g_dw407100 = 0x00;
			g_dw407104 = 0x00;
			eax_179 = ~0x1003;
l00403FAF:
			edxOut = edx;
			return (eax_179 ^ 13615) + 0x252E;
		}
	}
	eax_179 = ~0x1002;
	goto l00403FAF;
}

// 00403FB9: void fn00403FB9(Stack (ptr32 word32) dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      fn004052AC
void fn00403FB9(word32 * dwArg04, word32 dwArg08, <anonymous> * dwArg0C)
{
	Eq_678 dwLoc28;
	word32 dwLoc40;
	up32 dwLoc14_183 = 0x00;
	do
	{
		dwLoc14_183 = dwLoc14_311 + 0x01;
		if (dwLoc14_183 == 0x1D)
			ReplaceTextW(dwLoc28);
		dwLoc14_311 = dwLoc14_183;
	} while (dwLoc14_311 < 0x15);
	int32 * esi_67 = g_ptr4070DC;
	g_dw408028 &= g_t408018.u0;
	*esi_67 = *esi_67 *s ~0x1002 *s ~0x2007;
	g_t408078.u0 = (ui32) (g_t408078.u0 - 0x00408040);
	g_t408078.u0 = (ui32) (g_t408078.u0 & 0x004080A0);
	word32 * esi_82 = g_ptr4070D4;
	*esi_82 = ~*esi_82;
	g_ptr407304 = dwArg04;
	if (false)
		g_dw407308 = dwArg08;
	else if (false)
		g_ptr40730C = dwArg0C;
	g_dw408030 = g_dw408030 ^ 0x00408038;
	g_dw408030 += 0x00408000;
	g_dw408030 |= 0x0040807C;
	word32 * eax_144 = g_ptr4070D4;
	*eax_144 += ~0x0200D013;
}

// 0040417E: void fn0040417E(Register (ptr32 Eq_768) ebp, Register (ptr32 uint32) esi, Register uint32 edi)
// Called from:
//      Win32CrtStartup
void fn0040417E(struct Eq_768 * ebp, uint32 * esi, uint32 edi)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				uint32 ecx_16 = *esi;
				if (ecx_16 > edi)
					*esi = ecx_16 - 0x01;
				else if (ecx_16 == 0x00)
					*esi = edi;
				else
				{
					g_dw40806C = 0x00;
					do
					{
						++g_dw40806C;
						if (g_dw40806C == 22)
							SetPaletteEntries(ebp->tFFFFFFE4, 0x402E, ebp->tFFFFFFF4.u0, ebp->ptrFFFFFFE0);
					} while (g_dw40806C < 0x15);
					*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_16;
				}
			} while (*esi != edi);
		}
	} while ((word32) InterlockedExchangeAdd(&g_t4072EC, 0x00760667) + 0x00760667 != g_t4072EC);
}

// 0040422E: Register Eq_774 fn0040422E(Register (ptr32 Eq_774) esi, Register Eq_774 edi)
// Called from:
//      Win32CrtStartup
Eq_774 fn0040422E(union Eq_774 * esi, Eq_774 edi)
{
	esi->u0 = 0x01;
	Eq_774 eax_10 = InterlockedExchange(&g_t4072EC, 0x00760667);
	while (esi->u0 != edi)
	{
		Eq_774 ecx_20 = esi->u0;
		if (ecx_20 < edi)
		{
			if (ecx_20 == 0x00)
				goto l004042B7;
			g_dw407FF4 = 0x00;
			do
			{
				++g_dw407FF4;
				if (g_dw407FF4 == 0x20)
					RemoveDirectoryA(&g_t408236);
			} while (g_dw407FF4 < 0x1F);
			eax_10 = (word32) ecx_20 + ((uint32) ((uint64) edi /u 0x0101) + 1);
			esi->u0 = (uint32) eax_10;
		}
		else if (ecx_20 == 0x00)
		{
l004042B7:
			esi->u0 = (uint32) edi;
		}
		else
			esi->u0 = (uint32) (ecx_20 - 0x01);
	}
	return eax_10;
}

// 004042D0: Register word32 fn004042D0(Register word32 ecx, Register word32 edx, Register word32 esi, Register out ptr32 ecxOut, Register out ptr32 esiOut)
// Called from:
//      fn00404AA0
word32 fn004042D0(word32 ecx, word32 edx, word32 esi, ptr32 & ecxOut, ptr32 & esiOut)
{
	g_t40809C.u0 = 0x00;
	do
	{
		g_t40809C.u0 = (uint32) (g_t40809C.u0 + 0x01);
		if (g_t40809C.u0 == 0x2D)
			CreateDCW(&g_t408398, &g_t408328, &g_t40831E, (DEVMODEW *) 12060);
	} while (g_t40809C.u0 < 0x1F);
	word32 * eax_37 = g_ptr407080;
	g_dw4072F0 = *eax_37;
}

// 004043E1: void fn004043E1()
// Called from:
//      fn00404AA0
void fn004043E1()
{
	ptr32 fp;
	word32 dwLoc20;
	Eq_953 dwLoc24;
	g_dw408048 = 0x00;
	do
	{
		++g_dw408048;
		if (g_dw408048 == 0x14)
			GetCommState(dwLoc24, &g_t408098);
	} while (g_dw408048 < 0x10);
	ui32 v17_63 = dwLoc20 ^ g_dw408074;
	struct Eq_511 * edx_70 = g_ptr4072D8;
	g_t40809C.u0 = (uint32) 0x00408090;
	g_t40809C.u0 = (uint32) (g_t40809C.u0 ^ 0x00408020);
	word32 v19_87 = g_dw4072F4;
	word32 v20_92 = g_dw4072F0;
	struct Eq_1149 ** eax_100 = edx_70->ptr000C;
	g_dw407FC4 = g_dw407FC4 - 0x00408078 - (word32) (edx_70 < (struct Eq_511 *) ~0x013D);
	g_ptr407580();
}

// 00404505: Register word32 fn00404505(Register word32 ecx, Register word32 edx, Register ptr32 edi, Stack word32 dwArg00, Stack (ptr32 Eq_511) dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C, Stack word32 dwArg10, Register out ptr32 ediOut)
// Called from:
//      fn00404505
//      fn004053C3
word32 fn00404505(word32 ecx, word32 edx, ptr32 edi, word32 dwArg00, struct Eq_511 * dwArg04, word32 dwArg08, <anonymous> * dwArg0C, word32 dwArg10, ptr32 & ediOut)
{
	ptr32 fp;
	word32 dwLoc5C;
	word32 * esp_145;
	if (dwArg10 != 550007)
	{
		if (dwArg10 != 203272)
		{
			g_dw407FA8 = 0x18;
			while (g_dw407FA8 != 0x00)
			{
				if (g_dw407FA8 == 0x25)
					ChooseColorW((struct tagCHOOSECOLORW *) 0x53A1);
				--g_dw407FA8;
			}
			byte * ecx_59 = g_ptr408192;
			*ecx_59 += 113;
		}
		g_t408018.u0 = (uint32) (g_t408018.u0 + 4227044);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		word32 stackArg0 = <invalid>;
		word32 stackArg16 = <invalid>;
		word32 edi_291;
		fn00404505(ecx, edx_143, edi, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg16, out edi_291);
		esp_145 = fp - 0x0C;
	}
	else
		dwArg0C();
	word32 * eax_150 = g_ptr4080DA;
	*eax_150 -= dwLoc5C;
	word32 esi_163 = *esp_145;
	ediOut = edi;
	return esi_163;
}

// 00404673: FlagGroup bool fn00404673(Stack ui32 dwArg04, Stack ui32 dwArg08)
// Called from:
//      fn004054E3
bool fn00404673(ui32 dwArg04, ui32 dwArg08)
{
	g_dw40806C -= g_dw407FE0;
}

// 00404AA0: Register word32 fn00404AA0(Register word32 ecx, Register word32 edx, Register word32 esi, Register word32 edi, Register out ptr32 ediOut)
// Called from:
//      fn00404505
word32 fn00404AA0(word32 ecx, word32 edx, word32 esi, word32 edi, ptr32 & ediOut)
{
	Eq_1090 dwLoc1C;
	Eq_1091 dwLoc2C;
	Eq_1091 dwLoc24;
	Eq_1091 dwLoc10;
	up32 dwLoc30_477 = 0x00;
	do
	{
		dwLoc30_477 = dwLoc30_833 + 0x01;
		if (dwLoc30_477 == 0x1B)
			mouse_event(dwLoc10, dwLoc24, 0x5257, dwLoc2C, dwLoc1C);
		dwLoc30_833 = dwLoc30_477;
	} while (dwLoc30_833 < 0x19);
	g_dw408058 = __ror<word32,byte>(g_dw408058, 0x01);
}

// 00404EC0: void fn00404EC0(Register up32 edi)
// Called from:
//      fn004054E3
void fn00404EC0(up32 edi)
{
	up32 dwLocB8;
	word16 wLoc74;
	Eq_1124 dwLoc18;
	Eq_1125 dwLoc28;
	Eq_405 dwLoc1C;
	Eq_1124 dwLoc24;
	struct Eq_1128 * edx_13 = (struct Eq_1128 *) 0x05;
	do
	{
		g_t408054.u0 = 0x00;
		while (g_t408054.u0 < 22)
		{
			if (g_t408054.u0 == 0x22)
			{
				AppendMenuA(dwLoc24, dwLoc1C, 0x16AF, &g_t408263);
				dwLoc18 = dwLoc24;
			}
			g_t408054.u0 = (uint32) (g_t408054.u0 + 0x01);
		}
		if (g_dw407090 != 0x00)
			break;
		Mem49 = Mem30;
		ui8 al_50 = edx_13[4224215];
		g_dw407FB4 = g_dw407FB4 - 4227052 - (word32) (edi < dwLocB8);
		edx_13[4224215] = (struct Eq_1128) ((al_50 ^ 0x5F) + 0x31);
		++edx_13;
	} while (edx_13 < (struct Eq_1128 *) 0x14);
	struct Eq_1149 * edi_123 = null;
	if (*g_ptr4072D8->ptr000C == null)
		edi_123 = fn00403BC3();
	ui32 ecx_117 = ~0x1002;
	do
	{
		ui32 ecx_97 = ecx_117 ^ 13615;
		struct Eq_1195 * eax_98 = ecx_97 * 0x02 + 0x4A5C;
		eax_98->w4074C4 = (eax_98->w4074BC ^ 0x032F) + 0x022E;
		ecx_117 = ecx_97 + 0x01 ^ 13615;
	} while (ecx_117 != ~0x1005);
	if (edi_123 != null)
	{
		g_dw407FA8 = 0x00;
		while (g_dw407FA8 < 0x11)
		{
			if (g_dw407FA8 == 0x1C)
				GetTextExtentExPointW((struct HDC__ *) 0x805E, &g_t40831E, dwLoc28, 0x09, dwLoc28, (int32 *) 20727, dwLoc18);
			++g_dw407FA8;
		}
		struct Eq_1227 * ecx_141 = (struct Eq_1227 *) 0x09;
		Mem266 = Mem144;
		do
		{
			g_t408018.u0 = (uint32) (g_t408018.u0 & (word32) wLoc74);
			ui8 al_171 = (ecx_141[4224279] ^ 0x5F) + 0x31;
			g_t407FC0.u0 = (ui32) (g_t407FC0.u0 | 4226992);
			ecx_141[4224567] = (struct Eq_1227) al_171;
			--ecx_141;
		} while (ecx_141 != null);
		*g_ptr4072D8->ptr000C = (struct Eq_1149 **) edi_123;
	}
}

// 004050E5: void fn004050E5(Register up32 ebx, Register word32 esi, Register up32 edi)
// Called from:
//      Win32CrtStartup
void fn004050E5(up32 ebx, word32 esi, up32 edi)
{
	word32 * fp;
	up32 dwLoc34;
	int32 dwLoc28;
	ptr32 dwLoc5C;
	up32 dwLoc20;
	up32 dwLoc18_208 = 0x00;
	do
	{
		dwLoc18_208 = dwLoc18_328 + 0x01;
		if (dwLoc18_208 == 0x18)
		{
			SetPixel(fp - 8, 30881, dwLoc28, 0x00);
			dwLoc5C = fp - 8;
		}
		dwLoc18_328 = dwLoc18_208;
	} while (dwLoc18_328 < 0x11);
	g_dw408034 = g_dw408034 - 0x00408084 - (word32) (dwLoc34 < ebx);
	g_dw408034 |= 0x00408048;
	g_t408050.u0 = (uint32) (g_t408050.u0 + 0x004080A4);
	g_t408050.u0 = (uint32) (g_t408050.u0 ^ 4227032);
	g_t408050.u0 = (uint32) (g_t408050.u0 + 0x0040806C);
	g_ptr4074B8 = null;
	if (fn004054E3(ebx, esi, edi) == 0x00)
		return;
	g_dw407318 = g_dw4074CC;
	word32 eax_104 = g_dw4074D0;
	g_t408024.u0 = (ui32) 0x00407FF4;
	g_dw40731C = eax_104;
	g_dw407320 = g_dw4074D4;
	word32 * ebx_119 = fp;
	if (false)
	{
		word32 * eax_156 = g_ptr4080FA;
		*eax_156 = *eax_156 - 0x363D - (word32) (dwLoc20 < 13615);
		word32 * eax_160 = g_ptr4074B8;
		*eax_160 += g_dw407100;
	}
	else if (false)
	{
		g_ptr407314 = fp - 0x0C;
		word32 esi_122;
		word32 eax_118 = fn004052AC(dwLoc5C, out ebx_119, out esi_122);
		*g_ptr4074D8 = eax_118;
	}
	g_ptr4074B8 = ebx_119;
}

// 004052AC: Register word32 fn004052AC(Stack ptr32 dwArg00, Register out ptr32 ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn004050E5
word32 fn004052AC(ptr32 dwArg00, ptr32 & ebxOut, ptr32 & esiOut)
{
	word32 * fp;
	Eq_1412 dwLoc24;
	word32 dwLoc08_154;
	g_dw4070F0 = *(word32 *) ~0x0FFA;
	g_t40807C.u1 = (word32) dwLoc24 + g_t40807C.u1;
	g_dw4070F4 = *(word32 *) ~0x0FF6;
	fn00403FB9(fp - 8, **(word32 **) ~0x1002, g_ptr4072FC);
	ptr32 ebx_77;
	ptr32 esi_78;
	if (fn004053C3(out ebx_77, out esi_78) != 0x00)
	{
		g_dw407098 += 0x00677567;
		dwLoc08_154 = 0x00;
	}
	else
		dwLoc08_154 = *g_ptr4072D8->ptr003C;
	g_ptr4072F8 = fp;
	*g_ptr4072F8 = dwArg00 + g_dw407100;
	ebxOut = ebx_77;
	esiOut = esi_78;
	return dwLoc08_154;
}

// 004053C3: Register word32 fn004053C3(Register out ptr32 ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn004052AC
word32 fn004053C3(ptr32 & ebxOut, ptr32 & esiOut)
{
	word32 * fp;
	word32 dwLoc44;
	word32 dwLoc78;
	Eq_1091 dwLoc18;
	word32 * eax_9 = g_ptr407304;
	up32 dwLoc20_153;
	for (dwLoc20_153 = 0x00; dwLoc20_153 < 0x10; ++dwLoc20_153)
	{
		if (dwLoc20_153 == 0x1F)
			OpenFileMappingW(dwLoc18, 0x00, &g_t408337);
	}
	<anonymous> * eax_23 = g_ptr40730C;
	word32 ebx_31 = g_dw407308;
	word32 edx_50;
	word32 eax_47 = fn00403DE3(g_ptr4072D8, eax_9, out edx_50);
	g_t408084.u0 = (uint32) ((word32) g_t408084.u1 - dwLoc44);
	if (eax_47 == 0x00)
	{
		word32 edi_82;
		fn00404505(0x00, edx_50, 13615, dwLoc78, g_ptr4072D8, ebx_31, eax_23, 203272, out edi_82);
		g_ptr407300 = fp;
		word32 * eax_91 = g_ptr407300;
		*eax_91 += g_dw407100;
		g_dw40801C &= g_dw408000;
	}
}

// 004054E3: Register word32 fn004054E3(Register up32 ebx, Register word32 esi, Register up32 edi)
// Called from:
//      fn004050E5
word32 fn004054E3(up32 ebx, word32 esi, up32 edi)
{
	word32 dwLoc30;
	word32 dwLoc28;
	ptr32 fp;
	up32 ebx;
	word32 esi;
	up32 edi;
	bLoc28 = (byte) dwLoc28;
	word32 dwLoc48;
	word32 dwLoc08;
	word32 dwLoc34;
	word32 dwLoc24;
	word32 dwLoc10;
	eax_17 = fp - 32;
	fn00404EC0(edi);
	g_dw407FF8 = 0x00;
	while (true)
	{
		esi_540 = ϕ(esi, esi_502);
		esp_445 = fp - 0xAC;
		eax_38 = ϕ(eax_17, eax_505);
		Mem35 = ϕ(Mem31, Mem504);
		if (g_dw407FF8 >= 0x12)
			break;
		if (g_dw407FF8 == 0x1E)
			eax_498 = LockResource((void *) 22819);
		eax_505 = ϕ(eax_38, eax_498);
		Mem500 = ϕ(Mem35, Mem497);
		esi_501 = g_dw407FF8;
		esi_502 = esi_501 + 0x01;
		g_dw407FF8 = esi_501 + 0x01;
	}
	dwLoc0C_584 = eax_38;
	dwLoc28_789 = dwLoc28;
	dwLoc30_889 = dwLoc30;
	dwLoc08_586 = ~0x1002;
	esi_45 = 13615;
	edi_46 = (word32) bLoc28;
	dwLoc28_588 = edi_46 & 0x4D64;
	edi_53 = 0x252E;
l00405588:
	dwLoc30_1032 = ϕ(dwLoc30, dwLoc30_1031);
	dwLoc28_778 = ϕ(dwLoc28_588, dwLoc28_779);
	dwLoc08_678 = ϕ(dwLoc08_586, dwLoc08_679);
	dwLoc34_669 = ϕ(dwLoc34, dwLoc34_944);
	edi_512 = ϕ(edi_53, edi_513);
	esi_459 = ϕ(esi_45, esi_457);
	esp_64 = ϕ(esp_445, esp_477);
	Mem54 = ϕ(Mem52, Mem463);
	eax_55 = g_dw407090;
	if (eax_55 != 0x00)
		break;
	eax_60 = g_ptr4072D8;
	ecx_61 = eax_60->ptr000C;
	if (*ecx_61 != null)
	{
		esp_65 = esp_64 - 4;
		esp_65->dw0000 = 4224292;
		esp_65->dwFFFFFFFC = 0x01;
		esp_65->ptrFFFFFFF8 = &eax_60->dw0040 + 4;
		v18_73 = (struct Eq_1149 *) *ecx_61;
		esp_65->ptrFFFFFFF4 = v18_73;
		&v19_76.u0->unused = g_t407584.u0;
		esp_65->tFFFFFFF0.u0 = (HBITMAP) v19_76;
		fn004068C5(esp_65->tFFFFFFF0.u0, esp_65->ptrFFFFFFF4, esp_65->ptrFFFFFFF8, esp_65->dwFFFFFFFC, out eax_79, out ebx_1039, out esi_81, out edi_84);
		g_t407FE4.u0 = (ui32) 4227020;
		v21_93 = g_t407FE4.u0 - 0x00407FF0;
		g_t407FE4.u0 = (ui32) v21_93;
		g_ptr4074EC = eax_79;
	}
	edi_511 = ϕ(edi_512, edi_84);
	esp_478 = esp_64;
	esi_458 = ϕ(esi_459, esi_81);
	Mem98 = ϕ(Mem54, Mem97);
	eax_99 = g_ptr4074EC;
	v51_571 = PARITY_EVEN(eax_99);
	if (eax_99 == null)
	{
l004058DA:
		dwLoc30_1037 = ϕ(dwLoc30_1032, dwLoc30_1026, dwLoc30_1026);
		dwLoc34_944 = ϕ(dwLoc34_669, dwLoc34_667, dwLoc34_667);
		dwLoc28_779 = ϕ(dwLoc28_778, dwLoc28_602, dwLoc28_602);
		dwLoc08_676 = ϕ(dwLoc08_678, dwLoc08_652, dwLoc08_652);
		edi_513 = ϕ(edi_511, edi_153, edi_153);
		esp_477 = ϕ(esp_478, esp_142, esp_142);
		esi_457 = ϕ(esi_458, esi_162, esi_162);
		eax_460 = dwLoc08_676 ^ esi_457;
		eax_462 = eax_460 + 0x01 ^ esi_457;
		dwLoc08_679 = eax_462;
		dwLoc30_1031 = dwLoc30_1037;
		if (eax_462 != ~0x11F2)
			goto l00405588;
	}
	dwLoc10_589 = 0x00;
	ecx_107 = ~0x1002;
	dwLoc30_1024 = dwLoc30_1032;
	dwLoc30_1026 = dwLoc30_1024;
	dwLoc10_859 = ϕ(dwLoc10_589, dwLoc10_860);
	dwLoc34_667 = ϕ(dwLoc34_669, dwLoc34_661);
	dwLoc08_652 = ϕ(dwLoc08_678, dwLoc08_934);
	wLoc30_613 = (word16) dwLoc30_1026;
	dwLoc28_602 = ϕ(dwLoc28_778, dwLoc28_780);
	esi_162 = ϕ(esi_458, esi_404);
	edi_153 = ϕ(edi_511, edi_514);
	esp_137 = ϕ(esp_478, esp_414);
	v50_570 = ϕ(v51_571, v52_572);
	ecx_114 = ϕ(ecx_107, ecx_406);
	esp_138 = esp_137 - 4;
	esp_138->ptr0000 = (char *) 0x61;
	ebx_141 = esp_138->ptr0000;
	esp_142 = (char *) &esp_138->ptr0000 + 4;
	edx_145 = (uint32) (0x0002CB38 % ebx_141);
	eax_146 = (uint32) (0x0002CB38 /u ebx_141);
	if (edx_145 > 0x8A || ecx_114 == ~0x1032)
		goto l004058DA;
	ebx_155 = (word32) g_t408010.u0;
	ebx_157 = ebx_155 - dwLoc28_602 - (word32) (eax_146 < edi_153);
	g_t408010.u1 = (word32) ebx_157;
	ecx_163 = esi_162 ^ ~0x1006;
	ebx_164 = ecx_114 ^ esi_162;
	ecx_166 = ecx_163 + edi_153;
	edx_eax_168 = (uint64) (ebx_164 + 0x252E);
	edx_170 = (uint32) (edx_eax_168 % ecx_166);
	esp_138->ptr0000 = &g_b40752C;
	esp_138->ptrFFFFFFFC = &g_b40753C;
	dwLoc0C_605 = edx_170 << 0x03;
	eax_178 = _stricmp(esp_138->ptrFFFFFFFC, esp_138->ptr0000);
	ecx_196 = (word32) wLoc30_613;
	v35_197 = dwLoc28_602 ^ ecx_196;
	dwLoc28_615 = v35_197;
	esp_201 = (char *) &esp_138->ptr0000 + 4;
	dwLoc30_902 = dwLoc30_1026;
	if (eax_178 != 0x00)
	{
		v36_208 = (char *) g_a407498[edx_170];
		esp_138->ptr0000 = v36_208;
		esp_138->ptrFFFFFFFC = &g_b4074C4;
		esp_138->dwFFFFFFF8 = 0x00407340;
		esp_138->dwFFFFFFF4 = 0x03;
		esp_138->ptrFFFFFFF0 = 4224240;
		v37_219 = g_ptr4074EC;
		esp_138->ptrFFFFFFEC = v37_219;
		&v38_222.u0->unused = g_t407584.u0;
		esp_223 = esp_138 - 24;
		esp_138->tFFFFFFE8.u0 = (HBITMAP) v38_222;
		fn004068C5(esp_138->tFFFFFFE8.u0, esp_138->ptrFFFFFFEC, esp_138->ptrFFFFFFF0, esp_138->dwFFFFFFF4, out eax_1040, out ebx_226, out esi_227, out edi_230);
		g_dw408028 = 0x10;
		while (true)
		{
			dwLoc30_883 = ϕ(dwLoc30_884, dwLoc30_902);
			dwLoc28_783 = ϕ(dwLoc28_784, dwLoc28_615);
			dwLoc10_675 = ϕ(dwLoc10_963, dwLoc10_859);
			dwLoc34_664 = ϕ(dwLoc34_939, dwLoc34_667);
			dwLoc0C_658 = ϕ(dwLoc0C_937, dwLoc0C_605);
			dwLoc08_649 = ϕ(dwLoc08_929, dwLoc08_652);
			edi_543 = ϕ(edi_544, edi_230);
			esi_537 = ϕ(esi_538, esi_227);
			ebx_527 = ϕ(ebx_528, ebx_226);
			esp_240 = ϕ(esp_517, esp_223);
			Mem237 = ϕ(Mem453, Mem236);
			if (g_dw408028 == 0x00)
				break;
			if (g_dw408028 == 0x19)
			{
				esp_428 = esp_240 - 4;
				esp_428->dw0000 = 0x4307;
				esp_428->dwFFFFFFFC = dwLoc24;
				esp_428->dwFFFFFFF8 = 16173;
				esp_428->dwFFFFFFF4 = 0x484E;
				esp_428->dwFFFFFFF0 = 32372;
				esp_428->dwFFFFFFEC = 35991;
				esp_442 = esp_428 - 24;
				esp_428->dwFFFFFFE8 = dwLoc10_675;
			}
			dwLoc10_963 = dwLoc10_675;
			dwLoc34_939 = dwLoc34_664;
			dwLoc0C_937 = dwLoc0C_658;
			dwLoc08_929 = dwLoc08_649;
			dwLoc30_884 = dwLoc30_883;
			dwLoc28_784 = dwLoc28_783;
			edi_544 = edi_543;
			esi_538 = esi_537;
			ebx_528 = ebx_527;
			esp_517 = esp_240;
			Mem449 = Mem237;
			eax_450 = g_dw408028;
			g_dw408028 = eax_450 - 0x01;
		}
		esp_241 = esp_240 + 0x1C;
	}
	dwLoc30_882 = ϕ(dwLoc30_883, dwLoc30_902);
	dwLoc10_856 = ϕ(dwLoc10_675, dwLoc10_859);
	dwLoc28_782 = ϕ(dwLoc28_783, dwLoc28_615);
	dwLoc34_663 = ϕ(dwLoc34_664, dwLoc34_667);
	dwLoc0C_657 = ϕ(dwLoc0C_658, dwLoc0C_605);
	dwLoc08_648 = ϕ(dwLoc08_649, dwLoc08_652);
	edi_542 = ϕ(edi_543, edi_153);
	esi_536 = ϕ(esi_537, esi_162);
	esp_535 = ϕ(esp_241, esp_201);
	ebx_526 = ϕ(ebx_527, ebx_164);
	eax_243 = ~0x11F2;
	dwLoc14_617 = ~0x24DD;
	do
	{
		dwLoc30_629 = ϕ(dwLoc30_882, dwLoc30_903);
		dwLoc14_625 = ϕ(dwLoc14_617, dwLoc14_638);
		dwLoc10_623 = ϕ(dwLoc10_856, dwLoc10_863);
		edi_310 = ϕ(edi_542, edi_355);
		esi_309 = ϕ(esi_536, esi_344);
		esp_264 = ϕ(esp_535, esp_375);
		Mem256 = ϕ(Mem246, Mem353);
		ebx_253 = ϕ(ebx_526, ebx_534);
		eax_247 = ϕ(eax_243, eax_345);
		switch (eax_247)
		{
		case ~0x11D7:
			eax_295 = g_ptr4072D8;
			eax_296 = eax_295->ptr000C;
			v34_299 = (struct Eq_1149 *) *eax_296;
			eax_302 = (word32) g_t40800C.u1;
			eax_303 = eax_302 ^ g_dw408030;
			g_t40800C.u0 = (ui32) eax_303;
			eax_313 = fnFFFFEFFC(v34_299, 4224568);
			g_dw407514 = eax_313;
			break;
		case ~0x11C2:
			eax_262 = g_ptr40711C;
			eax_263 = (struct Eq_1149 *) *eax_262;
			esp_265 = esp_264 - 4;
			esp_265->dw0000 = 4224220;
			esp_265->ptrFFFFFFFC = eax_263;
			esp_265->dwFFFFFFF8 = 0x02;
			esp_265->ptrFFFFFFF4 = 0x004071A4;
			esp_265->ptrFFFFFFF0 = eax_263;
			&v40_275.u0->unused = g_t407584.u0;
			esp_276 = esp_265 - 20;
			esp_265->tFFFFFFEC.u0 = (HBITMAP) v40_275;
			P_288 = fn004068C5(esp_265->tFFFFFFEC.u0, esp_265->ptrFFFFFFF0, esp_265->ptrFFFFFFF4, esp_265->dwFFFFFFF8, out eax_278, out ebx_279, out esi_280, out edi_283);
			v55_575 = false;
			esp_292 = &esp_265->dw0000 + 1;
			dwLoc10_622 = eax_278;
			break;
		}
		dwLoc10_863 = ϕ(dwLoc10_623, dwLoc10_623, dwLoc10_622);
		ebx_534 = ϕ(ebx_253, ebx_253, ebx_279);
		esp_375 = ϕ(esp_312, esp_264, esp_292);
		edi_355 = ϕ(edi_310, edi_310, edi_283);
		esi_344 = ϕ(esi_309, esi_309, esi_280);
		if (!OVERFLOW<word32>(dwLoc48 - 0x8521))
			dwLoc30_630 = dwLoc30_629 | 0x5255;
		dwLoc30_1027 = ϕ(dwLoc30_629, dwLoc30_630);
		eax_345 = dwLoc14_625 - 0x01 ^ esi_344;
		ecx_347 = eax_345 ^ esi_344;
		g_t407FD4.u0 = (int32) 4227212;
		v41_349 = g_t407FD4.u0 + 0x00408084;
		g_t407FD4.u0 = (int32) v41_349;
		v42_351 = g_t407FD4.u0 - 4226992;
		g_t407FD4.u0 = (int32) v42_351;
		dwLoc14_638 = ecx_347;
		ecx_356 = ecx_347 + edi_355;
		dwLoc30_903 = dwLoc30_1027;
	} while (ecx_356 != 0x00);
	eax_361 = dwLoc08_648 ^ esi_344;
	ecx_362 = esi_344 ^ ~0x1006;
	ecx_364 = ecx_362 + edi_355;
	eax_365 = eax_361 + edi_355;
	edx_eax_366 = (uint64) eax_365;
	edx_368 = (uint32) (edx_eax_366 % ecx_364);
	esp_376 = esp_375 - 4;
	esp_376->dw0000 = edx_368 << 0x03;
	esp_376->dwFFFFFFFC = dwLoc0C_657;
	P_388 = fn00404673(esp_376->dwFFFFFFFC, esp_376->dw0000);
	esp_389 = &esp_376->dw0000 + 1;
	dwLoc34_659 = 0x00;
l00405849:
	dwLoc30_1038 = ϕ(dwLoc30_1027, dwLoc30_1034);
	dwLoc08_935 = ϕ(dwLoc08_648, dwLoc08_934);
	dwLoc10_861 = ϕ(dwLoc10_863, dwLoc10_860);
	dwLoc34_660 = ϕ(dwLoc34_659, dwLoc34_673);
	edi_515 = ϕ(edi_355, edi_514);
	v53_573 = ϕ(P_388, v52_572);
	esp_415 = ϕ(esp_389, esp_568);
	esi_405 = ϕ(esi_344, esi_404);
	ebx_402 = ϕ(ebx_534, ebx_401);
	v56_576 = dwLoc34_660 >= 0x1A;
	dwLoc30_1033 = dwLoc30_1038;
}

// 004059DC: Register word32 fn004059DC(Register (ptr32 (ptr32 Eq_2331)) esi, Register (ptr32 Eq_1149) edi, Stack (ptr32 word32) dwArg04, Stack Eq_1060 dwArg08, Stack (ptr32 (ptr32 Eq_2320)) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14, Stack (ptr32 word32) dwArg18, Stack (ptr32 word32) dwArg1C, Stack Eq_1060 dwArg20)
// Called from:
//      fn004068C5
word32 fn004059DC(struct Eq_2331 ** esi, struct Eq_1149 * edi, word32 * dwArg04, Eq_1060 dwArg08, struct Eq_2320 ** dwArg0C, word32 * dwArg10, word32 * dwArg14, word32 * dwArg18, word32 * dwArg1C, Eq_1060 dwArg20)
{
	struct Eq_2286 * fp;
	int32 dwLoc2C;
	Eq_405 dwLoc14;
	ui32 ebx_11 = ~0x1002;
	do
	{
		g_t408084.u0 = 0x00;
		while (g_t408084.u0 < 0x1D)
		{
			if (g_t408084.u0 == 0x26)
				SetClassLongW(dwLoc14, dwLoc2C, 13037);
			g_t408084.u0 = (uint32) (g_t408084.u0 + 0x01);
		}
		Eq_1060 ecx_203;
		up32 eax_197;
		if ((uint32) ((uint64) ebx_11 % 0x43) != 118 && ebx_11 != ~0x1007)
		{
			if ((uint32) ((uint64) ebx_11 % 118) < 0x98 && ebx_11 != ~0x1005)
			{
				if ((uint32) ((uint64) ebx_11 % 101) <= 0x0896 && ebx_11 != ~0x100B)
				{
					if ((uint32) ((uint64) ebx_11 % 0x87) != 0x0103 && ebx_11 != ~0x1009)
						goto l00405C0F;
					struct Eq_2331 * eax_184 = *esi;
					*dwArg1C = edi + eax_184->dw0024 / 64;
					up32 ecx_196 = eax_184->dw0014;
					eax_197 = eax_184->dw0018;
					if (ecx_196 > eax_197)
						eax_197 = ecx_196;
					ecx_203 = dwArg20;
					goto l00405C0D;
				}
				*dwArg10 = ~0x1006;
				*dwArg14 = ~0x1006;
				*dwArg18 = ~0x1004;
			}
			else
			{
				struct Eq_2320 * eax_141 = edi + edi->dw003C / 64;
				*dwArg0C = (struct Eq_2320 **) eax_141;
				*esi = (struct Eq_2331 **) (edi + eax_141->dw0078 / 64);
			}
		}
		else
		{
			struct Eq_2331 * eax_76 = *esi;
			word32 eax_79 = eax_76->dw0020;
			*dwArg04 = edi + eax_76->dw001C / 64;
			word32 dwLoc30_294;
			for (dwLoc30_294 = 0x17; dwLoc30_294 != 0x00; --dwLoc30_294)
			{
				if (dwLoc30_294 == 0x18)
					fp->dwFFFFFFF4 = 0x499D;
			}
			ecx_203 = dwArg08;
			eax_197 = edi + eax_79 / 64;
l00405C0D:
			ecx_203->lStructSize = eax_197;
		}
l00405C0F:
		ebx_11 = (ebx_11 ^ 13615) + 0x01 ^ 13615;
	} while (ebx_11 != ~0x1032);
	return 13615;
}

// 00405C2A: Register Eq_1091 Win32CrtStartup()
Eq_1091 Win32CrtStartup()
{
	ptr32 fp;
	word32 ebp;
	word32 esi;
	word32 edi;
	word32 ebx;
	struct <anonymous> tLoc14;
	struct <anonymous> tLoc0C;
	struct <anonymous> tLoc08;
	word32 dwLoc0294;
	word32 dwLoc02BC;
	word32 dwLoc034C;
	word32 dwLoc1C;
	word16 wLoc03FC;
	word32 dwLoc0340;
	word16 wLoc03A8;
	word32 dwLoc0250;
	word32 dwLoc02C4;
	byte bLoc030C;
	word32 dwLoc24;
	word32 dwLoc10;
	eax_15 = SHLWAPI.dll!StrSpnA(4224348, 4224344);
	P_809 = SLICE(SCZOP_19, bool, 5);
	if (eax_15 <= 0x0A)
	{
		esp_14->dwFFFFFFFC = esi;
		esp_14->dwFFFFFFF8 = edi;
		g_t408018.u0 = 0x00;
		do
		{
			Mem33 = ϕ(Mem29, Mem52);
			edi_34.u0 = g_t408018.u0;
			g_t408018.u0 = (word32) edi_34.u0 + 1;
			if (g_t408018.u0 == 0x1B)
			{
				esp_14->tFFFFFFF4.u0 = 15191;
				esp_14->tFFFFFFF0.u0 = 0x25A2;
				esp_14->tFFFFFFEC.u0 = 27777;
				esp_14->tFFFFFFE8.u0 = (HBITMAP) dwLoc1C;
				CreateCaret(esp_14->tFFFFFFE8.u1, esp_14->tFFFFFFEC.u1, esp_14->tFFFFFFF0.u0, esp_14->tFFFFFFF4.u1);
			}
			esp_71 = esp_14 - 8;
			Mem52 = ϕ(Mem49, Mem36);
		} while (g_t408018.u0 < 22);
		edi_55 = ~0x1002;
		fn0040417E(fp - 4, &tLoc14, ~0x1002);
		eax_68 = g_dw408000;
		eax_69 = eax_68 | dwLoc0294;
		g_dw408000 = eax_69;
		esp_14->tFFFFFFF4.u0 = 0x46;
		esp_14->tFFFFFFF4.u0 = 0x3A;
		esp_14->tFFFFFFF4.u0 = 0x5C;
		esi_88.u0 = esp_14->tFFFFFFF4.u0;
		esp_14->tFFFFFFF4.u0 = 0x4A;
		eax_98 = g_ptr40813A;
		ecx_99 = g_dw408088;
		v18_100 = *eax_98 ^ ecx_99;
		*eax_98 = v18_100;
		eax_103.u0 = esp_14->tFFFFFFF4.u0;
		esp_14->tFFFFFFF4.u0 = 0x48;
		ecx_137.u0 = esp_14->tFFFFFFF4.u0;
		esp_14->tFFFFFFF4.u0 = 0x44;
		esp_14->tFFFFFFF4.u0 = 0x4B;
		edx_158.u0 = esp_14->tFFFFFFF4.u0;
		g_t408054.u0 = (uint32) 0x00408004;
		v27_176 = g_t408054.u0 | 0x00408010;
		g_t408054.u0 = (uint32) v27_176;
		esp_14->tFFFFFFF4.u0 = 0x44;
		g_t408050.u0 = 0x00;
		while (true)
		{
			cx_271 = (word16) ecx_137;
			dx_269 = (word16) edx_158;
			eax_211 = ϕ(eax_103, eax_556);
			ax_219 = (word16) eax_211;
			esp_206 = esp_14 - 0x0C;
			Mem197 = ϕ(Mem193, Mem540);
			if (g_t408050.u0 >= 0x15)
				break;
			if (g_t408050.u0 == 0x17)
			{
				esp_14->tFFFFFFF0.u0 = (HBITMAP) dwLoc1C;
				esp_14->tFFFFFFEC.u0 = (HBITMAP) dwLoc10;
				esp_14->tFFFFFFE8.u0 = (HBITMAP) dwLoc10;
				esp_14->tFFFFFFE4 = (Eq_414) &g_dw408030;
				eax_534 = GetMessageW(esp_14->tFFFFFFE4, esp_14->tFFFFFFE8.u1, esp_14->tFFFFFFEC.u0, esp_14->tFFFFFFF0.u0);
			}
			eax_556 = ϕ(eax_211, eax_534);
			Mem536 = ϕ(Mem197, Mem533);
			edi_537.u0 = g_t408050.u0;
			g_t408050.u0 = (word32) edi_537.u0 + 1;
		}
		di_265 = (word16) esi_88;
		esi_207.u0 = esp_14->tFFFFFFF4.u0;
		si_209 = (word16) esi_207;
		si_215 = (word16) eax_211;
		si_221 = (word16) edx_158;
		si_252 = (word16) eax_211;
		eax_224 = (word32) wLoc03FC;
		v36_225 = g_dw407FC4 | eax_224;
		g_dw407FC4 = v36_225;
		eax_228.u0 = esp_14->tFFFFFFF4.u0;
		ax_232 = (word16) eax_228;
		esp_14->tFFFFFFF4.u0 = 0x44;
		eax_234.u0 = esp_14->tFFFFFFF4.u0;
		ax_238 = (word16) eax_234;
		esp_14->tFFFFFFF4.u0 = 0x4C;
		eax_240.u0 = esp_14->tFFFFFFF4.u0;
		ax_242 = (word16) eax_240;
		esp_14->tFFFFFFF4.u0 = 464;
		esi_255 = g_ptr40819A;
		esi_256 = *esi_255;
		v37_258 = g_t40805C.u0 + esi_256 + (word32) (dwLoc034C < esi_88);
		g_t40805C.u0 = (ui32) v37_258;
		si_267 = (word16) ecx_137;
		memset(esp_14->tFFFFFFEC.u2, esp_14->tFFFFFFF0.u0, esp_14->tFFFFFFF4.u2);
		esp_14->tFFFFFFF4.u0 = (ptr32) (fp - 0x021C);
		eax_281 = SHLWAPI.dll!PathMakePrettyW(di_265, si_209, si_215, si_221, si_252, si_267, dx_269, ax_219, cx_271, ax_232, ax_238, ax_242, ax_242, 0x00, fp - 484, 0x00, 0x2E);
		if (eax_281 == 0x00)
		{
			edx_803 = edx_283;
			esp_565 = esp_280;
			g_dw407FF8 = 0x00;
			while (true)
			{
				esp_451 = esp_565;
				Mem373 = ϕ(Mem369, Mem520);
				if (g_dw407FF8 == 0x18)
				{
					esp_510 = esp_565 - 4;
					esp_510->t0000.u0 = (ptr32) dwLoc24;
					esp_510->tFFFFFFFC = (BYTE *) 0x6AB0;
					LookupIconIdFromDirectory(esp_510->tFFFFFFFC, esp_510->t0000.u1);
				}
				Mem516 = ϕ(Mem373, Mem513);
				edi_517 = g_dw407FF8;
				g_dw407FF8 = edi_517 + 0x01;
			}
		}
		else
		{
			eax_292 = fn0040422E(&tLoc0C, fp - 16);
			edi_299 = 0x00;
			if (eax_292 < 0x3688)
			{
				esi_305.u0 = g_t40800C.u0;
				g_t40800C.u0 = (ui32) (esi_305 & 0x558D);
			}
			Mem316 = ϕ(Mem314, Mem310);
			esi_317 = g_dw4080A0;
			esi_319 = esi_317 - dwLoc0340;
			g_dw4080A0 = esi_319;
			fn0040422E(&g_dw407548, 0x00);
			fn0040417E(fp - 4, &g_dw40754C, 0x00);
		}
	}
	else
	{
		eax_541 = 0x00;
		SZ_542 = cond(0x00);
		S_813 = (bool) SZ_542;
		Z_825 = SLICE(SZ_542, bool, 2);
		O_543 = false;
		C_544 = false;
		Z_824 = Z_825;
		Top_815 = 0;
		S_812 = S_813;
		P_808 = P_809;
		O_806 = O_543;
		esi_805 = ϕ(esi, esi_457);
		edx_798 = ϕ(edx_17, edx_799);
		edi_796 = ϕ(edi, edi_452);
		ecx_795 = ϕ(ecx_16, ecx_501);
		eax_794 = ϕ(eax_541, eax_506);
		C_792 = ϕ(C_544, C_793);
		ebp_548 = ebp;
		esp_549 = fp;
		return eax_794;
	}
}

// 00406191: Register (ptr32 int16) cyflorvyce_a_LBPMgm__(Stack int32 dwArg04, Stack char bArg08)
int16 * cyflorvyce_a_LBPMgm__(int32 dwArg04, char bArg08)
{
	ui32 * edi_10 = g_ptr4081C2;
	*edi_10 &= g_dw408068;
	g_dw40804C -= g_t407FC8.u0;
	g_t407FDC.u1 = (word32) ((word32) g_t407FDC.u0 + g_dw407FB0);
	return (int16 *) <invalid>;
}

Eq_3697 g_t4061DE = // 004061DE
	{
		-2115204267,
		~0x1002,
		419186119,
	};
// 004068C5: FlagGroup bool fn004068C5(Stack Eq_405 dwArg04, Stack (ptr32 Eq_1149) dwArg08, Stack ptr32 dwArg0C, Stack int32 dwArg10, Register out Eq_405 eaxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out (ptr32 Eq_1149) ediOut)
// Called from:
//      fn00404673
//      fn004054E3
bool fn004068C5(Eq_405 dwArg04, struct Eq_1149 * dwArg08, ptr32 dwArg0C, int32 dwArg10, union Eq_405 & eaxOut, ptr32 & ebxOut, ptr32 & esiOut, struct Eq_1149 & ediOut)
{
}

// 00406D17: Register uint32 Cn_zb_kimt(Stack int32 dwArg04)
uint32 Cn_zb_kimt(int32 dwArg04)
{
	ptr32 fp;
	up32 ebx;
	up32 dwLoc1C;
	Eq_371 dwLoc24;
	Eq_371 ecx_14 = g_t408064.u0 - g_ptr4081B6->u2 - (word32) (ebx < dwLoc1C);
	g_t408064.u0 = (uint32) ecx_14;
	word32 * esi_18 = g_ptr408146;
	*esi_18 = *esi_18 - (word32) g_t408078.u1 - (word32) (dwLoc24 < ecx_14);
	ui32 * esi_23 = g_ptr40813E;
	*esi_23 = *esi_23 + (word32) g_t40807C.u0 + (word32) (ecx_14 < fp - 4);
	return <invalid>;
}

// 00406D5B: Register uint32 _GB_EN_JsqcfcxodtJ_n_j(Stack (ptr32 uint16) ptrArg04)
uint32 _GB_EN_JsqcfcxodtJ_n_j(uint16 * ptrArg04)
{
	uint32 dwLoc24;
	ui32 * edi_10 = g_ptr40816A;
	*edi_10 |= (word32) g_t408050.u1;
	uint32 edx_14 = (word32) g_b407FB8;
	g_t408054.u0 = (uint32) (g_t408054.u0 | edx_14);
	g_t407FD4.u0 = (int32) (g_t407FD4.u0 - *g_ptr408196 - (word32) (edx_14 < dwLoc24));
	return <invalid>;
}

// 00406DA0: Register int16 ti_o__o_s(Stack (ptr32 int16) ptrArg04)
int16 ti_o__o_s(int16 * ptrArg04)
{
	up32 eax;
	up32 dwLoc1C;
	g_t407FE4.u0 = (ui32) (g_t407FE4.u0 ^ g_t408078.u0);
	g_t407FD8.u1 = (word32) (g_t407FD8.u1 + g_ptr408182->u1 + (word32) (dwLoc1C < eax));
	g_dw408028 += (word32) g_t408044.u1;
	return <invalid>;
}

// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 * g_ptr407030 = &g_dw401040; // 00407030
ui32 ** g_ptr40703C = &g_ptr407030; // 0040703C
ui32 *** g_ptr407040 = &g_ptr40703C; // 00407040
word32 g_dw407068 = 0x004010AC; // 00407068
word32 * g_ptr407080 = &g_dw407068; // 00407080
struct Eq_513 * g_ptr40708C = null; // 0040708C
word32 g_dw407090 = 0x00; // 00407090
word32 g_dw407094 = ~0x2032; // 00407094
word32 g_dw407098 = ~0x3022; // 00407098
int32 g_dw40709C = 15917; // 0040709C
word32 * g_ptr4070D4 = &g_dw407094; // 004070D4
int32 * g_ptr4070DC = &g_dw40709C; // 004070DC
word32 g_dw4070F0 = 0x00; // 004070F0
word32 g_dw4070F4 = 0x00; // 004070F4
word32 g_dw4070F8 = 0x00; // 004070F8
word32 g_dw4070FC = 0x00; // 004070FC
ui32 g_dw407100 = 0x00; // 00407100
word32 g_dw407104 = 0x00; // 00407104
struct Eq_1149 * g_ptr407108 = null; // 00407108
Eq_511 g_t407110 = // 00407110
	{
		&g_ptr40708C,
		&g_ptr407108,
		&g_dw4070F8,
		&g_dw4070FC,
		0x00,
	};
struct Eq_1149 ** g_ptr40711C = &g_ptr407108; // 0040711C
struct Eq_511 * g_ptr4072D8 = &g_t407110; // 004072D8
Eq_779 g_t4072EC = 0x07860667; // 004072EC
word32 g_dw4072F0 = 0x05456465; // 004072F0
word32 g_dw4072F4 = 0x05475774; // 004072F4
word32 * g_ptr4072F8 = null; // 004072F8
<anonymous> * g_ptr4072FC = &g_t4017D8; // 004072FC
word32 * g_ptr407300 = &g_dw6576405; // 00407300
word32 * g_ptr407304 = &g_dw6546406; // 00407304
word32 g_dw407308 = 6624267; // 00407308
<anonymous> * g_ptr40730C = &g_tE61A67; // 0040730C
struct Eq_638 * g_ptr407310 = &g_t403DB3; // 00407310
ptr32 g_ptr407314 = 0x00077718; // 00407314
word32 g_dw407318 = 0x06751718; // 00407318
word32 g_dw40731C = 0x00060718; // 0040731C
word32 g_dw407320 = 0x07655767; // 00407320
Eq_3693 g_a407498[] = // 00407498
	{
	};
word32 * g_ptr4074B8 = &g_dw342509; // 004074B8
char g_b4074C4 = 'f'; // 004074C4
word32 g_dw4074CC = 488810; // 004074CC
word32 g_dw4074D0 = 0x00077777; // 004074D0
word32 g_dw4074D4 = 0x08764664; // 004074D4
word32 * g_ptr4074D8 = &g_dw42406; // 004074D8
ui8 g_a4074DC[16] = // 004074DC
	{
		0x49,
		0x6B,
		0x1C,
		0x40,
		0x1E,
		0x61,
		0x6D,
		0x4F,
		0x6C,
		0x6C,
		0x1E,
		0x6B,
		0x1D,
		0x1D,
		0x90,
		0x00,
	};
struct Eq_1149 * g_ptr4074EC = null; // 004074EC
word32 g_dw407514 = 0x00; // 00407514
byte g_a407517[10] = // 00407517
	{
		0x00,
		100,
		0x1D,
		0x1C,
		0x1E,
		100,
		0x6B,
		0x62,
		121,
		0x90,
	};
char g_b40752C = 'K'; // 0040752C
char g_b40753C = 'J'; // 0040753C
word32 g_dw407548 = 0x00787616; // 00407548
word32 g_dw40754C = 3479004; // 0040754C
word32 g_dw407550 = 0x08974774; // 00407550
word32 * g_ptr407554 = &g_dw76860438; // 00407554
<anonymous> * g_ptr407580 = fn004068C5; // 00407580
Eq_405 g_t407584 = // 00407584
	{
		&g_t4061DE
	};
ui8 g_a407637[10] = // 00407637
	{
		55,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
up32 g_dw407FA8 = 1070606; // 00407FA8
ui32 g_dw407FAC = 1081060; // 00407FAC
word32 g_dw407FB0 = 0x00103A21; // 00407FB0
ui32 g_dw407FB4 = 0x001025A2; // 00407FB4
byte g_b407FB8 = 33; // 00407FB8
word32 g_dw407FBC = 1080201; // 00407FBC
Eq_25 g_t407FC0 = // 00407FC0
	{
		0x001062D3
	};
ui32 g_dw407FC4 = 0x001071E0; // 00407FC4
Eq_113 g_t407FC8 = // 00407FC8
	{
		1077672
	};
word32 g_dw407FD0 = 1075917; // 00407FD0
Eq_2087 g_t407FD4 = // 00407FD4
	{
		0x001073F3
	};
Eq_96 g_t407FD8 = // 00407FD8
	{
		0x1AB5
	};
Eq_2987 g_t407FDC = // 00407FDC
	{
		0x37BE
	};
ui32 g_dw407FE0 = 1074404; // 00407FE0
Eq_384 g_t407FE4 = // 00407FE4
	{
		0x00106825
	};
ui32 g_dw407FE8 = 0x001037F9; // 00407FE8
word32 g_dw407FEC = 0x00100EA4; // 00407FEC
word32 g_dw407FF0 = 1081180; // 00407FF0
up32 g_dw407FF4 = 0x0010397D; // 00407FF4
up32 g_dw407FF8 = 0x001066F0; // 00407FF8
Eq_356 g_t407FFC = // 00407FFC
	{
		0x0902
	};
ui32 g_dw408000 = 0x001029B8; // 00408000
up32 g_dw408008 = 0x00102A59; // 00408008
Eq_33 g_t40800C = // 0040800C
	{
		0x00101BEC
	};
Eq_1885 g_t408010 = // 00408010
	{
		19665
	};
ui32 g_dw408014 = 0x001009B9; // 00408014
Eq_288 g_t408018 = // 00408018
	{
		0x001002E9
	};
ui32 g_dw40801C = 0x00106B90; // 0040801C
word32 g_dw408020 = 0x00104926; // 00408020
Eq_129 g_t408024 = // 00408024
	{
		0x00106D36
	};
ui32 g_dw408028 = 0x00100040; // 00408028
word32 g_dw40802C = 0x00106860; // 0040802C
ui32 g_dw408030 = 0x00102F73; // 00408030
uint32 g_dw408034 = 0x00107253; // 00408034
Eq_22 g_t408038 = // 00408038
	{
		0x00105E1C
	};
Eq_487 g_t408044 = // 00408044
	{
		1051771
	};
up32 g_dw408048 = 0x001001CD; // 00408048
ui32 g_dw40804C = 1071657; // 0040804C
Eq_249 g_t408050 = // 00408050
	{
		0x0010394C
	};
Eq_150 g_t408054 = // 00408054
	{
		1077163
	};
word32 g_dw408058 = 1076201; // 00408058
Eq_4 g_t40805C = // 0040805C
	{
		0x0010090F
	};
ui32 g_dw408060 = 0x00106C32; // 00408060
Eq_371 g_t408064 = // 00408064
	{
		0x00100279
	};
uint32 g_dw408068 = 0x00107240; // 00408068
uint32 g_dw40806C = 0x00107602; // 0040806C
Eq_195 g_t408070 = // 00408070
	{
		0x001070AB
	};
word32 g_dw408074 = 1061206; // 00408074
Eq_747 g_t408078 = // 00408078
	{
		1070610
	};
Eq_306 g_t40807C = // 0040807C
	{
		0x96
	};
Eq_192 g_t408080 = // 00408080
	{
		0x0010480D
	};
Eq_116 g_t408084 = // 00408084
	{
		0x00100710
	};
word32 g_dw408088 = 0x00100A80; // 00408088
ui32 g_dw40808C = 1077177; // 0040808C
Eq_104 g_t408090 = // 00408090
	{
		0xA3
	};
Eq_46 g_t408098 = // 00408098
	{
		0x00103F41
	};
Eq_150 g_t40809C = // 0040809C
	{
		1066899
	};
word32 g_dw4080A0 = 1068028; // 004080A0
word32 g_dw4080A4 = 0x00104210; // 004080A4
ui32 * g_ptr4080D2 = &g_dw407FAC; // 004080D2
ui32 * g_ptr4080D6 = &g_dw407FB0; // 004080D6
word32 * g_ptr4080DA = &g_dw407FB4; // 004080DA
word32 * g_ptr4080DE = &g_dw407FB8; // 004080DE
word32 * g_ptr4080E2 = &g_dw407FBC; // 004080E2
word32 * g_ptr4080F6 = &g_dw407FD0; // 004080F6
word32 * g_ptr4080FA = &g_dw407FD4; // 004080FA
word32 * g_ptr408102 = &g_dw407FDC; // 00408102
word32 * g_ptr40810E = &g_dw407FE8; // 0040810E
byte * g_ptr408112 = &g_b407FEC; // 00408112
word32 * g_ptr408116 = &g_dw407FF0; // 00408116
word32 * g_ptr40811E = &g_dw407FF8; // 0040811E
ui32 * g_ptr408126 = &g_dw408000; // 00408126
ui32 * g_ptr408132 = &g_dw40800C; // 00408132
ui32 * g_ptr408136 = &g_dw408010; // 00408136
ui32 * g_ptr40813A = &g_dw408014; // 0040813A
ui32 * g_ptr40813E = &g_dw408018; // 0040813E
word32 * g_ptr408146 = &g_dw408020; // 00408146
word32 * g_ptr408152 = &g_dw40802C; // 00408152
union Eq_434 * g_ptr40815E = &g_t408038; // 0040815E
ui32 * g_ptr40816A = &g_dw408044; // 0040816A
union Eq_3637 * g_ptr408182 = &g_t40805C; // 00408182
byte * g_ptr408192 = &g_b40806C; // 00408192
ui32 * g_ptr408196 = &g_dw408070; // 00408196
word32 * g_ptr40819A = &g_dw408074; // 0040819A
ui32 * g_ptr40819E = &g_dw408078; // 0040819E
ui32 * g_ptr4081B2 = &g_dw40808C; // 004081B2
union Eq_348 * g_ptr4081B6 = &g_t408090; // 004081B6
ui32 * g_ptr4081C2 = &g_dw40809C; // 004081C2
word32 * g_ptr4081C6 = &g_dw4080A0; // 004081C6
ui32 * g_ptr4081CA = &g_dw4080A4; // 004081CA
CHAR g_t408236 = 'I'; // 00408236
CHAR g_t408263 = 'Q'; // 00408263
WCHAR g_t40831E = 'U'; // 0040831E
WCHAR g_t408328 = 'T'; // 00408328
WCHAR g_t408337 = 'Z'; // 00408337
WCHAR g_t408398 = 'U'; // 00408398
// subject_import.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40F08C = 0xF138; // 0040F08C
word32 g_dw40F090 = 61766; // 0040F090
word32 g_dw40F094 = 0xF162; // 0040F094
word32 g_dw40F098 = 0xF170; // 0040F098
word32 g_dw40F09C = 0xF17C; // 0040F09C
word32 g_dw40F0A0 = 0xF18A; // 0040F0A0
word32 g_dw40F0A4 = 61858; // 0040F0A4
word32 g_dw40F0A8 = 0xF1B2; // 0040F0A8
word32 g_dw40F0AC = 0xF1C4; // 0040F0AC
word32 g_dw40F0B0 = 0xF1D0; // 0040F0B0
word32 g_dw40F0B4 = 0xF1E0; // 0040F0B4
word32 g_dw40F0B8 = 0xF1EE; // 0040F0B8
word32 g_dw40F0C0 = 0xF208; // 0040F0C0
word32 g_dw40F0C4 = 0xF21A; // 0040F0C4
word32 g_dw40F0CC = 62000; // 0040F0CC
word32 g_dw40F0D0 = 62020; // 0040F0D0
word32 g_dw40F0D4 = 62036; // 0040F0D4
word32 g_dw40F0D8 = 62060; // 0040F0D8
word32 g_dw40F0DC = 0xF27A; // 0040F0DC
word32 g_dw40F0E0 = 0xF290; // 0040F0E0
word32 g_dw40F0E4 = 62118; // 0040F0E4
word32 g_dw40F0E8 = 0xF2BA; // 0040F0E8
word32 g_dw40F0EC = 0xF2CA; // 0040F0EC
word32 g_dw40F0F0 = 62172; // 0040F0F0
word32 g_dw40F0F4 = 0xF2F6; // 0040F0F4
word32 g_dw40F0FC = 62234; // 0040F0FC
word32 g_dw40F100 = 62250; // 0040F100
word32 g_dw40F104 = 62266; // 0040F104
word32 g_dw40F108 = 62280; // 0040F108
word32 g_dw40F110 = 0xF36A; // 0040F110
word32 g_dw40F114 = 62324; // 0040F114
word32 g_dw40F11C = 62346; // 0040F11C
word32 g_dw40F120 = 62356; // 0040F120
word32 g_dw40F124 = 62376; // 0040F124
word32 g_dw40F128 = 62388; // 0040F128
word32 g_dw40F12C = 0xF3C0; // 0040F12C
word32 g_dw40F130 = 62424; // 0040F130
