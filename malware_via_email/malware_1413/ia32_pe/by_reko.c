// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0055B850: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_2 eax_7 = fn0055B861(ebp);
	*(fp - 0x10) = (uint32) eax_7;
	return eax_7;
}

// 0055B861: Register word32 fn0055B861(Register word32 ebp)
word32 fn0055B861(word32 ebp)
{
	ptr32 ebp_17;
	word32 ebx_18 = fn0055B8E8(fn0055B8BC(0x0055C200), &globals->dw55C200, fp - 0x04, ebp, out ebp_17);
	word32 ebx_23;
	word32 ebp_24;
	return fn0055B88E(ebx_18, ebp_17, out ebx_23, out ebp_24);
}

// 0055B88E: Register word32 fn0055B88E(Register word32 ebx, Register ptr32 ebp, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
word32 fn0055B88E(word32 ebx, ptr32 ebp, ptr32 & ebxOut, ptr32 & ebpOut)
{
fn0055B88E_entry:
	def fp
	def ebp
	def ebx
	def dwLoc04
	def Mem0
	def ebxOut
	def ebpOut
	esp_1 = fp
	eax_5 = fn0055B8C3(ebp, out ecx_3, out edx_4)
	fn0055B8AE(eax_5, edx_4, ebx)
	ebx_9 = fn0055B8E8(ecx_3, edx_4, ebp, dwLoc04, out ebp_8)
	eax_11 = *esp_1
	esp_12 = ebp_8
	ebp_13 = *esp_12
	esp_14 = esp_12 + 0x01
	return eax_11
l0055B88E:
l0055B88E:
	eax = fn0055B8C3(ebp, out ecx, out edx)
	fn0055B8AE(eax, edx, ebx)
l0055B89D:
fn0055B88E_exit:
	use ebx_9 (=> ebxOut)
	use ebp_13 (=> ebpOut)
}

// 0055B8A2: Register word32 fn0055B8A2(Register word32 edx, Stack word32 dwArg00)
word32 fn0055B8A2(word32 edx, word32 dwArg00)
{
	return edx + 1244;
}

// 0055B8AE: void fn0055B8AE(Register word32 eax, Register (ptr word32) edx, Register word32 ebx)
void fn0055B8AE(word32 eax, word32 * edx, word32 ebx)
{
	__rol(ebx, 0x03);
	*edx = *edx - (eax + 0x5656DF0F);
	*edx = __rol(*edx, 0x04);
	return;
}

// 0055B8BC: Register word32 fn0055B8BC(Register word32 edx)
word32 fn0055B8BC(word32 edx)
{
	return fn0055B8A2(edx, dwLoc04);
}

// 0055B8C3: Register word32 fn0055B8C3(Register ptr32 ebp, Register out ptr32 ecxOut, Register out ptr32 edxOut)
word32 fn0055B8C3(ptr32 ebp, ptr32 & ecxOut, ptr32 & edxOut)
{
	word32 eax_19 = fn0055B8D2(ebp);
	word32 ecx_21;
	*ecxOut = *(fp - 0x14);
	word32 edx_23;
	*edxOut = *(fp - 0x10);
	return eax_19;
}

// 0055B8D2: Register word32 fn0055B8D2(Register ptr32 ebp)
word32 fn0055B8D2(ptr32 ebp)
{
	word32 edx_3 = fn0055B8DF(dwLoc04);
	ptr32 esp_4;
	word32 * ebp_5;
	word32 eax_6;
	word32 * edx_7;
	fn44A2E5E1();
	*ebp_5 = 79855706;
	word32 eax_10 = *edx_7;
	*(esp_4 - 0x04) = v7;
	return eax_10;
}

// 0055B8DF: Register word32 fn0055B8DF(Stack word32 dwArg00)
word32 fn0055B8DF(word32 dwArg00)
{
	word32 edx_7 = DPB(dwArg00, (byte) dwArg00 + 0x04, 0);
	return edx_7;
}

// 0055B8E8: Register word32 fn0055B8E8(Register word32 ecx, Register (ptr word32) edx, Register ptr32 ebp, Stack word32 dwArg00, Register out ptr32 ebpOut)
word32 fn0055B8E8(word32 ecx, word32 * edx, ptr32 ebp, word32 dwArg00, ptr32 & ebpOut)
{
	*ebpOut = ebp;
	if (ecx - (edx + 0x01) != 0x00)
	{
		word32 ebx_24;
		word32 ebp_25;
		fn0055B88E(dwArg00, ebp, out ebx_24, out ebp_25);
		return ebx_24;
	}
	else
		return ebx;
}

