/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int start();
unsigned int __cdecl sub_403390(int a1, int a2);
unsigned int sub_403590();

//-------------------------------------------------------------------------
// Data declarations

int dword_401C00 = 1065183052; // weak
char byte_404000[16] =
{
  '\x90',
  'ï',
  'T',
  '\x12',
  'Æ',
  'g',
  '\xFF',
  '_',
  'E',
  '\x90',
  'x',
  '\x90',
  'õ',
  '4',
  '˜',
  '\x11'
}; // idb
char byte_404010[48] =
{
  'ø',
  '›',
  ' ',
  'b',
  'ü',
  'H',
  'Ð',
  'n',
  '|',
  '£',
  'V',
  '¡',
  'Å',
  '\0',
  '¶',
  '#',
  '§',
  'Á',
  'm',
  '#',
  'é',
  '\v',
  '–',
  '2',
  '5',
  '\xFF',
  '\b',
  '\xFF',
  'Ú',
  'V',
  'ú',
  '?',
  'à',
  '‡',
  '$',
  '\x12',
  '9',
  'û',
  '\x14',
  'X',
  '³',
  ' ',
  'k',
  'œ',
  'V',
  'c',
  '\x04',
  '#'
}; // idb
char byte_404040[32] =
{
  '¤',
  'Ü',
  'e',
  '$',
  'õ',
  'V',
  'Ê',
  'j',
  '}',
  '¡',
  'x',
  'þ',
  '-',
  'i',
  '\x8D',
  'æ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_404060 = 899014759; // weak
__int16 word_405AC0[] = { 3 }; // weak
__int16 word_405AC2[] = { 0 }; // weak
__int16 word_405AC4[670] =
{
  0,
  4,
  0,
  0,
  5,
  0,
  0,
  6,
  0,
  0,
  0,
  2,
  7,
  0,
  4,
  11,
  0,
  8,
  27,
  0,
  6,
  1,
  0,
  10,
  65,
  0,
  14,
  1089,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // idb
char byte_406000[]; // weak
int dword_406004; // weak
int dword_406008; // weak
int dword_406010; // weak
int dword_406014; // weak
int dword_406018; // weak
int dword_40601C; // weak
int dword_406020; // weak
int dword_406024; // weak
int dword_406028; // weak
int dword_40602C; // weak
int dword_406030; // weak
int dword_406034; // weak
int dword_406038; // weak
int dword_40603C; // weak


//----- (00401020) --------------------------------------------------------
int start()
{
  unsigned int v0; // ecx
  char *v1; // ebx
  unsigned int v2; // edx
  int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // esi
  int v7; // ebx
  int i; // edx
  char v9; // al
  int j; // eax
  int k; // ecx
  char v12; // al
  int v13; // ebx
  int l; // edx
  char *v15; // ecx
  int v16; // edx
  int v17; // eax
  char v18; // cl
  unsigned int m; // edx
  unsigned int v20; // ebx
  char *v21; // edi
  char *v22; // eax
  char *v23; // esi
  __int16 v24; // dx
  __int16 v25; // cx
  int v26; // edi
  int v27; // eax
  int v28; // esi
  int ii; // ebx
  int v30; // eax
  int v31; // ebx
  int v33; // edi
  int v34; // ebx
  int v35; // esi
  int v36; // edi
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  __int16 *v40; // eax
  __int16 *v41; // edx
  int v42; // eax
  unsigned int v43; // ecx
  unsigned int v44; // edx
  unsigned int v45; // eax
  unsigned int v46; // ecx
  unsigned __int8 v47; // cl
  int v48; // esi
  int v49; // eax
  bool v50; // al
  unsigned int v51; // edx
  unsigned int v52; // ebx
  int v53; // esi
  int v54; // edx
  char *v55; // ebx
  int n; // esi
  unsigned int v57; // eax
  int v58; // eax
  int v59; // esi
  int v60; // ebx
  unsigned int v61; // edi
  unsigned int v62; // eax
  char v63; // dl
  unsigned int v64; // eax
  int v65; // [esp+8h] [ebp-893Ch]
  int v66; // [esp+Ch] [ebp-8938h]
  int v67; // [esp+14h] [ebp-8930h]
  int v68; // [esp+18h] [ebp-892Ch]
  int v69; // [esp+1Ch] [ebp-8928h]
  int v70; // [esp+1Ch] [ebp-8928h]
  int v71; // [esp+20h] [ebp-8924h]
  int v72; // [esp+24h] [ebp-8920h]
  __int16 *v73; // [esp+3Ch] [ebp-8908h]
  char *v74; // [esp+3Ch] [ebp-8908h]
  unsigned int v75; // [esp+48h] [ebp-88FCh]
  unsigned int v76; // [esp+54h] [ebp-88F0h]
  char v77; // [esp+5Bh] [ebp-88E9h]
  char *v78; // [esp+68h] [ebp-88DCh]
  char v79; // [esp+6Dh] [ebp-88D7h]
  int v80; // [esp+70h] [ebp-88D4h]
  char *v81; // [esp+74h] [ebp-88D0h]
  int v82; // [esp+78h] [ebp-88CCh]
  unsigned int v83; // [esp+78h] [ebp-88CCh]
  int v84; // [esp+7Ch] [ebp-88C8h]
  int v85; // [esp+80h] [ebp-88C4h]
  int v86; // [esp+84h] [ebp-88C0h]
  int v87; // [esp+88h] [ebp-88BCh]
  int v88; // [esp+8Ch] [ebp-88B8h]
  int v89; // [esp+94h] [ebp-88B0h]
  unsigned int v90; // [esp+9Ch] [ebp-88A8h]
  unsigned int v91; // [esp+A0h] [ebp-88A4h]
  int v92; // [esp+A4h] [ebp-88A0h]
  char v93[20024]; // [esp+ACh] [ebp-8898h] BYREF
  char v94[12744]; // [esp+4EE4h] [ebp-3A60h] BYREF
  __int16 v95[2]; // [esp+80ACh] [ebp-898h] BYREF
  char v96[1580]; // [esp+80B0h] [ebp-894h] BYREF
  char v97[4]; // [esp+86DCh] [ebp-268h] BYREF
  char v98; // [esp+86E0h] [ebp-264h] BYREF
  char v99[326]; // [esp+87E0h] [ebp-164h] BYREF
  char v100[16]; // [esp+8926h] [ebp-1Eh]
  char v101[14]; // [esp+8936h] [ebp-Eh] BYREF

  v80 = sub_403590();
  if ( !v80 )
    return 0;
  v0 = 0;
  v99[0] = 0;
  v1 = v94;
  v76 = dword_40603C;
  v2 = dword_40603C / 5u + 4;
  v3 = 5 * dword_40603C;
  do
  {
    v4 = *(int *)((char *)&dword_401C00 + v0) ^ (dword_40603C | 0xA605EF2A);
    v0 += v2;
    *(_DWORD *)v1 = v4;
    v1 = &v1[-v3 + 4];
  }
  while ( v0 <= 0x176F );
  v5 = 0;
  v6 = v76 + 1;
  do
  {
    *(_DWORD *)v1 = *(int *)((char *)&dword_404060 + v5) ^ ((v76 >= 0xA605EF2B) - 1509560534);
    v1 += 4 * v76 + 4;
    v5 += 4 / v6;
  }
  while ( v5 <= 0x1A57 );
  v81 = v94;
  v7 = v76 | 0x108;
  v73 = v95;
  for ( i = 0; i != v7; ++i )
  {
    while ( 1 )
    {
      *v73 = i;
      if ( (i & 1) == 0 )
        break;
      ++i;
      v9 = *v81++;
      *((_BYTE *)v73 + 4) = v9 & 0xF;
      v73 += 3;
      if ( i == v7 )
        goto LABEL_10;
    }
    *((_BYTE *)v73 + 4) = (int)(unsigned __int8)*v81 >> (v76 / 5 + 4);
    v73 += 3;
  }
LABEL_10:
  v100[0] = 0;
  for ( j = 2; j != 17; ++j )
    v99[j + 325] = 0;
  for ( k = 0; k != 1584; k += 6 )
  {
    v12 = v96[k];
    if ( v12 > 0 )
      ++v100[v12 % (v76 - 1)];
  }
  v13 = 0;
  for ( l = 1; l != 16; ++l )
  {
    v13 = (v99[l + 325] + v13) << (2 - (v76 == 0));
    *(_DWORD *)&v99[4 * l + 260] = v13 + v76;
  }
  v15 = v96;
  do
  {
    v16 = *v15;
    v17 = *(_DWORD *)&v99[4 * v16 + 260];
    *((_WORD *)v15 - 1) = v17;
    v15 += 6;
    *(_DWORD *)&v99[4 * v16 + 260] = v17 + 1;
  }
  while ( v15 != &v98 );
  v18 = 0;
  m = 0;
  v90 = 0x108 / v6 - 1;
  if ( 0x108 / v6 != 1 )
    goto LABEL_25;
  while ( v18 )
  {
    v18 = 0;
    v20 = 0;
LABEL_23:
    for ( m = v20; m < v90; m = v20 )
    {
LABEL_25:
      v21 = &v101[6 * m + 2];
      v78 = v21 - 2188;
      v20 = m + 1;
      v79 = *(v21 - 2184);
      v22 = &v101[6 * m + 8];
      v23 = v22 - 2188;
      if ( v79 <= *(v22 - 2184) )
        goto LABEL_23;
      v24 = *((_WORD *)v78 + 1);
      v25 = *((_WORD *)v21 - 1094);
      *((_DWORD *)v21 - 547) = *((_DWORD *)v22 - 547);
      *((_WORD *)v78 + 2) = *((_WORD *)v23 + 2);
      *((_WORD *)v23 + 1) = v24;
      v23[4] = v79;
      *((_WORD *)v22 - 1094) = v25;
      v18 = 1;
    }
  }
  v33 = 128;
  v84 = -v76;
  while ( 2 )
  {
    while ( 2 )
    {
      v34 = v33;
      v35 = 0;
      v36 = 0;
      v92 = 0;
      v82 = -1;
      v75 = v76 - 1;
      while ( 1 )
      {
        while ( 1 )
        {
          v37 = v76 | 1;
          v38 = 0;
          do
          {
            v38 *= 2;
            if ( ((unsigned __int8)v34 & (unsigned __int8)*v81) != 0 )
              v38 |= 1u;
            v34 >>= 1;
            if ( !v34 )
            {
              ++v81;
              v34 = 128;
            }
            --v37;
          }
          while ( v37 );
          ++v36;
          v92 = v38 | (2 * v92);
          v39 = v96[6 * v35];
          if ( v36 > v39 )
          {
            v40 = &v95[3 * v35];
            do
            {
              v39 = *((char *)v40 + 10);
              ++v35;
              v40 += 3;
            }
            while ( v36 > v39 );
          }
          if ( v36 == v39 )
            break;
LABEL_49:
          if ( v82 >= 0 )
            goto LABEL_50;
        }
        v41 = &v95[3 * v35];
        if ( v95[3 * v35 + 1] != v92 )
        {
          do
          {
            ++v35;
            if ( *((char *)v41 + 10) != v36 )
              goto LABEL_49;
            v42 = v41[4];
            v41 += 3;
          }
          while ( v42 != v92 );
        }
        v45 = v95[3 * v35];
        v82 = -1;
        if ( v45 != -1 )
        {
          v82 = v45 % v75;
          if ( ((v45 % v75) & 0x80000000) == 0 )
            break;
        }
      }
LABEL_50:
      v43 = v76 + 1;
      v44 = (v76 + 1) << 8;
      if ( v82 < v44 )
      {
        v33 = v34;
        v93[v84++] = v82;
        continue;
      }
      break;
    }
    if ( v82 != v76 / 0x101 + 256 )
    {
      v83 = v82 - (v44 + v43);
      v46 = word_405AC0[3 * v83] / v43;
      if ( v46 )
      {
        v87 = v46;
        v33 = v34 >> 1;
        v47 = *v81;
        v77 = *v81;
        v48 = (unsigned __int8)*v81;
      }
      else
      {
        v47 = *v81;
        v88 = 0;
        v58 = word_405AC2[3 * v83] - v76 * (word_405AC2[3 * v83] | 1);
        v77 = *v81;
        do
        {
          while ( 1 )
          {
            v48 = v47;
            v88 *= 2;
            if ( ((unsigned __int8)v34 & v47) != 0 )
              v88 |= 1u;
            v34 >>= 1;
            if ( !v34 )
              break;
            v33 = v34 >> 1;
            if ( !--v58 )
              goto LABEL_86;
          }
          ++v81;
          --v58;
          v34 = 128;
          v33 = 64;
          v47 = *v81;
          v77 = *v81;
          v48 = (unsigned __int8)*v81;
        }
        while ( v58 );
LABEL_86:
        v91 = v76 / (word_405AC4[3 * v83] | 1u) + word_405AC4[3 * v83];
        v87 = v88 + v91 + v76 / (v91 | 1);
      }
      if ( v33 )
      {
        v89 = v33 >> 1;
        v49 = v48;
      }
      else
      {
        ++v81;
        v33 = 128;
        v47 = *v81;
        v89 = 64;
        v49 = (unsigned __int8)*v81;
        v77 = *v81;
      }
      v86 = 7;
      if ( (v34 & v48) != 0 )
      {
        if ( !v89 )
        {
          ++v81;
          v89 = 128;
          v77 = *v81;
        }
        v50 = (v33 & v49) != 0;
        v47 = v77;
        v33 = v89;
        v86 = (v76 | 8) + v50;
      }
      v51 = -1;
      v52 = word_405AC2[3 * v86];
      if ( v52 != -1 )
        v51 = v52 % (v76 - 1);
      v53 = 0;
      while ( 1 )
      {
        v53 *= 2;
        if ( ((unsigned __int8)v33 & v47) != 0 )
          v53 |= 1u;
        v33 >>= 1;
        if ( !v33 )
        {
          ++v81;
          v33 = 128;
        }
        if ( !--v51 )
          break;
        v47 = *v81;
      }
      v54 = word_405AC4[3 * v86];
      if ( v76 )
        v54 *= 2;
      if ( v87 > 0 )
      {
        v55 = &v93[v84];
        v74 = &v93[v84 - v54 - v53 - v76];
        for ( n = 0; n != v87; ++n )
        {
          v57 = (unsigned __int8)*v74++;
          *v55++ = v57 / (dword_40603C + 1);
        }
      }
      v84 = v87 + v84 - dword_40603C * (v87 | 1);
      continue;
    }
    break;
  }
  if ( v84 > 0 )
  {
    v59 = -1;
    v60 = 0;
    v61 = 0;
    do
    {
      v64 = (unsigned __int8)v93[v60];
      if ( v76 )
        v64 /= v76;
      v63 = v64;
      if ( v59 <= 67 )
      {
        if ( v61 >= (v76 | 0x10) )
        {
          if ( ++v59 > 47 )
          {
            if ( v59 > 63 )
              v63 = byte_406000[v59 - (64 - 65 * v76)];
            else
              v63 = byte_404040[v59 - 48 * v43];
          }
          else
          {
            v62 = byte_404010[v59];
            v63 = -1;
            if ( v62 != -1 )
              v63 = v62 % (v76 - 1);
          }
        }
        else
        {
          if ( byte_404000[v61] == (_BYTE)v64 )
            ++v61;
          else
            v61 = v76;
          v63 = v64;
        }
      }
      v93[v60++] = v43 * v63;
    }
    while ( v60 != v84 );
  }
  dword_406028 = 0;
  dword_406028 = sub_403390(-75737684, v80);
  dword_406014 = sub_403390(-870503712, v80);
  ((void (__stdcall *)(int, char *, int, int, int, int, int))((dword_40603C + 1) * dword_406014))(
    260,
    v97,
    v67,
    v68,
    v69,
    v71,
    v72);
  dword_406010 = sub_403390(-1804247159, v80);
  ((void (__stdcall *)(char *, _DWORD))((dword_40603C + 1) * dword_406010))(v97, 0);
  dword_406004 = sub_403390(-2129451784, v80);
  v26 = ((int (__stdcall *)(char *, int, int, _DWORD))((dword_40603C + 1) * dword_406004))(v99, -1073741824, 1, 0);
  if ( v26 != -1 )
  {
    dword_40602C = sub_403390(-1904863761, v80);
    v85 = ((int (__stdcall *)(int, _DWORD, int, _DWORD, int))((dword_40603C + 1) * dword_40602C))(v26, 0, 4, 0, v84 + 1);
    dword_406030 = sub_403390(-65071996, v80);
    v27 = ((int (__stdcall *)(int, int, _DWORD, _DWORD, _DWORD, int))((dword_40603C + 1) * dword_406030))(
            v85,
            2,
            0,
            0,
            0,
            v70);
    v101[1] = 0;
    v28 = v27;
    if ( v84 > 0 )
    {
      for ( ii = 0; ii != v84; ++ii )
      {
        v101[0] = v93[ii];
        v30 = ii + v28;
        ((void (__stdcall *)(int, char *))(dword_406028 * (dword_40603C + 1)))(v30, v101);
      }
    }
    dword_406034 = sub_403390(-881439336, v80);
    ((void (__stdcall *)(int))((dword_40603C + 1) * dword_406034))(v28);
    dword_406008 = sub_403390(-1810227487, v80);
    ((void (__stdcall *)(int))((dword_40603C + 1) * dword_406008))(v85);
    ((void (__stdcall *)(int))(dword_406008 * (dword_40603C + 1)))(v26);
    dword_40601C = sub_403390(-569695550, v80);
    v31 = ((int (__stdcall *)(char *))((dword_40603C + 1) * dword_40601C))(v99);
    dword_406018 = sub_403390(-1451745554, v80);
    ((void (__stdcall *)(_DWORD))((dword_40603C + 1) * dword_406018))(0);
    dword_406038 = sub_403390(-65846087, v31);
    ((void (__stdcall *)(char *, int, int))((dword_40603C + 1) * dword_406038))(v97, v65, v66);
    dword_406020 = sub_403390(-1643167800, v80);
    ((void (__stdcall *)(int))((dword_40603C + 1) * dword_406020))(v31);
    dword_406024 = sub_403390(-1643892781, v80);
    ((void (__stdcall *)(_DWORD))((dword_40603C + 1) * dword_406024))(0);
  }
  return 0;
}
// 401343: variable 'v67' is possibly undefined
// 401343: variable 'v68' is possibly undefined
// 401343: variable 'v69' is possibly undefined
// 401343: variable 'v71' is possibly undefined
// 401343: variable 'v72' is possibly undefined
// 4014A7: variable 'v70' is possibly undefined
// 401611: variable 'v65' is possibly undefined
// 401611: variable 'v66' is possibly undefined
// 401C00: using guessed type int dword_401C00;
// 404060: using guessed type int dword_404060;
// 405AC0: using guessed type __int16 word_405AC0[];
// 405AC2: using guessed type __int16 word_405AC2[];
// 406004: using guessed type int dword_406004;
// 406008: using guessed type int dword_406008;
// 406010: using guessed type int dword_406010;
// 406014: using guessed type int dword_406014;
// 406018: using guessed type int dword_406018;
// 40601C: using guessed type int dword_40601C;
// 406020: using guessed type int dword_406020;
// 406024: using guessed type int dword_406024;
// 406028: using guessed type int dword_406028;
// 40602C: using guessed type int dword_40602C;
// 406030: using guessed type int dword_406030;
// 406034: using guessed type int dword_406034;
// 406038: using guessed type int dword_406038;
// 40603C: using guessed type int dword_40603C;

//----- (00403390) --------------------------------------------------------
unsigned int __cdecl sub_403390(int a1, int a2)
{
  unsigned int v2; // ebx
  _DWORD *v3; // edx
  _BYTE *v4; // ecx
  signed int v5; // esi
  unsigned int v6; // eax
  signed int v7; // edi
  int v8; // ecx
  char *v9; // eax
  int v10; // ecx
  unsigned int v11; // eax
  int v12; // edx
  int v13; // edx
  unsigned int v15; // eax
  int v16; // [esp+14h] [ebp-94h]
  _BYTE *v17; // [esp+18h] [ebp-90h]
  _DWORD *v18; // [esp+1Ch] [ebp-8Ch]
  unsigned __int16 *v19; // [esp+20h] [ebp-88h]
  int v20; // [esp+24h] [ebp-84h]
  int v21; // [esp+28h] [ebp-80h]
  int v22[25]; // [esp+36h] [ebp-72h] BYREF
  char v23[14]; // [esp+9Ah] [ebp-Eh] BYREF

  v2 = dword_40603C;
  v21 = dword_40603C;
  v3 = (_DWORD *)(*(_DWORD *)((dword_40603C | a2) + *(_DWORD *)(a2 + 60) + 120) + a2 - dword_40603C * (a2 | 1));
  v18 = v3;
  if ( !(v3[6] / (unsigned int)(dword_40603C + 1)) )
    return 0;
  v20 = 0;
  v19 = (unsigned __int16 *)(v3[9] + (dword_40603C | a2));
  v16 = a2 + v3[8] - dword_40603C * (v3[8] | 1);
  while ( 1 )
  {
    v4 = (_BYTE *)(*(_DWORD *)(v16 + 4 * v20) + a2);
    v5 = 0;
    v23[1] = 0;
    v17 = v4;
    LOBYTE(v6) = *v4;
    if ( *v4 )
    {
      v7 = 0;
      do
      {
        if ( v2 )
          v6 = (char)v6 / v2;
        v23[0] = v6;
        v8 = dword_406028 * (v2 + 1);
        if ( v8 )
        {
          ((void (__stdcall *)(char *, unsigned int))v8)((char *)&v22[1] + v7, (unsigned int)v23 / (v2 + 1));
          v2 = dword_40603C;
        }
        else
        {
          *((_BYTE *)&v22[1] + v5) = v6 - v2 * (v6 | 1);
        }
        v7 = ++v5;
        LOBYTE(v6) = v17[v5];
      }
      while ( (_BYTE)v6 );
    }
    if ( (int)(v2 + 48) > v5 )
    {
      v9 = (char *)&v22[1] + v5;
      do
      {
        ++v5;
        *v9++ = 0;
      }
      while ( (int)(v2 + 48) > v5 );
    }
    v10 = 1;
    v11 = a1 | v21;
    do
    {
      v12 = v22[v10];
      if ( v2 )
        v12 *= 2;
      ++v10;
      v11 ^= v12;
    }
    while ( v10 != 13 );
    if ( v11 != -1 && v11 % (v2 - 1) == -1989060957 )
      break;
    if ( v18[6] / (v2 + 1) <= ++v20 )
      return 0;
    ++v19;
    v21 = v2;
  }
  v13 = -1;
  v15 = a2 + *(_DWORD *)((v18[7] + a2) * (v2 + 1) + 4 * *v19);
  if ( v15 == -1 )
    return v13;
  return v15 % (v2 - 1);
}
// 406028: using guessed type int dword_406028;
// 40603C: using guessed type int dword_40603C;

//----- (00403590) --------------------------------------------------------
unsigned int sub_403590()
{
  struct _TEB *v0; // eax
  int v1; // edi
  unsigned int v2; // ebx
  _DWORD *v3; // ecx
  unsigned int v4; // ebx
  unsigned int v5; // edx

  v0 = NtCurrentTeb();
  v1 = *(_DWORD *)((char *)v0->ProcessEnvironmentBlock->ImageBaseAddress
                 + dword_40603C / ((int)v0->ProcessEnvironmentBlock->ImageBaseAddress | 1u)
                 + 28);
  v3 = (_DWORD *)(v1 - dword_40603C * (v1 | 1));
  while ( 1 )
  {
    v2 = dword_40603C + 1;
    if ( *(_BYTE *)(v3[8] / (unsigned int)(dword_40603C + 1)) == 107 * ((_BYTE)dword_40603C + 1)
      && *(_BYTE *)(v3[8] / v2 + 2) == (unsigned __int8)(dword_40603C / 0x65u) + 101
      && *(_BYTE *)(v3[8] / v2 + 4) == 114 * ((_BYTE)dword_40603C + 1) )
    {
      break;
    }
    v3 = (_DWORD *)(dword_40603C | *v3);
    if ( v1 == *v3 )
      return 0;
  }
  v4 = v3[2];
  v5 = -1;
  if ( v4 != -1 )
    v5 = v4 % (dword_40603C - 1);
  return v5;
}
// 40603C: using guessed type int dword_40603C;

// nfuncs=4 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled
