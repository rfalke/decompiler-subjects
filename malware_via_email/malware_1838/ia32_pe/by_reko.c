// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct HINSTANCE__ g_t400000 = // 00400000
	{
		9460301,
	};
// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct HWND__ g_t402000 = // 00402000
	{
		-0x07F3D347,
	};
// 00404A00: Register uint16 fxUnmcbxMnBjr(Stack int16 wArg04, Stack bool fArg08)
uint16 fxUnmcbxMnBjr(int16 wArg04, bool fArg08)
{
	word32 * edx_9 = g_ptr4118AD;
	*edx_9 -= g_t411645.u0;
	g_dw4116D5 = g_dw4116D5 ^ *g_ptr41184D;
	ui32 * edi_17 = g_ptr4118A9;
	*edi_17 |= g_dw4116E5;
	return <invalid>;
}

// 00404A3A: Register word32 fn00404A3A(Register word32 ecx, Register word32 ebx, Register word32 esi, Register word32 edi, Register out ptr32 edxOut)
// Called from:
//      fn00407AAD
word32 fn00404A3A(word32 ecx, word32 ebx, word32 esi, word32 edi, ptr32 & edxOut)
{
}

// 00405009: Register ui32 fn00405009(Register out ptr32 edxOut, Register out ptr32 esiOut)
// Called from:
//      fn00405402
ui32 fn00405009(ptr32 & edxOut, ptr32 & esiOut)
{
	ptr32 fp;
	word32 dwLoc3C;
	word32 dwLocC4;
	word16 wLoc0108;
	word32 dwLoc20;
	word32 edx;
	eax_9 = g_ptr40B2EC;
	dwLoc60_159 = 0x00;
	while (true)
	{
		dwLoc60_160 = ϕ(dwLoc60_159, dwLoc60_187);
		Mem20 = ϕ(Mem15, Mem146);
		if (dwLoc60_160 >= 0x1D)
			break;
		if (dwLoc60_160 == 33)
			PrintDlgExW(dwLoc20);
		dwLoc60_187 = dwLoc60_160 + 0x01;
	}
	eax_23 = g_dw40B2F4;
	esp_25 = fp - 0x20;
	edx_210 = ϕ(edx, edx_57);
	eax_203 = ϕ(eax_23, eax_123);
	Mem126 = ϕ(Mem28, Mem118);
	esp_125 = ϕ(esp_25, esp_121);
	esi_127 = *esp_125;
	edxOut = edx_210;
	esiOut = esi_127;
	return eax_203;
}

// 0040514F: Register ui32 fn0040514F(Register up32 ebx, Stack (ptr32 Eq_686) dwArg04, Stack (ptr32 word32) dwArg08, Register out (ptr32 Eq_688) edxOut)
// Called from:
//      fn00405009
ui32 fn0040514F(up32 ebx, struct Eq_686 * dwArg04, word32 * dwArg08, struct Eq_688 & edxOut)
{
	ptr32 fp;
	WNDCLASSEXA * dwLoc20;
	struct Eq_688 * edx;
	up32 dwLoc38_245 = 0x00;
	do
	{
		dwLoc38_245 = dwLoc38_399 + 0x01;
		if (dwLoc38_245 == 0x25)
			FindTextW((struct tagFINDREPLACEW *) 15521);
		dwLoc38_399 = dwLoc38_245;
	} while (dwLoc38_399 < 22);
	g_dw411665 &= 0x28C4;
	word32 eax_131;
	WNDCLASSEXA * ecx_57 = g_ptr40B0E0;
	g_dw41168D = g_dw41168D - g_t411645.u0 - (word32) (ebx > ~0x1003);
	ptr32 esp_160 = fp - 0x18;
	if (ecx_57 != (WNDCLASSEXA *) 0x01 && *dwArg04->ptr0034 != 0x00)
	{
		struct Eq_180 * eax_132 = g_ptr40B2C4;
		edx = (struct Eq_688 *) *eax_132->ptr0008;
		word32 ecx_137 = Mem82[Mem82[edx + 60:word32] + 40 + edx:word32] + edx;
		if (eax_132->dw003C != 0x00)
		{
			WNDCLASSEXA * v20_143 = g_ptr40B0E0;
			struct Eq_688 ** eax_153 = g_ptr40B2C4->ptr0008;
			word32 eax_161;
			ecx_137();
			*dwArg08 = eax_161;
			dwLoc20 = v20_143;
		}
		g_dw40B0F0 = 0x00;
		up32 dwLoc48_339 = 0x00;
		do
		{
			dwLoc48_339 = dwLoc48_400 + 0x01;
			if (dwLoc48_339 == 0x2A)
			{
				WNDCLASSEXA ** esp_195 = esp_160 - 4;
				*esp_195 = (WNDCLASSEXA **) dwLoc20;
				RegisterClassExA(*esp_195);
			}
			dwLoc48_400 = dwLoc48_339;
		} while (dwLoc48_400 < 0x19);
		g_dw40B0F4 = 0x00;
		eax_131 = ~0x1003;
	}
	else
		eax_131 = ~0x1002;
	edxOut = edx;
	return (eax_131 ^ 13611) + 0x252A;
}

// 00405375: void fn00405375(Stack word32 dwArg04)
// Called from:
//      fn00404A3A
void fn00405375(word32 dwArg04)
{
	int32 dwLoc1C;
	Eq_805 dwLoc28;
	ui32 edi_15 = ~0x1002;
	do
	{
		up32 dwLoc18_88;
		for (dwLoc18_88 = 0x00; dwLoc18_88 < 22; ++dwLoc18_88)
		{
			if (dwLoc18_88 == 0x1E)
				GetKeyNameTextW(dwLoc28, &g_dw41169D, dwLoc1C);
		}
		g_ptr40B50C();
		edi_15 = (edi_15 ^ 13611) + 0x01 ^ 13611;
	} while (edi_15 != ~0x100D);
}

// 00405402: Register ptr32 fn00405402(Register ptr32 eax, Register word32 edx, Stack word32 dwArg00, Register out ptr32 edxOut, Register out ptr32 esiOut)
// Called from:
//      fn00407AAD
ptr32 fn00405402(ptr32 eax, word32 edx, word32 dwArg00, ptr32 & edxOut, ptr32 & esiOut)
{
	ptr32 fp;
	word32 ecx;
	ptr32 eax;
	word32 esi;
	word32 edx;
	word32 dwArg00;
	word32 dwLocAC;
	word32 dwLoc24;
	word32 dwLoc2C;
	dwLoc08_185 = ecx;
	eax_20 = g_dw40B2FC;
	g_dw40B0DC = eax_20;
	dwLoc28_191 = 0x1E;
	while (true)
	{
		dwLoc2C_246 = ϕ(dwLoc2C, dwLoc2C_265);
		dwLoc28_192 = ϕ(dwLoc28_191, dwLoc28_252);
		Mem24 = ϕ(Mem22, Mem178);
		if (dwLoc28_192 == 0x00)
			break;
		if (dwLoc28_192 == 0x26)
		{
			dwLoc28_247 = dwLoc2C_246;
			dwLoc2C_248 = 19590;
			DrawStateA((struct HDC__ *) 19590, (struct HBRUSH__ *) 23426, (BOOL (*)(HDC, LPARAM, WPARAM, int32, int32)) 19590, dwLoc2C_246, dwLoc24, 0x399F, dwLoc28_192, dwLoc24, 19590, 0x16CC);
		}
		dwLoc2C_265 = ϕ(dwLoc2C_246, dwLoc2C_248);
		dwLoc28_251 = ϕ(dwLoc28_192, dwLoc28_247);
		dwLoc28_252 = dwLoc28_251 - 0x01;
	}
	eax_28 = g_ptr40B300;
	g_ptr40B0E0 = eax_28;
	eax_31 = g_dw40B304;
	v21_34 = g_dw411685 + 4265565;
	g_dw411685 = v21_34;
	v22_36 = g_dw411685 & 4265641;
	g_dw411685 = v22_36;
	v25_40 = g_dw411685 + 0x004116F5;
	g_dw411685 = v25_40;
	g_dw40B0E4 = eax_31;
	v26_44 = g_dw40B2E0;
	eax_49 = g_ptr40B2F8;
	v27_50 = *eax_49;
	fn00405813(edx, fp - 8, v27_50, v26_44);
	eax_67 = fn00405009(out edx_71, out esi_69);
	if (eax_67 == 0x00)
		eax_81 = g_ptr40B2C4;
	else
	{
		dwLoc08_200 = 0x00;
		v29_96 = g_dw40B088 + 0x00677567;
		g_dw40B088 = v29_96;
		edx_278 = ϕ(edx_276, edx_71);
		dwLoc08_233 = ϕ(dwLoc08_198, dwLoc08_200);
		esi_100 = ϕ(esi_101, esi_69);
		g_ptr40B0FC = fp;
		eax_133 = dwArg00 + g_dw40B0F0;
		ecx_135 = g_ptr40B0FC;
		*ecx_135 = eax_133;
	}
}

// 004057D0: Register (ptr32 void) jCEoogfwBXoqxKlaNgtzkR(Stack uint16 wArg04, Stack cu8 bArg08)
void * jCEoogfwBXoqxKlaNgtzkR(uint16 wArg04, cu8 bArg08)
{
	up32 ecx;
	up32 dwLoc24;
	g_dw41169D = g_dw41169D - *g_ptr411831 - (word32) (dwLoc24 < ecx);
	ui32 * esi_16 = g_ptr4118E1;
	*esi_16 |= g_dw4116AD;
	g_dw41164D &= *g_ptr4118A5;
	return (void *) <invalid>;
}

// 00405813: void fn00405813(Register word32 edx, Stack ptr32 dwArg04, Stack word32 dwArg08, Stack ui32 dwArg0C)
// Called from:
//      fn00405402
void fn00405813(word32 edx, ptr32 dwArg04, word32 dwArg08, ui32 dwArg0C)
{
	bool P;
	Eq_65 dwLoc18;
	word32 dwLoc1C_181;
	for (dwLoc1C_181 = 0x1B; dwLoc1C_181 != 0x00; --dwLoc1C_181)
	{
		if (dwLoc1C_181 == 0x1E)
		{
			WaitForSingleObjectEx((void *) 0x3EED, 17957, dwLoc18);
			dwLoc18 = 0x3EED;
		}
	}
	int32 * esi_59 = g_ptr40B0CC;
	*esi_59 = *esi_59 *s ~0x1002 *s ~0x200F;
	word32 * esi_70 = g_ptr40B0C4;
	*esi_70 = ~*esi_70;
	if (false)
		g_ptr40B2EC = dwArg04;
	else if (false)
		g_dw40B2F0 = dwArg08;
	else if (false)
		g_dw40B2F4 = dwArg0C;
	word32 * eax_118 = g_ptr40B0C4;
	*eax_118 += ~0x0200D013;
}

// 00406185: void fn00406185()
// Called from:
//      Win32CrtStartup
void fn00406185()
{
	g_dw40B51C = g_dw40B51C ^ g_dw40B51C;
	g_dw40B520 = g_dw40B520 ^ g_dw40B520;
	g_dw40B524 = g_dw40B524 ^ g_dw40B524;
	g_ptr40B528 = g_ptr40B528;
}

// 004061B8: Register word32 fn004061B8(Register word32 ecx)
// Called from:
//      Win32CrtStartup
word32 fn004061B8(word32 ecx)
{
	Eq_1097 tLoc08;
	tLoc08 = (Eq_1097) ecx;
	fn0040688D(&tLoc08);
	return tLoc08;
}

// 004061CB: Register word32 fn004061CB(Register word32 ecx, Register word32 edx, Register int32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C, Stack word32 dwArg10)
// Called from:
//      fn00405009
//      fn004061CB
word32 fn004061CB(word32 ecx, word32 edx, int32 edi, word32 dwArg00, word32 dwArg04, word32 dwArg08, <anonymous> * dwArg0C, word32 dwArg10)
{
	word16 wLoc78;
	Eq_1027 dwLoc14;
	if (dwArg10 == 550007)
	{
		struct Eq_180 * v9_133 = g_ptr40B2C4;
		word32 v11_139 = g_dw40B0E4;
		WNDCLASSEXA * v12_142 = g_ptr40B0E0;
		g_t411645.u0 = (ui32) (g_t411645.u0 + 0x00411675);
		dwArg0C();
		goto l004062F7;
	}
	switch (dwArg10)
	{
	case 0x00060421:
		up32 dwLoc48_251 = 0x00;
		do
		{
			dwLoc48_251 = dwLoc48_378 + 0x01;
			if (dwLoc48_251 == 0x1A)
				GetCommTimeouts(dwLoc14, &g_t4116FD);
			dwLoc48_378 = dwLoc48_251;
		} while (dwLoc48_378 < 0x11);
		word32 * eax_55 = g_ptr411869;
		*eax_55 -= (word32) wLoc78;
		ecx = 0x00;
		if (*g_ptr40B2C4->ptr000C != null)
		{
			up32 eax_71 = g_dw40B080;
			ecx = 0x00;
			if (eax_71 == 0x00)
				ecx = fn00406E0C(eax_71, 0x00, edx, 550007, edi, out edx, out edi);
		}
		break;
	case 0x00031A00:
	default:
		goto l004062F7;
	}
	g_dw4116AD += 0x004116D9;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 stackArg0 = <invalid>;
	word32 stackArg16 = <invalid>;
	fn004061CB(ecx, edx, edi, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg16);
l004062F7:
	ui32 * ecx_189 = g_ptr411859;
	*ecx_189 = *ecx_189 ^ 28084;
}

// 0040643A: void fn0040643A(Stack (ptr32 Eq_1216) dwArg04)
// Called from:
//      fn00405375
void fn0040643A(struct Eq_1216 * dwArg04)
{
	g_dw4116D5 += 0x00411721;
	g_dw4116D5 &= 0x00411671;
	word32 esi_120 = 0x50;
	if (lstrlenW(&g_t40B4D0) == 0x08)
	{
		do
		{
			if (SHLWAPI.dll!PathGetArgsA(0x0040B4E4)->b0002 == 115)
			{
				if (esi_120 == 0x30)
				{
					up32 dwLoc4C_155;
					for (dwLoc4C_155 = 0x00; dwLoc4C_155 < 0x12; ++dwLoc4C_155)
					{
						if (dwLoc4C_155 == 0x1D)
						{
							esp_32->tFFFFFFFC = (Eq_1261) &g_dw41167D;
							esp_32->tFFFFFFF8 = (struct HDC__ *) 33573;
							GetTextMetricsA(esp_32->tFFFFFFF8, esp_32->tFFFFFFFC);
						}
					}
					if (g_dw40B4A8 == 0x00)
					{
						struct Eq_180 * eax_96 = g_ptr40B2C4;
						esp_32->tFFFFFFFC = (Eq_1261) &g_t40B500;
						esp_32->tFFFFFFF8 = (struct HDC__ *) 0x01;
						word16 ** eax_102 = eax_96->ptr000C;
						esp_32->ptrFFFFFFF4 = &eax_96->dw003C + 4;
						esp_32->ptrFFFFFFF0 = (word16 *) *eax_102;
						esp_32->dwFFFFFFEC = g_dw40B56C;
						word32 eax_112;
						g_ptr40B568();
						g_dw40B4A8 = eax_112;
					}
				}
				else if (esi_120 == 0x20)
					esp_32->tFFFFFFFC = dwArg04->t40B454;
			}
			--esi_120;
		} while (esi_120 != 0x00);
	}
}

// 00406588: Register int32 vzswloIbjjKVd(Stack uint16 wArg04)
int32 vzswloIbjjKVd(uint16 wArg04)
{
	union Eq_1328 * esi_9 = g_ptr4118A1;
	esi_9->u0 = (uint32) (esi_9->u0 ^ (word32) g_b41171D);
	g_t411641.u0 = (ui32) (g_t411641.u0 ^ g_dw411715);
	g_t411645.u0 = (ui32) ((word32) g_t411645.u1 & *g_ptr4118BD);
	return <invalid>;
}

// 004065CA: Register Eq_1028 Win32CrtStartup()
Eq_1028 Win32CrtStartup()
{
	ptr32 fp;
	word32 ecx;
	up32 ebx;
	up32 dwLoc34;
	if (fn004061B8(ecx) == 0x03)
		return 0x00;
	g_dw411719 = g_dw411719 + 0x004116E5 + (word32) (dwLoc34 < ebx);
	g_dw411719 |= 0x00411715;
	g_dw411719 -= 0x0041168D;
	fn00406185();
	g_ptr40B528 = fp;
	up32 dwLoc28_169;
	for (dwLoc28_169 = 0x00; dwLoc28_169 < 0x1F; ++dwLoc28_169)
	{
		if (dwLoc28_169 == 0x22)
			DestroyCaret();
	}
	fn00407567(fp - 4);
	byte * eax_60 = g_ptr411881;
	*eax_60 += 0x4F;
}

// 00406773: Register word32 fn00406773()
// Called from:
//      Win32CrtStartup
//      fn00406E0C
word32 fn00406773()
{
	Eq_1412 dwLoc28;
	word32 dwLoc44_102;
	for (dwLoc44_102 = 0x10; dwLoc44_102 != 0x00; --dwLoc44_102)
	{
		if (dwLoc44_102 == 0x1B)
			GetMonitorInfoW(dwLoc28, (struct tagMONITORINFO *) 0x57A5);
	}
}

// 00406847: void mcgroqeonY(Stack uint32 dwArg04)
void mcgroqeonY(uint32 dwArg04)
{
	up32 edi;
	up32 eax;
	up32 dwLoc24;
	ui32 * ebx_10 = g_ptr4118D1;
	*ebx_10 = *ebx_10 ^ g_dw411701;
	up32 esi_19 = g_dw41166D + (word32) g_b4116E9 + (word32) (edi < dwLoc24);
	g_dw41166D = esi_19;
	g_dw411709 = g_dw411709 - *g_ptr411901 - (word32) (esi_19 < eax);
}

// 0040688D: void fn0040688D(Register (ptr32 word32) esi)
// Called from:
//      fn004061B8
void fn0040688D(word32 * esi)
{
	if (lstrlenW(&g_t40B52C) == 0x08)
	{
		LoadIconA(*g_ptr40B04C, &g_t40B540);
		*esi = 0x01;
	}
	else
		*esi = 0x03;
	GetKeyState(20850);
}

<anonymous> g_t4068D0 = <code>; // 004068D0
// 00406E0C: Register ui32 fn00406E0C(Register up32 eax, Register ui32 ecx, Register word32 edx, Register word32 esi, Register int32 edi, Register out ptr32 edxOut, Register out Eq_1200 ediOut)
// Called from:
//      fn004061CB
ui32 fn00406E0C(up32 eax, ui32 ecx, word32 edx, word32 esi, int32 edi, ptr32 & edxOut, union Eq_1200 & ediOut)
{
	word32 dwLoc02A8;
	ptr32 fp;
	word32 esi;
	int32 edi;
	bool P;
	ui32 ecx;
	up32 eax;
	word32 edx;
	word32 dwLoc0294;
	word32 dwLoc02B0;
	byte bLoc02AC;
	wLoc02A8 = (word16) dwLoc02A8;
	word32 dwLoc0394;
	word32 dwLoc2C;
	word32 dwLoc0320;
	word32 dwLoc0C;
	word32 dwLoc14;
	word32 dwLoc1C;
	word32 dwLoc18;
	word32 dwLoc30;
	word32 dwLoc34;
	word32 dwLoc38;
	word32 dwLoc24;
	word32 dwLoc28;
	dwLocC0_698 = 0x00;
	while (true)
	{
		dwLocC0_699 = ϕ(dwLocC0_698, dwLocC0_1071);
		eax_239 = ϕ(eax, eax_628);
		esp_32 = fp - 0x5C;
		if (dwLocC0_699 >= 0x17)
			break;
		if (dwLocC0_699 == 0x1D)
			SetPaletteEntries((struct HPALETTE__ *) 0x4977, 30033, 8399, dwLoc28);
		eax_628 = dwLocC0_699 + 0x01;
		dwLocC0_1071 = dwLocC0_699 + 0x01;
	}
	dwLoc20_700 = ~0x1003;
	dwLoc24_703 = ~0x1002;
	esp_36 = fp - 100;
	esi_61 = 13611;
	edi_64 = 0x252A;
	dwLoc38_714 = 0x00;
	v24_70 = g_dw411699 - 0x004116F9;
	g_dw411699 = v24_70;
	eax_73 = fn00407978(out ecx_74, out edx_75);
	v56_690 = !PARITY_EVEN(eax_73);
	if (eax_73 != 0x00)
	{
		fn00406773();
		ecx_93 = g_ptr4118A9;
		edx_94 = (word32) bLoc02AC;
		v26_96 = *ecx_93 - edx_94 - (word32) (dwLoc02B0 < 13611);
		*ecx_93 = v26_96;
		ecx_98 = g_dw40B2D8;
		dwLoc2C_720 = 0x01;
		eax_104 = g_t40B2D4;
		dwLoc1C_721 = ~0x11D4;
		edx_106 = g_ptr4118A1;
		edx_107.u0 = edx_106->u0;
		v27_108 = g_t4116F5.u0 ^ edx_107;
		g_t4116F5.u0 = (ui32) v27_108;
		dwLoc20_722 = ~0x1003;
		dwLoc0C_723 = ~0x1002;
		dwLoc18_724 = ~0x1003;
		dwLoc28_725 = eax_104;
		edx_117 = (word32) wLoc02A8;
		eax_118 = g_dw41172D;
		eax_120 = eax_118 + edx_117 + (word32) (g_t4116C1.u0 < edx_107);
		g_dw41172D = eax_120;
		bLoc05_746 = 0x00;
		dwLoc14_747 = ~0x1003;
		eax_175 = ~0x1002;
		edx_179 = ~0x1002;
		ecx_186 = ecx_98 + ~0x2529 ^ 13611;
		edx_190 = 0x00;
		ebx_191 = ~0x1002 - ecx_186;
		dwLoc38_767 = ecx_186;
		if (ebx_191 != 0x00)
		{
			dwLoc24_1584 = ϕ(dwLoc24_703, dwLoc24_1569);
			dwLoc38_1563 = ϕ(dwLoc38_767, dwLoc38_1549);
			dwLoc18_1418 = ϕ(dwLoc18_724, dwLoc18_948);
			dwLoc20_1397 = ϕ(dwLoc20_722, dwLoc20_1401);
			dwLoc2C_1172 = ϕ(dwLoc2C_720, dwLoc2C_1176);
			dwLoc1C_839 = ϕ(dwLoc1C_721, dwLoc1C_1287);
			dwLoc0C_819 = ϕ(dwLoc0C_723, dwLoc0C_985);
			dwLoc28_776 = ϕ(dwLoc28_725, dwLoc28_1155);
			dwLoc14_774 = ϕ(dwLoc14_747, dwLoc14_927);
			esp_664 = ϕ(esp_36, esp_575);
			edi_236 = ϕ(edi_64, edi_492);
			eax_224 = ϕ(eax_175, eax_548);
			esi_221 = ϕ(esi_61, esi_489);
			v55_689 = ϕ(v56_690, v57_691);
			Mem214 = ϕ(Mem212, Mem205);
			edx_219 = dwLoc28_776;
			ecx_222 = dwLoc14_774 ^ esi_221;
			eax_225 = eax_224 ^ esi_221;
			ebx_226.u0 = g_t411641.u0;
			v35_227 = g_dw4116A9 & ebx_226;
			g_dw4116A9 = v35_227;
		}
	}
	edx_1644 = ϕ(edx_75, edx_190);
	ecx_1643 = ϕ(ecx_74, ecx_186);
	esp_571 = ϕ(esp_36, esp_36, esp_575);
	edi_576.u0 = esp_571->u0;
	edxOut = edx_1644;
	ediOut = edi_576;
	return ecx_1643;
}

// 00407567: Register ui32 fn00407567(Register (ptr32 Eq_1388) eax)
// Called from:
//      Win32CrtStartup
ui32 fn00407567(struct Eq_1388 * eax)
{
	g_ptr40B528 = (char *) eax + 4;
	g_dw40B51C = eax->dw0008;
	ui32 ecx_9 = eax->dw000C;
	g_dw40B520 = ecx_9;
	g_dw40B524 = eax->dw0010;
	return ecx_9;
}

// 0040758B: Register word32 fn0040758B(Stack word32 dwArg04, Stack (ptr32 Eq_1843) dwArg08, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404A3A
word32 fn0040758B(word32 dwArg04, struct Eq_1843 * dwArg08, ptr32 & esiOut, ptr32 & ediOut)
{
	ui32 dwLoc01AC;
	Eq_635 dwLoc10;
	word16 wLoc0E_563 = SLICE(dwLoc10, word16, 16);
	Eq_637 eax_10 = dwArg08->t40B458;
	up32 dwLoc8C_350 = 0x00;
	do
	{
		dwLoc8C_350 = dwLoc8C_571 + 0x01;
		if (dwLoc8C_350 == 0x26)
			eax_10 = PrintDlgExW(dwLoc10);
		dwLoc8C_571 = dwLoc8C_350;
	} while (dwLoc8C_571 < 0x1E);
	g_dw411739 = g_dw411739 ^ (word32) g_b4116B1;
	ui32 eax_76 = eax_10 ^ 13611;
	g_a40B308[(eax_76 + 0x252A) * 0x02] = 0x00;
	ui32 * edx_158 = g_ptr4118C1;
	*edx_158 &= (word32) g_b411705;
	g_dw4116D9 |= *g_ptr411835;
	g_dw411725 &= dwLoc01AC;
	g_t4116C1.u0 = (uint32) 0x00411651;
	g_t4116C1.u0 = (uint32) (g_t4116C1.u0 - 4265621);
	g_t4116C1.u0 = (uint32) (g_t4116C1.u0 & 4265557);
	struct Eq_180 * eax_214 = g_ptr40B2C4;
	g_dw4116D1 = g_dw4116D1 - 0x00411689 - (word32) (g_dw4116C5 > 0xFEF6);
	word16 ** eax_226 = eax_214->ptr000C;
	struct Eq_1937 * esp_239;
	g_ptr40B568();
	<anonymous> * eax_245 = g_ptr40B508;
	esp_239->ptr0014 = 0x0040B308;
	eax_245();
}

// 00407978: Register ui32 fn00407978(Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00406E0C
ui32 fn00407978(ptr32 & ecxOut, ptr32 & edxOut)
{
	word32 dwLoc48;
	Mem32 = Mem12;
	HWND * eax_33 = g_ptr40B070;
	g_t411641.u0 = (ui32) ((word32) g_t411641.u1 ^ dwLoc48);
	Eq_262 eax_104 = *eax_33;
	up32 dwLoc3C_125;
	for (dwLoc3C_125 = 0x00; dwLoc3C_125 < 0x13; ++dwLoc3C_125)
	{
		if (dwLoc3C_125 == 0x1E)
			eax_104 = FindTextW((struct tagFINDREPLACEW *) ~0x1002);
	}
	word32 eax_52 = *g_ptr40B074;
	g_t4116F5.u0 = (ui32) ((word32) g_t4116F5.u1 ^ *g_ptr411899);
	g_dw41167D += 0x7363;
	g_t40B2D4 = eax_104;
	g_dw40B2D8 = eax_52 + (0x04 - g_t40B2D4);
	word32 eax_82 = ~0x1003;
	if (g_t40B2D4 == null)
		eax_82 = ~0x1002;
	ecxOut = 0x252A;
	edxOut = 13611;
	return (eax_82 ^ 13611) + 0x252A;
}

// 00407AAD: void fn00407AAD(Register word32 ecx, Register word32 ebx, Register word32 esi, Register word32 edi)
// Called from:
//      Win32CrtStartup
void fn00407AAD(word32 ecx, word32 ebx, word32 esi, word32 edi)
{
	word32 * fp;
	word32 dwLoc24;
	g_dw4116AD -= 0x00411705;
	g_dw4116AD |= 0x004116D9;
	g_dw4116AD += 0x0041170D;
	g_ptr40B474 = null;
	word32 edx_196;
	if (fn00404A3A(ecx, ebx, esi, edi, out edx_196) != 0x00)
	{
		ui32 edi_181 = ~0x110F;
		word32 esi_168 = 13611;
		do
		{
			if (edi_181 == ~0x1022)
			{
				g_ptr40B474 = fp;
				goto l00407C6E;
			}
			if (edi_181 == ~0x100C)
			{
				word32 dwLoc3C_217;
				for (dwLoc3C_217 = 0x17; dwLoc3C_217 != 0x00; --dwLoc3C_217)
				{
					if (dwLoc3C_217 == 0x1C)
					{
						GetPixel((struct HDC__ *) 32373, 18100, 30308);
						dwLoc24 = 30308;
					}
				}
				if (g_ptr40B474 == null)
					goto l00407C56;
				Mem134 = Mem117;
				word32 * eax_135 = g_ptr40B474;
				*eax_135 += g_dw40B0F0;
			}
			else if (edi_181 == ~0x11C2)
			{
				g_dw40B2FC = g_dw40B488;
				g_ptr40B300 = g_ptr40B48C;
				g_dw40B304 = g_dw40B490;
				g_ptr40B2F8 = fp - 0x0C;
				*g_ptr40B494 = fn00405402(fp - 0x0C, edx_196, dwLoc24, out edx_196, out esi_168);
			}
			else
			{
l00407C56:
			}
l00407C6E:
			g_dw411731 = g_dw411731 ^ 4265561;
			edi_181 = (edi_181 ^ esi_168) - (esi_168 ^ ~0x1003) - 0x252A ^ esi_168;
		} while (edi_181 != ~0x1003);
	}
}

// subject_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 * g_ptr40B028 = &g_dw401024; // 0040B028
ui32 ** g_ptr40B034 = &g_ptr40B028; // 0040B034
ui32 *** g_ptr40B038 = &g_ptr40B034; // 0040B038
Eq_270 g_t40B040 = &g_t400000; // 0040B040
HINSTANCE * g_ptr40B04C = &g_t40B040; // 0040B04C
Eq_262 g_t40B058 = &g_t402000; // 0040B058
word32 g_dw40B064 = 4213244; // 0040B064
HWND * g_ptr40B070 = &g_t40B058; // 0040B070
word32 * g_ptr40B074 = &g_dw40B064; // 0040B074
struct Eq_688 * g_ptr40B07C = null; // 0040B07C
up32 g_dw40B080 = 0x00; // 0040B080
word32 g_dw40B084 = ~0x2032; // 0040B084
word32 g_dw40B088 = ~0x3022; // 0040B088
int32 g_dw40B08C = 15917; // 0040B08C
word32 * g_ptr40B0C4 = &g_dw40B084; // 0040B0C4
int32 * g_ptr40B0CC = &g_dw40B08C; // 0040B0CC
word32 g_dw40B0DC = 0x00; // 0040B0DC
WNDCLASSEXA * g_ptr40B0E0 = null; // 0040B0E0
word32 g_dw40B0E4 = 0x00; // 0040B0E4
word32 g_dw40B0F0 = 0x00; // 0040B0F0
word32 g_dw40B0F4 = 0x00; // 0040B0F4
word32 g_dw40B0F8 = 0x00; // 0040B0F8
word32 * g_ptr40B0FC = null; // 0040B0FC
Eq_180 g_t40B100 = // 0040B100
	{
		&g_ptr40B07C,
		&g_ptr40B0F8,
		0x00,
	};
word32 * g_ptr40B10C = &g_dw40B0F8; // 0040B10C
struct Eq_180 * g_ptr40B2C4 = &g_t40B100; // 0040B2C4
Eq_262 g_t40B2D4 = &g_t5456465; // 0040B2D4
word32 g_dw40B2D8 = 0x05475774; // 0040B2D8
ui32 g_dw40B2E0 = 4204332; // 0040B2E0
ptr32 g_ptr40B2EC = 0x06546406; // 0040B2EC
word32 g_dw40B2F0 = 6624259; // 0040B2F0
ui32 g_dw40B2F4 = 15080039; // 0040B2F4
word32 * g_ptr40B2F8 = &g_dw77710; // 0040B2F8
word32 g_dw40B2FC = 0x06751710; // 0040B2FC
WNDCLASSEXA * g_ptr40B300 = &g_t60710; // 0040B300
word32 g_dw40B304 = 0x07655767; // 0040B304
word16 g_a40B308[] = // 0040B308
	{
	};
word32 * g_ptr40B474 = &g_dw342501; // 0040B474
word32 g_dw40B488 = 488802; // 0040B488
WNDCLASSEXA * g_ptr40B48C = &g_t77777; // 0040B48C
word32 g_dw40B490 = 0x08764664; // 0040B490
word32 * g_ptr40B494 = &g_dw42406; // 0040B494
word32 g_dw40B4A8 = 0x00; // 0040B4A8
WCHAR g_t40B4D0 = 'h'; // 0040B4D0
struct tagTEXTMETRICA g_t40B500 = // 0040B500
	{
		0x72657375,
		0x00003233,
		0,
		0x0040643A,
		0x7274736C,
		0x576E656C,
		0,
		0x00787616,
		3479004,
		0x08974774,
		1988494384,
		111,
		0x00,
		115,
		0x00,
		0x70,
		0x00,
		100,
		0x00,
		0x61,
	};
<anonymous> * g_ptr40B508 = null; // 0040B508
<anonymous> * g_ptr40B50C = fn0040643A; // 0040B50C
ui32 g_dw40B51C = 0x00787616; // 0040B51C
ui32 g_dw40B520 = 3479004; // 0040B520
ui32 g_dw40B524 = 0x08974774; // 0040B524
ptr32 g_ptr40B528 = 1988494384; // 0040B528
WCHAR g_t40B52C = 'o'; // 0040B52C
CHAR g_t40B540 = 'd'; // 0040B540
<anonymous> * g_ptr40B568 = &g_t4068D0; // 0040B568
word32 g_dw40B56C = 0x00405A42; // 0040B56C
Eq_1337 g_t411641 = // 00411641
	{
		0x00105E54
	};
Eq_12 g_t411645 = // 00411645
	{
		0x0010611D
	};
ui32 g_dw41164D = 1050955; // 0041164D
ui32 g_dw411665 = 0x00100706; // 00411665
ui32 g_dw411669 = 0x00106914; // 00411669
up32 g_dw41166D = 0x00104CD4; // 0041166D
word32 g_dw41167D = 0x001040D2; // 0041167D
word32 g_dw411681 = 0x00100FA5; // 00411681
ui32 g_dw411685 = 0x00101326; // 00411685
word32 g_dw411689 = 0x00103D68; // 00411689
word32 g_dw41168D = 0x00105246; // 0041168D
ui32 g_dw411699 = 0x0010602D; // 00411699
word32 g_dw41169D = 1071221; // 0041169D
ui32 g_dw4116A9 = 0x0010323E; // 004116A9
ui32 g_dw4116AD = 1079731; // 004116AD
byte g_b4116B1 = 0x54; // 004116B1
byte g_b4116B5 = 229; // 004116B5
uint8 g_b4116BD = 0x84; // 004116BD
Eq_1328 g_t4116C1 = // 004116C1
	{
		0x0010000D
	};
up32 g_dw4116C5 = 0x00101979; // 004116C5
ui32 g_dw4116C9 = 0x001060CC; // 004116C9
word32 g_dw4116CD = 0x00100E00; // 004116CD
ui32 g_dw4116D1 = 0x0010030F; // 004116D1
ui32 g_dw4116D5 = 1071949; // 004116D5
ui32 g_dw4116D9 = 0x00106404; // 004116D9
ui32 g_dw4116DD = 1060476; // 004116DD
word32 g_dw4116E1 = 0x00101671; // 004116E1
ui32 g_dw4116E5 = 0x001068EA; // 004116E5
byte g_b4116E9 = 0x27; // 004116E9
Eq_196 g_t4116ED = // 004116ED
	{
		0x3D66
	};
ui32 g_dw4116F1 = 0x00103DF3; // 004116F1
Eq_1617 g_t4116F5 = // 004116F5
	{
		0x00100FDF
	};
struct _COMMTIMEOUTS g_t4116FD = // 004116FD
	{
		0x00107371,
		0x00103191,
		0x00104208,
		0x00102CCC,
		0x001061F2,
	};
word32 g_dw411701 = 0x00103191; // 00411701
byte g_b411705 = 0x08; // 00411705
ui32 g_dw411709 = 0x00102CCC; // 00411709
word32 g_dw411715 = 0x00103110; // 00411715
ui32 g_dw411719 = 1057500; // 00411719
byte g_b41171D = 0x8A; // 0041171D
ui32 g_dw411725 = 0x00104335; // 00411725
word32 g_dw41172D = 0x00101A06; // 0041172D
ui32 g_dw411731 = 1075100; // 00411731
word32 g_dw411735 = 0x0010454B; // 00411735
ui32 g_dw411739 = 0x00104A9A; // 00411739
word32 * g_ptr411831 = &g_dw411665; // 00411831
ui32 * g_ptr411835 = &g_dw411669; // 00411835
word32 * g_ptr41184D = &g_dw411681; // 0041184D
ui32 * g_ptr411859 = &g_dw41168D; // 00411859
word32 * g_ptr411869 = &g_dw41169D; // 00411869
byte * g_ptr411881 = &g_b4116B5; // 00411881
uint8 * g_ptr411889 = &g_b4116BD; // 00411889
word32 * g_ptr411899 = &g_dw4116CD; // 00411899
union Eq_1328 * g_ptr4118A1 = &g_t4116D5; // 004118A1
ui32 * g_ptr4118A5 = &g_dw4116D9; // 004118A5
ui32 * g_ptr4118A9 = &g_dw4116DD; // 004118A9
word32 * g_ptr4118AD = &g_dw4116E1; // 004118AD
ui32 * g_ptr4118BD = &g_dw4116F1; // 004118BD
ui32 * g_ptr4118C1 = &g_dw4116F5; // 004118C1
ui32 * g_ptr4118D1 = &g_dw411705; // 004118D1
ui32 * g_ptr4118E1 = &g_dw411715; // 004118E1
ui32 * g_ptr4118F9 = &g_dw41172D; // 004118F9
word32 * g_ptr411901 = &g_dw411735; // 00411901
CHAR g_t411955 = 'E'; // 00411955
// subject_edata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw433078 = 0x0003310C; // 00433078
word32 g_dw43307C = 0x00033120; // 0043307C
word32 g_dw433080 = 209200; // 00433080
word32 g_dw433084 = 0x0003313C; // 00433084
word32 g_dw433088 = 209224; // 00433088
word32 g_dw43308C = 209242; // 0043308C
word32 g_dw433094 = 209266; // 00433094
word32 g_dw43309C = 209294; // 0043309C
word32 g_dw4330A0 = 0x0003319E; // 004330A0
word32 g_dw4330A4 = 209332; // 004330A4
word32 g_dw4330A8 = 0x000331C8; // 004330A8
word32 g_dw4330AC = 0x000331E0; // 004330AC
word32 g_dw4330B0 = 0x000331EC; // 004330B0
word32 g_dw4330B4 = 0x000331FE; // 004330B4
word32 g_dw4330B8 = 209420; // 004330B8
word32 g_dw4330BC = 0x00033222; // 004330BC
word32 g_dw4330C0 = 0x00033234; // 004330C0
word32 g_dw4330C8 = 0x00033250; // 004330C8
word32 g_dw4330CC = 209502; // 004330CC
word32 g_dw4330D4 = 0x00033278; // 004330D4
word32 g_dw4330D8 = 209550; // 004330D8
word32 g_dw4330DC = 0x0003329A; // 004330DC
word32 g_dw4330E0 = 0x000332A6; // 004330E0
word32 g_dw4330E4 = 0x000332BA; // 004330E4
word32 g_dw4330E8 = 0x000332CC; // 004330E8
word32 g_dw4330EC = 209626; // 004330EC
word32 g_dw4330F0 = 0x000332E6; // 004330F0
word32 g_dw4330F4 = 0x000332FA; // 004330F4
word32 g_dw4330F8 = 0x0003330A; // 004330F8
word32 g_dw4330FC = 0x0003331C; // 004330FC
word32 g_dw433100 = 0x0003332A; // 00433100
word32 g_dw433104 = 0x0003333A; // 00433104
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__SetPaletteEntries = &g_t3310C; // 00401000
<anonymous> * __imp__GetDeviceCaps = &g_t33120; // 00401004
<anonymous> * __imp__GetPixel = &g_t33130; // 00401008
<anonymous> * __imp__GetRgnBox = &g_t3313C; // 0040100C
<anonymous> * __imp__GetTextMetricsA = &g_t33148; // 00401010
<anonymous> * __imp__StretchBlt = &g_t3315A; // 00401014
<anonymous> * __imp__PathGetArgsA = &g_t33172; // 0040101C
<anonymous> * __imp__SetSystemTime = &g_t3318E; // 00401024
<anonymous> * __imp__GetCurrentProcessId = &g_t3319E; // 00401028
<anonymous> * __imp__SetWaitableTimer = &g_t331B4; // 0040102C
<anonymous> * __imp__WaitForSingleObjectEx = &g_t331C8; // 00401030
<anonymous> * __imp__lstrlenW = &g_t331E0; // 00401034
<anonymous> * __imp__GetCommTimeouts = &g_t331EC; // 00401038
<anonymous> * __imp__ExitThread = &g_t331FE; // 0040103C
<anonymous> * __imp__EnumResourceNamesW = &g_t3320C; // 00401040
<anonymous> * __imp__CreateMailslotW = &g_t33222; // 00401044
<anonymous> * __imp__HeapCreate = &g_t33234; // 00401048
<anonymous> * __imp__PrintDlgExW = &g_t33250; // 00401050
<anonymous> * __imp__FindTextW = &g_t3325E; // 00401054
<anonymous> * __imp__CreateDialogParamA = &g_t33278; // 0040105C
<anonymous> * __imp__DrawTextW = &g_t3328E; // 00401060
<anonymous> * __imp__LoadIconA = &g_t3329A; // 00401064
<anonymous> * __imp__RegisterClassExA = &g_t332A6; // 00401068
<anonymous> * __imp__GetKeyNameTextW = &g_t332BA; // 0040106C
<anonymous> * __imp__DrawStateA = &g_t332CC; // 00401070
<anonymous> * __imp__DrawTextA = &g_t332DA; // 00401074
<anonymous> * __imp__LoadAcceleratorsA = &g_t332E6; // 00401078
<anonymous> * __imp__DefFrameProcW = &g_t332FA; // 0040107C
<anonymous> * __imp__CascadeWindows = &g_t3330A; // 00401080
<anonymous> * __imp__GetKeyState = &g_t3331C; // 00401084
<anonymous> * __imp__DestroyCaret = &g_t3332A; // 00401088
<anonymous> * __imp__GetMonitorInfoW = &g_t3333A; // 0040108C
