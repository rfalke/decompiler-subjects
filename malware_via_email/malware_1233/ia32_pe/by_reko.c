// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00401018();
	struct Eq_6 * ebx_28 = DPB(dwLoc14, 0x00, 0);
	struct Eq_10 * eax_31 = ebx_28 + ebx_28->dw003C / 0x0040;
	struct Eq_15 * edx_33 = &eax_31->w0014 + 0x02 + (word32) eax_31->w0014 / 22;
	ptr32 eax_41 = ebx_28 + edx_33->dw0034 / 0x0040;
	fn0040109F(0x10066F2F);
	struct Eq_33 * esp_71;
	word32 ebp_72;
	word32 edi_73;
	word32 esi_74;
	word32 ebx_75;
	word32 ecx_76;
	byte SZO_77;
	word32 eax_78;
	byte cl_79;
	byte SCZO_80;
	word32 edx_81;
	word16 bx_82;
	byte C_83;
	(eax_41 + 0x07EF)();
	word32 ecx_86 = esp_71->dw0004;
	<anonymous> * eax_88 = esp_71->ptr0008;
	esp_71->dw0018 = ecx_86;
	word32 esp_100;
	word32 ebp_101;
	word32 edi_102;
	word32 esi_103;
	word32 ebx_104;
	word32 ecx_105;
	byte SZO_106;
	word32 eax_107;
	byte cl_108;
	byte SCZO_109;
	word32 edx_110;
	word16 bx_111;
	byte C_112;
	eax_88();
	return fn00401064(dwArg00, dwArg04);
}

// 00401018: void fn00401018()
void fn00401018()
{
	return;
}

// 00401064: Register uint32 fn00401064(Stack ptr32 dwArg04, Stack word32 dwArg08)
uint32 fn00401064(ptr32 dwArg04, word32 dwArg08)
{
	byte * edx_32 = dwArg04;
	word32 ecx_106 = dwArg08;
	if (dwArg08 == 0x00)
	{
		byte * edi_100 = dwArg04;
		do
		{
			edi_100 = edi_108 + 0x01;
			byte * edi_108 = edi_100;
		} while (0x00 != *edi_108);
		ecx_106 = edi_100 - 0x01 - dwArg04;
	}
	uint32 eax_41 = ~0x00;
	byte al_42 = (byte) eax_41;
	do
	{
		eax_41 = DPB(eax_41, al_42 ^ *edx_32, 0);
		edx_32 = edx_32 + 0x01;
		byte bl_56 = 0x08;
		do
		{
			eax_41 = eax_41 >> 0x01;
			al_42 = (byte) eax_41;
			if (eax_41 < 0x00)
			{
				eax_41 = eax_41 ^ 3988292384;
				al_42 = (byte) (eax_41 ^ 3988292384);
			}
			bl_56 = bl_56 - 0x01;
		} while (bl_56 != 0x00);
		ecx_106 = ecx_106 - 0x01;
	} while (ecx_106 != 0x00);
	return ~eax_41;
}

// 0040109F: void fn0040109F(Stack word32 dwArg04)
void fn0040109F(word32 dwArg04)
{
	struct Eq_130 * edx_35 = fs->ptr0030->ptr000C->ptr000C;
	do
	{
		edx_35 = edx_35->ptr0000;
		byte * edi_57 = fp - 0x1D;
		word16 * esi_58 = edx_35->ptr0030;
		word32 ecx_178 = 0x0D;
l004010C0:
		word16 ax_63 = *esi_58;
		*edi_57 = (byte) ax_63;
		esi_58 = esi_58 + 0x01;
		edi_57 = edi_57 + 0x01;
		if (ax_63 != 0x00)
		{
			ecx_178 = ecx_178 - 0x01;
			if (ecx_178 != 0x00)
				goto l004010C0;
		}
		word32 ecx_72 = 0x0D;
		byte * esi_73 = fp - 0x1D;
		byte * edi_74 = fp - 0x1D;
		do
		{
			cu8 al_174 = *esi_73;
			esi_73 = esi_73 + 0x01;
			if (al_174 >= 0x41 && al_174 <= 0x5A)
				al_174 = al_174 + 0x20;
			*edi_74 = al_174;
			edi_74 = edi_74 + 0x01;
			ecx_72 = ecx_72 - 0x01;
		} while (ecx_72 != 0x00);
	} while ((fn00401064(fp - 0x1D, 0x00) ^ 0x6AE69F02) != 0x00);
	struct Eq_209 * eax_106 = edx_35->ptr0018;
	word32 * esi_112 = (char *) (eax_106 + (&(eax_106 + eax_106->dw003C / 0x0040)->dw003C)[0x0F] / 0x0040) + 0x001C;
	word32 * edi_113 = fp - 0x10;
	word32 ecx_114 = 0x03;
	do
	{
		*edi_113 = eax_106 + *esi_112 / 0x0040;
		esi_112 = esi_112 + 0x01;
		edi_113 = edi_113 + 0x01;
		ecx_114 = ecx_114 - 0x01;
	} while (ecx_114 != 0x00);
	word32 * esi_126 = dwLoc0C;
	do
	{
		esi_126 = esi_179 + 0x01;
		word32 * esi_179 = esi_126;
	} while (dwArg04 != fn00401064(eax_106 + *esi_179 / 0x0040, 0x00));
	return;
}

