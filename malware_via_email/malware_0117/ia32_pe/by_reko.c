// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_26 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = 0x00;
	word32 ebx_249 = eax_26 + 0x25;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		ebx_249 = eax_26 + 0x03;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 44);
	struct Eq_49 * esp_50 = fp - 0x4C;
	struct Eq_52 * eax_55 = null;
	do
	{
		if (esi_15 == ebx_249)
			esi_15.u0 = 0x00;
		eax_55[4199032] = (struct Eq_52) (eax_55[4199032] ^ *((word32) esi_15 + 0x00404000));
		eax_55 = eax_55 + 0x01;
		esi_15 = (word32) esi_15 + 0x01;
	} while (eax_55 < (struct Eq_52 *) 5152);
	struct Eq_74 * ecx_106 = &globals->t402558;
	uint32 dwLoc38_110 = 0x00;
	do
	{
		Eq_78 eax_94 = ecx_106->t0004;
		word16 * edx_228 = (char *) &ecx_106->t0004 + 0x04;
		if (eax_94 - 0x08 >> 0x01 > 0x00)
		{
			uint32 esi_227 = eax_94 - 0x08 >> 0x01;
			do
			{
				ui32 eax_230 = (word32) *edx_228;
				if ((eax_230 & 0xF000) == 0x3000)
				{
					struct Eq_100 * eax_241 = (eax_230 & 0x0FFF) + ecx_106->dw0000;
					eax_241->dw400FF8 = eax_241->dw400FF8 + 0xF0400FF8;
				}
				edx_228 = edx_228 + 0x01;
				esi_227 = esi_227 - 0x01;
			} while (esi_227 != 0x00);
		}
		Eq_78 eax_103 = ecx_106->t0004;
		uint32 edx_105 = (word32) eax_103.u0 + dwLoc38_110;
		ecx_106 = ecx_106 + eax_103;
		dwLoc38_110 = edx_105;
	} while (edx_105 < 228);
	struct Eq_124 * esi_113 = &globals->t401D54;
	esi_135 = esi_113;
	esp_138 = esp_50;
	if (globals->dw401D64 != 0x00)
	{
		do
		{
			struct Eq_124 * esi_135;
			struct Eq_49 * esp_138;
			esp_138 = esp_138 - 0x04;
			esp_138->dw0000 = esi_135->dw000C + 0x00400FF8;
			Eq_171 eax_143 = LoadLibraryA(esp_138->dw0000);
			esp_138[0x03] = (struct Eq_49) eax_143;
			Eq_171 edi_144 = eax_143;
			if (eax_143 != null)
			{
				word32 ebx_163 = esi_135->dw0000;
				if (ebx_163 == 0x00)
					ebx_163 = esi_135->dw0010;
				word32 * ebx_168 = ebx_163 + 0x00400FF8;
				word32 eax_171 = *ebx_168;
				word32 * esi_172 = esi_135->dw0010 + 0x00400FF8;
				bool S_175 = cond(eax_171);
				if (eax_171 != 0x00)
				{
					do
					{
						Eq_232 eax_201;
						if (!S_175)
						{
							struct Eq_258 * esp_214 = esp_138 - 0x04;
							esp_214->t0000 = (word32) *ebx_168;
							*(esp_214 - 0x04) = (HMODULE *) edi_144;
							eax_201 = GetProcAddress(*(esp_214 - 0x04), esp_214->t0000);
							edi_144 = esp_214->t0014;
						}
						else
						{
							LPCSTR * esp_221 = esp_138 - 0x04;
							*esp_221 = (LPCSTR *) (eax_171 + 0x00400FFA);
							*(esp_221 - 0x04) = (HMODULE *) edi_144;
							eax_201 = GetProcAddress(*(esp_221 - 0x04), *esp_221);
						}
						*esi_172 = (word32) eax_201;
						ebx_168 = ebx_168 + 0x01;
						eax_171 = *ebx_168;
						esp_138 = esp_138 - 0x08;
						esi_172 = esi_172 + 0x01;
						S_175 = cond(eax_171);
					} while (eax_171 != 0x00);
				}
				esi_135 = esp_138->dw0014;
			}
			esi_135 = esi_135 + 0x01;
			esp_138->dw0014 = esi_135;
		} while (esi_135->dw0010 != 0x00);
	}
	ptr32 esp_117;
	byte SCZO_118;
	word32 ebx_119;
	word32 ebp_120;
	word32 esi_121;
	word32 edi_122;
	byte SZO_123;
	byte C_124;
	word32 eax_125;
	byte Z_126;
	word32 edx_127;
	byte cl_128;
	word32 ecx_129;
	byte S_130;
	globals->t401A48();
	*(esp_117 - 0x04) = 0x00;
	ExitProcess(*(esp_117 - 0x04));
}

