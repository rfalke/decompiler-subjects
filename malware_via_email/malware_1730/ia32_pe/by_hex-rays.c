/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall start(char@<al>, int@<edx>, int _ECX@<ecx>, int _EBX@<ebx>, int@<ebp>, int@<edi>, int _ESI@<esi>);


//----- (0040C637) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __usercall start(
        char a1@<al>,
        int a2@<edx>,
        int _ECX@<ecx>,
        int _EBX@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int _ESI@<esi>)
{
  int v9; // eax
  int v10; // edi
  unsigned int v12; // eax
  bool v13; // cc
  int v17; // ebx
  int v18; // ecx
  char v20; // al
  bool v21; // cf
  char v24; // al
  unsigned int v25; // ebx
  bool v26; // cf
  unsigned int v27; // ebx
  int v29; // edx
  bool v30; // of
  int v31; // edx
  bool v35; // cf
  bool v37; // tt
  unsigned int v39; // esi
  int v42; // edi
  unsigned int v43; // ebx
  __int16 v46; // t2
  char v51; // tt
  bool v52; // cf
  unsigned int v53; // edi
  unsigned int v54; // ett
  int v55; // eax
  unsigned int v56; // esi
  int v57; // edi
  unsigned int v58; // esi
  int v59; // ecx
  char v61; // cl
  int v62; // eax
  bool v63; // cf
  bool v64; // tt
  int v65; // edi
  bool v67; // zf
  char v68; // of
  unsigned int v69; // ecx
  unsigned int v71; // edi
  char v74; // cf
  int v76; // esi
  int v79; // edi
  unsigned int v80; // esi
  int v84; // eax
  int v86; // edi
  int v87; // esi
  int v88; // esi
  unsigned int v89; // edx
  int v90; // edx
  bool v92; // zf
  bool v93; // cc
  unsigned int v94; // ecx
  unsigned int v95; // et2
  int v96; // edx
  unsigned int v97; // esi
  int v99; // esi
  char v101; // tt

  __asm { rcl     ebx, cl }
  BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ECX);
  BYTE1(a2) &= a1 >> _ECX;
  ++BYTE1(_ECX);
  _ECX = __ROR4__(_ECX, _ECX);
  __asm
  {
    rcr     esi, cl
    rcr     bl, cl
  }
  v79 = _EBX | a6;
  v80 = -1429434730;
  _EBX = __ROR4__(a2 + _EBX, _ECX);
  LOBYTE(_ECX) = BYTE1(a2) & _ECX;
  BYTE1(a2) <<= _ECX;
  _EAX = _ECX;
  _EDI = a2 + (v79 << _ECX);
  BYTE1(a2) <<= _ECX;
  LOBYTE(a2) = BYTE1(a2);
  __asm { rcr     edi, cl }
  v37 = __CFSHL__(a2, _ECX);
  _EDX = __ROL4__(a2, _ECX);
  v35 = v37;
  do
  {
    BYTE1(_ECX) -= v35 - 115;
    LOBYTE(_EDX) = _EDX + 1;
    BYTE1(_EAX) = -50;
    LOBYTE(_EAX) = BYTE1(_ECX) | BYTE1(_EBX) & _EAX;
    v80 -= 680421542;
    BYTE1(_EDX) >>= _ECX;
    _EAX ^= _ECX;
    v35 = v80 < 0xAD5258C0;
  }
  while ( v80 != -1387112256 );
  BYTE1(_ECX) ^= 0x5Du;
  if ( __SETP__(BYTE1(_ECX), 0) || !__SETP__(BYTE1(_ECX), 0) )
  {
    v35 = __CFSHR__(_EAX, _ECX);
    LOBYTE(_EAX) = (char)_EAX >> _ECX;
    v61 = v35 + _ECX + 95;
    v62 = _EAX >> v61;
    v64 = __CFSHL__(_EDX, v61);
    LOBYTE(_EDX) = __ROL1__(_EDX, v61);
    v63 = v64;
    if ( !v64 && _EDI >> v61 != 0 && (v63 || _EDI >> v61 == 0) )
      JUMPOUT(0x40C49A);
    v9 = v62 - 1;
    LOBYTE(_EDX) = _EDX - v9;
    LOBYTE(v9) = BYTE1(v9) | v9;
    BYTE1(v9) ^= 0x93u;
    v10 = _EBX - v9;
    LOBYTE(_EDX) = (_BYTE)_EDX << _EBX;
    _ECX = _EBX - 1;
    v12 = _EDX;
    v13 = (char)_EDX <= -73;
    LOBYTE(_EDX) = _EDX + 73;
    if ( !v13 && v13 )
    {
      v35 = *(_BYTE *)(a5 + 2 * v10 - 772374432) < 0xAu;
      *(_BYTE *)(a5 + 2 * v10 - 772374432) -= 10;
      _disable();
      _ECX = _ECX >> _ECX;
      LOBYTE(_EDX) = BYTE1(_EDX) + BYTE1(_EDX) + v35 + _EDX;
      BYTE1(_ECX) <<= _ECX;
      __asm { rcr     edx, cl }
      _EBX = v12 + _EBX;
      __asm { rcr     ebx, cl }
      v84 = 3;
      __asm { rcr     ch, cl }
      BYTE1(_ECX) += 7;
      v35 = __CFSHL__(_ECX, _ECX);
      _ECX = _ECX << _ECX;
      v39 = (v10 ^ 0xAD5258C0) - 1 - (v35 + _EBX);
      BYTE1(_ECX) ^= 0x85u;
      BYTE1(_EBX) -= BYTE1(_ECX);
      _ECX -= 3;
      LOBYTE(_ECX) = (_ECX | 0x47) + 18;
      __asm { rcr     bh, cl }
      LOBYTE(_EBX) = (_EBX - 54) ^ 0xCA;
      LOBYTE(_ECX) = (BYTE1(_EBX) << _ECX) & __ROR1__(
                                               __CFSHL__(BYTE1(_EBX), _ECX) + _ECX + 125,
                                               __CFSHL__(BYTE1(_EBX), _ECX) + _ECX + 125);
      _EDX = 0;
      _ECX = v39 & (_ECX << _ECX);
      LOBYTE(_ECX) = _ECX ^ 0x98;
      BYTE1(_EBX) = 0;
      ++_EBX;
      v87 = _ECX + 1;
      BYTE1(_ECX) = __ROR1__(_ECX, _ECX);
      SBYTE1(_EBX) >>= _ECX;
      __GS__ = 3;
      _EBX = _EBX + 1;
      v99 = v87 << _ECX;
      LOBYTE(_ECX) = _ECX - 65;
      _EDI = v99;
      BYTE1(_EBX) ^= 0xD8u;
      v74 = 0;
      LOBYTE(_EBX) = _EBX + 1;
      goto LABEL_40;
    }
    __asm { rcr     dh, cl }
    _EDX = __ROL4__(_EDX, _ECX);
    v18 = _ECX - _EDX;
    LOBYTE(v18) = (_BYTE)v18 << v18;
    LOBYTE(_EDX) = _EDX & 0x56;
    v20 = v12 - 58;
    v21 = __CFADD__(v20, -127);
    LOBYTE(v12) = v20 - 127;
    if ( v21 || !v21 )
    {
      LOBYTE(v12) = __ROL1__(v12, v18);
      LOBYTE(v18) = BYTE1(_EBX) + v18;
      LOBYTE(v12) = __ROR1__(v12, v18);
      BYTE1(_EDX) <<= v18;
      _ECX = _EBX & (_EBX ^ v18);
      v71 = v12 + (v10 | 0xAD5258C0);
      LOBYTE(_EDX) = _EDX | 0x9F;
      v55 = __ROR4__(_EDX + v12, _ECX);
      __asm { rcl     dl, cl }
      BYTE1(v55) |= _EBX;
      BYTE1(_ECX) = __ROL1__(BYTE1(v55) & BYTE1(_ECX), _ECX);
      ++v71;
      LOBYTE(_ECX) = __ROL4__(_ECX, _ECX);
      LOBYTE(v55) = __ROR1__(v55 - 1, _ECX);
      v35 = v71 < (unsigned int)__CFSHR__(v55, _ECX) + _EDX;
      _EDI = v71 - (__CFSHR__(v55, _ECX) + _EDX);
      LOBYTE(_ECX) = v35 + _ECX + 15;
      __asm { rcr     edi, cl }
      JUMPOUT(0x40C51A);
    }
    _CL = _EDX + v18;
    __asm { rcl     bl, cl }
  }
  else
  {
    LOBYTE(_EAX) = _EAX - 46;
    --a5;
    *(_DWORD *)_EDI = _EAX;
    v65 = _EDI + 4;
LABEL_33:
    v35 = __CFADD__(_EDX, v65);
    _EDI = _EDX + v65;
    LOBYTE(_ECX) = (_ECX & 0xCA) - (v35 + 26);
    BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ECX);
    _ESI = __ROL4__(v80, _ECX);
    BYTE1(_ECX) ^= _EAX ^ BYTE1(_EDX);
    v67 = BYTE1(_ECX) == 0;
    LOBYTE(_ECX) = __ROR1__((char)_ECX >> _ECX, (char)_ECX >> _ECX);
    if ( ((_ECX & 0x8000) != 0) == v68 && ((_ECX & 0x8000) != 0) != v68 )
    {
      *(_DWORD *)_EDI = _EAX;
      v69 = _ECX - 1;
      if ( v67 )
      {
        if ( v69 )
          JUMPOUT(0x40C4AB);
      }
      __halt();
    }
    while ( 1 )
    {
      v97 = _ECX + _ESI;
      if ( _EDX == 20095697 )
        break;
      LOBYTE(_ECX) = (_ECX - ((_EDX < 0x132A2D1) - 59)) & 0xDC;
      v99 = v97 - _EDI;
      BYTE1(_ECX) -= 59;
      LOBYTE(_EBX) = BYTE1(_EDX) & 0x27;
      BYTE1(_EBX) ^= BYTE1(_EAX);
      _ECX = _EDI & _ECX;
      __asm { rcl     ebx, cl }
      _ECX = _EBX & __ROL4__(_ECX, _ECX);
      v101 = _EAX & 1;
      v84 = __ROR4__(_EAX, 1);
      v74 = v101;
      if ( !v101 )
      {
        __asm { rcl     ecx, cl }
        _BH = BYTE1(_EBX) + 1;
        __asm { rcl     bh, cl }
        JUMPOUT(0x40C561);
      }
LABEL_40:
      v76 = v99 - (v74 + _ECX);
      LOBYTE(_EBX) = _EBX - (__CFADD__(BYTE1(_EBX), 40) + BYTE1(v84));
      v56 = _EDI + v76;
      BYTE1(_EBX) = _EDX;
      v59 = _EBX ^ __ROR4__(_ECX, _ECX);
      v57 = v56 ^ _EDI;
      v58 = v59 + v56;
      BYTE1(v59) -= _EDX;
      if ( !__SETP__(BYTE1(v59), 0) && __SETP__(BYTE1(v59), 0) )
      {
        if ( v84 - 1 >= 0 )
        {
          __debugbreak();
          JUMPOUT(0x40C3F5);
        }
        JUMPOUT(0x40C415);
      }
      BYTE1(_EBX) = (unsigned __int8)_EDX >> v59;
      _ECX = v84 | v59;
      LOBYTE(_ECX) = _ECX + 92;
      v35 = __CFSHR__(_EBX, _ECX);
      _EBX = _EBX >> _ECX;
      BYTE1(_EBX) -= __CFSHL__(v57, _ECX) + 58;
      __asm { rcl     bh, cl }
      _ESI = (v58 - (v35 + _EDX)) << _ECX;
      LOBYTE(_EBX) = (_EBX & 0x89) << _ECX;
      _EAX = __GS__;
      v35 = __CFADD__((_BYTE)_EBX, BYTE1(_EBX));
      BYTE1(_EBX) += _EBX;
      v86 = (v57 << _ECX << _ECX) - (v35 + _ESI);
      SBYTE1(_EBX) >>= _ECX;
      LOBYTE(_ECX) = _ECX - BYTE1(_EBX);
      LOBYTE(_EBX) = (_BYTE)_EBX << _ECX;
      v42 = v86 >> _ECX;
      LOBYTE(_ECX) = __ROL1__(_ECX, _ECX);
      v43 = _EDX | _EBX;
      LOBYTE(v43) = v43 + 120;
      SBYTE1(_ECX) >>= _ECX;
      if ( __SETP__(BYTE1(_ECX), 0) || !__SETP__(BYTE1(_ECX), 0) )
      {
        BYTE1(_ECX) = __ROL1__(BYTE1(_ECX), _ECX);
        v88 = __ROL4__(_ESI, _ECX);
        _ECX = _ECX >> _ECX;
        BYTE1(v43) = 0;
        LOBYTE(_ECX) = _ECX + 1;
        v17 = v88 ^ (v43 - (((unsigned __int8)_ECX < 0x23u) + _EDX++));
        v65 = _ECX + 1;
        LOBYTE(_ECX) = v17 | (((_BYTE)_ECX - 35) << (_ECX - 35));
        v80 = v88 >> _ECX;
        _EBX = (v17 << _ECX) - (__CFSHL__(v17, _ECX) + _ECX);
        LOBYTE(_ECX) = ((unsigned __int8)_ECX >> _ECX) & 0x4C;
        __asm { rcl     bh, cl }
        BYTE1(_EBX) = _EDX;
        LOBYTE(_ECX) = __GS__ & _ECX | 0x63;
        goto LABEL_33;
      }
      __asm { aam     0E0h ; 'à' }
      v46 = (unsigned __int16)_EAX % *(unsigned __int8 *)(_EDX - 85);
      LOBYTE(_EAX) = (unsigned __int16)_EAX / *(unsigned __int8 *)(_EDX - 85);
      BYTE1(_EAX) = (BYTE1(_EDX) & v46) + 1;
      LOBYTE(_EAX) = _EAX + 1;
      BYTE1(_EDX) += 94;
      __asm { rcl     eax, cl }
      LOBYTE(_EDX) = (char)_EDX >> _ECX;
      __asm { rcl     eax, cl }
      v35 = __CFSHL__(v42, _ECX);
      _EDI = v42 << _ECX;
      __asm { rcl     edi, cl }
      v51 = v35 + 11;
      v35 = BYTE1(_EAX) < (unsigned __int8)(v35 + 11);
      BYTE1(_EAX) -= v51;
      v54 = v35 + _ECX;
      v52 = _EDI < v54;
      v53 = _EDI - v54;
      v89 = _EDX - (v52 + v53);
      LOBYTE(v89) = BYTE1(_EAX) & v89;
      BYTE1(v89) = (BYTE1(v89) << _ECX) + 64;
      BYTE1(_EAX) &= 0x62u;
      LOBYTE(v89) = v89 | 0x89;
      LOBYTE(_EAX) = v89;
      v90 = v89 - 1;
      LOBYTE(_ECX) = _ECX + 15;
      __asm { rcr     ecx, cl }
      v35 = __CFSHL__(_EAX, _ECX);
      LOBYTE(_EAX) = (_BYTE)_EAX << _ECX;
      v92 = (_BYTE)_EAX == 0;
      v93 = v35 || (_BYTE)_EAX == 0;
      __asm { rcl     eax, cl }
      HIWORD(_EAX) = HIWORD(_ESI);
      if ( v93 || !v93 )
      {
        v29 = v90 - _ESI;
        LOBYTE(_ECX) = (char)_ECX >> _ECX;
        v30 = __OFADD__(_ECX < v43, v29);
        v31 = (_ECX < v43) + v29;
        v30 |= __OFADD__(_ESI, v31);
        v31 += _ESI;
        if ( !((v31 < 0) ^ v30 | (v31 == 0)) && (v31 < 0) ^ v30 | (v31 == 0) )
        {
          __asm { outsb }
          JUMPOUT(0x40C1D0);
        }
        JUMPOUT(0x40C7AD);
      }
      v95 = v43;
      _EBX = _ECX;
      v94 = v95;
      while ( !v92 )
        ;
      __asm { into }
      LOBYTE(v94) = BYTE1(v90) & v94;
      LOBYTE(_EAX) = -60;
      _ECX = v53 ^ v94;
      LOBYTE(_ECX) = BYTE1(v90) & _ECX;
      LOBYTE(v90) = v90 - BYTE1(_ESI);
      v96 = v90 >> _ECX;
      BYTE1(_EAX) = __ROR1__(BYTE1(_ESI), _ECX);
      _EDI = _ECX + __CFSHR__(BYTE1(_ESI), _ECX) + v53;
      LOBYTE(v96) = BYTE1(_ECX) & v96;
      _EDX = _EDI & v96;
      if ( __SETP__(_EDX, 0) || !__SETP__(_EDX, 0) )
      {
        v24 = 0xC4u >> _ECX;
        BYTE1(_EDX) &= _EDX;
        v25 = _EDX + _EBX;
        BYTE1(_ECX) &= v25;
        v26 = __CFADD__(_ECX, v25);
        v27 = _ECX + v25;
        __asm { rcl     edi, cl }
        if ( !__SETP__(v27, 0) && __SETP__(v27, 0) )
        {
          if ( v26 || v27 == 0 )
            JUMPOUT(0x40C116);
          JUMPOUT(0x40C0B3);
        }
        _CX = _ECX + 1;
        HIBYTE(_CX) = ((unsigned __int8)(v27 - (v26 + 29)) < (unsigned __int8)(((unsigned __int8)v27 < (unsigned __int8)(v26 + 29))
                                                                             + v24))
                    + HIBYTE(_CX)
                    - 74;
        __asm { rcl     ch, cl }
        JUMPOUT(0x40C135);
      }
      __asm { insd }
      ++a5;
    }
    __asm { rcl     bh, cl }
  }
}
// 40C55E: positive sp value 8 has been found
// 40C026: control flows out of bounds to 40C027
// 40C114: control flows out of bounds to 40C116
// 40C139: inconsistent fpu stack
// 40C1CF: control flows out of bounds to 40C1D0
// 40C3F4: control flows out of bounds to 40C3F5
// 40C46E: control flows out of bounds to 40C474
// 40C498: control flows out of bounds to 40C49A
// 40C516: control flows out of bounds to 40C51B
// 40C585: control flows out of bounds to 40C587
// 40C88C: control flows out of bounds to 40C88D
// 40C41C: control flows out of bounds to 40C41D
// 40C8DF: control flows out of bounds to 40C8E4
// 40BEFB: control flows out of bounds to 40C561
// 40C184: control flows out of bounds to 40C5B8
// 40C269: control flows out of bounds to 40C51A
// 40C5C7: control flows out of bounds to E2DBD21B
// 40C707: control flows out of bounds to 40BFD8
// 40BFC5: control flows out of bounds to 40C09B
// 40C10A: control flows out of bounds to 40C0B3
// 40C288: control flows out of bounds to 40C042
// 40C28E: control flows out of bounds to 40C296
// 40C3F2: control flows out of bounds to 40C415
// 40C464: control flows out of bounds to 40C135
// 40C4F0: control flows out of bounds to 40C4AB
// 40C54C: control flows out of bounds to 40C7AD
// 40C8DF: bad sp value at call
// 40C0C0: conditional instruction was optimized away because edx.4!=0
// 40C412: conditional instruction was optimized away because esi.4!=0
// 40C46E: conditional instruction was optimized away because ecx.4>=0
// 40C50E: conditional instruction was optimized away because edi.4>=0
// 40C886: conditional instruction was optimized away because esi.4>=0
// 40C4DF: variable 'v68' is possibly undefined

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
