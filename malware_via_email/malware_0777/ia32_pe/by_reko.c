// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: void fn13101000(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C, Stack ptr32 dwArg10, Stack Eq_6 dwArg14, Stack ptr32 dwArg18)
void fn13101000(LPVOID dwArg04, LPVOID dwArg08, word32 dwArg0C, ptr32 dwArg10, LPVOID dwArg14, ptr32 dwArg18)
{
	*dwArg10 = dwArg0C;
	word16 wLoc0C_21 = (word16) (uint32) ((uint64) (uint32) dwArg14 % 0x05);
	byte * dwArg04_26 = dwArg04 + dwArg14;
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg08 = (byte) ((int32) *dwArg04_26 ^ (word32) (&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&(dwArg18)[(int32) wLoc0C_21].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000)[0x00]);
		word16 cx_66 = wLoc0C_21 + 0x01;
		wLoc0C_21 = cx_66;
		if ((int32) cx_66 == 0x05)
			wLoc0C_21 = 0x00;
		dwArg08 = dwArg08 + 0x01;
		dwArg04_26 = dwArg04_26 + 0x01;
	}
	return;
}

// 131010A0: Register Eq_54 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	if (SafeArrayUnaccessData(null) == 0x80070057)
	{
		word32 ecx_134 = globals->dw13102000;
		fn13101000(fp - 0x28, fp - 0x28, 0x04, fp - 0x10, null, fp - 0x0234);
		word32 ecx_154 = globals->dw13102004;
		fn13101000(fp - 0x025C, fp - 600, 0x04, fp - 0x10, (void *) 0x04, fp - 0x0234);
		ui32 ecx_176 = globals->dw13102008;
		fn13101000(fp - 0x1C, fp - 0x14, 0x04, fp - 0x10, (void *) 0x08, fp - 0x0234);
		Eq_109 eax_202 = GetModuleHandleA(null);
		word32 eax_210 = globals->dw1310200C;
		fn13101000(fp - 0x28, fp - 0x1C, 0x04, fp - 0x10, (void *) 0x0C, fp - 0x0234);
		Eq_6 dwLoc0248_243 = globals->t13102010;
		fn13101000(fp - 600, fp - 0x0248, 0x04, fp - 0x10, (void *) 0x10, fp - 0x0234);
		Eq_6 ecx_271 = ecx_176 * 0x08 + 0x0C;
		Eq_6 dwLoc0250_266 = (void *) 0x14;
		word32 * dwLoc24_269 = &globals->dw13102014;
		Eq_3 eax_284 = VirtualAlloc(null, (char *) ecx_271 + ecx_154 + ecx_134, 0x3000, 0x40);
		word32 dwLoc0C_290 = eax_210 + eax_202 + ecx_271;
		Eq_6 dwLoc0264_294 = ecx_271;
		ui32 dwLoc08_295 = 0x00;
		Eq_173 dwLoc18_296 = null;
		while (0x01 != 0x00)
		{
			if (dwLoc0264_294 == dwLoc0248_243)
			{
				ui32 edx_423 = dwLoc08_295 + 0x01;
				dwLoc08_295 = edx_423;
				if (edx_423 == ecx_176)
					break;
				word32 edx_429 = *dwLoc24_269;
				fn13101000(fp - 0x1C - dwLoc0250_266, fp - 0x1C, 0x04, fp - 0x10, dwLoc0250_266, fp - 0x0234);
				LPVOID * ecx_458 = dwLoc24_269 + 0x01;
				Eq_6 eax_455 = (char *) dwLoc0250_266 + 0x04;
				dwLoc0248_243 = (Eq_6) *ecx_458;
				fn13101000(fp - 0x0248 - eax_455, fp - 0x0248, 0x04, fp - 0x10, eax_455, fp - 0x0234);
				dwLoc0250_266 = (Eq_6) ((char *) eax_455 + 0x04);
				dwLoc24_269 = (word32 *) ((char *) ecx_458 + 0x04);
				dwLoc0264_294 = null;
				dwLoc0C_290 = (byte *) (eax_202 + edx_429 / 0x04);
			}
			Mem408[eax_284 + dwLoc18_296:byte] = Mem0[dwLoc0C_290 + 0x00:byte];
			dwLoc0C_290 = dwLoc0C_290 + 0x01;
			dwLoc18_296 = dwLoc18_296 + 0x01;
			dwLoc0264_294 = (Eq_6) ((char *) dwLoc0264_294 + 0x01);
		}
		fn13101000(eax_284 - ecx_271, eax_284, ecx_154, fp - 0x0238, ecx_271, fp - 0x0234);
		word32 esp_368;
		word32 ebp_369;
		byte SCZO_370;
		word32 eax_371;
		word32 ecx_372;
		byte SZO_373;
		byte C_374;
		word32 ebx_375;
		word32 esi_376;
		byte Z_377;
		word32 edx_378;
		byte dl_379;
		(eax_284 + 0x0F50)();
		return 0x00;
	}
	else
	{
		word32 esp_111;
		word32 ebp_112;
		byte SCZO_113;
		Eq_54 eax_114;
		word32 ecx_115;
		byte SZO_116;
		byte C_117;
		word32 ebx_118;
		word32 esi_119;
		byte Z_120;
		word32 edx_121;
		byte dl_122;
		((<anonymous> **) 0x28)();
		return eax_114;
	}
}

