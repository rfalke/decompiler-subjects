// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40602C = 24744; // 0040602C
word32 g_dw406030 = 0x60B8; // 00406030
word32 g_dw406034 = 0x60CC; // 00406034
word32 g_dw406038 = 0x60DC; // 00406038
word32 g_dw40603C = 24824; // 0040603C
word32 g_dw406040 = 0x6110; // 00406040
word32 g_dw406044 = 24868; // 00406044
word32 g_dw406048 = 24888; // 00406048
word32 g_dw40604C = 0x614C; // 0040604C
word32 g_dw406050 = 24924; // 00406050
word32 g_dw406054 = 24944; // 00406054
word32 g_dw406058 = 24964; // 00406058
word32 g_dw40605C = 24988; // 0040605C
word32 g_dw406060 = 25000; // 00406060
<anonymous> * __imp__CloseHandle = &g_t60A8; // 0040606C
<anonymous> * __imp__CreateProcessA = &g_t60B8; // 00406070
<anonymous> * __imp__ExitProcess = &g_t60CC; // 00406074
<anonymous> * __imp__GetEnvironmentVariableA = &g_t60DC; // 00406078
<anonymous> * __imp__GetModuleFileNameA = &g_t60F8; // 0040607C
<anonymous> * __imp__GetShortPathNameA = &g_t6110; // 00406080
<anonymous> * __imp__GetThreadContext = &g_t6124; // 00406084
<anonymous> * __imp__ReadProcessMemory = &g_t6138; // 00406088
<anonymous> * __imp__ResumeThread = &g_t614C; // 0040608C
<anonymous> * __imp__SetThreadContext = &g_t615C; // 00406090
<anonymous> * __imp__VirtualAllocEx = &g_t6170; // 00406094
<anonymous> * __imp__WriteProcessMemory = &g_t6184; // 00406098
<anonymous> * __imp__lstrcatA = &g_t619C; // 0040609C
<anonymous> * __imp__lstrcpyA = &g_t61A8; // 004060A0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	int32 ebx_16_16_cl_bl;
	ptr32 fp;
	byte * esi;
	byte * edi;
	ptr32 ebp_18 = fn00401078(fp - 4);
	fn0040112B(ebx_16_16_cl_bl, esi, edi);
	fn00401078(ebp_18);
	return 0x00;
}

// 00401078: Register ptr32 fn00401078(Register ptr32 ebp)
// Called from:
//      Win32CrtStartup
ptr32 fn00401078(ptr32 ebp)
{
	Eq_23 tLoc04;
	tLoc04.ptr0000 = ebp;
	return fn00401085(&tLoc04);
}

// 00401085: Register (ptr32 Eq_30) fn00401085(Register (ptr32 Eq_30) ebp)
// Called from:
//      fn00401078
//      fn00401121
struct Eq_30 * fn00401085(struct Eq_30 * ebp)
{
	word32 * eax;
	if (ebp->ptrFFFFFFFC >= ebp->ptr000C)
		return ebp->ptr0000;
	if (ebp->ptrFFFFFFFC > (byte (*)[]) 0x01)
		Mem27[Mem0[ebp + 8:word32] + Mem0[ebp + -4:word32]:byte] = Mem0[Mem0[ebp + -4:word32] + Mem0[ebp + 8:word32]:byte] ^ 0x1E;
	if (ebp->ptrFFFFFFFC > (byte (*)[]) 0x02 && (ebp->ptrFFFFFFFC - 0x02 & 0x01) == 0x00)
		Mem50[Mem29[ebp + 8:word32] + Mem29[ebp + -4:word32]:byte] = Mem29[Mem29[ebp + -4:word32] + Mem29[ebp + 8:word32]:byte] + 0x7F;
	if (ebp->ptrFFFFFFFC > (byte (*)[]) 0x02)
	{
		byte (* edx_55)[] = ebp->ptrFFFFFFFC;
		if ((int32) (SEQ(edx_55 - 0x02 >> 0x1F, edx_55 - 0x02) % 0x03) == 0x00)
			Mem78[Mem52[ebp + 8:word32] + Mem52[ebp + -4:word32]:byte] = Mem52[Mem52[ebp + -4:word32] + Mem52[ebp + 8:word32]:byte] - 0xCC;
	}
	Mem91[Mem80[ebp + 8:word32] + Mem80[ebp + -4:word32]:byte] = Mem80[Mem80[ebp + -4:word32] + Mem80[ebp + 8:word32]:byte] - Mem80[ebp + 0x04:byte];
	fn00401121(eax);
	return ebp;
}

// 00401121: void fn00401121(Register (ptr32 word32) eax)
// Called from:
//      fn00401085
//      fn0040112B
void fn00401121(word32 * eax)
{
	struct Eq_30 * ebp;
	++*eax;
	fn00401085(ebp);
}

// 0040112B: void fn0040112B(Sequence int32 ebx_16_16_cl_bl, Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      Win32CrtStartup
void fn0040112B(int32 ebx_16_16_cl_bl, byte * esi, byte * edi)
{
	word32 * eax_12 = fn1993_476F();
	byte al_40 = (byte) eax_12;
	if (ebx_16_16_cl_bl <= 0x01)
		fn00401121(eax_12);
	else
	{
		*esi = al_40;
		*edi = *esi;
	}
}

