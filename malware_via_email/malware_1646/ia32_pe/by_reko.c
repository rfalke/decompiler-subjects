// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t12784; // 00412000
<anonymous> * __imp__GetProcAddress = &g_t12796; // 00412004
<anonymous> * __imp__HeapDestroy = &g_t127A8; // 00412008
<anonymous> * __imp__ReadFile = &g_t127B6; // 0041200C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t127C2; // 00412010
<anonymous> * __imp__ReadFile = &g_t127DC; // 00412014
<anonymous> * __imp__GetCurrentProcessId = &g_t127E8; // 00412018
<anonymous> * __imp__CreateFileW = &g_t127FE; // 0041201C
<anonymous> * __imp__LoadLibraryW = &g_t1280C; // 00412020
<anonymous> * __imp__DeleteCriticalSection = &g_t1281C; // 00412024
<anonymous> * __imp__VirtualProtect = &g_t12834; // 00412028
<anonymous> * __imp__HeapFree = &g_t12846; // 0041202C
<anonymous> * __imp__GetCurrentThreadId = &g_t12852; // 00412030
<anonymous> * __imp__TerminateProcess = &g_t12868; // 00412034
<anonymous> * __imp__lstrcmpiW = &g_t1287C; // 00412038
<anonymous> * __imp__HeapReAlloc = &g_t12888; // 0041203C
<anonymous> * __imp__lstrcpyW = &g_t12896; // 00412040
<anonymous> * __imp__VirtualProtect = &g_t128A2; // 00412044
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t128B4; // 00412048
<anonymous> * __imp__GetStartupInfoW = &g_t128CE; // 0041204C
<anonymous> * __imp__GetACP = &g_t128E0; // 00412050
<anonymous> * __imp__LocalAlloc = &g_t128EA; // 00412054
<anonymous> * __imp__TerminateProcess = &g_t128F8; // 00412058
<anonymous> * __imp__ReadFile = &g_t1290C; // 0041205C
<anonymous> * __imp__VirtualProtect = &g_t12918; // 00412060
<anonymous> * __imp__CreateThread = &g_t1292A; // 00412064
<anonymous> * __imp__LoadLibraryA = &g_t1293A; // 00412068
<anonymous> * __imp__GetStartupInfoW = &g_t1294A; // 0041206C
<anonymous> * __imp__GetCurrentProcessId = &g_t1295C; // 00412070
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12972; // 00412074
<anonymous> * __imp__TerminateProcess = &g_t1298C; // 00412078
<anonymous> * __imp__VirtualFree = &g_t129A0; // 0041207C
<anonymous> * __imp__GetStartupInfoA = &g_t129AE; // 00412080
<anonymous> * __imp__LoadLibraryW = &g_t129C0; // 00412084
<anonymous> * __imp__lstrcpyW = &g_t129D0; // 00412088
<anonymous> * __imp__InterlockedDecrement = &g_t129DC; // 0041208C
<anonymous> * __imp__SetLastError = &g_t129F4; // 00412090
<anonymous> * __imp__ExitProcess = &g_t12A04; // 00412094
<anonymous> * __imp__GetStartupInfoW = &g_t12A12; // 00412098
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12A24; // 0041209C
<anonymous> * __imp__lstrcmpiW = &g_t12A3E; // 004120A0
<anonymous> * __imp__GetStartupInfoA = &g_t12A4A; // 004120A4
<anonymous> * __imp__GetStartupInfoA = &g_t12A5C; // 004120A8
<anonymous> * __imp__ExitProcess = &g_t12A6E; // 004120AC
<anonymous> * __imp__GetVersionExA = &g_t12A7C; // 004120B0
<anonymous> * __imp__GetStartupInfoW = &g_t12A8C; // 004120B4
<anonymous> * __imp__QueryPerformanceCounter = &g_t12A9E; // 004120B8
<anonymous> * __imp__GetCommandLineA = &g_t12AB8; // 004120BC
<anonymous> * __imp__SetEvent = &g_t12ACA; // 004120C0
<anonymous> * __imp__SetEvent = &g_t12AD6; // 004120C4
<anonymous> * __imp__LoadLibraryW = &g_t12AE2; // 004120C8
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t12AF2; // 004120CC
<anonymous> * __imp__GetTickCount = &g_t12B10; // 004120D0
<anonymous> * __imp__GetStartupInfoW = &g_t12B20; // 004120D4
<anonymous> * __imp__ExitProcess = &g_t12B32; // 004120D8
<anonymous> * __imp__WriteFile = &g_t12B40; // 004120DC
<anonymous> * __imp__CloseHandle = &g_t12B4C; // 004120E0
<anonymous> * __imp__LoadLibraryW = &g_t12B5A; // 004120E4
<anonymous> * __imp__GetLastError = &g_t12B6A; // 004120E8
<anonymous> * __imp__GetModuleHandleA = &g_t12B7A; // 004120EC
<anonymous> * __imp__GetLastError = &g_t12B8E; // 004120F0
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12B9E; // 004120F4
<anonymous> * __imp__LocalAlloc = &g_t12BB8; // 004120F8
<anonymous> * __imp__SetLastError = &g_t12BC6; // 004120FC
<anonymous> * __imp__GetProcessHeap = &g_t12BD6; // 00412100
<anonymous> * __imp__GetCommandLineW = &g_t12BE8; // 00412104
<anonymous> * __imp__SetFilePointer = &g_t12BFA; // 00412108
<anonymous> * __imp__GetProcAddress = &g_t12C0C; // 0041210C
<anonymous> * __imp__MultiByteToWideChar = &g_t12C1E; // 00412110
<anonymous> * __imp__DeleteCriticalSection = &g_t12C34; // 00412114
<anonymous> * __imp__EnterCriticalSection = &g_t12C4C; // 00412118
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12C64; // 0041211C
<anonymous> * __imp__lstrcpyW = &g_t12C7E; // 00412120
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12C8A; // 00412124
<anonymous> * __imp__FreeLibrary = &g_t12CA4; // 00412128
<anonymous> * __imp__GetProcAddress = &g_t12CB2; // 0041212C
<anonymous> * __imp__WaitForSingleObject = &g_t12CC4; // 00412130
<anonymous> * __imp__OpenInputDesktop = &g_t12CE8; // 00412138
<anonymous> * __imp__DefWindowProcW = &g_t12CFC; // 0041213C
<anonymous> * __imp__SetCapture = &g_t12D0E; // 00412140
<anonymous> * __imp__SetScrollInfo = &g_t12D1C; // 00412144
<anonymous> * __imp__PeekMessageW = &g_t12D2C; // 00412148
<anonymous> * __imp__SetProcessWindowStation = &g_t12D3C; // 0041214C
<anonymous> * __imp__GetDlgCtrlID = &g_t12D56; // 00412150
<anonymous> * __imp__LoadStringW = &g_t12D66; // 00412154
<anonymous> * __imp__RegisterClassExW = &g_t12D74; // 00412158
<anonymous> * __imp__DrawTextW = &g_t12D88; // 0041215C
<anonymous> * __imp__IsDlgButtonChecked = &g_t12D94; // 00412160
<anonymous> * __imp__AppendMenuW = &g_t12DAA; // 00412164
<anonymous> * __imp__GetKeyState = &g_t12DB8; // 00412168
<anonymous> * __imp__OpenInputDesktop = &g_t12DC6; // 0041216C
<anonymous> * __imp__DestroyMenu = &g_t12DDA; // 00412170
<anonymous> * __imp__ReleaseDC = &g_t12DE8; // 00412174
<anonymous> * __imp__SetWindowTextA = &g_t12DF4; // 00412178
<anonymous> * __imp__MessageBeep = &g_t12E06; // 0041217C
<anonymous> * __imp__MessageBoxW = &g_t12E14; // 00412180
<anonymous> * __imp__SetForegroundWindow = &g_t12E22; // 00412184
<anonymous> * __imp__SetFocus = &g_t12E38; // 00412188
<anonymous> * __imp__IsWindow = &g_t12E44; // 0041218C
<anonymous> * __imp__GetProcessWindowStation = &g_t12E50; // 00412190
<anonymous> * __imp__SetCapture = &g_t12E6A; // 00412194
<anonymous> * __imp__SendMessageA = &g_t12E78; // 00412198
<anonymous> * __imp__InflateRect = &g_t12E88; // 0041219C
<anonymous> * __imp__BeginPaint = &g_t12E96; // 004121A0
<anonymous> * __imp__IntersectRect = &g_t12EA4; // 004121A4
<anonymous> * __imp__EnableWindow = &g_t12EB4; // 004121A8
<anonymous> * __imp__MessageBeep = &g_t12EC4; // 004121AC
<anonymous> * __imp__RegisterClassW = &g_t12ED2; // 004121B0
<anonymous> * __imp__CloseDesktop = &g_t12EE4; // 004121B4
<anonymous> * __imp__ShowCursor = &g_t12EF4; // 004121B8
<anonymous> * __imp__ShowWindow = &g_t12F02; // 004121BC
<anonymous> * __imp__SetForegroundWindow = &g_t12F10; // 004121C0
<anonymous> * __imp__FindWindowW = &g_t12F26; // 004121C4
<anonymous> * __imp__SetWindowLongA = &g_t12F34; // 004121C8
<anonymous> * __imp__SetForegroundWindow = &g_t12F46; // 004121CC
<anonymous> * __imp__SetProcessWindowStation = &g_t12F5C; // 004121D0
<anonymous> * __imp__GetDlgItem = &g_t12F76; // 004121D4
<anonymous> * __imp__GetWindowThreadProcessId = &g_t12F84; // 004121D8
<anonymous> * __imp__LoadStringW = &g_t12FA0; // 004121DC
<anonymous> * __imp__IsDialogMessageW = &g_t12FAE; // 004121E0
<anonymous> * __imp__GetFocus = &g_t12FC2; // 004121E4
<anonymous> * __imp__DialogBoxParamW = &g_t12FCE; // 004121E8
<anonymous> * __imp__LoadMenuW = &g_t12FE0; // 004121EC
<anonymous> * __imp__GetWindowRect = &g_t12FEC; // 004121F0
<anonymous> * __imp__SetThreadDesktop = &g_t12FFC; // 004121F4
<anonymous> * __imp__SendDlgItemMessageW = &g_t13010; // 004121F8
<anonymous> * __imp__KillTimer = &g_t13026; // 004121FC
<anonymous> * __imp__SetWindowLongW = &g_t13032; // 00412200
<anonymous> * __imp__PostQuitMessage = &g_t13044; // 00412204
<anonymous> * __imp__CopyRect = &g_t13056; // 00412208
<anonymous> * __imp__PtInRect = &g_t13062; // 0041220C
<anonymous> * __imp__GetAsyncKeyState = &g_t1306E; // 00412210
<anonymous> * __imp__OpenClipboard = &g_t13082; // 00412214
<anonymous> * __imp__DrawTextW = &g_t13092; // 00412218
<anonymous> * __imp__ExitWindowsEx = &g_t1309E; // 0041221C
<anonymous> * __imp__GetMessageW = &g_t130AE; // 00412220
<anonymous> * __imp__GetSubMenu = &g_t130BC; // 00412224
<anonymous> * __imp__UnregisterClassW = &g_t130CA; // 00412228
<anonymous> * __imp__OpenWindowStationW = &g_t130DE; // 0041222C
<anonymous> * __imp__LoadCursorA = &g_t130F4; // 00412230
<anonymous> * __imp__IsZoomed = &g_t13102; // 00412234
<anonymous> * __imp__CloseClipboard = &g_t1310E; // 00412238
<anonymous> * __imp__LoadIconW = &g_t13120; // 0041223C
<anonymous> * __imp__CheckMenuItem = &g_t1312C; // 00412240
<anonymous> * __imp__MapWindowPoints = &g_t1313C; // 00412244
<anonymous> * __imp__GetDlgItemTextW = &g_t1314E; // 00412248
<anonymous> * __imp__EndPaint = &g_t13160; // 0041224C
<anonymous> * __imp__EqualRect = &g_t1316C; // 00412250
<anonymous> * __imp__RestoreDC = &g_t13184; // 00412258
<anonymous> * __imp__CreatePatternBrush = &g_t13190; // 0041225C
<anonymous> * __imp__SelectObject = &g_t131A6; // 00412260
<anonymous> * __imp__SelectPalette = &g_t131B6; // 00412264
<anonymous> * __imp__DeleteObject = &g_t131C6; // 00412268
<anonymous> * __imp__TextOutW = &g_t131D6; // 0041226C
<anonymous> * __imp__SetTextColor = &g_t131E2; // 00412270
<anonymous> * __imp__TextOutW = &g_t131F2; // 00412274
<anonymous> * __imp__GetTextExtentPointW = &g_t131FE; // 00412278
<anonymous> * __imp__GetObjectW = &g_t13214; // 0041227C
<anonymous> * __imp__LineTo = &g_t13222; // 00412280
<anonymous> * __imp__SetBkColor = &g_t1322C; // 00412284
<anonymous> * __imp__RestoreDC = &g_t1323A; // 00412288
<anonymous> * __imp__MoveToEx = &g_t13246; // 0041228C
<anonymous> * __imp__RealizePalette = &g_t13252; // 00412290
<anonymous> * __imp__DeleteDC = &g_t13264; // 00412294
<anonymous> * __imp__TextOutW = &g_t13270; // 00412298
<anonymous> * __imp__CreateSolidBrush = &g_t1327C; // 0041229C
<anonymous> * __imp__TranslateCharsetInfo = &g_t13290; // 004122A0
<anonymous> * __imp__DeleteObject = &g_t132A8; // 004122A4
<anonymous> * __imp__RestoreDC = &g_t132B8; // 004122A8
<anonymous> * __imp__DeleteDC = &g_t132C4; // 004122AC
<anonymous> * __imp__GetTextExtentPoint32W = &g_t132D0; // 004122B0
<anonymous> * __imp__SelectPalette = &g_t132E8; // 004122B4
<anonymous> * __imp__SelectPalette = &g_t132F8; // 004122B8
<anonymous> * __imp__GetObjectW = &g_t13308; // 004122BC
<anonymous> * __imp__LineTo = &g_t13316; // 004122C0
<anonymous> * __imp__CreateRectRgn = &g_t13320; // 004122C4
<anonymous> * __imp__StretchBlt = &g_t13330; // 004122C8
<anonymous> * __imp__GetTextExtentPointW = &g_t1333E; // 004122CC
<anonymous> * __imp__GetObjectA = &g_t13354; // 004122D0
<anonymous> * __imp__SaveDC = &g_t13362; // 004122D4
<anonymous> * __imp__StretchBlt = &g_t1336C; // 004122D8
<anonymous> * __imp__GetTextExtentPoint32W = &g_t1337A; // 004122DC
<anonymous> * __imp__CreateBitmap = &g_t13392; // 004122E0
<anonymous> * __imp__StretchBlt = &g_t133A2; // 004122E4
<anonymous> * __imp__CreatePatternBrush = &g_t133B0; // 004122E8
<anonymous> * __imp__Rectangle = &g_t133C6; // 004122EC
<anonymous> * __imp__GetTextExtentPoint32W = &g_t133D2; // 004122F0
<anonymous> * __imp__LineTo = &g_t133EA; // 004122F4
<anonymous> * __imp__RestoreDC = &g_t133F4; // 004122F8
<anonymous> * __imp__SelectPalette = &g_t13400; // 004122FC
<anonymous> * __imp__SetStretchBltMode = &g_t13410; // 00412300
<anonymous> * __imp__SelectObject = &g_t13424; // 00412304
<anonymous> * __imp__DeleteDC = &g_t13434; // 00412308
<anonymous> * __imp__GetTextExtentPointW = &g_t13440; // 0041230C
<anonymous> * __imp__GetTextExtentPoint32W = &g_t13456; // 00412310
<anonymous> * __imp__GetTextExtentPoint32W = &g_t1346E; // 00412314
<anonymous> * __imp__SetBkMode = &g_t13486; // 00412318
<anonymous> * __imp__RestoreDC = &g_t13492; // 0041231C
<anonymous> * __imp__GetTextExtentPointW = &g_t1349E; // 00412320
<anonymous> * __imp__GetObjectA = &g_t134B4; // 00412324
<anonymous> * __imp__RealizePalette = &g_t134C2; // 00412328
<anonymous> * __imp__SetTextColor = &g_t134D4; // 0041232C
<anonymous> * __imp__DeleteObject = &g_t134E4; // 00412330
<anonymous> * __imp__StretchBlt = &g_t134F4; // 00412334
<anonymous> * __imp__DeleteObject = &g_t13502; // 00412338
<anonymous> * __imp__CreateCompatibleDC = &g_t13512; // 0041233C
<anonymous> * __imp__GetStockObject = &g_t13528; // 00412340
<anonymous> * __imp__CreateCompatibleDC = &g_t1353A; // 00412344
<anonymous> * __imp__CreateFontIndirectW = &g_t13550; // 00412348
<anonymous> * __imp__CreateCompatibleBitmap = &g_t13566; // 0041234C
<anonymous> * __imp__CreateFontIndirectW = &g_t13580; // 00412350
<anonymous> * __imp__SetMapMode = &g_t13596; // 00412354
<anonymous> * __imp__DeleteObject = &g_t135A4; // 00412358
<anonymous> * __imp__DeleteObject = &g_t135B4; // 0041235C
<anonymous> * __imp__SetBkColor = &g_t135C4; // 00412360
<anonymous> * __imp__SetBkMode = &g_t135D2; // 00412364
<anonymous> * __imp__SelectPalette = &g_t135DE; // 00412368
<anonymous> * __imp__MoveToEx = &g_t135EE; // 0041236C
<anonymous> * __imp__SelectObject = &g_t135FA; // 00412370
<anonymous> * __imp__SetTextColor = &g_t1360A; // 00412374
<anonymous> * __imp__GetTextMetricsW = &g_t1361A; // 00412378
<anonymous> * __imp__CreatePatternBrush = &g_t1362C; // 0041237C
<anonymous> * __imp__StretchBlt = &g_t13642; // 00412380
<anonymous> * __imp__SetWindowExtEx = &g_t13650; // 00412384
<anonymous> * __imp__GetTextExtentPoint32W = &g_t13662; // 00412388
<anonymous> * __imp__GetTextExtentPoint32W = &g_t1367A; // 0041238C
<anonymous> * __imp__DeleteDC = &g_t13692; // 00412390
word32 g_dw4123EC = 75652; // 004123EC
word32 g_dw4123F0 = 75670; // 004123F0
word32 g_dw4123F4 = 75688; // 004123F4
word32 g_dw4123F8 = 75702; // 004123F8
word32 g_dw4123FC = 0x000127C2; // 004123FC
word32 g_dw412400 = 75740; // 00412400
word32 g_dw412404 = 75752; // 00412404
word32 g_dw412408 = 75774; // 00412408
word32 g_dw41240C = 75788; // 0041240C
word32 g_dw412410 = 0x0001281C; // 00412410
word32 g_dw412414 = 75828; // 00412414
word32 g_dw412418 = 0x00012846; // 00412418
word32 g_dw41241C = 75858; // 0041241C
word32 g_dw412420 = 0x00012868; // 00412420
word32 g_dw412424 = 75900; // 00412424
word32 g_dw412428 = 0x00012888; // 00412428
word32 g_dw41242C = 0x00012896; // 0041242C
word32 g_dw412430 = 0x000128A2; // 00412430
word32 g_dw412434 = 75956; // 00412434
word32 g_dw412438 = 0x000128CE; // 00412438
word32 g_dw41243C = 76000; // 0041243C
word32 g_dw412440 = 76010; // 00412440
word32 g_dw412444 = 0x000128F8; // 00412444
word32 g_dw412448 = 76044; // 00412448
word32 g_dw41244C = 0x00012918; // 0041244C
word32 g_dw412450 = 0x0001292A; // 00412450
word32 g_dw412454 = 76090; // 00412454
word32 g_dw412458 = 76106; // 00412458
word32 g_dw41245C = 0x0001295C; // 0041245C
word32 g_dw412460 = 0x00012972; // 00412460
word32 g_dw412464 = 76172; // 00412464
word32 g_dw412468 = 0x000129A0; // 00412468
word32 g_dw41246C = 76206; // 0041246C
word32 g_dw412470 = 76224; // 00412470
word32 g_dw412474 = 0x000129D0; // 00412474
word32 g_dw412478 = 76252; // 00412478
word32 g_dw41247C = 76276; // 0041247C
word32 g_dw412480 = 76292; // 00412480
word32 g_dw412484 = 0x00012A12; // 00412484
word32 g_dw412488 = 0x00012A24; // 00412488
word32 g_dw41248C = 0x00012A3E; // 0041248C
word32 g_dw412490 = 0x00012A4A; // 00412490
word32 g_dw412494 = 0x00012A5C; // 00412494
word32 g_dw412498 = 0x00012A6E; // 00412498
word32 g_dw41249C = 0x00012A7C; // 0041249C
word32 g_dw4124A0 = 0x00012A8C; // 004124A0
word32 g_dw4124A4 = 76446; // 004124A4
word32 g_dw4124A8 = 76472; // 004124A8
word32 g_dw4124AC = 0x00012ACA; // 004124AC
word32 g_dw4124B0 = 0x00012AD6; // 004124B0
word32 g_dw4124B4 = 0x00012AE2; // 004124B4
word32 g_dw4124B8 = 0x00012AF2; // 004124B8
word32 g_dw4124BC = 0x00012B10; // 004124BC
word32 g_dw4124C0 = 76576; // 004124C0
word32 g_dw4124C4 = 0x00012B32; // 004124C4
word32 g_dw4124C8 = 76608; // 004124C8
word32 g_dw4124CC = 76620; // 004124CC
word32 g_dw4124D0 = 76634; // 004124D0
word32 g_dw4124D4 = 76650; // 004124D4
word32 g_dw4124D8 = 76666; // 004124D8
word32 g_dw4124DC = 76686; // 004124DC
word32 g_dw4124E0 = 76702; // 004124E0
word32 g_dw4124E4 = 0x00012BB8; // 004124E4
word32 g_dw4124E8 = 76742; // 004124E8
word32 g_dw4124EC = 76758; // 004124EC
word32 g_dw4124F0 = 76776; // 004124F0
word32 g_dw4124F4 = 76794; // 004124F4
word32 g_dw4124F8 = 0x00012C0C; // 004124F8
word32 g_dw4124FC = 0x00012C1E; // 004124FC
word32 g_dw412500 = 0x00012C34; // 00412500
word32 g_dw412504 = 76876; // 00412504
word32 g_dw412508 = 76900; // 00412508
word32 g_dw41250C = 76926; // 0041250C
word32 g_dw412510 = 0x00012C8A; // 00412510
word32 g_dw412514 = 76964; // 00412514
word32 g_dw412518 = 0x00012CB2; // 00412518
word32 g_dw41251C = 76996; // 0041251C
word32 g_dw412524 = 77032; // 00412524
word32 g_dw412528 = 0x00012CFC; // 00412528
word32 g_dw41252C = 77070; // 0041252C
word32 g_dw412530 = 0x00012D1C; // 00412530
word32 g_dw412534 = 77100; // 00412534
word32 g_dw412538 = 77116; // 00412538
word32 g_dw41253C = 77142; // 0041253C
word32 g_dw412540 = 0x00012D66; // 00412540
word32 g_dw412544 = 77172; // 00412544
word32 g_dw412548 = 0x00012D88; // 00412548
word32 g_dw41254C = 77204; // 0041254C
word32 g_dw412550 = 77226; // 00412550
word32 g_dw412554 = 77240; // 00412554
word32 g_dw412558 = 77254; // 00412558
word32 g_dw41255C = 77274; // 0041255C
word32 g_dw412560 = 77288; // 00412560
word32 g_dw412564 = 77300; // 00412564
word32 g_dw412568 = 77318; // 00412568
word32 g_dw41256C = 77332; // 0041256C
word32 g_dw412570 = 0x00012E22; // 00412570
word32 g_dw412574 = 77368; // 00412574
word32 g_dw412578 = 0x00012E44; // 00412578
word32 g_dw41257C = 77392; // 0041257C
word32 g_dw412580 = 77418; // 00412580
word32 g_dw412584 = 77432; // 00412584
word32 g_dw412588 = 77448; // 00412588
word32 g_dw41258C = 77462; // 0041258C
word32 g_dw412590 = 77476; // 00412590
word32 g_dw412594 = 77492; // 00412594
word32 g_dw412598 = 77508; // 00412598
word32 g_dw41259C = 77522; // 0041259C
word32 g_dw4125A0 = 0x00012EE4; // 004125A0
word32 g_dw4125A4 = 77556; // 004125A4
word32 g_dw4125A8 = 77570; // 004125A8
word32 g_dw4125AC = 0x00012F10; // 004125AC
word32 g_dw4125B0 = 77606; // 004125B0
word32 g_dw4125B4 = 77620; // 004125B4
word32 g_dw4125B8 = 77638; // 004125B8
word32 g_dw4125BC = 77660; // 004125BC
word32 g_dw4125C0 = 77686; // 004125C0
word32 g_dw4125C4 = 77700; // 004125C4
word32 g_dw4125C8 = 77728; // 004125C8
word32 g_dw4125CC = 77742; // 004125CC
word32 g_dw4125D0 = 77762; // 004125D0
word32 g_dw4125D4 = 77774; // 004125D4
word32 g_dw4125D8 = 77792; // 004125D8
word32 g_dw4125DC = 77804; // 004125DC
word32 g_dw4125E0 = 0x00012FFC; // 004125E0
word32 g_dw4125E4 = 0x00013010; // 004125E4
word32 g_dw4125E8 = 77862; // 004125E8
word32 g_dw4125EC = 77874; // 004125EC
word32 g_dw4125F0 = 0x00013044; // 004125F0
word32 g_dw4125F4 = 77910; // 004125F4
word32 g_dw4125F8 = 77922; // 004125F8
word32 g_dw4125FC = 77934; // 004125FC
word32 g_dw412600 = 77954; // 00412600
word32 g_dw412604 = 77970; // 00412604
word32 g_dw412608 = 77982; // 00412608
word32 g_dw41260C = 77998; // 0041260C
word32 g_dw412610 = 0x000130BC; // 00412610
word32 g_dw412614 = 0x000130CA; // 00412614
word32 g_dw412618 = 0x000130DE; // 00412618
word32 g_dw41261C = 78068; // 0041261C
word32 g_dw412620 = 0x00013102; // 00412620
word32 g_dw412624 = 0x0001310E; // 00412624
word32 g_dw412628 = 0x00013120; // 00412628
word32 g_dw41262C = 0x0001312C; // 0041262C
word32 g_dw412630 = 0x0001313C; // 00412630
word32 g_dw412634 = 0x0001314E; // 00412634
word32 g_dw412638 = 0x00013160; // 00412638
word32 g_dw41263C = 78188; // 0041263C
word32 g_dw412644 = 0x00013184; // 00412644
word32 g_dw412648 = 0x00013190; // 00412648
word32 g_dw41264C = 0x000131A6; // 0041264C
word32 g_dw412650 = 0x000131B6; // 00412650
word32 g_dw412654 = 78278; // 00412654
word32 g_dw412658 = 0x000131D6; // 00412658
word32 g_dw41265C = 0x000131E2; // 0041265C
word32 g_dw412660 = 0x000131F2; // 00412660
word32 g_dw412664 = 0x000131FE; // 00412664
word32 g_dw412668 = 0x00013214; // 00412668
word32 g_dw41266C = 0x00013222; // 0041266C
word32 g_dw412670 = 0x0001322C; // 00412670
word32 g_dw412674 = 0x0001323A; // 00412674
word32 g_dw412678 = 0x00013246; // 00412678
word32 g_dw41267C = 0x00013252; // 0041267C
word32 g_dw412680 = 0x00013264; // 00412680
word32 g_dw412684 = 78448; // 00412684
word32 g_dw412688 = 0x0001327C; // 00412688
word32 g_dw41268C = 78480; // 0041268C
word32 g_dw412690 = 0x000132A8; // 00412690
word32 g_dw412694 = 0x000132B8; // 00412694
word32 g_dw412698 = 0x000132C4; // 00412698
word32 g_dw41269C = 78544; // 0041269C
word32 g_dw4126A0 = 78568; // 004126A0
word32 g_dw4126A4 = 78584; // 004126A4
word32 g_dw4126A8 = 0x00013308; // 004126A8
word32 g_dw4126AC = 0x00013316; // 004126AC
word32 g_dw4126B0 = 0x00013320; // 004126B0
word32 g_dw4126B4 = 0x00013330; // 004126B4
word32 g_dw4126B8 = 0x0001333E; // 004126B8
word32 g_dw4126BC = 78676; // 004126BC
word32 g_dw4126C0 = 0x00013362; // 004126C0
word32 g_dw4126C4 = 78700; // 004126C4
word32 g_dw4126C8 = 0x0001337A; // 004126C8
word32 g_dw4126CC = 78738; // 004126CC
word32 g_dw4126D0 = 0x000133A2; // 004126D0
word32 g_dw4126D4 = 78768; // 004126D4
word32 g_dw4126D8 = 0x000133C6; // 004126D8
word32 g_dw4126DC = 0x000133D2; // 004126DC
word32 g_dw4126E0 = 0x000133EA; // 004126E0
word32 g_dw4126E4 = 0x000133F4; // 004126E4
word32 g_dw4126E8 = 78848; // 004126E8
word32 g_dw4126EC = 0x00013410; // 004126EC
word32 g_dw4126F0 = 78884; // 004126F0
word32 g_dw4126F4 = 0x00013434; // 004126F4
word32 g_dw4126F8 = 0x00013440; // 004126F8
word32 g_dw4126FC = 0x00013456; // 004126FC
word32 g_dw412700 = 78958; // 00412700
word32 g_dw412704 = 78982; // 00412704
word32 g_dw412708 = 78994; // 00412708
word32 g_dw41270C = 79006; // 0041270C
word32 g_dw412710 = 0x000134B4; // 00412710
word32 g_dw412714 = 0x000134C2; // 00412714
word32 g_dw412718 = 0x000134D4; // 00412718
word32 g_dw41271C = 0x000134E4; // 0041271C
word32 g_dw412720 = 0x000134F4; // 00412720
word32 g_dw412724 = 0x00013502; // 00412724
word32 g_dw412728 = 0x00013512; // 00412728
word32 g_dw41272C = 79144; // 0041272C
word32 g_dw412730 = 0x0001353A; // 00412730
word32 g_dw412734 = 0x00013550; // 00412734
word32 g_dw412738 = 0x00013566; // 00412738
word32 g_dw41273C = 79232; // 0041273C
word32 g_dw412740 = 0x00013596; // 00412740
word32 g_dw412744 = 0x000135A4; // 00412744
word32 g_dw412748 = 0x000135B4; // 00412748
word32 g_dw41274C = 79300; // 0041274C
word32 g_dw412750 = 0x000135D2; // 00412750
word32 g_dw412754 = 0x000135DE; // 00412754
word32 g_dw412758 = 0x000135EE; // 00412758
word32 g_dw41275C = 0x000135FA; // 0041275C
word32 g_dw412760 = 79370; // 00412760
word32 g_dw412764 = 0x0001361A; // 00412764
word32 g_dw412768 = 79404; // 00412768
word32 g_dw41276C = 0x00013642; // 0041276C
word32 g_dw412770 = 79440; // 00412770
word32 g_dw412774 = 0x00013662; // 00412774
word32 g_dw412778 = 0x0001367A; // 00412778
word32 g_dw41277C = 0x00013692; // 0041277C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010C1: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	word32 ebx;
	ui32 edi;
	struct Eq_6 * edx;
	struct Eq_7 * eax;
	ui32 ecx;
	ui32 edi_15 = edi | edx | eax;
	ui32 ecx_19 = ecx | edi_15;
	ui32 ebx_17 = ebx - edx;
	uint32 edi_21 = edi_15 + ecx_19;
	uint32 edi_24 = edi_21 - ebx_17 - (word32) (edi_21 < 0x00);
	ui32 ebx_27 = ebx_17 - edx - (word32) (edi_24 < 0x00);
	struct Eq_30 * ebp_117 = fp - 4;
	struct Eq_7 * esi_20 = eax;
	uint32 edi_29 = (edi_24 | eax) + ebx_27;
	struct Eq_37 * ebx_227 = ebx_27 | edx;
	if (ebx_227 == (struct Eq_37 *) 0x4B256A52)
		ebx_227->t0000.u1 += ecx_19;
	struct Eq_41 * ecx_33 = ecx_19 & eax;
l00401159:
	uint32 edi_47 = ebx_227 + edi_29 | eax;
	struct Eq_68 * esi_307 = esi_20 - ecx_33 - edi_47;
	up32 ecx_52 = 0x00 - edi_47 - (word32) (esi_307 < null);
	struct Eq_37 * ecx_320 = ecx_52 - edx - (word32) (edi_47 - eax < (word32) (ecx_52 < 0x00));
l004013BE:
	uint64 eax_ecx_753;
	uint32 edi_247;
	struct Eq_37 * edx_195;
	uint32 esi_241;
	Eq_2 eax_445;
	struct Eq_37 * edi_224;
	ui32 eax_501;
	struct Eq_57 * eax_261;
	struct Eq_37 * ecx_226;
	struct Eq_37 * eax_335;
	struct Eq_60 * eax_178;
	struct Eq_7 * edi_231;
	struct Eq_37 * ecx_204;
	int32 ecx_67 = (ecx_320 | ebx_227) - edx;
	ui32 esi_69 = eax + (esi_307 & ebx_227);
	Eq_2 edx_73 = edx - ebx_227 + ecx_67;
	word32 eax_74 = eax + (ebx_227 + ecx_67);
	if (ecx_67 == 1934484699)
	{
		edx_195 = edx_73 & eax_74;
		struct Eq_37 * edi_243 = edx - ecx_67;
		esi_241 = esi_69 - edx_73;
		ecx_226 = edx_195;
		byte cl_460 = (byte) edx_195;
		word24 ecx_24_8_462 = SLICE(edx_195, word24, 8);
		byte al_562 = (byte) edi_243;
		ui24 eax_24_8_570 = SLICE(edi_243, word24, 8);
		ebx_227 = edi_243;
		edi_247 = edi_243 & edx_195;
		if (edi_243 == (struct Eq_37 *) 3479034700)
		{
			eax_ecx_753 = SEQ(eax_24_8_570, al_562 + Mem238[(edx_195 + 0x23028080) + edi_243:byte], edx_195);
			goto l00401404;
		}
		struct Eq_108 * eax_253 = esi_241 & edi_243;
		edx_195 = eax_253 + (edx_195 - edi_243) / 0x23C22303 - edi_243;
		edi_224 = edx_195 + edi_247;
		esi_20 = esi_241 + eax_253 + edx_195;
		if (edx_195 == (struct Eq_37 *) 688994099)
		{
			eax_253->b0000 |= 0x11;
			int32 ecx_463 = SEQ(ecx_24_8_462, cl_460 + eax_253->b23C22302);
			edx_195 += ecx_463;
			ecx_320 = edi_243 + ecx_463;
			esi_20 = (esi_20 | edi_224) & edi_224;
			goto l0040134E;
		}
		eax_261 = eax_253 + edi_224;
	}
	else
	{
		ui32 esi_78 = esi_69 & edx;
		ui32 ecx_81 = ecx_67 & esi_78 | edx_73;
		ui32 ecx_84 = ecx_81 & esi_78;
		uint32 ebx_105;
		ui32 edi_165 = ecx_84;
		uint32 eax_88 = edx - ecx_81 - ecx_84;
		Eq_2 eax_125 = edx_73;
		uint32 edx_100 = edx_73 - ecx_84 - (word32) (eax_88 < 0x00);
		for (ebx_105 = 876390702; ebx_105 != 2757679732; ebx_105 += 1045232538)
		{
			uint32 esi_101 = edx_756;
			ui32 edx_104 = edx_756 | ecx_84 | edx_756;
			edx_100 = edx_104 - edx_756;
			edx_756 = edx_100;
		}
		__fclex();
		__wait();
		uint32 ecx_113 = 0x00;
		do
		{
			ebp_117 = ebp_117->ptr0000;
			struct Eq_420 * esp_121 = (char *) &ebp_117->ptr0000 + 4;
			if (ecx_84 == 0x0A71A0A3)
			{
				eax_125->dw84881211 &= eax_125;
				goto l00401213;
			}
			eax_125 = __smsw<word32>();
			byte al_130 = (byte) eax_125;
			++ecx_113;
			if (ecx_113 == 0x02)
				return eax_125;
		} while ((al_130 & 0x08) != 0x00);
		do
			;
		while (((byte) __smsw<word32>() & 0x02) == 0x00);
		uint32 ebx_145 = ebx_105 - edx_756;
		esi_101 = edx_756 + ebx_145;
		ui64 edi_ebx_671 = SEQ(esi_101, ebx_145 - (edx_100 + ecx_113) - (word32) (esi_101 < 0x00)) - SEQ(ebx_158, esi_101);
		uint32 ebx_158 = (word32) edi_ebx_671;
		edi_165 = SLICE(edi_ebx_671, word32, 32);
		ecx_113 = esi_101;
		edx_100 = ebx_158;
		ebx_105 = esi_101;
l00401213:
		esp_121->ptrFFFFFFFC = null;
		uint32 edx_184 = edx_100 & ebx_105;
		eax_178 = esp_121->ptrFFFFFFFC;
		uint32 ecx_187 = ecx_113 - edx_184;
		byte al_234 = (byte) eax_178;
		word24 eax_24_8_291 = SLICE(eax_178, word24, 8);
		uint32 esi_182 = esi_101 & ebx_105;
		ui32 edi_193 = (edi_165 | ecx_187) - ebx_105 * 0x02;
		uint32 ebx_194 = ebx_105 & (edx_184 | ecx_187);
		edx_195 = null;
		ui64 edi_esi_659 = SEQ(edi_193, esi_182 - eax_178) - SEQ(esi_200, 0x00);
		ui64 edi_ecx_662 = SEQ(SLICE(edi_esi_659, word32, 32), ecx_187) - SEQ(ebx_194, ebx_194);
		ui32 esi_200 = (word32) edi_esi_659;
		ecx_204 = (word32) edi_ecx_662;
		uint32 esi_211 = esi_200 & eax_178 + (SLICE(edi_ecx_662, word32, 32) & esi_200);
		__syscall<byte>(0x2E);
		ui64 esi_esi_680 = SEQ(esi_220, esi_211) - SLICE(cond(esi_211), bool, 1);
		word32 esi_223 = SLICE(esi_esi_680, word32, 32);
		ebx_227 = ecx_204 + esi_223;
		ui32 esi_220 = (word32) esi_esi_680;
		edi_224 = ecx_204;
		ecx_226 = ecx_204;
		byte cl_232 = (byte) ecx_204;
		esi_20 = (struct Eq_7 *) (ebx_227 + esi_223);
		if (ecx_204 != (struct Eq_37 *) ~0x27D25932)
		{
			edi_231 = esi_20;
			goto l004012DD;
		}
		eax_178[0x0011] = (struct Eq_60) cl_232;
		eax_261 = SEQ(eax_24_8_291, al_234 + ((eax_178->a0003))[ecx_204].b0000);
		ebx_227->t0000.u1 = 468855755;
	}
	ebx_227->t0000.u0 = ~0x34;
	edx_195 += edi_224;
	ui32 edi_283 = edi_224 | edx_195;
	if (ebx_227 == (struct Eq_37 *) 3060930675)
	{
		eax_261->b8BD82321 |= ~0x29;
		goto l00401133;
	}
	esi_20 |= eax_261;
	edi_231 = esi_20;
	ebx_227 = ebx_227 + esi_20 - edx_195 | ecx_226;
	edx_195 = ecx_226;
	byte dl_336 = (byte) ecx_226;
	eax_178 = (eax_261 & ecx_226) - esi_20;
	if (ecx_226 != (struct Eq_37 *) 3253130730)
	{
		edi_224 = esi_20 & ecx_226 + eax_178;
		ui64 eax_esi_683 = &&(eax_178->*((eax_178->*esi_20).t0000).u0) - &(&(ecx_226->*((ecx_226->*edi_224).t0000).u0));
		esi_307 = (word32) eax_esi_683;
		word32 eax_313 = SLICE(eax_esi_683, word32, 32) - ebx_227;
		ebx_227 = edi_224 + ((ebx_227 & esi_307 | esi_307) - esi_307);
		ecx_320 = esi_307 + edi_224;
		if (edi_224 != (struct Eq_37 *) 3432011399)
		{
			ui32 ebx_324 = ebx_227 & ecx_226;
			ecx_226 += ebx_324;
			eax_261 = eax_313 - ebx_227;
			esi_20 = (esi_307 & ecx_226) - edi_224;
			edi_283 = edi_224 & ebx_324;
			ebx_227 = ebx_324 | ecx_226;
l00401133:
			uint32 eax_440 = eax_261 & esi_20 | ebx_227;
			uint32 ecx_441 = ecx_226 - eax_261 - esi_20 - edx_195;
			ui64 ecx_eax_674 = SEQ(ecx_441, eax_440) - SEQ(eax_445, ecx_441);
			edx = edx_195 | eax_440;
			eax_445 = (word32) ecx_eax_674;
			edi_29 = esi_20 + ((edi_283 & edx_195) + eax_440);
			byte dl_451 = (byte) edx;
			ecx_33 = SLICE(ecx_eax_674, word32, 32);
			byte ah_453 = SLICE(eax_445, byte, 8);
			byte al_625 = (byte) eax_445;
			word16 eax_16_16_626 = SLICE(eax_445, word16, 16);
			if (edi_29 != 4184274414)
				return eax_445;
			ecx_33->t0000.u0 = dl_451;
			eax = SEQ(eax_16_16_626, ah_453 + (ebx_227->t0000).u0 + (byte) (edi_29 < 4184274414), al_625);
			goto l00401159;
		}
		ecx_320->t0000.u0 = dl_336;
		eax_335 = eax_313 - 0x01;
l0040127A:
		uint32 ebx_390 = edi_224 + (ebx_227 | eax_335);
		uint32 ecx_394 = (ecx_320 & ebx_390) - eax_335;
		struct Eq_475 * ebx_393 = ebx_390 - edi_224;
		byte cl_406 = (byte) ecx_394;
		struct Eq_462 * eax_396 = eax_335 | esi_307;
		if (ecx_394 == 3067702396)
		{
			eax_396->dw8B844801 = eax_396->dw8B844801 + ecx_394 + (word32) (ecx_394 < 3067702396);
			ebx_393->dw0000 >>= cl_406;
		}
		ebx_393->dw0000 <<= 0x01;
		ebx_393->dw23F81BC3 = 466586590;
	}
	eax_178->dwFE8B0148 &= eax_178;
l004012DD:
	word32 eax_364;
	ui32 edi_351 = edi_231 - ebx_227 - (word32) (ecx_204 < (struct Eq_37 *) ~0x27D25932);
	word24 eax_24_8_365 = SLICE(eax_178, word24, 8);
	ecx_320 = ecx_226 & edi_351;
	edi_224 = edi_351 & eax_178;
	if (edx_195 != (struct Eq_37 *) ~0x00)
	{
		byte al_361 = edx_195->bFFFFFFFF;
		eax_364 = SEQ(eax_24_8_365, al_361);
		if (edi_224 == (struct Eq_37 *) 0x4C33060D)
		{
			eax_501 = SEQ(eax_24_8_365, al_361 + SEQ(eax_24_8_365, al_361)->bB010112 + (byte) (edi_224 < (struct Eq_37 *) 0x4C33060D));
			goto l00401301;
		}
	}
	else
		eax_364 = SEQ(eax_24_8_365, 0x2E);
	if (eax_364 == 0xC000002E)
	{
l0040134E:
		ui32 edx_475 = edx_195 & ecx_320;
		ui64 ebx_ebx_677 = SEQ(ebx_477, ebx_227) - SEQ(edx_475, ecx_320);
		esi_20 += edx_195;
		ui32 ebx_477 = (word32) ebx_ebx_677;
		edx_195 = edx_475 - edi_224 - (word32) (SLICE(ebx_ebx_677, word32, 32) < 0x00);
		uint32 eax_492 = edx_195 + (ecx_320 & esi_20);
		edi_224 = edi_224 - esi_20 - (word32) (eax_492 < 0x00);
		ecx_320 = edi_224;
		ebx_227 = esi_20 & ecx_320 & eax_492;
		eax_501 = eax_492 | edi_224;
l00401301:
		struct Eq_274 * ecx_514 = ecx_320 - esi_20 - (word32) (ebx_227 + eax_501 < 0x00);
		ui32 esi_519 = esi_20 | (ebx_227 & ecx_514 | edi_224) | esi_20;
		uint32 edi_521 = edi_224 - esi_20;
		eax_445 = (Eq_2) (ecx_514 + (((esi_20 - edi_521) - (word32) (edi_521 < 0x00)) + edi_521));
		edi_247 = edi_521 - eax_445 - (word32) (eax_445 < null);
		esi_241 = esi_519 - eax_445 + edi_247;
		ebx_227 = edx_195;
		eax_ecx_753 = SEQ(eax_445, ecx_514);
		if (eax_445 == (struct <anonymous> *) 2416080228)
		{
			Mem542[ecx_514 + 4044048392 + eax_445:word32] = Mem539[ecx_514 + 4044048392 + eax_445:word32] & eax_445;
			return eax_445;
		}
l00401404:
		__cli();
		uint64 eax_ecx_665 = eax_ecx_753 - SEQ(ecx_567, esi_241);
		uint32 esi_577 = esi_241 | edi_247;
		uint32 ecx_567 = (word32) eax_ecx_665;
		uint32 eax_573 = SLICE(eax_ecx_665, word32, 32);
		uint32 edx_578 = edx_195 & esi_577;
		ui64 ecx_edx_656 = SEQ(edi_247, edx_578) - SEQ(edx_583, esi_577);
		ui32 edx_583 = (word32) ecx_edx_656;
		word32 ecx_586 = SLICE(ecx_edx_656, word32, 32);
		Eq_2 ebx_599;
		word32 esi_603;
		__out<word32>(fn004025D7(eax_573, ecx_586, ebx_227, edi_247, out ebx_599, out esi_603), ebx_599);
		return ebx_599;
	}
	esi_307 = esi_20 | ecx_320;
	ebx_227 &= edx_195;
	eax_335 = edx_195;
	edx = edx_195 - esi_307;
	if (edi_224 == (struct Eq_37 *) 913029098)
	{
		edx_195->t0000.u1 = ecx_320 + (edx_195->t0000).u1;
		eax = edx_195 - (struct Eq_605 *) 0x01;
		goto l004013BE;
	}
	goto l0040127A;
}

// 00401FB3: void fn00401FB3(Register ui32 eax, Register ui32 ecx, Register word32 edx, Register ui32 esi)
// Called from:
//      fn0040209F
void fn00401FB3(ui32 eax, ui32 ecx, word32 edx, ui32 esi)
{
	ui32 ecx_6 = ecx | esi;
	ui32 esi_18 = esi - ecx_6;
	byte * ecx_24 = (ecx_6 | esi_18) - eax;
	Eq_626 ecx_31 = ecx_24 * 0x02 + edx;
	fn0040252A(ecx_24, ecx_31, edx + ~0x026F, ecx_24, ecx_24);
}

// 00401FF4: void fn00401FF4(Register up32 eax, Register (ptr32 (ptr32 Eq_649)) ecx, Register ui32 ebx, Register ui32 esi, Register uint32 edi)
// Called from:
//      fn0040209F
void fn00401FF4(up32 eax, struct Eq_649 ** ecx, ui32 ebx, ui32 esi, uint32 edi)
{
	byte cl_85 = (byte) ecx;
	ui32 ebx_6 = ebx | edi;
	struct Eq_649 * v10_9 = *ecx;
	ui32 esi_18 = esi - ecx - (word32) (eax + edi < 0x00);
	uint32 edx_23 = edi + (ebx_6 - edi);
	ui32 edi_33 = (edi | ecx) - v10_9;
	byte al_41 = (byte) v10_9;
	byte ah_55 = SLICE(v10_9, byte, 8);
	uint32 esi_35 = (esi_18 & edi) + edi + edi_33 - ((edx_23 - edi) - (word32) (edx_23 < 0x00) | ecx);
	uint32 edx_42 = (word32) al_41;
	ui32 edi_44 = edx_42 | v10_9;
	ui32 esi_50 = (esi_35 & edi_33) - v10_9 + edi_44 + (edi_44 - edx_42);
	uint32 ebx_56 = (word32) ah_55;
	ui32 esi_66 = esi_50 & edx_42 | ecx;
	if (esi_66 != 1684888342)
		fn00402783(v10_9, ecx, edx_42, ebx_56, esi_66);
	else
	{
		v10_9->b8B880180 |= cl_85;
		fn00402783(v10_9, ecx, edx_42, ebx_56, esi_66);
	}
}

// 0040200E: void fn0040200E()
// Called from:
//      fn004025D7
//      fn00402724
void fn0040200E()
{
	Eq_626 ecx;
	fn00402846(ecx, edx);
}

// 00402055: void fn00402055(Register Eq_626 eax, Register (ptr32 (ptr32 code)) edx, Register Eq_626 ebx, Register ui32 esi, Register (ptr32 byte) edi, Stack Eq_727 dwArg00)
// Called from:
//      fn00401FF4
//      fn0040209F
void fn00402055(Eq_626 eax, <anonymous> ** edx, Eq_626 ebx, ui32 esi, byte * edi, Eq_727 dwArg00)
{
	up32 ebx_22 = &(ebx.u0 + esi / 4)->u0;
	up32 edx_29 = edx - ebx_22 - (word32) (ebx_22 < 0x00);
	uint32 eax_33 = eax | esi | esi | esi;
	uint32 edx_39 = edx_29 + eax_33;
	ui32 edi_35 = edi | dwArg00;
	uint32 ebx_37 = ebx_22 + edx_29 - eax_33;
	uint32 eax_40 = eax_33 - edx_39;
	fn00402450(SEQ(edx_39, eax_40), dwArg00, ebx_37, edi_35);
}

// 00402076: Register word16 fn00402076(Register (ptr32 Eq_758) eax, Register uint32 ecx, Register Eq_152 ebx, Register uint32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn004025D7
word16 fn00402076(struct Eq_758 * eax, uint32 ecx, Eq_152 ebx, uint32 edi, ptr32 & ebxOut, ptr32 & esiOut)
{
	struct Eq_764 * eax_10 = eax & edi;
	ui32 edi_12 = edi & ebx;
	ui32 esi_14 = edi | edi_12;
	ui32 ecx_20 = ecx + esi_14;
	byte al_66 = (byte) eax_10;
	uint32 edi_19 = edi_12 | ebx;
	ui32 ebx_22 = (word32) ebx.u0 + esi_14;
	ui32 edx_23 = ecx_20 | esi_14;
	if (edx_23 != 2266289763)
	{
		ui32 edx_30 = edx_23 | edi_19;
		int32 esi_31 = esi_14 + edi_19 + ebx_22;
		uint32 ecx_32 = edx_23 | eax_10 | edx_30;
		ui64 edx_ecx_74 = SEQ(edx_30 | eax_10, ecx_32) - SEQ(ebx_22, edi_19);
		uint32 edx_42 = SLICE(edx_ecx_74, word32, 32);
		ptr32 eax_45 = eax_10 - edi_19 - (word32) (edx_42 < 0x00);
		uint32 ebx_47 = edx_42 + eax_45;
		Eq_816 eax_48 = eax_45 + esi_31;
		ui32 edi_50 = edi_19 | ebx_47;
		ui32 esi_52 = (word32) edx_ecx_74 | edx_42;
		ptr32 ebx_57;
		ptr32 esi_61;
		uint32 edx_60 = (uint32) fn004021C4(eax_48, ebx_47, esi_52, edi_50, 35435499, out ebx_57, out esi_61);
		ebxOut = ebx_57;
		esiOut = esi_61;
		return (word16) edx_60;
	}
	else
		eax_10->a2BD88B48[ecx_20].b0000 |= al_66;
}

// 0040209F: void fn0040209F(Register Eq_626 eax, Register ui32 edx, Register word32 edi, Stack Eq_727 dwArg00)
// Called from:
//      fn004021A4
void fn0040209F(Eq_626 eax, ui32 edx, word32 edi, Eq_727 dwArg00)
{
	ui32 edx_9 = edx | eax;
	byte * edi_16 = edi - edx_9;
	<anonymous> ** edx_18 = edx_9 & edi_16;
	Eq_626 ebx_22 = edx_9 & edx_18;
	fn00402055(eax, edx_18, ebx_22, edx_9, edi_16, dwArg00);
}

// 00402142: void fn00402142(Register Eq_626 eax, Register (ptr32 (ptr32 code)) edx)
// Called from:
//      fn00401FF4
//      fn00402304
void fn00402142(Eq_626 eax, <anonymous> ** edx)
{
	if (edx != (<anonymous> **) 0x87E05D27)
		return;
	fn0040215D(eax, edx);
}

// 0040215D: void fn0040215D(Register Eq_626 eax, Register (ptr32 (ptr32 code)) edx)
// Called from:
//      fn00402142
//      fn004025D7
void fn0040215D(Eq_626 eax, <anonymous> ** edx)
{
	struct Eq_865 * fp;
	byte al_10 = (byte) eax;
	Mem8[edx + 0x00:word32] = Mem0[edx + 0x00:word32] + eax;
	fp->a23F71B11[eax].b0000 = al_10;
}

// 00402163: void fn00402163(Register Eq_626 eax, Register Eq_626 ecx, Register (ptr32 (ptr32 code)) edx, Register Eq_626 ebx, Register (ptr32 byte) edi)
// Called from:
//      fn00401FF4
void fn00402163(Eq_626 eax, Eq_626 ecx, <anonymous> ** edx, Eq_626 ebx, byte * edi)
{
	byte al_38 = (byte) eax;
	word32 edx_15 = edx + ecx;
	word32 edi_19 = edi + edx - eax - edx_15 - CONVERT(edx_15 <u 0x00, bool, word32);
	ui32 ebx_23 = (ebx | edi_19) & edx_15 | edx_15;
	uint32 edi_24 = &(eax.u0 + edi_19 / 4)->u0;
	if (eax != 1054200137)
		fn00402575(SEQ(ebx_23, edi_24), eax, ecx, edx_15, edx_15);
	else
	{
		eax.u1->b21840288 = al_38;
		word32 ebx_65;
		word32 esi_66;
		fn0040218F(eax, ecx, edx_15, ebx_23, edx_15, edi_24, out ebx_65, out esi_66);
	}
}

// 0040218F: Register word16 fn0040218F(Register Eq_626 eax, Register Eq_626 ecx, Register (ptr32 (ptr32 code)) edx, Register ui32 ebx, Register (ptr32 (ptr32 code)) esi, Register uint32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn00402163
//      fn004021C4
word16 fn0040218F(Eq_626 eax, Eq_626 ecx, <anonymous> ** edx, ui32 ebx, <anonymous> ** esi, uint32 edi, ptr32 & ebxOut, ptr32 & esiOut)
{
	up32 ecx_6 = &(ecx.u0 + edi / 4)->u0;
	up32 edi_10 = edi - ebx - (word32) (ecx_6 < 0x00);
	up32 esi_14 = esi - edi_10 - (word32) (edi_10 < 0x00);
	fn004021A4();
	up32 esi_18 = esi_14 - edx - (word32) (esi_14 < 0x00);
	ptr32 ebx_22 = ebx - eax - (word32) (esi_18 < 0x00);
	ptr32 esi_25 = esi_18 - edx + ecx_6;
	uint32 edx_35 = (uint32) fn004021A4();
	ebxOut = ebx_22;
	esiOut = esi_25;
	return (word16) edx_35;
}

// 004021A4: Register word16 fn004021A4()
// Called from:
//      fn0040218F
word16 fn004021A4()
{
	word32 edi;
	Eq_626 eax;
	ui32 edx;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_727 stackArg0 = <invalid>;
	fn0040209F(eax, edx, edi, stackArg0);
	return <invalid>;
}

// 004021C4: Register word16 fn004021C4(Register Eq_816 eax, Register uint32 ebx, Register ui32 esi, Register ui32 edi, Stack ui32 dwArg00, Register out ptr32 ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn00402076
word16 fn004021C4(Eq_816 eax, uint32 ebx, ui32 esi, ui32 edi, ui32 dwArg00, ptr32 & ebxOut, ptr32 & esiOut)
{
	ui32 eax_19 = eax & esi & ebx;
	<anonymous> ** edi_15 = edi & dwArg00;
	ui32 ebx_22 = ebx - eax_19;
	ui32 ebx_31 = ebx_22 - edi_15 | dwArg00 ^ 35435435;
	Eq_626 eax_28 = eax_19 & esi;
	ui32 edi_33 = (char *) edi_15 + ebx_31 & eax_28;
	ui32 ebx_38 = ebx_31 - eax_28;
	uint32 edi_41 = (edi_33 | eax_28) + (dwArg00 ^ 35435435);
	<anonymous> ** esi_46 = (eax_28 & ebx_38) - (dwArg00 ^ 35435435);
	Eq_626 ecx_47 = (dwArg00 ^ 35435435) & edi_15;
	ptr32 ebx_52;
	ptr32 esi_56;
	uint32 edx_55 = (uint32) fn0040218F(eax_28, ecx_47, edi_15, ebx_38, esi_46, edi_41, out ebx_52, out esi_56);
	ebxOut = ebx_52;
	esiOut = esi_56;
	return (word16) edx_55;
}

// 00402222: void fn00402222()
// Called from:
//      fn00401FF4
//      fn0040261E
void fn00402222()
{
	word32 esi_72;
	fn00402603(eax, edx, esi, out esi_72);
}

// 00402304: Register word16 fn00402304()
// Called from:
//      fn00401FF4
//      fn00402603
word16 fn00402304()
{
	word32 esi_74;
	return fn00402603(eax, edx, esi, out esi_74);
}

// 0040238F: void fn0040238F(Sequence ui64 ebx_edi, Register (ptr32 Eq_1023) eax, Register (ptr32 (ptr32 Eq_649)) ecx, Register (ptr32 Eq_1024) edx, Register uint32 esi)
// Called from:
//      fn00402474
//      fn00402783
void fn0040238F(ui64 ebx_edi, struct Eq_1023 * eax, struct Eq_649 ** ecx, struct Eq_1024 * edx, uint32 esi)
{
	ui32 ebx = SLICE(ebx_edi, word32, 32);
	uint32 edx_14 = edx & ebx;
	ui64 ebx_edi_43 = ebx_edi - SEQ(edx_14, edx_14);
	uint32 ebx_21 = SLICE(ebx_edi_43, word32, 32);
	ui32 esi_29 = esi - ebx & (char *) ecx + (((word32) ebx_edi_43 - eax) - (word32) (ebx_21 < 0x00));
	fn00402783(eax ^ ~0x0137, ecx, edx_14, ebx_21, esi_29);
}

// 004023AA: void fn004023AA()
// Called from:
//      fn00402450
//      fn00402458
void fn004023AA()
{
	fn004025B9();
}

// 004023C6: void fn004023C6(Register (ptr32 code) eax, Register Eq_727 edx, Register word32 ebx, Register ui32 edi)
// Called from:
//      fn00402407
//      fn00402575
void fn004023C6(<anonymous> * eax, Eq_727 edx, word32 ebx, ui32 edi)
{
	byte * edx_18;
	word32 eax_19;
	byte * ecx_20;
	eax();
	byte al_38 = (byte) eax_19;
	word24 eax_24_8_45 = SLICE(eax_19, word24, 8);
	byte cl_47 = (byte) ecx_20;
	if (edx_18 != (byte *) 311328002)
	{
		if (ecx_20 != (byte *) 3438968292)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_727 stackArg4 = <invalid>;
			fn004024B3(stackArg4);
		}
		else
		{
			*ecx_20 &= 0x12;
			*ecx_20 |= al_38;
			fn00402222();
		}
	}
	else
	{
		struct Eq_1086 * eax_46 = SEQ(eax_24_8_45, al_38 + *edx_18);
		eax_46->b0008 |= cl_47;
		eax_46->dwFA2BCE0B = eax_46 + eax_46->dwFA2BCE0B / 9;
		fn004023EB(edx);
	}
}

// 004023E7: void fn004023E7(Register Eq_727 edx)
// Called from:
//      fn00402450
//      fn004024B3
void fn004023E7(Eq_727 edx)
{
	fn004023EB(edx);
}

// 004023EB: void fn004023EB(Register Eq_727 edx)
// Called from:
//      fn00401FF4
//      fn004023E7
void fn004023EB(Eq_727 edx)
{
	fn004028B4();
}

// 00402407: void fn00402407(Sequence ui64 edx_edi, Register (ptr32 Eq_1023) eax, Register (ptr32 (ptr32 Eq_649)) ecx, Register ui32 ebx)
// Called from:
//      fn00402783
//      fn00402846
void fn00402407(ui64 edx_edi, struct Eq_1023 * eax, struct Eq_649 ** ecx, ui32 ebx)
{
	uint32 esi;
	struct Eq_1024 * edx = SLICE(edx_edi, word32, 32);
	byte bl_21 = (byte) ebx;
	word24 ebx_24_8_183 = SLICE(ebx, word24, 8);
	uint32 edi = (word32) edx_edi;
	ui32 esi_10 = edx - (word32) edx_edi;
	ui32 edi_25 = edi - esi_10;
	byte * ebx_165 = SEQ(ebx_24_8_183, __rol<byte,byte>(bl_21, 0x00));
	int32 ecx_34 = edi_25 & esi_10;
	while (true)
	{
		uint32 ecx_47 = ecx_34 - edx * 0x02;
		byte bl_50 = (byte) ebx_165;
		word24 ebx_24_8_59 = SLICE(ebx_165, word24, 8);
		byte ah_166 = SLICE(eax, byte, 8);
		byte cl_172 = (byte) ecx_47;
		if (eax == (struct Eq_1023 *) 0x5597ADF3)
			break;
		ui32 ecx_56 = ecx_47 & edx;
		ecx_34 = ecx_56 | eax & ecx_56;
		ui8 bl_64 = bl_50 + 0x20 ^ ~0x0C;
		ui8 * esi_74 = edx + ecx_34 / 2;
		ui32 esi_78 = esi_74 & edx - esi_74;
		ebx_165 = SEQ(ebx_24_8_59, bl_64);
		if (eax != (struct Eq_1023 *) 0xA843037B)
		{
			edx->b0000 = bl_64;
			word32 esi_91 = esi_78 - eax;
			word32 edi_92 = esi_78 - edx - esi_91;
			uint32 esi_93 = edx + esi_91 / 2;
			byte * ebx_97 = SEQ(ebx_24_8_59, bl_64);
			if (edx == (struct Eq_1024 *) 0x15A227E2)
			{
				fn00402724();
				return;
			}
			ui64 edi_ecx_192 = SEQ(ebx_97 + edi_92 & edx, esi_93) - &(ebx_97->*ebx_97);
			uint32 edi_105 = SLICE(edi_ecx_192, word32, 32);
			up32 esi_108 = esi_93 - edx - edi_105 - (word32) (edi_105 < 0x00);
			uint32 esi_111 = esi_108 - edi_105 - (word32) (esi_108 < 0x00);
			ui64 ecx_ecx_195 = SEQ(ecx_112, (word32) edi_ecx_192) - esi_111;
			Eq_1291 dl_131 = (byte) edx + 0x01;
			word24 edx_24_8_140 = SLICE(edx + 0x01, word24, 8);
			ui32 ecx_112 = (word32) ecx_ecx_195;
			ui32 ecx_115 = SLICE(ecx_ecx_195, word32, 32);
			uint32 esi_117 = esi_111 | edx + 0x01;
			ui64 ecx_edi_198 = SEQ(ecx_115, edi_105) - esi_117;
			uint32 ecx_122 = eax + SLICE(ecx_edi_198, word32, 32) / 558401541;
			byte * edi_118 = (word32) ecx_edi_198;
			word32 ecx_126 = ecx_122 - esi_117 - CONVERT(ecx_122 <u 0x00, bool, word32) | edx + 0x01;
			byte ah_134 = SLICE(eax - 0x01, byte, 8);
			if (eax != (struct Eq_1023 *) 3481022061)
			{
				word32 esi_243;
				fn004025FF(eax, edx, esi, out esi_243);
				return;
			}
			else
			{
				&ecx_126->u0->u0 = dl_131;
				byte dl_133 = dl_131 + Mem132[edx + 0x01:byte];
				*ebx_97 |= ah_134;
				<anonymous> ** edx_141 = SEQ(edx_24_8_140, dl_133);
				fn0040252A(eax - 0x01, ecx_126, edx_141, ebx_97, edi_118);
				return;
			}
		}
		eax->dw21488801 = eax->dw21488801 + ecx_34 + (word32) (eax < (struct Eq_1023 *) 0xA843037B);
		*ebx_165 |= ah_166;
	}
	eax->t0000.u1 = (byte) (eax->t0000.u1 | cl_172);
	ui40 v21_v20_189 = SEQ(edx->b0000, eax->t0000.u0) + SEQ(0x23, ecx_47);
	eax->t0000.u0 = (uint32) (word32) v21_v20_189;
	edx->b0000 = SLICE(v21_v20_189, byte, 32);
	fn0040238F(SEQ(ebx, edi), eax, ecx, edx, esi);
}

// 00402450: void fn00402450(Sequence uint64 edx_eax, Register Eq_727 ecx, Register uint32 ebx, Register ui32 edi)
// Called from:
//      fn00402055
//      fn0040209F
void fn00402450(uint64 edx_eax, Eq_727 ecx, uint32 ebx, ui32 edi)
{
	uint32 edx = SLICE(edx_eax, word32, 32);
	ui64 edx_eax_28 = edx_eax - SEQ(ecx, edx);
	ui32 edi_6 = edi | ebx;
	struct Eq_649 * eax_11 = (word32) edx_eax_28;
	uint32 edx_14 = SLICE(edx_eax_28, word32, 32);
	fn00402458(eax_11, edx_14, ebx, edi_6);
}

// 00402458: void fn00402458(Register (ptr32 Eq_649) eax, Register uint32 edx, Register uint32 ebx, Register ui32 edi)
// Called from:
//      fn00401FF4
//      fn00402450
void fn00402458(struct Eq_649 * eax, uint32 edx, uint32 ebx, ui32 edi)
{
	bool C;
	uint32 edx_25 = edx - eax - (word32) C;
	struct Eq_1379 * ebx_31 = ebx - edx_25 - (word32) (edx_25 < 0x00) | eax;
	if (edi != 2343233218)
		fn004023AA();
	else
		fn00402471(eax, ebx_31);
}

// 00402471: void fn00402471(Register (ptr32 Eq_649) eax, Register (ptr32 Eq_1379) ebx)
// Called from:
//      fn00402450
//      fn00402458
void fn00402471(struct Eq_649 * eax, struct Eq_1379 * ebx)
{
	bool C;
	Mem10[ebx + 66595825 + eax:word32] = Mem0[ebx + 66595825 + eax:word32] + eax + CONVERT(C, bool, word32);
}

// 00402474: void fn00402474(Register (ptr32 Eq_649) eax, Register (ptr32 (ptr32 Eq_649)) ecx, Register uint32 edx, Register uint32 ebx, Register ui32 esi, Register ui32 edi)
// Called from:
//      fn00401FF4
void fn00402474(struct Eq_649 * eax, struct Eq_649 ** ecx, uint32 edx, uint32 ebx, ui32 esi, ui32 edi)
{
	ui32 eax_11 = eax + edx;
	ui32 edi_9 = edi - eax;
	ui32 edx_15 = (edx & eax_11) + edi_9 | edi_9;
	ui32 esi_16 = (char *) ecx + esi + edi_9 - ecx;
	uint32 edi_21 = (edi_9 + ebx & esi_16) - ebx;
	ui32 esi_24 = eax_11 + edx_15;
	struct Eq_1024 * edx_27 = esi_24 - edi_21;
	struct Eq_1023 * eax_23 = eax_11 + ebx;
	ui32 ebx_25 = ebx - edx_15;
	uint32 esi_28 = esi_24 & edx_27;
	fn0040238F(SEQ(ebx_25, edi_21), eax_23, ecx, edx_27, esi_28);
}

// 004024B3: void fn004024B3(Stack Eq_727 dwArg04)
// Called from:
//      fn00401FF4
//      fn004023AA
void fn004024B3(Eq_727 dwArg04)
{
	fn004023E7(dwArg04);
}

// 0040252A: void fn0040252A(Register (ptr32 byte) eax, Register Eq_626 ecx, Register (ptr32 (ptr32 code)) edx, Register (ptr32 byte) ebx, Register (ptr32 byte) edi)
// Called from:
//      fn00401FB3
//      fn00402407
void fn0040252A(byte * eax, Eq_626 ecx, <anonymous> ** edx, byte * ebx, byte * edi)
{
	Eq_626 eax_43 = (eax | edi) & ecx;
	if (ebx != (byte *) 0x2D7CC996)
		fn0040261C();
	else
		fn00402548(eax_43, ecx, edx, eax_43, ebx);
}

// 00402548: void fn00402548(Register Eq_626 eax, Register Eq_626 ecx, Register (ptr32 (ptr32 code)) edx, Register Eq_626 ebx, Register (ptr32 byte) edi)
// Called from:
//      fn00402407
//      fn0040252A
void fn00402548(Eq_626 eax, Eq_626 ecx, <anonymous> ** edx, Eq_626 ebx, byte * edi)
{
	Eq_1462 fp;
	byte ah_9 = SLICE(eax, byte, 8);
	byte cl_14 = (byte) ecx;
	byte ch_276 = SLICE(ecx, byte, 8);
	word16 ecx_16_16_280 = SLICE(ecx, word16, 16);
	eax.u1->dwFFFFFF80 = &(ecx.u0 + (eax.u1)->dwFFFFFF80 / 4)->u0;
	&ecx->u0->u0 = *ecx | ah_9;
	&ebx->u0->u0 = *ebx | cl_14;
	byte al_214 = (byte) ecx;
	uint32 edi_32 = edi | ecx;
	<anonymous> ** edx_34 = 0x00 - ecx - edx;
	union Eq_1520 * ebx_36 = (char *) edx + (ebx & ecx) | ecx;
	if (ecx != 391918770)
	{
		ebx_36->u0 = (ui32) (ebx_36->u0 << 0x01);
		uint32 ebx_45 = ebx_36 | ecx | edx | edx_34;
		ui32 esi_47 = ebx_45 & edi_32;
		ui32 edx_48 = edx_34 - edi_32;
		if (ebx_45 != 0xC66F212C)
		{
			Eq_1547 esi_57 = SLICE(SEQ(esi_47 - (edx_48 | ecx), edi_32) - SEQ(ecx, ebx_45), word32, 32);
			uint32 ebx_62 = &(ecx.u0 + ebx_45 / 4)->u0;
			if (ebx_62 == 0x2ACF0F9F)
			{
				ecx.u1->dw0008 = &(ecx.u0 + (ecx.u1)->dw0008 / 4)->u0;
				fn00402304();
				return;
			}
			ui64 ebx_esi_300 = SEQ(ecx + 80, esi_57 | ecx) - SEQ(esi_70, ecx);
			word32 edi_67 = ecx + 80 - esi_57 - CONVERT(ebx_62 <u 0x2ACF0F9F, bool, word32);
			ui32 esi_70 = (word32) ebx_esi_300;
			union Eq_1291 * ebx_108 = SLICE(ebx_esi_300, word32, 32) - edi_67;
			if (ebx_108 == (union Eq_1291 *) ~0x7851F580)
			{
				ui40 v29_v27_301 = SEQ(Mem84[ebx_108 + 0x00:word32], Mem40[ecx + 80:byte]) + SEQ(fp + 0x01, 0x11);
				Mem84[ecx + 80:byte] = SLICE(v29_v27_301, byte, 0);
				ebx_108->u0 = SLICE(v29_v27_301, word32, 8);
			}
			else
				ebx_108 &= ecx;
			ui64 esi_edi_304 = SEQ(ecx, edi_67) - SEQ(ecx, ecx + 80);
			ui32 edx_112 = &((Eq_1291[]) 80 + (ecx * 0x02) / 4)->u0;
			up32 esi_106 = SLICE(esi_edi_304, word32, 32);
			ui32 edi_102 = (word32) esi_edi_304;
			Eq_1291 dl_207 = (byte) edx_112;
			ui32 ebx_113 = ebx_108 - ecx - (word32) (esi_106 < 0x00) + esi_106;
			if (ecx == ~0x4FA21732)
			{
				&ecx->u0->u0 = dl_207;
				(fp + 468779778)[ecx * 0x04] += ecx;
				fn00402142(eax, edx);
				return;
			}
			ui32 edi_116 = edi_102 | ebx_113;
			ui32 ebx_119 = ebx_113 - edi_116 | edx_112;
			ui32 esi_125 = &(ecx.u0 + esi_106 / 4)->u0 & edx_112;
			ui32 esi_129 = esi_125 - ebx_119;
			Eq_1658 esi_134 = esi_129 & edi_116;
			Eq_1660 edx_139 = edx_112 - ecx * 0x02;
			if (edx_139 == ~0x243438CC)
			{
				&((word32) (ecx - 8) + ecx * 0x02)->u0->u0 = (word32) *((word32) (ecx - 8) + ecx * 0x02) + 1;
				fn00402846(ecx, edx);
				return;
			}
			ui64 esi_esi_310 = SEQ(esi_146, esi_134 + (ecx + 0x0078)) - SEQ(ecx - edx_139, ecx);
			ui32 esi_146 = (word32) esi_esi_310;
			word32 esi_149 = SLICE(esi_esi_310, word32, 32);
			word32 edx_150 = ecx + esi_134 | ecx + 0x0078;
			word32 esi_157 = esi_149 + (ecx + 0x80) | ecx;
			word32 eax_171 = Mem121[ecx + 0x80:word32];
			word32 esi_166 = esi_157 & ecx + 0x80;
			byte al_190 = (byte) eax_171;
			word24 eax_24_8_194 = SLICE(eax_171, word24, 8);
			ui32 ebx_173 = edx_150 - esi_166;
			if (eax_171 * 0x02 == 3033517751)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_727 stackArg0 = <invalid>;
				fn00402055(eax, edx, ebx, esi, edi, stackArg0);
				return;
			}
			ui32 edx_178 = edx_150 & eax_171 * 0x02;
			byte * edx_182 = edx_178 & esi_166 & esi_166;
			uint32 ebx_186 = ebx_173 - edx_178 & (&(ecx.u0 + esi_166 / 4)->u0 | eax_171);
			if (ebx_186 == 601790348)
			{
				byte al_192 = al_190 + *edx_182 + (byte) (ebx_186 < 601790348);
				struct Eq_1742 * eax_195 = SEQ(eax_24_8_194, al_192);
				eax_195->b23D10302 |= al_192;
				fn004025B9();
				return;
			}
		}
		fn00402163(eax, ecx, edx, ebx, edi);
	}
	else
	{
		(fp - 0x0078)[ecx].b0000 = (fp - 0x0078)[ecx].b0000 | al_214;
		Eq_626 ecx_281 = SEQ(ecx_16_16_280, ch_276 + ebx_36->u1, cl_14);
		fn00402575(edi_32, ecx, ecx_281, edx_34, edx);
	}
}

// 00402575: void fn00402575(Sequence ui64 ebx_edi, Register Eq_626 eax, Register Eq_626 ecx, Register (ptr32 (ptr32 code)) edx, Register (ptr32 (ptr32 code)) esi)
// Called from:
//      fn00402163
//      fn00402407
void fn00402575(ui64 ebx_edi, Eq_626 eax, Eq_626 ecx, <anonymous> ** edx, <anonymous> ** esi)
{
	ui64 ebx_edi_49 = ebx_edi - SEQ(edi_20, eax);
	int32 edi_20 = (word32) ebx_edi_49;
	int32 esi_27 = esi | ecx;
	<anonymous> * eax_31 = *edx;
	word32 ebx_32 = (SLICE(ebx_edi_49, word32, 32) | edi_20) - edx;
	Eq_727 edx_33 = (char *) edx + esi_27;
	ui32 edi_35 = edi_20 + (esi_27 - edi_20);
	fn004023C6(eax_31, edx_33, ebx_32, edi_35);
}

// 004025B9: void fn004025B9()
// Called from:
//      fn00401FF4
//      fn004023AA
void fn004025B9()
{
}

// 004025D7: Register word16 fn004025D7(Register uint32 eax, Register word32 ecx, Register (ptr32 Eq_37) ebx, Register uint32 edi, Register out Eq_152 ebxOut, Register out ptr32 esiOut)
// Called from:
//      Win32CrtStartup
word16 fn004025D7(uint32 eax, word32 ecx, struct Eq_37 * ebx, uint32 edi, union Eq_152 & ebxOut, ptr32 & esiOut)
{
	struct Eq_758 * eax_19 = eax + edi;
	Eq_152 ebx_14 = eax - edi & (ecx + eax) - ebx;
	byte al_36 = (byte) eax_19;
	word24 eax_24_8_40 = SLICE(eax_19, word24, 8);
	struct Eq_1024 * edx_20 = eax | eax_19;
	if (eax != 0x55CD9D7D)
	{
		Eq_152 ebx_24;
		ptr32 esi_28;
		uint32 edx_27 = (uint32) fn00402076(eax_19, eax, ebx_14, edi, out ebx_24, out esi_28);
		ebxOut = ebx_24;
		esiOut = esi_28;
		return (word16) edx_27;
	}
	else
	{
		struct Eq_1023 * eax_41 = SEQ(eax_24_8_40, al_36 + eax_19->b23F22B02 + (byte) (eax < 0x55CD9D7D));
		ptr32 esi_46;
		uint32 edx_45 = (uint32) fn004025FF(eax_41, edx_20, edi, out esi_46);
		ebxOut = ebx_14;
		esiOut = esi_46;
		return (word16) edx_45;
	}
}

// 004025FF: Register word16 fn004025FF(Register (ptr32 Eq_1023) eax, Register (ptr32 Eq_1024) edx, Register uint32 esi, Register out ptr32 esiOut)
// Called from:
//      fn00401FF4
//      fn004025D7
word16 fn004025FF(struct Eq_1023 * eax, struct Eq_1024 * edx, uint32 esi, ptr32 & esiOut)
{
	word32 esi_30 = esi - edx;
	ptr32 esi_41;
	uint32 edx_40 = (uint32) fn00402603(eax, edx, esi_30, out esi_41);
	esiOut = esi_41;
	return (word16) edx_40;
}

// 00402603: Register word16 fn00402603(Register (ptr32 Eq_1023) eax, Register (ptr32 Eq_1024) edx, Register word32 esi, Register out Eq_1026 esiOut)
// Called from:
//      fn00402222
//      fn00402304
//      fn004025D7
//      fn004025FF
word16 fn00402603(struct Eq_1023 * eax, struct Eq_1024 * edx, word32 esi, union Eq_1026 & esiOut)
{
	ptr32 fp;
	byte al_35 = (byte) eax;
	Eq_1026 esi_11 = esi - eax;
	if ((eax + (edx | eax) / 558401541 & edx) != 3213370272)
	{
		uint32 edx_31 = (uint32) fn00402304();
		esiOut = eax - 0x5E51D005;
		return (word16) edx_31;
	}
	else
	{
		(fp - 117)[eax].b0000 = al_35;
		uint32 edx_39 = (uint32) fn0040261C();
		esiOut = esi_11;
		return (word16) edx_39;
	}
}

// 0040261C: Register word16 fn0040261C()
// Called from:
//      fn00401FF4
//      fn0040252A
//      fn00402603
word16 fn0040261C()
{
	fn0040261E();
	return <invalid>;
}

// 0040261E: void fn0040261E()
// Called from:
//      fn00402603
//      fn0040261C
void fn0040261E()
{
	fn00402222();
}

// 00402724: void fn00402724()
// Called from:
//      fn00401FF4
//      fn0040261E
void fn00402724()
{
	__lock();
	fn0040200E();
}

// 00402783: void fn00402783(Register (ptr32 Eq_649) eax, Register (ptr32 (ptr32 Eq_649)) ecx, Register uint32 edx, Register uint32 ebx, Register ui32 esi)
// Called from:
//      fn00401FF4
//      fn0040238F
void fn00402783(struct Eq_649 * eax, struct Eq_649 ** ecx, uint32 edx, uint32 ebx, ui32 esi)
{
	ui32 edi;
	byte cl_78 = (byte) ecx;
	ui32 edx_6 = edx & ebx;
	ui64 edi_esi_105 = SEQ(edx_6, esi + edx_6 & ebx) - SEQ(edx_6, ecx);
	word32 edi_17 = SLICE(edi_esi_105, word32, 32);
	ui32 edx_18 = edx_6 & ecx;
	word32 esi_22 = (word32) edi_esi_105 - edx_18 - (word32) ((ebx & eax) + edi_17 < 0x00);
	ui32 edi_23 = edi_17 + edx_18;
	struct Eq_1023 * eax_25 = ~eax;
	byte * esi_30 = esi_22 - (eax_25 - edi_23);
	if (ecx != (struct Eq_649 **) 0x73CD304A)
	{
		if (eax_25 != null)
			fn00402458(eax, edx, ebx, edi);
		else
		{
			uint64 edx_edi_111 = &(ecx->*esi_30) - ecx;
			uint32 edx_53 = SLICE(edx_edi_111, word32, 32);
			uint32 edi_50 = (word32) edx_edi_111;
			ui32 edx_56 = edx_53 - eax_25 - (word32) (edx_53 < 0x00);
			ui32 ebx_58 = esi_30 | eax_25;
			fn00402407(SEQ(edx_56, edi_50), eax_25, ecx, ebx_58);
		}
	}
	else
	{
		eax_25->dw0002 &= ecx;
		*esi_30 |= cl_78;
		fn00402474(eax, ecx, edx, ebx, esi, edi);
	}
}

// 00402846: void fn00402846(Register Eq_626 ecx, Register (ptr32 (ptr32 code)) edx)
// Called from:
//      fn00402407
//      fn00402724
void fn00402846(Eq_626 ecx, <anonymous> ** edx)
{
	uint32 edi;
	struct Eq_1023 * eax;
	ui32 ebx;
	word32 ecx_25 = ecx + edx;
	fn00402407(edi, eax, ecx_25, ebx);
}

// 004028B4: void fn004028B4()
// Called from:
//      fn0040209F
//      fn004023EB
void fn004028B4()
{
	ui32 ecx;
	fn00401FB3(eax, ecx, edx, esi);
}

