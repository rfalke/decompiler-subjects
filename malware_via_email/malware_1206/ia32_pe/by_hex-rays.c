/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __cdecl _set_app_type(_crt_app_type Type);
// HANDLE __stdcall GetProcessHeap();
// HANDLE __stdcall OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetCurrentProcessId();
// HANDLE __stdcall OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// DWORD __stdcall GetFileAttributesA(LPCSTR lpFileName);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall IsWindow(HWND hWnd);
// HDC __stdcall GetDC(HWND hWnd);
// LPSTR __stdcall CharUpperA(LPSTR lpsz);
// HRESULT __stdcall CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem, LPMONIKER *ppmk);
// int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int128 a4);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_412E33; // weak
_UNKNOWN unk_413EBF; // weak


//----- (004012F8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int128 a4)
{
  int v4; // ecx
  unsigned __int8 v5; // al
  _BYTE *v6; // eax
  int v7; // edx
  __int16 v8; // ax
  int v9; // ecx
  char *v10; // eax
  int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // edx
  __int64 v14; // rax
  int v15; // ecx
  unsigned int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // eax
  _DWORD *v20; // edi
  _DWORD *v21; // esi
  char *v22; // edx
  int v23; // ecx
  int v24; // ebx
  int v25; // ecx
  char *v26; // edx
  __int64 v28; // [esp-14h] [ebp-280h]
  int v29; // [esp-Ch] [ebp-278h]
  int v33; // [esp+Ch] [ebp-260h] BYREF
  int v34; // [esp+24h] [ebp-248h]
  int v35; // [esp+3Ch] [ebp-230h]
  char v36; // [esp+48h] [ebp-224h] BYREF
  _DWORD v37[2]; // [esp+49h] [ebp-223h]
  int v38; // [esp+54h] [ebp-218h]
  _DWORD *v39; // [esp+58h] [ebp-214h]
  char v40; // [esp+8Ch] [ebp-1E0h] BYREF
  int v41; // [esp+96h] [ebp-1D6h]
  __int16 v42; // [esp+A0h] [ebp-1CCh]
  int v43; // [esp+BCh] [ebp-1B0h]
  char v44; // [esp+C0h] [ebp-1ACh]
  int v45; // [esp+F0h] [ebp-17Ch]
  int v46; // [esp+118h] [ebp-154h]
  int v47; // [esp+11Ch] [ebp-150h]
  __int16 v48; // [esp+128h] [ebp-144h]
  int v49; // [esp+130h] [ebp-13Ch]
  int v50; // [esp+150h] [ebp-11Ch]
  int v51; // [esp+158h] [ebp-114h]
  int v52; // [esp+162h] [ebp-10Ah]
  CHAR sz[12]; // [esp+188h] [ebp-E4h] BYREF
  int v54; // [esp+194h] [ebp-D8h]
  int v55; // [esp+19Ch] [ebp-D0h]
  int v56; // [esp+1A0h] [ebp-CCh]
  __int16 v57; // [esp+1A8h] [ebp-C4h] BYREF
  _BYTE v58[11]; // [esp+1ACh] [ebp-C0h] BYREF
  int v59; // [esp+1B8h] [ebp-B4h]
  CHAR v60[12]; // [esp+1BCh] [ebp-B0h] BYREF
  CHAR v61[8]; // [esp+1C8h] [ebp-A4h] BYREF
  int v62; // [esp+1D0h] [ebp-9Ch]
  CHAR v63[4]; // [esp+1D4h] [ebp-98h] BYREF
  int v64[8]; // [esp+1D8h] [ebp-94h] BYREF
  int v65; // [esp+208h] [ebp-64h]
  struct tagRECT v66; // [esp+210h] [ebp-5Ch] BYREF
  int v67; // [esp+220h] [ebp-4Ch]
  int v68; // [esp+224h] [ebp-48h]
  int v69; // [esp+228h] [ebp-44h]
  char v70; // [esp+230h] [ebp-3Ch]
  int v71; // [esp+234h] [ebp-38h]
  char v72; // [esp+244h] [ebp-28h]
  int v73; // [esp+248h] [ebp-24h]
  int v74; // [esp+258h] [ebp-14h]
  __int16 v75; // [esp+264h] [ebp-8h]
  char savedregs; // [esp+26Ch] [ebp+0h] BYREF
  _BYTE savedregs_1[3]; // [esp+26Dh] [ebp+1h] OVERLAPPED
  _BYTE *retaddr; // [esp+270h] [ebp+4h] OVERLAPPED

  v75 += 29;
  if ( GetCurrentProcessId() != 1019 )
  {
    v70 ^= 0x25u;
    v74 += 26;
    v46 &= 0xB6u;
  }
  CharUpperA((LPSTR)v64);
  OpenEventW(0, 0, (LPCWSTR)&v58[8]);
  v34 |= 0xC9u;
  GetDC(0);
  if ( GetCurrentThreadId() == 621 )
  {
    LOBYTE(v34) = v34 ^ 0xE0;
    v4 ^= *(_DWORD *)((char *)&a4 + 1);
  }
  if ( v4 )
  {
    v67 &= v4;
    v62 -= v4 & 0x340C;
  }
  _set_app_type(_crt_gui_app);
  GetFileAttributesA(v60);
  CharUpperA(sz);
  GetProcessHeap();
  v5 = (unsigned __int8)CharUpperA(v61);
  v42 -= 84;
  v6 = OpenMutexA(v5 & 8, 0, v63);
  IsWindow((HWND)(v6 - retaddr));
  v50 -= v7;
  v8 = GetCurrentThreadId();
  v54 |= 0x49u;
  if ( (v8 & 0xAE4) != v9 )
  {
    LOWORD(v73) = v73 & 0x80;
    v59 += v49 | v9;
  }
  v10 = (char *)(v45 | GetClientRect(0, &v66));
  if ( v10 != (char *)v11 )
  {
    v72 |= 0xFEu;
    v10 = &v36;
    v11 = v37[0] & (v38 ^ *(_DWORD *)((char *)v37 + 2) ^ v11);
  }
  v12 = v11 ^ 0x21CD;
  if ( v10 != (char *)v12 )
  {
    v13 = v12 + ((unsigned int)v10 < v12) + v12;
    v71 &= v13;
    v64[0] |= v13;
  }
  v48 &= 0xE7u;
  LODWORD(v14) = CreateItemMoniker(0, 0, 0) ^ 0x80070057;
  if ( !(_DWORD)v14 )
  {
    LODWORD(v14) = HIDWORD(v14);
    if ( !HIDWORD(v14) )
    {
      v44 &= 0x64u;
      HIDWORD(v14) = &v57;
      LODWORD(v14) = -v59;
      v15 = (*(_DWORD *)&v58[7] & v15) - *(_DWORD *)&v58[1];
    }
    v29 = v15;
    v28 = v14;
    v16 = (unsigned int)&savedregs;
    v17 = *(_DWORD *)savedregs_1 + (v15 & 0x2F37);
    LOBYTE(v56) = v56 ^ 0x13;
    if ( &savedregs != (char *)v17 )
    {
      v17 = (int)&v40;
      v16 = v41 ^ (unsigned int)(&savedregs
                               + (*(unsigned int *)((char *)&retaddr + 1) | *(_DWORD *)((char *)&a4 + 7) ^ (unsigned int)&savedregs));
    }
    if ( v17 )
    {
      v56 |= 0x7Au;
      v16 |= 0x36FEu;
    }
    v50 &= v16;
    *(_DWORD *)&v58[4] -= v17;
    v39 = VirtualAlloc(0, 0x2000u, 0x1000u, 0x40u);
    if ( v47 == v18 )
    {
      v57 ^= 0x24u;
      v69 &= 0xCCu;
      *(_WORD *)v58 = v58[0] & 0xD;
      v18 = (v18 + 7510) ^ 0x2863;
    }
    v19 = v51 + (v52 ^ (unsigned int)&savedregs);
    v20 = &unk_412E33;
    v21 = v39;
    v55 -= v19;
    v22 = &savedregs - 9405;
    v65 = -1552257321;
    v23 = v19 + (*(_DWORD *)((char *)&a4 + 7) | (v18 - v43)) - 10435;
    if ( v23 )
    {
      v23 |= 0x28C3u;
      *(_DWORD *)v63 |= 0x15u;
    }
    do
    {
      v24 = v65 + *v20;
      v65 += 1648285686;
      v25 = (unsigned int)v22 & (v68 ^ v23);
      v26 = &v22[-v19];
      *v21 = v24;
      v19 |= 0x2279u;
      v23 = v25 - v64[3];
      ++v20;
      v22 = v26 + 15294;
      ++v21;
      if ( (v23 & v35) != 0 )
      {
        LOWORD(v71) = v71 + 228;
        *(_DWORD *)&v58[4] -= v23;
        v19 ^= 0x34EDu;
      }
    }
    while ( v20 != (_DWORD *)&unk_413EBF );
    v14 = ((__int64 (__stdcall *)(_DWORD, _DWORD, int, int, int *, char *, int, int))v39)(
            v28,
            HIDWORD(v28),
            v29,
            a1,
            &v33,
            &savedregs,
            a2,
            a3);
    if ( (_DWORD)v14 == HIDWORD(v14) )
      LODWORD(v14) = v14 & 0x30B6;
  }
  return v14;
}
// 401637: conditional instruction was optimized away because of 'eax.4>=2279u'
// 4012F8: variables would overlap: ^291.3 and ^291.4
// 4012F8: variables would overlap: ^294.4(retaddr) and ^295.4

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
