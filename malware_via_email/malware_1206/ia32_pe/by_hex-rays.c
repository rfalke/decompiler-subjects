/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __usercall start@<eax>(int@<ebx>, int@<edi>, int@<esi>, __int128);

//-------------------------------------------------------------------------
// Data declarations

// extern void (__cdecl *_set_app_type)(_crt_app_type Type);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HANDLE (__stdcall *OpenEventW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *IsWindow)(HWND hWnd);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern LPSTR (__stdcall *CharUpperA)(LPSTR lpsz);
// extern HRESULT (__stdcall *CreateItemMoniker)(LPCOLESTR lpszDelim, LPCOLESTR lpszItem, LPMONIKER *ppmk);
_UNKNOWN unk_412E33; // weak
_UNKNOWN unk_413EBF; // weak


//----- (004012F8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int128 a4)
{
  int v4; // ecx
  unsigned __int8 v5; // al
  _BYTE *v6; // eax
  int v7; // edx
  __int16 CurrentThreadId; // ax
  int v9; // ecx
  char *v10; // eax
  int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // edx
  __int64 v14; // rax
  int v15; // ecx
  unsigned int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // eax
  _DWORD *v20; // edi
  _DWORD *v21; // esi
  char *v22; // edx
  int v23; // ecx
  int v24; // ebx
  int v25; // ecx
  char *v26; // edx
  __int64 v28; // [esp-14h] [ebp-280h]
  int v29; // [esp-Ch] [ebp-278h]
  int v33; // [esp+Ch] [ebp-260h] BYREF
  int v34; // [esp+24h] [ebp-248h]
  int v35; // [esp+3Ch] [ebp-230h]
  char v36; // [esp+48h] [ebp-224h] BYREF
  _BYTE v37[15]; // [esp+49h] [ebp-223h]
  _DWORD *v38; // [esp+58h] [ebp-214h]
  char v39; // [esp+8Ch] [ebp-1E0h] BYREF
  int v40; // [esp+96h] [ebp-1D6h]
  __int16 v41; // [esp+A0h] [ebp-1CCh]
  int v42; // [esp+BCh] [ebp-1B0h]
  char v43; // [esp+C0h] [ebp-1ACh]
  int v44; // [esp+F0h] [ebp-17Ch]
  int v45; // [esp+118h] [ebp-154h]
  int v46; // [esp+11Ch] [ebp-150h]
  __int16 v47; // [esp+128h] [ebp-144h]
  int v48; // [esp+130h] [ebp-13Ch]
  int v49; // [esp+150h] [ebp-11Ch]
  int v50; // [esp+158h] [ebp-114h]
  int v51; // [esp+162h] [ebp-10Ah]
  char sz[12]; // [esp+188h] [ebp-E4h] BYREF
  int v53; // [esp+194h] [ebp-D8h]
  int v54; // [esp+19Ch] [ebp-D0h]
  int v55; // [esp+1A0h] [ebp-CCh]
  __int16 v56; // [esp+1A8h] [ebp-C4h] BYREF
  _BYTE v57[11]; // [esp+1ACh] [ebp-C0h] BYREF
  int v58; // [esp+1B8h] [ebp-B4h]
  char v59[12]; // [esp+1BCh] [ebp-B0h] BYREF
  char v60[8]; // [esp+1C8h] [ebp-A4h] BYREF
  int v61; // [esp+1D0h] [ebp-9Ch]
  CHAR v62[4]; // [esp+1D4h] [ebp-98h] BYREF
  int v63[8]; // [esp+1D8h] [ebp-94h] BYREF
  int v64; // [esp+208h] [ebp-64h]
  struct tagRECT v65; // [esp+210h] [ebp-5Ch] BYREF
  int v66; // [esp+220h] [ebp-4Ch]
  int v67; // [esp+224h] [ebp-48h]
  int v68; // [esp+228h] [ebp-44h]
  char v69; // [esp+230h] [ebp-3Ch]
  int v70; // [esp+234h] [ebp-38h]
  char v71; // [esp+244h] [ebp-28h]
  int v72; // [esp+248h] [ebp-24h]
  int v73; // [esp+258h] [ebp-14h]
  __int16 v74; // [esp+264h] [ebp-8h]
  char savedregs; // [esp+26Ch] [ebp+0h] BYREF
  _BYTE savedregs_1[3]; // [esp+26Dh] [ebp+1h] OVERLAPPED
  _BYTE *retaddr; // [esp+270h] [ebp+4h] OVERLAPPED

  v74 += 29;
  if ( GetCurrentProcessId() != 1019 )
  {
    v69 ^= 0x25u;
    v73 += 26;
    v45 &= 0xB6u;
  }
  CharUpperA((LPSTR)v63);
  OpenEventW(0, 0, (LPCWSTR)&v57[8]);
  v34 |= 0xC9u;
  GetDC(0);
  if ( GetCurrentThreadId() == 621 )
  {
    LOBYTE(v34) = v34 ^ 0xE0;
    v4 ^= *(_DWORD *)((char *)&a4 + 1);
  }
  if ( v4 )
  {
    v66 &= v4;
    v61 -= v4 & 0x340C;
  }
  _set_app_type(_crt_gui_app);
  GetFileAttributesA(v59);
  CharUpperA(sz);
  GetProcessHeap();
  v5 = (unsigned __int8)CharUpperA(v60);
  v41 -= 84;
  v6 = OpenMutexA(v5 & 8, 0, v62);
  IsWindow((HWND)(v6 - retaddr));
  v49 -= v7;
  CurrentThreadId = GetCurrentThreadId();
  v53 |= 0x49u;
  if ( (CurrentThreadId & 0xAE4) != v9 )
  {
    LOWORD(v72) = v72 & 0x80;
    v58 += v48 | v9;
  }
  v10 = (char *)(v44 | GetClientRect(0, &v65));
  if ( v10 != (char *)v11 )
  {
    v71 |= 0xFEu;
    v10 = &v36;
    v11 = *(_DWORD *)v37 & (*(_DWORD *)&v37[11] ^ *(_DWORD *)&v37[2] ^ v11);
  }
  v12 = v11 ^ 0x21CD;
  if ( v10 != (char *)v12 )
  {
    v13 = v12 + ((unsigned int)v10 < v12) + v12;
    v70 &= v13;
    v63[0] |= v13;
  }
  v47 &= 0xE7u;
  LODWORD(v14) = CreateItemMoniker(0, 0, 0) ^ 0x80070057;
  if ( !(_DWORD)v14 )
  {
    LODWORD(v14) = HIDWORD(v14);
    if ( !HIDWORD(v14) )
    {
      v43 &= 0x64u;
      HIDWORD(v14) = &v56;
      LODWORD(v14) = -v58;
      v15 = (*(_DWORD *)&v57[7] & v15) - *(_DWORD *)&v57[1];
    }
    v29 = v15;
    v28 = v14;
    v16 = (unsigned int)&savedregs;
    v17 = *(_DWORD *)savedregs_1 + (v15 & 0x2F37);
    LOBYTE(v55) = v55 ^ 0x13;
    if ( &savedregs != (char *)v17 )
    {
      v17 = (int)&v39;
      v16 = v40 ^ (unsigned int)&savedregs_1[(*(unsigned int *)((char *)&retaddr + 1) | *(_DWORD *)((char *)&a4 + 7) ^ (unsigned int)&savedregs)
                                           - 1];
    }
    if ( v17 )
    {
      v55 |= 0x7Au;
      v16 |= 0x36FEu;
    }
    v49 &= v16;
    *(_DWORD *)&v57[4] -= v17;
    v38 = VirtualAlloc(0, 0x2000u, 0x1000u, 0x40u);
    if ( v46 == v18 )
    {
      v56 ^= 0x24u;
      v68 &= 0xCCu;
      *(_WORD *)v57 = v57[0] & 0xD;
      v18 = (v18 + 7510) ^ 0x2863;
    }
    v19 = v50 + (v51 ^ (unsigned int)&savedregs);
    v20 = &unk_412E33;
    v21 = v38;
    v54 -= v19;
    v22 = &savedregs - 9405;
    v64 = -1552257321;
    v23 = v19 + (*(_DWORD *)((char *)&a4 + 7) | (v18 - v42)) - 10435;
    if ( v23 )
    {
      v23 |= 0x28C3u;
      *(_DWORD *)v62 |= 0x15u;
    }
    do
    {
      v24 = v64 + *v20;
      v64 += 1648285686;
      v25 = (unsigned int)v22 & (v67 ^ v23);
      v26 = &v22[-v19];
      *v21 = v24;
      v19 |= 0x2279u;
      v23 = v25 - v63[3];
      ++v20;
      v22 = v26 + 15294;
      ++v21;
      if ( (v23 & v35) != 0 )
      {
        LOWORD(v70) = v70 + 228;
        *(_DWORD *)&v57[4] -= v23;
        v19 ^= 0x34EDu;
      }
    }
    while ( v20 != (_DWORD *)&unk_413EBF );
    v14 = ((__int64 (__stdcall *)(_DWORD, _DWORD, int, int, int *, char *, int, int))v38)(
            v28,
            HIDWORD(v28),
            v29,
            a1,
            &v33,
            &savedregs,
            a2,
            a3);
    if ( (_DWORD)v14 == HIDWORD(v14) )
      LODWORD(v14) = v14 & 0x30B6;
  }
  return v14;
}
// 401637: conditional instruction was optimized away because eax.4>=2279u
// 4012F8: variables would overlap: ^291.3 and ^291.4
// 4012F8: variables would overlap: ^294.4(retaddr) and ^295.4
// 4012F8: using guessed type CHAR sz[12];
// 4012F8: using guessed type CHAR var_A4[8];
// 4012F8: using guessed type CHAR anonymous_5[12];

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
