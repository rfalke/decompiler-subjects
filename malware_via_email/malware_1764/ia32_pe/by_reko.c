// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t11674; // 00411000
<anonymous> * __imp__InterlockedIncrement = &g_t11686; // 00411004
<anonymous> * __imp__VirtualProtect = &g_t1169E; // 00411008
<anonymous> * __imp__QueryPerformanceCounter = &g_t116B0; // 0041100C
<anonymous> * __imp__GetProcessHeap = &g_t116CA; // 00411010
<anonymous> * __imp__GetModuleHandleW = &g_t116DC; // 00411014
<anonymous> * __imp__CreateFileW = &g_t116F0; // 00411018
<anonymous> * __imp__ReadFile = &g_t116FE; // 0041101C
<anonymous> * __imp__LocalFree = &g_t1170A; // 00411020
<anonymous> * __imp__HeapDestroy = &g_t11716; // 00411024
<anonymous> * __imp__VirtualProtect = &g_t11724; // 00411028
<anonymous> * __imp__HeapFree = &g_t11736; // 0041102C
<anonymous> * __imp__InitializeCriticalSection = &g_t11742; // 00411030
<anonymous> * __imp__VirtualAlloc = &g_t1175E; // 00411034
<anonymous> * __imp__LeaveCriticalSection = &g_t1176E; // 00411038
<anonymous> * __imp__InterlockedExchange = &g_t11786; // 0041103C
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t1179C; // 00411040
<anonymous> * __imp__LocalFree = &g_t117B8; // 00411044
<anonymous> * __imp__HeapDestroy = &g_t117C4; // 00411048
<anonymous> * __imp__VirtualProtect = &g_t117D2; // 0041104C
<anonymous> * __imp__GetModuleFileNameW = &g_t117E4; // 00411050
<anonymous> * __imp__FreeLibrary = &g_t117FA; // 00411054
<anonymous> * __imp__GetProcAddress = &g_t11808; // 00411058
<anonymous> * __imp__InterlockedCompareExchange = &g_t1181A; // 0041105C
<anonymous> * __imp__GetCurrentProcess = &g_t11838; // 00411060
<anonymous> * __imp__GetCurrentThreadId = &g_t1184C; // 00411064
<anonymous> * __imp__GetCurrentThreadId = &g_t11862; // 00411068
<anonymous> * __imp__HeapAlloc = &g_t11878; // 0041106C
<anonymous> * __imp__GetTickCount = &g_t11884; // 00411070
<anonymous> * __imp__UnhandledExceptionFilter = &g_t11894; // 00411074
<anonymous> * __imp__Sleep = &g_t118B0; // 00411078
<anonymous> * __imp__InterlockedIncrement = &g_t118B8; // 0041107C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t118D0; // 00411080
<anonymous> * __imp__HeapAlloc = &g_t118EA; // 00411084
<anonymous> * __imp__VirtualProtect = &g_t118F6; // 00411088
<anonymous> * __imp__ReadFile = &g_t11908; // 0041108C
<anonymous> * __imp__GetVersionExA = &g_t11914; // 00411090
<anonymous> * __imp__LocalAlloc = &g_t11924; // 00411094
<anonymous> * __imp__EnterCriticalSection = &g_t11932; // 00411098
<anonymous> * __imp__DeleteCriticalSection = &g_t1194A; // 0041109C
<anonymous> * __imp__HeapDestroy = &g_t11962; // 004110A0
<anonymous> * __imp__LoadLibraryA = &g_t11970; // 004110A4
<anonymous> * __imp__SetLastError = &g_t11980; // 004110A8
<anonymous> * __imp__GetProcAddress = &g_t11990; // 004110AC
<anonymous> * __imp__GetModuleHandleA = &g_t119A2; // 004110B0
<anonymous> * __imp__CreateFileW = &g_t119B6; // 004110B4
<anonymous> * __imp__GetProcessHeap = &g_t119C4; // 004110B8
<anonymous> * __imp__LeaveCriticalSection = &g_t119D6; // 004110BC
<anonymous> * __imp__MultiByteToWideChar = &g_t119EE; // 004110C0
<anonymous> * __imp__lstrcmpiW = &g_t11A04; // 004110C4
<anonymous> * __imp__Sleep = &g_t11A10; // 004110C8
<anonymous> * __imp__DeleteCriticalSection = &g_t11A18; // 004110CC
<anonymous> * __imp__InterlockedIncrement = &g_t11A30; // 004110D0
<anonymous> * __imp__InterlockedDecrement = &g_t11A48; // 004110D4
<anonymous> * __imp__InitializeCriticalSection = &g_t11A60; // 004110D8
<anonymous> * __imp__GetModuleHandleW = &g_t11A7C; // 004110DC
<anonymous> * __imp__InterlockedCompareExchange = &g_t11A90; // 004110E0
<anonymous> * __imp__GetVersionExA = &g_t11AAE; // 004110E4
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t11ABE; // 004110E8
<anonymous> * __imp__CloseHandle = &g_t11ADA; // 004110EC
<anonymous> * __imp__CreateEventW = &g_t11AE8; // 004110F0
<anonymous> * __imp__HeapAlloc = &g_t11AF8; // 004110F4
<anonymous> * __imp__LeaveCriticalSection = &g_t11B04; // 004110F8
<anonymous> * __imp__StretchBlt = &g_t11B2A; // 00411100
<anonymous> * __imp__CreateDIBSection = &g_t11B38; // 00411104
<anonymous> * __imp__MoveToEx = &g_t11B4C; // 00411108
<anonymous> * __imp__RoundRect = &g_t11B58; // 0041110C
<anonymous> * __imp__GetWindowOrgEx = &g_t11B64; // 00411110
<anonymous> * __imp__GetWindowOrgEx = &g_t11B76; // 00411114
<anonymous> * __imp__GetBrushOrgEx = &g_t11B88; // 00411118
<anonymous> * __imp__CreateBitmap = &g_t11B98; // 0041111C
<anonymous> * __imp__CombineRgn = &g_t11BA8; // 00411120
<anonymous> * __imp__GetBrushOrgEx = &g_t11BB6; // 00411124
<anonymous> * __imp__CombineRgn = &g_t11BC6; // 00411128
<anonymous> * __imp__BitBlt = &g_t11BD4; // 0041112C
<anonymous> * __imp__CreateRectRgn = &g_t11BDE; // 00411130
<anonymous> * __imp__CreatePen = &g_t11BEE; // 00411134
<anonymous> * __imp__SelectObject = &g_t11BFA; // 00411138
<anonymous> * __imp__GetPixel = &g_t11C0A; // 0041113C
<anonymous> * __imp__GetBkColor = &g_t11C16; // 00411140
<anonymous> * __imp__GetCurrentObject = &g_t11C24; // 00411144
<anonymous> * __imp__GetCurrentObject = &g_t11C38; // 00411148
<anonymous> * __imp__CreateCompatibleDC = &g_t11C4C; // 0041114C
<anonymous> * __imp__SelectObject = &g_t11C62; // 00411150
<anonymous> * __imp__SetTextColor = &g_t11C72; // 00411154
<anonymous> * __imp__BitBlt = &g_t11C82; // 00411158
<anonymous> * __imp__CreatePen = &g_t11C8C; // 0041115C
<anonymous> * __imp__Polygon = &g_t11C98; // 00411160
<anonymous> * __imp__CreateDIBSection = &g_t11CA2; // 00411164
<anonymous> * __imp__CreateRectRgn = &g_t11CB6; // 00411168
<anonymous> * __imp__MoveToEx = &g_t11CC6; // 0041116C
<anonymous> * __imp__SetBkColor = &g_t11CD2; // 00411170
<anonymous> * __imp__GetWindowOrgEx = &g_t11CE0; // 00411174
<anonymous> * __imp__SetBkColor = &g_t11CF2; // 00411178
<anonymous> * __imp__PatBlt = &g_t11D00; // 0041117C
<anonymous> * __imp__CreateCompatibleDC = &g_t11D0A; // 00411180
<anonymous> * __imp__GetWindowExtEx = &g_t11D20; // 00411184
<anonymous> * __imp__SetWindowExtEx = &g_t11D32; // 00411188
<anonymous> * __imp__CreateSolidBrush = &g_t11D44; // 0041118C
<anonymous> * __imp__CreateCompatibleDC = &g_t11D58; // 00411190
<anonymous> * __imp__CreateFontIndirectA = &g_t11D6E; // 00411194
<anonymous> * __imp__LineTo = &g_t11D84; // 00411198
<anonymous> * __imp__GetPixel = &g_t11D8E; // 0041119C
<anonymous> * __imp__CombineRgn = &g_t11D9A; // 004111A0
<anonymous> * __imp__SetWindowOrgEx = &g_t11DA8; // 004111A4
<anonymous> * __imp__CreateBitmapIndirect = &g_t11DBA; // 004111A8
<anonymous> * __imp__Polygon = &g_t11DD2; // 004111AC
<anonymous> * __imp__SetBkColor = &g_t11DDC; // 004111B0
<anonymous> * __imp__GetBrushOrgEx = &g_t11DEA; // 004111B4
<anonymous> * __imp__StretchBlt = &g_t11DFA; // 004111B8
<anonymous> * __imp__StretchBlt = &g_t11E08; // 004111BC
<anonymous> * __imp__PatBlt = &g_t11E16; // 004111C0
<anonymous> * __imp__CreateDIBitmap = &g_t11E20; // 004111C4
<anonymous> * __imp__CreateRectRgn = &g_t11E32; // 004111C8
<anonymous> * __imp__StretchBlt = &g_t11E42; // 004111CC
<anonymous> * __imp__CreateFontIndirectA = &g_t11E50; // 004111D0
<anonymous> * __imp__SetBkMode = &g_t11E66; // 004111D4
<anonymous> * __imp__SetWindowOrgEx = &g_t11E72; // 004111D8
<anonymous> * __imp__SetBrushOrgEx = &g_t11E84; // 004111DC
<anonymous> * __imp__CreateBitmap = &g_t11E94; // 004111E0
<anonymous> * __imp__StretchBlt = &g_t11EA4; // 004111E4
<anonymous> * __imp__BitBlt = &g_t11EB2; // 004111E8
<anonymous> * __imp__SetTextColor = &g_t11EBC; // 004111EC
<anonymous> * __imp__DispatchMessageW = &g_t11ED6; // 004111F4
<anonymous> * __imp__GetDesktopWindow = &g_t11EEA; // 004111F8
<anonymous> * __imp__DispatchMessageW = &g_t11EFE; // 004111FC
<anonymous> * __imp__PostMessageW = &g_t11F12; // 00411200
<anonymous> * __imp__SendMessageW = &g_t11F22; // 00411204
<anonymous> * __imp__wsprintfA = &g_t11F32; // 00411208
<anonymous> * __imp__GetParent = &g_t11F3E; // 0041120C
<anonymous> * __imp__GetDC = &g_t11F4A; // 00411210
<anonymous> * __imp__CharNextW = &g_t11F52; // 00411214
<anonymous> * __imp__IsWindow = &g_t11F5E; // 00411218
<anonymous> * __imp__IsWindow = &g_t11F6A; // 0041121C
<anonymous> * __imp__KillTimer = &g_t11F76; // 00411220
<anonymous> * __imp__CharNextW = &g_t11F82; // 00411224
<anonymous> * __imp__DefWindowProcW = &g_t11F8E; // 00411228
<anonymous> * __imp__GetWindowRect = &g_t11FA0; // 0041122C
<anonymous> * __imp__PeekMessageW = &g_t11FB0; // 00411230
<anonymous> * __imp__GetSysColor = &g_t11FC0; // 00411234
<anonymous> * __imp__SendDlgItemMessageW = &g_t11FCE; // 00411238
<anonymous> * __imp__CreateWindowExW = &g_t11FE4; // 0041123C
<anonymous> * __imp__TranslateMessage = &g_t11FF6; // 00411240
<anonymous> * __imp__SetDlgItemTextW = &g_t1200A; // 00411244
<anonymous> * __imp__ReleaseDC = &g_t1201C; // 00411248
<anonymous> * __imp__GetParent = &g_t12028; // 0041124C
<anonymous> * __imp__GetParent = &g_t12034; // 00411250
<anonymous> * __imp__EndDialog = &g_t12040; // 00411254
<anonymous> * __imp__ReleaseDC = &g_t1204C; // 00411258
<anonymous> * __imp__PostMessageW = &g_t12058; // 0041125C
<anonymous> * __imp__DestroyWindow = &g_t12068; // 00411260
<anonymous> * __imp__LoadStringW = &g_t12078; // 00411264
<anonymous> * __imp__GetSystemMetrics = &g_t12086; // 00411268
<anonymous> * __imp__KillTimer = &g_t1209A; // 0041126C
<anonymous> * __imp__InvalidateRect = &g_t120A6; // 00411270
<anonymous> * __imp__DialogBoxParamW = &g_t120B8; // 00411274
<anonymous> * __imp__DefWindowProcW = &g_t120CA; // 00411278
<anonymous> * __imp__SetWindowTextW = &g_t120DC; // 0041127C
<anonymous> * __imp__IsDlgButtonChecked = &g_t120EE; // 00411280
<anonymous> * __imp__LoadCursorW = &g_t12104; // 00411284
<anonymous> * __imp__wsprintfA = &g_t12112; // 00411288
<anonymous> * __imp__SetForegroundWindow = &g_t1211E; // 0041128C
<anonymous> * __imp__EndDialog = &g_t12134; // 00411290
<anonymous> * __imp__SetTimer = &g_t12140; // 00411294
<anonymous> * __imp__DefWindowProcW = &g_t1214C; // 00411298
<anonymous> * __imp__BeginPaint = &g_t1215E; // 0041129C
<anonymous> * __imp__EndDialog = &g_t1216C; // 004112A0
<anonymous> * __imp__BeginPaint = &g_t12178; // 004112A4
<anonymous> * __imp__DestroyWindow = &g_t12186; // 004112A8
<anonymous> * __imp__GetWindowLongW = &g_t12196; // 004112AC
<anonymous> * __imp__SetForegroundWindow = &g_t121A8; // 004112B0
<anonymous> * __imp__SetTimer = &g_t121BE; // 004112B4
<anonymous> * __imp__PostQuitMessage = &g_t121CA; // 004112B8
<anonymous> * __imp__IsWindow = &g_t121DC; // 004112BC
<anonymous> * __imp__EndDialog = &g_t121E8; // 004112C0
<anonymous> * __imp__GetSysColor = &g_t121F4; // 004112C4
<anonymous> * __imp__GetParent = &g_t12202; // 004112C8
<anonymous> * __imp__DestroyWindow = &g_t1220E; // 004112CC
<anonymous> * __imp__SetWindowTextW = &g_t1221E; // 004112D0
<anonymous> * __imp__wsprintfA = &g_t12230; // 004112D4
<anonymous> * __imp__PeekMessageW = &g_t1223C; // 004112D8
<anonymous> * __imp__LoadIconW = &g_t1224C; // 004112DC
<anonymous> * __imp__DestroyWindow = &g_t12258; // 004112E0
<anonymous> * __imp__IsDlgButtonChecked = &g_t12268; // 004112E4
<anonymous> * __imp__DispatchMessageW = &g_t1227E; // 004112E8
<anonymous> * __imp__ReleaseDC = &g_t12292; // 004112EC
<anonymous> * __imp__PeekMessageW = &g_t1229E; // 004112F0
<anonymous> * __imp__GetFocus = &g_t122AE; // 004112F4
<anonymous> * __imp__PostMessageW = &g_t122BA; // 004112F8
<anonymous> * __imp__GetSysColor = &g_t122CA; // 004112FC
<anonymous> * __imp__EndDialog = &g_t122D8; // 00411300
<anonymous> * __imp__SetTimer = &g_t122E4; // 00411304
<anonymous> * __imp__CreateWindowExW = &g_t122F0; // 00411308
word32 g_dw411364 = 0x00011674; // 00411364
word32 g_dw411368 = 0x00011686; // 00411368
word32 g_dw41136C = 0x0001169E; // 0041136C
word32 g_dw411370 = 0x000116B0; // 00411370
word32 g_dw411374 = 0x000116CA; // 00411374
word32 g_dw411378 = 0x000116DC; // 00411378
word32 g_dw41137C = 0x000116F0; // 0041137C
word32 g_dw411380 = 0x000116FE; // 00411380
word32 g_dw411384 = 0x0001170A; // 00411384
word32 g_dw411388 = 0x00011716; // 00411388
word32 g_dw41138C = 0x00011724; // 0041138C
word32 g_dw411390 = 0x00011736; // 00411390
word32 g_dw411394 = 0x00011742; // 00411394
word32 g_dw411398 = 0x0001175E; // 00411398
word32 g_dw41139C = 0x0001176E; // 0041139C
word32 g_dw4113A0 = 0x00011786; // 004113A0
word32 g_dw4113A4 = 0x0001179C; // 004113A4
word32 g_dw4113A8 = 0x000117B8; // 004113A8
word32 g_dw4113AC = 0x000117C4; // 004113AC
word32 g_dw4113B0 = 0x000117D2; // 004113B0
word32 g_dw4113B4 = 0x000117E4; // 004113B4
word32 g_dw4113B8 = 0x000117FA; // 004113B8
word32 g_dw4113BC = 0x00011808; // 004113BC
word32 g_dw4113C0 = 0x0001181A; // 004113C0
word32 g_dw4113C4 = 0x00011838; // 004113C4
word32 g_dw4113C8 = 0x0001184C; // 004113C8
word32 g_dw4113CC = 71778; // 004113CC
word32 g_dw4113D0 = 0x00011878; // 004113D0
word32 g_dw4113D4 = 0x00011884; // 004113D4
word32 g_dw4113D8 = 0x00011894; // 004113D8
word32 g_dw4113DC = 0x000118B0; // 004113DC
word32 g_dw4113E0 = 0x000118B8; // 004113E0
word32 g_dw4113E4 = 71888; // 004113E4
word32 g_dw4113E8 = 0x000118EA; // 004113E8
word32 g_dw4113EC = 0x000118F6; // 004113EC
word32 g_dw4113F0 = 0x00011908; // 004113F0
word32 g_dw4113F4 = 0x00011914; // 004113F4
word32 g_dw4113F8 = 0x00011924; // 004113F8
word32 g_dw4113FC = 0x00011932; // 004113FC
word32 g_dw411400 = 0x0001194A; // 00411400
word32 g_dw411404 = 0x00011962; // 00411404
word32 g_dw411408 = 0x00011970; // 00411408
word32 g_dw41140C = 0x00011980; // 0041140C
word32 g_dw411410 = 0x00011990; // 00411410
word32 g_dw411414 = 0x000119A2; // 00411414
word32 g_dw411418 = 0x000119B6; // 00411418
word32 g_dw41141C = 0x000119C4; // 0041141C
word32 g_dw411420 = 0x000119D6; // 00411420
word32 g_dw411424 = 0x000119EE; // 00411424
word32 g_dw411428 = 0x00011A04; // 00411428
word32 g_dw41142C = 0x00011A10; // 0041142C
word32 g_dw411430 = 0x00011A18; // 00411430
word32 g_dw411434 = 0x00011A30; // 00411434
word32 g_dw411438 = 0x00011A48; // 00411438
word32 g_dw41143C = 72288; // 0041143C
word32 g_dw411440 = 0x00011A7C; // 00411440
word32 g_dw411444 = 0x00011A90; // 00411444
word32 g_dw411448 = 0x00011AAE; // 00411448
word32 g_dw41144C = 0x00011ABE; // 0041144C
word32 g_dw411450 = 0x00011ADA; // 00411450
word32 g_dw411454 = 72424; // 00411454
word32 g_dw411458 = 0x00011AF8; // 00411458
word32 g_dw41145C = 0x00011B04; // 0041145C
word32 g_dw411464 = 0x00011B2A; // 00411464
word32 g_dw411468 = 0x00011B38; // 00411468
word32 g_dw41146C = 0x00011B4C; // 0041146C
word32 g_dw411470 = 0x00011B58; // 00411470
word32 g_dw411474 = 0x00011B64; // 00411474
word32 g_dw411478 = 0x00011B76; // 00411478
word32 g_dw41147C = 0x00011B88; // 0041147C
word32 g_dw411480 = 0x00011B98; // 00411480
word32 g_dw411484 = 0x00011BA8; // 00411484
word32 g_dw411488 = 0x00011BB6; // 00411488
word32 g_dw41148C = 0x00011BC6; // 0041148C
word32 g_dw411490 = 0x00011BD4; // 00411490
word32 g_dw411494 = 0x00011BDE; // 00411494
word32 g_dw411498 = 0x00011BEE; // 00411498
word32 g_dw41149C = 0x00011BFA; // 0041149C
word32 g_dw4114A0 = 0x00011C0A; // 004114A0
word32 g_dw4114A4 = 0x00011C16; // 004114A4
word32 g_dw4114A8 = 0x00011C24; // 004114A8
word32 g_dw4114AC = 0x00011C38; // 004114AC
word32 g_dw4114B0 = 0x00011C4C; // 004114B0
word32 g_dw4114B4 = 0x00011C62; // 004114B4
word32 g_dw4114B8 = 0x00011C72; // 004114B8
word32 g_dw4114BC = 0x00011C82; // 004114BC
word32 g_dw4114C0 = 0x00011C8C; // 004114C0
word32 g_dw4114C4 = 0x00011C98; // 004114C4
word32 g_dw4114C8 = 0x00011CA2; // 004114C8
word32 g_dw4114CC = 0x00011CB6; // 004114CC
word32 g_dw4114D0 = 0x00011CC6; // 004114D0
word32 g_dw4114D4 = 0x00011CD2; // 004114D4
word32 g_dw4114D8 = 0x00011CE0; // 004114D8
word32 g_dw4114DC = 0x00011CF2; // 004114DC
word32 g_dw4114E0 = 0x00011D00; // 004114E0
word32 g_dw4114E4 = 0x00011D0A; // 004114E4
word32 g_dw4114E8 = 72992; // 004114E8
word32 g_dw4114EC = 0x00011D32; // 004114EC
word32 g_dw4114F0 = 0x00011D44; // 004114F0
word32 g_dw4114F4 = 0x00011D58; // 004114F4
word32 g_dw4114F8 = 73070; // 004114F8
word32 g_dw4114FC = 0x00011D84; // 004114FC
word32 g_dw411500 = 0x00011D8E; // 00411500
word32 g_dw411504 = 0x00011D9A; // 00411504
word32 g_dw411508 = 0x00011DA8; // 00411508
word32 g_dw41150C = 0x00011DBA; // 0041150C
word32 g_dw411510 = 0x00011DD2; // 00411510
word32 g_dw411514 = 0x00011DDC; // 00411514
word32 g_dw411518 = 0x00011DEA; // 00411518
word32 g_dw41151C = 0x00011DFA; // 0041151C
word32 g_dw411520 = 0x00011E08; // 00411520
word32 g_dw411524 = 0x00011E16; // 00411524
word32 g_dw411528 = 0x00011E20; // 00411528
word32 g_dw41152C = 0x00011E32; // 0041152C
word32 g_dw411530 = 0x00011E42; // 00411530
word32 g_dw411534 = 0x00011E50; // 00411534
word32 g_dw411538 = 0x00011E66; // 00411538
word32 g_dw41153C = 73330; // 0041153C
word32 g_dw411540 = 0x00011E84; // 00411540
word32 g_dw411544 = 0x00011E94; // 00411544
word32 g_dw411548 = 0x00011EA4; // 00411548
word32 g_dw41154C = 0x00011EB2; // 0041154C
word32 g_dw411550 = 0x00011EBC; // 00411550
word32 g_dw411558 = 0x00011ED6; // 00411558
word32 g_dw41155C = 0x00011EEA; // 0041155C
word32 g_dw411560 = 0x00011EFE; // 00411560
word32 g_dw411564 = 0x00011F12; // 00411564
word32 g_dw411568 = 0x00011F22; // 00411568
word32 g_dw41156C = 0x00011F32; // 0041156C
word32 g_dw411570 = 0x00011F3E; // 00411570
word32 g_dw411574 = 0x00011F4A; // 00411574
word32 g_dw411578 = 0x00011F52; // 00411578
word32 g_dw41157C = 0x00011F5E; // 0041157C
word32 g_dw411580 = 0x00011F6A; // 00411580
word32 g_dw411584 = 0x00011F76; // 00411584
word32 g_dw411588 = 0x00011F82; // 00411588
word32 g_dw41158C = 0x00011F8E; // 0041158C
word32 g_dw411590 = 0x00011FA0; // 00411590
word32 g_dw411594 = 0x00011FB0; // 00411594
word32 g_dw411598 = 0x00011FC0; // 00411598
word32 g_dw41159C = 0x00011FCE; // 0041159C
word32 g_dw4115A0 = 73700; // 004115A0
word32 g_dw4115A4 = 0x00011FF6; // 004115A4
word32 g_dw4115A8 = 73738; // 004115A8
word32 g_dw4115AC = 0x0001201C; // 004115AC
word32 g_dw4115B0 = 0x00012028; // 004115B0
word32 g_dw4115B4 = 73780; // 004115B4
word32 g_dw4115B8 = 0x00012040; // 004115B8
word32 g_dw4115BC = 0x0001204C; // 004115BC
word32 g_dw4115C0 = 0x00012058; // 004115C0
word32 g_dw4115C4 = 73832; // 004115C4
word32 g_dw4115C8 = 73848; // 004115C8
word32 g_dw4115CC = 0x00012086; // 004115CC
word32 g_dw4115D0 = 73882; // 004115D0
word32 g_dw4115D4 = 0x000120A6; // 004115D4
word32 g_dw4115D8 = 0x000120B8; // 004115D8
word32 g_dw4115DC = 73930; // 004115DC
word32 g_dw4115E0 = 0x000120DC; // 004115E0
word32 g_dw4115E4 = 0x000120EE; // 004115E4
word32 g_dw4115E8 = 0x00012104; // 004115E8
word32 g_dw4115EC = 0x00012112; // 004115EC
word32 g_dw4115F0 = 0x0001211E; // 004115F0
word32 g_dw4115F4 = 0x00012134; // 004115F4
word32 g_dw4115F8 = 0x00012140; // 004115F8
word32 g_dw4115FC = 0x0001214C; // 004115FC
word32 g_dw411600 = 0x0001215E; // 00411600
word32 g_dw411604 = 0x0001216C; // 00411604
word32 g_dw411608 = 0x00012178; // 00411608
word32 g_dw41160C = 0x00012186; // 0041160C
word32 g_dw411610 = 0x00012196; // 00411610
word32 g_dw411614 = 0x000121A8; // 00411614
word32 g_dw411618 = 74174; // 00411618
word32 g_dw41161C = 0x000121CA; // 0041161C
word32 g_dw411620 = 0x000121DC; // 00411620
word32 g_dw411624 = 0x000121E8; // 00411624
word32 g_dw411628 = 0x000121F4; // 00411628
word32 g_dw41162C = 0x00012202; // 0041162C
word32 g_dw411630 = 0x0001220E; // 00411630
word32 g_dw411634 = 0x0001221E; // 00411634
word32 g_dw411638 = 0x00012230; // 00411638
word32 g_dw41163C = 0x0001223C; // 0041163C
word32 g_dw411640 = 0x0001224C; // 00411640
word32 g_dw411644 = 0x00012258; // 00411644
word32 g_dw411648 = 74344; // 00411648
word32 g_dw41164C = 0x0001227E; // 0041164C
word32 g_dw411650 = 0x00012292; // 00411650
word32 g_dw411654 = 0x0001229E; // 00411654
word32 g_dw411658 = 74414; // 00411658
word32 g_dw41165C = 0x000122BA; // 0041165C
word32 g_dw411660 = 74442; // 00411660
word32 g_dw411664 = 0x000122D8; // 00411664
word32 g_dw411668 = 0x000122E4; // 00411668
word32 g_dw41166C = 0x000122F0; // 0041166C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040C2DB: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
	v5 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	bh &= 99;
	C.u0 = false;
	v11 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rcl<word32,byte>(ecx, cl, C);
	&ch.u3->u0 = (byte) ch + 52;
	eax >>= cl;
	edi >>= cl;
	ah -= dl;
	&SCZO.u3->u0 = cond(ah);
	ah = ah ^ ch;
	SZ = cond(ah);
	O = false;
	C.u0 = false;
	while (true)
	{
		&al.u3->u0 = (byte) al.u0 + 1;
		al &= ch;
		C.u0 = false;
		ch = ch - ah - C;
		edi <<= cl;
		&SCZO.u3->u0 = cond(edi);
		ecx.u0 = 2412389734;
		dh = dh + bh + C;
		&SCZO.u3->u0 = cond(dh);
		ebx = ebx + esi + C;
		&SCZO.u3->u0 = cond(ebx);
		if (Test(LE,SZO))
			break;
		edx = edx;
		ebx = ebx;
		if (Test(GT,SZO))
			break;
		if (Test(OV,O))
			__syscall<byte>(0x04);
		v30 = ebx.u6->bC780F7D3 | al;
		ebx.u6->bC780F7D3 = v30;
		SZ = cond(ebx.u6->bC780F7D3);
		__out<word32>(dx, eax);
		v32 = (ecx & 0x01 << cl) != 0x00;
		ecx = __ror<word32,byte>(ecx, cl);
		bh |= bl;
		bh &= dl;
		C.u0 = false;
		ch = ch + dl + C;
		&SCZO.u3->u0 = cond(ch);
		cl >>= cl;
		esi += ebx;
		ebx = ebx ^ ecx;
		SZ = cond(ebx);
		O = false;
		C.u0 = false;
l0040BFD9:
		ecx -= ebx;
		&SCZO.u3->u0 = cond(ecx);
		bh = bh - ~0x4C - C;
		esi += edi;
		&bl.u3->u0 = (byte) bl.u0 + 1;
		bh &= 0xC5;
		SZ = cond(bh);
		O = false;
		C.u0 = false;
		ch &= dl;
		C.u0 = false;
		cl = cl - 0x25 - C;
		edi = edi ^ esi;
		edi <<= cl;
		edi += ecx;
		ebx -= eax;
		cl |= ch;
		ecx <<= cl;
		&SCZO.u3->u0 = cond(ecx);
		ecx >>= cl;
		SCZ = cond(ecx);
		edi = edx;
l0040C588:
		esi &= edx;
		ch += bl;
		&SCZO.u3->u0 = cond(ch);
		&ch.u3->u0 = (bool) C.u0 + ((byte) ch.u0 + 97);
		++edi;
		v39 = (cl & 0x01 << cl) != 0x00;
		cl = __ror<byte,byte>(cl, cl);
		eax = gs;
		edi -= eax;
		--cl;
		ch <<= cl;
		&SCZO.u3->u0 = cond(ch);
		bh = bh - dh - C;
		bl >>= cl;
		&SCZO.u3->u0 = cond(bl);
		edi = eax;
		if (Test(LT,SO))
		{
l0040C78A:
			esi = esi - ecx - C;
			&SCZO.u3->u0 = cond(esi);
			v134 = (bl & 0x01 << 0x08 - cl) != 0x00;
			bl = __rcl<byte,byte>(bl, cl, C);
			C = v134;
			bl = bl - ch - C;
			ebx &= ecx;
			edi &= ebx;
			bl <<= cl;
			edi >>= cl;
			&cl.u3->u0 = (byte) cl + 0x00AD;
			bl |= 0xD2;
			C.u0 = false;
			edi = edi + edx + C;
			cl <<= cl;
			bl -= 0x67;
			edi -= edx;
			&SCZO.u3->u0 = cond(edi);
			v135 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v135;
			bh.u0 = 0x5A;
			v136 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v136;
			bl = bl - ~0x46 - C;
			&SCZO.u3->u0 = cond(bl);
			cl = bl;
			v137 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rcl<byte,byte>(bh, cl, C);
			C = v137;
			++edx;
			v138 = (cl & 0x01 << cl) != 0x00;
			cl = __rcr<byte,byte>(cl, cl, C);
			ebx += ecx;
			&SCZO.u3->u0 = cond(ebx);
			ebx >>= cl;
			SCZ = cond(ebx);
			if (Test(LE,SZO))
			{
l0040C4F8:
				bl -= ch;
				&SCZO.u3->u0 = cond(bl);
				bl = bl - al - C;
				&cl.u3->u0 = (byte) cl + 0x0078;
				ecx = ecx ^ eax;
				C.u0 = false;
				ch = ch + al + C;
				edi <<= cl;
				&SCZO.u3->u0 = cond(edi);
l0040C211:
				bl = bl - ch - C;
				bl &= dl;
				C.u0 = false;
				v95 = (ecx & 0x01 << 0x20 - cl) != 0x00;
				ecx = __rcl<word32,byte>(ecx, cl, C);
				ecx <<= cl;
				--esi;
				v96 = (ch & 0x01 << cl) != 0x00;
				ch = __ror<byte,byte>(ch, cl);
				ch = ah;
				v97 = (bl & 0x01 << 0x08 - cl) != 0x00;
				bl = __rol<byte,byte>(bl, cl);
				cl += bh;
				&SCZO.u3->u0 = cond(edx - 20072747);
				if (Test(EQ,Z))
				{
					dl = dl - bl - C;
					&SCZO.u3->u0 = cond(dl);
					bl.u0 = 0x4A;
					v98 = (eax & 0x01 << 0x20 - cl) != 0x00;
					eax = __rol<word32,byte>(eax, cl);
					ebx >>= cl;
					ebx -= edx;
					&SCZO.u3->u0 = cond(ebx);
					v99 = (dh & 0x01 << 0x08 - cl) != 0x00;
					dh = __rcl<byte,byte>(dh, cl, C);
					v100 = (esi & 0x01 << 0x20 - cl) != 0x00;
					esi = __rol<word32,byte>(esi, cl);
					C = v100;
					return;
				}
				--bh;
				esi >>= cl;
				ch &= cl;
				cl = cl ^ 0x7B;
				C.u0 = false;
				ebx = ebx - edx - C;
				&SCZO.u3->u0 = cond(ebx);
				bl += bh;
				&SCZO.u3->u0 = cond(bl);
				v102 = (edi & 0x01 << cl) != 0x00;
				edi = __rcr<word32,byte>(edi, cl, C);
				C = v102;
l0040C563:
				&ch.u3->u0 = (byte) ch + 1;
				v103 = (cl & 0x01 << cl) != 0x00;
				cl = __rcr<byte,byte>(cl, cl, C);
				edi += ecx;
				bl |= ah;
				C.u0 = false;
				&cl.u3->u0 = (byte) cl + 1;
				esi = esi + ebx + C;
				edi &= edx;
				SZ = cond(edi);
				O = false;
				C.u0 = false;
				if (Test(GE,SO))
				{
					edx = edx;
					ebx = ebx;
					if (Test(LT,SO))
					{
						al = *((word32) ebx + (uint32) al);
						edi = edi - ((ebx.u6)->tFA8B3766).u0 - C;
						&SCZO.u3->u0 = cond(edi);
						goto l0040C588;
					}
				}
				v108 = (eax & 0x01 << 0x01) != 0x00;
				eax = __ror<word32,byte>(eax, 0x01);
				C = v108;
				if (Test(UGE,C))
				{
					bh <<= cl;
					&SCZO.u3->u0 = cond(bh);
					v109 = (edi & 0x01 << 0x20 - cl) != 0x00;
					edi = __rcl<word32,byte>(edi, cl, C);
					--ebx;
					ebx = ebx ^ eax;
					SZ = cond(ebx);
					O = false;
					C.u0 = false;
					if (Test(NO,O))
					{
						edx = edx;
						ebx = ebx;
						if (Test(OV,O))
						{
							if (Test(OV,O))
							{
								__out<byte>(0x80, al);
								goto l0040C3CE;
							}
l0040C364:
							bl <<= cl;
							bl &= 0x6A;
							esi <<= cl;
							&SCZO.u3->u0 = cond(edx - (struct Eq_1110 *) ~0x00);
							if (Test(NE,Z))
								al.u0 = edx.u6->tFFFFFFFF.u0;
							else
								al.u0 = 0x2E;
l0040C494:
							v91 = Mem0[eax + 0x00:byte] + al;
							*eax.u0 = v91;
							&SCZO.u3->u0 = cond(v91);
							v92 = (*edi & 0x01 << 0x84) != 0x00;
							*edi = __ror<byte,byte>(*edi, 0x84);
							C = v92;
							&eax.u3->u0 = (int32) ax;
							D = false;
						}
					}
					esi <<= cl;
					&SCZO.u3->u0 = cond(esi);
					v115 = (esi & 0x01 << cl) != 0x00;
					esi = __rcr<word32,byte>(esi, cl, C);
					C = v115;
					v116 = (esi & 0x01 << 0x20 - cl) != 0x00;
					esi = __rcl<word32,byte>(esi, cl, C);
					cl &= al;
					bl = bl ^ 44;
					v117 = (ecx & 0x01 << 0x20 - cl) != 0x00;
					ecx = __rol<word32,byte>(ecx, cl);
					edi &= ecx;
					bh >>= cl;
					cl >>= cl;
					bl <<= cl;
					cl = cl ^ 0x7E;
					SZ = cond(cl);
					O = false;
					C.u0 = false;
					if (Test(GT,SZO))
					{
						edx = edx;
						ebx = ebx;
						if (Test(LE,SZO))
							;
					}
					ecx = ecx + eax + C;
					bl += al;
					&SCZO.u3->u0 = cond(bl);
					bl = bl - dl - C;
					edi |= ebx;
					v120 = (bl & 0x01 << 0x08 - cl) != 0x00;
					bl = __rol<byte,byte>(bl, cl);
					C = v120;
					&bh.u3->u0 = (byte) bh + 1;
					--bh;
					SZO = cond(bh);
					fn0040DA5B();
					if (Test(LT,SO))
					{
						esp -= (struct Eq_1999 *) 4;
						*esp = esi;
						al &= dl;
						SZ = cond(al);
						O = false;
						C.u0 = false;
						al = *(union Eq_3 *) ~0x5B6644C9;
					}
					v129 = ebx.u6->dwBB9330A0 & eax;
					ebx.u6->dwBB9330A0 = v129;
					SZ = cond(ebx.u6->dwBB9330A0);
					edx_eax = (int64) eax;
					v130 = *esi;
					*edi = v130;
					++esi;
					++edi;
					v131 = esp;
					esp -= (struct Eq_1892 *) 4;
					*esp = eax;
					esp -= (struct Eq_1897 *) 4;
					*esp = ecx;
					esp -= (struct Eq_1902 *) 4;
					*esp = edx;
					esp -= (struct Eq_1907 *) 4;
					*esp = ebx;
					esp -= (struct Eq_1912 *) 4;
					*esp = v131;
					esp -= (struct Eq_1917 *) 4;
					*esp = ebp;
					esp -= (struct Eq_1922 *) 4;
					*esp = esi;
					esp -= (struct Eq_1927 *) 4;
					*esp = edi;
					&SCZO.u3->u0 = cond(*esi - *edi);
					esi += 4;
					edi += 4;
					&eax.u3->u0 = (int32) ax;
					*(union Eq_3 *) ~0x67C44444 = eax;
					al = al - 88 - C;
					ebp.u0 = ~0x44508594;
					*(union Eq_3 *) ~0x4444509D = al;
					v132 = *(word32 *) 3148194157 - ~0x5A299244;
					*(word32 *) 3148194157 = v132;
					&SCZO.u3->u0 = cond(v132);
					ebx.u0 = 2494293435;
					eax = __in<word32>(dx);
					edi += 4;
					v133 = Mem0[ebp + 0x1090BBBB:word32] + edi + C;
					&((byte) ebp.u0 + 0x1090BBBB)->u3->u0 = v133;
					*(union Eq_3 *) 0x90AB6DA0 = eax;
					++ecx;
					al = *(union Eq_3 *) 3664620327;
					ebp.u0 = 0x4999BBBB;
					&SCZO.u3->u0 = cond(*esi - *edi);
					esi += 4;
					edi += 4;
					edx_eax = (int64) eax;
					--ecx;
					SZO = cond(ecx);
					return;
				}
				goto l0040BFD9;
			}
			edx = edx;
			ebx = ebx;
			if (Test(GT,SZO))
				goto l0040C4F8;
			++eax;
			--ebp;
			al -= ~0x4C;
			&SCZO.u3->u0 = cond(al);
			dl = dl - bh - C;
			&SCZO.u3->u0 = cond(dl);
l0040C285:
			bl |= cl;
			C.u0 = false;
			ebx = ebx - ecx - C;
			dl >>= cl;
			ah >>= cl;
			v113 = (ch & 0x01 << 0x08 - cl) != 0x00;
			ch = __rol<byte,byte>(ch, cl);
			dl <<= cl;
			bl = bl ^ 0x54;
			eax <<= cl;
			&SCZO.u3->u0 = cond(eax);
			bl = bl + ch + C;
			&SCZO.u3->u0 = cond(bl);
			dh = dh - ah - C;
			&SCZO.u3->u0 = cond(dh);
			bl <<= cl;
			&SCZO.u3->u0 = cond(bl);
			edi = edi - esi - C;
			dh <<= cl;
			edx &= edi;
			bl >>= cl;
			v114 = (ah & 0x01 << cl) != 0x00;
			ah = __ror<byte,byte>(ah, cl);
			dl &= 0x5E;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			goto l0040C670;
		}
		edx = edx;
		ebx = ebx;
		if (Test(GE,SO))
			goto l0040C78A;
		__out<word32>(0x5C, eax);
		__wait();
		ecx -= (struct Eq_331 *) 0x01;
		ah <<= cl;
		&SCZO.u3->u0 = cond(ah);
l0040C5B6:
		bh <<= cl;
		--dh;
		edi >>= cl;
		bl = bl ^ 223;
		esi = ecx;
		al &= bl;
		C.u0 = false;
		bl = bl + al + C;
		bh <<= cl;
		&SCZO.u3->u0 = cond(bh);
		bl <<= cl;
		&SCZO.u3->u0 = cond(bl);
		v45 = (ah & 0x01 << 0x08 - cl) != 0x00;
		ah = __rol<byte,byte>(ah, cl);
		C = v45;
		--bl;
		bh <<= cl;
		dh |= cl;
		C.u0 = false;
		edx = edx - eax - C;
		al &= 0x2D;
		C.u0 = false;
		dl = bh;
		ah = ah - ch - C;
		edx <<= cl;
		&SCZO.u3->u0 = cond(edx);
		if (Test(UGT,CZ))
		{
			edx = edx;
			ebx = ebx;
			if (Test(UGT,CZ))
				goto l0040C1E1;
			v58 = *ebx & bh;
			*ebx = v58;
			SZ = cond(*ebx);
			O = false;
			C.u0 = false;
			esp -= (struct Eq_687 *) 4;
			*esp = ecx;
l0040C43B:
			bh &= 202;
			++esi;
			v59 = (esi & 0x01 << cl) != 0x00;
			esi = __ror<word32,byte>(esi, cl);
			bh &= cl;
			C.u0 = false;
			v60 = (dh & 0x01 << cl) != 0x00;
			dh = __rcr<byte,byte>(dh, cl, C);
			C = v60;
			v61 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rcl<byte,byte>(dh, cl, C);
			&SCZO.u3->u0 = cond(ecx - 0x530AABFF);
			if (Test(NE,Z))
			{
				v63 = (eax & 0x01 << 0x20 - cl) != 0x00;
				eax = __rol<word32,byte>(eax, cl);
				al <<= cl;
				&bl.u3->u0 = (byte) bl.u0 + 0x008E;
				dl |= bl;
				ah += bl;
				&SCZO.u3->u0 = cond(ah);
				ecx += ebx;
				cl |= dl;
				ah += dh;
				v68 = (ecx & 0x01 << 0x20 - cl) != 0x00;
				ecx = __rol<word32,byte>(ecx, cl);
				ebx >>= cl;
				bh &= ah;
				--ch;
				ah += al;
				al |= 0x18;
				SZ = cond(al);
				O = false;
				C.u0 = false;
				bl >>= cl;
				ah <<= cl;
				ch.u0 = 0xAC;
				ah &= ~0x34;
				bh &= dl;
				C.u0 = false;
				cl = cl - dl - C;
				esi |= eax;
				SZ = cond(esi);
				O = false;
				C.u0 = false;
l0040C0F2:
				edx >>= cl;
				cl = bl;
				ah -= ch;
				edx -= (struct Eq_846 *) 0x01;
				dl <<= cl;
				v56 = (ecx & 0x01 << 0x20 - cl) != 0x00;
				ecx = __rol<word32,byte>(ecx, cl);
				ch >>= cl;
				&SCZO.u3->u0 = cond(ch);
				v57 = (dl & 0x01 << cl) != 0x00;
				dl = __rcr<byte,byte>(dl, cl, C);
				C = v57;
				al = al - bh - C;
				&SCZO.u3->u0 = cond(al);
				esi = esi ^ edx;
				v65 = (edx & 0x01 << cl) != 0x00;
				edx = __ror<word32,byte>(edx, cl);
				bh -= 151;
				ebx &= edi;
				eax = edi;
				bh |= 0xA0;
				C.u0 = false;
				ebx = ebx + esi + C;
				edx = ecx;
				v66 = (edx & 0x01 << cl) != 0x00;
				edx = __ror<word32,byte>(edx, cl);
				bh |= ch;
				C.u0 = false;
				edx = edx + edi + C;
				v67 = (bh & 0x01 << cl) != 0x00;
				bh = __ror<byte,byte>(bh, cl);
				ecx = ecx ^ ebx;
				SZ = cond(ecx);
				O = false;
				C.u0 = false;
				if (Test(NO,O))
				{
					edx = edx;
					ebx = ebx;
					if (Test(OV,O))
					{
						ecx -= (struct Eq_799 *) 0x01;
						SZO = cond(ecx);
						__sti();
						eax = ebx;
						return;
					}
				}
				cl = cl - dh - C;
				&SCZO.u3->u0 = cond(cl);
				v72 = (eax & 0x01 << cl) != 0x00;
				eax = __rcr<word32,byte>(eax, cl, C);
				&bl.u3->u0 = (byte) bl + 0x00D0;
				&SCZO.u3->u0 = cond(bl);
				ebx = ebx - edx - C;
				edi <<= cl;
				&SCZO.u3->u0 = cond(edi);
				v73 = (edi & 0x01 << cl) != 0x00;
				edi = __rcr<word32,byte>(edi, cl, C);
				C = v73;
				ah = ah + dh + C;
				v74 = (edi & 0x01 << cl) != 0x00;
				edi = __ror<word32,byte>(edi, cl);
				ah |= cl;
				SZ = cond(ah);
				O = false;
				C.u0 = false;
				if (Test(SG,S))
				{
l0040BF2F:
					cl = cl ^ ~0x12;
					dh |= dl;
					v85 = (edx & 0x01 << cl) != 0x00;
					edx = __ror<word32,byte>(edx, cl);
					ecx <<= cl;
					esi |= ebx;
					bl = bl ^ bh;
					&bh.u3->u0 = (byte) bh + 1;
					SZO = cond(bh);
					v86 = (dh & 0x01 << 0x08 - cl) != 0x00;
					dh = __rol<byte,byte>(dh, cl);
					C = v86;
					v87 = (cl & 0x01 << cl) != 0x00;
					cl = __rcr<byte,byte>(cl, cl, C);
					C = v87;
					if (Test(ULT,C))
						goto l0040C285;
					edx = edx;
					ebx = ebx;
					if (Test(UGE,C))
						goto l0040C285;
					al = *esi;
					++esi;
					SZP = cond(ebp.u6->bD2F35907 & bl);
					O = false;
					C.u0 = false;
					goto l0040BF58;
				}
				edx = edx;
				ebx = ebx;
				if (Test(NS,S))
					goto l0040BF2F;
				esp -= (struct Eq_953 *) 4;
				*esp = ebx;
				ecx &= ebp.u6->dwFFFFFFD3;
				al = *((word32) ebx + (uint32) al);
				ebx &= edx;
				bl &= al;
				dh <<= cl;
				edi |= eax;
				C.u0 = false;
				v76 = (dl & 0x01 << cl) != 0x00;
				dl = __rcr<byte,byte>(dl, cl, C);
				++esi;
				ebx >>= cl;
				&SCZO.u3->u0 = cond(ebx);
				--bl;
				ecx = ecx + edx + C;
				al += ch;
				&dh.u3->u0 = (byte) dh + 1;
				ch <<= cl;
				&SCZO.u3->u0 = cond(ch);
				if (Test(SG,S))
				{
l0040C62B:
					cl -= 0x32;
					dl.u0 = 0xD8;
					al <<= cl;
					&SCZO.u3->u0 = cond(al);
					ah = ah - bl - C;
					bl = bl ^ 0x77;
					dh = dh ^ cl;
					SZ = cond(dh);
					O = false;
					C.u0 = false;
					&ah.u3->u0 = (byte) ah.u0 + 0x0084;
					cl -= 0x8C;
					&SCZO.u3->u0 = cond(cl);
					eax.u0 = 0x03;
					bh = bh + dh + C;
					dl &= dh;
					bh = bh ^ cl;
					C.u0 = false;
					dl = dl - 171 - C;
					dh >>= cl;
					cl >>= cl;
					&SCZO.u3->u0 = cond(cl);
					if (Test(NE,Z))
					{
						edx = edx;
						ebx = ebx;
						if (Test(EQ,Z))
						{
							cl.u0 = 0x05;
							v90 = *esi;
							*edi = v90;
							esi += 4;
							edi += 4;
							&SCZO.u3->u0 = cond(eax - *edi);
							edi += 4;
							al |= 0x81;
							SZ = cond(al);
							O = false;
							C.u0 = false;
							goto l0040C494;
						}
					}
					edx += ecx;
					dh |= 0x06;
					dh >>= cl;
					v101 = (bl & 0x01 << 0x08 - cl) != 0x00;
					bl = __rol<byte,byte>(bl, cl);
					bh >>= cl;
					esi |= ebx;
					C.u0 = false;
					bh = bh - 0x09 - C;
					ch &= ah;
					C.u0 = false;
					&bl.u3->u0 = (bool) C.u0 + ((byte) bl + 27);
					bh -= 0x7D;
					ebx = edx;
					dh <<= cl;
					&SCZO.u3->u0 = cond(dh);
					if (Test(UGE,C))
					{
						edx = edx;
						ebx = ebx;
						if (Test(ULT,C))
						{
							__out<byte>(0xC3, al);
							fn80C2_FE35();
							return;
						}
					}
					v110 = (ch & 0x01 << 0x08 - cl) != 0x00;
					ch = __rol<byte,byte>(ch, cl);
					ch >>= cl;
					edi += ecx;
					v111 = (cl & 0x01 << 0x08 - cl) != 0x00;
					cl = __rol<byte,byte>(cl, cl);
					C = v111;
					dl = dl + dh + C;
					cl &= 166;
					ecx |= eax;
					v112 = (ebx & 0x01 << cl) != 0x00;
					ebx = __ror<word32,byte>(ebx, cl);
					edx = edx ^ edx;
					SZ = cond(edx);
					O = false;
					C.u0 = false;
					bl = ah;
					return;
				}
				edx = edx;
				ebx = ebx;
				if (Test(NS,S))
					goto l0040C62B;
				__wait();
				if (Test(NO,O))
				{
					if (Test(NE,Z))
					{
l0040C166:
						bl &= ch;
						C.u0 = false;
						v35 = (al & 0x01 << 0x08 - cl) != 0x00;
						al = __rcl<byte,byte>(al, cl, C);
						bl |= ~0x44;
						&bl.u3->u0 = (byte) bl + 200;
						ah >>= cl;
						dh = ah;
						dl = dl ^ cl;
						C.u0 = false;
						--ah;
						al = al - ~0x01 - C;
						bh >>= cl;
						ebx >>= cl;
						v36 = (eax & 0x01 << cl) != 0x00;
						eax = __ror<word32,byte>(eax, cl);
						C = v36;
						&bh.u3->u0 = (byte) bh + 1;
						SZO = cond(bh);
						&dh.u3->u0 = (byte) dh + 1;
						ah <<= cl;
						bl = ah;
						dh <<= cl;
						&SCZO.u3->u0 = cond(dh);
						bh = bh - bl - C;
						&SCZO.u3->u0 = cond(bh);
						ebx = ebx + esi + C;
						&SCZO.u3->u0 = cond(ebx);
						ebx = esi;
						if (Test(PO,P))
						{
							edx = edx;
							ebx = ebx;
							if (Test(PE,P))
							{
								ebx = *esp;
								&esp.u3->u0 = (word32) esp + 4;
								fnD37B8F14();
								goto l0040C390;
							}
						}
						dh += bh;
						dl -= bl;
						&SCZO.u3->u0 = cond(dl);
						esi = esi - ecx - C;
						v42 = (al & 0x01 << 0x08 - cl) != 0x00;
						al = __rol<byte,byte>(al, cl);
						edi += eax;
						dl <<= cl;
						bh <<= cl;
						&SCZO.u3->u0 = cond(bh);
						if (Test(LE,SZO))
						{
l0040C00B:
							dh <<= cl;
							v46 = (bl & 0x01 << cl) != 0x00;
							bl = __ror<byte,byte>(bl, cl);
							C = v46;
							&al.u3->u0 = (bool) C.u0 + ((byte) al + 0x00A8);
							bl.u0 = 0x03;
							dl >>= cl;
							bh = bh ^ dl;
							C.u0 = false;
							esi = eax;
							al = al + ah + C;
							&SCZO.u3->u0 = cond(al);
							bl = bl - ~0x04 - C;
							eax <<= cl;
							&SCZO.u3->u0 = cond(eax);
							v47 = (edi & 0x01 << cl) != 0x00;
							edi = __ror<word32,byte>(edi, cl);
							C = v47;
							if (Test(UGT,CZ))
							{
								edx = edx;
								ebx = ebx;
								if (Test(ULE,CZ))
									return;
							}
							ah &= cl;
							al = al ^ ch;
							dl &= al;
							dl &= 0xB4;
							al >>= cl;
							dl &= cl;
							++ebx;
							esi -= eax;
							&SCZO.u3->u0 = cond(esi);
							v64 = (ebx & 0x01 << 0x20 - cl) != 0x00;
							ebx = __rcl<word32,byte>(ebx, cl, C);
							al -= ~0x46;
							&SCZO.u3->u0 = cond(al);
							dl = dl - 0x4F - C;
							&SCZO.u3->u0 = cond(dl);
							ah = ah ^ ~0x58;
							SZ = cond(ah);
							O = false;
							C.u0 = false;
l0040C3CE:
							edi &= ecx;
							edx >>= cl;
							v69 = (dl & 0x01 << cl) != 0x00;
							dl = __ror<byte,byte>(dl, cl);
							esi <<= cl;
							dh &= 0x5D;
							SZ = cond(dh);
							O = false;
							C.u0 = false;
							&dl.u3->u0 = (byte) dl + 1;
							&bl.u3->u0 = (bool) C.u0 + ((byte) bl + 131);
							dl <<= cl;
							&SCZO.u3->u0 = cond(dl);
							v71 = (ebx & 0x01 << cl) != 0x00;
							ebx = __rcr<word32,byte>(ebx, cl, C);
							al.u0 = 0x93;
							bl >>= cl;
							SCZ = cond(bl);
							v77 = (ah & 0x01 << 0x08 - cl) != 0x00;
							ah = __rcl<byte,byte>(ah, cl, C);
							al >>= cl;
							bl -= 0x1B;
							ah = ah ^ 188;
							C.u0 = false;
							v78 = (dh & 0x01 << 0x08 - cl) != 0x00;
							dh = __rcl<byte,byte>(dh, cl, C);
							dl -= 0x1F;
							&SCZO.u3->u0 = cond(dl);
							eax = eax + esi + C;
							al = ch;
							v79 = (dh & 0x01 << cl) != 0x00;
							dh = __ror<byte,byte>(dh, cl);
							al &= 0x7C;
							SZ = cond(al);
							O = false;
							C.u0 = false;
							bl = ah;
l0040C390:
							*Top += (real64) *((byte) eax.u0 - 0x3A751616);
							ah.u0 = 220;
							esi = ecx;
							dh += dl;
							esi = esi ^ eax;
							SZ = cond(esi);
							O = false;
							C.u0 = false;
							dh = dh ^ dl;
							&ah.u3->u0 = (byte) ah + 65;
							edx &= eax;
							v44 = (bh & 0x01 << cl) != 0x00;
							bh = __ror<byte,byte>(bh, cl);
							eax &= edi;
							dh >>= cl;
							bl |= 0x95;
							esi |= edx;
							C.u0 = false;
							&dh.u3->u0 = (byte) dh + 1;
							eax = eax - ecx - C;
							bl -= bh;
							&SCZO.u3->u0 = cond(bl);
							if (Test(GE,SO))
							{
								edx = edx;
								ebx = ebx;
								if (Test(LT,SO))
								{
									&SCZO.u3->u0 = cond(dh - ((ebp.u6)->tFFFFFF82).u0);
									ecx.u0 = ~0x2D1C2D55;
								}
							}
							goto l0040C5B6;
						}
						edx = edx;
						ebx = ebx;
						if (Test(GT,SZO))
							goto l0040C00B;
						ecx->u1 = (int64) trunc(*Top);
						Top = (real64 *) ((char *) Top + 1);
						if (Test(ULT,C))
							goto l0040C52F;
						goto l0040C554;
					}
					esp -= *edx;
					&SCZO.u3->u0 = cond(esp);
					v80 = edx;
					eax = v80;
					edx_eax = (int64) eax;
					goto l0040C1E1;
				}
				v82 = Mem0[eax + 0x00:byte] + al;
				*eax.u0 = v82;
				&SCZO.u3->u0 = cond(v82);
				edx = edx;
				ebx = ebx;
				if (Test(LE,SZO))
					goto l0040C1AA;
			}
			else
			{
				edi |= esi;
				++edx;
				bl += cl;
				al.u0 = ~0x18;
				al -= 0x1C;
				bh -= ch;
				&SCZO.u3->u0 = cond(bh);
				&cl.u3->u0 = (byte) cl + 1;
				SZO = cond(cl);
				if (Test(NE,Z))
				{
					edx = edx;
					ebx = ebx;
					if (Test(EQ,Z))
					{
						esp -= (struct Eq_837 *) 2;
						*esp = ss;
						eax.u0 = 0x8031C96C;
					}
				}
l0040C52F:
				dh = dh ^ 0xAA;
				C.u0 = false;
				esi = esi + eax + C;
				bl &= 0x51;
				C.u0 = false;
				al = al - bl - C;
				bh <<= cl;
				edi |= edx;
				C.u0 = false;
				al = al - ~0x19 - C;
				edi <<= cl;
				v43 = (edi & 0x01 << cl) != 0x00;
				edi = __ror<word32,byte>(edi, cl);
				edx <<= cl;
				edx -= (Eq_3 (*)[]) 0x01;
				dh &= bh;
				cl -= 0x23;
				&SCZO.u3->u0 = cond(cl);
				if (Test(GE,SO))
				{
					edx = edx;
l0040C554:
					ebx = ebx;
					if (Test(LT,SO))
					{
						eax += esp;
						&SCZO.u3->u0 = cond(eax - ~0x202C20FD);
						goto l0040C563;
					}
				}
				bl = bl ^ ah;
				C.u0 = false;
				&cl.u3->u0 = (byte) cl + 1;
				esp -= 4;
				esp->u0 = 0x00;
				eax = *esp;
				&esp.u3->u0 = (word32) esp + 4;
				v48 = (edi & 0x01 << 0x20 - cl) != 0x00;
				edi = __rcl<word32,byte>(edi, cl, C);
				edx -= esi;
				ch >>= cl;
				esi |= edi;
				cl <<= cl;
				edx &= esi;
				C.u0 = false;
				bl = bl - 0x87 - C;
				&SCZO.u3->u0 = cond(bl);
				if (Test(UGT,CZ))
				{
					edx = edx;
					ebx = ebx;
					if (Test(UGT,CZ))
						goto l0040C641;
					C.u0 = true;
					*edi = ax;
					edi += 2;
					edx = edx + edi[esi * 0x08] + C;
					&SCZO.u3->u0 = cond(edx);
					C.u0 = false;
					goto l0040C0C3;
				}
l0040C641:
				&dl.u3->u0 = (byte) dl + 0x007D;
				al = al ^ ~0x07;
				eax += edx;
				edx = edx ^ edx;
				ebx >>= cl;
				edi <<= cl;
				cl = al;
				ch += bh;
				edi <<= cl;
				al -= bh;
				&SCZO.u3->u0 = cond(al);
				v125 = (ah & 0x01 << cl) != 0x00;
				ah = __rcr<byte,byte>(ah, cl, C);
				C = v125;
				if (Test(NO,O))
				{
					edx = edx;
					ebx = ebx;
					if (Test(OV,O))
					{
						SZP = cond(*((word32) edx + (edx * 0x02 + 831848381)) & bl);
						O = false;
						C.u0 = false;
l0040C670:
						esi = esi ^ eax;
						ecx >>= cl;
						SCZ = cond(ecx);
						v118 = (al & 0x01 << cl) != 0x00;
						al = __rcr<byte,byte>(al, cl, C);
						dh |= al;
						ecx -= eax;
						&cl.u3->u0 = (byte) cl.u0 + 1;
						bh |= cl;
						SZ = cond(bh);
						O = false;
						C.u0 = false;
						ah.u0 = 0x67;
						if (Test(GE,SO))
						{
							edx = edx;
							ebx = ebx;
							if (Test(LT,SO))
							{
								&SCZO.u3->u0 = cond(bh - *ebx);
								SCZO = *esp;
								esp += 0x04;
								return;
							}
						}
						ecx = ecx ^ eax;
						bl = bl ^ dl;
						++eax;
						dh |= bl;
						bh <<= cl;
						&SCZO.u3->u0 = cond(bh);
						v119 = (esi & 0x01 << cl) != 0x00;
						esi = __ror<word32,byte>(esi, cl);
						C = v119;
						cl -= ch;
						&SCZO.u3->u0 = cond(cl);
						&cl.u3->u0 = (byte) cl + 1;
						v122 = (ecx & 0x01 << cl) != 0x00;
						ecx = __rcr<word32,byte>(ecx, cl, C);
						esi <<= cl;
						dl -= bh;
						ecx &= edx;
						v123 = (dh & 0x01 << 0x08 - cl) != 0x00;
						dh = __rol<byte,byte>(dh, cl);
						C = v123;
						v124 = (dl & 0x01 << cl) != 0x00;
						dl = __rcr<byte,byte>(dl, cl, C);
						edx &= esi;
						ecx -= esi;
						&SCZO.u3->u0 = cond(ecx);
						++esi;
						SZO = cond(esi);
						return;
					}
				}
				eax = eax ^ esi;
				eax -= ecx;
				&cl.u3->u0 = (byte) cl + 1;
				ah &= ch;
				edi |= ecx;
				esi >>= cl;
				bh = bh ^ ah;
				SZ = cond(bh);
				O = false;
				C.u0 = false;
				if (Test(GT,SZO))
				{
					edx = edx;
					ebx = ebx;
					if (Test(LE,SZO))
					{
l0040C1AA:
						__out<word32>(dx, eax);
						__out<byte>(0x24, al);
						goto l0040C1AD;
					}
				}
			}
			__syscall<byte>(0x2E);
			v83 = (edi & 0x01 << 0x20 - cl) != 0x00;
			edi = __rcl<word32,byte>(edi, cl, C);
			ch &= al;
			v84 = (ebx & 0x01 << cl) != 0x00;
			ebx = __ror<word32,byte>(ebx, cl);
			bl <<= cl;
			bh >>= cl;
			cl -= 0x50;
			ebx |= edi;
			ch &= 0x17;
			C.u0 = false;
			bh = bh - dl - C;
			&SCZO.u3->u0 = cond(bh);
			cl = cl - ah - C;
			&SCZO.u3->u0 = cond(cl);
			goto l0040C364;
		}
l0040C1E1:
		ebx |= ecx;
		dh -= ~0x42;
		dl -= bl;
		edi >>= cl;
		dl <<= cl;
		&al.u3->u0 = (byte) al + 0x0088;
		eax |= esi;
		ah <<= cl;
		dh |= 0x43;
		C.u0 = false;
		ah = bl;
		ah = ah - dl - C;
		&SCZO.u3->u0 = cond(ah);
		if (Test(GT,SZO))
		{
			edx = edx;
			ebx = ebx;
			if (Test(GT,SZO))
				goto l0040C0C3;
			v94 = (*((word32) esi + (edi * 0x02 + 0x6A639CA6)) & 0x01 << 0x01) != 0x00;
			*((word32) esi + (edi * 0x02 + 0x6A639CA6)) = __rcr<byte,byte>(*((word32) esi + (edi * 0x02 + 0x6A639CA6)), 0x01, C);
			C = v94;
			goto l0040C211;
		}
l0040C0C3:
		edx -= (struct Eq_1267 *) 0x01;
		v50 = (edi & 0x01 << 0x20 - cl) != 0x00;
		edi = __rol<word32,byte>(edi, cl);
		v51 = (esi & 0x01 << 0x20 - cl) != 0x00;
		esi = __rol<word32,byte>(esi, cl);
		al &= 0x7D;
		--dh;
		--esi;
		edi |= esi;
		esi += edx;
		dl &= ah;
		C.u0 = false;
		--dl;
		SZO = cond(dl);
		al = cl;
		v52 = (edx & 0x01 << 0x20 - cl) != 0x00;
		edx = __rcl<word32,byte>(edx, cl, C);
		C = v52;
		v53 = (dl & 0x01 << 0x08 - cl) != 0x00;
		dl = __rcl<byte,byte>(dl, cl, C);
		C = v53;
		if (Test(GE,SO))
		{
			edx = edx;
			ebx = ebx;
			if (Test(LT,SO))
			{
				ebx.u6->ptrFFFFFFC3 = ds;
				esp = *esp;
				esp += 4;
				&v55.u3->u0 = (bool) C.u0 + ((word64) (*eax) - 1021582638);
				*eax = v55;
				&SCZO.u3->u0 = cond(v55);
				goto l0040C0F2;
			}
		}
		ecx += 1631888566;
		dl += dh;
		&SCZO.u3->u0 = cond(dl);
		esi = esi + edx + C;
		&SCZO.u3->u0 = cond(esi);
		v121 = (ah & 0x01 << cl) != 0x00;
		ah = __rcr<byte,byte>(ah, cl, C);
		edx -= esi;
		dl |= 161;
		dh |= ch;
		al >>= cl;
		&al.u3->u0 = (byte) al + 1;
		eax = ebx;
		esi = ebx;
		ah <<= cl;
		&SCZO.u3->u0 = cond(ah);
		&dl.u3->u0 = (byte) dl.u0 + 43;
		&SCZO.u3->u0 = cond(ecx - 4114456134);
		if (Test(NE,Z))
			goto l0040BF8A;
		v126 = (ah & 0x01 << 0x08 - cl) != 0x00;
		ah = __rol<byte,byte>(ah, cl);
		bh = bh ^ dl;
		v127 = (ebx & 0x01 << cl) != 0x00;
		ebx = __ror<word32,byte>(ebx, cl);
		C = v127;
		v128 = (edi & 0x01 << 0x20 - cl) != 0x00;
		edi = __rcl<word32,byte>(edi, cl, C);
		bl = bl ^ 0x4F;
		SZ = cond(bl);
		O = false;
		C.u0 = false;
l0040BF58:
		__sti();
		bh |= dh;
		ecx -= edi;
		dh += ch;
		bh = bh ^ 0x23;
		eax.u0 = 0x530AABFF;
		bh >>= cl;
		SCZ = cond(bh);
		--ecx;
		v89 = (ch & 0x01 << 0x08 - cl) != 0x00;
		ch = __rcl<byte,byte>(ch, cl, C);
		bl &= ch;
		C.u0 = false;
		--edx;
		SZO = cond(edx);
		if (Test(NS,S))
		{
			edx = edx;
			ebx = ebx;
			if (Test(SG,S))
			{
				esp -= (struct Eq_1174 *) 4;
				*esp = edi;
				ebp.u0 = 0xD283EC80;
				goto l0040BF7F;
			}
		}
		bl -= dh;
		cl >>= cl;
		edx += ecx;
		&SCZO.u3->u0 = cond(edx);
		mm0 = (word64) eax;
		v105 = (ebx & 0x01 << cl) != 0x00;
		ebx = __rcr<word32,byte>(ebx, cl, C);
		bl -= ah;
		&cl.u3->u0 = (byte) cl + 117;
		&SCZO.u3->u0 = cond(cl);
		ecx &= eax;
		al &= ch;
		bl.u0 = 171;
		v106 = (esi & 0x01 << 0x20 - cl) != 0x00;
		esi = __rol<word32,byte>(esi, cl);
		al &= 0x91;
		SZ = cond(al);
		O = false;
		C.u0 = false;
		ecx = (word32) mm0;
		do
		{
			edi = edi - edx - C;
			edi = edi ^ eax;
			C.u0 = false;
			v107 = (edi & 0x01 << 0x20 - cl) != 0x00;
			edi = __rcl<word32,byte>(edi, cl, C);
			esi = edi;
			ah -= 0x4F;
			&SCZO.u3->u0 = cond(ah);
			dh = dh + cl + C;
			ebx -= eax;
			&SCZO.u3->u0 = cond(ebx);
			if (Test(EQ,Z))
				goto l0040C43B;
			edx = edx;
			ebx = ebx;
			if (Test(NE,Z))
				goto l0040C43B;
		} while (Test(GE,SO));
		ah = ah ^ ch;
		SZ = cond(ah);
		O = false;
		C.u0 = false;
	}
	ah -= 131;
	&SCZO.u3->u0 = cond(ah);
	v26 = (al & 0x01 << cl) != 0x00;
	al = __ror<byte,byte>(al, cl);
	C = v26;
l0040BF7F:
	bl = bl + dl + C;
	&SCZO.u3->u0 = cond(bl);
	v27 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	C = v27;
	v28 = (bh & 0x01 << cl) != 0x00;
	bh = __rcr<byte,byte>(bh, cl, C);
	C = v28;
	edx = edx - ecx - C;
	&SCZO.u3->u0 = cond(edx);
	v29 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	C = v29;
l0040BF8A:
	al |= dl;
	esi >>= cl;
	dh &= 114;
	C.u0 = false;
	eax = eax - edi - C;
	al &= bl;
	SZ = cond(al);
	O = false;
	C.u0 = false;
	if (Test(NO,O))
	{
		edx = edx;
		ebx = ebx;
		if (Test(OV,O))
		{
			esp -= 4;
			*esp = eax;
			&SCZO.u3->u0 = cond(*esi - *edi);
			&esi.u3->u0 = (word32) esi + 4;
			&edi.u3->u0 = (word32) edi + 4;
			C = !C;
		}
	}
l0040C1AD:
	dl -= ah;
	al <<= cl;
	&dl.u3->u0 = (byte) dl + 48;
	ah |= 177;
	eax += ecx;
	--esi;
	dl |= 0x09;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	if (Test(UGT,CZ))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULE,CZ))
		{
			esi = esi ^ ebp;
			eax = Mem0[edx + esi:word32] *s 3553307563;
			&SCZO.u3->u0 = cond(eax);
			return;
		}
	}
	goto l0040C166;
}

// 0040D37C: define fn0040D37C
// Called from:
//      fn0040D5CB
//      fn0040DDA1
define fn0040D37C
{
	word32 ebx;
	byte dh;
	bh = SLICE(ebx, byte, 8);
	byte ah;
	word32 ecx;
	word32 edi;
	cl_10 = (byte) ecx;
	Top_3 = 0;
	dh_6 = dh - bh;
	ah_8 = ah - 0x01;
	ecx_12 = __rol<word32,byte>(ecx, cl_10);
	cl_19 = (byte) ecx_12;
	edi_14 = edi + 0x01;
	SZO_15 = cond(edi + 0x01);
	ebx_18 = ebx;
	O_23 = SLICE(SZO_15, bool, 4);
	S_24 = (bool) SZO_15;
	Z_25 = SLICE(SZO_15, bool, 2);
	v15_20 = (ebx_18 & 0x01 << cl_19) != 0x00;
	ebx_21 = __ror<word32,byte>(ebx_18, cl_19);
	C_22 = v15_20;
}

// 0040D39D: define fn0040D39D
// Called from:
//      fn0040D695
//      fn0040DDC6
define fn0040D39D
{
	esp = fp;
	Top = 0;
	v6 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	v9 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	bl >>= cl;
	SCZ = cond(bl);
	ebx = ebx + eax + C;
	edi &= edx;
	esi = ebx + esi;
	esi &= ebx;
	SZ = cond(esi);
	O = false;
	C.u0 = false;
	if (Test(NS,S))
	{
		edx = edx;
		ebx = ebx;
		if (Test(SG,S))
		{
			--ecx;
			if (Test(NE,Z) && ecx != 0x00)
			{
				fn0040D3C3();
				return;
			}
			else
				ebx->aDFD3A313[eax].ptr0000 = cs;
		}
	}
	v23 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	v25 = (ah & 0x01 << 0x08 - 0x1E) != 0x00;
	ah = __rol<byte,byte>(ah, 0x1E);
	&edi.u3->u0 = (word32) edi + 1;
	++bl;
	bl = 0x9A;
	--bh;
	bl <<= cl;
	bh &= ah;
	&bh.u3->u0 = (byte) bh + 53;
	SCZO = cond(bh);
	bh.u0 = ~0x62;
	fn0040D51B();
}

// 0040D3C2: define fn0040D3C2
// Called from:
//      fn0040D5CB
//      fn0040D790
define fn0040D3C2
{
	word32 edi;
	byte cl;
	bool C;
	Top_3 = 0;
	v6_6 = (edi & 0x01 << cl) != 0x00;
	edi_8 = __rcr<word32,byte>(edi, cl, C);
	C_9 = v6_6;
}

// 0040D3C3: define fn0040D3C3
// Called from:
//      fn0040D695
define fn0040D3C3
{
	esp = fp;
	Top = null;
	ebx->w3F813FB = (int16) trunc(*Top);
	Top = (real64 *) ((char *) Top + 1);
}

// 0040D3EA: define fn0040D3EA
// Called from:
//      fn0040D695
define fn0040D3EA
{
	esp = fp;
	Top = 0;
	v6 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v6;
	bl = bl - 0x02 - C;
	bl = dh;
	bh += 0x5D;
	SCZO = cond(bh);
	edi = edi - eax - C;
	bl -= 223;
	SCZO = cond(bl);
	v13 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	C = v13;
	bh <<= cl;
	ah = ah ^ 0x30;
	v17 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	bh |= 0x60;
	bl -= 0xD0;
	bl |= al;
	C.u0 = false;
	v19 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	esi >>= cl;
	bh >>= cl;
	SCZO = cond(bh);
	if (Test(PE,P))
		fn0040DDC6();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(PO,P))
			fn0040DDC6();
		else
		{
			eax = __in<word32>(dx);
			SCZO = cond(eax - 3537079031);
			fn0040D775();
		}
	}
}

// 0040D464: define fn0040D464
// Called from:
//      fn0040D599
define fn0040D464
{
}

// 0040D488: define fn0040D488
// Called from:
//      fn0040D599
//      fn0040DDA5
define fn0040D488
{
	esp = fp;
	Top = 0;
	fn0040DDA1();
}

// 0040D495: define fn0040D495
// Called from:
//      fn0040D464
//      fn0040D8A4
define fn0040D495
{
	esp = fp;
	Top = 0;
	&bl.u3->u0 = (byte) bl.u2 + 1;
	bh = bh - al - C;
	SCZO = cond(bh);
	v11 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	ebx &= edi;
	bl = bl ^ 118;
	edi &= edx;
	bl >>= cl;
	SCZO = cond(bl);
	v17 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	C = v17;
	al = ah;
	edi = &(C.u3 + (edi + ebx) / 8)->u0;
	SCZO = cond(edi);
	if (Test(OV,O))
		fn0040DBCD();
	else
		fn0040D4B0();
}

// 0040D4B0: define fn0040D4B0
// Called from:
//      fn0040D8A4
//      fn0040DD22
define fn0040D4B0
{
	esp = fp;
	Top = 0;
	fn0040DDA1();
}

// 0040D4E9: define fn0040D4E9
// Called from:
//      fn0040D5CB
//      fn0040D790
define fn0040D4E9
{
	word32 ecx;
	byte bl;
	byte bh;
	cl = (byte) ecx;
	byte dl;
	byte al;
	byte ah;
	word16 ebx_16_16;
	word24 edx_24_8;
	bool P;
	selector ds;
	word16 eax_16_16;
	Top_3 = 0;
	bh_7 = bh ^ bl - 0x01;
	bl_10 = __rol<byte,byte>(bl - 0x01, cl);
	dl_14 = (dl ^ 113) + 0x41;
	al_19 = al + ah + (byte) (dl_14 < 0x00);
	al_20 = al_19 >> cl;
	bh_21 = bh_7 << cl;
	ecx_23 = ecx;
	ecx_24 = ecx_23 ^ 0x05566345;
	al_26 = al_20 - dl_14;
	ebx_28 = SEQ(ebx_16_16, bh_21, bl_10);
	edx_30 = SEQ(edx_24_8, dl_14);
	ebx_31 = ebx_28 + edx_30;
	SCZO_32 = cond(ebx_31);
	eax_43 = SEQ(eax_16_16, ah, al_26);
	C_51 = SLICE(SCZO_32, bool, 1);
	O_59 = SLICE(SCZO_32, bool, 4);
	S_63 = (bool) SCZO_32;
	Z_67 = SLICE(SCZO_32, bool, 2);
	if (P)
		fn0040DB7A();
	else if (P)
		fn0040DB7A();
	else
	{
		*ebx_31 = (struct Eq_3019 **) ds;
		v25_44 = eax_43->dwF70B98F7 - eax_43;
		eax_43->dwF70B98F7 = v25_44;
		SCZO_46 = cond(v25_44);
		C_50 = SLICE(SCZO_46, bool, 1);
		O_58 = SLICE(SCZO_46, bool, 4);
		S_62 = (bool) SCZO_46;
		Z_66 = SLICE(SCZO_46, bool, 2);
		fn0040D51B();
	}
}

// 0040D51B: define fn0040D51B
// Called from:
//      fn0040D5CB
//      fn0040D695
define fn0040D51B
{
	esp = fp;
	Top = 0;
	bh = bh ^ 0x98;
	esi |= edi;
	ebx -= edx;
	bh = bh ^ 0x51;
	esi = edi;
	ah = ~ah;
	bl -= ~0x70;
	edi <<= cl;
	SCZO = cond(edi);
	bh = bh - 0x3B - C;
	SCZO = cond(bh);
	if (Test(ULT,C))
		fn0040D8A4();
	else
		fn0040D537();
}

// 0040D537: define fn0040D537
// Called from:
//      fn0040D51B
//      fn0040D569
//      fn0040D599
//      fn0040D5CB
//      fn0040D8F0
//      fn0040DC9B
define fn0040D537
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(UGE,C))
		fn0040D8A4();
	else
	{
		dh = 0x80;
		v10 = ebx->bC3D226AA | cl;
		ebx->bC3D226AA = v10;
		SZ = cond(ebx->bC3D226AA);
		O = false;
		C = false;
		fn0040D547();
	}
}

// 0040D547: define fn0040D547
// Called from:
//      fn0040D537
//      fn0040D6C2
//      fn0040DB65
//      fn0040DB6B
define fn0040D547
{
	esp = fp;
	Top = 0;
	v6 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	edi >>= cl;
	esi &= edx;
	dh >>= cl;
	SCZ = cond(dh);
	v17 = (ebx & 0x01 << cl) != 0x00;
	ebx = __rcr<word32,byte>(ebx, cl, C);
	dh >>= cl;
	dl <<= cl;
	edi = ebx;
	eax += 0x08;
	v20 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	C = v20;
	v21 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rcl<word32,byte>(edx, cl, C);
	C = v21;
	bh = (byte) &(C.u3 + (bh + 0xD2) /8 8)->u0;
	edi |= ecx;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
	if (Test(OV,O))
		fn0040DC9B();
	else
		fn0040D569();
}

// 0040D569: define fn0040D569
// Called from:
//      fn0040D537
//      fn0040D6C2
define fn0040D569
{
	esp = fp;
	Top = 0;
	fn0040D537();
}

// 0040D57A: define fn0040D57A
// Called from:
//      fn0040D569
//      fn0040DA31
//      fn0040DC2B
//      fn0040DC3D
define fn0040D57A
{
	word32 ecx;
	word32 edi;
	word32 edx;
	word32 ebx;
	cl = (byte) ecx;
	word32 esi;
	Top_3 = 0;
	edi_6 = edi + edx;
	SCZO_7 = cond(edi_6);
	C_11.u0 = SLICE(SCZO_7, bool, 1);
	ebx_12 = __rcl<word32,byte>(ebx, cl, C_11);
	ebx_13 = ebx_12 - edx;
	ecx_15 = ecx;
	bh_19 = SLICE(ebx_13, byte, 8);
	ebx_16_16_35 = SLICE(ebx_13, word16, 16);
	edx_16 = edx + ecx_15;
	dl_20 = (byte) edx_16;
	bh_21 = bh_19 ^ dl_20;
	esi_23 = esi - edx_16;
	edi_27 = edi_6 << cl;
	esi_28 = esi_23 >> cl;
	edi_29 = edi_27 << cl;
	SCZO_30 = cond(edi_29);
	C_33 = SLICE(SCZO_30, bool, 1);
	ebx_36 = SEQ(ebx_16_16_35, bh_21, dl_20);
	O_43 = SLICE(SCZO_30, bool, 4);
	S_45 = (bool) SCZO_30;
	Z_48 = SLICE(SCZO_30, bool, 2);
	if (edi_29 <= 0x00)
		fn0040D8F0();
	else
		fn0040D599();
}

// 0040D599: define fn0040D599
// Called from:
//      fn0040D569
//      fn0040DC2B
define fn0040D599
{
	esp = fp;
	Top = null;
	fn0040D537();
}

// 0040D5AA: define fn0040D5AA
// Called from:
//      fn0040D599
//      fn0040D790
//      fn0040DD73
define fn0040D5AA
{
	esp = fp;
	Top = 0;
	bh <<= cl;
	ch = ch ^ ~0x41;
	C.u0 = false;
	esp -= 4;
	*esp = edx;
	ch = 0x20;
	&bl.u3->u0 = (bool) C.u0 + ((byte) bl + 2);
	v14 = (eax & 0x01 << cl) != 0x00;
	eax = __ror<word32,byte>(eax, cl);
	v15 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rol<word32,byte>(eax, cl);
	C = v15;
	bh = bh + bl + C;
	bl &= ~0x31;
	SZ = cond(bl);
	O = false;
	v16 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	v18 = (al & 0x01 << cl) != 0x00;
	al = __ror<byte,byte>(al, cl);
	C = v18;
	fn0040DD73();
}

// 0040D5CB: define fn0040D5CB
// Called from:
//      fn0040DA5B
define fn0040D5CB
{
	esp = fp;
	Top = null;
	v5 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	esi >>= cl;
	al -= 0x49;
	ch >>= cl;
	SCZ = cond(ch);
	edx = edx + ebx + C;
	SCZO = cond(edx);
	edi = edi - eax - C;
	ah <<= cl;
	SCZO = cond(ah);
	if (Test(PO,P))
	{
		edx = edx;
		ebx = ebx;
		if (Test(PE,P))
		{
			esp -= 2;
			esp->u1 = (struct Eq_7263 *) cs;
			dh &= bh;
			SZ = cond(dh);
			O = false;
			C.u0 = false;
			fn0040D5EE();
			return;
		}
	}
	v27 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	esp -= 4;
	esp->u0 = 0x05566305;
	ah &= ~0x0E;
	v28 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	cl -= ah;
	v29 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	C = v29;
	v30 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	v31 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	al |= 116;
	SZ = cond(al);
	O = false;
	C.u0 = false;
	ch >>= cl;
	cl = cl ^ 171;
	ecx.u0 = esp->u0;
	esp = (union Eq_3558 *) ((char *) esp + 4);
	bl = (byte) bh.u2 + bl;
	al = al ^ bl;
	dh = dh ^ al;
	dh = dh ^ bh;
	bh >>= cl;
	bh = bh ^ dh;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D4E9();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(NE,Z))
			fn0040D4E9();
		else
		{
			v35 = dl;
			dl = cl;
			cl = v35;
			SZP = cond(ebx->bB3D82BAE & dh);
			O = false;
			C.u0 = false;
			ebx->qwFFFFFFD2 = (int64) trunc(Top->r0000);
			Top = (struct Eq_3507 *) ((char *) &Top->r0000 + 1);
			if (Test(GT,CZ))
				Top->r0000 = Top->r0003;
		}
	}
}

// 0040D5EE: define fn0040D5EE
// Called from:
//      fn0040D5CB
//      fn0040DAFA
define fn0040D5EE
{
	esp = fp;
	Top = 0;
	ah = ah ^ ~0x0A;
	C.u0 = false;
	ah = ah + bh + C;
	al &= 11;
	edi >>= cl;
	dh >>= cl;
	dl -= ~0x29;
	v16 = (ah & 0x01 << cl) != 0x00;
	ah = __ror<byte,byte>(ah, cl);
	C = v16;
	eax = *esp;
	++esp;
	v18 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	bl = bl ^ 200;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	fn0040D98C();
}

// 0040D61E: define fn0040D61E
// Called from:
//      fn0040D537
//      fn0040DAFA
define fn0040D61E
{
	esp = fp;
	Top = 0;
	v5 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	dl |= 0xC4;
	&cl.u3->u0 = &(cl.u3 + bl /8 8)->u0;
	SCZO = cond(cl);
	fn0040DC1E();
}

// 0040D62F: define fn0040D62F
// Called from:
//      fn0040D654
//      fn0040D6DD
define fn0040D62F
{
	esp = fp;
	Top = 0;
	dh &= ~0x09;
	v11 = (ebx & 0x01 << cl) != 0x00;
	ebx = __ror<word32,byte>(ebx, cl);
	edx = edx ^ ebx;
	C.u0 = false;
	v14 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	edi -= ecx;
	eax = ~eax;
	v19 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	C = v19;
	v20 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	dl += 0xB8;
	SCZO = cond(dl);
	dl = dl - bh - C;
	esi &= ebx;
	SZ = cond(esi);
	O = false;
	C.u0 = false;
	esi -= edx;
	bh = bh ^ ~0x49;
	ebx >>= cl;
	bl >>= cl;
	edx = ecx;
	eax |= eax;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		v27 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rol<byte,byte>(bl, cl);
		bl >>= cl;
		dh <<= cl;
		ah |= bh;
		SZ = cond(ah);
		O = false;
		C.u0 = false;
		fn0040D6C2();
	}
	else
	{
		v26 = (edi & 0x01 << cl) != 0x00;
		edi = __rcr<word32,byte>(edi, cl, C);
		bh = bh ^ dl;
		SZ = cond(bh);
		O = false;
		C.u0 = false;
		fn0040D839();
	}
}

// 0040D654: define fn0040D654
// Called from:
//      fn0040D695
//      fn0040D6DD
define fn0040D654
{
	esp = fp;
	Top = null;
	FPUF.u0 = cond(Top->r0000 - Top->r0003);
	Top = (struct Eq_3931 *) &Top->r0000;
	v7 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	SZP = cond(*ebx & ~0x0E);
	C.u0 = false;
	dl = (int8) ((bool) C.u0 + (dl + ah));
	dl <<= cl;
	eax = eax ^ ~0x0137;
	++esi;
	--dl;
	SZO = cond(dl);
	dl >>= cl;
	SCZ = cond(dl);
	bl.u0 = 0x30;
	fn0040D62F();
}

// 0040D695: define fn0040D695
// Called from:
//      fn0040D6C2
//      fn0040DC86
define fn0040D695
{
	esp = fp;
	Top = 0;
	v5 = (ebx & 0x01 << cl) != 0x00;
	ebx = __rcr<word32,byte>(ebx, cl, C);
	ah = dl;
	&esi.u3->u0 = &(esi.u3 + edi / 8)->u0;
	SCZO = cond(esi);
	bh = (byte) &(C.u3 + (bh + 0x08) /8 8)->u0;
	SCZO = cond(bh);
	v14 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	ah += 0x27;
	v15 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	C = v15;
	ah = *edx;
	bl = (byte) &(C.u3 + (bl + ah) /8 8)->u0;
	SCZO = cond(bl);
	--bh;
	SZO = cond(bh);
	if (Test(EQ,Z))
		fn0040D3EA();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(NE,Z))
			fn0040D3EA();
		else
		{
			ecx = *esp;
			++esp;
			if (Test(UGE,C))
			{
				al = *(byte *) 596355165;
				fn0040D654();
			}
			else
			{
				Z = __arpl(*(word16 *) 3279987815, bx, &*(word16 *) 3279987815);
				fn0040D6C4();
			}
		}
	}
}

// 0040D6C2: define fn0040D6C2
// Called from:
//      fn0040D6DD
//      fn0040DC2B
define fn0040D6C2
{
	esp = fp;
	Top = 0;
	bl += 0x9C;
	SCZO = cond(bl);
	fn0040D6C4();
}

// 0040D6C4: define fn0040D6C4
// Called from:
//      fn0040D695
//      fn0040D6C2
define fn0040D6C4
{
	esp = fp;
	Top = 0;
	esp -= 4;
	esp->u1 = (word32) SCZDOP;
	v6 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	dh >>= cl;
	edi += eax;
	--ecx;
	v16 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	v18 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	C = v18;
	++al;
	al = (bool) C + (al + 77);
	SCZO = cond(al);
	edx = edx - ecx - C;
	SCZO = cond(edx);
	if (Test(LE,SZO))
		fn0040D930();
	else
		fn0040D6DD();
}

// 0040D6DD: define fn0040D6DD
// Called from:
//      fn0040D6C2
//      fn0040D6C4
define fn0040D6DD
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(GT,SZO))
		fn0040D930();
	else
	{
		v8 = ebx;
		ebx = eax;
		eax = v8;
		v11 = ecx;
		ecx = eax;
		eax = v11;
		eax = eax - 632603201 - C;
		SCZO = cond(eax);
		fn0040D6ED();
	}
}

// 0040D6ED: define fn0040D6ED
// Called from:
//      fn0040D6DD
//      fn0040D790
//      fn0040DC7E
//      fn0040DDA1
define fn0040D6ED
{
	esp = fp;
	Top = 0;
	ah = 0x25;
	esi <<= cl;
	ebx -= ecx;
	ah -= 177;
	SCZO = cond(ah);
	eax = (word32) ((bool) C + (eax + edx));
	al &= 0xC2;
	SZ = cond(al);
	O = false;
	C.u0 = false;
	fn0040DC7E();
}

// 0040D772: define fn0040D772
// Called from:
//      fn0040D8A4
//      fn0040D8CF
define fn0040D772
{
	esp = fp;
	Top = 0;
	dl = bl;
	v8 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	C = v8;
	fn0040D775();
}

// 0040D775: define fn0040D775
// Called from:
//      fn0040D695
//      fn0040D8A4
define fn0040D775
{
	esp = fp;
	Top = 0;
	v5 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	C = v5;
	__out<word32>(dx, eax);
	dh = dh - ah - C;
	edx |= edi;
	edx >>= cl;
	dh |= 252;
	v17 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	edi -= esi;
	SCZO = cond(edi);
	v19 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	C = v19;
	v20 = eax.u6->dw0010;
	esp -= 4;
	*esp = v20;
	if (Test(ULT,C))
		fn0040DCC3();
	else
		fn0040D790();
}

// 0040D790: define fn0040D790
// Called from:
//      fn0040D775
//      fn0040D8A4
define fn0040D790
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(UGE,C))
		fn0040DCC3();
	else if (Test(LE,SZO))
	{
		--ebx;
		ebx = (word32) ah;
		esi = esi - ebx - C;
		esi |= edi;
		C.u0 = false;
		v19 = (esi & 0x01 << 0x20 - cl) != 0x00;
		esi = __rcl<word32,byte>(esi, cl, C);
		esi >>= cl;
		&edi.u3->u0 = (word32) edi + 1;
		eax >>= 0x10;
		SCZO = cond(eax);
		if (Test(LE,SZO))
			fn0040D3C2();
		else
		{
			edx = edx;
			ebx = ebx;
			if (Test(GT,SZO))
				fn0040D3C2();
			else
			{
				__cli();
				bh >>= 11;
				SCZO = cond(bh);
				fn0040DDA1();
			}
		}
	}
	else
	{
		ecx = *esp;
		++esp;
		ecx >>= cl;
		dl <<= cl;
		SCZO = cond(dl);
		bh = bh - ah - C;
		SCZO = cond(bh);
		--edx;
		SZO = cond(edx);
		ecx = *esp;
		++esp;
		edx = 0x00779054;
		edx = *esp;
		++esp;
		edi >>= cl;
		ch &= dh;
		ebx += ecx;
		edi = edi ^ esi;
		ecx |= ebx;
		C.u0 = false;
		ah = ~0x05;
		eax = (word32) eax + 1;
		ebx = ebx - eax - C;
		edx -= ~0x0196;
		SCZO = cond(edx);
		edi = edi - eax - C;
		bl >>= cl;
		SCZO = cond(bl);
		esi <<= cl;
		SCZO = cond(esi);
		--eax;
		cl = cl - dl - C;
		SCZO = cond(cl);
		ch = ch - 0x1C - C;
		cl <<= cl;
		++ah;
		SZO = cond(ah);
		v42 = (edi & 0x01 << 0x20 - cl) != 0x00;
		edi = __rol<word32,byte>(edi, cl);
		C = v42;
		v43 = (bh & 0x01 << cl) != 0x00;
		bh = __rcr<byte,byte>(bh, cl, C);
		bl >>= cl;
		edi >>= cl;
		SCZ = cond(edi);
		if (Test(OV,O))
			fn0040D5AA();
		else
		{
			edx = edx;
			ebx = ebx;
			if (Test(NO,O))
				fn0040D5AA();
			else
			{
				v44 = edi.u6->dw951FDFAA;
				edi.u6->dw951FDFAA = ebp;
				ebp = v44;
				fn0040D4E9();
			}
		}
	}
}

// 0040D839: define fn0040D839
// Called from:
//      fn0040D62F
//      fn0040D695
define fn0040D839
{
	esp = fp;
	Top = 0;
	__cli();
	bh = bh - 222 - C;
	bl -= 0xC6;
	SCZO = cond(bl);
	fn0040DAC1();
}

// 0040D867: define fn0040D867
// Called from:
//      fn0040DBA4
//      fn0040DDC6
define fn0040D867
{
	esp = fp;
	Top = 0;
	v7 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	bl.u0 = 0x53;
	v10 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	bh = al;
	&bl.u3->u0 = (byte) bl.u0 + 1;
	ah += 226;
	bl <<= cl;
	SCZO = cond(bl);
	v16 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	C = v16;
	if (Test(PE,P))
		fn0040D39D();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(PO,P))
			fn0040D39D();
		else if (Test(GE,SO))
			fn0040D839();
		else
		{
			SCZO = ah;
			fn0040D88B();
		}
	}
}

// 0040D88B: define fn0040D88B
// Called from:
//      fn0040D695
//      fn0040DA5B
//      fn0040DA5D
define fn0040D88B
{
	word32 ecx_24_8_bh;
	ptr32 fp;
	byte al;
	bool C;
	byte bl;
	byte cl;
	&bh.u3->u0 = SLICE(ecx_24_8_bh, byte, 8);
	word24 eax_24_8;
	word32 edx;
	word32 edi;
	Top_3 = 0;
	al_6 = al - 0x14 - (byte) C;
	bl_9 = bl ^ cl;
	eax_13 = SEQ(eax_24_8, al_6);
	bh_eax_55 = SEQ(bh, eax_13);
	al_edx_56 = SEQ(al_17, edx);
	bh_eax_57 = bh_eax_55 + al_edx_56;
	eax_15 = (word32) bh_eax_57;
	bh_19 = SLICE(bh_eax_57, byte, 32);
	al_17 = (byte) eax_15;
	ah_40 = SLICE(eax_15, byte, 8);
	eax_16_16_45 = SLICE(eax_15, word16, 16);
	ecx_23 = ecx_24_8_bh;
	edi_25 = edi - ecx_23 - (word32) (bh_19 < 0x00);
	edi_26 = edi_25 >> bh;
	edx_30 = edx + eax_15;
	SCZO_31 = cond(edx_30);
	C_33.u0 = SLICE(SCZO_31, bool, 1);
	edi_34 = __rcr<word32,byte>(edi_26, bh, C_33);
	bl_36 = bl_9 - 0x01 | 0xA9;
	ecx_37 = SLICE(ecx_24_8_bh, word32, 8);
	v35_60 = SEQ(ah_40, ecx_37) << 0x01;
	ecx_38 = (byte) v35_60;
	ah_44.u1 = SLICE(v35_60, word32, 8);
	eax_46 = SEQ(eax_16_16_45, ah_44, al_17);
	eax_47 = eax_46 + 0x01;
	ecx_48 = ecx_38 & eax_46 + 0x01;
	SZ_49 = cond(ecx_48);
	S_63 = (bool) SZ_49;
	Z_64 = SLICE(SZ_49, bool, 2);
	O_50 = false;
	C_51 = false;
	esp_53 = fp - 8;
	fn0040D5CB();
}

// 0040D8A4: define fn0040D8A4
// Called from:
//      fn0040D51B
//      fn0040D5CB
define fn0040D8A4
{
	esp = fp;
	Top = 0;
	bh &= 110;
	bl <<= cl;
	bl -= bh;
	bh += cl;
	esi -= ebx;
	esi |= edi;
	v15 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	edi >>= cl;
	SCZO.u0 = cond(edi);
	v16 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	v17 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	C = v17;
	if (Test(UGT,CZ))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULE,CZ))
		{
			D = true;
			ebx = (ui32) &(edi->u3 + ebx / 8)->u0;
			SCZO.u0 = cond(ebx);
			Z = __arpl(edx->wFFFFFFF3, bx, &edx->wFFFFFFF3);
			fn0040D8CF();
			return;
		}
	}
	bh >>= cl;
	ah -= 0xCC;
	SCZO.u0 = cond(ah);
	bh.u0 = 0x2D;
	v48 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	ebx <<= cl;
	&edi.u3->u0 = (word32) edi + 1;
	bl |= dl;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	if (Test(LE,SZO))
		fn0040D495();
	else
	{
		edx = edx;
		ebx = ebx;
		if (Test(GT,SZO))
			fn0040D495();
		else
		{
			SCZO.u1 = esp->u1;
			esp = (union Eq_4768 *) ((char *) esp + 4);
		}
	}
}

// 0040D8CF: define fn0040D8CF
// Called from:
//      fn0040D8A4
//      fn0040DAEE
define fn0040D8CF
{
	esp = fp;
	Top = 0;
	edx = edi;
	edi = edi - ebx - C;
	esi = esi ^ edx;
	edx = edx ^ eax;
	bl >>= cl;
	dh = bl;
	edi += eax;
	dh = dh ^ bh;
	eax += ecx;
	esi >>= cl;
	bl += dh;
	esi <<= cl;
	SCZO = cond(esi);
	fn0040D772();
}

// 0040D8F0: define fn0040D8F0
// Called from:
//      fn0040D599
//      fn0040DC2B
define fn0040D8F0
{
	esp = fp;
	Top = 0;
	fn0040D537();
}

// 0040D930: define fn0040D930
// Called from:
//      fn0040D6C2
//      fn0040D6C4
//      fn0040D6DD
define fn0040D930
{
fn0040D930_entry:
	esp = fp
	Top = 0
	v6 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rcl<word32,byte>(ebx, cl, C)
	ah = ah & ~0x48
	edi = edi << cl
	SCZO = cond(edi)
	ebx = ebx + edi + C
	eax = eax << cl
	ecx = ecx >> 0x0F
	eax = eax << cl
	SCZO = cond(eax)
	v16 = (edx & 0x01 << 0x20 - cl) != 0x00
	edx = __rcl<word32,byte>(edx, cl, C)
	edi = edi >> cl
	SCZ = cond(edi)
	v19 = (dh & 0x01 << 0x08 - cl) != 0x00
	dh = __rcl<byte,byte>(dh, cl, C)
	C = v19
	v20 = (ah & 0x01 << cl) != 0x00
	ah = __rcr<byte,byte>(ah, cl, C)
	C = v20
	branch Test(LE,SZO) l0040DA81
l0040D930:
l0040D930:
fn0040D930_exit:
}

// 0040D94B: define fn0040D94B
// Called from:
//      fn0040D953
//      fn0040D972
define fn0040D94B
{
fn0040D94B_entry:
	esp = fp
	Top = 0
	v5 = eax + *eax
	*eax = v5
	v9 = (byte) &(cl.u3 + ebx->bF1B8DD2 /8 8)->u0
	ebx->bF1B8DD2 = v9
	SCZO = cond(v9)
	fn0040D953()
	return
l0040D94B:
l0040D94B:
	fn0040D953()
	return
l0040D94D_thunk_fn0040D953:
l0040D94E:
	edx = edx
	ebx = ebx
	branch Test(GT,SZO) l0040DA81
l0040DA81:
	v14 = (bl & 0x01 << cl) != 0x00
	bl = __rcr<byte,byte>(bl, cl, C)
	eax = eax & ebx
	C.u0 = false
	al = al + cl + C
	esi = esi - 0x01
	dh = dh << cl
	bh = bh ^ al
	ecx = ecx << 0x0F
	dl = dl + al
	esi = esi >> cl
	dh = dh >> cl
	bl = bl & 0x24
	SZ = cond(bl)
	O = false
	C.u0 = false
	fn0040DAFA()
	return
l0040DA98_thunk_fn0040DAFA:
fn0040D94B_exit:
}

// 0040D953: define fn0040D953
// Called from:
//      fn0040D6DD
//      fn0040D94B
define fn0040D953
{
	esp = fp;
	Top = 0;
	ecx->u1 = esp->u1;
	esp = (union Eq_5121 *) ((char *) esp + 4);
	v6 = eax + *eax;
	*eax = v6;
	v10 = edi->b0014 + dh;
	edi->b0014 = v10;
	SCZO = cond(v10);
	fn0040D95A();
}

// 0040D95A: define fn0040D95A
// Called from:
//      fn0040D6DD
//      fn0040D953
define fn0040D95A
{
	esp = fp;
	Top = null;
	--Top;
	*Top = (real64) eax->wD03369EE;
	eax += ebx;
	edx >>= cl;
	dl = dl ^ 0x47;
	esi |= ecx;
	SZ = cond(esi);
	O = false;
	C = false;
	ebx &= eax;
	SZ = cond(ebx);
	O = false;
	C = false;
	fn0040D654();
}

// 0040D971: define fn0040D971
// Called from:
//      fn0040DC2B
//      fn0040DC3D
define fn0040D971
{
	esp = fp;
	Top = 0;
	ah -= 0x32;
	SCZO = cond(ah);
	fn0040D972();
}

// 0040D972: define fn0040D972
// Called from:
//      fn0040D6C2
//      fn0040DC3D
define fn0040D972
{
	esp = fp;
	Top = null;
	al = __in<byte>(dx);
	dl = dl ^ bl;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	if (Test(GT,CZ))
		Top->r0000 = Top->r0002;
	fn0040D94B();
}

// 0040D98C: define fn0040D98C
// Called from:
//      fn0040D5CB
//      fn0040D5EE
define fn0040D98C
{
	esp = fp;
	Top = 0;
	v7 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	ebx <<= cl;
	dh |= ~0x11;
	C.u0 = false;
	dl = dl - bh - C;
	bh |= dh;
	dl -= bl;
	dl -= dh;
	bh += al;
	SCZO = cond(bh);
	edx = (word32) al;
	bl.u0 = ~0x51;
	ebx -= eax;
	SCZO = cond(ebx);
	bl.u0 = ~0x22;
	--ebx;
	SZO = cond(ebx);
	v20 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v20;
	esi >>= cl;
	SCZ = cond(esi);
	v23 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	edi = edi ^ esi;
	bh += 0x4C;
	SCZO = cond(bh);
	v25 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rcl<word32,byte>(esi, cl, C);
	C = v25;
	++edi;
	SZO = cond(edi);
	fn0040D8A4();
}

// 0040DA31: define fn0040DA31
// Called from:
//      fn0040DC3D
//      fn0040DCC3
define fn0040DA31
{
	ptr32 fp;
	byte dl;
	byte al;
	<unknown> Mem0;
	byte bl;
	byte cl;
	byte bh;
	byte ah;
	word32 edi;
	word32 esi;
	word16 ebx_16_16;
	word24 ecx_24_8;
	word32 dwArg00;
	esp_31 = fp;
	Top_32 = 0;
	dl_35 = dl - al;
	edx_37 = dwArg00;
	esp_38 = fp + 4;
	bl_41 = bl >> cl;
	bh_44 = bh - ah;
	SCZO_45 = cond(bh_44);
	C_46 = SLICE(SCZO_45, bool, 1);
	bh_47 = bh_44 + ~0x2A + (byte) (bh_44 < 0x00);
	bl_48 = bl_41 << cl;
	v14_50 = (edi & 0x01 << cl) != 0x00;
	edi_51 = __ror<word32,byte>(edi, cl);
	esi_53 = esi >> cl;
	bl_54 = bl_48 + ~0x22;
	ebx_56 = SEQ(ebx_16_16, bh_47, bl_48 + ~0x22);
	ebx_57 = ebx_56 | dwArg00;
	SZ_58 = cond(ebx_57);
	Z_61 = SLICE(SZ_58, bool, 2);
	O_59 = false;
	C_60 = false;
	ecx_63 = SEQ(ecx_24_8, cl);
	if (ebx_57 == 0x00)
		fn0040D57A();
	else
		fn0040DA4C();
}

// 0040DA4C: define fn0040DA4C
// Called from:
//      fn0040DA31
//      fn0040DC3D
define fn0040DA4C
{
	word32 edx;
	word32 ebx;
	bool Z;
	word32 ecx;
	word32 edi;
	word32 esi;
	byte al;
	bool C;
	<unknown> Mem0;
	Top_3 = 0;
	edx_5 = edx;
	ebx_7 = ebx;
	if (Z)
		fn0040D57A();
	else
	{
		al_23 = al + 0x34 + (byte) C;
		SCZO_24 = cond(al_23);
		C_28.u0 = SLICE(SCZO_24, bool, 1);
		O_40 = SLICE(SCZO_24, bool, 4);
		S_42 = (bool) SCZO_24;
		Z_45 = SLICE(SCZO_24, bool, 2);
		edx->tFFFFFFD3.u0 = (int8) __rcr<byte,byte>(edx->tFFFFFFD3.u0, 0xD1, C_28);
		C_30 = false;
		fn0040DA5D();
	}
}

// 0040DA5B: define fn0040DA5B
// Called from:
//      Win32CrtStartup
define fn0040DA5B
{
	esp = fp;
	Top = 0;
	v5 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rcl<word32,byte>(ecx, cl, C);
	C = v5;
	fn0040DA5D();
}

// 0040DA5D: define fn0040DA5D
// Called from:
//      fn0040DA5B
//      fn0040DC2B
define fn0040DA5D
{
	esp = fp;
	Top = 0;
	dl -= ~0x60;
	bl = bl ^ ch;
	ah -= 0x55;
	SCZO = cond(ah);
	v13 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v13;
	v14 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	C = v14;
	v16 = (al & 0x01 << cl) != 0x00;
	al = __rcr<byte,byte>(al, cl, C);
	C = v16;
	if (Test(PE,P))
		fn0040D88B();
	else
		fn0040DA71();
}

// 0040DA71: define fn0040DA71
// Called from:
//      fn0040DA5B
//      fn0040DA5D
define fn0040DA71
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(PO,P))
		fn0040D88B();
	else
	{
		v8 = (ebx & 0x01 << 0x20 - 0x01) != 0x00;
		ebx = __rcl<word32,byte>(ebx, 0x01, C);
		C = v8;
		fn0040DAEE();
	}
}

// 0040DAC1: define fn0040DAC1
// Called from:
//      fn0040D6DD
//      fn0040D839
define fn0040DAC1
{
	esp = fp;
	Top = 0;
	edi <<= cl;
	dl &= al;
	esi = esi ^ edi;
	v14 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	v16 = (ebx & 0x01 << cl) != 0x00;
	ebx = __ror<word32,byte>(ebx, cl);
	edi >>= cl;
	dl <<= cl;
	edx <<= cl;
	dl &= 0x6C;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	eax = ecx;
	if (Test(GE,SO))
	{
		edx = edx;
		ebx = ebx;
		if (Test(LT,SO))
		{
			esp -= 4;
			*esp = ebp;
			ebp = esp;
			esp -= 20515;
			bh.u0 = 211;
			fn0040DAE3();
			return;
		}
	}
	bh = bh ^ 0x91;
	C.u0 = false;
	v23 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	C = v23;
	edx = esi;
	&dl.u3->u0 = (bool) C.u0 + ((byte) dl + 95);
	&SCZO.u3->u0 = cond(dl);
	ebx = esi;
	bl = bl - 0x19 - C;
	&SCZO.u3->u0 = cond(bl);
	bh |= 0x48;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
l0040D7E3:
	bh |= dl;
	&eax.u3->u0 = &(eax.u3 + (eax.u6)->dw003C / 8)->u0;
	&bl.u3->u0 = (byte) bl + 1;
	dl |= bl;
	C.u0 = false;
	dl = dl - ah - C;
	dl -= cl;
	&SCZO.u3->u0 = cond(dl);
	&bh.u3->u0 = (bool) C.u0 + ((byte) bh.u0 + 0x00D7);
	v27 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	bh = bh ^ ah;
	C.u0 = false;
	bh = bh - ch - C;
	&SCZO.u3->u0 = cond(bh);
	&edx.u3->u0 = (word32) eax + 80;
	&ebx.u3->u0 = (word32) ebx + 1;
	SZO = cond(ebx);
	if (Test(UGE,C))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULT,C))
		{
			v29 = ebx;
			ebx = eax;
			eax = v29;
			__cli();
			v30 = Mem0[edi + 0x00:word32] + edi + C;
			*edi = v30;
			ebp -= ebx.u6->dwFFFFFFD2;
			&SCZO.u3->u0 = cond(ebp);
			al = *((word32) ebx + (uint32) al);
			goto l0040D80E;
		}
	}
	v48 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	C = v48;
l0040D80E:
	bl += dl;
	bh <<= cl;
	bl &= dl;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	ebx = edi;
	v31 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v31;
	if (Test(GE,SO))
	{
		edx = edx;
		ebx = ebx;
		if (Test(LT,SO))
		{
			SCZO = *esp;
			&esp.u3->u0 = (word32) esp + 4;
			return;
		}
	}
	v32 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	ebx <<= cl;
	bl |= 227;
	v33 = *edx;
	esp -= 4;
	*esp = v33;
	bl += al;
	dh >>= cl;
	ebx <<= cl;
	&SCZO.u3->u0 = cond(ebx);
	--dl;
	&bh.u3->u0 = (byte) bh + 1;
	dh = dh + al + C;
	&SCZO.u3->u0 = cond(dh);
	v36 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	C = v36;
	if (Test(NO,O))
	{
		edx = edx;
		ebx = ebx;
		if (Test(OV,O))
		{
			__out<word32>(dx, eax);
			&esi.u3->u0 = (word32) esi + 4;
			v38 = esp;
			esp = eax;
			eax = v38;
			ecx.u0 = 3481334535;
			goto l0040D7E3;
		}
	}
	&dh.u3->u0 = (byte) dh + 0x00D0;
	&SCZO.u3->u0 = cond(dh);
	esp -= 4;
	*esp = ecx;
	dl = dl - ~0x44 - C;
	v39 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	bh = bh ^ ah;
	edx -= edi;
	bl <<= cl;
	edx >>= cl;
	edi = edi ^ edx;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
	if (Test(UGE,C))
	{
		edx = edx;
		ebx = ebx;
		if (Test(ULT,C))
		{
			gs = Mem0[edi + 849208842 + ebp:selector];
			C.u0 = true;
			goto l0040DB59;
		}
	}
	bh = bh ^ cl;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
l0040DB59:
	edx <<= cl;
	edx -= (union Eq_3 *) 0x01;
	bh += dh;
	&SCZO.u3->u0 = cond(bh);
	v41 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	v42 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	C = v42;
	&eax.u3->u0 = (word32) eax + 0x0078;
	fn0040DB65();
}

// 0040DAE3: define fn0040DAE3
// Called from:
//      fn0040DAC1
//      fn0040DC9B
define fn0040DAE3
{
	esp = fp;
	Top = 0;
	esi <<= cl;
	edx |= esi;
	dh &= 0x48;
	C.u0 = false;
	v13 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	edx += ecx;
	SCZO = cond(edx);
	fn0040DAEE();
}

// 0040DAEE: define fn0040DAEE
// Called from:
//      fn0040DA71
//      fn0040DC9B
define fn0040DAEE
{
	esp = fp;
	Top = 0;
	v5 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	C = v5;
	fn0040D8CF();
}

// 0040DAFA: define fn0040DAFA
// Called from:
//      fn0040D6C2
define fn0040DAFA
{
	esp = fp;
	Top = 0;
	bh = bh ^ dh;
	al >>= cl;
	edx = esi;
	ebx -= esi;
	edi >>= cl;
	v16 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	ah <<= cl;
	esi += edx;
	SCZO = cond(esi);
	if (Test(NO,O))
	{
		edx = edx;
		ebx = ebx;
		if (Test(OV,O))
		{
			ecx = ecx - *edi - C;
			SCZO = cond(ecx);
			--ecx;
			if (Test(NE,Z) && ecx != 0x00)
			{
				fn0040DB65();
				return;
			}
			else
			{
				bh &= ah;
				v26 = (edx & 0x01 << 0x20 - cl) != 0x00;
				edx = __rol<word32,byte>(edx, cl);
				edi = esi;
				ebx >>= cl;
				SCZO = cond(ebx);
				if (Test(NS,S))
				{
					edx = edx;
					ebx = ebx;
					if (Test(SG,S))
					{
						esp -= 4;
						esp->u3 = (Eq_3 (*)[]) esi;
						ebx += eax->dwD7D3B106;
						SCZO = cond(ebx);
						fn0040DBA4();
						return;
					}
				}
				v29 = (bh & 0x01 << cl) != 0x00;
				bh = __ror<byte,byte>(bh, cl);
				v30 = (al & 0x01 << 0x08 - cl) != 0x00;
				al = __rol<byte,byte>(al, cl);
				ah >>= cl;
				al |= ~0x29;
				C.u0 = false;
				esp -= 4;
				esp->u3 = (Eq_3 (*)[]) ecx;
				ecx = ecx - edx - C;
				SCZO = cond(ecx);
				bh = bh - 0x08 - C;
				SCZO = cond(bh);
				fn0040D61E();
				return;
			}
		}
	}
	edx >>= cl;
	v20 = *ecx;
	esp -= 4;
	esp->u3 = (Eq_3 (*)[]) v20;
	v21 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	C = v21;
	--edx;
	--bl;
	ah = (int8) ((bool) C + (ah + ch));
	SCZO = cond(ah);
	ebx = ebx + edx + C;
	SCZO = cond(ebx);
	fn0040D5EE();
}

// 0040DB65: define fn0040DB65
// Called from:
//      fn0040DAC1
//      fn0040DAFA
define fn0040DB65
{
	esp = fp;
	Top = 0;
	if (Test(LE,SZO))
		fn0040D547();
	else
		fn0040DB6B();
}

// 0040DB6B: define fn0040DB6B
// Called from:
//      fn0040DAC1
//      fn0040DB65
define fn0040DB6B
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(GT,SZO))
		fn0040D547();
	else
	{
		D = false;
		esp -= 4;
		*esp = ecx;
		++ebx;
		SZO = cond(ebx);
		fnD402F71F();
		fn0040DB7D();
	}
}

// 0040DB7A: define fn0040DB7A
// Called from:
//      fn0040D5CB
define fn0040DB7A
{
}

// 0040DB7D: define fn0040DB7D
// Called from:
//      fn0040D6C2
define fn0040DB7D
{
	esp = fp;
	Top = 0;
}

// 0040DBA4: define fn0040DBA4
// Called from:
//      fn0040DAFA
//      fn0040DDC6
define fn0040DBA4
{
	esp = fp;
	Top = 0;
	bh = ch;
	v7 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	bh = bh ^ ~0x24;
	v12 = (ah & 0x01 << 0x17) != 0x00;
	ah = __ror<byte,byte>(ah, 0x17);
	C = v12;
	bl = bl - 0x8E - C;
	edi |= eax;
	C.u0 = false;
	bl = (bool) C.u0 + (bl + 0x3C);
	SCZO = cond(bl);
	if (Test(EQ,Z))
		fn0040D867();
	else
		fn0040DBBC();
}

// 0040DBBC: define fn0040DBBC
// Called from:
//      fn0040DBA4
//      fn0040DDC6
define fn0040DBBC
{
	esp = fp;
	Top = 0;
	edx = edx;
	ebx = ebx;
	if (Test(NE,Z))
		fn0040D867();
	else
		fn0040DC3D();
}

// 0040DBCD: define fn0040DBCD
// Called from:
//      fn0040D4B0
//      fn0040D8A4
define fn0040DBCD
{
	esp = fp;
	Top = 0;
	fn0040DDA1();
}

// 0040DC1E: define fn0040DC1E
// Called from:
//      fn0040D537
//      fn0040D61E
define fn0040DC1E
{
	esp = fp;
	Top = 0;
	edi <<= cl;
	edi >>= cl;
	SCZO = cond(edi);
	fn0040DC21();
}

// 0040DC21: define fn0040DC21
// Called from:
//      fn0040D790
//      fn0040DC1E
define fn0040DC21
{
	esp = fp;
	Top = 0;
	__out<word32>(dx, eax);
	dl <<= cl;
	SCZO = cond(dl);
	dl = 171;
	fn0040DC2B();
	fn0040DC2B();
}

// 0040DC2B: define fn0040DC2B
// Called from:
//      fn0040DC1E
//      fn0040DC21
define fn0040DC2B
{
	esp = fp;
	Top = 0;
	dh = dh ^ 0x86;
	C.u0 = false;
	cl = cl - 0xD8 - C;
	SCZO = cond(cl);
	cl = cl - bh - C;
	SCZO = cond(cl);
	v11 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	ch >>= cl;
	SCZ = cond(ch);
	v15 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	C = v15;
	v17 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	C = v17;
}

// 0040DC3D: define fn0040DC3D
// Called from:
//      fn0040D695
define fn0040DC3D
{
	esp = fp;
	Top = 0;
	D = true;
}

// 0040DC7E: define fn0040DC7E
// Called from:
//      fn0040D6ED
//      fn0040D790
define fn0040DC7E
{
	esp = fp;
	Top = 0;
	fn0040D6ED();
}

// 0040DC86: define fn0040DC86
// Called from:
//      fn0040D6ED
//      fn0040D790
define fn0040DC86
{
	esp = fp;
	Top = 0;
	esi -= edx;
	edi &= edx;
	bl >>= cl;
	bh = bh ^ ah;
	--esi;
	al += 161;
	SCZO = cond(al);
	fn0040D695();
}

// 0040DC9B: define fn0040DC9B
// Called from:
//      fn0040D569
//      fn0040D6C2
define fn0040DC9B
{
	esp = fp;
	Top = 0;
	fn0040D537();
}

// 0040DCC3: define fn0040DCC3
// Called from:
//      fn0040D775
//      fn0040D8A4
//      fn0040DC9B
define fn0040DCC3
{
	esp = fp;
	Top = 0;
	esi -= edx;
	SCZO = cond(esi);
	dh = dh - 33 - C;
	++bl;
	--edi;
	ebx = ebx ^ ecx;
	C.u0 = false;
	--bh;
	dh = (bool) C.u0 + (dh + ~0x29);
	SCZO = cond(dh);
	ebx = ebx - edx - C;
	bl -= dh;
	ebx = ebx ^ edx;
	dh |= 0x04;
	SZ = cond(dh);
	O = false;
	C.u0 = false;
	fn0040DA31();
}

// 0040DD22: define fn0040DD22
// Called from:
//      fn0040D599
define fn0040DD22
{
	esp = fp;
	Top = 0;
	fn0040DDA1();
}

// 0040DD73: define fn0040DD73
// Called from:
//      fn0040D5AA
//      fn0040D790
define fn0040DD73
{
	esp = fp;
	Top = 0;
	fn0040D5AA();
}

// 0040DDA1: define fn0040DDA1
// Called from:
//      fn0040D488
//      fn0040D4B0
//      fn0040D790
//      fn0040DBCD
//      fn0040DD22
//      fn0040DDA5
define fn0040DDA1
{
	esp = fp;
	Top = 0;
	v6 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	--edi;
	&bl.u3->u0 = (byte) bl + 0x00FF;
	SCZO = cond(bl);
	fn0040DDA5();
}

// 0040DDA5: define fn0040DDA5
// Called from:
//      fn0040D599
//      fn0040DDA1
define fn0040DDA5
{
	esp = fp;
	Top = 0;
}

// 0040DDC6: define fn0040DDC6
// Called from:
//      fn0040D3EA
//      fn0040D695
define fn0040DDC6
{
	esp = fp;
	Top = 0;
	bl -= dl;
	esi >>= cl;
	++bh;
	ah = -ah;
	--bl;
	&ebx.u3->u0 = &(ebx.u3 + edx / 8)->u0;
	SCZO = cond(ebx);
	v15 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	ebx = esi;
	bh |= ch;
	esi = eax;
	bl -= 0x89;
	SCZO = cond(bl);
	v21 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	C = v21;
	fn0040DBA4();
}

