// subject_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__RegOpenKeyA = &g_t3070; // 00403000
<anonymous> * __imp__RegQueryValueW = &g_t307E; // 00403004
<anonymous> * __imp__RegCreateKeyA = &g_t308F; // 00403008
<anonymous> * __imp__RegQueryValueExA = &g_t309F; // 0040300C
<anonymous> * __imp__RegQueryValueExW = &g_t30B2; // 00403010
<anonymous> * __imp__RegCreateKeyExW = &g_t30C5; // 00403014
<anonymous> * __imp__RegOpenKeyExA = &g_t30D7; // 00403018
<anonymous> * __imp__RegEnumKeyW = &g_t30E7; // 0040301C
word32 g_dw40304C = 0x3070; // 0040304C
word32 g_dw403050 = 12414; // 00403050
word32 g_dw403054 = 0x308F; // 00403054
word32 g_dw403058 = 0x309F; // 00403058
word32 g_dw40305C = 0x30B2; // 0040305C
word32 g_dw403060 = 0x30C5; // 00403060
word32 g_dw403064 = 0x30D7; // 00403064
word32 g_dw403068 = 0x30E7; // 00403068
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040108A: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 fp;
	ui32 ebx;
	word32 ebp;
	struct Eq_6 * fs;
	Eq_7 dwArg00;
	struct Eq_8 * edi_8 = __ror<word32,byte>((struct Eq_8 *) ~0x06F0, 0x04);
	struct Eq_8 * edx_13 = __rol<word32,byte>(0x055FF8B9, 0x04);
	struct Eq_35 ** ecx_27 = __ror<word32,byte>((struct Eq_8 *) 0x012FF000, 0x04) + (fp & __rol<word32,byte>(0xE000001F, 0x03)) / 64;
	struct Eq_35 * eax_31 = *ecx_27;
	struct Eq_8 * ecx_106 = ecx_27 & ebx;
	word32 edx_327 = SEQ(SLICE(edx_13, word16, 16), (word16) edx_13 - 0x33);
	do
	{
		--eax_31;
		word16 ax_100 = (word16) eax_31;
		word16 eax_16_16_135 = SLICE(eax_31, word16, 16);
		if (eax_31->dw0000 == edi_8)
		{
			byte dl_325 = (byte) __ror<word32,byte>((struct Eq_8 *) 1020, 0x02);
			while (eax_31[4] != dl_325)
				--ecx_106;
			goto l004010FB;
		}
		ecx_106 += ebx / 64;
	} while (eax_31->dw0000 != edx_327);
	struct Eq_8 * ecx_70 = __rol<word32,byte>(0x20000001, 0x07);
	byte cl_328 = (byte) ecx_70;
	do
	{
		ax_100 = (word16) eax_31 - 0x01;
		eax_16_16_135 = SLICE(eax_31 - 0x01, word16, 16);
		ecx_106 = ecx_70;
	} while (eax_31->bFFFFFFFF != cl_328);
l004010FB:
	Eq_3 edx_122 = fp;
	struct Eq_8 * ecx_111 = __ror<word32,byte>(ecx_106, 0x07);
	Eq_7 edi_115 = dwArg00;
	word32 eax_139 = SEQ(eax_16_16_135, ax_100 - ~0x54);
	do
	{
		&edi_115.u0->dw0000 = (word32) edi_115 + 1;
		edx_122 -= edi_115;
	} while (edi_115.u0->dw0000 != __ror<word32,byte>((struct Eq_8 *) 0x30C0, 0x06));
	struct Eq_112 * esp_146;
	edi_115();
	struct Eq_8 * ecx_190 = *((char *) *fs->ptr0030->ptr000C->ptr001C + 8);
	esp_146->ptrFFFFFFFC = (struct Eq_8 *) 0x4443BBD7;
	esp_146->ptrFFFFFFF8 = ecx_190;
	struct Eq_8 * edi_203 = fn00401478(esp_146->ptrFFFFFFF8, esp_146->ptrFFFFFFFC);
	struct Eq_8 * esi_214 = __rol<word32,byte>(0x60000003, 0x05);
	struct Eq_8 * eax_218 = __rol<word32,byte>(0x36321736, 0x01);
	esp_146->ptrFFFFFFFC = esi_214;
	esp_146->ptrFFFFFFF8 = eax_218;
	esp_146->ptrFFFFFFF4 = __ror<word32,byte>((struct Eq_8 *) 0x6323A373, 0x03);
	esp_146->ptrFFFFFFF0 = esp_146 - 0x0C;
	struct Eq_8 * eax_240;
	edi_203();
	esp_146->ptrFFFFFFF8 = (struct Eq_8 *) 3633639433;
	esp_146->ptrFFFFFFF4 = eax_240;
	esp_146->ptrFFFFFFF8 = fn00401478(esp_146->ptrFFFFFFF4, esp_146->ptrFFFFFFF8);
	struct Eq_8 * eax_272 = esp_146->ptrFFFFFFF8;
	esp_146->ptrFFFFFFF8 = null;
	esp_146->ptrFFFFFFF4 = null;
	esp_146->ptrFFFFFFF0 = 0x00;
	esp_146->dwFFFFFFEC = 12646967;
	esp_146->dwFFFFFFE8 = 1118437288;
	word32 ecx_274 = 0x00;
	word32 edx_280 = 0x00;
	struct Eq_223 * esp_285 = esp_146 - 0x18;
	while (true)
	{
		esp_285->dwFFFFFFFC = 0x0C55;
		word32 edx_299;
		eax_272();
		(*(<anonymous> **) 0x0008CD89)();
	}
}

// 00401478: Register word32 fn00401478(Stack (ptr32 Eq_8) dwArg04, Stack (ptr32 Eq_8) dwArg08)
// Called from:
//      Win32CrtStartup
word32 fn00401478(struct Eq_8 * dwArg04, struct Eq_8 * dwArg08)
{
	int32 edx_12 = dwArg04->dw003C;
	__wait();
	__wait();
	struct Eq_243 * edx_21 = dwArg04 + ((&dwArg04->dw003C + 0x0F)[edx_12 / 64] - ~0x1B) / 64;
	int32 * edx_32 = dwArg04 + edx_21->dw0004 / 64;
	word32 edi_24[] = dwArg04 + edx_21->dw0000 / 64;
	word16 eax_36[] = dwArg04 + edx_21->dw0008 / 64;
	byte * eax_107 = dwArg04 + *edx_32 / 64;
	__wait();
	int32 * edi_103 = edx_32;
	ui32 dwLoc0C_124 = 0x00;
	ui8 dl_112 = 0x00;
	ui24 edx_24_8_115 = 0x00;
	while (true)
	{
		do
		{
			struct Eq_8 * edx_63 = __ror<word32,byte>(SEQ(edx_24_8_115, dl_112 + *eax_107), 0x1D);
			__wait();
			++eax_107;
			dl_112 = (byte) edx_63 ^ 0x3F;
			edx_24_8_115 = SLICE(edx_63, word24, 8) ^ 10481548;
		} while (*eax_107 != 0x00);
		if ((edx_63 ^ ~0x601073C0 ^ dwArg08) == 0x00)
			break;
		__wait();
		++edi_103;
		eax_107 = (byte *) (dwArg04 + *edi_103 / 64);
		__wait();
		++dwLoc0C_124;
		dl_112 = 0x00;
		edx_24_8_115 = 0x00;
	}
	return dwArg04 + edi_24[(uint32) eax_36[dwLoc0C_124]] / 64;
}

