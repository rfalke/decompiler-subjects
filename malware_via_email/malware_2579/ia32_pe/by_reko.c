// subject_rdata_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetModuleHandleA = &g_t2A94C; // 00403000
<anonymous> * __imp__CloseHandle = &g_t2A960; // 00403004
<anonymous> * __imp__GetLastError = &g_t2A96E; // 00403008
<anonymous> * __imp__GetThreadLocale = &g_t2A97E; // 0040300C
<anonymous> * __imp__GetProcAddress = &g_t2A990; // 00403010
<anonymous> * __imp__VirtualAlloc = &g_t2A9A2; // 00403014
<anonymous> * __imp__LoadLibraryA = &g_t2A9B2; // 00403018
<anonymous> * __imp__OLEAUT32.dll_318 = &g_t8000013E; // 00403020
<anonymous> * __imp__DispatchMessageA = &g_t2A9F2; // 00403028
<anonymous> * __imp__TranslateMessage = &g_t2A9DE; // 0040302C
<anonymous> * __imp__GetMessageA = &g_t2A9D0; // 00403030
word32 g_dw403038 = 0x1000; // 00403038
word32 g_dw405378 = 0x00; // 00405378
Eq_388 g_t40537C = // 0040537C
	{
		0x00
	};
Eq_1601 g_t405380 = // 00405380
	{
		null
	};
<anonymous> * g_ptr405384 = null; // 00405384
byte g_b405388 = 55; // 00405388
byte g_b405389 = 0x38; // 00405389
// subject_rdata_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b42A8B8 = 99; // 0042A8B8
word32 g_dw42A914 = 174412; // 0042A914
word32 g_dw42A918 = 0x0002A960; // 0042A918
word32 g_dw42A91C = 174446; // 0042A91C
word32 g_dw42A920 = 174462; // 0042A920
word32 g_dw42A924 = 0x0002A990; // 0042A924
word32 g_dw42A928 = 0x0002A9A2; // 0042A928
word32 g_dw42A92C = 174514; // 0042A92C
word32 g_dw42A934 = 0x8000013E; // 0042A934
word32 g_dw42A93C = 0x0002A9F2; // 0042A93C
word32 g_dw42A940 = 174558; // 0042A940
word32 g_dw42A944 = 174544; // 0042A944
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack (ptr32 Eq_2) dwArg04)
// Called from:
//      fn00401640
void fn00401000(struct Eq_2 * dwArg04)
{
	Eq_3 tLoc8C;
	uint32 dwLoc74;
	dwArg04->dw0000 = (word32) g_b405388;
	tLoc8C.ptr0004 = (char *) &dwArg04->dw0000 + 1;
	tLoc8C.dw0000 = 0x00405389;
	word32 eax_21 = 0x00;
	struct Eq_23 * ecx_165 = (char *) &dwArg04->dw0000 + 1;
	byte * ebp_201 = &g_b405389;
	word32 dwLoc7C_381 = 0x00;
	word32 dwLoc78_382 = 0x00;
	uint32 edx_200 = tLoc8C.dw0008;
l00401044:
	tLoc8C.dw000C = eax_21 - 0x01;
	if (eax_21 == 0x00)
	{
		edx_200 = (word32) *ebp_201;
		++ebp_201;
		tLoc8C.ptr0000 = ebp_201;
		tLoc8C.dw000C = 0x07;
	}
	edx_200 *= 0x02;
	if ((edx_200 >> 0x07 & 0x01) == 0x00)
	{
		ecx_165->b0000 = *ebp_201;
		++ebp_201;
		tLoc8C.ptr0000 = ebp_201;
		++ecx_165;
		goto l004012AD;
	}
	word32 eax_75 = tLoc8C.dw000C;
	tLoc8C.dw000C = eax_75 - 0x01;
	if (eax_75 == 0x00)
	{
		edx_200 = (word32) *ebp_201;
		++ebp_201;
		tLoc8C.ptr0000 = ebp_201;
		tLoc8C.dw000C = 0x07;
	}
	uint32 edx_230 = edx_200 * 0x02;
	tLoc8C.dw0008 = edx_230;
	if ((edx_200 >> 0x07 & 0x01) != 0x00)
	{
		word32 eax_219 = tLoc8C.dw000C;
		tLoc8C.dw000C = eax_219 - 0x01;
		if (eax_219 == 0x00)
		{
			edx_230 = (word32) *ebp_201;
			++ebp_201;
			tLoc8C.ptr0000 = ebp_201;
			tLoc8C.dw000C = 0x07;
		}
		edx_200 = edx_230 * 0x02;
		if ((edx_230 >> 0x07 & 0x01) != 0x00)
		{
			ui32 edi_284 = 0x00;
			word32 dwLoc7C_401 = 0x04;
			do
			{
				word32 eax_291 = tLoc8C.dw000C;
				tLoc8C.dw000C = eax_291 - 0x01;
				if (eax_291 == 0x00)
				{
					edx_200 = (word32) *ebp_201;
					tLoc8C.dw000C = 0x07;
					++ebp_201;
				}
				word32 v19_314 = dwLoc7C_401 - 0x01;
				edx_200 *= 0x02;
				dwLoc7C_401 = v19_314;
				edi_284 = (edx_200 >> 0x07 & 0x01) + edi_284 * 0x02;
			} while (v19_314 != 0x00);
			tLoc8C.ptr0000 = ebp_201;
			if (edi_284 != 0x00)
			{
				ecx_165->b0000 = *(ecx_165 - edi_284);
				++ecx_165;
			}
			else
			{
				ecx_165->b0000 = 0x00;
				++ecx_165;
			}
l004012AD:
			tLoc8C.ptr0004 = ecx_165;
			dwLoc7C_381 = 0x00;
			goto l004012B1;
		}
		uint32 edi_246 = (word32) *ebp_201;
		++ebp_201;
		tLoc8C.ptr0000 = ebp_201;
		ui32 esi_251 = (edi_246 & 0x01) + 0x02;
		if (edi_246 >> 0x01 != 0x00)
		{
			if (esi_251 != 0x00)
			{
				do
				{
					ecx_165->b0000 = *(ecx_165 - (edi_246 >> 0x01));
					++ecx_165;
					--esi_251;
				} while (esi_251 != 0x00);
				tLoc8C.ptr0004 = ecx_165;
				dwLoc74 = edi_246 >> 0x01;
				dwLoc7C_381 = 0x01;
				goto l004012B1;
			}
		}
		else
			dwLoc78_382 = 0x01;
		dwLoc74 = edi_246 >> 0x01;
		dwLoc7C_381 = 0x01;
		goto l004012B1;
	}
	ui32 eax_113;
	word32 eax_102 = fn004015C0(&tLoc8C);
	if (dwLoc7C_381 == 0x00)
	{
		if (eax_102 == 0x02)
		{
			word32 eax_185 = fn004015C0(&tLoc8C);
			ecx_165 = tLoc8C.ptr0004;
			if (eax_185 != 0x00)
			{
				do
				{
					++ecx_165;
					ecx_165->bFFFFFFFF = *(ecx_165 - dwLoc74);
					--eax_185;
				} while (eax_185 != 0x00);
				edx_200 = tLoc8C.dw0008;
				ebp_201 = tLoc8C.ptr0000;
				tLoc8C.ptr0004 = ecx_165;
				dwLoc7C_381 = 0x01;
l004012B1:
				if (dwLoc78_382 != 0x00)
					return;
				eax_21 = tLoc8C.dw000C;
				goto l00401044;
			}
			goto l00401288;
		}
		eax_113 = eax_102 - 0x03;
	}
	else
		eax_113 = eax_102 - 0x02;
	byte * ecx_121 = tLoc8C.ptr0000;
	uint32 eax_125 = (eax_113 << 0x08) + (word32) (*ecx_121);
	tLoc8C.ptr0000 = ecx_121 + 1;
	word32 eax_131 = fn004015C0(&tLoc8C);
	if (eax_125 >= 0x7D00)
		++eax_131;
	if (eax_125 >= 0x0500)
		++eax_131;
	if (eax_125 < 0x80)
		eax_131 += 0x02;
	ecx_165 = tLoc8C.ptr0004;
	if (eax_131 != 0x00)
	{
		do
		{
			ecx_165->b0000 = *(ecx_165 - eax_125);
			++ecx_165;
			--eax_131;
		} while (eax_131 != 0x00);
		tLoc8C.ptr0004 = ecx_165;
	}
	dwLoc74 = eax_125;
l00401288:
	edx_200 = tLoc8C.dw0008;
	ebp_201 = tLoc8C.ptr0000;
	dwLoc7C_381 = 0x01;
	goto l004012B1;
}

// 00401480: Register word32 fn00401480(Stack Eq_388 dwArg04, Stack Eq_388 dwArg08)
// Called from:
//      fn00401640
//      fn00401FC0
word32 fn00401480(Eq_388 dwArg04, Eq_388 dwArg08)
{
	struct Eq_390 * edi_31 = (char *) dwArg04.u2 + ((char *) dwArg04.u2 + (dwArg04.u1)->ptr003C)[0x0078];
	GetModuleHandleA(0x00);
	word32 dwLoc0138_189 = 0x00;
	word32 eax_40[] = (char *) dwArg04.u2 + edi_31->dw001C;
	int32 esi_41[] = (char *) dwArg04.u2 + edi_31->dw0020;
	ui32 dwLoc013C_194 = 0x00;
	if (edi_31->dw0018 > 0x00)
	{
		do
		{
			int32 ecx_50 = esi_41[dwLoc013C_194];
			byte al_52 = dwArg04.u4[ecx_50];
			byte * ecx_53 = (char *) dwArg04.u2 + ecx_50;
			Eq_388 edx_54 = 0x00;
			while (al_52 != 0x00)
			{
				++ecx_53;
				edx_54 = __rol<word32,byte>(edx_54, 0x03) ^ (int32) al_52;
				al_52 = *ecx_53;
			}
			word32 eax_175 = 0x7C;
			word32 ebx_74;
			for (ebx_74 = 0x0F; ebx_74 != 0x00; --ebx_74)
			{
				eax_175 += 0x05;
				if (eax_175 != 0x00)
					eax_175 = 0x06;
			}
			if (edx_54 == dwArg08)
			{
				dwLoc0138_189 = 0x01;
				break;
			}
			++dwLoc013C_194;
		} while (dwLoc013C_194 + 0x01 < edi_31->dw0018);
	}
	word16 ebx_117[] = fn00401980();
	if (dwLoc0138_189 == 0x00)
		return 0x00;
	GetLastError();
	return (char *) dwArg04.u2 + eax_40[(word32) ebx_117[dwLoc013C_194]];
}

// 004015C0: Register ui32 fn004015C0(Register (ptr32 Eq_130) edi)
// Called from:
//      fn00401000
ui32 fn004015C0(struct Eq_130 * edi)
{
	ui32 ebp_14 = 0x01;
	word32 ecx_21 = edi->dw000C;
	uint32 eax_22 = edi->dw0008;
	do
	{
		word32 ecx_25 = ecx_21 - 0x01;
		if (ecx_21 == 0x00)
		{
			byte * ecx_35 = edi->ptr0000;
			eax_22 = (word32) *ecx_35;
			edi->ptr0000 = ecx_35 + 1;
			ecx_25 = ecx_21 + 7;
		}
		ebp_14 = (eax_22 >> 0x07 & 0x01) + ebp_14 * 0x02;
		uint32 eax_51 = eax_22 * 0x02;
		ecx_21 = ecx_25 - 0x01;
		if (ecx_25 == 0x00)
		{
			byte * ecx_62 = edi->ptr0000;
			eax_51 = (word32) *ecx_62;
			edi->ptr0000 = ecx_62 + 1;
			ecx_21 = ecx_25 + 7;
		}
		eax_22 = eax_51 * 0x02;
	} while ((eax_51 >> 0x07 & 0x01) != 0x00);
	edi->dw0008 = eax_22;
	edi->dw000C = ecx_21;
	return ebp_14;
}

// 00401640: Register word32 fn00401640()
// Called from:
//      Win32CrtStartup
word32 fn00401640()
{
	ptr32 fp;
	struct Eq_567 * fs;
	Eq_568 tLoc02D8;
	Eq_569 tLoc02C0;
	word32 dwLoc02D4;
	__align_stack<word32>(fp - 4);
	ui32 ecx_21 = 877;
	ui32 edx_22;
	for (edx_22 = 0x06; edx_22 != 0x00; --edx_22)
	{
		ecx_21 <<= 0x04;
		if (ecx_21 == 0x00)
			ecx_21 = 0x09;
	}
	CloseHandle(0x00);
	struct Eq_2 * edi_55 = fn00401DE0(edx_22);
	GetThreadLocale();
	word16 si_209 = edi_55[((word32) edi_55[0x0F].dw0000 + 22) / 4];
	tLoc02C0 = (Eq_569) 122;
	fn00401D70(&tLoc02D8, &tLoc02C0, 11);
	fn00401480(LoadLibraryA(&tLoc02D8), 3321835334)();
	GetLastError();
	fn00401000(edi_55);
	struct Eq_2 * eax_164 = edi_55;
	word32 ecx_165;
	for (ecx_165 = 0x000147FF; ecx_165 != 0x00; --ecx_165)
	{
		eax_164->dw0000 += 0x5C16;
		++eax_164;
	}
	word32 ecx_176 = 0x6B;
	Eq_388 edx_177;
	for (edx_177 = 11; edx_177 != 0x00; --edx_177)
	{
		ecx_176 -= 0x0A;
		tLoc02D8 = (Eq_568) ecx_176;
		if (ecx_176 == 0x00)
		{
			tLoc02D8 = (Eq_568) 0x06;
			ecx_176 = 0x06;
		}
	}
	GetModuleHandleA(edx_177);
	word32 ebp_205 = Mem197[edi_55 + 60:word32] + edi_55;
	ebp_205->w0016 = si_209;
	word32 esi_211 = ebp_205->dw00A0;
	tLoc02D8 = (Eq_568) ebp_205;
	ebp_205->dw00C0 = dwLoc02D4;
	if (esi_211 != 0x00)
	{
		struct Eq_709 * esi_219 = g_t40537C.u1 + esi_211 / 64;
		GetLastError();
		word32 edx_231 = g_t40537C.u1 - ebp_205->dw0034;
		while (esi_219->dw0000 != 0x00)
		{
			Eq_729 eax_237 = esi_219->t0004.u0;
			word16 * ecx_243 = (char *) &esi_219->t0004 + 4;
			if (eax_237 - 0x08 >> 0x01 > 0x00)
			{
				uint32 edi_246 = eax_237 - 0x08 >> 0x01;
				do
				{
					ui32 eax_249 = (word32) *ecx_243;
					if ((eax_249 & 0xF000) == 0x3000)
					{
						word32 * eax_258 = g_t40537C.u1 + ((eax_249 & 0x0FFF) + esi_219->dw0000) / 64;
						*eax_258 += edx_231;
					}
					++ecx_243;
					--edi_246;
				} while (edi_246 != 0x00);
			}
			esi_219 += esi_219->t0004.u0 / 8;
		}
	}
	if (ebp_205->dw0080 != 0x00)
	{
		GetModuleHandleA(0x00);
		struct Eq_797 * ebp_303 = g_t40537C.u1 + ebp_205->dw0080 / 64;
		while (ebp_303->dw0010 != 0x00)
		{
			Eq_388 eax_313 = LoadLibraryA(g_t40537C.u1 + ebp_303->dw000C / 64);
			if (eax_313 != 0x00)
			{
				word32 edi_321 = ebp_303->dw0000;
				if (edi_321 == 0x00)
					edi_321 = ebp_303->dw0010;
				Eq_388 eax_328 = g_t40537C.u1;
				union Eq_839 * edi_332 = (char *) eax_328.u2 + edi_321;
				word32 * esi_333 = (char *) eax_328.u2 + ebp_303->dw0010;
				Eq_846 eax_334 = edi_332->u1;
				while (eax_334 != 0x00)
				{
					Eq_388 eax_346;
					if (eax_334 < 0x00)
						eax_346.u2 = (word32) edi_332->u0;
					else
						eax_346.u2 = g_t40537C.u1 + ((word32) eax_334 + 2) / 64;
					*esi_333 = (word32) GetProcAddress(eax_313, eax_346);
					edi_332 = (union Eq_839 *) ((char *) edi_332 + 4);
					eax_334 = edi_332->u1;
					++esi_333;
				}
			}
			++ebp_303;
		}
		ebp_205 = (struct Eq_683 *) tLoc02D8;
	}
	g_ptr405384 = (<anonymous> *) (g_t40537C.u1 + ebp_205->dw0028 / 64);
	struct Eq_782 * esi_431 = fs->ptr0030->ptr000C->ptr000C;
	do
		esi_431 = esi_431->ptr0000;
	while (esi_431->t0018.u1 != g_t40537C.u1);
	GetThreadLocale();
	esi_431->ptr001C = g_ptr405384;
	word32 ecx_448;
	for (ecx_448 = 22; ecx_448 != 0x00; --ecx_448)
		;
	return *(word32 *) 0x40;
}

// 00401980: Register word32 fn00401980()
// Called from:
//      fn00401480
word32 fn00401980()
{
	CloseHandle(0x00);
	GetLastError();
	GetModuleHandleA(0x00);
	uint32 ecx_40 = 788;
	Eq_388 edx_41;
	for (edx_41 = 0x09; edx_41 != 0x00; --edx_41)
	{
		ecx_40 >>= 0x07;
		if (ecx_40 == 0x00)
			ecx_40 = 0x08;
	}
	GetModuleHandleA(edx_41);
	GetLastError();
	GetLastError();
	uint32 ecx_639 = 0xBA;
	Eq_388 edx_75;
	for (edx_75 = 0x0A; edx_75 != 0x00; --edx_75)
	{
		ecx_639 >>= 0x01;
		if (ecx_639 == 0x00)
			ecx_639 = 0x00;
	}
	CloseHandle(edx_75);
	up32 eax_104 = 0x01F5;
	Eq_388 edx_106;
	for (edx_106 = 0x30; edx_106 != 0x00; --edx_106)
	{
		if (eax_104 <= 0x00)
			eax_104 = 0x04;
	}
	GetModuleHandleA(edx_106);
	GetModuleHandleA(0x00);
	word32 eax_156;
	for (eax_156 = 0x02; eax_156 != 0x00; --eax_156)
		;
	GetLastError();
	GetThreadLocale();
	GetModuleHandleA(0x00);
	word32 ecx_199;
	for (ecx_199 = 0x08; ecx_199 != 0x00; --ecx_199)
		;
	GetThreadLocale();
	GetLastError();
	CloseHandle(0x00);
	Eq_388 ecx_228;
	for (ecx_228 = 0x14; ecx_228 != 0x00; --ecx_228)
		;
	GetModuleHandleA(ecx_228);
	uint32 ecx_247 = 0x030F;
	Eq_388 edi_248;
	for (edi_248 = 0x09; edi_248 != 0x00; --edi_248)
	{
		uint32 edx_252 = SLICE(ecx_247 *64 0x24924925, word32, 32);
		uint32 ecx_255 = (ecx_247 - edx_252 >> 0x01) + edx_252;
		ecx_247 = ecx_255 >> 0x02;
		if (ecx_255 >> 0x02 == 0x00)
			ecx_247 = 0x02;
	}
	GetThreadLocale();
	CloseHandle(edi_248);
	CloseHandle(edi_248);
	CloseHandle(edi_248);
	uint32 ecx_309 = 0x024E;
	word32 edi_310;
	for (edi_310 = 22; edi_310 != 0x00; --edi_310)
	{
		uint32 edx_314 = SLICE(ecx_309 *64 0x24924925, word32, 32);
		uint32 ecx_317 = (ecx_309 - edx_314 >> 0x01) + edx_314;
		ecx_309 = ecx_317 >> 0x02;
		if (ecx_317 >> 0x02 != 0x00)
			ecx_309 = 0x05;
	}
	GetModuleHandleA(0x00);
	word32 eax_348 = 0x01CC;
	word32 edx_349;
	for (edx_349 = 0x0E; edx_349 != 0x00; --edx_349)
	{
		--eax_348;
		if (eax_348 != 0x00)
			eax_348 = 0x01;
	}
	GetThreadLocale();
	uint32 eax_368 = 900;
	Eq_388 edx_369;
	for (edx_369 = 0x0F; edx_369 != 0x00; --edx_369)
	{
		eax_368 >>= 0x03;
		if (eax_368 == 0x00)
			eax_368 = 0x06;
	}
	CloseHandle(edx_369);
	GetModuleHandleA(0x00);
	word32 ecx_417 = 0x026A;
	Eq_388 edx_418;
	for (edx_418 = 0x0D; edx_418 != 0x00; --edx_418)
	{
		ecx_417 += 0x08;
		if (ecx_417 == 0x00)
			ecx_417 = 0x01;
	}
	CloseHandle(edx_418);
	GetThreadLocale();
	word32 ecx_456 = 0x0160;
	Eq_388 edx_457;
	for (edx_457 = 0x09; edx_457 != 0x00; --edx_457)
	{
		ecx_456 -= 0x06;
		if (ecx_456 == 0x00)
			ecx_456 = 0x01;
	}
	GetModuleHandleA(edx_457);
	GetModuleHandleA(0x00);
	word32 edx_492;
	for (edx_492 = 0x02; edx_492 != 0x00; --edx_492)
		;
	GetLastError();
	word32 edx_521;
	ui32 ecx_522 = 0x0168;
	for (edx_521 = 0x0F; edx_521 != 0x00; --edx_521)
	{
		ui32 ecx_524 = ecx_522 * 0x05;
		ecx_522 = ecx_524 * 0x02;
		if (ecx_524 * 0x02 == 0x00)
			ecx_522 = 0x0A;
	}
	GetThreadLocale();
	Eq_388 ecx_544;
	for (ecx_544 = 0x09; ecx_544 != 0x00; --ecx_544)
		;
	GetModuleHandleA(ecx_544);
	GetLastError();
	CloseHandle(0x00);
	CloseHandle(0x00);
	GetThreadLocale();
	ui32 ecx_602 = 0x0204;
	Eq_388 edx_603;
	for (edx_603 = 0x1D; edx_603 != 0x00; --edx_603)
	{
		ui32 ecx_605 = ecx_602 * 0x02;
		ecx_602 = ecx_605 * 0x04;
		if (ecx_605 * 0x04 == 0x00)
			ecx_602 = 0x08;
	}
	GetModuleHandleA(edx_603);
	return 0x00;
}

// 00401D70: void fn00401D70(Register (ptr32 Eq_618) eax, Register (ptr32 byte) ecx, Register word32 ebx)
// Called from:
//      fn00401640
//      fn00401DE0
//      fn00401FC0
void fn00401D70(CHAR * eax, byte * ecx, word32 ebx)
{
	byte bl = (byte) ebx;
	byte * esi_12 = ecx;
	CHAR * edi_14 = eax;
	cu8 al_15 = *ecx;
	while (al_15 != 0x00)
	{
		ui8 al_32;
		if (al_15 <= 0x5A && al_15 >= 0x41)
			al_32 = (byte) ((int64) ((int32) al_15 - 65 + ebx) % 0x1A) + 0x41;
		else if (al_15 <= 122 && al_15 >= 0x61)
			al_32 = (byte) ((int64) ((int32) al_15 - 97 + ebx) % 0x1A) + 0x61;
		else
			al_32 = al_15 ^ 0x1A - bl;
		*edi_14 = (char) al_32;
		++esi_12;
		al_15 = *esi_12;
		++edi_14;
	}
}

// 00401DE0: Register word32 fn00401DE0(Register ui32 edx)
// Called from:
//      fn00401640
//      fn00401FC0
word32 fn00401DE0(ui32 edx)
{
	ptr32 fp;
	Eq_1313 tLoc58;
	Eq_568 tLoc18;
	ui32 dwLoc01D1;
	word32 dwLoc01D9;
	word32 dwLoc0223;
	word32 dwLoc022C;
	word32 dwLoc0216;
	word16 wLoc0218;
	Eq_1321 dwLocF4;
	word32 dwLoc0101;
	word32 dwLocEF;
	word32 dwLoc02C2;
	ui32 dwLoc8F;
	word16 wLoc28;
	Eq_388 eax_20 = GetModuleHandleA(0x00);
	GetThreadLocale();
	GetLastError();
	tLoc58 = (Eq_1313) 118;
	fn00401D70(&tLoc18, &tLoc58, 0x13);
	Eq_388 eax_76 = LoadLibraryA(&tLoc18);
	word32 v19_84 = (word32) (GetLastError() - dwLocF4) + dwLocEF;
	Eq_878 eax_90 = GetProcAddress(eax_76, 202);
	CloseHandle(0x00);
	CloseHandle(0x00);
	ui32 v10_22 = dwLoc01D1 & eax_20;
	word32 v14_25 = dwLoc01D9 - eax_20;
	ui32 eax_28 = eax_20 & edx;
	<anonymous> * eax_110 = eax_90();
	word32 * ecx_112 = (word32 *) <invalid>;
	word32 * edx_111 = (word32 *) <invalid>;
	ptr32 esp_109 = fp - 0x02E4;
	if (eax_110 == null)
		eax_110();
	word32 esp_165;
	struct Eq_1395 * esp_126 = esp_109 - 4;
	GetModuleHandleA(esp_126->t0000.u4);
	esp_126->t0000.u1 = (DWORD) 0xA7;
	Eq_878 eax_138 = GetProcAddress(esp_126->tFFFFFFFC.u3, esp_126->t0000.u4);
	ui32 v22_142 = dwLoc8F | GetLastError();
	GetThreadLocale();
	esp_126->t0000.u1 = (DWORD) (fp - 40);
	esp_126->tFFFFFFFC.u1 = (DWORD) (fp - 56);
	<anonymous> * eax_166 = OLEAUT32.dll!Ordinal_318(fp - 40, fp - 56, v22_142, 11, 11, fp - 72, eax_76, 0x00);
	if (eax_166 != null)
		eax_166();
	struct Eq_1452 * esp_184 = esp_165 - 4;
	esp_184->ptr0000 = fp - 40;
	esp_184->ptrFFFFFFFC = fp - 56;
	esp_184->ptrFFFFFFF8 = fp - 72;
	<anonymous> * eax_197 = eax_138();
	word32 * ecx_199 = (word32 *) <invalid>;
	word32 * edx_198 = (word32 *) <invalid>;
	word32 * esp_196 = esp_184 - 8;
	if (eax_197 != null)
		eax_197();
	if (wLoc28 != 11)
		eax_197();
	return *esp_196;
}

// 00401F50: Register Eq_388 Win32CrtStartup()
Eq_388 Win32CrtStartup()
{
	ptr32 fp;
	word32 * ebp_7 = fp - 4;
	word32 * esp_11 = fp - 0x0C;
	uint32 ecx_116 = 0x01E5;
	word32 edx_14;
	for (edx_14 = 0x10; edx_14 != 0x00; --edx_14)
	{
		ecx_116 >>= 0x07;
		if (ecx_116 == 0x00)
			ecx_116 = 0x04;
	}
	word32 eax_118 = 400;
	word32 edx_34;
	for (edx_34 = 0x03; edx_34 != 0x00; --edx_34)
	{
		eax_118 -= 0x04;
		if (eax_118 != 0x00)
			eax_118 = 0x00;
	}
	word32 eax_56 = fn00401FC0();
	if (eax_56 != 0x00)
	{
		ebp_7 = fn00401640();
		esp_11 = (word32 *) <invalid>;
	}
	word32 ecx_93 = *esp_11;
	*ebp_7 = 0x00;
	Eq_388 eax_113;
	g_ptr405384();
	return eax_113;
}

// 00401FC0: Register word32 fn00401FC0()
// Called from:
//      Win32CrtStartup
word32 fn00401FC0()
{
	ptr32 fp;
	Eq_568 tLoc10;
	ui32 edx_35;
	word32 esp_32;
	<anonymous> * eax_33 = OLEAUT32.dll!Ordinal_318(fp - 48, fp - 32, fp - 32, fp - 48, fp - 0x0044, 11, 11);
	if (eax_33 != null)
		eax_33();
	if (g_dw405378 != 0x00)
		return 0x01;
	g_dw405378 = 0x01;
	struct Eq_1564 * esp_54 = esp_32 - 4;
	esp_54->t0000.u1 = (DWORD) 4202432;
	fn00401DE0(edx_35);
	g_t40537C.u1 = esp_54->t0000.u1;
	g_t40537C.u0 = 0x00;
	Eq_388 eax_72 = g_t40537C.u1;
	word32 ecx_73 = eax_72.u1->ptr003C;
	Eq_1585 esi_105 = eax_72.u3[(ecx_73 + 80) / 4];
	esp_54->t0000.u1 = (DWORD) 0x40;
	esp_54->tFFFFFFFC.u1 = (DWORD) 0x1000;
	esp_54->tFFFFFFF8 = esi_105;
	esp_54->tFFFFFFF4.u0 = 0x00;
	Eq_1601 eax_87 = VirtualAlloc(esp_54->tFFFFFFF4, esp_54->tFFFFFFF8, esp_54->tFFFFFFFC.u1, esp_54->t0000.u1);
	g_t405380.u0 = (DWORD) eax_87;
	struct Eq_1627 * ecx_77 = (char *) eax_72.u2 + ecx_73;
	struct Eq_1629 * ebx_142 = &g_dw403038;
	if (esi_105 > 0x00)
	{
		Eq_1601 ecx_100 = eax_87;
		Eq_1642 edi_97 = g_t40537C.u1 - eax_87;
		do
		{
			Mem103[ecx_100 + 0x00:byte] = Mem101[edi_97 + ecx_100:byte];
			++ecx_100;
			--esi_105;
		} while (esi_105 != 0x00);
	}
	ptr32 eax_112 = eax_87 - g_t40537C.u1;
	if (g_dw403038 != 0x00)
	{
		do
		{
			word32 edx_119;
			for (edx_119 = 0x17; edx_119 != 0x00; --edx_119)
				Mem132 = Mem118;
			uint32 eax_145 = ebx_142->t0004.u0 - 0x08 >> 0x01;
			word16 * ecx_147 = (char *) &ebx_142->t0004 + 4;
			if (eax_145 != 0x00)
			{
				uint32 edx_149 = eax_145;
				do
				{
					ui32 eax_156 = (word32) *ecx_147;
					if ((eax_156 & 0xF000) == 0x3000)
					{
						word32 * eax_165 = g_t405380.u0 + (eax_156 & 0x0FFF) + ebx_142->dw0000;
						*eax_165 += eax_112;
					}
					++ecx_147;
					--edx_149;
				} while (edx_149 != 0x00);
			}
			ebx_142 += ebx_142->t0004.u0 / 8;
		} while (ebx_142->dw0000 != 0x00);
	}
	esp_54->t0000.u1 = (DWORD) 0x00;
	CloseHandle(esp_54->t0000);
	fn00401D70(&tLoc10, &g_b42A8B8, 0x10);
	esp_54->t0000.u1 = (DWORD) &tLoc10;
	Eq_388 eax_226 = LoadLibraryA(esp_54->t0000.u4);
	esp_54->t0000.u1 = (DWORD) 35392525;
	esp_54->tFFFFFFFC.u1 = (DWORD) eax_226;
	if (fn00401480(esp_54->tFFFFFFFC.u1, esp_54->t0000.u1) == null)
		g_ptr405384 = (<anonymous> *) (g_t405380.u0 + ecx_77->dw0028);
	return 0x00;
}

