// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 edx_16;
	word32 ebp_17;
	word32 eax_18 = fn00401078(out edx_16, out ebp_17);
	Mem25[fp - 0x18 + 0x00:word32] = Mem0[0x00404400:word32];
	Mem27[fp - 0x1C + 0x00:word32] = 0x00402000;
	fn00401133(eax_18, edx_16, ebx, ebp_17, edi, SLICE(ebp, selector, 16));
	Mem37[fp - 0x12 + 0x00:word32] = 0x062E;
	Mem39[fp - 22 + 0x00:word32] = 0x00401133;
	word32 edx_40;
	word32 ebp_41;
	fn00401078(out edx_40, out ebp_41);
	if (false)
	{
		Mem54[fp - 0x12 + 0x00:word32] = 0x00405000;
		Mem56[fp - 22 + 0x00:word32] = 0x00401000;
		lstrcpyA(Mem56[fp - 22 + 0x00:LPSTR], Mem56[fp - 0x12 + 0x00:LPCSTR]);
	}
	return 0x00;
}

// 00401078: Register word32 fn00401078(Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn00401078(ptr32 & edxOut, ptr32 & ebpOut)
{
	word32 edx_9;
	word32 ebp_10;
	return fn00401127(fp - 0x04, out edx_9, out ebp_10);
}

// 004010F1: Register word32 fn004010F1(Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn004010F1(word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
fn004010F1_entry:
	eax = fn00401127(ebp, out edx, out ebp)
	al = (byte) eax (alias)
	return eax
	def edx
	def ebp
	def eax
	def al
	def edxOut
	def ebpOut
l004010F1:
	esp = v3
	eax = Mem0[ebp - 0x04 + 0x00:word32]
	edx = Mem0[ebp + 0x08:word32]
	edx = edx + eax
	eax = Mem0[ebp - 0x04 + 0x00:word32]
	eax = eax + Mem0[ebp + 0x08:word32]
	al = Mem0[eax + 0x00:byte]
	eax = DPB(eax, al, 0) (alias)
	eax = eax - 0x3C
	al = (byte) eax (alias)
	SCZO = cond(eax)
	Mem0[edx + 0x00:byte] = al
	eax = Mem0[ebp - 0x04 + 0x00:word32]
	eax = eax & 0x01
	al = (byte) eax (alias)
	SZO = cond(eax & eax)
	C = false
	eax = fn0040110D(eax, ebp, out edx, out ebp)
	al = (byte) eax (alias)
	return eax
l00401106:
l0040110C_thunk_fn0040110D:
fn004010F1_exit:
	edx_4 = PHI(edx, edx)
	ebp_5 = PHI(ebp, ebp)
	eax_6 = PHI(eax, eax)
	al_7 = PHI(al, al)
	use edx_4 (=> edxOut)
	use ebp_5 (=> ebpOut)
}

// 0040110D: Register word32 fn0040110D(Register word32 eax, Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn0040110D(word32 eax, word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
fn0040110D_entry:
	def fp
	def ebp
	def Mem0
	def eax
	def edxOut
	def ebpOut
	esp_1 = fp
	v4_4 = Mem0[ebp + 0x17:byte] << 0x8B
	Mem5[ebp + 0x17:byte] = v4_4
	SCZO_6 = cond(v4_4)
	eax_10 = fn00401111(eax, ebp, out edx_8, out ebp_9)
	return eax_10
l0040110D:
l0040110D:
	branch Test(NE,Z) l00401127
	goto l00401110
l0040110D_thunk_fn00401111:
l0040110D_thunk_fn00401127:
	eax = fn00401127(ebp, out edx, out ebp)
	return eax
l00401110:
	eax = Mem0[ebp - 0x04 + 0x00:word32]
	eax = fn00401111(eax, ebp, out edx, out ebp)
	return eax
l00401110_thunk_fn00401111:
fn0040110D_exit:
	edx_11 = PHI(edx_8, edx, edx)
	ebp_12 = PHI(ebp_9, ebp, ebp)
	eax_13 = PHI(eax_10, eax, eax)
	use edx_11 (=> edxOut)
	use ebp_12 (=> ebpOut)
}

// 00401111: Register word32 fn00401111(Register word32 eax, Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn00401111(word32 eax, word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
fn00401111_entry:
	def fp
	def ebp
	def Mem0
	def eax
	def edxOut
	def ebpOut
	esp_1 = fp
	ebp_3 = ebp + 0x01
	D_4 = false
	ecx_6 = Mem0[ebp_3 + 0x08:word32]
	ecx_8 = ecx_6 + eax
	eax_9 = Mem0[ebp_3 - 0x04 + 0x00:word32]
	eax_10 = eax_9 + Mem0[ebp_3 + 0x08:word32]
	edx_11 = Mem0[ebp_3 - 0x04 + 0x00:word32]
	dl_12 = (byte) edx_11 (alias)
	al_13 = Mem0[eax_10 + 0x00:byte]
	al_14 = al_13 - dl_12
	SCZO_15 = cond(al_14)
	Mem16[ecx_8 + 0x00:byte] = al_14
	eax_19 = fn00401127(ebp_3, out edx_17, out ebp_18)
	al_20 = (byte) eax_19 (alias)
	return eax_19
l00401111:
l00401111:
	ecx = Mem0[ebp + 0x08:word32]
	ecx = ecx + eax
	eax = Mem0[ebp - 0x04 + 0x00:word32]
	eax = eax + Mem0[ebp + 0x08:word32]
	edx = Mem0[ebp - 0x04 + 0x00:word32]
	dl = (byte) edx (alias)
	al = Mem0[eax + 0x00:byte]
	al = al - dl
	SCZO = cond(al)
	Mem0[ecx + 0x00:byte] = al
l00401123_thunk_fn00401127:
	eax = fn00401127(ebp, out edx, out ebp)
	al = (byte) eax (alias)
	return eax
l00401125_thunk_fn00401127:
fn00401111_exit:
	edx_21 = PHI(edx_17, edx)
	ebp_22 = PHI(ebp_18, ebp)
	eax_23 = PHI(eax_19, eax)
	al_24 = PHI(al_20, al)
	use edx_21 (=> edxOut)
	use ebp_22 (=> ebpOut)
}

// 00401127: Register word32 fn00401127(Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn00401127(word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
	esp = v3;
	eax = ebp - 0x04;
	edx_eax = SEQ(edx, eax);
	v6 = Mem0[eax + 0x00:word32] + 0x01;
	Mem0[eax + 0x00:word32] = v6;
	SZO = cond(v6);
	eax = Mem0[ebp - 0x04 + 0x00:word32];
	edx_eax = SEQ(edx, eax);
	al = (byte) eax;
	SCZO = cond(eax - Mem0[ebp + 0x0C:word32]);
	SO = SCZO;
	if (Test(GE,SO))
	{
		esp = ebp;
		ebp = Mem0[esp + 0x00:word32];
		esp = esp + 0x04;
		return eax;
	}
	else
	{
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x01);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			ecx = Mem0[ebp + 0x08:word32];
			ecx = ecx + eax;
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			edx = Mem0[ebp + 0x08:word32];
			edx = edx + eax;
			al = ~0x00;
			al = ~0x00 ^ Mem0[edx + 0x00:byte];
			SZO = cond(al);
			C = false;
			Mem0[ecx + 0x00:byte] = al;
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x01);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax - 0x01;
			eax = eax & 0x03;
			SZO = cond(eax & eax);
			Z = SZO;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				edx = Mem0[ebp + 0x08:word32];
				edx = edx + eax;
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				eax = eax + Mem0[ebp + 0x08:word32];
				al = Mem0[eax + 0x00:byte];
				eax = DPB(eax, al, 0);
				eax = eax + 0x07;
				al = (byte) eax;
				SCZO = cond(eax);
				Mem0[edx + 0x00:byte] = al;
			}
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x03);
		SZO = SCZO;
		if (Test(LE,SZO))
		{
			eax = fn004010F1(ebp, out edx, out ebp);
			edx_eax = SEQ(edx, eax);
			al = (byte) eax;
			return eax;
		}
		else
		{
			edx = Mem0[ebp - 0x04 + 0x00:word32];
			edx = edx - 0x03;
			eax = 0x03;
			ecx = 0x03;
			eax = edx;
			edx = edx >> 0x1F;
			edx_eax = SEQ(edx, eax);
			v16 = edx_eax;
			edx = (int32) (v16 % 0x03);
			eax = (int32) (v16 / 0x03);
			SZO = cond(edx & edx);
			Z = SZO;
			C = false;
			if (Test(NE,Z))
			{
				eax = fn004010F1(ebp, out edx, out ebp);
				edx_eax = SEQ(edx, eax);
				al = (byte) eax;
				return eax;
			}
			else
			{
				eax = fn004010F1(ebp, out edx, out ebp);
				edx_eax = SEQ(edx, eax);
				al = (byte) eax;
				return eax;
			}
		}
	}
}

// 00401133: void fn00401133(Register word32 eax, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 edi, Stack selector psegArg02)
void fn00401133(word32 eax, word32 edx, word32 ebx, word32 ebp, word32 edi, selector psegArg02)
{
	Mem6[eax + 0x00:word32] = ebx;
	if (SZO)
	{
		if (P)
		{
			word32 edx_81;
			word32 ebp_82;
			fn0040110D(edx - 0x51E000A7, ebp, out edx_81, out ebp_82);
			return;
		}
		else
			return;
	}
	else if (SZO)
	{
		word32 edx_47;
		word32 ebp_48;
		fn004010F1(ebp, out edx_47, out ebp_48);
		return;
	}
	else if (edi < 0x01)
		return;
	else
		__inb(DPB(dx, 0x87, 8));
}

