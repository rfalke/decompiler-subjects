// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw403000 = 0x1000; // 00403000
word32 g_dw405340 = 0x00; // 00405340
Eq_2 g_t405344 = // 00405344
	{
		0x00
	};
Eq_1247 g_t405348 = // 00405348
	{
		null
	};
Eq_2 g_t40534C = // 0040534C
	{
		0x00
	};
byte g_b405350 = 0x59; // 00405350
byte g_b405351 = 0x38; // 00405351
byte g_b409780 = 0x69; // 00409780
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__RegQueryValueA = &g_t21B2; // 00402000
<anonymous> * __imp__GetProcAddress = &g_t2102; // 00402008
<anonymous> * __imp__VirtualAlloc = &g_t2114; // 0040200C
<anonymous> * __imp__CloseHandle = &g_t20E4; // 00402010
<anonymous> * __imp__LoadLibraryA = &g_t2138; // 00402014
<anonymous> * __imp__GetModuleHandleA = &g_t20D0; // 00402018
<anonymous> * __imp__GetCurrentThread = &g_t2124; // 0040201C
<anonymous> * __imp__GetLastError = &g_t20F2; // 00402020
<anonymous> * __imp__GetMessageA = &g_t218C; // 00402028
<anonymous> * __imp__CharNextA = &g_t219A; // 0040202C
<anonymous> * __imp__DispatchMessageA = &g_t2164; // 00402030
<anonymous> * __imp__GetKeyState = &g_t2156; // 00402034
<anonymous> * __imp__TranslateMessage = &g_t2178; // 00402038
word32 g_dw402090 = 0x21B2; // 00402090
word32 g_dw402098 = 0x2102; // 00402098
word32 g_dw40209C = 0x2114; // 0040209C
word32 g_dw4020A0 = 0x20E4; // 004020A0
word32 g_dw4020A4 = 0x2138; // 004020A4
word32 g_dw4020A8 = 0x20D0; // 004020A8
word32 g_dw4020AC = 8484; // 004020AC
word32 g_dw4020B0 = 0x20F2; // 004020B0
word32 g_dw4020B8 = 8588; // 004020B8
word32 g_dw4020BC = 0x219A; // 004020BC
word32 g_dw4020C0 = 8548; // 004020C0
word32 g_dw4020C4 = 0x2156; // 004020C4
word32 g_dw4020C8 = 8568; // 004020C8
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack Eq_2 dwArg04)
// Called from:
//      fn004014A0
void fn00401000(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_4 tLoc0144;
	uint32 dwLoc0130;
	__align_stack<word32>(fp - 4);
	uint32 esi_100 = tLoc0144.dw0008;
	*dwArg04.u4 = g_b405350;
	tLoc0144.ptr0004 = (word32) dwArg04 + 1;
	tLoc0144.ptr0000 = 0x00405351;
	word32 ebx_22 = 0x00;
	struct Eq_35 * edx_173 = (word32) dwArg04 + 1;
	byte * edi_223 = &g_b405351;
	word32 dwLoc0148_434 = 0x00;
	word32 dwLoc0134_435 = 0x00;
	do
	{
		--ebx_22;
		if (ebx_22 == 0x00)
		{
			esi_100 = (word32) *edi_223;
			++edi_223;
			tLoc0144.ptr0000 = edi_223;
			ebx_22 += 7;
		}
		esi_100 *= 0x02;
		if ((esi_100 >> 0x07 & 0x01) != 0x00)
		{
			word32 ebx_226 = ebx_22 - 0x01;
			tLoc0144.dw000C = ebx_226;
			if (ebx_22 == 0x00)
			{
				esi_100 = (word32) *edi_223;
				++edi_223;
				tLoc0144.ptr0000 = edi_223;
				tLoc0144.dw000C = 0x07;
				ebx_226 = 0x07;
			}
			uint32 esi_104 = esi_100 * 0x02;
			tLoc0144.dw0008 = esi_104;
			if ((esi_100 >> 0x07 & 0x01) != 0x00)
			{
				ebx_22 = ebx_226 - 0x01;
				if (ebx_226 == 0x00)
				{
					esi_104 = (word32) *edi_223;
					++edi_223;
					tLoc0144.ptr0000 = edi_223;
					ebx_22 = ebx_226 + 7;
				}
				esi_100 = esi_104 * 0x02;
				if ((esi_104 >> 0x07 & 0x01) != 0x00)
				{
					ui32 ecx_311 = 0x00;
					word32 dwLoc0148_495 = 0x04;
					do
					{
						--ebx_22;
						if (ebx_22 == 0x00)
						{
							esi_100 = (word32) *edi_223;
							++edi_223;
							ebx_22 += 7;
						}
						word32 v29_344 = dwLoc0148_495 - 0x01;
						esi_100 *= 0x02;
						dwLoc0148_495 = v29_344;
						ecx_311 = (esi_100 >> 0x07 & 0x01) + ecx_311 * 0x02;
					} while (v29_344 != 0x00);
					tLoc0144.ptr0000 = edi_223;
					if (ecx_311 != 0x00)
					{
						edx_173->b0000 = *(edx_173 - ecx_311);
						++edx_173;
					}
					else
					{
						edx_173->b0000 = 0x00;
						++edx_173;
					}
					goto l004012B0;
				}
				uint32 ecx_271 = (word32) *edi_223;
				++edi_223;
				tLoc0144.ptr0000 = edi_223;
				ui32 eax_275 = (ecx_271 & 0x01) + 0x02;
				if (ecx_271 >> 0x01 != 0x00)
				{
					if (eax_275 == 0x00)
						goto l004011C4;
					do
					{
						++edx_173;
						edx_173->bFFFFFFFF = *(edx_173 - (ecx_271 >> 0x01));
						--eax_275;
					} while (eax_275 != 0x00);
					tLoc0144.ptr0004 = edx_173;
					dwLoc0130 = ecx_271 >> 0x01;
					dwLoc0148_434 = 0x01;
				}
				else
				{
					dwLoc0134_435 = 0x01;
l004011C4:
					dwLoc0130 = ecx_271 >> 0x01;
					dwLoc0148_434 = 0x01;
				}
				goto l004012B4;
			}
			ui32 eax_121;
			word32 eax_111 = fn00401AC0(&tLoc0144);
			if (dwLoc0148_434 == 0x00)
			{
				if (eax_111 == 0x02)
				{
					word32 eax_193 = fn00401AC0(&tLoc0144);
					edx_173 = tLoc0144.ptr0004;
					if (eax_193 != 0x00)
					{
						do
						{
							++edx_173;
							edx_173->bFFFFFFFF = *(edx_173 - dwLoc0130);
							--eax_193;
						} while (eax_193 != 0x00);
						tLoc0144.ptr0004 = edx_173;
					}
					goto l00401280;
				}
				eax_121 = eax_111 - 0x03;
			}
			else
				eax_121 = eax_111 - 0x02;
			byte * ecx_129 = tLoc0144.ptr0000;
			uint32 eax_133 = (eax_121 << 0x08) + (word32) (*ecx_129);
			tLoc0144.ptr0000 = ecx_129 + 1;
			word32 eax_139 = fn00401AC0(&tLoc0144);
			if (eax_133 >= 0x7D00)
				++eax_139;
			if (eax_133 >= 0x0500)
				++eax_139;
			if (eax_133 < 0x80)
				eax_139 += 0x02;
			edx_173 = tLoc0144.ptr0004;
			if (eax_139 != 0x00)
			{
				do
				{
					edx_173->b0000 = *(edx_173 - eax_133);
					++edx_173;
					--eax_139;
				} while (eax_139 != 0x00);
				tLoc0144.ptr0004 = edx_173;
			}
			dwLoc0130 = eax_133;
l00401280:
			ebx_22 = tLoc0144.dw000C;
			esi_100 = tLoc0144.dw0008;
			edi_223 = tLoc0144.ptr0000;
			dwLoc0148_434 = 0x01;
		}
		else
		{
			edx_173->b0000 = *edi_223;
			++edi_223;
			tLoc0144.ptr0000 = edi_223;
			++edx_173;
l004012B0:
			tLoc0144.ptr0004 = edx_173;
			dwLoc0148_434 = 0x00;
		}
l004012B4:
	} while (dwLoc0134_435 == 0x00);
}

// 00401380: Register word32 fn00401380()
// Called from:
//      fn004014A0
//      fn00401920
word32 fn00401380()
{
	ptr32 fp;
	Eq_353 tLoc14;
	Eq_353 tLoc05;
	byte bLoc38;
	byte bLoc37;
	word32 edx_23;
	for (edx_23 = 0x15; edx_23 != 0x00; --edx_23)
		;
	tLoc05 = (Eq_353) 0x00;
	CharNextA(&tLoc05);
	<anonymous> * edx_53 = fn004018B0(&tLoc14, 0x0A, &g_b409780);
	Eq_383 eax_62 = LoadLibraryA(&tLoc14);
	Eq_2 eax_73 = GetCurrentThread();
	if (eax_73 == 0x00)
		edx_53();
	int32 esi_85;
	for (esi_85 = 0x00; esi_85 < 0x03; ++esi_85)
		;
	word32 ecx_108;
	<anonymous> * eax_107 = fn00401C20(eax_62, 0x021C0C0C, out ecx_108);
	struct Eq_411 * esp_115 = fp - 0xB4;
	do
	{
		struct Eq_414 * esp_119 = esp_115 - 4;
		esp_119->dw0000 = 0x00;
		esp_119->dwFFFFFFFC = 0x00;
		esp_119->dwFFFFFFF8 = 0x00;
		word32 eax_133;
		eax_107();
	} while (eax_133 != 0x00);
	esp_115->dwFFFFFFFC = ~0x00;
	esp_115->dwFFFFFFF8 = ~0x00;
	esp_115->dwFFFFFFF4 = ~0x00;
	word32 ecx_148;
	<anonymous> * eax_149;
	word32 esp_147;
	eax_107();
	if (eax_149 != (<anonymous> *) 0x00EFEF20)
		eax_149();
	GetLastError();
	struct Eq_452 * esp_169 = esp_147 - 4;
	esp_169->t0000.u1 = (DWORD) 3769334729;
	word32 ecx_373;
	<anonymous> * eax_172 = fn00401C20(eax_62, esp_169->t0000.u1, out ecx_373);
	esp_169->t0000.u1 = (DWORD) 0x00;
	esp_169->dwFFFFFFFC = 0x08;
	esp_169->dwFFFFFFF8 = 2172712;
	<anonymous> * eax_195;
	word32 ecx_196;
	eax_172();
	ptr32 esp_193 = esp_169 - 8;
	if (eax_195 != (<anonymous> *) 0x00222728)
		eax_195();
	struct Eq_486 * esp_214 = esp_193 - 4;
	esp_214->t0000.u1 = (DWORD) 2921600904;
	word32 ecx_374;
	<anonymous> * eax_217 = fn00401C20(eax_62, esp_214->t0000.u1, out ecx_374);
	esp_214->t0000.u1 = (DWORD) 0x20;
	esp_214->ptrFFFFFFFC = fp - 56;
	esp_214->dwFFFFFFF8 = 11;
	<anonymous> * eax_235;
	eax_217();
	struct Eq_515 * esp_233 = esp_214 - 8;
	ptr32 ecx_243 = fp - 56;
	if (eax_235 != fp - 56)
		eax_235();
	if (bLoc38 != bLoc37)
		eax_235();
	return esp_233->dw0004;
}

// 004014A0: void fn004014A0(Register ui32 eax)
// Called from:
//      Win32CrtStartup
void fn004014A0(ui32 eax)
{
	ptr32 fp;
	struct Eq_529 * fs;
	Eq_530 tLoc38;
	Eq_353 tLoc28;
	ui32 dwLocA5;
	word32 dwLoc0235;
	word24 nLoc0238;
	word32 dwLoc019A;
	word32 dwLoc40;
	word24 nLoc43;
	word32 dwLoc63;
	word16 wLoc5F;
	word32 dwLoc0260;
	Eq_2 esi_15 = g_t405344.u1;
	ptr32 esp_16 = fp - 0x0274;
	ui32 v10_21 = dwLocA5 | eax;
	Eq_2 eax_24 = GetCurrentThread();
	if (eax_24 == 0x00)
		esi_15();
	struct Eq_555 * esi_45 = fn00401380();
	word32 eax_60 = esi_45->dw003C;
	word32 edx_62 = esi_45[(eax_60 + 0xC0) / 64];
	word16 wLoc14_573 = esi_45[(eax_60 + 22) / 64];
	tLoc38 = (Eq_530) 0x6D;
	fn004018B0(&tLoc28, 0x18, &tLoc38);
	struct Eq_583 * esp_98 = esp_16 - 4;
	esp_98->t0000.u1 = (DWORD) &tLoc28;
	Eq_383 eax_100 = LoadLibraryA(esp_98->t0000.u1);
	esp_98->t0000.u1 = (DWORD) 3321835334;
	word32 ecx_786;
	<anonymous> * eax_105 = fn00401C20(eax_100, esp_98->t0000.u1, out ecx_786);
	esp_98->t0000.u1 = (DWORD) (fp - 16);
	esp_98->dwFFFFFFFC = 0x40;
	esp_98->dwFFFFFFF8 = 0x6200;
	esp_98->ptrFFFFFFF4 = esi_45;
	eax_105();
	esp_98->tFFFFFFF0.u1 = (DWORD) 0x00;
	Eq_383 eax_136 = GetModuleHandleA(esp_98->tFFFFFFF0.u1);
	ptr32 esp_137 = esp_98 - 0x0C;
	if (eax_136 == null)
		(*(fp - 4))();
	struct Eq_643 * esp_161 = esp_137 - 4;
	esp_161->t0000.u1 = (DWORD) esi_15;
	fn00401000(esp_161->t0000.u1);
	Eq_2 eax_173 = esi_15;
	Eq_2 ecx_174;
	for (ecx_174 = 0x187F; ecx_174 != 0x00; --ecx_174)
	{
		eax_173.u3->unused = (int32) (eax_173.u3->unused + 0x4DF4);
		eax_173.u2 = (word32) eax_173 + 4;
	}
	esp_161->t0000.u1 = (DWORD) ecx_174;
	GetModuleHandleA(esp_161->t0000.u1);
	word32 edi_196 = Mem191[esi_15 + 60:word32] + esi_15;
	edi_196->dw00C0 = edx_62;
	word32 eax_198 = edi_196->dw00A0;
	edi_196->w0016 = wLoc14_573;
	if (eax_198 != 0x00)
	{
		struct Eq_706 * esi_206 = eax_198 + g_t405344.u1;
		esp_161->tFFFFFFFC.u1 = (DWORD) (fp - 20);
		CharNextA(esp_161->tFFFFFFFC.u1);
		ptr32 edx_217 = g_t405344.u1 - edi_196->dw0034;
		word32 ecx_219 = 0x0162;
		word32 ebx_220;
		for (ebx_220 = 0x0A; ebx_220 != 0x00; --ebx_220)
		{
			ecx_219 -= 0x03;
			if (ecx_219 != 0x00)
				ecx_219 = 0x03;
		}
		if (esi_206->dw0000 != ebx_220)
		{
			do
			{
				Eq_845 eax_249 = esi_206->t0004.u0;
				word16 * ecx_255 = (char *) &esi_206->t0004 + 4;
				if (eax_249 - 0x08 >> 0x01 > 0x00)
				{
					uint32 dwLoc18_584 = eax_249 - 0x08 >> 0x01;
					do
					{
						ui32 eax_262 = (word32) *ecx_255;
						if ((eax_262 & 0xF000) == 0x3000)
						{
							word32 * eax_271 = (eax_262 & 0x0FFF) + esi_206->dw0000 + g_t405344.u1;
							*eax_271 += edx_217;
						}
						uint32 v30_281 = dwLoc18_584 - 0x01;
						++ecx_255;
						dwLoc18_584 = v30_281;
					} while (v30_281 != 0x00);
				}
				esi_206 += esi_206->t0004.u0 / 8;
			} while (esi_206->dw0000 != 0x00);
		}
	}
	if (edi_196->dw0080 != 0x00)
	{
		esp_161->tFFFFFFFC.u1 = (DWORD) 0x00;
		CloseHandle(esp_161->tFFFFFFFC.u1);
		struct Eq_770 * ebx_311 = edi_196->dw0080 + g_t405344.u1;
		struct Eq_770 * dwLoc14_588 = ebx_311;
		while (ebx_311->dw0010 != 0x00)
		{
			esp_161->tFFFFFFFC.u1 = (DWORD) (ebx_311->dw000C + g_t405344.u1);
			Eq_383 eax_324 = LoadLibraryA(esp_161->tFFFFFFFC.u1);
			if (eax_324 != null)
			{
				word32 ebx_343;
				word32 eax_338 = ebx_311->dw0000;
				if (eax_338 != 0x00)
					ebx_343 = eax_338;
				else
					ebx_343 = ebx_311->dw0010;
				Eq_2 eax_346 = g_t405344.u1;
				union Eq_819 * ebx_351 = (char *) eax_346.u2 + ebx_343;
				Eq_821 eax_353 = ebx_351->u1;
				word32 * esi_352 = (char *) eax_346.u2 + dwLoc14_588->dw0010;
				bool v37_526 = eax_353 >= 0x00;
				while (eax_353 != 0x00)
				{
					Eq_2 edx_362;
					if (!v37_526)
						edx_362.u2 = (word32) ebx_351->u0;
					else
						edx_362 = (word32) eax_353 + 2 + g_t405344.u1;
					esp_161->tFFFFFFFC.u1 = (DWORD) edx_362;
					esp_161->tFFFFFFF8 = eax_324;
					*esi_352 = (word32) GetProcAddress(esp_161->tFFFFFFF8, esp_161->tFFFFFFFC.u1);
					ebx_351 = (union Eq_819 *) ((char *) ebx_351 + 4);
					eax_353 = ebx_351->u1;
					++esi_352;
					v37_526 = eax_353 >= 0x00;
				}
				ebx_311 = dwLoc14_588;
			}
			++ebx_311;
			dwLoc14_588 = ebx_311;
		}
	}
	Eq_2 eax_408 = edi_196->dw0028 + g_t405344.u1;
	g_t40534C.u1 = (DWORD) eax_408;
	esp_161->tFFFFFFFC.u1 = (DWORD) eax_408;
	struct Eq_747 * edi_443 = fs->ptr0030->ptr000C->ptr000C;
	Eq_2 eax_444 = g_t405344.u1;
	do
		edi_443 = edi_443->ptr0000;
	while (edi_443->t0018.u1 != eax_444);
	esp_161->tFFFFFFFC.u1 = (DWORD) (fp - 8);
	CharNextA(esp_161->tFFFFFFFC.u1);
	edi_443->t001C.u1 = g_t40534C.u1;
	word32 ecx_477 = 0x03B3;
	word32 edx_478;
	for (edx_478 = 0x0A; edx_478 != 0x00; --edx_478)
	{
		ecx_477 += 0x02;
		if (ecx_477 == 0x00)
			ecx_477 = 0x01;
	}
}

// 004017A0: void fn004017A0()
// Called from:
//      fn00401380
void fn004017A0()
{
	Eq_976 tLoc1C;
	while (GetMessageA(&tLoc1C, null, 0x00, 0x00) != 0x00)
	{
		TranslateMessage(&tLoc1C);
		DispatchMessageA(&tLoc1C);
	}
}

// 00401800: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	<anonymous> * eax_13 = (<anonymous> *) 0x035E;
	Eq_2 edx_14;
	for (edx_14 = 0x31; edx_14 != 0x00; --edx_14)
	{
		eax_13 -= 0x0A;
		<anonymous> * dwLoc08_156 = eax_13;
		if (eax_13 == null)
		{
			eax_13 = (<anonymous> *) 0x08;
			dwLoc08_156 = (<anonymous> *) 0x08;
		}
		<anonymous> * ecx_25 = dwLoc08_156;
	}
	ptr32 esp_42 = fp - 0x0C;
	if (RegQueryValueA(edx_14, edx_14, edx_14, edx_14) != 0x06)
		(*(fp - 4))();
	word32 eax_54 = fn00401920(ecx_25);
	word16 eax_16_16_149 = SLICE(eax_54, word16, 16);
	if (eax_54 != 0x00)
	{
		int32 * esp_70 = esp_42 - 4;
		*esp_70 = 66;
		uint32 ecx_147 = 0x033B;
		word32 edx_75;
		ui32 eax_150 = SEQ(eax_16_16_149, GetKeyState(*esp_70));
		for (edx_75 = 0x06; edx_75 != 0x00; --edx_75)
		{
			ecx_147 >>= 0x08;
			uint32 dwLoc08_163 = ecx_147;
			if (ecx_147 == 0x00)
			{
				ecx_147 = 0x08;
				dwLoc08_163 = 0x08;
			}
			eax_150 = eax_150 ^ dwLoc08_163;
		}
		fn004014A0(eax_150);
	}
	word32 eax_111 = 0x02D6;
	word32 edx_112;
	for (edx_112 = 0x4C; edx_112 != 0x00; --edx_112)
	{
		eax_111 -= 0x07;
		if (eax_111 == 0x00)
			eax_111 = 0x09;
	}
	return g_t40534C.u1;
}

// 004018B0: Register (ptr32 byte) fn004018B0(Register (ptr32 Eq_376) eax, Register word32 ecx, Register (ptr32 byte) edx)
// Called from:
//      fn00401380
//      fn004014A0
byte * fn004018B0(CHAR * eax, word32 ecx, byte * edx)
{
	word24 edx_24_8_125 = SLICE(edx, word24, 8);
	byte * esi_11 = edx;
	CHAR * edi_13 = eax;
	cu8 al_14 = *edx;
	if (al_14 != 0x00)
	{
		byte cl_92 = (byte) ecx;
		do
		{
			ui8 al_36;
			if (al_14 <= 0x5A && al_14 >= 0x41)
			{
				int32 edx_63 = (int32) ((int64) ((int32) al_14 - 65 + ecx) % 0x1A);
				byte dl_65 = (byte) edx_63;
				al_36 = dl_65 + 0x41;
				edx = SEQ(SLICE(edx_63, word24, 8), dl_65 + 0x41);
			}
			else if (al_14 <= 122 && al_14 >= 0x61)
			{
				int32 edx_49 = (int32) ((int64) ((int32) al_14 - 97 + ecx) % 0x1A);
				byte dl_51 = (byte) edx_49;
				al_36 = dl_51 + 0x61;
				edx = SEQ(SLICE(edx_49, word24, 8), dl_51 + 0x61);
			}
			else
			{
				byte dl_35 = 0x1A - cl_92;
				al_36 = al_14 ^ dl_35;
				edx = SEQ(edx_24_8_125, dl_35);
			}
			*edi_13 = (char) al_36;
			++esi_11;
			edx_24_8_125 = SLICE(edx, word24, 8);
			al_14 = *esi_11;
			++edi_13;
		} while (al_14 != 0x00);
	}
	return edx;
}

// 00401920: Register word32 fn00401920(Register (ptr32 code) ecx)
// Called from:
//      Win32CrtStartup
word32 fn00401920(<anonymous> * ecx)
{
	ptr32 fp;
	word32 dwLoc013B;
	word24 nLoc0137;
	word32 dwLoc9D;
	Eq_1181 dwLoc3D;
	word32 dwLoc47;
	word32 dwLocFA;
	word32 dwLoc0102;
	word32 dwLoc0148;
	Eq_1040 eax_30 = RegQueryValueA(0x00, 0x00, 0x00, 0x00);
	ptr32 esp_31 = fp - 0x0160;
	if (eax_30 != 0x06)
	{
		word32 edx_38;
		ecx();
	}
	if (g_dw405340 != 0x00)
		return 0x01;
	g_dw405340 = 0x01;
	struct Eq_1210 * esp_47 = esp_31 - 4;
	esp_47->t0000.u1 = (DWORD) 0x00401920;
	fn00401380();
	g_t405344.u1 = esp_47->t0000.u1;
	g_t405344.u0 = 0x00;
	Eq_2 ecx_64 = g_t405344.u1;
	word32 eax_65 = *((word32) ecx_64 + 60);
	Eq_1231 esi_66 = ecx_64.u3[(eax_65 + 80) / 4];
	esp_47->t0000.u1 = (DWORD) 0x40;
	esp_47->tFFFFFFFC.u1 = (DWORD) 0x1000;
	esp_47->tFFFFFFF8 = esi_66;
	esp_47->tFFFFFFF4.u0 = 0x00;
	Eq_1247 eax_79 = VirtualAlloc(esp_47->tFFFFFFF4, esp_47->tFFFFFFF8, esp_47->tFFFFFFFC.u1, esp_47->t0000.u1);
	g_t405348.u0 = (byte *) eax_79;
	struct Eq_1273 * eax_69 = (char *) ecx_64.u2 + eax_65;
	struct Eq_1275 * ebx_121 = &g_dw403000;
	if (esi_66 > 0x00)
	{
		Eq_1247 ecx_89 = eax_79;
		int32 eax_90 = g_t405344.u1 - eax_79;
		do
		{
			*ecx_89.u0 = ecx_89.u0[eax_90];
			++ecx_89;
			--esi_66;
		} while (esi_66 != 0x00);
	}
	Eq_1280 edi_105 = eax_79 - g_t405344.u1;
	if (g_dw403000 != 0x00)
	{
		do
		{
			word32 ecx_111;
			for (ecx_111 = 0x0D; ecx_111 != 0x00; --ecx_111)
				;
			uint32 eax_124 = ebx_121->t0004.u0 - 0x08 >> 0x01;
			word16 * ecx_126 = (char *) &ebx_121->t0004 + 4;
			if (eax_124 != 0x00)
			{
				uint32 edx_128 = eax_124;
				do
				{
					ui32 eax_134 = (word32) *ecx_126;
					if ((eax_134 & 0xF000) == 0x3000)
					{
						word32 * eax_143 = g_t405348.u0 + ((eax_134 & 0x0FFF) + ebx_121->dw0000);
						*eax_143 = (word32) edi_105 + *eax_143;
					}
					++ecx_126;
					--edx_128;
				} while (edx_128 != 0x00);
			}
			ebx_121 += ebx_121->t0004.u0 / 8;
		} while (ebx_121->dw0000 != 0x00);
	}
	uint32 ecx_162 = 338;
	Eq_2 edx_163;
	for (edx_163 = 0x0A; edx_163 != 0x00; --edx_163)
		ecx_162 >>= 0x03;
	struct Eq_1364 * esp_194 = esp_31 - 4;
	esp_194->t0000.u1 = (DWORD) edx_163;
	esp_194->tFFFFFFFC.u1 = (DWORD) edx_163;
	esp_194->tFFFFFFF8.u1 = (DWORD) edx_163;
	esp_194->tFFFFFFF4.u1 = (DWORD) edx_163;
	Eq_1040 eax_202 = RegQueryValueA(esp_194->tFFFFFFF4.u1, esp_194->tFFFFFFF8.u1, esp_194->tFFFFFFFC.u1, esp_194->t0000.u1);
	if (eax_202 != 0x06)
	{
		word32 edx_231;
		(*(edi_105 - dwLoc3D))();
	}
	g_t40534C.u1 = g_t405348.u0 + eax_69->dw0028;
	return 0x00;
}

// 00401AC0: Register ui32 fn00401AC0(Register (ptr32 Eq_123) esi)
// Called from:
//      fn00401000
ui32 fn00401AC0(struct Eq_123 * esi)
{
	word32 ecx_17 = esi->dw000C;
	uint32 eax_27 = esi->dw0008;
	ui32 edi_16 = 0x01;
	do
	{
		word32 ecx_19 = ecx_17 - 0x01;
		if (ecx_17 == 0x00)
		{
			byte * ecx_26 = esi->ptr0000;
			eax_27 = (word32) *ecx_26;
			esi->ptr0000 = ecx_26 + 1;
			ecx_19 = ecx_17 + 7;
		}
		edi_16 = (eax_27 >> 0x07 & 0x01) + edi_16 * 0x02;
		uint32 eax_49 = eax_27 * 0x02;
		ecx_17 = ecx_19 - 0x01;
		if (ecx_19 == 0x00)
		{
			byte * ecx_56 = esi->ptr0000;
			eax_49 = (word32) *ecx_56;
			esi->ptr0000 = ecx_56 + 1;
			ecx_17 = ecx_19 + 7;
		}
		eax_27 = eax_49 * 0x02;
	} while ((eax_49 >> 0x07 & 0x01) != 0x00);
	esi->dw000C = ecx_17;
	esi->dw0008 = eax_27;
	return edi_16;
}

// 00401C20: Register word32 fn00401C20(Register Eq_383 ebx, Stack Eq_2 dwArg04, Register out (ptr32 (arr word32)) ecxOut)
// Called from:
//      fn00401380
//      fn004014A0
word32 fn00401C20(Eq_383 ebx, Eq_2 dwArg04, word32 (& ecxOut)
{
	word32 edi_24 = Mem22[Mem16[ebx + 60:word32] + ebx + 0x0078:word32];
	word16 eax_27[] = Mem22[edi_24 + 36 + ebx:word32] + ebx;
	GetProcAddress(null, 0x00);
	struct Eq_1514 * edi_26 = ebx + edi_24 / 4;
	word32 eax_43[] = ebx + edi_26->dw0020 / 4;
	word32 ecx_155[] = ebx + edi_26->dw001C / 4;
	ui32 dwLoc08_174 = 0x00;
	if (edi_26->dw0018 > 0x00)
	{
		do
		{
			byte * ecx_56 = ebx + eax_43[dwLoc08_174] / 4;
			Eq_2 edx_103 = 0x00;
			byte al_62 = *ecx_56;
			while (al_62 != 0x00)
			{
				++ecx_56;
				edx_103 = __rol<word32,byte>(edx_103, 0x03) ^ (int32) al_62;
				al_62 = *ecx_56;
			}
			ecx_155 = (word32 (*)[]) 0x0312;
			word32 esi_82;
			for (esi_82 = 0x52; esi_82 != 0x00; --esi_82)
			{
				word32 (* eax_85)[] = ecx_155 *32 0x07;
				ecx_155 = eax_85;
				if (eax_85 == null)
					ecx_155 = (word32 (*)[]) 0x02;
			}
			if (edx_103 == dwArg04)
			{
				GetLastError();
				word32 eax_130 = ebx + ecx_155[(word32) eax_27[dwLoc08_174]] / 4;
				ecxOut = ecx_155;
				return eax_130;
			}
			++dwLoc08_174;
		} while (dwLoc08_174 + 0x01 < edi_26->dw0018);
	}
	ecxOut = ecx_155;
	return 0x00;
}

