// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

CHAR g_t40402C = 'z'; // 0040402C
word32 g_dw4040B8 = 0x00; // 004040B8
int32 g_dw4040BC = 0; // 004040BC
int32 g_dw4040C0 = 0; // 004040C0
Eq_200 g_t4040C4 = // 004040C4
	{
		0
	};
int32 g_dw4040C8 = 0; // 004040C8
word32 g_dw4040CC = 0x00; // 004040CC
Eq_2 g_t4040D0 = // 004040D0
	{
		
		{
		}
	};
ptr32 g_ptr4040D4 = 0x00; // 004040D4
int32 g_dw4040D8 = 0; // 004040D8
word32 g_dw4040DC = 0x00; // 004040DC
int32 g_dw4040E0 = 0; // 004040E0
Eq_2 g_t4040E4 = // 004040E4
	{
		
		{
		}
	};
word32 g_dw4040E8 = 0x00; // 004040E8
Eq_118 g_t4040EC = // 004040EC
	{
		0
	};
Eq_2 g_t4040F0 = // 004040F0
	{
		
		{
		}
	};
struct Eq_856 * g_ptr4040F4 = null; // 004040F4
<anonymous> * g_ptr4040F8 = null; // 004040F8
Eq_120 g_t4040FC = // 004040FC
	{
		0
	};
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetBkColor = &g_t3544; // 00403000
<anonymous> * __imp__GetTextFaceA = &g_t3534; // 00403004
<anonymous> * __imp__ReadFile = &g_t321A; // 0040300C
<anonymous> * __imp__SetFilePointer = &g_t3226; // 00403010
<anonymous> * __imp__GetFileSize = &g_t3238; // 00403014
<anonymous> * __imp__GetModuleFileNameA = &g_t3246; // 00403018
<anonymous> * __imp__GetStartupInfoA = &g_t325C; // 0040301C
<anonymous> * __imp__GetModuleHandleA = &g_t326E; // 00403020
<anonymous> * __imp__HeapFree = &g_t3282; // 00403024
<anonymous> * __imp__GetProcessHeap = &g_t328E; // 00403028
<anonymous> * __imp__CloseHandle = &g_t320C; // 0040302C
<anonymous> * __imp__VirtualAlloc = &g_t32AC; // 00403030
<anonymous> * __imp__VirtualFree = &g_t32BC; // 00403034
<anonymous> * __imp__UnmapViewOfFile = &g_t32CA; // 00403038
<anonymous> * __imp__MapViewOfFileEx = &g_t32DC; // 0040303C
<anonymous> * __imp__CreateFileMappingA = &g_t32EE; // 00403040
<anonymous> * __imp__GetProcAddress = &g_t3304; // 00403044
<anonymous> * __imp__LoadLibraryA = &g_t3316; // 00403048
<anonymous> * __imp__ExitProcess = &g_t31FE; // 0040304C
<anonymous> * __imp__HeapAlloc = &g_t32A0; // 00403050
<anonymous> * __imp__CreateFileA = &g_t31F0; // 00403054
<anonymous> * __imp__LoadBitmapW = &g_t335C; // 0040305C
<anonymous> * __imp__EnumClipboardFormats = &g_t336A; // 00403060
<anonymous> * __imp__GetMenuDefaultItem = &g_t3382; // 00403064
<anonymous> * __imp__GetDesktopWindow = &g_t3348; // 00403068
<anonymous> * __imp__RegisterClassExA = &g_t33A8; // 0040306C
<anonymous> * __imp__SetMenuInfo = &g_t33BC; // 00403070
<anonymous> * __imp__BroadcastSystemMessageW = &g_t33CA; // 00403074
<anonymous> * __imp__ToAsciiEx = &g_t33E4; // 00403078
<anonymous> * __imp__IsClipboardFormatAvailable = &g_t33F0; // 0040307C
<anonymous> * __imp__EnumDisplaySettingsExA = &g_t340E; // 00403080
<anonymous> * __imp__MoveWindow = &g_t3428; // 00403084
<anonymous> * __imp__SetCursor = &g_t3436; // 00403088
<anonymous> * __imp__EnumThreadWindows = &g_t3442; // 0040308C
<anonymous> * __imp__CharUpperW = &g_t3456; // 00403090
<anonymous> * __imp__LoadAcceleratorsW = &g_t3464; // 00403094
<anonymous> * __imp__CreateWindowExA = &g_t3478; // 00403098
<anonymous> * __imp__RegisterClassA = &g_t348A; // 0040309C
<anonymous> * __imp__LoadCursorA = &g_t349C; // 004030A0
<anonymous> * __imp__LoadIconA = &g_t34AA; // 004030A4
<anonymous> * __imp__DefWindowProcA = &g_t34B6; // 004030A8
<anonymous> * __imp__GetMenuItemInfoW = &g_t34C8; // 004030AC
<anonymous> * __imp__GetMonitorInfoW = &g_t34DC; // 004030B0
<anonymous> * __imp__GetKeyboardType = &g_t34EE; // 004030B4
<anonymous> * __imp__LoadMenuIndirectW = &g_t3500; // 004030B8
<anonymous> * __imp__GetKeyboardLayout = &g_t3514; // 004030BC
<anonymous> * __imp__GetDC = &g_t3340; // 004030C0
<anonymous> * __imp__CopyRect = &g_t3334; // 004030C4
<anonymous> * __imp__SubtractRect = &g_t3398; // 004030C8
word32 g_dw403120 = 13636; // 00403120
word32 g_dw403124 = 0x3534; // 00403124
word32 g_dw40312C = 12826; // 0040312C
word32 g_dw403130 = 0x3226; // 00403130
word32 g_dw403134 = 0x3238; // 00403134
word32 g_dw403138 = 0x3246; // 00403138
word32 g_dw40313C = 12892; // 0040313C
word32 g_dw403140 = 12910; // 00403140
word32 g_dw403144 = 0x3282; // 00403144
word32 g_dw403148 = 12942; // 00403148
word32 g_dw40314C = 12812; // 0040314C
word32 g_dw403150 = 12972; // 00403150
word32 g_dw403154 = 12988; // 00403154
word32 g_dw403158 = 13002; // 00403158
word32 g_dw40315C = 13020; // 0040315C
word32 g_dw403160 = 0x32EE; // 00403160
word32 g_dw403164 = 0x3304; // 00403164
word32 g_dw403168 = 0x3316; // 00403168
word32 g_dw40316C = 0x31FE; // 0040316C
word32 g_dw403170 = 0x32A0; // 00403170
word32 g_dw403174 = 0x31F0; // 00403174
word32 g_dw40317C = 0x335C; // 0040317C
word32 g_dw403180 = 0x336A; // 00403180
word32 g_dw403184 = 0x3382; // 00403184
word32 g_dw403188 = 0x3348; // 00403188
word32 g_dw40318C = 0x33A8; // 0040318C
word32 g_dw403190 = 0x33BC; // 00403190
word32 g_dw403194 = 0x33CA; // 00403194
word32 g_dw403198 = 0x33E4; // 00403198
word32 g_dw40319C = 0x33F0; // 0040319C
word32 g_dw4031A0 = 0x340E; // 004031A0
word32 g_dw4031A4 = 13352; // 004031A4
word32 g_dw4031A8 = 13366; // 004031A8
word32 g_dw4031AC = 0x3442; // 004031AC
word32 g_dw4031B0 = 13398; // 004031B0
word32 g_dw4031B4 = 0x3464; // 004031B4
word32 g_dw4031B8 = 13432; // 004031B8
word32 g_dw4031BC = 0x348A; // 004031BC
word32 g_dw4031C0 = 0x349C; // 004031C0
word32 g_dw4031C4 = 0x34AA; // 004031C4
word32 g_dw4031C8 = 13494; // 004031C8
word32 g_dw4031CC = 13512; // 004031CC
word32 g_dw4031D0 = 13532; // 004031D0
word32 g_dw4031D4 = 0x34EE; // 004031D4
word32 g_dw4031D8 = 0x3500; // 004031D8
word32 g_dw4031DC = 13588; // 004031DC
word32 g_dw4031E0 = 0x3340; // 004031E0
word32 g_dw4031E4 = 0x3334; // 004031E4
word32 g_dw4031E8 = 0x3398; // 004031E8
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      Win32CrtStartup
//      fn00401C70
//      fn00401F00
void fn00401000(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_5 tLoc3C;
	Eq_6 tLoc2C;
	tLoc2C.bottom = (LONG) 0x00197781;
	tLoc2C.left = (LONG) 0x2929;
	g_dw4040E0 <<= 0x55;
	tLoc2C.right = (LONG) 0x0564;
	g_dw4040E0 = g_dw4040D8;
	tLoc2C.top = (LONG) 6444873;
	CopyRect(&tLoc3C, &tLoc2C);
	Eq_2 dwLoc0C_76 = 0x00;
	while (dwLoc0C_76 < dwArg0C)
	{
		Mem61[dwArg04 + dwLoc0C_76:byte] = Mem54[dwArg08 + dwLoc0C_76:byte];
		&dwLoc0C_76.u3->unused = (word32) dwLoc0C_76 + 1;
	}
}

// 004010C0: void fn004010C0(Stack Eq_51 dwArg04, Stack Eq_2 dwArg08, Stack Eq_53 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn004010C0(Eq_51 dwArg04, Eq_2 dwArg08, Eq_53 dwArg0C)
{
	Eq_54 tLoc0134;
	Eq_55 tLoc2C;
	Eq_56 tLoc14;
	int32 dwLoc30;
	word32 dwLoc10;
	g_dw4040C0 = g_dw4040E0 >> ~0x45;
	tLoc0134 = (Eq_54) 0x00;
	g_dw4040E0 = dwLoc30;
	GetTextFaceA(GetDC(GetDesktopWindow()), 0xFF, &tLoc0134);
	if ((word32) tLoc0134 == 0x00)
		g_dw4040E0 = dwLoc30 >> g_dw4040C0;
	if (dwArg0C >= 0x01)
	{
		byte dl_49 = dwArg04->b0000;
		Eq_53 dwLoc0C_214 = 0x01;
		int32 dwLoc1C_215 = 0x00;
		do
		{
			byte cl_57 = Mem54[dwArg04 + dwLoc0C_214:byte];
			dwLoc0C_214 = (word32) dwLoc0C_214 + 1;
			ui32 eax_65 = g_t4040FC.u0 << g_t4040EC.u1;
			if ((word32) cl_57 == (word32) dl_49)
			{
				if ((word32) dwArg04[((word32) dwLoc0C_214 + 1) / 24] == 0x00)
				{
					dwArg08.u5[dwLoc1C_215] = dl_49;
					g_t4040FC.u0 = (int32) (g_t4040EC.u0 << (byte) dwLoc10 * 0x02 >> 0x25);
					++dwLoc1C_215;
					dwLoc0C_214 = (word32) dwLoc0C_214 + 2;
				}
				else
				{
					g_t4040FC.u0 = (int32) (g_t4040EC.u0 *s 0x000BF8FD);
					int32 eax_111 = fn004012B0(&tLoc14, dwArg04 + ((word32) dwLoc0C_214 + 1) / 24) + ((word32) dwLoc0C_214 + 1);
					g_t4040FC.u0 = (int32) (g_t4040EC.u0 + eax_65 + dwLoc10);
					dwLoc0C_214 = fn004012B0(&tLoc2C, dwArg04 + eax_111 / 24) + eax_111;
					up32 dwLoc20_233;
					for (dwLoc20_233 = 0x00; dwLoc20_233 < tLoc14; ++dwLoc20_233)
					{
						dwArg08.u5[dwLoc1C_215] = dwArg08.u5[dwLoc1C_215 - tLoc2C];
						++dwLoc1C_215;
					}
				}
			}
			else
			{
				dwArg08.u5[dwLoc1C_215] = cl_57;
				++dwLoc1C_215;
			}
		} while (dwLoc0C_214 < dwArg0C);
	}
}

// 004012B0: Register word32 fn004012B0(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn004010C0
word32 fn004012B0(ui32 * dwArg04, byte * dwArg08)
{
	int32 dwLoc2C;
	ui32 dwLoc0C_49 = 0x00;
	word32 dwLoc28_50 = 0x00;
	do
	{
		ui32 ecx_15 = (word32) *dwArg08;
		g_t4040EC.u0 = (int32) (g_t4040C4.u0 *s dwLoc2C);
		ui32 ecx_27 = dwLoc0C_49 << 0x07 | ecx_15 & 0x7F;
		++dwArg08;
		dwLoc0C_49 = ecx_27;
		++dwLoc28_50;
	} while ((ecx_15 & 0x80) != 0x00);
	*dwArg04 = ecx_27;
	return dwLoc28_50;
}

// 00401330: Register Eq_220 fn00401330(Stack Eq_74 dwArg04)
// Called from:
//      Win32CrtStartup
Eq_220 fn00401330(Eq_74 dwArg04)
{
	Eq_220 eax_36;
	Eq_220 eax_28 = CreateFileA(dwArg04, 0x80000000, 0x01, null, 0x03, 0x80, null);
	if (eax_28 == (void *) ~0x00)
		eax_36 = null;
	else
		eax_36 = eax_28;
	return eax_36;
}

// 00401390: void fn00401390(Stack (ptr32 Eq_243) dwArg04, Stack byte bArg08, Stack int32 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn00401390(struct _STARTUPINFOA * dwArg04, byte bArg08, int32 dwArg0C)
{
	g_t4040C4.u0 = (int32) LoadBitmapW;
	int32 dwLoc0C_37;
	for (dwLoc0C_37 = 0x00; dwLoc0C_37 < dwArg0C; ++dwLoc0C_37)
		dwArg04[dwLoc0C_37 / 0x0044] = (struct _STARTUPINFOA) bArg08;
}

// 004013E0: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	word32 ebx;
	word32 esi;
	word32 edi;
	struct Eq_263 * fs;
	Eq_264 tLocDC;
	Eq_6 tLocCC;
	Eq_266 tLocBC;
	Eq_2 tLoc84;
	Eq_268 tLoc7C;
	int32 dwLoc24;
	word32 dwLoc0C;
	word32 dwArg08;
	Eq_2 dwArg04;
	word32 dwLoc18;
	int32 edx_23 = 0x000E116E >> (g_t4040EC.u1 + 0x5A) + g_t4040C4.u1;
	g_t4040EC.u0 = (int32) GetMonitorInfoW;
	g_t4040FC.u0 = (int32) GetMenuItemInfoW;
	tLocBC.style = (UINT) 0x00;
	tLocBC.lpfnWndProc = (WNDPROC) DefWindowProcA;
	tLocBC.cbClsExtra = 0x00;
	g_t4040FC.u0 = (int32) (0x000D24CD - edx_23);
	tLocBC.cbWndExtra = 0x00;
	tLocBC.hInstance = (HINSTANCE) GetModuleHandleA(0x00);
	g_t4040FC.u0 = (int32) (g_t4040FC.u0 << g_t4040FC << g_t4040FC);
	tLocBC.hIcon = (HICON) LoadIconA(GetModuleHandleA(0x00), 0x00404000);
	tLocBC.hCursor = (HCURSOR) LoadCursorA(0x00, 0x7F00);
	g_t4040C4.u0 = (int32) (g_t4040EC.u0 *s dwLoc24 + 0x00029170);
	tLocBC.hbrBackground = (HBRUSH) null;
	g_t4040FC.u0 = (int32) (g_t4040C4.u0 + ~0x000AD87F + edx_23 >> 0x7C);
	tLocBC.lpszMenuName = (LPCSTR) null;
	g_t4040FC.u0 = 721557;
	tLocBC.lpszClassName = (LPCSTR) &g_t40402C;
	g_t4040FC.u0 = (int32) (666473 << (byte) dwLoc0C);
	RegisterClassA(&tLocBC);
	if (dwArg08 != 0x01)
		g_dw4040E8 = 0x00;
	else
	{
		g_dw4040E8 = 0x01;
		g_t4040D0.u2 = (DWORD) dwArg04;
	}
	Eq_2 dwLoc30_856;
	CreateWindowExA(0x00, 0x00404044, 0x00404034, 0x01, 340340, 2302297, 808, 0x6873, null, null, GetModuleHandleA(0x00), 0x00);
	g_t4040FC.u0 = (int32) LoadAcceleratorsW;
	if (g_dw4040E8 == 0x00)
		dwLoc30_856 = GetModuleHandleA(0x00);
	else
		dwLoc30_856 = dwArg04;
	tLocCC.bottom = (LONG) 140727345;
	tLocCC.left = (LONG) 0x9736;
	tLocCC.right = (LONG) 0x04497197;
	tLocCC.top = (LONG) 0x0994;
	g_dw4040E0 = g_dw4040BC;
	CopyRect(&tLocDC, &tLocCC);
	g_dw4040C8 = 0x00;
	g_t4040FC.u0 = (int32) CharUpperW;
	word32 ecx_183 = dwLoc30_856 + Mem180[dwLoc30_856 + 60:word32];
	fn00401390(&tLoc7C, 0x00, 0x44);
	tLoc7C.cb = (DWORD) 0x44;
	tLoc7C.lpDesktop = (LPSTR) null;
	GetStartupInfoA(&tLoc7C);
	g_t4040EC.u0 = (int32) EnumThreadWindows;
	if (tLoc7C.lpDesktop == null)
		return 0x00;
	g_t4040C4.u0 = (int32) (988983 - g_t4040FC.u0 - dwLoc0C + g_t4040C4.u0);
	g_dw4040BC = 0x00166D1E;
	Eq_358 eax_228 = LoadCursorA(0x00, 0x00404068);
	if (eax_228 != null)
		SetCursor(eax_228);
	g_t4040EC.u0 = (int32) MoveWindow;
	struct Eq_559 * eax_265 = ecx_183 + 6 + (word32) ecx_183[5] / 4 + ((word32) (ecx_183->t0006).u1 - 0x01) *s 0x0A;
	Eq_74 eax_281 = (uint32) ((uint64) ((word32) ecx_183[0x0F].unused + (eax_265->dw0010 - 1)) /u ecx_183[0x0F]) *s ecx_183[0x0F] + eax_265->dw0014;
	g_t4040FC.u0 = (int32) EnumDisplaySettingsExA;
	fn00402690(0x0200);
	int32 dwLoc28_884 = 2255859;
	if (eax_281 == 0x00)
		return 0x00;
	g_t4040C4.u0 = (int32) IsClipboardFormatAvailable;
	GetModuleFileNameA(dwLoc30_856, eax_281, 0x0200);
	g_dw4040BC = 4287546642;
	Eq_358 eax_318 = LoadCursorA(0x00, 0x00404090);
	if (eax_318 != null)
	{
		SetCursor(eax_318);
		dwLoc28_884 = 6303100;
	}
	g_dw4040BC = dwLoc28_884 *s dwLoc28_884 << (byte) dwLoc28_884;
	Eq_220 eax_354 = fn00401330(eax_281);
	if (eax_354 == null)
		return 0x00;
	int32 edx_368 = g_t4040FC.u0 >> g_t4040C4.u1 *s ~0x09 + 0x9A;
	g_t4040FC.u0 = (int32) ToAsciiEx;
	Eq_2 eax_379 = GetFileSize(eax_354, null) - eax_281;
	g_t4040EC.u0 = (int32) BroadcastSystemMessageW;
	if (eax_379 == 0x00)
		return 0x00;
	fn00402690(eax_379.u9.u0 + 4);
	if (eax_379 == ~0x0F)
		return 0x00;
	SetFilePointer(eax_354, eax_281, null, 0x00);
	if (ReadFile(eax_354, eax_379.u9.u0 + 4, eax_379, &tLoc84, null) == 0x00 || tLoc84 != eax_379)
		return 0x00;
	g_t4040EC.u0 = (int32) SetMenuInfo;
	g_t4040FC.u0 = (int32) (0x0005A588 << (byte) edx_368 >> g_t4040EC.u1 *s (byte) edx_368);
	CloseHandle(eax_354);
	g_t4040C4.u0 = (int32) RegisterClassExA;
	if (tLoc84 != eax_379)
		return 0x00;
	g_t4040EC.u0 = (int32) SubtractRect;
	fn00401000(eax_379.u9.u0 + 4, eax_379 * 0x02 - 0x30, 0x40);
	g_t4040EC.u0 = (int32) GetMenuDefaultItem;
	int32 dwLoc28_932 = dwLoc28_884;
	if (GetBkColor((struct HDC__ *) 0x0015C561) == ~0x00)
	{
		g_dw4040BC = g_dw4040C8 - 0x00505D23;
		dwLoc28_932 = dwLoc28_884 << g_dw4040E0 + g_dw4040D8;
	}
	g_dw4040D8 = dwLoc28_932 - g_dw4040C8 << ~0x79;
	Eq_53 edx_508 = eax_379.u9.u0[4];
	g_t4040C4.u0 = (int32) EnumClipboardFormats;
	g_dw4040D8 = dwLoc28_932 *s 4383850;
	GetBkColor((struct HDC__ *) 0x9963) != ~0x00;
	Eq_2 edx_534 = *((word32) eax_379 + 20);
	Eq_53 dwLoc10_945 = 0x00;
	while (dwLoc10_945 < edx_508)
	{
		Mem734[eax_379 + 0x10 + dwLoc10_945 + 8:word32] = Mem538[eax_379 + 0x10 + dwLoc10_945 + 8:word32] ^ 3322;
		dwLoc10_945 = (word32) dwLoc10_945 + 8;
	}
	fn00402690(edx_534);
	g_t4040E4.u2 = (DWORD) edx_534;
	if (g_t4040E4.u2 != 0x00)
	{
		struct Eq_839 * ebp_626;
		fn004010C0((word32) eax_379 + 24, g_t4040E4.u2, edx_508);
		ui32 edx_582 = 0x000157CC << g_t4040C4.u1;
		g_t4040EC.u0 = (int32) (g_t4040C4.u0 << g_t4040FC);
		g_ptr4040F4 = 24;
		g_dw4040CC = edi;
		g_dw4040B8 = esi;
		g_dw4040DC = ebx;
		g_ptr4040D4 = fp - 4;
		g_t4040FC.u0 = (int32) (dwLoc18 - 971343 - ((0x00 >> (byte) edx_582) >> ~0x22));
		if (g_dw4040E8 != 0x00)
			ebp_626 = fn00401C70(0x00401B9A - g_t4040D0.u2);
		else
			ebp_626 = fn00401C70(0x00401B9A - GetModuleHandleA(0x00));
		if (fn00401F00(g_t4040E4.u2) != 0x00)
		{
			g_t4040EC.u0 = (int32) (g_t4040EC.u0 >> ebp_626->b0010 >> ebp_626->b0014);
			g_t4040FC.u0 = (int32) (g_t4040C4.u0 - 585083);
			g_t4040FC.u0 = (int32) (ebp_626->dwFFFFFFF8 << ~0x36);
			Eq_120 edx_693 = 0x0A7D << ebp_626->b0010 *s ebp_626->b0020;
			g_t4040FC.u0 = (int32) edx_693;
			Eq_118 ecx_701 = g_t4040EC.u0;
			int32 eax_703 = g_t4040FC.u0 << ebp_626->b0008 >> (byte) ecx_701;
			ebp_626->dwFFFFFFEC = eax_703;
			word32 eax_709;
			g_ptr4040F8();
			return eax_709;
		}
		else
		{
			fn00402650(g_t4040E4.u2);
			ExitProcess(0x00582353);
		}
	}
	else
		ExitProcess(0x01795716);
}

// 00401C70: Register word32 fn00401C70(Stack ptr32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401C70(ptr32 dwArg04)
{
	ptr32 fp;
	word32 ebp;
	int32 dwLoc2C;
	word32 dwLoc1C;
	ui32 dwLoc20;
	Eq_2 dwLoc3C_209;
	g_t4040EC.u0 = (int32) GetKeyboardLayout;
	g_t4040C4.u0 = (int32) LoadMenuIndirectW;
	if (g_dw4040E8 != 0x00)
		dwLoc3C_209.u2 = g_t4040D0.u2;
	else
		dwLoc3C_209 = GetModuleHandleA(0x00);
	if (dwLoc3C_209 == 0x00)
		return ebp;
	g_t4040C4.u0 = (int32) GetKeyboardType;
	g_t4040C4.u0 = (int32) (g_t4040EC.u0 *s dwLoc2C *s 0x00059D4E);
	word32 eax_37 = dwLoc3C_209 + Mem34[dwLoc3C_209 + 60:word32];
	g_t4040F0.u2 = (DWORD) VirtualAlloc(0x00, eax_37[20], 0x3000, 0x40);
	if (g_t4040F0.u2 == 0x00)
		return ebp;
	int32 eax_57 = g_t4040FC.u0 *s 0x00011679 + g_t4040C4.u0;
	fn00401000(g_t4040F0.u2, dwLoc3C_209, eax_37[20]);
	word32 edx_78 = g_t4040F0.u2 - dwLoc3C_209;
	if (Mem79[eax_37 + 0xA4:word32] != 0x00)
	{
		word32 dwLoc14_224 = dwLoc3C_209 + Mem79[eax_37 + 0xA0:word32];
		while (dwLoc14_224[1] != 0x00)
		{
			int32 eax_118 = g_t4040FC.u0 + 943420 + eax_57;
			Eq_1059 edx_123 = dwLoc14_224[1] - 0x08 >> 0x01;
			Eq_1067 dwLoc38_238 = dwLoc14_224 + 2;
			dwLoc2C = eax_57 *s 705902 + 323394;
			Eq_1059 dwLoc0C_240 = 0x00;
			while (dwLoc0C_240 < edx_123)
			{
				dwLoc20 = eax_118 *s 0x000A3BFB << (byte) dwLoc20 << ~0x7C;
				if ((word32) *((word32) dwLoc38_238 + dwLoc0C_240 * 0x02) >> 0x0C == 0x03)
					(g_t4040F0.u2 + (dwLoc14_224->unused).u0)[((word32) *((word32) dwLoc38_238 + dwLoc0C_240 * 0x02) & 0x0FFF) / 4] += edx_78;
				dwLoc0C_240 = (word32) dwLoc0C_240.u1 + 1;
			}
			dwLoc14_224 += Mem139[dwLoc14_224 + 4:word32];
		}
	}
	<anonymous> * eax_102 = dwArg04 + g_t4040F0.u2;
	word32 edx_113;
	eax_102();
	return fp - 4;
}

// 00401F00: Register word32 fn00401F00(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401F00(Eq_2 dwArg04)
{
	int32 dwLoc20;
	int32 dwLoc24;
	word32 dwLoc08;
	int32 dwLoc30;
	word32 eax_209;
	word32 edx_16 = dwArg04 + Mem13[dwArg04 + 60:word32];
	struct Eq_1140 * dwLoc2C_684 = &edx_16->w0014 + 2 + (word32) edx_16->w0014 / 84;
	Eq_2 eax_33 = VirtualAlloc(0x00, edx_16->t0050.u2, 0x3000, 0x40);
	if (eax_33 != 0x00)
	{
		g_t4040C4.u0 = (int32) (0x00 << (byte) dwLoc20 - g_t4040C4.u1);
		fn00401000(eax_33, dwArg04, (word32) dwArg04.u9.u1[3].dw003C + 252 + (word32) edx_16->w0006 *s 0x28);
		up32 dwLoc10_694;
		for (dwLoc10_694 = 0x00; dwLoc10_694 < (word32) edx_16->w0006; ++dwLoc10_694)
		{
			g_t4040FC.u0 = 0x00;
			if (dwLoc2C_684->dw0014 != 0x00 && dwLoc2C_684->dw0010 != 0x00)
				fn00401000(eax_33 + Mem632[dwLoc2C_684 + 0x0C:word32], dwArg04 + Mem627[dwLoc2C_684 + 20:word32], CONVERT(CONVERT(Mem605[dwLoc2C_684 + 16:word32] - 1 + Mem605[edx_16 + 60:word32], word32, uint64) /u Mem605[edx_16 + 60:word32], word32, uint32) *s Mem605[edx_16 + 60:word32]);
			g_t4040FC.u0 = (int32) (g_t4040FC.u0 *s dwLoc30);
			++dwLoc2C_684;
		}
		word32 edx_78 = eax_33 + Mem75[eax_33 + 60:word32];
		word32 dwLoc54_700 = eax_33 + Mem79[edx_78 + 0x80:word32];
		while (dwLoc54_700.u0[4] != 0x00)
		{
			word32 eax_466 = GetModuleHandleA(eax_33 + Mem86[dwLoc54_700 + 0x0C:word32]);
			Eq_2 dwLoc18_829 = eax_466;
			if (eax_466 == 0x00)
			{
				if (g_dw4040E8 != 0x00)
				{
					eax_209 = 0x00;
					return eax_209;
				}
				word32 eax_482 = LoadLibraryA(eax_33 + Mem468[dwLoc54_700 + 0x0C:word32]);
				dwLoc18_829 = eax_482;
				dwLoc20 = g_t4040C4.u0 *s 0x000E3550 *s dwLoc24;
				if (eax_482 == 0x00)
				{
					eax_209 = 0x00;
					return eax_209;
				}
			}
			Eq_1263 dwLoc40_838;
			Eq_1264 dwLoc28_837;
			dwLoc30 = g_t4040FC.u0 << (byte) dwLoc24 + g_t4040EC.u1;
			if (dwLoc54_700.u1->t0000.u0 != 0x00)
			{
				dwLoc28_837 = eax_33 + Mem498[dwLoc54_700 + 0x00:word32];
				dwLoc40_838 = eax_33 + Mem514[dwLoc54_700 + 16:word32];
			}
			else
			{
				dwLoc28_837 = eax_33 + Mem498[dwLoc54_700 + 16:word32];
				dwLoc40_838 = eax_33 + Mem505[dwLoc54_700 + 0x00:word32];
			}
			word32 dwLoc14_841 = 0x00;
			if (dwLoc54_700.u0[4] != 0x00 && ((dwLoc54_700.u1)->t0000).u0 != 0x00)
				dwLoc14_841 = 0x01;
			while (dwLoc28_837.u1->t0000.u0 != 0x00)
			{
				dwLoc30 = g_t4040C4.u0 - dwLoc20;
				if ((dwLoc28_837.u1->t0000.u0 & 0x80000000) != 0x00)
					dwLoc28_837.u1->t0000.u0 = (struct Eq_1911 *) GetProcAddress(dwLoc18_829, dwLoc28_837.u1->t0000.u0 & 0x7FFFFFFF);
				else
					Mem561[dwLoc28_837 + 0x00:word32] = GetProcAddress(dwLoc18_829, Mem540[dwLoc28_837 + 0x00:word32] + 2 + eax_33);
				if (dwLoc28_837.u1->t0000.u0 == 0x00)
				{
					eax_209 = 0x00;
					return eax_209;
				}
				if (dwLoc14_841 != 0x00)
					dwLoc40_838.u1->t0000.u0 = dwLoc28_837.u1->t0000.u0;
				dwLoc28_837 += 0x04;
				dwLoc40_838 += 0x04;
			}
			dwLoc54_700 += 0x14;
		}
		if (g_dw4040E8 != 0x00)
		{
			ptr32 ecx_94 = g_t4040D0.u2 - ((edx_78.u0)->t0034).u2;
			if (edx_78.u0->dw00A4 != 0x00)
			{
				word32 dwLoc1C_705 = eax_33 + Mem95[edx_78 + 0xA0:word32];
				while (dwLoc1C_705.u0[1] != 0x00)
				{
					uint32 ecx_413 = dwLoc1C_705.u0[1] - 0x08 >> 0x01;
					word32 dwLoc4C_816 = dwLoc1C_705 + 0x08;
					uint32 dwLoc10_817;
					for (dwLoc10_817 = 0x00; dwLoc10_817 < ecx_413; ++dwLoc10_817)
					{
						dwLoc30 = 0x00;
						if ((word32) *((word32) dwLoc4C_816 + dwLoc10_817 * 0x02) >> 0x0C == 0x03)
							Mem454[eax_33 + Mem430[dwLoc1C_705 + 0x00:word32] + (CONVERT(dwLoc4C_816[dwLoc10_817 * 0x02], word16, word32) & 0x0FFF):word32] = Mem430[eax_33 + Mem430[dwLoc1C_705 + 0x00:word32] + (CONVERT(dwLoc4C_816[dwLoc10_817 * 0x02], word16, word32) & 0x0FFF):word32] + ecx_94;
					}
					dwLoc1C_705 += Mem421[dwLoc1C_705 + 4:word32];
				}
			}
		}
		Eq_220 eax_127 = CreateFileMappingA((void *) ~0x00, null, 0x04, 0x00, edx_78.u0->t0050.u2, 0x00);
		if (eax_127 != null)
		{
			g_t4040FC.u0 = (int32) (dwLoc20 + 0x00073B70);
			if (g_dw4040E8 != 0x00)
				g_t4040F0.u2 = (DWORD) MapViewOfFileEx(eax_127, 0x22, 0x00, 0x00, 0x00, g_t4040D0.u2);
			else
				g_t4040F0.u2 = (DWORD) MapViewOfFileEx(eax_127, 0x22, 0x00, 0x00, 0x00, edx_78.u0->t0034.u2);
			if (g_t4040F0.u2 == 0x00)
			{
				dwLoc30 = dwLoc20 << (byte) (dwLoc24 *s dwLoc30);
				if (g_dw4040E8 != 0x00)
				{
					if (UnmapViewOfFile(g_t4040D0.u2) == 0x00 && VirtualFree(g_t4040D0.u2, 0x00, 0x8000) == 0x00)
					{
						eax_209 = 0x00;
						return eax_209;
					}
				}
				else if (UnmapViewOfFile(edx_78.u0->t0034.u2) == 0x00 && VirtualFree(((edx_78.u0)->t0034).u2, 0x00, 0x8000) == 0x00)
				{
					eax_209 = 0x00;
					return eax_209;
				}
				if (g_dw4040E8 != 0x00)
					g_t4040F0.u2 = (DWORD) MapViewOfFileEx(eax_127, 0x22, 0x00, 0x00, 0x00, g_t4040D0.u2);
				else
					g_t4040F0.u2 = (DWORD) MapViewOfFileEx(eax_127, 0x22, 0x00, 0x00, 0x00, edx_78.u0->t0034.u2);
				if (g_t4040F0.u2 == 0x00)
				{
					if (g_dw4040E8 != 0x00)
						g_t4040F0.u2 = (DWORD) VirtualAlloc(g_t4040D0.u2, edx_78.u0->t0050.u2, 0x3000, 0x40);
					else
						g_t4040F0.u2 = (DWORD) VirtualAlloc(edx_78.u0->t0034.u2, edx_78.u0->t0050.u2, 0x3000, 0x40);
					if (g_t4040F0.u2 == 0x00)
					{
						eax_209 = 0x00;
						return eax_209;
					}
				}
			}
			g_t4040FC.u0 = (int32) (156494 << g_t4040EC.u1 *s (byte) dwLoc08);
			fn00401000(g_t4040F0.u2, eax_33, edx_78.u0->t0050.u2);
			if (g_dw4040E8 != 0x00)
				fn004024F0(g_t4040D0.u2, (char *) edx_78.u0->ptr0028 + g_t4040F0.u2);
			else
				fn004025E0(g_t4040F0.u2);
			g_t4040C4.u0 = (int32) (dwLoc20 - 0x00060CA5);
			g_ptr4040F8 = (<anonymous> *) ((char *) edx_78.u0->ptr0028 + g_t4040F0.u2);
			edx_78.u0->ptr0028 = g_ptr4040F8;
			g_t4040C4.u0 = (int32) (dwLoc30 >> g_t4040FC);
			eax_209 = 0x01;
			return eax_209;
		}
		else
		{
			eax_209 = 0x00;
			return eax_209;
		}
	}
	else
	{
		eax_209 = 0x00;
		return eax_209;
	}
}

// 004024F0: void fn004024F0(Stack Eq_2 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      fn00401F00
void fn004024F0(Eq_2 dwArg04, ptr32 dwArg08)
{
	int32 dwLoc24;
	g_t4040FC.u0 = (int32) (g_t4040EC.u0 - 0x000DC541 << ~0x08);
	struct Eq_1707 * ecx_24 = g_ptr4040F4->ptr0030->ptr000C->ptr000C;
	g_t4040FC.u0 = (int32) (0x000EDB03 >> g_t4040EC.u1 >> ~0xBF);
	struct Eq_1707 * dwLoc18_100 = ecx_24;
	do
	{
		int32 edx_51 = g_t4040C4.u0 + 642333 - g_t4040FC.u0 >> g_t4040EC.u1;
		if (dwLoc18_100 == null)
			return;
		g_t4040FC.u0 = (int32) (g_t4040C4.u0 *s edx_51 *s dwLoc24);
		if (dwLoc18_100->t0018.u2 == dwArg04)
		{
			dwLoc18_100->ptr001C = dwArg08;
			return;
		}
		g_t4040C4.u0 = (int32) (g_t4040C4.u0 - dwLoc24);
		struct Eq_1707 * ecx_68 = dwLoc18_100->ptr0000;
		dwLoc18_100 = ecx_68;
	} while (ecx_68 != ecx_24);
}

// 004025E0: void fn004025E0(Stack Eq_2 dwArg04)
// Called from:
//      fn00401F00
void fn004025E0(Eq_2 dwArg04)
{
	word32 dwLoc10;
	int32 eax_10 = g_t4040EC.u0 + dwLoc10;
	struct Eq_1711 * eax_23 = g_ptr4040F4->ptr0030;
	g_t4040C4.u0 = 0x0DDB;
	eax_23->t0008.u2 = (DWORD) dwArg04;
	g_t4040C4.u0 = (int32) (g_t4040FC.u0 + g_t4040EC.u0 << (byte) eax_10);
}

// 00402650: void fn00402650(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00402650(Eq_2 dwArg04)
{
	int32 dwLoc0C;
	g_t4040EC.u0 = (int32) (dwLoc0C *s dwLoc0C >> ~0x60);
	HeapFree(GetProcessHeap(), 0x00, dwArg04);
}

// 00402690: void fn00402690(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00402690(Eq_2 dwArg04)
{
	word32 dwLoc10;
	g_t4040C4.u0 = (int32) (dwLoc10 + 102966 >> g_t4040C4.u1);
	HeapAlloc(GetProcessHeap(), 0x00, dwArg04);
}

