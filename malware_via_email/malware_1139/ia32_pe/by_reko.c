// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__CreateThread = &g_t12DE; // 00401000
<anonymous> * __imp__ExitProcess = &g_t12EE; // 00401004
<anonymous> * __imp__VirtualAlloc = &g_t12FC; // 00401008
<anonymous> * __imp__VirtualProtect = &g_t130C; // 0040100C
<anonymous> * __imp__GetProcessHeap = &g_t12CC; // 00401010
// 00401020: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	Eq_4 tLoc20;
	DWORD tLoc08;
	Eq_6 dwLoc14;
	fn00401260(&tLoc20);
	ui32 ecx_21 = tLoc20;
	ui32 eax_25 = (ecx_21 << 0x0E) + 0x000A5020;
	Eq_345 ecx_28[] = (eax_25 & 0xFFFF0000) + 4294865484;
	*((word32) tLoc20 + (fp - 0xEB)) = (Eq_4) (ecx_28[ecx_21].dw0000 - 0x28);
	Eq_6 eax_38 = (eax_25 & 0xFFFF0000) + (&(ecx_28 + (ecx_21 << 0x09) / 0x0200)->dw0000)[-1] + 0xFF - tLoc20;
	VirtualProtect(eax_38, dwLoc14, 0x04, &tLoc08);
	fn004011F0(eax_38, dwLoc14, tLoc20.u0);
	struct Eq_75 * ebx_76 = (char *) eax_38.u0 + *(((word32) eax_38 + 0x0113) - tLoc20);
	ui32 ecx_82 = tLoc20;
	uint32 dwLoc1C_245 = (uint32) ebx_76->b0006;
	Eq_6 eax_99 = VirtualAlloc(ebx_76->t0034.u0, ((char *) &ebx_76->t0034 + 0x0D8C - ((ecx_82 << 0x05) >> 0x01))->u0, 0x3000, (ecx_82 << 0x05) + ~0x1A9F);
	tLoc08 = (Eq_2) eax_99;
	fn00401240(((char *) &ebx_76->t0034 + 0x00F7 - tLoc20)->u0, eax_38, eax_99);
	struct Eq_136 * esi_119 = (char *) &ebx_76->t0034 + 0x00C4;
	do
	{
		fn00401240(esi_119->dw0010, (char *) eax_38.u0 + esi_119->dw0014, (word32) tLoc08 + esi_119->dw000C);
		uint32 v25_145 = dwLoc1C_245 - 0x01;
		++esi_119;
		dwLoc1C_245 = v25_145;
	} while (v25_145 != 0x00);
	Mem156[fp + 0xD7 - Mem146[&tLoc20 + 0x00:word32]:word32] = Mem146[ebx_76 - 0xAF + Mem146[&tLoc20 + 0x00:word32]:word32] + Mem146[&tLoc08 + 0x00:word32];
	ui32 ecx_171 = tLoc20;
	word32 edx_157 = tLoc20;
	<anonymous> * eax_174 = (ecx_171 << 0x06) + 0x003FDC80;
	struct Eq_199 * esp_177;
	eax_174();
	esp_177->tFFFFFFFC.u0 = tLoc20.u0;
	esp_177->tFFFFFFF8.u0 = 0x38;
	esp_177->tFFFFFFF4.u0 = (LPVOID) (fp - 88);
	fn004011F0(esp_177->tFFFFFFF4.u0, esp_177->tFFFFFFF8.u0, esp_177->tFFFFFFFC.u0);
	word32 ecx_200 = tLoc20;
	Eq_6 eax_204 = tLoc08;
	do
		eax_204.u0 = (word32) eax_204 + 1;
	while (*eax_204 != ecx_200 + 0xAABBCC06);
	esp_177->tFFFFFFFC.u0 = (LPVOID) eax_204;
	esp_177->tFFFFFFF8.u0 = (word32) tLoc20 + (fp - 303);
	Eq_6 eax_220 = 0x010F - tLoc20;
	esp_177->tFFFFFFF4.u0 = (LPVOID) eax_220;
	return SEQ(SLICE(eax_220, word24, 8), fn00401240(esp_177->tFFFFFFF4.u0, esp_177->tFFFFFFF8.u0, esp_177->tFFFFFFFC.u0));
}

// 004011F0: void fn004011F0(Stack Eq_6 dwArg04, Stack Eq_6 dwArg08, Stack Eq_6 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn004011F0(Eq_6 dwArg04, Eq_6 dwArg08, Eq_6 dwArg0C)
{
	Eq_6 ebx_22 = dwArg04;
	Eq_6 ecx_10 = dwArg08;
	word32 eax_15 = (word32) dwArg0C + 311805790;
	word32 dwLoc08_52 = 0x01;
	while (true)
	{
		ebx_22->u0 = *ebx_22 ^ eax_15;
		ecx_10 -= 0x04;
		if (ecx_10 <= 0x00)
			break;
		eax_15 = eax_15 + 891907372 + dwLoc08_52;
		ebx_22 = (word32) ebx_22 + 0x00DB - dwArg0C;
		dwLoc08_52 = -dwLoc08_52;
	}
}

// 00401240: Register byte fn00401240(Stack Eq_6 dwArg04, Stack Eq_6 dwArg08, Stack Eq_6 dwArg0C)
// Called from:
//      Win32CrtStartup
byte fn00401240(Eq_6 dwArg04, Eq_6 dwArg08, Eq_6 dwArg0C)
{
	Eq_6 edi_14 = dwArg0C;
	Eq_6 esi_15 = dwArg08;
	Eq_6 ecx_16 = dwArg04;
	do
	{
		byte al_19 = *esi_15.u1;
		*edi_14.u1 = al_19;
		esi_15.u0 = (word32) esi_15 + 1;
		edi_14.u0 = (word32) edi_14 + 1;
		--ecx_16;
	} while (ecx_16 != 0x00);
	return al_19;
}

// 00401260: void fn00401260(Stack (ptr32 uint32) dwArg04)
// Called from:
//      Win32CrtStartup
void fn00401260(uint32 * dwArg04)
{
	uint32 eax_12;
	(*(<anonymous> **) 0x7FFE0300)();
	*dwArg04 = (eax_12 & 0x0F) + ((eax_12 >> 0x18) + 0x10) - 0x01;
}

word32 g_dw4012B4 = 0x12DE; // 004012B4
word32 g_dw4012B8 = 0x12EE; // 004012B8
word32 g_dw4012BC = 0x12FC; // 004012BC
word32 g_dw4012C0 = 0x130C; // 004012C0
word32 g_dw4012C4 = 0x12CC; // 004012C4
