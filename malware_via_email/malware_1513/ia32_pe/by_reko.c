// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040108B: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 fp;
	struct Eq_4 * fs;
	struct Eq_5 * dwArg00;
	struct Eq_6 * ecx_6 = __rol<word32,byte>(0x21FFFFFF, 0x07);
	word32 esi_24 = __ror<word32,byte>((struct Eq_17 *) 4291151914, 0x07) + dwArg00;
	struct Eq_17 * edx_25 = __rol<word32,byte>(155616, 0x03)[(fp & __ror<word32,byte>((struct Eq_17 *) 0x3FC0, 0x06)) / 1628062181];
l004010C5:
	++edx_25;
	if (edx_25->dw0000 != ecx_6)
	{
		bool v46_267 = edx_25->dw0000 != esi_24;
		do
		{
			if (v46_267)
				goto l004010C5;
			--edx_25;
			Eq_58 al_59 = (byte) __rol<word32,byte>(0x40000002, 0x06);
			v46_267 = edx_25->dw0000 != al_59;
		} while (edx_25->dw0000 != al_59);
	}
	else
	{
		edx_25 += 4;
		if (edx_25[4] != (byte) __rol<word32,byte>(0xFC000003, 0x06))
		{
			++ecx_6->dw610A41E1;
l00401102:
			struct Eq_6 * edx_78 = __ror<word32,byte>(edx_25, 0x10);
			struct Eq_5 * ecx_80 = dwArg00;
			do
				--ecx_80;
			while (ecx_80->t0000.u0 != __rol<word32,byte>(0x18000006, 0x05));
			struct Eq_80 * esp_96;
			ecx_80();
			struct Eq_82 * eax_114 = fs->ptr0030->ptr000C;
			struct Eq_6 * ecx_123 = *((char *) *eax_114->ptr001C + 8);
			esp_96->ptrFFFFFFFC = (struct Eq_6 *) 414199694;
			esp_96->ptrFFFFFFF8 = ecx_123;
			<anonymous> * edi_134 = fn0040143B(esp_96->ptrFFFFFFF8, esp_96->ptrFFFFFFFC);
			struct Eq_6 * edx_143 = __ror<word32,byte>((struct Eq_17 *) 0x3600, 0x07);
			struct Eq_6 * ecx_147 = __rol<word32,byte>(0x36321736, 0x01);
			esp_96->ptrFFFFFFFC = edx_143;
			esp_96->ptrFFFFFFF8 = ecx_147;
			esp_96->ptrFFFFFFF4 = __rol<word32,byte>(0x9B191D1B, 0x02);
			esp_96->ptrFFFFFFF0 = esp_96 - 0x0C;
			edi_134();
			esp_96->ptrFFFFFFF8 = (struct Eq_6 *) ~0x1B251B1D;
			esp_96->ptrFFFFFFF4 = eax_114 - 0x01;
			<anonymous> * edi_180 = fn0040143B(esp_96->ptrFFFFFFF4, esp_96->ptrFFFFFFF8);
			esp_96->ptrFFFFFFF8 = null;
			esp_96->ptrFFFFFFF4 = null;
			esp_96->ptrFFFFFFF0 = 0x00;
			esp_96->dwFFFFFFEC = 0x00D0FA18;
			esp_96->dwFFFFFFE8 = ~0x540B0078;
			esp_96->dwFFFFFFE4 = 101;
			word32 eax_205;
			word32 edx_206;
			edi_180();
			<anonymous> * ecx_220 = *(<anonymous> **) 2581580;
			ui32 ecx_227;
			ui32 * eax_228;
			ecx_220();
			*eax_228 |= ecx_227;
		}
	}
	goto l00401102;
}

// 0040143B: Register word32 fn0040143B(Stack (ptr32 Eq_6) dwArg04, Stack (ptr32 Eq_6) dwArg08)
// Called from:
//      Win32CrtStartup
word32 fn0040143B(struct Eq_6 * dwArg04, struct Eq_6 * dwArg08)
{
	struct Eq_217 * ecx_39 = dwArg04 + (*((word32) (dwArg04 - ~0x77) + dwArg04->dw003C) - ~0x1B) / 1628062181;
	word32 edi_42[] = dwArg04 + ecx_39->dw0000 / 1628062181;
	word32 * ecx_49 = dwArg04 + ecx_39->dw0004 / 1628062181;
	word16 eax_57[] = dwArg04 + ecx_39->dw0008 / 1628062181;
	__wait();
	__wait();
	word32 * edi_134 = ecx_49;
	ui32 dwLoc1C_159 = 0x00;
	byte * eax_137 = dwArg04 + *ecx_49 / 1628062181;
	ui8 cl_141 = 0x00;
	ui24 ecx_24_8_144 = 0x00;
	while (true)
	{
		do
		{
			struct Eq_6 * ecx_89 = __ror<word32,byte>(SEQ(ecx_24_8_144, cl_141 + *eax_137), 0x17);
			cl_141 = (byte) ecx_89 ^ 151;
			ecx_24_8_144 = SLICE(ecx_89, word24, 8) ^ 4688081;
			++eax_137;
		} while (*eax_137 != 0x00);
		if ((ecx_89 ^ 1200148887 ^ dwArg08) == 0x00)
			break;
		edi_134 -= ~0x03;
		++dwLoc1C_159;
		eax_137 = (byte *) (dwArg04 + *edi_134 / 1628062181);
		cl_141 = 0x00;
		ecx_24_8_144 = 0x00;
	}
	return dwArg04 + edi_42[(uint32) eax_57[dwLoc1C_159]] / 1628062181;
}

