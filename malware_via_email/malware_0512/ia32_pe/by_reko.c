// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack word32 dwArg04)
word32 fn003E1000(word32 dwArg04)
{
	return dwArg04 + dwArg04->dw003C / 0x0040;
}

// 003E101F: void fn003E101F(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E101F(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	fn003E1942(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
	return;
}

// 003E10B0: Register Eq_32 fn003E10B0(Stack Eq_33 dwArg04, Stack Eq_34 dwArg08, Stack word32 dwArg0C)
FARPROC fn003E10B0(HMODULE dwArg04, LPCSTR dwArg08, word32 dwArg0C)
{
	Eq_32 eax_44;
	Eq_32 eax_21 = GetProcAddress(dwArg04, dwArg0C);
	if (fn003E1A30(dwArg08, 0x003E2030) == 0x00)
	{
		if (fn003E19AF(0x003E2030, dwArg0C, 0x003E2040) == 0x00)
		{
			globals->t3E8810 = eax_21;
			eax_44 = (Eq_32) &globals->t3E1050;
			return eax_44;
		}
		if (fn003E19AF(0x003E2040, dwArg0C, 0x003E2054) == 0x00)
		{
			globals->t3E8814 = eax_21;
			eax_44 = (Eq_32) &globals->t3E1081;
			return eax_44;
		}
	}
	eax_44 = eax_21;
	return eax_44;
}

// 003E1122: Register byte fn003E1122(Stack word32 dwArg04)
byte fn003E1122(word32 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1136: void fn003E1136(Stack (ptr Eq_85) dwArg04, Stack word32 dwArg08)
void fn003E1136(Eq_85 * dwArg04, word32 dwArg08)
{
	globals->t3E8818 = GetModuleHandleA(null);
	globals->dw3E881C = dwArg08;
	struct Eq_97 * dwLoc08_227 = dwArg08 + dwArg04->dw0080;
	while (dwLoc08_227->dw000C != 0x00)
	{
		ui32 * dwLoc10_125;
		Eq_34 ecx_87 = dwArg08 + dwLoc08_227->dw000C;
		Eq_33 eax_92 = LoadLibraryA(ecx_87);
		if (dwLoc08_227->dw0004 == 0x00)
			dwLoc10_125 = dwArg08 + dwLoc08_227->dw0010;
		else
			dwLoc10_125 = dwArg08 + dwLoc08_227->dw0000;
		word32 * dwLoc18_111 = dwArg08 + dwLoc08_227->dw0010;
		while (*dwLoc10_125 != 0x00)
		{
			Eq_32 dwLoc14_156;
			if ((word32) fn003E1122(*dwLoc10_125) != 0x00)
				dwLoc14_156 = GetProcAddress(eax_92, (word32) (word16) (*dwLoc10_125 & 0xFFFF));
			else
				dwLoc14_156 = fn003E10B0(eax_92, ecx_87, dwArg08 + *dwLoc10_125 + 0x02);
			*dwLoc18_111 = (word32) dwLoc14_156;
			dwLoc18_111 = dwLoc18_111 + 0x01;
			dwLoc10_125 = dwLoc10_125 + 0x01;
		}
		dwLoc08_227 = dwLoc08_227 + 0x01;
	}
	return;
}

// 003E1270: void fn003E1270(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E1270(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (ReadFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00)
	{
		if ((ecx & 0x00) != dwArg0C)
			goto l003E1278;
	}
	return;
}

// 003E12A6: void fn003E12A6(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E12A6(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (WriteFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00)
	{
		if ((ecx & 0x00) != dwArg0C)
			goto l003E12AE;
	}
	return;
}

// 003E12DC: void fn003E12DC(Register ui32 ecx, Stack ptr32 dwArg04, Stack word32 dwArg08, Stack uint32 dwArg0C)
void fn003E12DC(ui32 ecx, ptr32 dwArg04, word32 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_10 = ecx & 0x00;
	while (dwLoc08_10 < dwArg0C)
	{
		fn003E12A6(dwArg08, dwArg04->dw0004, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		fn003E1270(dwArg08, dwArg04->dw0000, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		dwLoc08_10 = dwLoc08_10 + 0x02;
	}
	return;
}

// 003E141E: void fn003E141E(Stack ptr32 dwArg04)
void fn003E141E(ptr32 dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
	return;
}

// 003E143B: Register word32 fn003E143B(Register ui32 ecx)
word32 fn003E143B(ui32 ecx)
{
	struct Eq_280 * eax_16 = fn003E15D0()->ptr0030;
	if ((word32) eax_16->b0002 == 0x00)
	{
		globals->dw40FC7D = 17757;
		globals->dw40FC81 = 14108;
		globals->dw40FC85 = 22572;
		globals->dw40FC89 = 0x20CD;
		globals->dw40FC89 = globals->dw40FC89 + 19255;
		if (CreatePipe(fp - 0x24, fp - 0x14, null, 0x10) != 0x00)
		{
			if (CreatePipe(fp - 0x18, fp - 0x20, null, 0x10) != 0x00)
			{
				Eq_189 eax_113 = CreateThread(null, 0x00, &globals->t3E1330, fp - 0x24, 0x00, fp - 0x0C);
				fn003E12DC(ecx, fp - 0x18, 0x003E3000, globals->dw3E8803 >> 0x02);
				fn003E141E(fp - 0x18);
				fn003E141E(fp - 0x24);
				CloseHandle(eax_113);
				struct Eq_85 * eax_145 = fn003E1000(0x003E3000);
				if (eax_145 != null)
				{
					word32 eax_170 = eax_145->dw0034;
					fn003E101F(0x003E3000, eax_170, eax_145->dw0054);
					fn003E15E0(eax_145, 0x003E3000, eax_170);
					struct Eq_85 * eax_196 = fn003E1000(eax_170);
					if (eax_196 != null)
					{
						fn003E1136(eax_196, eax_170);
						fn003E1776(eax_196, eax_170);
						eax_16->dw0008 = eax_170;
						<anonymous> * ecx_235 = eax_170 + eax_145->dw0028;
						word32 esp_238;
						word32 ebp_239;
						byte SCZO_240;
						word32 eax_241;
						byte SZO_242;
						byte C_243;
						byte Z_244;
						word32 ecx_245;
						ecx_235();
					}
				}
			}
		}
	}
	return 0x00;
}

// 003E15B5: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ExitProcess(fn003E143B(ecx));
}

// 003E15D0: Register word32 fn003E15D0()
word32 fn003E15D0()
{
	return fs->dw0018;
}

// 003E15E0: void fn003E15E0(Stack (ptr Eq_85) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E15E0(Eq_85 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word16 ax_21 = dwArg04->w0006;
	cui16 wLoc14_130 = wLoc14 & 0x00;
	while ((word32) wLoc14_130 < (word32) ax_21)
	{
		Eq_16 dwLoc2C_132;
		Eq_16 eax_64 = (&dwArg04->w0006 + 121)[((word32) wLoc14_130 *s 0x28 + 0x08) / 0x08];
		Eq_16 v16_73 = (&dwArg04->w0006 + 121)[((word32) wLoc14_130 *s 0x28 + 0x10) / 0x08];
		if (eax_64 < v16_73)
			dwLoc2C_132 = eax_64;
		else
			dwLoc2C_132 = v16_73;
		fn003E1942(dwArg0C + Mem0[((word32) wLoc14_130 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_130 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_132);
		wLoc14_130 = wLoc14_130 + 0x01;
	}
	return;
}

// 003E16AB: Register ui32 fn003E16AB(Register Eq_501 ecx, Stack word32 dwArg04)
ui32 fn003E16AB(Eq_501 ecx, word32 dwArg04)
{
	ui32 dwLoc08_10 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_10 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_117;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_117 = dwLoc08_10 | 0x40;
			else
				dwLoc08_117 = dwLoc08_10 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_117 = dwLoc08_10 | 0x80;
		else
			dwLoc08_117 = dwLoc08_10 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_117 = dwLoc08_10 | 0x04;
		else
			dwLoc08_117 = dwLoc08_10 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_117 = dwLoc08_10 | 0x08;
	else
		dwLoc08_117 = dwLoc08_10 | 0x01;
	return dwLoc08_117;
}

// 003E1776: void fn003E1776(Stack (ptr Eq_85) dwArg04, Stack word32 dwArg08)
void fn003E1776(Eq_85 * dwArg04, word32 dwArg08)
{
	word16 ax_21 = dwArg04->w0006;
	cui16 wLoc14_108 = wLoc14 & 0x00;
	while ((word32) wLoc14_108 < (word32) ax_21)
	{
		VirtualProtect(dwArg08 + Mem0[((word32) wLoc14_108 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], Mem0[(word32) wLoc14_108 *s 0x28 + 0x08 + (dwArg04 + 0xF8):word32], fn003E16AB(dwArg04 + 0xF8, Mem0[(word32) wLoc14_108 *s 0x28 + 0x24 + (dwArg04 + 0xF8):word32]), fp - 0x18);
		wLoc14_108 = wLoc14_108 + 0x01;
	}
	return;
}

// 003E1810: Register int32 fn003E1810(Stack word32 dwArg04)
int32 fn003E1810(word32 dwArg04)
{
	int32 eax_12;
	if (dwArg04 >= 0x41 && dwArg04 <= 0x5A)
		eax_12 = dwArg04 + 0x20;
	else
		eax_12 = dwArg04;
	return eax_12;
}

// 003E1942: void fn003E1942(Stack Eq_14 dwArg04, Stack word32 dwArg08, Stack Eq_16 dwArg0C)
void fn003E1942(LPVOID dwArg04, word32 dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = *dwArg08;
		dwArg04 = dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
	return;
}

// 003E19AF: Register int32 fn003E19AF(Register word32 ecx, Stack Eq_34 dwArg04, Stack word32 dwArg08)
int32 fn003E19AF(word32 ecx, LPCSTR dwArg04, word32 dwArg08)
{
	while (true)
	{
		int32 eax_31 = (word32) *dwArg04 - (word32) (*dwArg08);
		int32 dwLoc08_34 = eax_31;
		if (eax_31 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_31 < 0x00)
		dwLoc08_34 = eax_31 | ~0x00;
	else if (eax_31 > 0x00)
		dwLoc08_34 = 0x01;
	return dwLoc08_34;
}

// 003E1A30: Register word32 fn003E1A30(Stack word32 dwArg04, Stack word32 dwArg08)
word32 fn003E1A30(word32 dwArg04, word32 dwArg08)
{
	do
	{
		word32 eax_19 = fn003E1810((word32) *dwArg04);
		dwArg04 = dwArg04 + 0x01;
		word32 eax_41 = fn003E1810((word32) *dwArg08);
		dwArg08 = dwArg08 + 0x01;
	} while (eax_19 == 0x00 || eax_19 != eax_41);
	return eax_19 - eax_41;
}

