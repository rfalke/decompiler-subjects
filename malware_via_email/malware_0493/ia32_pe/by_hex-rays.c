/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void start();
DWORD sub_401041();
DWORD __stdcall sub_40109C(_BYTE *, int);
int sub_40110C();
void sub_40117D();
void sub_401191();
char *sub_40119C();
DWORD sub_401374();
void __stdcall __noreturn sub_401387(int, int, int);
_BYTE *__stdcall sub_40138F(_BYTE *, _BYTE *, int);

//-------------------------------------------------------------------------
// Data declarations

// extern DWORD (__stdcall *GetLastError)();
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *GetProcessTimes)(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
_UNKNOWN loc_40103B; // weak
int dword_402000; // weak
int dword_402008; // weak
int dword_40200C; // weak
int dword_402100; // weak
int dword_402120; // weak
_BYTE byte_402154[37502]; // weak
_UNKNOWN unk_40B3D2; // weak


//----- (00401020) --------------------------------------------------------
void start()
{
  void (*v0)(void); // ebx

  v0 = (void (*)(void))((char *)&loc_40103B + sub_401374());
  v0();
  sub_40119C();
  sub_401191();
}

//----- (00401041) --------------------------------------------------------
DWORD sub_401041()
{
  dword_402000 = *(_DWORD *)(((unsigned int)sub_401041 & 0xFFFF0000) + 0xD074);
  dword_402008 = (int)byte_402154;
  dword_40200C = (int)&byte_402154[dword_402000];
  sub_40138F(byte_402154, (_BYTE *)(((unsigned int)sub_401041 & 0xFFFF0000) + 53384), dword_402000);
  return sub_40109C((_BYTE *)dword_402008, dword_402000);
}
// 402000: using guessed type int dword_402000;
// 402008: using guessed type int dword_402008;
// 40200C: using guessed type int dword_40200C;
// 402154: using guessed type _BYTE byte_402154[37502];

//----- (0040109C) --------------------------------------------------------
DWORD __stdcall sub_40109C(_BYTE *a1, int a2)
{
  int v3; // edx
  DWORD result; // eax
  int *v5; // esi
  _BYTE *v6; // ecx
  int v7; // edx
  int v8[3]; // [esp+0h] [ebp-Ch] BYREF

  v8[0] = -1205576311;
  v8[1] = 2116616619;
  v8[2] = 0;
  v3 = a2;
  do
  {
    *a1++ -= 59;
    --v3;
  }
  while ( v3 );
  dword_402008 += 2;
  result = (sub_401374() ^ 6) - 1;
  v5 = v8;
  v8[0] &= result;
  v6 = (_BYTE *)dword_402008;
  v7 = a2;
  do
  {
    LOBYTE(result) = *(_BYTE *)v5 ^ *v6;
    *v6 = result;
    v5 = (int *)((char *)v5 + 1);
    if ( !*(_BYTE *)v5 )
      v5 = v8;
    ++v6;
    --v7;
  }
  while ( v7 );
  dword_402100 = dword_402008;
  return result;
}
// 402008: using guessed type int dword_402008;
// 402100: using guessed type int dword_402100;
// 40109C: using guessed type _DWORD var_C[3];

//----- (0040110C) --------------------------------------------------------
int sub_40110C()
{
  _DWORD *v0; // ebx
  _DWORD *v1; // esi
  FARPROC *v2; // edi
  HMODULE hModule; // [esp+0h] [ebp-4h]

  v0 = (_DWORD *)(dword_402120 + *(_DWORD *)(dword_402120 + *(_DWORD *)(dword_402120 + 60) + 128));
  do
  {
    hModule = LoadLibraryA((LPCSTR)(dword_402120 + v0[3]));
    v1 = (_DWORD *)(dword_402120 + *v0);
    v2 = (FARPROC *)(dword_402120 + v0[4]);
    do
      *v2++ = GetProcAddress(hModule, (LPCSTR)(dword_402120 + *v1++ + 2));
    while ( *v1 );
    v0 += 5;
  }
  while ( v0[3] );
  return 0;
}
// 402120: using guessed type int dword_402120;

//----- (0040117D) --------------------------------------------------------
void sub_40117D()
{
  NtCurrentTeb()->ProcessEnvironmentBlock->ImageBaseAddress = (void *)dword_402120;
}
// 402120: using guessed type int dword_402120;

//----- (00401191) --------------------------------------------------------
void sub_401191()
{
  sub_40110C();
  sub_40117D();
}

//----- (0040119C) --------------------------------------------------------
char *sub_40119C()
{
  void *v0; // esp
  _DWORD *v1; // ebx
  _BYTE *v2; // esi
  int v3; // edi
  int v5; // [esp+DCC4h] [ebp-8h]

  v0 = alloca(20);
  v1 = (_DWORD *)(*(_DWORD *)(dword_402100 - 11434 + 11494) + dword_402100);
  *(_DWORD *)((char *)&unk_40B3D2 - 37554) = v1[13];
  v5 = *((unsigned __int8 *)v1 + 6);
  v2 = VirtualAlloc((LPVOID)v1[13], v1[20], 0x3000u, 0x40u);
  sub_40138F(v2, (_BYTE *)dword_402100, v1[21]);
  v3 = (int)(v1 + 62);
  do
  {
    sub_40138F(
      &v2[*(_DWORD *)(v3 - 21044 + 21056)],
      (_BYTE *)(*(_DWORD *)(v3 + 20) + dword_402100),
      *(_DWORD *)(v3 + 16));
    v3 += 40;
    --v5;
  }
  while ( v5 );
  return &v2[v1[10]];
}
// 40119C: could not find valid save-restore pair for ebx
// 40119C: could not find valid save-restore pair for ebp
// 40119C: could not find valid save-restore pair for edi
// 402100: using guessed type int dword_402100;

//----- (00401374) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
DWORD sub_401374()
{
  void *v1; // [esp-10h] [ebp-10h]
  struct _FILETIME *v2; // [esp-Ch] [ebp-Ch]
  struct _FILETIME *v3; // [esp-8h] [ebp-8h]
  struct _FILETIME *v4; // [esp-4h] [ebp-4h]
  struct _FILETIME *savedregs; // [esp+0h] [ebp+0h]

  GetProcessTimes(v1, v2, v3, v4, savedregs);
  return GetLastError();
}
// 40137D: positive sp value 10 has been found
// 401377: variable 'v1' is possibly undefined
// 401377: variable 'v2' is possibly undefined
// 401377: variable 'v3' is possibly undefined
// 401377: variable 'v4' is possibly undefined
// 401377: variable 'savedregs' is possibly undefined

//----- (00401387) --------------------------------------------------------
void __stdcall __noreturn sub_401387(int a1, int a2, int a3)
{
  ExitProcess(0);
}

//----- (0040138F) --------------------------------------------------------
_BYTE *__stdcall sub_40138F(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *result; // eax
  int i; // ecx

  result = a2;
  for ( i = a3; i; --i )
    *a1++ = *result++;
  return result;
}

// nfuncs=10 queued=10 decompiled=10 lumina nreq=0 worse=0 better=0
// ALL OK, 10 function(s) have been successfully decompiled
