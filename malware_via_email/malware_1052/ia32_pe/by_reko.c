// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_tE488; // 0040E000
<anonymous> * __imp__GetModuleFileNameA = &g_tE49A; // 0040E004
<anonymous> * __imp__InitializeCriticalSection = &g_tE4B0; // 0040E008
<anonymous> * __imp__Sleep = &g_tE4CC; // 0040E00C
<anonymous> * __imp__MultiByteToWideChar = &g_tE4D4; // 0040E010
<anonymous> * __imp__ReadFile = &g_tE4EA; // 0040E014
<anonymous> * __imp__VirtualAlloc = &g_tE4F6; // 0040E018
<anonymous> * __imp__VirtualProtect = &g_tE506; // 0040E01C
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tE518; // 0040E020
<anonymous> * __imp__lstrlenA = &g_tE534; // 0040E024
<anonymous> * __imp__LoadLibraryA = &g_tE540; // 0040E028
<anonymous> * __imp__EnterCriticalSection = &g_tE550; // 0040E02C
<anonymous> * __imp__LocalFree = &g_tE568; // 0040E030
<anonymous> * __imp__QueryPerformanceCounter = &g_tE574; // 0040E034
<anonymous> * __imp__GetProcAddress = &g_tE58E; // 0040E038
<anonymous> * __imp__GetProcAddress = &g_tE5A0; // 0040E03C
<anonymous> * __imp__QueryPerformanceCounter = &g_tE5B2; // 0040E040
<anonymous> * __imp__lstrlenA = &g_tE5CC; // 0040E044
<anonymous> * __imp__GetProcessHeap = &g_tE5D8; // 0040E048
<anonymous> * __imp__GetModuleHandleA = &g_tE5EA; // 0040E04C
<anonymous> * __imp__MultiByteToWideChar = &g_tE5FE; // 0040E050
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_tE614; // 0040E054
<anonymous> * __imp__GetLastError = &g_tE62E; // 0040E058
<anonymous> * __imp__HeapFree = &g_tE63E; // 0040E05C
<anonymous> * __imp__MultiByteToWideChar = &g_tE64A; // 0040E060
<anonymous> * __imp__GetModuleFileNameW = &g_tE660; // 0040E064
<anonymous> * __imp__LeaveCriticalSection = &g_tE676; // 0040E068
<anonymous> * __imp__VirtualProtect = &g_tE68E; // 0040E06C
<anonymous> * __imp__GetCurrentThreadId = &g_tE6A0; // 0040E070
<anonymous> * __imp__InterlockedDecrement = &g_tE6B6; // 0040E074
<anonymous> * __imp__GetTickCount = &g_tE6CE; // 0040E078
<anonymous> * __imp__ReadFile = &g_tE6DE; // 0040E07C
<anonymous> * __imp__GetProcessHeap = &g_tE6EA; // 0040E080
<anonymous> * __imp__InterlockedDecrement = &g_tE6FC; // 0040E084
<anonymous> * __imp__UnhandledExceptionFilter = &g_tE714; // 0040E088
<anonymous> * __imp__GetCurrentProcessId = &g_tE730; // 0040E08C
<anonymous> * __imp__HeapDestroy = &g_tE746; // 0040E090
<anonymous> * __imp__LocalFree = &g_tE754; // 0040E094
<anonymous> * __imp__GetTickCount = &g_tE760; // 0040E098
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tE770; // 0040E09C
<anonymous> * __imp__HeapDestroy = &g_tE78C; // 0040E0A0
<anonymous> * __imp__InitializeCriticalSection = &g_tE79A; // 0040E0A4
<anonymous> * __imp__CreateFileW = &g_tE7B6; // 0040E0A8
<anonymous> * __imp__ReadFile = &g_tE7C4; // 0040E0AC
<anonymous> * __imp__GetLastError = &g_tE7D0; // 0040E0B0
<anonymous> * __imp__DeleteCriticalSection = &g_tE7E0; // 0040E0B4
<anonymous> * __imp__GetModuleHandleW = &g_tE7F8; // 0040E0B8
<anonymous> * __imp__InterlockedDecrement = &g_tE80C; // 0040E0BC
<anonymous> * __imp__InterlockedExchange = &g_tE824; // 0040E0C0
<anonymous> * __imp__CreateFileW = &g_tE83A; // 0040E0C4
<anonymous> * __imp__GetCurrentThreadId = &g_tE848; // 0040E0C8
<anonymous> * __imp__GetLastError = &g_tE85E; // 0040E0CC
<anonymous> * __imp__ReadFile = &g_tE86E; // 0040E0D0
<anonymous> * __imp__FreeLibrary = &g_tE87A; // 0040E0D4
<anonymous> * __imp__DeleteCriticalSection = &g_tE888; // 0040E0D8
<anonymous> * __imp__HeapAlloc = &g_tE8A0; // 0040E0DC
<anonymous> * __imp__GetCurrentProcessId = &g_tE8AC; // 0040E0E0
<anonymous> * __imp__GetCurrentProcessId = &g_tE8C2; // 0040E0E4
<anonymous> * __imp__UnhandledExceptionFilter = &g_tE8D8; // 0040E0E8
<anonymous> * __imp__CreateFileW = &g_tE8F4; // 0040E0EC
<anonymous> * __imp__QueryPerformanceCounter = &g_tE902; // 0040E0F0
<anonymous> * __imp__MultiByteToWideChar = &g_tE91C; // 0040E0F4
<anonymous> * __imp__FreeLibrary = &g_tE932; // 0040E0F8
<anonymous> * __imp__QueryPerformanceCounter = &g_tE940; // 0040E0FC
<anonymous> * __imp__HeapFree = &g_tE95A; // 0040E100
<anonymous> * __imp__InterlockedIncrement = &g_tE966; // 0040E104
<anonymous> * __imp__lstrcmpiW = &g_tE97E; // 0040E108
<anonymous> * __imp__CloseHandle = &g_tE98A; // 0040E10C
<anonymous> * __imp__HeapAlloc = &g_tE998; // 0040E110
<anonymous> * __imp__EnableWindow = &g_tE9B2; // 0040E118
<anonymous> * __imp__GetSystemMetrics = &g_tE9C2; // 0040E11C
<anonymous> * __imp__GetSysColor = &g_tE9D6; // 0040E120
<anonymous> * __imp__LoadIconW = &g_tE9E4; // 0040E124
<anonymous> * __imp__GetDC = &g_tE9F0; // 0040E128
<anonymous> * __imp__SetWindowTextW = &g_tE9F8; // 0040E12C
<anonymous> * __imp__GetDesktopWindow = &g_tEA0A; // 0040E130
<anonymous> * __imp__SendMessageW = &g_tEA1E; // 0040E134
<anonymous> * __imp__DispatchMessageW = &g_tEA2E; // 0040E138
<anonymous> * __imp__SetWindowLongW = &g_tEA42; // 0040E13C
<anonymous> * __imp__DialogBoxParamW = &g_tEA54; // 0040E140
<anonymous> * __imp__GetWindowRect = &g_tEA66; // 0040E144
<anonymous> * __imp__DefWindowProcW = &g_tEA76; // 0040E148
<anonymous> * __imp__GetDesktopWindow = &g_tEA88; // 0040E14C
<anonymous> * __imp__GetWindowRect = &g_tEA9C; // 0040E150
<anonymous> * __imp__SetForegroundWindow = &g_tEAAC; // 0040E154
<anonymous> * __imp__InvalidateRect = &g_tEAC2; // 0040E158
<anonymous> * __imp__GetWindowRect = &g_tEAD4; // 0040E15C
<anonymous> * __imp__MessageBoxW = &g_tEAE4; // 0040E160
<anonymous> * __imp__SetFocus = &g_tEAF2; // 0040E164
<anonymous> * __imp__GetWindowLongW = &g_tEAFE; // 0040E168
<anonymous> * __imp__MessageBoxW = &g_tEB10; // 0040E16C
<anonymous> * __imp__ReleaseDC = &g_tEB1E; // 0040E170
<anonymous> * __imp__wsprintfA = &g_tEB2A; // 0040E174
<anonymous> * __imp__DialogBoxParamW = &g_tEB36; // 0040E178
<anonymous> * __imp__SetWindowTextW = &g_tEB48; // 0040E17C
<anonymous> * __imp__LoadCursorW = &g_tEB5A; // 0040E180
<anonymous> * __imp__GetWindowRect = &g_tEB68; // 0040E184
<anonymous> * __imp__GetWindowLongW = &g_tEB78; // 0040E188
<anonymous> * __imp__GetSystemMetrics = &g_tEB8A; // 0040E18C
<anonymous> * __imp__LoadIconW = &g_tEB9E; // 0040E190
<anonymous> * __imp__BeginPaint = &g_tEBAA; // 0040E194
<anonymous> * __imp__SetWindowTextW = &g_tEBB8; // 0040E198
<anonymous> * __imp__BeginPaint = &g_tEBCA; // 0040E19C
<anonymous> * __imp__LoadCursorW = &g_tEBD8; // 0040E1A0
<anonymous> * __imp__EndDialog = &g_tEBE6; // 0040E1A4
<anonymous> * __imp__GetFocus = &g_tEBF2; // 0040E1A8
<anonymous> * __imp__DestroyWindow = &g_tEBFE; // 0040E1AC
<anonymous> * __imp__EndDialog = &g_tEC0E; // 0040E1B0
<anonymous> * __imp__SendDlgItemMessageW = &g_tEC1A; // 0040E1B4
<anonymous> * __imp__GetClientRect = &g_tEC30; // 0040E1B8
<anonymous> * __imp__GetDesktopWindow = &g_tEC40; // 0040E1BC
<anonymous> * __imp__GetParent = &g_tEC54; // 0040E1C0
<anonymous> * __imp__SendDlgItemMessageW = &g_tEC60; // 0040E1C4
<anonymous> * __imp__TranslateMessage = &g_tEC76; // 0040E1C8
<anonymous> * __imp__SetWindowTextW = &g_tEC8A; // 0040E1CC
<anonymous> * __imp__GetWindowLongW = &g_tEC9C; // 0040E1D0
<anonymous> * __imp__TranslateMessage = &g_tECAE; // 0040E1D4
<anonymous> * __imp__SetForegroundWindow = &g_tECC2; // 0040E1D8
<anonymous> * __imp__TranslateMessage = &g_tECD8; // 0040E1DC
<anonymous> * __imp__SetWindowPos = &g_tECEC; // 0040E1E0
<anonymous> * __imp__DefWindowProcW = &g_tECFC; // 0040E1E4
<anonymous> * __imp__DialogBoxParamW = &g_tED0E; // 0040E1E8
<anonymous> * __imp__GetDesktopWindow = &g_tED20; // 0040E1EC
<anonymous> * __imp__LoadCursorW = &g_tED34; // 0040E1F0
<anonymous> * __imp__KillTimer = &g_tED42; // 0040E1F4
<anonymous> * __imp__IsDlgButtonChecked = &g_tED4E; // 0040E1F8
<anonymous> * __imp__EndDialog = &g_tED64; // 0040E1FC
<anonymous> * __imp__wsprintfA = &g_tED70; // 0040E200
<anonymous> * __imp__LoadIconW = &g_tED7C; // 0040E204
<anonymous> * __imp__CharNextW = &g_tED88; // 0040E208
<anonymous> * __imp__GetWindowRect = &g_tED94; // 0040E20C
<anonymous> * __imp__GetParent = &g_tEDA4; // 0040E210
<anonymous> * __imp__CharNextW = &g_tEDB0; // 0040E214
<anonymous> * __imp__PeekMessageW = &g_tEDBC; // 0040E218
<anonymous> * __imp__BeginPaint = &g_tEDCC; // 0040E21C
word32 g_dw40E264 = 0xE488; // 0040E264
word32 g_dw40E268 = 58522; // 0040E268
word32 g_dw40E26C = 58544; // 0040E26C
word32 g_dw40E270 = 0xE4CC; // 0040E270
word32 g_dw40E274 = 58580; // 0040E274
word32 g_dw40E278 = 0xE4EA; // 0040E278
word32 g_dw40E27C = 0xE4F6; // 0040E27C
word32 g_dw40E280 = 0xE506; // 0040E280
word32 g_dw40E284 = 58648; // 0040E284
word32 g_dw40E288 = 58676; // 0040E288
word32 g_dw40E28C = 58688; // 0040E28C
word32 g_dw40E290 = 0xE550; // 0040E290
word32 g_dw40E294 = 58728; // 0040E294
word32 g_dw40E298 = 0xE574; // 0040E298
word32 g_dw40E29C = 0xE58E; // 0040E29C
word32 g_dw40E2A0 = 0xE5A0; // 0040E2A0
word32 g_dw40E2A4 = 58802; // 0040E2A4
word32 g_dw40E2A8 = 58828; // 0040E2A8
word32 g_dw40E2AC = 58840; // 0040E2AC
word32 g_dw40E2B0 = 58858; // 0040E2B0
word32 g_dw40E2B4 = 58878; // 0040E2B4
word32 g_dw40E2B8 = 58900; // 0040E2B8
word32 g_dw40E2BC = 0xE62E; // 0040E2BC
word32 g_dw40E2C0 = 0xE63E; // 0040E2C0
word32 g_dw40E2C4 = 58954; // 0040E2C4
word32 g_dw40E2C8 = 0xE660; // 0040E2C8
word32 g_dw40E2CC = 58998; // 0040E2CC
word32 g_dw40E2D0 = 0xE68E; // 0040E2D0
word32 g_dw40E2D4 = 0xE6A0; // 0040E2D4
word32 g_dw40E2D8 = 0xE6B6; // 0040E2D8
word32 g_dw40E2DC = 0xE6CE; // 0040E2DC
word32 g_dw40E2E0 = 0xE6DE; // 0040E2E0
word32 g_dw40E2E4 = 0xE6EA; // 0040E2E4
word32 g_dw40E2E8 = 0xE6FC; // 0040E2E8
word32 g_dw40E2EC = 59156; // 0040E2EC
word32 g_dw40E2F0 = 0xE730; // 0040E2F0
word32 g_dw40E2F4 = 0xE746; // 0040E2F4
word32 g_dw40E2F8 = 59220; // 0040E2F8
word32 g_dw40E2FC = 0xE760; // 0040E2FC
word32 g_dw40E300 = 0xE770; // 0040E300
word32 g_dw40E304 = 0xE78C; // 0040E304
word32 g_dw40E308 = 59290; // 0040E308
word32 g_dw40E30C = 0xE7B6; // 0040E30C
word32 g_dw40E310 = 59332; // 0040E310
word32 g_dw40E314 = 0xE7D0; // 0040E314
word32 g_dw40E318 = 0xE7E0; // 0040E318
word32 g_dw40E31C = 0xE7F8; // 0040E31C
word32 g_dw40E320 = 0xE80C; // 0040E320
word32 g_dw40E324 = 0xE824; // 0040E324
word32 g_dw40E328 = 59450; // 0040E328
word32 g_dw40E32C = 0xE848; // 0040E32C
word32 g_dw40E330 = 0xE85E; // 0040E330
word32 g_dw40E334 = 0xE86E; // 0040E334
word32 g_dw40E338 = 59514; // 0040E338
word32 g_dw40E33C = 0xE888; // 0040E33C
word32 g_dw40E340 = 59552; // 0040E340
word32 g_dw40E344 = 59564; // 0040E344
word32 g_dw40E348 = 59586; // 0040E348
word32 g_dw40E34C = 0xE8D8; // 0040E34C
word32 g_dw40E350 = 59636; // 0040E350
word32 g_dw40E354 = 0xE902; // 0040E354
word32 g_dw40E358 = 59676; // 0040E358
word32 g_dw40E35C = 59698; // 0040E35C
word32 g_dw40E360 = 0xE940; // 0040E360
word32 g_dw40E364 = 0xE95A; // 0040E364
word32 g_dw40E368 = 0xE966; // 0040E368
word32 g_dw40E36C = 0xE97E; // 0040E36C
word32 g_dw40E370 = 0xE98A; // 0040E370
word32 g_dw40E374 = 0xE998; // 0040E374
word32 g_dw40E37C = 0xE9B2; // 0040E37C
word32 g_dw40E380 = 0xE9C2; // 0040E380
word32 g_dw40E384 = 0xE9D6; // 0040E384
word32 g_dw40E388 = 0xE9E4; // 0040E388
word32 g_dw40E38C = 59888; // 0040E38C
word32 g_dw40E390 = 59896; // 0040E390
word32 g_dw40E394 = 0xEA0A; // 0040E394
word32 g_dw40E398 = 0xEA1E; // 0040E398
word32 g_dw40E39C = 59950; // 0040E39C
word32 g_dw40E3A0 = 59970; // 0040E3A0
word32 g_dw40E3A4 = 59988; // 0040E3A4
word32 g_dw40E3A8 = 60006; // 0040E3A8
word32 g_dw40E3AC = 60022; // 0040E3AC
word32 g_dw40E3B0 = 60040; // 0040E3B0
word32 g_dw40E3B4 = 60060; // 0040E3B4
word32 g_dw40E3B8 = 60076; // 0040E3B8
word32 g_dw40E3BC = 60098; // 0040E3BC
word32 g_dw40E3C0 = 60116; // 0040E3C0
word32 g_dw40E3C4 = 0xEAE4; // 0040E3C4
word32 g_dw40E3C8 = 60146; // 0040E3C8
word32 g_dw40E3CC = 0xEAFE; // 0040E3CC
word32 g_dw40E3D0 = 0xEB10; // 0040E3D0
word32 g_dw40E3D4 = 0xEB1E; // 0040E3D4
word32 g_dw40E3D8 = 60202; // 0040E3D8
word32 g_dw40E3DC = 0xEB36; // 0040E3DC
word32 g_dw40E3E0 = 60232; // 0040E3E0
word32 g_dw40E3E4 = 60250; // 0040E3E4
word32 g_dw40E3E8 = 60264; // 0040E3E8
word32 g_dw40E3EC = 60280; // 0040E3EC
word32 g_dw40E3F0 = 0xEB8A; // 0040E3F0
word32 g_dw40E3F4 = 0xEB9E; // 0040E3F4
word32 g_dw40E3F8 = 60330; // 0040E3F8
word32 g_dw40E3FC = 0xEBB8; // 0040E3FC
word32 g_dw40E400 = 60362; // 0040E400
word32 g_dw40E404 = 60376; // 0040E404
word32 g_dw40E408 = 0xEBE6; // 0040E408
word32 g_dw40E40C = 60402; // 0040E40C
word32 g_dw40E410 = 0xEBFE; // 0040E410
word32 g_dw40E414 = 0xEC0E; // 0040E414
word32 g_dw40E418 = 60442; // 0040E418
word32 g_dw40E41C = 60464; // 0040E41C
word32 g_dw40E420 = 0xEC40; // 0040E420
word32 g_dw40E424 = 60500; // 0040E424
word32 g_dw40E428 = 0xEC60; // 0040E428
word32 g_dw40E42C = 0xEC76; // 0040E42C
word32 g_dw40E430 = 60554; // 0040E430
word32 g_dw40E434 = 0xEC9C; // 0040E434
word32 g_dw40E438 = 0xECAE; // 0040E438
word32 g_dw40E43C = 60610; // 0040E43C
word32 g_dw40E440 = 60632; // 0040E440
word32 g_dw40E444 = 0xECEC; // 0040E444
word32 g_dw40E448 = 60668; // 0040E448
word32 g_dw40E44C = 60686; // 0040E44C
word32 g_dw40E450 = 0xED20; // 0040E450
word32 g_dw40E454 = 0xED34; // 0040E454
word32 g_dw40E458 = 0xED42; // 0040E458
word32 g_dw40E45C = 0xED4E; // 0040E45C
word32 g_dw40E460 = 60772; // 0040E460
word32 g_dw40E464 = 0xED70; // 0040E464
word32 g_dw40E468 = 60796; // 0040E468
word32 g_dw40E46C = 60808; // 0040E46C
word32 g_dw40E470 = 60820; // 0040E470
word32 g_dw40E474 = 60836; // 0040E474
word32 g_dw40E478 = 0xEDB0; // 0040E478
word32 g_dw40E47C = 60860; // 0040E47C
word32 g_dw40E480 = 0xEDCC; // 0040E480
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00406323: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	struct Eq_3 * fp;
	struct Eq_4 * ebp;
	Eq_5 edx;
	bool C;
	struct Eq_7 * esi;
	word32 eax;
	Eq_9 ebx;
	Eq_10 cl;
	word24 ecx_24_8;
	ui16 di;
	word16 edi_16_16;
	Eq_2 gs;
	bool P;
l00406323:
	int32 esi_10 = esi + eax;
	word24 edx_24_8_28 = SLICE(__rcr<word32,byte>(edx, 0x13, C), word24, 8);
	uint8 ah_17 = SLICE(eax, byte, 8);
	Eq_10 cl_21 = ~cl;
	word32 ebx_23 = SLICE(ah_17 - 0x5AF25686F4, word32, 8);
	word16 eax_16_16_1094 = SLICE(eax, word16, 16);
	uint8 al_1110 = (byte) eax;
	esi = esi_10 >> 0x07;
	struct Eq_25 * edx_29 = SEQ(edx_24_8_28, 0xE0);
	ui32 ecx_34 = SEQ(ecx_24_8, cl_21);
	int32 ebx_52 = SEQ(SLICE(ebx_23, word16, 16), cl_21, (byte) ebx_23);
	if (esi_10 >> 0x07 == 0x7FDFC091)
	{
l00406350:
		word32 edx_1083;
		Eq_2 eax_1084;
		word32 ecx_1085;
		esi->ptrFFFFFFF7();
		byte cl_1246 = (byte) ecx_1085;
		word24 ecx_24_8_1247 = SLICE(ecx_1085, word24, 8);
		return eax_1084;
	}
	Eq_5 edx_31 = __ror<word32,byte>(edx_29, 0x14);
	struct Eq_40 * ecx_37 = __rcl<word32,byte>(SEQ(ecx_24_8, cl_21), cl_21, (edx_29 & 0x00100000) != 0x00);
	Eq_10 cl_41 = (byte) ecx_37;
	byte cl_48 = cl_41 - (ah_17 - 244);
	ui16 di_45 = di << cl_41;
	byte ch_56 = SLICE(ecx_37, byte, 8);
	word16 ecx_16_16_60 = SLICE(ecx_37, word16, 16);
	int32 ebx_53 = ebx_52 >> cl_48;
	word24 eax_24_8_1095 = SEQ(eax_16_16_1094, ah_17 - 244);
	edx = SEQ(SLICE(edx_31, word16, 16), __rcl<byte,byte>(~SLICE(edx_31, byte, 8), cl_41, (ecx_34 & 0x01 << 0x20 - cl_21) != 0x00) >> 0x13 >> cl_41, (byte) edx_31);
	ui32 edi_1109 = SEQ(edi_16_16, di_45);
	word16 eax_16_16_1147 = eax_16_16_1094;
	ebx = ebx_53 << cl_48;
	byte ch_58 = ch_56 | SLICE(ebx, byte, 8);
	cl = ~cl_48;
	while (true)
	{
		struct Eq_25 * edx_64 = edx - 0x01;
		Eq_10 cl_66 = (byte) cl.u1 + 1;
		edx = __ror<word32,byte>(edx_64, cl_66);
		struct Eq_3 * esp_252 = fp;
		di = di_45;
		byte bh_82 = SLICE(ebx, byte, 8);
		byte bl_107 = (byte) ebx;
		word16 ebx_16_16_108 = SLICE(ebx, word16, 16);
		byte dh_83 = SLICE(edx, byte, 8);
		ui8 dl_85 = (byte) edx;
		int16 edx_16_16_166 = SLICE(edx, word16, 16);
		cl = __rcr<byte,byte>(cl_66, cl_66, (edx_64 & 0x01 << cl_66) != 0x00);
		C = SLICE(cond(ebx - 465694036), bool, 1);
		eax = SEQ(eax_24_8_1095, al_1110);
		ecx_24_8 = SEQ(ecx_16_16_60, ch_58);
		if (ebx != 465694036)
			break;
		ebp = fp - 4;
		if (!P)
			goto l00406323;
	}
	int16 cx_78 = SEQ(ch_58 << cl, cl) >> cl;
	Eq_10 dl_87 = __rol<byte,byte>(dl_85, 0x10);
	word32 ecx_93 = -SEQ(ecx_16_16_60, cx_78);
	ui32 edi_94 = (edi_1109 | 1873026366) + 1673703576;
	Eq_10 bh_90 = __ror<byte,byte>(bh_82 + dh_83, (byte) cx_78);
	word24 ecx_24_8_111 = SLICE(ecx_93, word24, 8);
	ui16 di_103 = (word16) edi_94;
	word16 edi_16_16_1123 = SLICE(edi_94, word16, 16);
	Eq_10 cl_101 = __rcr<byte,byte>((byte) ecx_93, 0x14, SLICE(cond(edi_94), bool, 1));
	word32 ebx_109 = SEQ(ebx_16_16_108, (byte) bh_90 + 1, bl_107);
	cui16 dx_115 = SEQ(dh_83, dl_87);
	uint16 di_105 = __ror<word16,byte>(di_103, cl_101);
	word32 ebx_110 = ~ebx_109;
	struct Eq_40 * ecx_114 = __rcl<word32,byte>(SEQ(ecx_24_8_111, cl_101), 0x01, (di_103 & 0x01 << cl_101) != 0x00);
	byte bl_149 = (byte) ebx_110;
	byte bh_159 = SLICE(ebx_110, byte, 8);
	word16 ebx_16_16_1121 = SLICE(ebx_110, word16, 16);
	uint8 cl_125 = (byte) ecx_114;
	word24 ecx_24_8_128 = SLICE(ecx_114, word24, 8);
	ui16 di_116 = di_105 | dx_115;
	struct Eq_25 * esi_120 = __rcr<word32,byte>(esi_10 >> 0x07, 0x15, false);
	Eq_245 v367_1229 = SEQ(cl_125, ecx_129) >> cl_125;
	word32 ecx_132 = (word32) v367_1229;
	Eq_5 esi_134 = __ror<word32,byte>(esi_120, 0x17);
	ui24 ch_cx_1226 = SEQ(ch_145, 228, (byte) ecx_132) + SEQ(al_1110, (word16) esi_134);
	word16 cx_143 = (word16) ch_cx_1226;
	uint32 ecx_129 = SEQ(ecx_24_8_128, SLICE(v367_1229, byte, 32));
	ui8 ch_145 = SLICE(cx_143, byte, 8);
	uint32 ecx_155 = SEQ(SLICE(ecx_132, word16, 16), SLICE(ch_cx_1226, byte, 16), (byte) cx_143);
	Eq_2 eax_1264 = SEQ(eax_24_8_1095, al_1110);
	if (esi_134 == 0x89C8C802)
		return eax_1264;
	Eq_10 cl_158 = (byte) (ecx_155 >> 0x05) ^ dl_87;
	int32 edx_168 = SEQ(edx_16_16_166, __rcr<byte,byte>(dh_83 | 0x52, cl_158, false), dl_87 | bh_159) >> cl_158;
	byte bh_170 = bh_159 | SLICE(edx_168, byte, 8);
	Eq_294 edx_173 = edx_168 + SEQ(ebx_16_16_1121, bh_170, bl_149 + 0x01);
	byte ch_1118 = SLICE(ecx_155 >> 0x05, byte, 8);
	ui16 ecx_16_16_1128 = SLICE(ecx_155 >> 0x05, word16, 16);
	byte dl_1111 = (byte) edx_173;
	word24 edx_24_8_1113 = SLICE(edx_173, word24, 8);
	word16 bx_1116 = SEQ(bh_170, bl_149 + 0x01);
	Eq_9 edi_1124 = SEQ(edi_16_16_1123, __ror<word16,byte>(di_116, cl_158));
	struct Eq_316 * esi_1122 = (word32) esi_134 - 80707904 + (word32) (edx_173 < 0x00);
	Eq_323 cx_1370 = SEQ(ch_1118, cl_158);
	Eq_325 ax_1388 = SEQ(ah_17 - 244, al_1110);
l00406668:
	Eq_560 dx_1394;
	struct Eq_363 * eax_1391;
	Eq_560 dx_1381;
	up32 eax_1378;
	Eq_325 ax_1373;
	Eq_2 eax_1265;
	ui16 edx_16_16_1170;
	Eq_325 eax_986;
	Eq_10 cl_1166;
	Eq_10 ch_450;
	cui16 ebx_16_16_905;
	word16 eax_16_16_1219;
	struct Eq_25 * esi_352;
	uint32 edi_347;
	byte bl_863;
	byte bh_850;
	byte al_1206;
	struct Eq_25 * edi_439;
	uint32 ebx_698;
	word24 ebx_24_8_1208;
	int32 edi_714;
	byte ch_1204;
	byte bl_1203;
	word16 ecx_16_16_1177;
	word16 ebx_16_16_1175;
	Eq_325 ax_1168;
	Eq_560 dx_1167;
	ui8 ch_1164;
	word16 bx_1161;
	struct Eq_40 * edi_212;
	int16 ebx_16_16_402;
	uint8 bl_399;
	struct Eq_316 * esi_339;
	uint8 ch_241;
	byte bh_376;
	Eq_10 cl_243;
	struct Eq_389 * edx_309;
	struct Eq_389 * edx_254;
	bool v371_1233;
	word32 edx_183 = SEQ(edx_24_8_1113, -dl_1111) + 0xB6D1EE04 + (word32) (dl_1111 != 0x00);
	bci8 dl_184 = (byte) edx_183;
	Eq_10 cl_1205 = (byte) cx_1370;
	struct Eq_40 * edx_192 = __rcl<word32,byte>(SEQ(SLICE(edx_183, word24, 8), dl_184 >> 0x06), cl_1205, SLICE(cond(dl_184 >> 0x06), bool, 1));
	struct Eq_25 * ebx_1368 = __rcr<word32,byte>(SEQ(ebx_16_16_1121, bx_1116 ^ cx_1370), 0x1B, false);
	Eq_403 ch_194 = SLICE(cx_1370, byte, 8);
	byte ah_425 = SLICE(ax_1388, byte, 8);
	byte al_369 = (byte) ax_1388;
	cui16 di_1136 = (word16) edi_1124;
	word16 edi_16_16_1141 = SLICE(edi_1124, word16, 16);
	byte dl_206 = (byte) edx_192;
	byte dh_213 = SLICE(edx_192, byte, 8);
	word16 edx_16_16_363 = SLICE(edx_192, word16, 16);
	byte bh_1134 = SLICE(ebx_1368, byte, 8);
	byte bl_1138 = (byte) ebx_1368;
	word16 ebx_16_16_1145 = SLICE(ebx_1368, word16, 16);
	bool v368_1230 = esi_1122 != (struct Eq_316 *) 3447842038;
	word24 ecx_24_8_219 = SEQ(ecx_16_16_1128, ch_194);
	if (esi_1122 == (struct Eq_316 *) 3447842038)
	{
		ebp = ebp->ptr0000;
		esp_252 = (struct Eq_3 *) ((char *) &ebp->ptr0000 + 4);
		eax_1391 = SEQ(eax_16_16_1147, ah_425, al_369);
		if (OVERFLOW<word32>(esi_1122 - (struct Eq_316 *) 3447842038))
			goto l00406659;
		edx_254 = (struct Eq_389 *) (edx_192 + 1);
		v371_1233 = !OVERFLOW<word32>(edx_192 + 1);
		ax_1373 = SEQ(eax_16_16_1147, ah_425, ~0x09);
l0040668F:
		word24 edx_24_8_308 = SLICE(edx_254, word24, 8);
		__fsave(edx_254->w0000);
		eax_16_16_1147 = SLICE(ax_1373, word16, 16);
		byte al_318 = (byte) ax_1373;
		word16 si_291 = (word16) esi_1122;
		bcu8 ah_283 = SLICE(ax_1373, byte, 8);
		byte dl_273 = (byte) edx_254;
		byte dh_323 = (byte) edx_24_8_308;
		edx_16_16_1170 = SLICE(edx_24_8_308, word16, 8);
		if (!v371_1233)
			__syscall<byte>(0x04);
		byte cl_264 = cl_1205 & bh_1134;
		ch_241 = ch_194 >> cl_264;
		ui16 di_271 = di_1136 << cl_264 - 0x01;
		word24 ebx_24_8_298 = SEQ(ebx_16_16_1145, bh_1134 | ~0x41);
		edx_309 = edx_254;
		word24 ecx_24_8_315 = SEQ(ecx_16_16_1128, ch_241);
		cl_243 = ah_283 >> ah_283;
		word32 ebx_301 = SEQ(ebx_24_8_298, ~bl_1138 | ah_283) + ~0x09AF070A + (word32) (cl_243 < 0x00);
		byte bl_326 = (byte) ebx_301;
		word16 ebx_16_16_334 = SLICE(ebx_301, word16, 16);
		struct Eq_468 * ecx_316 = SEQ(ecx_24_8_315, cl_243);
		esi_339 = esi_1122;
		ui32 ebx_354 = SEQ(ebx_16_16_334, __rcr<byte,byte>(SLICE(ebx_301, byte, 8), cl_243, SLICE(cond(ebx_301), bool, 1)), bl_326);
		edi_212 = SEQ(edi_16_16_1141 ^ 56151, (di_271 ^ 33729) + si_291);
		if (edx_254 != (struct Eq_389 *) ~0x312D22A8)
		{
			__syscall<byte>(0x2E);
			word32 ecx_322 = ecx_316 - ax_1373;
			uint32 ebx_335 = SEQ(ebx_16_16_334, ah_283, bl_326 + ~0x41);
			ch_450 = SLICE(ecx_322, byte, 8);
			cl_1166 = (byte) ecx_322;
			ecx_16_16_1128 = SLICE(ecx_322, word16, 16);
			byte dl_325 = dl_273 | dh_323;
			Eq_10 dh_332 = __rcr<byte,byte>(dh_323 - 0x01, 0x08, SLICE(cond(bl_326 + ~0x41), bool, 1));
			bh_850 = SLICE(ebx_335 >> 0x17, byte, 8);
			bl_863 = (byte) (ebx_335 >> 0x17);
			ebx_16_16_905 = SLICE(ebx_335 >> 0x17, word16, 16);
			eax_986 = ax_1373;
			if (esi_1122 != (struct Eq_316 *) 2483492939)
				goto l00406A65;
			edi_347 = esp_252->dw0000;
			++esp_252;
			esi_352 = (struct Eq_25 *) (esi_1122 + 2);
			eax_1378 = SEQ(SLICE(ax_1373, word24, 8), esi_1122->b0000 ^ 0x1A);
			dx_1394 = SEQ(dh_332, dl_325);
			goto l00406903;
		}
		ecx_316->dw004E &= ebx_354 - 0x01;
		*(byte *) 3627220289 = al_318;
		bh_376 = SLICE(ebx_354 - 0x01, byte, 8);
		bl_399 = bl_326 - 0x01;
		ebx_16_16_402 = SLICE(ebx_354 - 0x01, word16, 16);
	}
	else
	{
		byte bl_207 = (byte) ebx_1368 | 0xAA;
		uint32 esi_215 = esi_1122 >> 0x13;
		byte bh_228 = SLICE(ebx_1368, byte, 8) | ~0x04;
		cui16 ebx_16_16_244 = SLICE(ebx_1368, word16, 16) | 61119;
		byte dl_208 = dl_206 & bl_207;
		edi_212 = __rcl<word32,byte>(edi_1124, 0x0D, false);
		cui16 si_230 = (word16) esi_215;
		word16 esi_16_16_394 = SLICE(esi_215, word16, 16);
		word32 ecx_221 = -SEQ(ecx_24_8_219, cl_1205 << cl_1205);
		Eq_10 dh_227 = __rcr<byte,byte>(dh_213 + 0x01, 0x07, false);
		byte cl_223 = (byte) ecx_221;
		byte ch_240 = SLICE(ecx_221, byte, 8);
		ecx_16_16_1128 = SLICE(ecx_221, word16, 16);
		ui32 ebx_245 = SEQ(ebx_16_16_244, bh_228 + 0x01, bl_207);
		esi_339 = SEQ(esi_16_16_394, si_230 & SEQ(dh_227, dl_208));
		ch_241 = ch_240 - 0x01;
		cl_243 = (byte) dh_227 + (cl_223 & ~0x2A) + (dl_208 - 0x01) + (byte) (dh_227 << 0x1C < 0x00);
		bh_376 = SLICE(ebx_245 << 0x1A, byte, 8);
		bl_399 = bl_207 << 0x1A;
		ebx_16_16_402 = SLICE(ebx_245 << 0x1A, word16, 16);
		edx_309 = SEQ(edx_16_16_363, dh_227 << 0x1C, dl_208 - 0x01);
		ax_1373 = ax_1388;
	}
	uint32 edx_365 = edx_309 >> 0x1A;
	uint8 bh_379 = bh_376 << 0x07;
	word32 edx_384 = SEQ(SLICE(edx_365, word16, 16), SEQ(SLICE(edx_365, byte, 8), (byte) edx_365 + (byte) ax_1373 + (byte) (edx_365 < 0x00)) >> cl_243) + 3387363075 + (word32) (bh_379 < 0x00);
	byte ah_424 = SLICE(ax_1373, byte, 8);
	byte dl_412 = (byte) edx_384;
	edx_16_16_1170 = SLICE(edx_384, word16, 16);
	ui32 ecx_392 = SEQ(ecx_16_16_1128, ch_241 | 0x7F, cl_243);
	ui32 ecx_396 = ecx_392 | esi_339;
	int32 ebx_407 = SEQ(ebx_16_16_402, bh_379 | ~0x48, bl_399) >> ((byte) ecx_396 << 0x09);
	byte bl_413 = (byte) ebx_407;
	ebx_16_16_1175 = SLICE(ebx_407, word16, 16);
	byte dl_414 = dl_412 + bl_413;
	ui32 ecx_416 = ecx_396 << 0x09 | 3157747589;
	byte cl_431 = (byte) ecx_416;
	Eq_9 edi_422 = edi_212 << 0x09;
	word32 ecx_432 = SEQ(SLICE(ecx_416, word16, 16), ah_424, cl_431);
	esi_1122 = esi_339 + 0x1850ED54 + (word32) (edi_422 < 0x00);
	ch_1164 = SLICE(ecx_432 - 0x92DA1332, byte, 8);
	cl_1166 = cl_431 - 0x32;
	ecx_16_16_1177 = SLICE(ecx_432 - 0x92DA1332, word16, 16);
	Eq_755 v64_435 = (edi_422 & 0x00080000) != 0x00;
	struct Eq_40 * edi_437 = __rcl<word32,byte>(edi_422, 0x0D, SLICE(cond(ecx_432 - 0x92DA1332), bool, 1));
	bx_1161 = SEQ(0x5D, bl_413);
	dx_1167 = SEQ(0x19, dl_414 | 0x4C);
	ax_1168 = ax_1373;
	edi_439 = edi_437 - 1221646791 - v64_435;
l00406A3D:
	word16 bx_442 = bx_1161 - 0x01;
	ui32 edx_456 = SEQ(edx_16_16_1170, dx_1167 - ax_1168) << cl_1166;
	ch_450 = __ror<byte,byte>(__rol<byte,byte>(ch_1164, 0x18), cl_1166);
	byte al_1157 = (byte) ax_1168;
	byte ah_1160 = SLICE(ax_1168, byte, 8);
	int32 ebx_459 = SEQ(ebx_16_16_1175, SLICE(bx_442, byte, 8) & 0x5B, (byte) bx_442);
	byte dl_476 = (byte) edx_456;
	Eq_10 dh_485 = SLICE(edx_456, byte, 8);
	word16 edx_16_16_491 = SLICE(edx_456, word16, 16);
	ui32 ecx_462 = SEQ(ecx_16_16_1177, ch_450, cl_1166);
	if (ecx_462 == 3966249975)
	{
		eax_986.u1 = esp_252->dw0002;
l00406A65:
		word16 esi_16_16_1038 = SLICE(esi_1122, word16, 16);
		ci16 si_1010 = (word16) esi_1122;
		ci16 ax_1020 = (word16) eax_986;
		word16 eax_16_16_1266 = SLICE(eax_986, word16, 16);
		ui8 ch_995 = ch_450 << cl_1166;
		if (eax_986 != 0xC0000005)
		{
			int16 ax_1024 = ax_1020 >> cl_1166;
			byte ah_1026 = SLICE(ax_1024, byte, 8);
			byte al_1032 = (byte) ax_1024;
			ui8 ah_1027 = ah_1026 << cl_1166;
			byte al_1033 = al_1032 & ah_1027;
			return SEQ(eax_16_16_1266, ah_1027 | ch_995, al_1033);
		}
		esi = SEQ(esi_16_16_1038, si_1010 >> cl_1166);
		goto l00406350;
	}
	ui32 ecx_466 = ecx_462 & esi_1122;
	Eq_5 esi_467 = esi_1122 - 0x452F6B28;
	Eq_10 cl_482 = (byte) ecx_466;
	Eq_5 esi_474 = __ror<word32,byte>(__rcr<word32,byte>(esi_467, 0x17, SLICE(cond(esi_467), bool, 1)) ^ 0x910E1F4B, 0x02);
	byte dl_477 = ~dl_476;
	word32 ecx_490 = SEQ(SLICE(ecx_466, word16, 16), SLICE(ecx_466, byte, 8) - 0x01, cl_482);
	word16 edi_16_16_1126 = SLICE(__ror<word32,byte>(edi_439, cl_482), word16, 16);
	Eq_10 dh_487 = __ror<byte,byte>(dh_485, cl_482);
	cx_1370 = ecx_490 - SEQ(edx_16_16_491, dh_487, dl_477) - ((dh_485 & 0x01 << cl_482) != 0x00);
	ebx_1368 = ebx_459 >> 0x1C << 0x06;
	ecx_16_16_1128 = SLICE(cx_1370, word16, 16);
	esi_1122 = esi_474 << 0x1B;
	edx_192 = ~SEQ(edx_16_16_491, SEQ(dh_487, dl_477) << (byte) cx_1370) + (esi_474 << 0x1B);
	v368_1230 = ebx_1368 != (struct Eq_25 *) 1281129383;
	edi_1124 = SEQ(edi_16_16_1126, ax_1168);
	eax_1391 = SEQ(eax_16_16_1147, ah_1160, al_1157);
l00406659:
	eax_16_16_1147 = SLICE(eax_1391, word16, 16);
	Eq_10 cl_1115 = (byte) cx_1370;
	bx_1116 = (word16) ebx_1368;
	ebx_16_16_1121 = SLICE(ebx_1368, word16, 16);
	dl_1111 = (byte) edx_192;
	edx_24_8_1113 = SLICE(edx_192, word24, 8);
	byte dh_1183 = SLICE(edx_192, byte, 8);
	word16 edx_16_16_1184 = SLICE(edx_192, word16, 16);
	word24 ecx_24_8_1181 = SEQ(ecx_16_16_1128, SLICE(cx_1370, byte, 8));
	struct Eq_363 * eax_1375 = eax_1391;
	if (!v368_1230)
	{
		uint8 v55_967 = edx_192[75] << 0x01;
		edx_192[75] = (struct Eq_40) v55_967;
		ebx_1368->dwC0D68121 = ebx_1368->dwC0D68121 - edx_192 - (word32) (v55_967 < 0x00);
		ax_1388 = (word16) eax_1391;
		goto l00406668;
	}
	while (true)
	{
		Eq_10 cl_515 = __ror<byte,byte>(cl_1115, 0x11);
		word32 ecx_518 = SEQ(ecx_24_8_1181, cl_515);
		ui16 eax_16_16_638 = SLICE(eax_1375, word16, 16);
		ui8 ah_596 = SLICE(eax_1375, byte, 8);
		byte bl_511 = (byte) ebx_1368;
		byte al_509 = (byte) eax_1375;
		byte ch_523 = SLICE(ecx_518 - 0x98058091, byte, 8);
		word16 ecx_16_16_541 = SLICE(ecx_518 - 0x98058091, word16, 16);
		ui8 dh_527 = dh_1183 + 0x01;
		uint32 ecx_542 = SEQ(ecx_16_16_541, ch_523 - 0x99 & 0x0E, cl_515 - 0x91);
		uint32 edi_547 = edi_1124 - ~0x0650F355 - (word32) (ecx_542 >> 0x08 < 0x00);
		word32 edx_534 = SEQ(edx_16_16_1184, __rol<byte,byte>(dh_527, 0x0C), bl_511);
		ui32 ebx_538 = ebx_1368 << cl_515 - 0x91;
		struct Eq_25 * ecx_552 = __rcr<word32,byte>(ecx_542 >> 0x08, (byte) (ecx_542 >> 0x08), SLICE(cond(edi_547), bool, 1));
		dx_1381 = edx_534 + 3813743677 ^ 321521378;
		struct Eq_25 * ebx_558 = __rcr<word32,byte>(SEQ(SLICE(ebx_538, word24, 8), (byte) ebx_538 << 0x0A), 0x07, false);
		ch_1204 = SLICE(ecx_552, byte, 8);
		cl_1205 = (byte) ecx_552;
		ecx_16_16_1128 = SLICE(ecx_552, word16, 16);
		ui8 dh_562 = SLICE(dx_1381, byte, 8);
		byte dl_589 = (byte) dx_1381;
		Eq_560 dx_712 = (word16) dx_1381;
		edx_16_16_1170 = SLICE(dx_1381, word16, 16);
		cui16 bx_564 = (word16) ebx_558;
		uint16 ebx_16_16_568 = SLICE(ebx_558, word16, 16);
		bl_1203 = (byte) ebx_558;
		ebx_24_8_1208 = SLICE(ebx_558, word24, 8);
		if (ecx_552 == (struct Eq_25 *) 3811104657)
			break;
		ui40 ch_ebx_1228 = SEQ((ch_1204 | dh_562) - 0x01, ebx_16_16_568, bx_564 << cl_1205) + SEQ(dh_562, 0xAA238F8A);
		Eq_10 ch_573 = SLICE(ch_ebx_1228, byte, 32);
		word32 ebx_570 = (word32) ch_ebx_1228;
		Eq_10 cl_577 = __rcr<byte,byte>(cl_1205, 0x07, SLICE(cond(ch_573), bool, 1));
		byte bh_615 = SLICE(ebx_570, byte, 8);
		word16 ebx_16_16_623 = SLICE(ebx_570, word16, 16);
		byte bl_580 = (bool) ((cl_1205 & 0x80) != 0x00) + ((byte) cl_577.u1 + (byte) ebx_570);
		Eq_10 ch_585 = __rcl<byte,byte>(ch_573, 11, SLICE(cond(dh_562 + 0x29), bool, 1));
		if (esi_1122 == (struct Eq_316 *) 0xCCC5A8A2)
		{
			eax_1375->a0043[ebp].b0000 += dl_589;
			__halt();
		}
		ui32 ecx_604 = SEQ(ecx_16_16_1128, __rcl<byte,byte>(ch_585, cl_577, false), cl_577) << cl_577;
		edx_16_16_1184 = ~0x11E3;
		bcu8 cl_620 = (byte) ecx_604;
		word24 ecx_24_8_651 = SLICE(ecx_604, word24, 8);
		word16 ax_618 = (word16) eax_1375;
		Eq_9 edi_617 = edi_547 >> 0x0F << 0x13;
		Eq_9 ebx_624 = SEQ(ebx_16_16_623, bh_615 + 232, bl_580);
		bool C_626 = SLICE(cond(cl_620 >> 0x0C), bool, 1);
		ui32 edx_636 = SEQ(~0x11E3, ax_618);
		struct Eq_40 * ebx_627 = __rcl<word32,byte>(ebx_624, cl_620 >> 0x0C, C_626);
		Eq_10 ah_631 = __rol<byte,byte>(ah_596, 22);
		Eq_10 cl_634 = __rcl<byte,byte>(cl_620 >> 0x0C, cl_620 >> 0x0C, false);
		byte bh_649 = SLICE(ebx_627, byte, 8);
		bcu8 bl_661 = (byte) ebx_627;
		word16 ebx_16_16_662 = SLICE(ebx_627, word16, 16);
		esi_1122 |= edx_636;
		struct Eq_40 * edi_644 = __rcl<word32,byte>(edi_617, cl_634, SLICE(cond(SEQ(eax_16_16_638, ah_631, al_509 + 0x12 + ((ebx_624 & 0x01 << 0x20 - (cl_620 >> 0x0C)) != 0x00)) << 0x18), bool, 1));
		ui32 ecx_652 = SEQ(ecx_24_8_651, cl_634);
		edi_1124 = __rol<word32,byte>(edi_644, 0x15);
		word32 ebx_663 = SEQ(ebx_16_16_662, bh_649 & 0x40, bl_661);
		word32 ecx_660 = __rcl<word32,byte>(ecx_652 & 345442371, 0x18, (edi_644 & 0x0800) != 0x00) - edx_636 - (((ecx_652 & 345442371) & 0x0100) != 0x00);
		word16 bx_671 = SEQ(SLICE(ebx_663 - 0x01, byte, 8), bl_661 - 0x01 >> 0x1D) - ax_618 - (word16) (bl_661 - 0x01 >> 0x1D < 0x00);
		cl_1115 = (byte) ecx_660;
		word16 ebx_16_16_686 = SLICE(ebx_663 - 0x01, word16, 16);
		di_1136 = (word16) edi_1124;
		edi_16_16_1141 = SLICE(edi_1124, word16, 16);
		ch_194 = SLICE(ecx_660, byte, 8);
		ecx_16_16_1128 = SLICE(ecx_660, word16, 16);
		ecx_24_8_1181 = SLICE(ecx_660, word24, 8);
		byte bl_1180 = (byte) bx_671;
		ui8 dl_674 = al_509 ^ cl_1115;
		dh_1183 = 0x00;
		word32 ebx_687 = SEQ(ebx_16_16_686, bx_671);
		word24 ebx_24_8_1187 = SEQ(ebx_16_16_686, SLICE(bx_671, byte, 8));
		if (esi_1122 != (struct Eq_316 *) 0x4F427AF6)
		{
			word32 ebx_688 = ebx_687 + ecx_660;
			cl_1205 = __rcl<byte,byte>(cl_1115, cl_1115, false);
			esi_1122 = esi_1122 | 1913885939 | 0x055D5B8B;
			bh_1134 = SLICE(ebx_688, byte, 8);
			bl_1138 = (byte) ebx_688;
			ebx_16_16_1145 = SLICE(ebx_688, word16, 16);
			edx_254 = SEQ(0x00EE1C00, dl_674 - 0x01) - 926847292;
			v371_1233 = !OVERFLOW<word32>(ebx_688 - 0xCBF2006F);
			ax_1373.u1 = 0x00;
			if (ebx_688 != 0xCBF2006F)
				goto l0040668F;
			__sti();
			edi_439 = null;
			al_1206 = (byte) edi_1124;
			eax_16_16_1219 = SLICE(edi_1124, word16, 16);
			ebx_698 = 0xD3A95209;
			goto l0040695D;
		}
		esp_252 -= 4;
		esp_252->dw0000 = 53900805;
		ebx_1368 = SEQ(ebx_24_8_1187, bl_1180);
		eax_1375 = null;
	}
	word32 eax_713 = __in<word32>(dx_712);
	al_1206 = (byte) eax_713;
	eax_16_16_1219 = SLICE(eax_713, word16, 16);
	edi_714 = edi_547 + 4;
l00406A0E:
	ch_194 = (ch_1204 + (byte) dx_1381 | 223) >> 0x15;
	Eq_9 edi_734 = edi_714 >> 0x1C;
	byte bl_746 = (bool) ((edi_734 & 0x01 << 0x20 - cl_1205) != 0x00) + (bl_1203 + al_1206);
	struct Eq_40 * edi_741 = __rcl<word32,byte>(edi_734, cl_1205, SLICE(cond(ch_194), bool, 1));
	uint32 ebx_748 = SEQ(ebx_24_8_1208, bl_746);
	ebx_16_16_1175 = SLICE(ebx_24_8_1208, word16, 8);
	esi_1122 |= 4050339896;
	edi_439 = SEQ(SLICE(edi_741, word16, 16), (word16) edi_741 - 0x01);
	dx_1167 = dx_1381;
	bool C_963 = SLICE(cond(ebx_748 - ~0x061444C1), bool, 1);
	bx_1161 = SEQ((byte) ebx_24_8_1208, bl_746);
	if (ebx_748 == ~0x061444C1)
	{
		word32 eax_959 = __in<word32>(dx_1381);
		*(union Eq_10 *) 0xBCBA17C0 = __rcr<byte,byte>(*(union Eq_10 *) 0xBCBA17C0, 0x3F, C_963);
		eax_16_16_1147 = SLICE(eax_959, word16, 16);
		ax_1168 = (word16) eax_959;
		cl_1166.u0 = 0x3F;
		ch_1164 = 0x18;
		ecx_16_16_1177 = ~0x4345;
		goto l00406A3D;
	}
	ebx_698 = ebx_748 >> cl_1205;
l0040695D:
	ui32 ebx_754 = ebx_698 ^ 0x40592DA2;
	cu8 cl_765 = (byte) cl_1205 + 64;
	byte ch_757 = ch_194 & 0x08;
	word24 ebx_24_8_784 = SLICE(ebx_754, word24, 8);
	esi_352 = esi_1122 - edi_439 - (word32) (cl_765 < 0x00);
	word16 cx_774 = SEQ(-ch_757, cl_765);
	word32 ebx_785 = SEQ(ebx_24_8_784, (bool) (ch_757 != 0x00) + ((byte) cl_1205 + (byte) ebx_754));
	word32 ecx_781 = (bool) (cx_774 != 0x00) + (SEQ(ecx_16_16_1128, -cx_774) + 2678744548);
	bci8 cl_782 = (byte) ecx_781;
	ui16 bx_787 = (word16) ebx_785 ^ ~0x1606;
	struct Eq_25 * ebx_794 = __rcr<word32,byte>(SEQ(SLICE(ebx_24_8_784, word16, 8) ^ ~0x2127, __ror<word16,byte>(bx_787, cl_782 >> 0x1D)), 0x06, (bx_787 & 0x01 << (cl_782 >> 0x1D)) != 0x00);
	byte ch_798 = -SLICE(ecx_781, byte, 8);
	ecx_16_16_1128 = SLICE(ecx_781, word16, 16);
	bci8 bl_795 = (byte) ebx_794;
	ebx_16_16_905 = SLICE(ebx_794, word16, 16);
	cui16 cx_833 = SEQ(ch_798, cl_782 >> 0x1D);
	if (esi_352 != (struct Eq_25 *) ~0x2482BFB4)
	{
		eax_1265 = gs;
		return eax_1265;
	}
	esi_352->bFFFFFFD3 &= ~0x29;
	uint16 cx_836 = __ror<word16,byte>(SEQ(ch_798, cl_782 >> 0x1D), cl_782 >> 0x1D);
	cl_1166 = (byte) cx_836;
	int16 bx_841 = ~SEQ((bl_795 >> 0x09) + 191, bl_795 >> 0x09);
	ch_450 = __rcl<byte,byte>(SLICE(cx_836, byte, 8) - 0x01, cl_1166, (cx_833 & 0x01 << (cl_782 >> 0x1D)) != 0x00) >> cl_1166;
	edx_16_16_1170 = 0x00;
	bh_850 = SLICE(bx_841, byte, 8);
	bl_863 = (byte) bx_841;
	edi_347 = edi_439 >> 11;
	eax_1378 = SEQ(eax_16_16_1219, 0x03, al_1206 ^ ~0x02);
	dx_1394.u0 = 0x00;
	if (SEQ(ecx_16_16_1128, ch_450, cl_1166) == 0xA0863C1A)
	{
		__in<word32>(0x00);
		__out<byte>(0x00, (byte) __in<word32>(0x00));
	}
l00406903:
	Eq_2 ax_867 = (word16) eax_1378;
	byte bh_857 = (byte) ch_450 + bh_850;
	eax_16_16_1219 = SLICE(eax_1378, word16, 16);
	al_1206 = (byte) ax_867;
	bci8 bl_866 = bl_863 - 0x01;
	gs = ax_867;
	uint32 edi_872 = edi_347 + 857454881;
	ui8 ch_876 = __rcl<byte,byte>(ch_450, 0x09, SLICE(cond(bh_857), bool, 1)) << cl_1166;
	ui8 bh_877 = bh_857 ^ cl_1166;
	Eq_10 cl_878 = cl_1166 | 0x95;
	bool C_883 = SLICE(cond(esi_352 - (struct Eq_25 *) 1625695101), bool, 1);
	if (esi_352 == (struct Eq_25 *) 1625695101)
	{
		if (esi_352 < (struct Eq_25 *) 1625695101)
		{
			eax_1265 = fnC1795C47();
			return eax_1265;
		}
	}
	Eq_10 cl_884 = __rcr<byte,byte>(cl_878, 0x05, C_883);
	word16 bx_889 = ~SEQ(__rol<byte,byte>(bh_877, 0x04), bl_866 - 220 >> 11);
	byte bl_890 = (byte) bx_889;
	byte bh_908 = SLICE(bx_889, byte, 8);
	edi_714 = edi_872 - ~0x560B31B1;
	word16 di_912 = (word16) edi_872 - ~0x31B1;
	if (eax_1378 == 3077334464)
		;
	ui16 cx_913 = SEQ(ch_876, cl_884) ^ di_912;
	word16 cx_927 = -SEQ(SLICE(cx_913, byte, 8), 0x00);
	bl_1203 = (bl_890 << 0x0A & 118) + 0x50;
	esi_1122 = esi_352 + 0x20D90792 + CONVERT(eax_1378 <u 3077334464, bool, word32) - ~0x4A08F1F2;
	ch_1204 = SLICE(cx_927, byte, 8);
	cl_1205 = (byte) cx_927;
	ebx_24_8_1208 = SEQ(ebx_16_16_905 & 0x3059, __ror<byte,byte>(bh_908 & 0x03, (byte) cx_913));
	dx_1381 = dx_1394;
	goto l00406A0E;
}

