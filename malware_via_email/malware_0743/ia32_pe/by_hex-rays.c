/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __stdcall sub_401000(unsigned int *a1, int a2, signed int a3);
// int __usercall sub_4011FF@<eax>(int@<eax>, int@<ebp>);
// int __usercall sub_40126D@<eax>(_BYTE *@<edi>, _BYTE *@<esi>);
// int __usercall sub_401285@<eax>(int@<ebx>);
// int __usercall sub_401537@<eax>(HMODULE@<ebx>, const CHAR *@<edi>, FARPROC *@<esi>);
int sub_401596();
// int byte_40815A(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401259; // weak
__int16 word_401FFE; // weak
int dword_4020F4 = 0; // weak
int dword_403748 = 1549556828; // weak
int dword_40374C = 1549556828; // weak
int dword_403750 = 1549556828; // weak
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);


//----- (00401000) --------------------------------------------------------
void __stdcall sub_401000(unsigned int *a1, int a2, signed int a3)
{
  __m64 v3; // mm2
  unsigned int v4; // esi
  __m64 v5; // mm7
  __m64 v6; // mm4
  unsigned int v7; // edi
  unsigned int v8; // eax
  __m64 v9; // mm0
  unsigned int v10; // ebx
  __m64 v11; // mm1
  unsigned int v12; // eax
  __m64 v13; // mm3
  unsigned int *v14; // edx
  int v15; // ebx
  int v16; // eax
  unsigned int v17; // ebx
  int v18; // ecx
  unsigned int v19; // ecx
  __m64 v20; // mm4
  unsigned int i; // eax
  __m64 v22; // mm7
  __m64 v23; // mm1
  signed int v24; // ecx
  __m64 v25; // mm3
  unsigned int v26; // ebx
  int v27; // ecx
  unsigned int v28; // eax
  bool v29; // cc
  unsigned int v30; // edi

  _m_empty();
  v3 = _mm_cvtsi32_si64(a3);
  v4 = *a1;
  if ( a3 > 1 )
  {
    v5 = _mm_cvtsi32_si64(0);
    v6 = _mm_cvtsi32_si64(a3 - 1);
    v7 = a1[a3 - 1];
    v8 = 0x34u / a3 + 6;
    do
    {
      v9 = _mm_cvtsi32_si64(v8 - 1);
      v10 = _mm_cvtsi64_si32(v5) - 1640531527;
      v5 = _mm_cvtsi32_si64(v10);
      v11 = _mm_cvtsi32_si64((v10 >> 2) & 3);
      v12 = 0;
      v13 = _mm_cvtsi32_si64(0);
      v14 = a1;
      do
      {
        v15 = ((v7 ^ *(_DWORD *)(a2 + 4 * (_mm_cvtsi64_si32(v11) ^ _mm_cvtsi64_si32(v13) & 3)))
             + (v14[v12 + 1] ^ _mm_cvtsi64_si32(v5))) ^ (((16 * v7) ^ (v14[v12 + 1] >> 3))
                                                       + ((4 * v14[v12 + 1]) ^ (v7 >> 5)));
        v16 = _mm_cvtsi64_si32(v13);
        v14 = a1;
        v17 = a1[v16] + v15;
        v7 = v17;
        a1[v16] = v17;
        v12 = v16 + 1;
        v13 = _mm_cvtsi32_si64(v12);
      }
      while ( v12 != _mm_cvtsi64_si32(v6) );
      v18 = _mm_cvtsi64_si32(v6);
      v7 = a1[v18]
         + (((v17 ^ *(_DWORD *)(a2 + 4 * (_mm_cvtsi64_si32(v11) ^ _mm_cvtsi64_si32(v13) & 3)))
           + (*a1 ^ _mm_cvtsi64_si32(v5))) ^ (((16 * v17) ^ (*a1 >> 3)) + ((4 * *a1) ^ (v17 >> 5))));
      a1[v18] = v7;
      v8 = _mm_cvtsi64_si32(v9);
    }
    while ( v8 );
  }
  else if ( a3 < -1 )
  {
    v19 = -_mm_cvtsi64_si32(v3) - 1;
    v20 = _mm_cvtsi32_si64(v19);
    for ( i = -1640531527 * (0x34 / (v19 + 1) + 6); i; i = _mm_cvtsi64_si32(v22) + 1640531527 )
    {
      v22 = _mm_cvtsi32_si64(i);
      v23 = _mm_cvtsi32_si64((i >> 2) & 3);
      v24 = _mm_cvtsi64_si32(v20);
      if ( v24 <= 0 )
        break;
      do
      {
        v25 = _mm_cvtsi32_si64(v24);
        v26 = ((a1[v24 - 1] ^ *(_DWORD *)(a2 + 4 * (_mm_cvtsi64_si32(v23) ^ _mm_cvtsi64_si32(v25) & 3)))
             + (v4 ^ _mm_cvtsi64_si32(v22))) ^ (((16 * a1[v24 - 1]) ^ (v4 >> 3)) + ((4 * v4) ^ (a1[v24 - 1] >> 5)));
        v27 = _mm_cvtsi64_si32(v25);
        v28 = a1[v27] - v26;
        v4 = v28;
        a1[v27] = v28;
        v29 = v27 <= 1;
        v24 = v27 - 1;
      }
      while ( !v29 );
      v30 = a1[_mm_cvtsi64_si32(v20)];
      v4 = *a1
         - (((v30 ^ *(_DWORD *)(a2 + 4 * (_mm_cvtsi64_si32(v23) ^ _mm_cvtsi64_si32(_mm_cvtsi32_si64(v24)) & 3)))
           + (v28 ^ _mm_cvtsi64_si32(v22))) ^ (((16 * v30) ^ (v28 >> 3)) + ((4 * v28) ^ (v30 >> 5))));
      *a1 = v4;
    }
  }
}

//----- (004011FF) --------------------------------------------------------
int __usercall sub_4011FF@<eax>(int a1@<eax>, int a2@<ebp>)
{
  int v2; // edi
  int v3; // esi
  int v5[2]; // [esp+0h] [ebp-8h] BYREF

  LOWORD(a1) = a1 & 0x1000;
  v2 = a1;
  v5[1] = (int)&loc_401259;
  v5[0] = (int)NtCurrentTeb()->NtTib.ExceptionList;
  while ( 1 )
  {
    dword_403748 = (int)v5;
    dword_40374C = a2;
    dword_403750 = v2;
    if ( *(_WORD *)v2 == 23117 )
    {
      v3 = v2;
      v2 += *(_DWORD *)(v2 + 60);
      if ( *(_WORD *)v2 == 17744 )
        break;
    }
    v2 -= 4096;
  }
  return v3;
}
// 403748: using guessed type int dword_403748;
// 40374C: using guessed type int dword_40374C;
// 403750: using guessed type int dword_403750;

//----- (0040126D) --------------------------------------------------------
int __usercall sub_40126D@<eax>(_BYTE *a1@<edi>, _BYTE *a2@<esi>)
{
  int v2; // edx
  bool v3; // zf
  _BYTE *v5; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( *a2 )
  {
    v3 = *a2++ == *a1++;
    if ( !v3 )
    {
      do
        v3 = *a1++ == 0;
      while ( !v3 );
      a2 = v5;
      ++v2;
    }
  }
  return v2;
}
// 40127D: variable 'v5' is possibly undefined

//----- (00401285) --------------------------------------------------------
int __usercall sub_401285@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // ebp
  int result; // eax

  if ( ((int (*)(void))(&byte_40815A + 13))() == -2 )
    a1 = dword_4020F4;
  v1 = (_DWORD *)(a1 + *(_DWORD *)(a1 + *(_DWORD *)(a1 + 60) + 120));
  result = a1
         + *(_DWORD *)(a1
                     + v1[7]
                     + 4
                     * *(unsigned __int16 *)(a1
                                           + v1[9]
                                           + 2 * sub_40126D((_BYTE *)(a1 + *(_DWORD *)(a1 + v1[8])), &dword_4020F4)
                                           + 2
                                           - 2 * v1[4]));
  dword_4020F4 = result;
  return result;
}
// 4020F4: using guessed type int dword_4020F4;
// 40815A: using guessed type int byte_40815A(void);

//----- (00401537) --------------------------------------------------------
int __usercall sub_401537@<eax>(HMODULE a1@<ebx>, const CHAR *a2@<edi>, FARPROC *a3@<esi>)
{
  int result; // eax

  do
  {
    *a3 = GetProcAddress(a1, a2);
    result = 0;
    a2 += strlen(a2) + 1;
    ++a3;
  }
  while ( *a2 );
  return result;
}

//----- (00401596) --------------------------------------------------------
int sub_401596()
{
  int v0; // ebx

  v0 = ((int (*)(void))(&byte_40815A + 13))();
  return ((int (*)(void))((char *)&word_401FFE - v0))();
}
// 401FFE: using guessed type __int16 word_401FFE;
// 40815A: using guessed type int byte_40815A(void);

// nfuncs=6 queued=6 decompiled=6 lumina nreq=0 worse=0 better=0
// ALL OK, 6 function(s) have been successfully decompiled
