/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __userpurge sub_40D82C@<eax>(int _EAX@<eax>, unsigned int _EDX@<edx>, int _ECX@<ecx>, unsigned int _EBX@<ebx>, int@<ebp>, int@<edi>, int@<esi>, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);


//----- (0040D82C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge sub_40D82C@<eax>(
        int _EAX@<eax>,
        unsigned int _EDX@<edx>,
        int _ECX@<ecx>,
        unsigned int _EBX@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  char v64; // al
  int v65; // esi
  bool v66; // zf
  bool v67; // sf
  char v68; // of
  char v70; // al
  int v74; // esi
  unsigned int v79; // edi
  int v81; // esi
  unsigned int v86; // edi
  bool v87; // of
  unsigned int v88; // ebx
  int v90; // esi
  unsigned __int8 v94; // cl
  int v95; // ebx
  bool v97; // tt
  int v100; // ebx
  bool v102; // tt
  int v104; // eax
  unsigned int v106; // edx
  unsigned __int64 v107; // kr00_8
  int v108; // eax
  int v109; // edx
  int v110; // eax
  int v111; // edi
  int v114; // esi
  unsigned int v115; // edx
  bool v116; // cf
  int v117; // edi
  int result; // eax
  int v127; // edi
  int v128; // edx
  int v132; // ebx
  int v134; // edi
  int v136; // edx
  int v138; // esi
  unsigned int v141; // edx
  unsigned int v142; // edx
  BOOL v143; // ett
  int v148; // esi
  char v149; // cf
  int v150; // ebx
  int v151; // edi
  char v152; // dh
  int v153; // ecx
  bool v154; // tt
  bool v155; // cf
  unsigned int v156; // edi
  unsigned int v157; // ett
  char v158; // cc
  int v164; // esi
  int v169; // esi
  _BYTE *v170; // edi
  int v171; // edi
  int v175; // edx
  unsigned int v176; // [esp-Ch] [ebp-Ch]
  int v177; // [esp-8h] [ebp-8h] BYREF

  --BYTE1(_EBX);
  LOBYTE(_EAX) = _EAX - _EDX;
  __asm
  {
    rcr     eax, cl
    rcr     bl, cl
  }
  _ESI = a7 >> _ECX;
  v88 = _EBX >> _ECX;
  _ECX = __ROL4__(_ECX, _ECX);
  v177 = _ECX;
  __asm { rcl     dl, cl }
  _EDX = _EDX >> _ECX;
  v86 = a6 + 1;
  v87 = __OFSUB__((_BYTE)v88, -6);
  LOBYTE(v88) = v88 + 6;
  if ( !v87 && v87 )
    __asm { retf    242Ah }
  v152 = BYTE1(_EDX) + 48;
  v153 = _ECX << _ECX;
  v154 = __CFSHR__(v152, v153);
  BYTE1(_EDX) = __ROR1__(v152, v153);
  v157 = v154 + _EDX;
  v155 = v86 < v157;
  v156 = v86 - v157;
  v158 = (v153 + 1 < 0) ^ __OFADD__(1, v153);
  _ECX = v153 + 1;
  if ( v158 || !v158 )
  {
    LOBYTE(v88) = v88 & 0x15;
    v94 = BYTE1(_ECX) & _ECX;
    LOBYTE(_EDX) = _EDX & 0xE6;
    v95 = __ROL4__(v88, v94);
    _CL = __CFSHR__(v156, BYTE1(v95) ^ (v94 >> v94)) + (BYTE1(v95) ^ (v94 >> v94)) - 117;
    BYTE1(_EDX) = BYTE1(_EAX) + (BYTE1(_EDX) | 0x18);
    __asm { rcl     edx, cl }
    JUMPOUT(0x40DE5A);
  }
  *(_BYTE *)(a5 - 756278440) += ((unsigned __int16)&v177 >> 8) + v155;
  *(_BYTE *)_EDX <<= _ECX;
  __asm { lock shl esi, cl }
  v176 = *(_DWORD *)_ECX;
  LOBYTE(_EDX) = _EDX + 1;
  _ESI = _ESI >> _ECX;
  __asm
  {
    rcl     edx, cl
    rcl     esi, cl
  }
  v79 = v156 >> _ECX;
  __asm { rcl     edx, cl }
  BYTE1(_EDX) &= 0xA1u;
  v81 = _ESI - (__CFSHR__(BYTE1(_EDX), _ECX) + v79);
  BYTE1(_EDX) = BYTE1(_ECX) ^ __ROR1__(BYTE1(_EDX), _ECX);
  __asm { rcl     dh, cl }
  v106 = (unsigned __int8)*(_DWORD *)_ECX;
  _BL = *(_DWORD *)_ECX ^ 0x37;
  __asm { rcr     bl, cl }
  _EBX = (unsigned __int8)BYTE1(*(_DWORD *)_ECX);
  _ESI = _ECX & (v81 << _ECX);
  __asm { rcr     esi, cl }
  v169 = (int)((_ECX ^ (_ESI - 1)) - 1) >> _ECX;
  v170 = (_BYTE *)((unsigned __int8)v176 | ((__ROR4__(v79 << _ECX, _ECX) - (unsigned __int8)v176 + 1) << _ECX));
  v104 = (unsigned __int8)v176 + HIWORD(v176);
  BYTE1(v106) = (-90 << _ECX) - (__CFSHL__(-90, _ECX) + v176);
  _ESI = v169 - 1;
  LOBYTE(v106) = (v176 + BYTE2(v176) + v176) ^ 0x42;
  if ( __SETP__(v106, 0) || !__SETP__(v106, 0) )
  {
    BYTE1(v106) += BYTE1(v176) + __CFADD__(BYTE1(v106), 28) + 28;
    v116 = __CFADD__(BYTE1(v176), v104);
    v64 = BYTE1(v176) + v176 + BYTE2(v176);
    v65 = _ESI << _ECX;
    LOBYTE(_EBX) = BYTE1(v176) - 1;
    LOBYTE(v106) = (v64 + v116 + v106) | 0x9A;
    v66 = (_BYTE)v106 == 0;
    v67 = (v106 & 0x80u) != 0;
    _EDX = __ROR4__(v106, _ECX);
    if ( !(v67 ^ v68 | v66) && v67 ^ v68 | v66 )
      JUMPOUT(0x40D512);
    BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ECX);
    BYTE1(_EDX) = __CFADD__(BYTE1(_EDX) << _ECX, -126) + (BYTE1(_EDX) << _ECX) - 126 + 29;
    v70 = v64 ^ 0xC8;
    v116 = __CFADD__(BYTE1(_EBX), 125);
    BYTE1(_EBX) += 125;
    LOBYTE(_EDX) = (_EBX + v116 + _EDX) & 0x33;
    LOBYTE(_EBX) = BYTE1(_EDX) + _EBX;
    BYTE1(_EDX) ^= 0xD1u;
    __asm { rcr     bh, cl }
    v132 = v65 ^ _EBX;
    __asm { rcl     edx, cl }
    LOBYTE(_EDX) = _EDX & 0xF;
    LOBYTE(v132) = v132 - 1;
    _ESI = v65 - 1;
    if ( !__SETP__(_ESI, 0) && __SETP__(_ESI, 0) )
    {
      *v170 = v70;
      JUMPOUT(0x40DBF5);
    }
    BYTE1(_EDX) <<= _ECX;
    __asm { rcr     esi, cl }
    _EDX = v132 + __ROL4__(_EDX, _ECX);
    __asm { rcr     dl, cl }
    JUMPOUT(0x40DB2B);
  }
  if ( (char)(v176 + BYTE2(v176) + v176) >= 0 )
    JUMPOUT(0x40DA66);
  *(int *)(_ESI - 28) >>= _ECX;
  __asm { outsd }
  v107 = __PAIR64__(_ECX, _ECX) + v106;
  v108 = __ROR4__(v104, _ECX);
  v109 = v108 | v107;
  v110 = (v108 | v107) + v108;
  v111 = v110 & (unsigned int)&v170[-HIDWORD(v107)];
  v116 = BYTE1(_EBX) < 0xA8u;
  BYTE1(_EBX) += 88;
  v100 = v109 + v116 + _EBX;
  v102 = __CFSHR__(v110, _ECX);
  _EAX = __ROR4__(v110, _ECX);
  LOBYTE(v109) = v109 - 1;
  BYTE1(_EAX) -= v102 + v109;
  BYTE1(v109) |= BYTE1(_EAX);
  BYTE1(_EAX) -= 71;
  __asm { rcl     eax, cl }
  _EDX = v109 >> _ECX;
  _EBX = v100 >> _ECX;
  __asm { rcl     ebx, cl }
  _ECX = (char *)(_ECX - 442);
  LOBYTE(_EDX) = __ROR1__(_EDX, (char)_ECX);
  LOBYTE(_EBX) = _EBX - 1;
  v74 = _ESI - 1;
  BYTE1(_EBX) |= (unsigned __int16)(_EAX + 1) >> 8;
  BYTE1(_EDX) |= 0x85u;
  LOBYTE(_EBX) = BYTE1(_ECX) | _EBX;
  v134 = (v111 ^ 0x486F4685) + 1;
  BYTE1(_EBX) = _EDX + (((SBYTE1(_EBX) >> (char)_ECX) - 1) ^ 0xE2);
  __asm { rcr     edx, cl }
  v116 = __CFSHL__(_EDX, (_BYTE)_ECX);
  v136 = _EDX << (char)_ECX;
  BYTE1(v136) += v116 + 30;
  LOBYTE(v136) = v136 - 1;
  if ( !__SETP__(v136, 0) && __SETP__(v136, 0) )
  {
    _CL = -88;
    __asm { fstp9   st }
    LOBYTE(v136) = v136 - 1;
    BYTE1(v136) = -123;
    v138 = __ROL4__(v74, 168);
    _EDX = (v136 - v138) << 8;
    LOBYTE(_EDX) = -33;
    __asm { rcl     edx, cl }
    BYTE1(_EDX) = 100;
    --BYTE1(_EBX);
    LOBYTE(_EDX) = __ROR1__(0, 168);
    v97 = __CFSHR__(v138, -88);
    _ESI = __ROR4__(v138, 168);
    _EDX = __ROL4__((_EBX + (unsigned int)v97 + (_EDX >> 8)) >> 8, 168);
    __asm { rcr     esi, cl }
    BYTE1(_EDX) = 47 - (((_BYTE)_EDX != 0) - 29) - 1 + 111;
    LOBYTE(_EDX) = 0;
    BYTE1(_EBX) = __ROR1__(__ROL1__(BYTE1(_EBX), 16), 14);
    __asm { rcr     edx, cl }
    _ESI = _EBX & (((unsigned int)(_ESI - 1044409944) >> 8) + 1) ^ 0x486F4685;
    __asm
    {
      rcr     dl, cl
      rcr     esi, cl
    }
    v90 = _EBX | _ESI;
    LOBYTE(_EDX) = _EDX - 70 - (((unsigned __int8)_EDX < 0x46u) + _EBX);
    BYTE1(_EDX) = __ROR1__(_EBX ^ BYTE1(_EDX), 168);
    v115 = ((v90 | _EDX) - 1) | 0x486F4685;
    LOBYTE(v115) = __ROL1__(v115 + 95, 168);
    BYTE1(v115) = (BYTE1(v115) - 1) & 0xD7;
    v151 = (v90 ^ v115) + 1;
    _ESI = v90 - 1044409944;
    MEMORY[0xC1BF91A8] = BYTE1(_EBX);
    __asm { rcl     esi, cl }
    v114 = _ESI - (__CFSHL__(BYTE1(v115), -88) + 1215252101);
    HIWORD(v115) = HIWORD(v151);
    BYTE1(v115) = BYTE1(v151) + 70;
    v116 = __CFADD__(v151, 1215252101);
    v117 = v151 + 1215252101;
    if ( !v116 && v116 )
      JUMPOUT(0x40DA61);
    v171 = v114 + __CFSHL__(v117 - 1, -88) + ((v117 - 1) << 8);
    _CL = -87;
    BYTE1(v115) = __ROR1__(BYTE1(v115), 169) - 1;
    LOBYTE(v115) = BYTE1(_EBX) ^ __ROR1__(0, 169);
    if ( !__SETP__(v115, 0) && __SETP__(v115, 0) )
    {
      _enable();
      __asm { rcr     byte ptr [ebx], 1 }
      LOBYTE(v115) = __ROL1__(v115, 169);
      _BX = _EBX - 1;
      LOBYTE(_BX) = BYTE1(v115);
      _CL = 127;
      ++BYTE1(v115);
      v116 = __CFADD__(__CFSHR__(-1044409943, 15), (_BYTE)v115);
      LOBYTE(v115) = __CFSHR__(-1044409943, 15) + v115;
      v116 |= __CFADD__(HIBYTE(_BX), (_BYTE)v115);
      LOBYTE(v115) = HIBYTE(_BX) + v115;
      v175 = v115 - 1;
      __asm { rcr     bh, cl }
      LOBYTE(v175) = _BX + v116 + v175;
      v175 >>= 31;
      _CL = 0;
      LOBYTE(v175) = v175 | 7;
      _EDI = v171 + 1 - v175;
      __asm { rcl     edi, cl }
      JUMPOUT(0x40D897);
    }
    SBYTE1(v115) >>= 7;
    v141 = v115 >> 9;
    BYTE1(v141) = __ROR1__(BYTE1(v141), 169);
    v116 = __CFSHL__(v141, -87);
    LOBYTE(v141) = 0;
    v143 = v116;
    v116 = __CFADD__(v116, v141);
    v142 = v143 + v141;
    v116 |= __CFADD__(_EBX, v142);
    v142 += _EBX;
    LOBYTE(v142) = v142 - (v116 - 111);
    BYTE1(v142) ^= 0xD0u;
    _ESI = (v142 & (v114 >> 9) ^ 0x486F4684) - 1215252100;
    __asm { rcr     esi, cl }
    JUMPOUT(0x40DCB4);
  }
  BYTE1(_EBX) = (_BYTE)_ECX;
  _EAX = 2895;
  BYTE1(v136) = __ROR1__(BYTE1(v136), (char)_ECX);
  LOBYTE(_EBX) = 44;
  v127 = v134 - v136;
  v128 = _EBX | v136;
  LOBYTE(_EBX) = 81;
  _EBX = _EBX << (char)_ECX;
  LOBYTE(_EBX) = (unsigned __int8)_EBX >> (char)_ECX;
  _EDX = v128 + 1;
  BYTE1(_EDX) -= BYTE1(_EBX);
  LOBYTE(_EDX) = 79;
  BYTE1(_EBX) >>= (char)_ECX;
  do
  {
    v148 = __ROL4__(_EDX, (char)_ECX);
    v116 = __CFADD__(__CFSHL__(_EDX, (_BYTE)_ECX), _EBX);
    v150 = __CFSHL__(_EDX, (_BYTE)_ECX) + _EBX;
    v149 = v116 | __CFADD__(v148, v150);
    _EBX = v148 + v150;
    if ( v149 | (_EBX == 0) || !(v149 | (_EBX == 0)) )
      JUMPOUT(0x40DD71);
    __outbyte(_EDX, 0x4Fu);
    *(_BYTE *)(v148 - 655720041) = 0;
    BYTE1(_EBX) = -45;
    --*(_DWORD *)(v148 - 45);
    __outdword(_EDX, 0xB4Fu);
    v127 = (v148 & v127) - 2895;
  }
  while ( _EDX != 1208429608 );
  __asm { rcl     dh, cl }
  BYTE1(_EAX) = -72;
  __asm { rcl     ebx, cl }
  v164 = v148 - (__CFSHR__(v127, (_BYTE)_ECX) + _EDX);
  LOBYTE(_EBX) = BYTE1(_ECX) ^ _EBX;
  _CX = __ROL4__(_ECX, (char)_ECX);
  BYTE1(_EBX) = __ROL1__(BYTE1(_EBX), _CX);
  __asm { rcr     al, cl }
  _DH = BYTE1(v164);
  __asm { rcl     ch, cl }
  result = v164 ^ _EAX;
  __asm
  {
    rcr     ebx, cl
    rcr     dh, cl
  }
  BYTE1(result) = BYTE1(result) - 10 - (__CFADD__(BYTE1(result), -10) + result);
  LOBYTE(result) = _EBX & result;
  return result;
}
// 40D928: positive sp value 4 has been found
// 40D895: control flows out of bounds to 40D897
// 40D955: inconsistent fpu stack
// 40DA60: control flows out of bounds to 40DA61
// 40DB36: control flows out of bounds to 40DB38
// 40DBF3: control flows out of bounds to 40DBF5
// 40DC87: control flows out of bounds to 40DC89
// 40D511: control flows out of bounds to 40D512
// 40D56D: control flows out of bounds to 40D56E
// 40D6BB: control flows out of bounds to 40D6BD
// 40D7BF: control flows out of bounds to 40D7C1
// 40DDDB: control flows out of bounds to 40DDDC
// 40DE7D: control flows out of bounds to 40DE83
// 40DF05: control flows out of bounds to 40DF0B
// 40D89F: control flows out of bounds to 80EB5DA8
// 40D932: control flows out of bounds to 40DAE4
// 40DBCE: control flows out of bounds to 40DB2B
// 40DD44: control flows out of bounds to 40D518
// 40D9CE: control flows out of bounds to 40DE08
// 40D9E3: control flows out of bounds to 40D978
// 40DA1E: control flows out of bounds to 40DA66
// 40DB18: control flows out of bounds to 40D6F4
// 40DBA9: control flows out of bounds to 40D67D
// 40DC6C: control flows out of bounds to 40DCB5
// 40DC81: control flows out of bounds to 40DCB4
// 40D581: control flows out of bounds to 40D763
// 40D645: control flows out of bounds to 40D594
// 40D655: control flows out of bounds to 40D5DF
// 40D6B5: control flows out of bounds to 40DD71
// 40D6E1: control flows out of bounds to 40DE5A
// 40D767: control flows out of bounds to 40D6F3
// 40D82A: control flows out of bounds to 40D8A0
// 40DE2C: control flows out of bounds to 40DEA0
// 40DE47: control flows out of bounds to 40D8A3
// 40DE59: control flows out of bounds to 40DE2D
// 40DE9F: control flows out of bounds to 40D743
// 40DAB3: conditional instruction was optimized away because esi.4!=0
// 40DB83: conditional instruction was optimized away because esi.4>=1
// 40D6EB: conditional instruction was optimized away because ah.1>=0
// 40DDD3: conditional instruction was optimized away because dh.1>=0
// 40DEFD: conditional instruction was optimized away because dl.1>=0
// 40D509: variable 'v68' is possibly undefined
// 40D82C: too many input arguments, some ignored

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
