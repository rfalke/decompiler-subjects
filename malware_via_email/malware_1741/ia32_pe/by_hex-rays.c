/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __userpurge sub_40D82C@<eax>(int _EAX@<eax>, unsigned int _EDX@<edx>, int _ECX@<ecx>, unsigned int _EBX@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);


//----- (0040D82C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge sub_40D82C@<eax>(int _EAX@<eax>, unsigned int _EDX@<edx>, int _ECX@<ecx>, unsigned int _EBX@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  char v64; // al
  int v65; // esi
  bool v66; // zf
  bool v67; // sf
  char v68; // of
  char v70; // al
  int v71; // esi
  int v75; // esi
  unsigned int v80; // edi
  bool v82; // tt
  unsigned int v87; // edi
  bool v88; // of
  unsigned int v89; // ebx
  int v91; // esi
  unsigned __int8 v95; // cl
  int v96; // ebx
  bool v98; // tt
  int v101; // ebx
  bool v103; // tt
  int v105; // eax
  unsigned int v107; // edx
  unsigned __int64 v108; // kr00_8
  int v109; // eax
  int v110; // edx
  int v111; // eax
  int v112; // edi
  int v115; // esi
  unsigned int v116; // edx
  bool v117; // cf
  int v118; // edi
  int result; // eax
  int v128; // edi
  int v129; // edx
  int v132; // esi
  int v134; // ebx
  int v136; // edi
  int v138; // edx
  int v140; // esi
  unsigned int v143; // edx
  unsigned int v144; // edx
  BOOL v145; // ett
  int v150; // esi
  char v151; // cf
  int v152; // ebx
  int v153; // edi
  char v154; // dh
  int v155; // ecx
  bool v156; // tt
  bool v157; // cf
  unsigned int v158; // edi
  _BYTE *v159; // ett
  char v160; // cc
  int v166; // esi
  int v171; // esi
  _BYTE *v172; // edi
  int v173; // edi
  int v177; // edx
  unsigned int v178; // [esp-Ch] [ebp-Ch]
  int v179; // [esp-8h] [ebp-8h] BYREF

  --BYTE1(_EBX);
  LOBYTE(_EAX) = _EAX - _EDX;
  __asm
  {
    rcr     eax, cl
    rcr     bl, cl
  }
  _ESI = a7 >> _ECX;
  v89 = _EBX >> _ECX;
  _ECX = __ROL4__(_ECX, _ECX);
  v179 = _ECX;
  __asm { rcl     dl, cl }
  _EDX = _EDX >> _ECX;
  v87 = a6 + 1;
  v88 = __OFSUB__((_BYTE)v89, -6);
  LOBYTE(v89) = v89 + 6;
  if ( !v88 && v88 )
    __asm { retf    242Ah }
  v154 = BYTE1(_EDX) + 48;
  v155 = _ECX << _ECX;
  v156 = __CFSHR__(v154, v155);
  BYTE1(_EDX) = __ROR1__(v154, v155);
  v159 = (_BYTE *)(v156 + _EDX);
  v157 = v87 < (unsigned int)v159;
  v158 = v87 - (_DWORD)v159;
  v160 = (v155 + 1 < 0) ^ __OFADD__(1, v155);
  _ECX = v155 + 1;
  if ( v160 || !v160 )
  {
    LOBYTE(v89) = v89 & 0x15;
    v95 = BYTE1(_ECX) & _ECX;
    LOBYTE(_EDX) = _EDX & 0xE6;
    v96 = __ROL4__(v89, v95);
    _CL = __CFSHR__(v158, BYTE1(v96) ^ (v95 >> v95)) + (BYTE1(v96) ^ (v95 >> v95)) - 117;
    BYTE1(_EDX) = BYTE1(_EAX) + (BYTE1(_EDX) | 0x18);
    __asm { rcl     edx, cl }
    JUMPOUT(0x40DE5A);
  }
  *(_BYTE *)(a5 - 756278440) += ((unsigned __int16)&v179 >> 8) + v157;
  *(_BYTE *)_EDX <<= _ECX;
  __asm { lock shl esi, cl }
  v178 = *(_DWORD *)_ECX;
  LOBYTE(_EDX) = _EDX + 1;
  _ESI = _ESI >> _ECX;
  __asm
  {
    rcl     edx, cl
    rcl     esi, cl
  }
  v80 = v158 >> _ECX;
  __asm { rcl     edx, cl }
  BYTE1(_EDX) &= 0xA1u;
  v82 = __CFSHR__(BYTE1(_EDX), _ECX);
  BYTE1(_EDX) = BYTE1(_ECX) ^ __ROR1__(BYTE1(_EDX), _ECX);
  __asm { rcl     dh, cl }
  v107 = (unsigned __int8)*(_DWORD *)_ECX;
  _BL = *(_DWORD *)_ECX ^ 0x37;
  __asm { rcr     bl, cl }
  _EBX = (unsigned __int8)BYTE1(*(_DWORD *)_ECX);
  _ESI = _ECX & ((_ESI - (v82 + v80)) << _ECX);
  __asm { rcr     esi, cl }
  v171 = (int)((_ECX ^ (_ESI - 1)) - 1) >> _ECX;
  v172 = (_BYTE *)((unsigned __int8)v178 | ((__ROR4__(v80 << _ECX, _ECX) - (unsigned __int8)v178 + 1) << _ECX));
  v105 = (unsigned __int8)v178 + HIWORD(v178);
  BYTE1(v107) = (-90 << _ECX) - (__CFSHL__(-90, _ECX) + v178);
  _ESI = v171 - 1;
  LOBYTE(v107) = (v178 + BYTE2(v178) + v178) ^ 0x42;
  if ( __SETP__(v107, 0) || !__SETP__(v107, 0) )
  {
    BYTE1(v107) += BYTE1(v178) + __CFADD__(BYTE1(v107), 28) + 28;
    v117 = __CFADD__(BYTE1(v178), v105);
    v64 = BYTE1(v178) + v178 + BYTE2(v178);
    v65 = _ESI << _ECX;
    LOBYTE(_EBX) = BYTE1(v178) - 1;
    LOBYTE(v107) = (v64 + v117 + v107) | 0x9A;
    v66 = (_BYTE)v107 == 0;
    v67 = (v107 & 0x80u) != 0;
    _EDX = __ROR4__(v107, _ECX);
    if ( !(v67 ^ v68 | v66) && v67 ^ v68 | v66 )
      JUMPOUT(0x40D512);
    BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ECX);
    BYTE1(_EDX) = __CFADD__(BYTE1(_EDX) << _ECX, -126) + (BYTE1(_EDX) << _ECX) - 126 + 29;
    v70 = v64 ^ 0xC8;
    v71 = v65 + 1;
    v117 = __CFADD__(BYTE1(_EBX), 125);
    BYTE1(_EBX) += 125;
    LOBYTE(_EDX) = (_EBX + v117 + _EDX) & 0x33;
    v132 = v71 - 1;
    LOBYTE(_EBX) = BYTE1(_EDX) + _EBX;
    BYTE1(_EDX) ^= 0xD1u;
    __asm { rcr     bh, cl }
    v134 = v132 ^ _EBX;
    __asm { rcl     edx, cl }
    LOBYTE(_EDX) = _EDX & 0xF;
    LOBYTE(v134) = v134 - 1;
    _ESI = v132 - 1;
    if ( !__SETP__(_ESI, 0) && __SETP__(_ESI, 0) )
    {
      *v172 = v70;
      JUMPOUT(0x40DBF5);
    }
    BYTE1(_EDX) <<= _ECX;
    __asm { rcr     esi, cl }
    _EDX = v134 + __ROL4__(_EDX, _ECX);
    __asm { rcr     dl, cl }
    JUMPOUT(0x40DB2B);
  }
  if ( (char)(v178 + BYTE2(v178) + v178) >= 0 )
    JUMPOUT(0x40DA66);
  *(int *)(_ESI - 28) >>= _ECX;
  __asm { outsd }
  v108 = __PAIR64__(_ECX, _ECX) + v107;
  v109 = __ROR4__(v105, _ECX);
  v110 = v109 | v108;
  v111 = (v109 | v108) + v109;
  v112 = v111 & (unsigned int)&v172[-HIDWORD(v108)];
  v117 = BYTE1(_EBX) < 0xA8u;
  BYTE1(_EBX) += 88;
  v101 = v110 + v117 + _EBX;
  v103 = __CFSHR__(v111, _ECX);
  _EAX = __ROR4__(v111, _ECX);
  LOBYTE(v110) = v110 - 1;
  BYTE1(_EAX) -= v103 + v110;
  BYTE1(v110) |= BYTE1(_EAX);
  BYTE1(_EAX) -= 71;
  __asm { rcl     eax, cl }
  _EDX = v110 >> _ECX;
  _EBX = v101 >> _ECX;
  __asm { rcl     ebx, cl }
  _ECX = (char *)(_ECX - 442);
  LOBYTE(_EDX) = __ROR1__(_EDX, (char)_ECX);
  LOBYTE(_EBX) = _EBX - 1;
  v75 = _ESI - 1;
  BYTE1(_EBX) |= (unsigned __int16)(_EAX + 1) >> 8;
  BYTE1(_EDX) |= 0x85u;
  LOBYTE(_EBX) = BYTE1(_ECX) | _EBX;
  v136 = (v112 ^ 0x486F4685) + 1;
  BYTE1(_EBX) = _EDX + (((SBYTE1(_EBX) >> (char)_ECX) - 1) ^ 0xE2);
  __asm { rcr     edx, cl }
  v117 = __CFSHL__(_EDX, (_BYTE)_ECX);
  v138 = _EDX << (char)_ECX;
  BYTE1(v138) += v117 + 30;
  LOBYTE(v138) = v138 - 1;
  if ( !__SETP__(v138, 0) && __SETP__(v138, 0) )
  {
    _CL = -88;
    __asm { fstp9   st }
    LOBYTE(v138) = v138 - 1;
    BYTE1(v138) = -123;
    v140 = __ROL4__(v75, 168);
    _EDX = (v138 - v140) << 8;
    LOBYTE(_EDX) = -33;
    __asm { rcl     edx, cl }
    BYTE1(_EDX) = 100;
    --BYTE1(_EBX);
    LOBYTE(_EDX) = __ROR1__(0, 168);
    v98 = __CFSHR__(v140, -88);
    _ESI = __ROR4__(v140, 168);
    _EDX = __ROL4__((_EBX + (unsigned int)v98 + (_EDX >> 8)) >> 8, 168);
    __asm { rcr     esi, cl }
    BYTE1(_EDX) = 47 - (((_BYTE)_EDX != 0) - 29) - 1 + 111;
    LOBYTE(_EDX) = 0;
    BYTE1(_EBX) = __ROR1__(__ROL1__(BYTE1(_EBX), 16), 14);
    __asm { rcr     edx, cl }
    _ESI = _EBX & (((unsigned int)(_ESI - 1044409944) >> 8) + 1) ^ 0x486F4685;
    __asm
    {
      rcr     dl, cl
      rcr     esi, cl
    }
    v91 = _EBX | _ESI;
    LOBYTE(_EDX) = _EDX - 70 - (((unsigned __int8)_EDX < 0x46u) + _EBX);
    BYTE1(_EDX) = __ROR1__(_EBX ^ BYTE1(_EDX), 168);
    v116 = ((v91 | _EDX) - 1) | 0x486F4685;
    LOBYTE(v116) = __ROL1__(v116 + 95, 168);
    BYTE1(v116) = (BYTE1(v116) - 1) & 0xD7;
    v153 = (v91 ^ v116) + 1;
    _ESI = v91 - 1044409944;
    MEMORY[0xC1BF91A8] = BYTE1(_EBX);
    __asm { rcl     esi, cl }
    v115 = _ESI - (__CFSHL__(BYTE1(v116), -88) + 1215252101);
    HIWORD(v116) = HIWORD(v153);
    BYTE1(v116) = BYTE1(v153) + 70;
    v117 = __CFADD__(v153, 1215252101);
    v118 = v153 + 1215252101;
    if ( !v117 && v117 )
      JUMPOUT(0x40DA61);
    v173 = v115 + __CFSHL__(v118 - 1, -88) + ((v118 - 1) << 8);
    _CL = -87;
    BYTE1(v116) = __ROR1__(BYTE1(v116), 169) - 1;
    LOBYTE(v116) = BYTE1(_EBX) ^ __ROR1__(0, 169);
    if ( !__SETP__(v116, 0) && __SETP__(v116, 0) )
    {
      _enable();
      __asm { rcr     byte ptr [ebx], 1 }
      LOBYTE(v116) = __ROL1__(v116, 169);
      _BX = _EBX - 1;
      LOBYTE(_BX) = BYTE1(v116);
      _CL = 127;
      ++BYTE1(v116);
      v117 = __CFADD__(__CFSHR__(-1044409943, 15), (_BYTE)v116);
      LOBYTE(v116) = __CFSHR__(-1044409943, 15) + v116;
      v117 |= __CFADD__(HIBYTE(_BX), (_BYTE)v116);
      LOBYTE(v116) = HIBYTE(_BX) + v116;
      v177 = v116 - 1;
      __asm { rcr     bh, cl }
      LOBYTE(v177) = _BX + v117 + v177;
      v177 >>= 31;
      _CL = 0;
      LOBYTE(v177) = v177 | 7;
      _EDI = v173 + 1 - v177;
      __asm { rcl     edi, cl }
      JUMPOUT(0x40D897);
    }
    SBYTE1(v116) >>= 7;
    v143 = v116 >> 9;
    BYTE1(v143) = __ROR1__(BYTE1(v143), 169);
    v117 = __CFSHL__(v143, -87);
    LOBYTE(v143) = 0;
    v145 = v117;
    v117 = __CFADD__(v117, v143);
    v144 = v145 + v143;
    v117 |= __CFADD__(_EBX, v144);
    v144 += _EBX;
    LOBYTE(v144) = v144 - (v117 - 111);
    BYTE1(v144) ^= 0xD0u;
    _ESI = (v144 & (v115 >> 9) ^ 0x486F4684) - 1215252100;
    __asm { rcr     esi, cl }
    JUMPOUT(0x40DCB4);
  }
  BYTE1(_EBX) = (_BYTE)_ECX;
  _EAX = 2895;
  BYTE1(v138) = __ROR1__(BYTE1(v138), (char)_ECX);
  LOBYTE(_EBX) = 44;
  v128 = v136 - v138;
  v129 = _EBX | v138;
  LOBYTE(_EBX) = 81;
  _EBX = _EBX << (char)_ECX;
  LOBYTE(_EBX) = (unsigned __int8)_EBX >> (char)_ECX;
  _EDX = v129 + 1;
  BYTE1(_EDX) -= BYTE1(_EBX);
  LOBYTE(_EDX) = 79;
  BYTE1(_EBX) >>= (char)_ECX;
  do
  {
    v150 = __ROL4__(_EDX, (char)_ECX);
    v117 = __CFADD__(__CFSHL__(_EDX, (_BYTE)_ECX), _EBX);
    v152 = __CFSHL__(_EDX, (_BYTE)_ECX) + _EBX;
    v151 = v117 | __CFADD__(v150, v152);
    _EBX = v150 + v152;
    if ( v151 | (_EBX == 0) || !(v151 | (_EBX == 0)) )
      JUMPOUT(0x40DD71);
    __outbyte(_EDX, 0x4Fu);
    *(_BYTE *)(v150 - 655720041) = 0;
    BYTE1(_EBX) = -45;
    --*(_DWORD *)(v150 - 45);
    __outdword(_EDX, 0xB4Fu);
    v128 = (v150 & v128) - 2895;
  }
  while ( _EDX != 1208429608 );
  __asm { rcl     dh, cl }
  BYTE1(_EAX) = -72;
  __asm { rcl     ebx, cl }
  v166 = v150 - (__CFSHR__(v128, (_BYTE)_ECX) + _EDX);
  LOBYTE(_EBX) = BYTE1(_ECX) ^ _EBX;
  _CX = __ROL4__(_ECX, (char)_ECX);
  BYTE1(_EBX) = __ROL1__(BYTE1(_EBX), _CX);
  __asm { rcr     al, cl }
  _DH = BYTE1(v166);
  __asm { rcl     ch, cl }
  result = v166 ^ _EAX;
  __asm
  {
    rcr     ebx, cl
    rcr     dh, cl
  }
  BYTE1(result) = BYTE1(result) - 10 - (__CFADD__(BYTE1(result), -10) + result);
  LOBYTE(result) = _EBX & result;
  return result;
}
// 40D928: positive sp value 4 has been found
// 40D895: control flows out of bounds to 40D897
// 40D955: inconsistent fpu stack
// 40DA60: control flows out of bounds to 40DA61
// 40DB36: control flows out of bounds to 40DB38
// 40DBF3: control flows out of bounds to 40DBF5
// 40DC87: control flows out of bounds to 40DC89
// 40D511: control flows out of bounds to 40D512
// 40D56D: control flows out of bounds to 40D56E
// 40D6BB: control flows out of bounds to 40D6BD
// 40D7BF: control flows out of bounds to 40D7C1
// 40DDDB: control flows out of bounds to 40DDDC
// 40DE7D: control flows out of bounds to 40DE83
// 40DF05: control flows out of bounds to 40DF0B
// 40D89F: control flows out of bounds to 80EB5DA8
// 40D932: control flows out of bounds to 40DAE4
// 40DBCE: control flows out of bounds to 40DB2B
// 40DD44: control flows out of bounds to 40D518
// 40D9CE: control flows out of bounds to 40DE08
// 40D9E3: control flows out of bounds to 40D978
// 40DA1E: control flows out of bounds to 40DA66
// 40DB18: control flows out of bounds to 40D6F4
// 40DBA9: control flows out of bounds to 40D67D
// 40DC6C: control flows out of bounds to 40DCB5
// 40DC81: control flows out of bounds to 40DCB4
// 40D581: control flows out of bounds to 40D763
// 40D645: control flows out of bounds to 40D594
// 40D655: control flows out of bounds to 40D5DF
// 40D6B5: control flows out of bounds to 40DD71
// 40D6E1: control flows out of bounds to 40DE5A
// 40D767: control flows out of bounds to 40D6F3
// 40D82A: control flows out of bounds to 40D8A0
// 40DE2C: control flows out of bounds to 40DEA0
// 40DE47: control flows out of bounds to 40D8A3
// 40DE59: control flows out of bounds to 40DE2D
// 40DE9F: control flows out of bounds to 40D743
// 40DAB3: conditional instruction was optimized away because of 'esi.4!=0'
// 40DB83: conditional instruction was optimized away because of 'esi.4>=1'
// 40D55D: conditional instruction was optimized away because of 'dl.1<34u'
// 40D567: conditional instruction was optimized away because of 'dl.1<34u'
// 40D6EB: conditional instruction was optimized away because of 'ah.1>=0'
// 40DDD3: conditional instruction was optimized away because of 'dh.1>=0'
// 40DEFD: conditional instruction was optimized away because of 'dl.1>=0'
// 40D509: variable 'v68' is possibly undefined
// 40D82C: too many input arguments, some ignored

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
