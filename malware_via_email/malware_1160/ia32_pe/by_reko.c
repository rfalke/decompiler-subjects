// subject_rsrc.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw4104B0 = 66812; // 004104B0
word32 g_dw4104B4 = 66828; // 004104B4
word32 g_dw4104B8 = 66848; // 004104B8
word32 g_dw4104BC = 66864; // 004104BC
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040116C: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	struct Eq_3 * fp;
	struct Eq_4 * fs;
	struct Eq_5 * edx;
	struct Eq_6 * esi;
	Eq_7 ecx;
	word32 ebp;
	word32 ebx;
	struct Eq_10 * cs;
	struct Eq_11 * ss;
	struct Eq_12 * ds;
	byte * edi;
	byte dl_325 = (byte) edx;
	word16 edx_16_16_326 = SLICE(edx, word16, 16);
	do
	{
		fs->ptr0000 = fp;
		null = (union Eq_7 *) ecx;
		++ebx;
		++ebp;
		byte bh_30 = SLICE(ebx, byte, 8);
		byte bl_39 = (byte) ebx;
		word16 ebx_16_16_327 = SLICE(ebx, word16, 16);
		Eq_7 al_24 = null;
		if (Test(OV,false))
			;
		--ecx;
	} while (al_24 != 0x00 && ecx != 0x00);
	byte bh_31 = bh_30 - al_24;
	Eq_47 ebp_34 = ebp + (fp->a463F001D)[(uint32) al_24 / 4];
	ui32 ebx_328 = SEQ(ebx_16_16_327, bh_31, bl_39);
	if (ebp_34 < 0x00)
	{
		Eq_2 eax_38 = (uint32) __in<byte>(0xB8);
		eax_38->a333D6692[eax_38].b0000 -= bl_39;
		edx->b53678868 >>= 0x5B;
		return eax_38;
	}
	else
	{
		byte al_53 = (byte) al_24.u0 + 64 + (byte) (ebp_34 < 0x00);
		struct Eq_91 * esp_304 = (struct Eq_91 *) 4;
		cu8 al_57 = al_53 + 116 + (byte) ((uint32) al_53 < 0x6C1F0F8B);
		al_292 = al_57;
		do
		{
			cu8 al_292;
			cu8 al_61 = al_292 + 0x70 + (byte) (al_57 < 0x00);
			int32 edx_69 = SEQ(edx_16_16_326, ~0x18, dl_325);
			word32 v23_72 = (esp_304 + 1002905176)[edx_69 / 2].ptr0000 + ebx_328;
			(esp_304 + 1002905176)[edx_69 / 2] = (struct Eq_91) v23_72;
			byte al_64 = al_61 - 0x3A - (byte) (al_61 < 0x00);
			word16 dx_331 = SEQ(~0x18, dl_325);
			if (v23_72 == 0x00)
			{
				byte v31_80 = esi->bE3ACC410 + bh_31;
				esi->bE3ACC410 = v31_80;
				Eq_2 esp_100 = esp_304 & ebx_328;
				if (!OVERFLOW<byte>(v31_80))
					;
				Eq_2 eax_397 = (uint32) al_64;
				if (v31_80 == 0x00 && ecx != 0x01)
					return eax_397;
				else
				{
					Eq_2 eax_452 = SEQ(edx_16_16_326, dx_331);
					do
					{
						eax_452 = __in<word32>(0x60);
						__out<word32>(~0x09, eax_452);
						do
						{
							Eq_61 dx_94 = (word16) eax_452;
							__out<byte>(dx_94, (byte) eax_452);
							ci8 dl_111 = (byte) dx_94;
							++esi;
							Eq_2 eax_135 = eax_452;
							if (eax_452 >= esp_100)
								esp_100->ptrFFFFFFFE = (struct Eq_10 ****) cs;
							*(struct Eq_11 **) 0x9C053CDE = ss;
							esp_100 = (struct <anonymous> *) 0x9C053CDE;
							if (dl_111 < esi->bCF1C1006)
								return eax_135;
							if (dl_111 > esi->bCF1C1006)
							{
								__in<word32>(dx_94);
								eax_452->ptr0002 = (struct Eq_282 *) ss;
								ds = (struct Eq_12 *) eax_452->ptr0002;
								esp_100 = eax_452 + 4;
								eax_135 = (struct <anonymous> *) 3353287860;
							}
							up32 eax_137 = (char *) eax_135 - 1480255772;
							eax_452 = (Eq_2) (int64) eax_137;
							ui8 * eax_147 = (word32) eax_452;
							byte al_233 = (byte) eax_452;
							word24 eax_24_8_285 = SLICE(eax_452, word24, 8);
						} while (eax_137 > 0x00);
						*eax_147 <<= ~0x04;
						esi = (struct Eq_6 *) 0x7BA3CADB;
						eax_135 = SEQ(eax_24_8_285, 0x15);
						if ((al_233 | 0x11) <= 0x11)
							fn6EA78D63(ds);
					} while ((al_233 | 0x11) < 0x11);
					return eax_135;
				}
			}
			*edi = esi->b0000;
			ds = (struct Eq_12 *) esp_304->ptr0000;
			__wait();
			uint32 * esp_302 = esp_304 + 1;
			al_292 = al_64 & 0x84;
			++esi;
			++edi;
			esp_304 = (struct Eq_91 *) (esp_302 + 1);
			uint32 eax_309 = (uint32) (al_64 & 0x84);
		} while (ecx == 0x00);
		*esp_302 = eax_309;
	}
}

