// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct HINSTANCE__ g_t400000 = // 00400000
	{
		9460301,
	};
// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__DestroyPropertySheetPage = &g_tE134; // 00401000
<anonymous> * __imp__ImageList_AddMasked = &g_tE150; // 00401004
<anonymous> * __imp__ImageList_GetImageCount = &g_tE166; // 00401008
<anonymous> * __imp__PathMakePrettyW = &g_tE18E; // 00401010
<anonymous> * __imp__StrSpnA = &g_tE1A0; // 00401014
<anonymous> * __imp__CreateDIBitmap = &g_tE1B6; // 0040101C
<anonymous> * __imp__CreateHalftonePalette = &g_tE1C8; // 00401020
<anonymous> * __imp__CreateCompatibleDC = &g_tE1E0; // 00401024
<anonymous> * __imp__SetBitmapDimensionEx = &g_tE1F6; // 00401028
<anonymous> * __imp__StretchBlt = &g_tE20E; // 0040102C
<anonymous> * __imp__GetCurrentProcessId = &g_tE226; // 00401034
<anonymous> * __imp__InterlockedExchangeAdd = &g_tE23C; // 00401038
<anonymous> * __imp__SetCommMask = &g_tE256; // 0040103C
<anonymous> * __imp__TransactNamedPipe = &g_tE264; // 00401040
<anonymous> * __imp__AreFileApisANSI = &g_tE278; // 00401044
<anonymous> * __imp__InterlockedExchange = &g_tE28A; // 00401048
<anonymous> * __imp__CreateFileW = &g_tE2A0; // 0040104C
<anonymous> * __imp__Sleep = &g_tE2AE; // 00401050
<anonymous> * __imp__ExitProcess = &g_tE2B6; // 00401054
<anonymous> * __imp__GetCurrentThreadId = &g_tE2C4; // 00401058
<anonymous> * __imp__GetDateFormatW = &g_tE2DA; // 0040105C
<anonymous> * __imp__IntersectRect = &g_tE2FA; // 00401064
<anonymous> * __imp__SetDlgItemInt = &g_tE30A; // 00401068
<anonymous> * __imp__MoveWindow = &g_tE31A; // 0040106C
<anonymous> * __imp__GetClipCursor = &g_tE328; // 00401070
<anonymous> * __imp__RedrawWindow = &g_tE338; // 00401074
<anonymous> * __imp__ChangeMenuW = &g_tE348; // 00401078
<anonymous> * __imp__LoadIconW = &g_tE356; // 0040107C
<anonymous> * __imp__CharLowerW = &g_tE362; // 00401080
<anonymous> * __imp__PostMessageA = &g_tE370; // 00401084
<anonymous> * __imp__GetNextDlgGroupItem = &g_tE380; // 00401088
<anonymous> * __imp__CreateDialogParamA = &g_tE396; // 0040108C
<anonymous> * __imp__DefWindowProcA = &g_tE3AC; // 00401090
<anonymous> * __imp__ClientToScreen = &g_tE3BE; // 00401094
<anonymous> * __imp__memset = &g_tE3DC; // 0040109C
<anonymous> * __imp___stricmp = &g_tE3E6; // 004010A0
// 004038A8: Register (ptr32 int16) au_jPZL_V_D__d(Stack uint32 dwArg04, Stack int16 wArg08)
int16 * au_jPZL_V_D__d(uint32 dwArg04, int16 wArg08)
{
	g_t4079F1.u0 = (uint32) ((word32) g_t4079F1.u1 | g_dw407945);
	g_dw407981 += g_t4079D9.u0;
	g_t4079B1.u1 = (word32) ((word32) g_t4079B1.u0 - g_ptr407BC7->u1);
	return (int16 *) <invalid>;
}

// 004038F0: Register (ptr32 void) YIFUJLj_r_n_IJ(Stack (ptr32 uint32) ptrArg04)
void * YIFUJLj_r_n_IJ(uint32 * ptrArg04)
{
	up32 esi;
	up32 dwLoc24;
	ui32 * edi_9 = g_ptr407BEF;
	*edi_9 |= (word32) g_b407985;
	union Eq_51 * ebx_15 = g_ptr407BEB;
	ebx_15->u1 = (word32) (ebx_15->u1 + g_dw4079F9);
	g_t40798D.u0 = (uint32) (g_t40798D.u0 - g_ptr407C33->u1 - (word32) (esi < dwLoc24));
	return (void *) <invalid>;
}

// 0040392E: Register uint16 SS_UAXmq_a_bvx(Stack int32 dwArg04, Stack uint16 wArg08)
uint16 SS_UAXmq_a_bvx(int32 dwArg04, uint16 wArg08)
{
	union Eq_79 * ecx_10 = g_ptr407C13;
	ecx_10->u0 = (ui32) (ecx_10->u0 + (word32) g_t4079D1.u1);
	g_t40794D.u0 = (ui32) ((word32) g_t40794D.u1 & *g_ptr407C1F);
	word32 * esi_17 = g_ptr407BB3;
	*esi_17 -= g_dw407979;
	return <invalid>;
}

// 0040396A: Register cu8 TA_gsidq_WP_FKJsfvp(Stack bool fArg04, Stack (ptr32 uint32) ptrArg08)
cu8 TA_gsidq_WP_FKJsfvp(bool fArg04, uint32 * ptrArg08)
{
	up32 ecx;
	up32 dwLoc28;
	word32 * ebx_11 = g_ptr407B5B;
	*ebx_11 = *ebx_11 + g_dw407981 + (word32) (ecx < dwLoc28);
	up32 * esi_19 = g_ptr407BB7;
	*esi_19 -= g_dw407975;
	g_t407991.u1 = (ui32) ((word32) g_t407991.u0 & *g_ptr407B6B);
	return <invalid>;
}

// 004039AA: Register (ptr32 real64) bsh_hhuc_w(Stack int32 dwArg04)
real64 * bsh_hhuc_w(int32 dwArg04)
{
	g_t407A29.u0 = (uint32) ((word32) g_t407A29.u1 & (word32) g_t4079C1.u1);
	up32 * ebx_14 = g_ptr407BB7;
	*ebx_14 -= g_dw407A0D;
	g_dw407A11 |= (word32) g_t4079D1.u0;
	return (real64 *) <invalid>;
}

// 004039ED: Register int16 QYRS_EIPYDNmsndYSD_A(Stack bool fArg04)
int16 QYRS_EIPYDNmsndYSD_A(bool fArg04)
{
	g_t407A01.u0 = (ui32) (g_t407A01.u0 - *g_ptr407BB7);
	g_t4079AD.u0 = (uint32) ((word32) g_t4079AD.u1 & *g_ptr407C3B);
	word32 * ecx_20 = g_ptr407BE7;
	*ecx_20 -= g_dw4079DD;
	return <invalid>;
}

// 00403A30: Register char ueDH_KBY_WG(Stack int16 wArg04)
char ueDH_KBY_WG(int16 wArg04)
{
	g_t4079F1.u0 = (uint32) (g_t4079F1.u0 | g_ptr407BD3->u1);
	g_dw4079B5 -= *g_ptr407B7B;
	g_t4079A1.u0 = (uint32) (g_t4079A1.u0 + *g_ptr407BC3);
	return <invalid>;
}

// 00403A76: Register uint32 jAK_D_NP_gqny__l__xtht(Stack uint32 dwArg04, Stack uint32 dwArg08)
uint32 jAK_D_NP_gqny__l__xtht(uint32 dwArg04, uint32 dwArg08)
{
	Eq_245 ebx;
	uint32 eax;
	g_t4079A1.u0 = (uint32) (g_t4079A1.u0 | g_t4079D9.u0);
	g_t4079A9.u1 = (word32) ((word32) g_t4079A9.u0 - g_dw4079F9 - (word32) (ebx < g_t407995.u0));
	g_t407A1D.u1 = (up32) ((word32) g_t407A1D.u0 - *g_ptr407B5F - (word32) (g_dw40799D < eax));
	return <invalid>;
}

// 00403ACA: void fn00403ACA(Register (ptr32 Eq_278) eax)
// Called from:
//      Win32CrtStartup
void fn00403ACA(struct Eq_278 * eax)
{
	g_dw407554 = (char *) eax + 4;
	g_dw407548 = eax->dw0008;
	g_dw40754C = eax->dw000C;
	g_dw407550 = eax->dw0010;
}

// 00403AEE: FpuStack real32 tzyUQPRv(Stack int32 dwArg04, Stack int32 dwArg08)
real32 tzyUQPRv(int32 dwArg04, int32 dwArg08)
{
	up32 edx;
	up32 dwLoc24;
	g_dw407A09 += g_dw407999;
	union Eq_314 * ecx_19 = g_ptr407C1B;
	ecx_19->u1 = (word32) (ecx_19->u1 + (word32) g_t407989.u1 + (word32) (dwLoc24 < edx));
	g_dw407961 |= (word32) g_b4079E5;
	return <invalid>;
}

// 00403B39: Register (ptr32 char) BBHCLQZ__TGH(Stack char bArg04)
char * BBHCLQZ__TGH(char bArg04)
{
	union Eq_25 * dwLoc28;
	union Eq_25 * ebx_10 = g_ptr407BC7;
	Eq_142 edi_11 = g_t407949.u1 ^ ebx_10->u1;
	g_t407949.u1 = (ui32) edi_11;
	g_t407965.u1 = (word32) ((word32) g_t407965.u0 - *g_ptr407B73 - (word32) (ebx_10 < dwLoc28));
	ui32 * edi_20 = g_ptr407C1F;
	*edi_20 = *edi_20 + g_t4079B1.u1 + (word32) (edi_11 < g_t407991.u1);
	return (char *) <invalid>;
}

// 00403B83: Register int32 cbcs___yPDS_EDB_XB(Stack int32 dwArg04)
int32 cbcs___yPDS_EDB_XB(int32 dwArg04)
{
	g_t407949.u1 = (ui32) (g_t407949.u1 + g_ptr407B4F->u0);
	g_t4079C1.u0 = (ui32) ((word32) g_t4079C1.u1 & *g_ptr407BDF);
	g_t40797D.u0 = (ui32) ((word32) g_t40797D.u1 ^ (word32) g_t407A1D.u0);
	return <invalid>;
}

// 00403BCC: Register (ptr32 word16) fn00403BCC(Register up32 ebx)
// Called from:
//      fn00404FE4
word16 * fn00403BCC(up32 ebx)
{
	word32 dwLoc48;
	ptr32 fp;
	Eq_405 dwLoc08;
	ui32 dwLoc38;
	Eq_407 dwLoc30;
	RECT * dwLoc1C;
	RECT * dwLoc2C;
	g_dw407A19 = 0x00;
	Eq_405 eax_10 = dwLoc08;
	do
	{
		++g_dw407A19;
		if (g_dw407A19 == 0x1D)
			eax_10 = IntersectRect(&g_dw407981, dwLoc2C, dwLoc1C);
	} while (g_dw407A19 < 0x19);
	ui32 eax_59 = eax_10 ^ dwLoc08;
	if (dwLoc30 > 0x3660)
		dwLoc30 = fp - 40;
	g_t4079C5.u1 = (word32) ((word32) g_t4079C5.u0 + *g_ptr407BE3);
	g_t407955.u0 = (int32) (g_t407955.u0 >> 0x01);
	g_dw407A21 = g_dw407A21 ^ dwLoc48;
	ui32 eax_95 = eax_59 + 0x01 << 0x04;
	word16 * eax_148 = 0x01 - (eax_95 << 0x0C) - 1 & *(*(*g_ptr407040));
	g_t40798D.u0 = (uint32) (g_t40798D.u0 - dwLoc48 - (word32) (ebx > 0x032F));
	int32 ecx_134 = dwLoc30 & dwLoc38;
	word16 * dwLoc10_289 = eax_148;
	word16 ax_167 = *eax_148 - 0x022E;
	while ((ax_167 ^ 0x032F) != 23344)
	{
		word16 * v33_183 = dwLoc10_289 - (eax_95 << 0x0C);
		dwLoc10_289 = v33_183;
		word16 ax_187 = *v33_183;
		ax_167 = ax_187 - 0x022E;
	}
	return dwLoc10_289;
}

Eq_666 g_t403DE4 = // 00403DE4
	{
		<code>,
		0x40709405,
	};
// 00403E14: Register ui32 fn00403E14(Register (ptr32 Eq_512) ebx, Register word32 esi, Register word32 edi, Stack (ptr32 Eq_515) dwArg04, Stack (ptr32 word32) dwArg08, Register out (ptr32 Eq_517) edxOut)
// Called from:
//      fn00405439
ui32 fn00403E14(struct Eq_512 * ebx, word32 esi, word32 edi, struct Eq_515 * dwArg04, word32 * dwArg08, struct Eq_517 & edxOut)
{
	struct Eq_518 * fp;
	Eq_519 dwLoc1C;
	int32 dwLoc2C;
	struct Eq_517 * edx;
	Eq_519 dwLoc14_234 = 0x00;
	while (dwLoc14_234 < 0x1D)
	{
		if (dwLoc14_234 == 0x2B)
			SetDlgItemInt(~0x1003, dwLoc2C, dwLoc14_234, ~0x1003);
		&dwLoc14_234.u0->unused = (word32) dwLoc14_234 + 1;
	}
	word32 eax_143;
	BITMAPINFO * ecx_26 = g_ptr4070F0;
	g_dw407951 -= *g_ptr407B77;
	if (ecx_26 != (BITMAPINFO *) 0x01 && *dwArg04->ptr0038 != 0x00)
	{
		struct Eq_515 * ecx_54 = g_ptr4072D8;
		edx = (struct Eq_517 *) *ecx_54->ptr0008;
		word32 eax_59 = Mem37[Mem37[edx + 60:word32] + 40 + edx:word32] + edx;
		if (ecx_54->dw0040 != 0x00)
		{
			word32 * ecx_67 = g_ptr407B43;
			*ecx_67 = *ecx_67 - 0x2A65 - (word32) (ebx > (struct Eq_512 *) 0x1540D070);
			g_ptr407310->t0000 = (<anonymous>) 233;
			struct Eq_666 * ecx_79 = g_ptr407310;
			ecx_79->dw0001 = eax_59 - ~0x2528 - ecx_79 - 0x252E;
			Mem86 = Mem84;
			if (true)
			{
				if (false)
				{
					fp->tFFFFFFB4.u0 = (HDC) dwLoc1C;
					fp->ptrFFFFFFB0 = (BITMAPINFO *) 0x1540D070;
					fp->ptrFFFFFFAC = (struct Eq_517 *) 14934;
					fp->tFFFFFFA8 = (char *) 0x28B8;
					fp->ptrFFFFFFA4 = (BITMAPINFOHEADER *) 7616;
					fp->tFFFFFFA0.u0 = (HDC) dwLoc1C;
					CreateDIBitmap(fp->tFFFFFFA0.u0, fp->ptrFFFFFFA4, fp->tFFFFFFA8, fp->ptrFFFFFFAC, fp->ptrFFFFFFB0, fp->tFFFFFFB4.u0);
				}
			}
			fp->tFFFFFFB4.u0 = g_t4070F4.u0;
			fp->ptrFFFFFFB0 = g_ptr4070F0;
			struct Eq_517 ** eax_108 = g_ptr4072D8->ptr0008;
			fp->ptrFFFFFFAC = (struct Eq_517 *) *eax_108;
			word32 eax_116;
			g_ptr407310();
			*dwArg08 = eax_116;
		}
		g_ptr407100 = null;
		g_dw407104 = 0x00;
		eax_143 = ~0x1003;
	}
	else
		eax_143 = ~0x1002;
	edxOut = edx;
	return (eax_143 ^ 13615) + 0x252E;
}

// 00403FFD: Register word32 fn00403FFD(Register word32 eax, Register word32 edx, Register word32 esi, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      fn004052FB
word32 fn00403FFD(word32 eax, word32 edx, word32 esi, word32 dwArg04, word32 dwArg08, <anonymous> * dwArg0C)
{
	ptr32 fp;
	word32 esi;
	word32 eax;
	word32 edx;
	word32 dwArg04;
	<anonymous> * dwArg0C;
	word32 dwArg08;
	word32 dwLoc14;
	word32 dwLoc28;
	ecx_11 = ~0x1002;
	esp_12 = fp - 0x0C;
	dwLoc08_178 = ~0x1002;
	dwLoc08_180 = ~0x1003;
	eax_20 = (struct HPALETTE__ *) 0x0200B00F;
	g_t407A1D.u1 = (up32) 0x00;
	do
	{
		eax_174 = ϕ(eax_20, eax_173);
		Mem26 = ϕ(Mem22, Mem39);
		edx_27.u1 = g_t407A1D.u1;
		g_t407A1D.u1 = (word32) edx_27.u1 + 1;
		if (g_t407A1D.u1 == 0x14)
			eax_37 = CreateHalftonePalette(dwLoc14);
		eax_173 = ϕ(eax_37, eax_174);
		Mem39 = ϕ(Mem36, Mem29);
	} while (g_t407A1D.u1 < 0x13);
	edx_42 = (word32) g_t407A01.u1;
	g_t407A01.u0 = (ui32) (edx_42 ^ 1651);
	edx_49.u0 = 13615;
	esp_51 = fp - 16;
	dwLoc08_204 = ϕ(dwLoc08_202, dwLoc08_180);
	dwLoc28_184 = ϕ(dwLoc28_214, dwLoc28);
	esp_163 = ϕ(esp_161, esp_51);
	eax_102 = ϕ(eax_151, eax_173);
	edx_86 = ϕ(edx_132, edx_49);
	Mem59 = ϕ(Mem156, Mem55);
	ecx_56 = ϕ(ecx_138, ecx_11);
	esi_57 = ecx_56 + 1;
	if (dwLoc28_184 <= 0x2296)
	{
		ebx_62 = g_ptr407B67;
		ebx_63 = *ebx_62;
		v24_64 = dwLoc28_184 | ebx_63;
		dwLoc28_185 = v24_64;
	}
	dwLoc28_216 = ϕ(dwLoc28_184, dwLoc28_185);
	Mem75 = ϕ(Mem72, Mem65);
	esi_80 = *((char *) g_a4070D4 + (esi_57 & 0x03) * 0x04);
	ebx_81 = *esi_80;
	ebx_83 = ebx_81 *s ecx_56;
	g_t4079D9.u0 = (ui32) 0x00407979;
	v23_90 = g_t4079D9.u0 - 0x004079C9 - (word32) (edx_86 < ebx_83 *s ~0x2007);
	g_t4079D9.u0 = (ui32) v23_90;
	*esi_80 = ebx_83 *s ~0x2007;
	esi_93 = ecx_56 - 1;
	esi_98 = *((char *) g_a4070D4 + (esi_93 & 0x03) * 0x04);
}

// 004041AB: void fn004041AB(Register (ptr32 Eq_927) ebp, Register (ptr32 uint32) esi, Register uint32 edi)
// Called from:
//      Win32CrtStartup
void fn004041AB(struct Eq_927 * ebp, uint32 * esi, uint32 edi)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				uint32 ecx_16 = *esi;
				if (ecx_16 > edi)
					*esi = ecx_16 - 0x01;
				else if (ecx_16 == 0x00)
					*esi = edi;
				else
				{
					g_t4079AD.u0 = 0x00;
					do
					{
						g_t4079AD.u0 = (uint32) (g_t4079AD.u0 + 0x01);
						if (g_t4079AD.u0 == 0x1F)
							MoveWindow(0x1A5F, ebp->dwFFFFFFEC, ebp->dwFFFFFFE4, ebp->dwFFFFFFF4, 0x112B, 0x00);
					} while (g_t4079AD.u0 < 0x1E);
					*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_16;
				}
			} while (*esi != edi);
		}
	} while ((word32) InterlockedExchangeAdd(&g_t4072EC, 0x00760667) + 0x00760667 != g_t4072EC);
}

// 00404262: void fn00404262(Register (ptr32 Eq_1010) ebp, Register (ptr32 uint32) esi, Register uint32 edi)
// Called from:
//      Win32CrtStartup
void fn00404262(struct Eq_1010 * ebp, uint32 * esi, uint32 edi)
{
	*esi = 0x01;
	InterlockedExchange(&g_t4072EC, 0x00760667);
	while (*esi != edi)
	{
		uint32 ecx_22 = *esi;
		if (ecx_22 < edi)
		{
			if (ecx_22 == 0x00)
				goto l004042FF;
			g_dw407961 = 0x00;
			while (g_dw407961 < 0x15)
			{
				if (g_dw407961 == 0x17)
					DestroyPropertySheetPage(ebp->tFFFFFFE8);
				++g_dw407961;
			}
			*esi = (uint32) ((uint64) edi /u 0x0101) + 1 + ecx_22;
		}
		else if (ecx_22 == 0x00)
		{
l004042FF:
			*esi = edi;
		}
		else
			*esi = ecx_22 - 0x01;
	}
}

// 00404313: Register ui32 fn00404313(Register uint32 edx, Register Eq_155 edi, Register out ptr32 ecxOut)
// Called from:
//      fn00404C15
ui32 fn00404313(uint32 edx, Eq_155 edi, ptr32 & ecxOut)
{
	word16 wLoc20;
	Eq_572 dwLoc28;
	g_t40797D.u0 = (ui32) (g_t40797D.u1 - wLoc20 - (word32) (g_dw407A11 < edx));
	BOOL eax_36 = g_t407080;
	g_t4079F1.u0 = 0x00;
	do
	{
		g_t4079F1.u0 = (uint32) (g_t4079F1.u0 + 0x01);
		if (g_t4079F1.u0 == 0x2A)
			eax_36 = SetCommMask((void *) 0x3668, dwLoc28);
	} while (g_t4079F1.u0 < 0x1F);
	union Eq_314 * esi_93 = g_ptr407C1B;
	int32 eax_62 = *eax_36;
	word32 eax_66 = *g_ptr407084;
	esi_93->u0 = (byte) (esi_93->u0 - 114 - (byte) (g_t407A29.u0 < edi));
	g_dw4072F0 = eax_62;
	g_dw4072F4 = eax_66 + (0x04 - g_dw4072F0);
	word32 eax_111 = ~0x1003;
	if (g_dw4072F0 == 0x00)
	{
		union Eq_314 * eax_117 = g_ptr407C1B;
		eax_117->u0 = (byte) (eax_117->u0 + 0x82);
		eax_111 = ~0x1002;
	}
	ecxOut = 0x252E;
	return (eax_111 ^ 13615) + 0x252E;
}

// 0040445A: void fn0040445A()
// Called from:
//      fn00404C15
void fn0040445A()
{
	ptr32 fp;
	word32 dwLoc1C;
	word32 dwLoc18;
	word32 dwLoc24;
	word32 dwLoc14_128;
	for (dwLoc14_128 = 0x18; dwLoc14_128 != 0x00; --dwLoc14_128)
	{
		if (dwLoc14_128 == 0x27)
			GetClipCursor(&g_t407949);
	}
	word32 v17_47 = dwLoc24 + (word32) g_b4079ED;
	g_dw40799D = g_dw40799D ^ 4225573;
	g_dw40799D += 4225585;
	byte * eax_71 = g_ptr407BDB;
	struct Eq_515 * edx_60 = g_ptr4072D8;
	*eax_71 -= 0x3D;
	word32 * eax_90 = edx_60->ptr000C;
	g_ptr407580();
}

// 00404585: Register ptr32 fn00404585(Register word32 ecx, Register ptr32 edx, Register ptr32 edi, Stack (ptr32 Eq_512) dwArg08, Stack (ptr32 code) dwArg0C, Stack (ptr32 Eq_1221) dwArg10, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00404585
//      fn00405439
ptr32 fn00404585(word32 ecx, ptr32 edx, ptr32 edi, struct Eq_512 * dwArg08, <anonymous> * dwArg0C, struct Eq_1221 * dwArg10, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	struct Eq_512 * fp;
	Eq_519 dwLoc28;
	ptr32 edx_150;
	ptr32 * esp_152;
	if (dwArg10 != (struct Eq_1221 *) 550007)
	{
		if (dwArg10 != (struct Eq_1221 *) 203272)
		{
			up32 dwLoc40_216;
			for (dwLoc40_216 = 0x00; dwLoc40_216 < 0x10; ++dwLoc40_216)
			{
				if (dwLoc40_216 == 0x1F)
					CreateCompatibleDC(dwLoc28);
			}
			g_dw4079D5 += 0x0880;
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_1221 * stackArg16 = (struct Eq_1221 *) <invalid>;
		word32 ebp_274;
		word32 esi_275;
		word32 edi_276;
		edx_150 = fn00404585(ecx, edx_150, edi, fp->ptr0008, fp->ptr000C, stackArg16, out ebp_274, out esi_275, out edi_276);
		esp_152 = fp - 0x0C;
	}
	else
		dwArg0C();
	fp->ptr0008 = fp;
	ui32 * ecx_157 = g_ptr407C07;
	<anonymous> * eax_156 = g_ptr407100;
	*ecx_157 |= 22423;
	fp->ptr000C = eax_156;
	<anonymous> * ecx_165 = (char *) fp->ptr000C + (fp->ptr0008)->dw0000;
	fp->tFFFFFF70.u0 = (ui32) ((word32) fp->tFFFFFF70.u1 & 24246);
	ptr32 esi_171 = *esp_152;
	fp->ptr000C = ecx_165;
	struct Eq_512 * eax_173 = fp->ptr0008;
	eax_173->dw0000 = eax_173->dw0000 ^ (fp->ptr0008)->dw0000;
	g_t40798D.u0 = (uint32) ((word32) g_t40798D.u1 & g_t407995.u0);
	struct Eq_512 * eax_183 = fp->ptr0008;
	eax_183->dw0000 = eax_183->dw0000 ^ fp->ptr000C;
	ebpOut = fp->ptrFFFFFFFC;
	esiOut = esi_171;
	ediOut = edi;
	return edx_150;
}

// 0040471A: Register ui32 fn0040471A(Register uint32 ecx, Register ui32 ebx, Register word32 esi, Register word32 edi, Stack (ptr32 Eq_1358) dwArg04, Stack ui32 dwArg08, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn00405562
ui32 fn0040471A(uint32 ecx, ui32 ebx, word32 esi, word32 edi, struct Eq_1358 * dwArg04, ui32 dwArg08, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	Eq_1363 dwLoc60;
	ui32 dwLoc9C;
	word32 dwLoc10;
	word32 eax_10 = dwArg04->dw40749C;
	g_dw407951 = 0x00;
	ptr32 esp_19 = fp - 0x01FC;
	while (g_dw407951 < 0x14)
	{
		if (g_dw407951 == 0x1C)
		{
			eax_10 = COMCTL32.dll!ImageList_AddMasked(dwLoc10, 21311, 16228);
			esp_19 = esp_473;
		}
		++g_dw407951;
	}
	struct Eq_1378 * esp_20 = esp_19 - 4;
	esp_20->dw0000 = ebx;
	up32 v29_42;
	esp_20->dwFFFFFFFC = esi;
	if (dwLoc60 <= 0x35E2)
	{
		up32 * edx_40 = g_ptr407BB7;
		v29_42 = *edx_40 - g_t4079D1.u2 - (word32) (dwLoc60 < 0x35E2);
		*edx_40 = v29_42;
	}
	byte * ecx_52 = g_ptr407B47;
	*ecx_52 = *ecx_52 - 0x44 - (byte) (v29_42 < 0x00);
	esp_20->dwFFFFFFF8 = edi;
	word32 * edx_83 = g_ptr407B43;
	*edx_83 -= 22514;
	g_a407340[((eax_10 ^ 13615) + 0x252E) * 0x02] = 0x00;
	g_dw4079F9 &= dwLoc9C;
	union Eq_1457 * ebx_117 = g_ptr407C2F;
	ebx_117->u0 = (byte) (ebx_117->u0 - 101);
	g_dw407969 -= g_dw407A05;
}

// 00404C15: Register word32 fn00404C15(Register uint32 edx, Register word32 esi, Register word32 edi, Register out ptr32 ebpOut, Register out ptr32 ediOut)
// Called from:
//      fn00404585
word32 fn00404C15(uint32 edx, word32 esi, word32 edi, ptr32 & ebpOut, ptr32 & ediOut)
{
	struct Eq_1479 * fp;
	ui32 dwLoc9C;
	byte bLocC8;
	int32 dwLoc20;
	up32 dwLoc0114;
	Eq_1484 dwLoc7C;
	up32 dwLoc30_415;
	for (dwLoc30_415 = 0x00; dwLoc30_415 < 0x10; ++dwLoc30_415)
	{
		if (dwLoc30_415 == 0x11)
			SetBitmapDimensionEx((struct HBITMAP__ *) 10043, 23110, dwLoc20, &g_dw4079A5);
	}
	word32 ecx_45;
	if (fn00404313(edx, 0x252E, out ecx_45) != 0x00)
	{
		fn0040445A();
		ui32 ecx_68 = g_dw4072F4;
		int32 eax_72 = g_dw4072F0;
		g_dw4079D5 &= dwLoc9C;
		g_t407995.u0 = (uint32) ((word32) g_t407995.u1 & 0x1228);
		--g_dw4079CD;
		ui32 dwLoc14_435 = ~0x252D;
		ui8 edx_116[] = null;
		if (ecx_68 != 0x00)
		{
			do
			{
				ui8 bl_239;
				g_dw407A05 = g_dw407A05 + (word32) bLocC8 + (word32) (g_dw407A39 > 0x252E);
				byte cl_119 = edx_116[eax_72];
				if (false)
				{
					word32 ecx_241 = (word32) cl_119;
					byte cl_259 = (byte) ecx_241;
					if (dwLoc0114 <= 0x7D92)
						g_dw4079A5 <<= 0x01;
					g_t40797D.u0 = (ui32) (g_t40797D.u0 | dwLoc7C);
					bl_239 = (cl_259 ^ 0x5F) + 0x31 + cl_119 - edx_116[eax_72];
				}
				else
				{
					word32 ebx_158 = (word32) cl_119 - ~0x24FF;
					up32 dwLoc54_453 = 0x00;
					do
					{
						up32 dwLoc54_455 = dwLoc54_453 + 0x01;
						if (dwLoc54_455 == 0x20)
						{
							fp->dwFFFFFEAC = ~0x1003;
							fp->dwFFFFFEA8 = ~0x1003;
							fp->dwFFFFFEA4 = dwLoc14_435;
							fp->dwFFFFFEA0 = 0x32A0;
							fp->dwFFFFFE9C = ecx_68;
							fp->dwFFFFFE98 = dwLoc14_435;
						}
						dwLoc54_453 = dwLoc54_455;
					} while (dwLoc54_455 < 0x18);
					bl_239 = __ror<byte,byte>((byte) ebx_158 - 0x2E, 0x01);
				}
				edx_116[eax_72] = edx_116[eax_72] ^ edx_116[eax_72];
				dwLoc7C.u1 = (word32) dwLoc7C + g_ptr407C27->u1;
				++edx_116[eax_72];
				edx_116[eax_72] += bl_239;
				--edx_116[eax_72];
				ui32 edx_352 = dwLoc14_435 + 0x01 ^ 13615 ^ 13615;
				dwLoc14_435 = edx_352;
				edx_116 = edx_352 + 0x252E;
			} while (edx_352 + 0x252E != ecx_68);
		}
	}
}

// 00404FE4: Register (ptr32 (arr byte)) fn00404FE4(Register up32 ebx, Register word32 esi, Register word32 edi)
// Called from:
//      fn00405562
byte (* fn00404FE4)[](up32 ebx, word32 esi, word32 edi)
{
	ptr32 fp;
	Eq_1662 dwLoc34;
	struct Eq_1663 * edx_13 = (struct Eq_1663 *) 0x05;
	ptr32 esp_14 = fp - 8;
	while (g_dw407090 == 0x00)
	{
		g_dw407A2D = 0x00;
		while (g_dw407A2D < 0x19)
		{
			if (g_dw407A2D == 0x28)
			{
				COMCTL32.dll!ImageList_GetImageCount(0x4D96);
				edx_13 = edx_192;
				esp_14 = esp_190;
			}
			++g_dw407A2D;
		}
		edx_13[4224215] = (struct Eq_1663) ((edx_13[4224215] ^ 0x5F) + 0x31);
		++edx_13;
		if (edx_13 >= (struct Eq_1663 *) 0x14)
			break;
	}
	Mem60 = Mem45;
	word32 * eax_62 = g_ptr4072D8->ptr000C;
	struct Eq_1681 * esp_67 = esp_14 - 4;
	esp_67->dw0000 = esi;
	esp_67->dwFFFFFFFC = edi;
	word32 edi_134 = 0x00;
	if (*eax_62 == 0x00)
		edi_134 = fn00403BCC(ebx);
	g_w4079BD -= g_w407A15;
	ui32 ecx_108 = ~0x1002;
	byte (* edx_107)[] = (byte (*)[]) 13615;
	do
	{
		ui32 ecx_110 = ecx_108 ^ 13615;
		struct Eq_1740 * eax_116 = ecx_110 * 0x02 + 0x4A5C;
		eax_116->w4074C4 = (eax_116->w4074BC ^ 0x032F) + 0x022E;
		ecx_108 = ecx_110 + 0x01 ^ 13615;
	} while (ecx_108 != ~0x1005);
	if (edi_134 != 0x00)
	{
		esp_67->tFFFFFFF8.u0 = 0x09;
		Eq_1662 ecx_143 = esp_67->tFFFFFFF8.u0;
		g_t407995.u0 = (uint32) (g_t407995.u0 + 23177 + (word32) (ecx_143 < dwLoc34));
		edx_107 = 4224288 - ecx_143;
		Eq_1780 esi_154 = 0x00407640 - ecx_143;
		do
		{
			Mem164[esi_154 + ecx_143:byte] = (Mem158[edx_107 + ecx_143:byte] ^ 0x5F) + 0x31;
			--ecx_143;
		} while (ecx_143 != 0x00);
		*g_ptr4072D8->ptr000C = edi_134;
	}
	return edx_107;
}

// 00405183: Register word32 fn00405183(Register up32 ebx, Register word32 esi, Register word32 edi)
// Called from:
//      Win32CrtStartup
word32 fn00405183(up32 ebx, word32 esi, word32 edi)
{
	word32 * fp;
	g_dw4079F9 = 0x1C;
	struct Eq_1813 * ebp_118 = fp - 4;
	while (g_dw4079F9 != 0x00)
	{
		if (g_dw4079F9 == 0x1D)
			AreFileApisANSI();
		--g_dw4079F9;
	}
	g_ptr4074B8 = null;
	word32 edx_162;
	word32 eax_30 = fn00405562(ebx, esi, edi, out edx_162);
	g_dw407A19 -= 4225413;
	if (eax_30 != 0x00)
	{
		ui32 edi_121 = ~0x1107;
		word32 * ebx_114 = fp;
		word32 esi_123 = 13615;
		do
		{
			g_dw407318 = g_dw4074CC;
			g_dw40731C = g_dw4074D0;
			g_dw407320 = g_dw4074D4;
			if (edi_121 == ~0x1004)
			{
				ebp_118->tFFFFFFEC.u0 = 617848348;
				if (ebp_118->tFFFFFFEC.u0 < 617848348)
				{
					union Eq_1457 * eax_99 = g_ptr407C2F;
					eax_99->u1 = (word32) (eax_99->u1 - g_dw407A0D);
					ebp_118->tFFFFFFEC.u0 = (int32) (ebp_118->tFFFFFFEC.u0 - *g_ptr407B97);
				}
				word32 * eax_109 = g_ptr4074B8;
				*eax_109 = (char *) g_ptr407100 + *eax_109;
			}
			else if (edi_121 == ~0x11C2)
			{
				g_ptr407314 = ebp_118 - 8;
				word32 eax_77 = fn004052FB(edx_162, esi_123, edi_121, out edx_162, out ebx_114, out ebp_118, out esi_123, out edi_121);
				g_t4079A9.u1 = (word32) (g_t4079A9.u1 - (ebp_118->tFFFFFFEC).u0);
				*g_ptr4074D8 = eax_77;
			}
			g_ptr4074B8 = ebx_114;
			edi_121 = (edi_121 ^ esi_123) - (ebp_118->dwFFFFFFF4 ^ esi_123) - 0x252E ^ esi_123;
		} while (edi_121 != ~0x1003);
	}
	return ebp_118->dw0000;
}

// 004052FB: Register word32 fn004052FB(Register word32 edx, Register word32 esi, Register ui32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out (ptr32 Eq_1920) ebpOut, Register out ptr32 esiOut, Register out Eq_1922 ediOut)
// Called from:
//      fn00405183
word32 fn004052FB(word32 edx, word32 esi, ui32 edi, ptr32 & edxOut, ptr32 & ebxOut, struct Eq_1920 & ebpOut, ptr32 & esiOut, union Eq_1922 & ediOut)
{
	ui32 dwLoc48;
	Eq_519 dwLoc28;
	up32 dwLoc1C_155;
	for (dwLoc1C_155 = 0x00; dwLoc1C_155 < 0x18; ++dwLoc1C_155)
	{
		if (dwLoc1C_155 == 0x1E)
		{
			ChangeMenuW((struct HMENU__ *) 0x65F9, 0x6B45, &g_t407DBF, 0x7C20, dwLoc28);
			dwLoc1C_155 = 0x6B45;
		}
	}
	g_t407955.u0 = (int32) ((word32) g_t407955.u1 & dwLoc48);
}

// 00405439: Register ui32 fn00405439(Register word32 esi, Register word32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn004052FB
ui32 fn00405439(word32 esi, word32 edi, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_572 dwLoc18;
	Eq_572 dwLoc24;
	word32 * eax_9 = g_ptr407304;
	up32 dwLoc20_166;
	for (dwLoc20_166 = 0x00; dwLoc20_166 < 0x12; ++dwLoc20_166)
	{
		if (dwLoc20_166 == 33)
			CreateFileW(&g_t407DCF, (char *) 35397, dwLoc24, (struct _SECURITY_ATTRIBUTES *) 0x7F5F, dwLoc18, (char *) ~0x1003, (void *) 23778);
	}
	<anonymous> * eax_23 = g_ptr40730C;
	struct Eq_512 * ebx_31 = g_ptr407308;
	ptr32 edx_50;
	word32 esi_77;
	struct Eq_2033 * ebp_78;
	word32 edi_80;
	ptr32 edx_76 = fn00404585(0x00, edx_50, 13615, ebx_31, eax_23, (struct Eq_1221 *) 203272, out ebp_78, out esi_77, out edi_80);
	g_ptr407300 = (word32 *) (&ebp_78->ptr0000 + 1);
	word32 * eax_90 = g_ptr407300;
	<anonymous> * ecx_91 = g_ptr407100;
	g_dw407A05 &= (word32) ebp_78->wFFFFFFE4;
	*eax_90 = (char *) ecx_91 + *eax_90;
	struct Eq_1221 * esp_81 = (struct Eq_1221 *) <invalid>;
	word32 eax_99 = ebp_78->dwFFFFFFFC;
	ebp_78->tFFFFFFE0.u0 = (ui32) ((word32) ebp_78->tFFFFFFE0.u1 ^ 6648);
	ptr32 edi_115 = esp_81->ptr0010;
	ptr32 esi_121 = esp_81->ptr0014;
	ptr32 ebx_123 = esp_81->ptr0018;
	ptr32 ebp_125 = ebp_78->ptr0000;
	edxOut = edx_76;
	ebxOut = ebx_123;
	ebpOut = ebp_125;
	esiOut = esi_121;
	ediOut = edi_115;
	return (eax_99 ^ edi_80) + esi_77;
}

// 00405562: Register word32 fn00405562(Register up32 ebx, Register word32 esi, Register word32 edi, Register out ptr32 edxOut)
// Called from:
//      fn00405183
word32 fn00405562(up32 ebx, word32 esi, word32 edi, ptr32 & edxOut)
{
	ptr32 fp;
	word32 dwLoc40;
	word16 wLoc7C;
	Eq_2104 edx_116 = fn00404FE4(ebx, esi, edi);
	g_t4079B9.u1 = (up32) 0x00;
	while (true)
	{
		ptr32 esp_472 = fp - 0xAC;
		if (g_t4079B9.u1 >= 0x1B)
			break;
		if (g_t4079B9.u1 == 0x25)
			LoadIconW(&g_t400000, &g_t407E19);
		g_t4079B9.u1 = (up32) (g_t4079B9.u1 + 0x01);
	}
	g_t4079A1.u0 = (uint32) (g_t4079A1.u0 - dwLoc40);
	ui32 dwLoc08_578 = ~0x1002;
	word32 esi_113 = 13615;
	word32 edi_115 = 0x252E;
	while (g_dw407090 == 0x00)
	{
		struct Eq_515 * eax_84 = g_ptr4072D8;
		word32 * ecx_85 = eax_84->ptr000C;
		if (*ecx_85 != 0x00)
		{
			struct Eq_2152 * esp_89 = esp_472 - 4;
			esp_89->dw0000 = 4224292;
			g_w407A15 &= 4225485;
			g_w407A15 -= 4225429;
			esp_89->dwFFFFFFFC = 0x01;
			esp_89->ptrFFFFFFF8 = &eax_84->dw0040 + 4;
			esp_89->dwFFFFFFF4 = *ecx_85;
			esp_89->ptrFFFFFFF0 = g_ptr407584;
			word32 ebx_961;
			g_dw4074EC = fn004069C6(edx_116, esp_89->ptrFFFFFFF0, esp_89->dwFFFFFFF4, esp_89->ptrFFFFFFF8, esp_89->dwFFFFFFFC, out edx_116, out ebx_961, out esi_113, out edi_115);
		}
		ptr32 esp_139 = esp_472;
		if (g_dw4074EC != 0x00)
		{
			ui32 ecx_134 = ~0x1002;
			while (true)
			{
				struct Eq_2225 * esp_140 = esp_139 - 4;
				esp_140->ptr0000 = (char *) 0x61;
				byte * ebx_144 = g_ptr407B6F;
				*ebx_144 |= 0x2E;
				esp_139 = (char *) &esp_140->ptr0000 + 4;
				edx_116.u0 = (uint32) (0x0002CB38 % esp_140->ptr0000);
				if (edx_116 > 0x8A || ecx_134 == ~0x1032)
					break;
				esp_140->ptr0000 = &g_b40752C;
				esp_140->tFFFFFFFC = (Eq_572) &g_b40753C;
				ui32 ebx_163 = ecx_134 ^ esi_113;
				int32 eax_178 = _stricmp(esp_140->tFFFFFFFC, esp_140->ptr0000);
				g_t40798D.u0 = 0x00;
				uint32 edx_170 = (uint32) ((uint64) (ebx_163 + 0x252E) % ((esi_113 ^ ~0x1006) + edi_115));
				Eq_2104 edx_176 = edx_170 << 0x03;
				do
				{
					g_t40798D.u0 = (uint32) (g_t40798D.u0 + 0x01);
					if (g_t40798D.u0 == 0x23)
					{
						esp_140->tFFFFFFFC = (char *) 27673;
						Sleep(esp_140->tFFFFFFFC);
					}
				} while (g_t40798D.u0 < 0x13);
				if (eax_178 != 0x00)
				{
					esp_140->ptr0000 = (char *) g_a407498[edx_170];
					esp_140->tFFFFFFFC = (Eq_572) &g_b4074C4;
					esp_140->dwFFFFFFF8 = 0x00407340;
					esp_140->dwFFFFFFF4 = 0x03;
					esp_140->ptrFFFFFFF0 = 4224240;
					esp_140->dwFFFFFFEC = g_dw4074EC;
					g_t407949.u1 = (ui32) (g_t407949.u1 - 4225373);
					g_t407949.u1 = (ui32) (g_t407949.u1 | 4225373);
					esp_140->ptrFFFFFFE8 = g_ptr407584;
					fn004069C6(edx_170 << 0x03, esp_140->ptrFFFFFFE8, esp_140->dwFFFFFFEC, esp_140->ptrFFFFFFF0, esp_140->dwFFFFFFF4, out edx_176, out ebx_163, out esi_113, out edi_115);
				}
				ptr32 esp_283 = esp_139;
				ui32 eax_267 = ~0x11F2;
				ui32 dwLoc14_594 = ~0x24DD;
				do
				{
					if (eax_267 == ~0x11D7)
					{
						union Eq_2411 * eax_333 = g_ptr407BBF;
						eax_333->u1 = (byte) __rol<byte,byte>(eax_333->u1, 0x07);
						word32 * eax_337 = g_ptr4072D8->ptr000C;
						struct Eq_2426 * esp_338 = esp_283 - 4;
						esp_338->dw0000 = 4224568;
						esp_338->dwFFFFFFFC = *eax_337;
						union Eq_79 * eax_355 = g_ptr407C13;
						eax_355->u1 = (byte) (eax_355->u1 + 121);
						g_dw407514 = fn00000000();
					}
					else if (eax_267 == ~0x11C2)
					{
						int32 ecx_311;
						word32 eax_282 = *g_ptr40711C;
						struct Eq_2515 * esp_284 = esp_283 - 4;
						esp_284->dw0000 = 4224220;
						esp_284->dwFFFFFFFC = eax_282;
						esp_284->dwFFFFFFF8 = 0x02;
						esp_284->ptrFFFFFFF4 = 0x004071A4;
						esp_284->dwFFFFFFF0 = eax_282;
						esp_284->ptrFFFFFFEC = g_ptr407584;
						fn004069C6(edx_176, esp_284->ptrFFFFFFEC, esp_284->dwFFFFFFF0, esp_284->ptrFFFFFFF4, esp_284->dwFFFFFFF8, out edx_176, out ebx_163, out esi_113, out edi_115);
						if (esi_113 != 0x6C9B)
						{
							ecx_311 = (word32) wLoc7C;
							wLoc7C = (word16) (ecx_311 >> 0x09);
						}
						g_t4079C5.u1 = (word32) ((word32) g_t4079C5.u0 - g_dw4079A5 - (word32) (ecx_311 >> 0x09 < 0x00));
						esp_283 = &esp_284->dw0000 + 1;
					}
					eax_267 = dwLoc14_594 - 0x01 ^ esi_113;
					ui32 ecx_391 = eax_267 ^ esi_113;
					dwLoc14_594 = ecx_391;
				} while (ecx_391 + edi_115 != 0x00);
				uint32 ecx_403 = (esi_113 ^ ~0x1006) + edi_115;
				struct Eq_2474 * esp_414 = esp_283 - 4;
				esp_414->dw0000 = (uint32) ((uint64) ((dwLoc08_578 ^ esi_113) + edi_115) % ecx_403) << 0x03;
				esp_414->ptrFFFFFFFC = edx_170 << 0x03;
				word32 ebx_422 = fn0040471A(ecx_403, ebx_163, esi_113, edi_115, esp_414->ptrFFFFFFFC, esp_414->dw0000, out esi_113, out edi_115);
				esp_139 = &esp_414->dw0000 + 1;
				ecx_134 = ebx_422 + 1 ^ esi_113;
			}
		}
		word32 dwLoc24_657 = 0x10;
		while (true)
		{
			esp_472 = esp_139;
			if (dwLoc24_657 == 0x00)
				break;
			if (dwLoc24_657 == 0x1A)
			{
				LPWSTR * esp_492 = esp_139 - 4;
				*esp_492 = (LPWSTR *) (WCHAR *) 0x6DC6;
				CharLowerW(*esp_492);
			}
			--dwLoc24_657;
		}
		ui32 eax_467 = (dwLoc08_578 ^ esi_113) + 0x01 ^ esi_113;
		dwLoc08_578 = eax_467;
		if (eax_467 == ~0x11F2)
			break;
	}
}

// 00405A9C: Register Eq_2104 fn00405A9C(Register Eq_2104 edx, Register (ptr32 Eq_2577) esi, Register word32 edi, Stack (ptr32 Eq_2579) dwArg04, Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10, Stack ptr32 dwArg14, Stack ptr32 dwArg18, Stack ptr32 dwArg1C, Stack ptr32 dwArg20)
// Called from:
//      fn004069C6
Eq_2104 fn00405A9C(Eq_2104 edx, struct Eq_2577 * esi, word32 edi, struct Eq_2579 * dwArg04, ptr32 dwArg08, ptr32 dwArg0C, ptr32 dwArg10, ptr32 dwArg14, ptr32 dwArg18, ptr32 dwArg1C, ptr32 dwArg20)
{
}

// 00405D48: Register Eq_572 Win32CrtStartup()
Eq_572 Win32CrtStartup()
{
	struct Eq_2588 * fp;
	word32 esi;
	word32 edi;
	Eq_2591 tLoc14;
	Eq_519 dwLoc10;
	Eq_519 dwLoc1C;
	Eq_572 eax_510;
	if (SHLWAPI.dll!StrSpnA(4224348, 4224344) > 0x0A)
		eax_510 = null;
	else
	{
		esp_14->dwFFFFFFFC = esi;
		esp_14->dwFFFFFFF8 = edi;
		word32 dwLoc0220_586;
		for (dwLoc0220_586 = 0x13; dwLoc0220_586 != 0x00; --dwLoc0220_586)
		{
			if (dwLoc0220_586 == 0x14)
			{
				esp_14->tFFFFFFF4 = 15354;
				esp_14->tFFFFFFF0.u0 = 0x3D02;
				esp_14->tFFFFFFEC.u0 = (HDC) dwLoc10;
				esp_14->tFFFFFFE8.u0 = (HDC) dwLoc1C;
				DefWindowProcA(esp_14->tFFFFFFE8.u0, esp_14->tFFFFFFEC.u0, esp_14->tFFFFFFF0.u0, esp_14->tFFFFFFF4);
			}
		}
		fn004041AB(fp - 4, &tLoc14, ~0x1002);
		esp_14->tFFFFFFF4 = 0x46;
		esp_14->tFFFFFFF4 = 0x3A;
		esp_14->tFFFFFFF4 = 0x5C;
		esp_14->tFFFFFFF4 = 0x4A;
		esp_14->tFFFFFFF4 = 0x48;
		esp_14->tFFFFFFF4 = 0x44;
		esp_14->tFFFFFFF4 = 0x4B;
		union Eq_51 * edi_140 = g_ptr407BEB;
		edi_140->u0 = (byte) (edi_140->u0 + 11);
		esp_14->tFFFFFFF4 = 0x44;
		esp_14->tFFFFFFF4 = 0x2E;
		g_t4079A1.u0 = 0x00;
		do
		{
			g_t4079A1.u0 = (uint32) (g_t4079A1.u0 + 0x01);
			if (g_t4079A1.u0 == 0x19)
			{
				esp_14->tFFFFFFF0.u0 = (HDC) dwLoc1C;
				esp_14->tFFFFFFEC.u0 = (HDC) dwLoc1C;
				ClientToScreen(esp_14->tFFFFFFEC.u0, esp_14->tFFFFFFF0.u2);
			}
		} while (g_t4079A1.u0 < 0x18);
		Mem508 = Mem208;
		eax_510 = (Eq_572) *fp->ptrFFFFFFF4;
	}
	return eax_510;
}

// 004062AE: Register uint32 b_cw_wkqwprts_T_T__(Stack (ptr32 int32) ptrArg04, Stack (ptr32 char) ptrArg08)
uint32 b_cw_wkqwprts_T_T__(int32 * ptrArg04, char * ptrArg08)
{
	up32 ecx;
	g_t4079B9.u1 = (up32) ((word32) g_t4079B9.u0 + g_dw4079E9 + (word32) (ecx < g_dw407A2D));
	g_t4079FD.u1 = (word32) ((word32) g_t4079FD.u0 - *g_ptr407B6B);
	union Eq_79 * edx_21 = g_ptr407C13;
	edx_21->u0 = (ui32) (edx_21->u0 | g_dw407981);
	return <invalid>;
}

<anonymous> g_t4062FC = <code>; // 004062FC
// 004069C6: Register word32 fn004069C6(Register Eq_2104 edx, Stack (ptr32 code) dwArg04, Stack word32 dwArg08, Stack ptr32 dwArg0C, Stack word32 dwArg10, Register out Eq_2104 edxOut, Register out Eq_2196 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn0040471A
//      fn00405562
word32 fn004069C6(Eq_2104 edx, <anonymous> * dwArg04, word32 dwArg08, ptr32 dwArg0C, word32 dwArg10, union Eq_2104 & edxOut, union Eq_2196 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	Eq_2777 tLoc40;
	Eq_2778 tLoc20;
	word32 dwLoc28;
	word32 dwLoc2C;
	word32 dwLoc30;
	word16 dwLoc24[];
	up32 dwLoc90;
	int32 dwLoc38;
	word32 esi_30 = ~0x1002;
	ptr32 * esp_206 = fp - 0x0204;
	word32 dwLoc18_538 = ~0x1003;
	word32 dwLoc1C_539 = ~0x1002;
	ui32 dwLoc10_540 = ~0x1002;
l00406A2E:
	if (dwLoc1C_539 == esi_30)
	{
		word32 dwLoc68_542;
		for (dwLoc68_542 = 0x1C; dwLoc68_542 != 0x00; --dwLoc68_542)
		{
			if (dwLoc68_542 == 0x2A)
			{
				union Eq_519 * esp_481 = esp_206 - 4;
				esp_481->u0 = 0x7587;
				CreateHalftonePalette(esp_481->u0);
			}
		}
		struct Eq_2799 * esp_52 = esp_206 - 4;
		esp_52->ptr0000 = fp - 48;
		esp_52->ptrFFFFFFFC = fp - 36;
		esp_52->ptrFFFFFFF8 = fp - 52;
		esp_52->ptrFFFFFFF4 = fp - 40;
		esp_52->ptrFFFFFFF0 = fp - 44;
		esp_52->ptrFFFFFFEC = fp - 0x0044;
		g_dw407A39 = g_dw407A39 ^ 0x0040794D;
		g_dw407A39 -= 4225413;
		g_dw407A39 |= 0x0040796D;
		esp_52->ptrFFFFFFE8 = fp - 56;
		esp_52->ptrFFFFFFE4 = &tLoc40;
		edx = fn00405A9C(edx, &tLoc20, dwArg08, esp_52->ptrFFFFFFE4, esp_52->ptrFFFFFFE8, esp_52->ptrFFFFFFEC, esp_52->ptrFFFFFFF0, esp_52->ptrFFFFFFF4, esp_52->ptrFFFFFFF8, esp_52->ptrFFFFFFFC, esp_52->ptr0000);
		esi_30 = ~0x1002;
	}
	if (dwLoc28 != esi_30)
	{
		struct Eq_2901 * eax_101 = tLoc20;
		if (eax_101->dw0018 == 0x00 || eax_101->dw0014 == 0x00)
		{
			dwLoc18_538 = esi_30;
			goto l00406CAA;
		}
	}
	if (dwLoc2C != esi_30 && (dwLoc10_540 != (dwLoc30 + ~0x252D ^ 13615) && dwLoc18_538 == ~0x1003))
	{
		Eq_2932 ecx_145 = (dwLoc10_540 ^ 13615) + 0x252E;
		if (ecx_145 >= 0x05)
			dwLoc1C_539 = ~0x1003;
		struct Eq_2939 * eax_153 = tLoc20;
		if (ecx_145 < (eax_153->t0018).u0)
		{
			edx = (word32) dwLoc24[ecx_145];
			if (edx <= eax_153->dw0014 - 0x01)
			{
				g_t407965.u1 = (word32) (g_t407965.u1 & g_t40794D.u0);
				ptr32 * esp_208 = esp_206 - 4;
				*esp_208 = fp - 8;
				word32 eax_197 = 0x252E;
				up32 dwLocC8_614 = 0x00;
				do
				{
					dwLocC8_614 = dwLocC8_1030 + 0x01;
					if (dwLocC8_614 == 0x2B)
					{
						eax_197 = COMCTL32.dll!ImageList_GetImageCount(dwLoc10_540);
						ecx_145 = ecx_232;
						esp_208 = esp_230;
					}
					dwLocC8_1030 = dwLocC8_614;
				} while (dwLocC8_1030 < 0x1C);
				bool C_255;
				if (dwLoc90 > 0x250F)
				{
					byte * edx_248 = g_ptr407BCB;
					byte v27_249 = *edx_248 - 99;
					*edx_248 = v27_249;
					C_255 = SLICE(cond(v27_249), bool, 1);
				}
				else
				{
					word32 v28_244 = g_dw407971 - g_ptr407C3F->u0;
					g_dw407971 = v28_244;
					C_255 = SLICE(cond(v28_244), bool, 1);
				}
				union Eq_3021 * edx_253 = g_ptr407C0B;
				edx_253->u1 = (byte) __rcr<byte,byte>(edx_253->u1, 0x05, C_255);
				int32 edx_267 = (dwLoc28 ^ 13615) + eax_197;
				struct Eq_3036 * esp_281 = esp_208 - 4;
				esp_281->dw0000 = (word32) *((word32) (edx_267 *s ecx_145) + dwLoc38) + dwArg08;
				g_dw4079E1 -= 0x36A2;
				esp_281->ptrFFFFFFFC = dwArg0C;
				g_dw407A39 -= 0x004079E9;
				g_dw407A39 &= 0x004079C9;
				word32 ecx_305;
				dwArg04();
l00406CAA:
				dwLoc10_540 = (dwLoc10_540 ^ 13615) + 0x01 ^ 13615;
				goto l00406A2E;
			}
		}
	}
	Mem433 = Mem164;
	struct Eq_3065 * esp_436 = esp_206 + 1;
	ptr32 edi_435 = *esp_206;
	ptr32 esi_437 = esp_436->ptr0000;
	Eq_2196 ebx_439 = esp_436->t0004.u0;
	edxOut = edx;
	ebxOut = ebx_439;
	esiOut = esi_437;
	ediOut = edi_435;
	return 0x00;
}

// 00406E93: Register uint32 km_gSHWw(Stack (ptr32 char) ptrArg04)
uint32 km_gSHWw(char * ptrArg04)
{
	up32 eax;
	up32 dwLoc24;
	union Eq_3021 * ecx_10 = g_ptr407C0B;
	ecx_10->u0 = (ui32) (ecx_10->u0 & g_dw407A11);
	g_dw4079E1 |= g_ptr407C3F->u0;
	g_t40794D.u0 = (ui32) ((word32) g_t40794D.u1 - *g_ptr407B8B - (word32) (dwLoc24 < eax));
	return <invalid>;
}

// 00406ED7: Register int16 NP_O_BkgxXNMr__(Stack uint32 dwArg04, Stack int16 wArg08)
int16 NP_O_BkgxXNMr__(uint32 dwArg04, int16 wArg08)
{
	union Eq_314 * esi_14 = g_ptr407C1B;
	esi_14->u1 = (word32) (esi_14->u1 + (word32) g_t4079A1.u1);
	union Eq_2411 * edx_18 = g_ptr407BBF;
	edx_18->u0 = (ui32) (edx_18->u0 ^ (word32) g_b4079F5);
	ui32 * edx_23 = g_ptr407C3B;
	*edx_23 |= (word32) g_t407989.u0;
	return <invalid>;
}

// 00406F10: Register int16 _Cxmehk_(Stack uint16 wArg04, Stack int32 dwArg08)
int16 _Cxmehk_(uint16 wArg04, int32 dwArg08)
{
	ptr32 fp;
	ptr32 ebx;
	g_t4079F1.u0 = (uint32) (g_t4079F1.u0 + g_ptr407C3F->u0 + (word32) (ebx < fp - 44));
	g_b407985 |= g_ptr407BC7->u1;
	g_dw407979 -= g_dw407961;
	return <invalid>;
}

// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 * g_ptr407030 = &g_dw401034; // 00407030
ui32 ** g_ptr40703C = &g_ptr407030; // 0040703C
ui32 *** g_ptr407040 = &g_ptr40703C; // 00407040
word32 g_dw407074 = 4208804; // 00407074
Eq_405 g_t407080 = 0x00407068; // 00407080
word32 * g_ptr407084 = &g_dw407074; // 00407084
struct Eq_517 * g_ptr40708C = null; // 0040708C
word32 g_dw407090 = 0x00; // 00407090
word32 * g_a4070D4[] = // 004070D4
	{
	};
BITMAPINFO * g_ptr4070F0 = null; // 004070F0
Eq_519 g_t4070F4 = // 004070F4
	{
		null
	};
word32 g_dw4070F8 = 0x00; // 004070F8
<anonymous> * g_ptr407100 = null; // 00407100
word32 g_dw407104 = 0x00; // 00407104
word32 g_dw407108 = 0x00; // 00407108
Eq_515 g_t407110 = // 00407110
	{
		&g_ptr40708C,
		&g_dw407108,
		&g_dw4070F8,
		0x00,
	};
word32 * g_ptr40711C = &g_dw407108; // 0040711C
struct Eq_515 * g_ptr4072D8 = &g_t407110; // 004072D8
Eq_938 g_t4072EC = 0x07860667; // 004072EC
int32 g_dw4072F0 = 0x05456465; // 004072F0
ui32 g_dw4072F4 = 0x05475774; // 004072F4
word32 * g_ptr407300 = &g_dw6576405; // 00407300
word32 * g_ptr407304 = &g_dw6546406; // 00407304
struct Eq_512 * g_ptr407308 = &g_t65140B; // 00407308
<anonymous> * g_ptr40730C = &g_tE61A67; // 0040730C
struct Eq_666 * g_ptr407310 = &g_t403DE4; // 00407310
ptr32 g_ptr407314 = 0x00077718; // 00407314
word32 g_dw407318 = 0x06751718; // 00407318
word32 g_dw40731C = 0x00060718; // 0040731C
word32 g_dw407320 = 0x07655767; // 00407320
word16 g_a407340[] = // 00407340
	{
	};
Eq_3247 g_a407498[] = // 00407498
	{
	};
word32 * g_ptr4074B8 = &g_dw342509; // 004074B8
char g_b4074C4 = 'f'; // 004074C4
word32 g_dw4074CC = 488810; // 004074CC
word32 g_dw4074D0 = 0x00077777; // 004074D0
word32 g_dw4074D4 = 0x08764664; // 004074D4
word32 * g_ptr4074D8 = &g_dw42406; // 004074D8
word32 g_dw4074EC = 0x00; // 004074EC
word32 g_dw407514 = 0x00; // 00407514
char g_b40752C = 'K'; // 0040752C
char g_b40753C = 'J'; // 0040753C
word32 g_dw407548 = 0x00787616; // 00407548
word32 g_dw40754C = 3479004; // 0040754C
word32 g_dw407550 = 0x08974774; // 00407550
word32 g_dw407554 = 0x76860438; // 00407554
<anonymous> * g_ptr407580 = fn004069C6; // 00407580
<anonymous> * g_ptr407584 = &g_t4062FC; // 00407584
ui32 g_dw407945 = 0x00100E42; // 00407945
Eq_142 g_t407949 = // 00407949
	{
		0x7C6C
	};
Eq_88 g_t40794D = // 0040794D
	{
		0x00105F29
	};
up32 g_dw407951 = 0x00106D74; // 00407951
Eq_448 g_t407955 = // 00407955
	{
		1057915
	};
word32 g_dw40795D = 1076670; // 0040795D
uint32 g_dw407961 = 1062066; // 00407961
Eq_347 g_t407965 = // 00407965
	{
		0x0C
	};
word32 g_dw407969 = 0x0010280C; // 00407969
ui32 g_dw40796D = 1071571; // 0040796D
word32 g_dw407971 = 1060700; // 00407971
word32 g_dw407975 = 0x00104990; // 00407975
word32 g_dw407979 = 1071157; // 00407979
Eq_394 g_t40797D = // 0040797D
	{
		0x00104B74
	};
ui32 g_dw407981 = 1060706; // 00407981
byte g_b407985 = 0x0D; // 00407985
Eq_316 g_t407989 = // 00407989
	{
		0x5C
	};
Eq_59 g_t40798D = // 0040798D
	{
		0x00102F70
	};
Eq_142 g_t407991 = // 00407991
	{
		0x5D60
	};
Eq_245 g_t407995 = // 00407995
	{
		0x00100376
	};
word32 g_dw407999 = 0x00106D30; // 00407999
uint32 g_dw40799D = 0x00101902; // 0040799D
Eq_233 g_t4079A1 = // 004079A1
	{
		0x001023BB
	};
uint32 g_dw4079A5 = 0x00103D74; // 004079A5
Eq_252 g_t4079A9 = // 004079A9
	{
		0x4C
	};
Eq_191 g_t4079AD = // 004079AD
	{
		0x001066B0
	};
Eq_19 g_t4079B1 = // 004079B1
	{
		~0x12
	};
word32 g_dw4079B5 = 0x00100365; // 004079B5
Eq_2108 g_t4079B9 = // 004079B9
	{
		0x20
	};
word16 g_w4079BD = 11892; // 004079BD
Eq_158 g_t4079C1 = // 004079C1
	{
		0x00105E1D
	};
Eq_438 g_t4079C5 = // 004079C5
	{
		166
	};
Eq_25 g_t4079C9 = // 004079C9
	{
		0x2F
	};
word32 g_dw4079CD = 0x0010351A; // 004079CD
Eq_81 g_t4079D1 = // 004079D1
	{
		~0x0C
	};
ui32 g_dw4079D5 = 0x0010400D; // 004079D5
Eq_15 g_t4079D9 = // 004079D9
	{
		1072252
	};
word32 g_dw4079DD = 1078505; // 004079DD
ui32 g_dw4079E1 = 0x001047AA; // 004079E1
byte g_b4079E5 = ~0x45; // 004079E5
word32 g_dw4079E9 = 0x0010193E; // 004079E9
byte g_b4079ED = 133; // 004079ED
Eq_6 g_t4079F1 = // 004079F1
	{
		0x00104C67
	};
byte g_b4079F5 = 0x10; // 004079F5
ui32 g_dw4079F9 = 1079771; // 004079F9
Eq_2757 g_t4079FD = // 004079FD
	{
		0x14
	};
Eq_183 g_t407A01 = // 00407A01
	{
		0x001004C9
	};
ui32 g_dw407A05 = 0x001061FE; // 00407A05
word32 g_dw407A09 = 0x00103414; // 00407A09
word32 g_dw407A0D = 0x00107AA0; // 00407A0D
uint32 g_dw407A11 = 1065665; // 00407A11
ui16 g_w407A15 = 0x6083; // 00407A15
uint32 g_dw407A19 = 0x0010087D; // 00407A19
Eq_263 g_t407A1D = // 00407A1D
	{
		188
	};
ui32 g_dw407A21 = 1057700; // 00407A21
Eq_155 g_t407A29 = // 00407A29
	{
		0x00101831
	};
up32 g_dw407A2D = 0x0010136B; // 00407A2D
Eq_1457 g_t407A31 = // 00407A31
	{
		0x7E
	};
Eq_64 g_t407A35 = // 00407A35
	{
		113
	};
uint32 g_dw407A39 = 1065667; // 00407A39
ui32 g_dw407A3D = 0x0010643D; // 00407A3D
Eq_2997 g_t407A41 = // 00407A41
	{
		0x00105AAA
	};
word32 * g_ptr407B43 = &g_dw407945; // 00407B43
byte * g_ptr407B47 = &g_b407949; // 00407B47
union Eq_381 * g_ptr407B4F = &g_t407951; // 00407B4F
word32 * g_ptr407B5B = &g_dw40795D; // 00407B5B
word32 * g_ptr407B5F = &g_dw407961; // 00407B5F
ui32 * g_ptr407B67 = &g_dw407969; // 00407B67
ui32 * g_ptr407B6B = &g_dw40796D; // 00407B6B
byte * g_ptr407B6F = &g_b407971; // 00407B6F
word32 * g_ptr407B73 = &g_dw407975; // 00407B73
word32 * g_ptr407B77 = &g_dw407979; // 00407B77
word32 * g_ptr407B7B = &g_dw40797D; // 00407B7B
word32 * g_ptr407B8B = &g_dw40798D; // 00407B8B
word32 * g_ptr407B97 = &g_dw407999; // 00407B97
word32 * g_ptr407BB3 = &g_dw4079B5; // 00407BB3
up32 * g_ptr407BB7 = &g_dw4079B9; // 00407BB7
union Eq_2411 * g_ptr407BBF = &g_t4079C1; // 00407BBF
word32 * g_ptr407BC3 = &g_dw4079C5; // 00407BC3
union Eq_25 * g_ptr407BC7 = &g_t4079C9; // 00407BC7
byte * g_ptr407BCB = &g_b4079CD; // 00407BCB
union Eq_220 * g_ptr407BD3 = &g_t4079D5; // 00407BD3
byte * g_ptr407BDB = &g_b4079DD; // 00407BDB
ui32 * g_ptr407BDF = &g_dw4079E1; // 00407BDF
word32 * g_ptr407BE3 = &g_dw4079E5; // 00407BE3
word32 * g_ptr407BE7 = &g_dw4079E9; // 00407BE7
union Eq_51 * g_ptr407BEB = &g_t4079ED; // 00407BEB
ui32 * g_ptr407BEF = &g_dw4079F1; // 00407BEF
ui32 * g_ptr407C07 = &g_dw407A09; // 00407C07
union Eq_3021 * g_ptr407C0B = &g_t407A0D; // 00407C0B
union Eq_79 * g_ptr407C13 = &g_t407A15; // 00407C13
union Eq_314 * g_ptr407C1B = &g_t407A1D; // 00407C1B
ui32 * g_ptr407C1F = &g_dw407A21; // 00407C1F
union Eq_1598 * g_ptr407C27 = &g_t407A29; // 00407C27
union Eq_1457 * g_ptr407C2F = &g_t407A31; // 00407C2F
union Eq_64 * g_ptr407C33 = &g_t407A35; // 00407C33
ui32 * g_ptr407C3B = &g_dw407A3D; // 00407C3B
union Eq_2997 * g_ptr407C3F = &g_t407A41; // 00407C3F
WCHAR g_t407DBF = 'S'; // 00407DBF
WCHAR g_t407DCF = 'K'; // 00407DCF
WCHAR g_t407E19 = 'X'; // 00407E19
// subject_import.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40E08C = 57652; // 0040E08C
word32 g_dw40E090 = 0xE150; // 0040E090
word32 g_dw40E094 = 0xE166; // 0040E094
word32 g_dw40E09C = 0xE18E; // 0040E09C
word32 g_dw40E0A0 = 0xE1A0; // 0040E0A0
word32 g_dw40E0A8 = 57782; // 0040E0A8
word32 g_dw40E0AC = 57800; // 0040E0AC
word32 g_dw40E0B0 = 0xE1E0; // 0040E0B0
word32 g_dw40E0B4 = 0xE1F6; // 0040E0B4
word32 g_dw40E0B8 = 0xE20E; // 0040E0B8
word32 g_dw40E0C0 = 0xE226; // 0040E0C0
word32 g_dw40E0C4 = 0xE23C; // 0040E0C4
word32 g_dw40E0C8 = 0xE256; // 0040E0C8
word32 g_dw40E0CC = 57956; // 0040E0CC
word32 g_dw40E0D0 = 57976; // 0040E0D0
word32 g_dw40E0D4 = 57994; // 0040E0D4
word32 g_dw40E0D8 = 0xE2A0; // 0040E0D8
word32 g_dw40E0DC = 0xE2AE; // 0040E0DC
word32 g_dw40E0E0 = 58038; // 0040E0E0
word32 g_dw40E0E4 = 58052; // 0040E0E4
word32 g_dw40E0E8 = 0xE2DA; // 0040E0E8
word32 g_dw40E0F0 = 0xE2FA; // 0040E0F0
word32 g_dw40E0F4 = 0xE30A; // 0040E0F4
word32 g_dw40E0F8 = 58138; // 0040E0F8
word32 g_dw40E0FC = 58152; // 0040E0FC
word32 g_dw40E100 = 0xE338; // 0040E100
word32 g_dw40E104 = 58184; // 0040E104
word32 g_dw40E108 = 58198; // 0040E108
word32 g_dw40E10C = 0xE362; // 0040E10C
word32 g_dw40E110 = 0xE370; // 0040E110
word32 g_dw40E114 = 0xE380; // 0040E114
word32 g_dw40E118 = 58262; // 0040E118
word32 g_dw40E11C = 58284; // 0040E11C
word32 g_dw40E120 = 0xE3BE; // 0040E120
word32 g_dw40E128 = 58332; // 0040E128
word32 g_dw40E12C = 0xE3E6; // 0040E12C
