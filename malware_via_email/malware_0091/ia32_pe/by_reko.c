// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

void g_v10000000 = ??void??; // 10000000
byte g_b100001EF = 0xE0; // 100001EF
byte g_b10000217 = 0xE0; // 10000217
// subject_UPX0.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_10 g_t10001000 = // 10001000
	{
		0x00,
	};
// subject_UPX1.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_8 g_t10006000 = // 10006000
	{
		~0x12
	};
// 10009990: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	word32 * fp;
	word32 ecx;
	word32 edx;
	DWORD ebp;
	struct Eq_7 * es;
	union Eq_8 * esi_20730 = &g_t10006000;
	struct Eq_10 * edi_20832 = &g_t10001000;
	ebp_20724 = ebp;
	while (true)
	{
		Eq_2 ebp_20724;
		esi_20730 -= ~0x03;
		uint32 ebx_20726 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
		bool v10278_20918 = ebx_20726 < 0x00;
		do
		{
			if (!v10278_20918)
			{
				Eq_38 eax_49 = 0x01;
				do
				{
					do
					{
						uint32 ebx_60;
						uint32 ebx_51 = ebx_20726 * 0x02;
						ebx_60 = ebx_51;
						if (ebx_51 == 0x00)
						{
							esi_20730 -= ~0x03;
							ebx_60 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
						}
						eax_49 = eax_49 * 0x02 + (word32) (ebx_51 < 0x00);
						ebx_20726 = ebx_60 * 0x02;
					} while (ebx_20726 >= 0x00);
					if (ebx_20726 != 0x00)
						break;
					esi_20730 -= ~0x03;
					ebx_20726 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
				} while (ebx_20726 >= 0x00);
				if (eax_49 >= 0x03)
				{
					esi_20730 = (union Eq_8 *) ((char *) esi_20730 + 1);
					Eq_2 eax_94 = ~SEQ(eax_49 - 0x03, esi_20730->u0);
					if (eax_94 == 0x00)
					{
						VirtualProtect(&g_v10000000, 0x1000, 0x04, fp - 36);
						g_b100001EF &= 0x7F;
						g_b10000217 &= 0x7F;
						VirtualProtect(&g_v10000000, 0x1000, eax_94, fp - 36);
						uint16 dx_20898 = (word16) edx;
						word32 * esp_177 = fp;
						ci8 * eax_178 = fp - 0x80;
						do
						{
							esp_177 -= 4;
							*esp_177 = 0x00;
						} while (esp_177 != fp - 0x80);
						do
						{
							ci8 v10262_20670 = *eax_178 + (byte) eax_178;
							*eax_178 = v10262_20670;
							eax_178 = __in<word32>(dx_20898);
						} while (v10262_20670 > 0x00);
						struct Eq_182 * esp_20693;
						word32 eax_20694;
						word32 edx_20696;
						(*((word32) ebp - 117))();
						byte al_20700 = __in<byte>((word16) edx_20696);
						*((word32) ebp - 8) = (Eq_2) 0x6000;
						esp_20693->ptrFFFFFFEA = es;
						byte * eax_20713 = SEQ(SLICE(eax_20694, word24, 8), al_20700);
						*eax_20713 += SLICE(eax_20694, byte, 8);
						*eax_20713 += (byte) edx_20696;
						*((word32) ebp - 16) = (Eq_2) 0xC5;
					}
					ebp_20724 = eax_94;
				}
				ui32 ebx_20727 = ebx_20726 * 0x02;
				bool C_20740 = SLICE(cond(ebx_20727), bool, 1);
				if (ebx_20727 == 0x00)
				{
					esi_20730 -= ~0x03;
					ebx_20727 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
					C_20740 = SLICE(cond(ebx_20727), bool, 1);
				}
				ui32 ecx_20743 = (word32) C_20740;
				uint32 ebx_20745 = ebx_20727 * 0x02;
				ebx_20726 = ebx_20745;
				if (ebx_20745 == 0x00)
				{
					esi_20730 -= ~0x03;
					ebx_20726 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
				}
				ui32 ecx_20760 = ecx_20743 * 0x02 + (word32) (ebx_20745 < 0x00);
				if (ecx_20760 == 0x00)
				{
					ui32 ecx_20763 = ecx_20760 + 0x01;
					do
					{
						do
						{
							uint32 ebx_20775;
							uint32 ebx_20766 = ebx_20726 * 0x02;
							ebx_20775 = ebx_20766;
							if (ebx_20766 == 0x00)
							{
								esi_20730 -= ~0x03;
								ebx_20775 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
							}
							ecx_20763 = ecx_20763 * 0x02 + (word32) (ebx_20766 < 0x00);
							ebx_20726 = ebx_20775 * 0x02;
						} while (ebx_20726 >= 0x00);
						if (ebx_20726 != 0x00)
							break;
						esi_20730 -= ~0x03;
						ebx_20726 = esi_20730->u1 * 0x02 + (word32) (esi_20730 < null);
					} while (ebx_20726 >= 0x00);
					ecx_20760 = ecx_20763 + 0x02;
				}
				Eq_243 ecx_20814 = ecx_20760 + 0x01 + (word32) (ebp_20724 < ~0x0CFF);
				word32 edx_20825 = edi_20832 + ebp_20724;
				if (ebp_20724 > ~0x03)
				{
					do
					{
						edi_20832->b0000 = (byte) edx_20825->dw0000;
						++edx_20825;
						edi_20832 = &edi_20832->b0000 + 1;
						--ecx_20814;
					} while (ecx_20814 != 0x00);
				}
				else
				{
					do
					{
						edi_20832->b0000 = (byte) edx_20825->dw0000;
						edx_20825 += 4;
						++edi_20832;
						ecx_20814 -= 0x04;
					} while (ecx_20814 > 0x00);
					edi_20832 += ecx_20814;
				}
			}
			else
			{
				edi_20832->b0000 = esi_20730->u0;
				esi_20730 = (union Eq_8 *) ((char *) esi_20730 + 1);
				edi_20832 = &edi_20832->b0000 + 1;
			}
			ebx_20726 *= 0x02;
			v10278_20918 = ebx_20726 < 0x00;
		} while (ebx_20726 != 0x00);
	}
}

// subject_UPX2.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw1000A028 = 0xA050; // 1000A028
word32 g_dw1000A02C = 0xA05E; // 1000A02C
word32 g_dw1000A030 = 0xA06E; // 1000A030
word32 g_dw1000A034 = 0xA07E; // 1000A034
word32 g_dw1000A038 = 41100; // 1000A038
word32 g_dw1000A03C = 41114; // 1000A03C
