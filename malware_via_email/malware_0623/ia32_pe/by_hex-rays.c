/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// unsigned __int8 __usercall start@<al>(int a1@<ecx>, __int16 a2@<bp>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_4003CD@<al>(char a1@<cf>, int a2@<eax>, int a3@<ecx>, int _EBX@<ebx>, __int16 _BP@<bp>, int a6@<edi>, int a7@<esi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40031F; // weak
__int16 word_400542 = -32678; // weak
int dword_400704 = 165; // weak


//----- (00400300) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned __int8 __usercall start@<al>(int a1@<ecx>, __int16 a2@<bp>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax
  _BYTE *i; // ebx

  v4 = dword_400704;
  for ( i = (char *)&word_400542 + 47; i >= (_BYTE *)&loc_40031F; --i )
    *i += v4;
  sub_4003CD(i < (_BYTE *)&loc_40031F, v4, a1, (int)i, a2, a3, a4);
  MEMORY[0x9BA25EA5]();
  return __inbyte(0x5Eu);
}
// 400333: positive sp value 14 has been found
// 400300: could not find valid save-restore pair for ebx
// 400542: using guessed type __int16 word_400542;
// 400704: using guessed type int dword_400704;

//----- (004003CD) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_4003CD@<al>(char a1@<cf>, int a2@<eax>, int a3@<ecx>, int _EBX@<ebx>, __int16 _BP@<bp>, int a6@<edi>, int a7@<esi>)
{
  int v7; // et0
  int v8; // ecx
  unsigned __int32 v9; // eax
  char v11; // cc
  unsigned __int16 v12; // dx
  char v14; // t2
  unsigned __int32 v15; // eax
  int v16; // ecx
  int v17; // ebx
  _BYTE *v22; // [esp-58h] [ebp-5Ch]
  __int16 v23; // [esp-54h] [ebp-58h]
  unsigned __int16 v24; // [esp-50h] [ebp-54h]
  int v25; // [esp-44h] [ebp-48h]
  int v26; // [esp-2Ch] [ebp-30h]
  int v27; // [esp-28h] [ebp-2Ch]
  int v28; // [esp-4h] [ebp-8h]
  unsigned int v29; // [esp+0h] [ebp-4h]

  LOBYTE(a2) = -26;
  _EDI = a6 + 1;
  __asm { bound   ebx, [bp+di-54A5h] }
  v11 = (*(_DWORD *)(_EDI + 91) + a1 + _EBX < 0) ^ (__OFADD__(a1, _EBX) | __OFADD__(*(_DWORD *)(_EDI + 91), a1 + _EBX)) | (*(_DWORD *)(_EDI + 91) + a1 + _EBX == 0);
  *v22 = BYTE1(v22);
  if ( a3 != 1 )
  {
    __DS__ = v23;
    v7 = a2;
    __outbyte(0x4Bu, _BP);
    MEMORY[0x9BA28F28]();
    __FS__ = *(_WORD *)(a7 + 4 * v8);
    v9 = __indword(0x77u);
    *(_WORD *)(v7 + 54) = __FS__;
    __asm { iret }
    JUMPOUT(0x4003A1);
  }
  if ( !v11 )
  {
    v12 = v24;
    LOBYTE(a2) = MEMORY[0x431BE657];
    __asm { into }
    _EBX = v25;
    v14 = MEMORY[0x431BE657];
    __outbyte(0xA3u, _EDI);
    __outbyte(0xD8u, _EDI);
    ++_EBX;
    __asm { rcr     byte ptr [ebx+5Bh], 5Bh }
    *(_DWORD *)(a2 + 4) = _EDI;
    __asm { icebp }
    LOBYTE(_EBX) = 67;
    __asm { rcr     dword ptr [ebx+5Bh], 1 }
    *(_DWORD *)(a2 + 8) = _EDI;
    v15 = __indword(v12);
    __outbyte(0xD5u, v14 + 12);
    v16 = v26;
    v17 = v27;
    LOBYTE(v15) = __inbyte(0xD8u);
    _EAX = MEMORY[0x9B265C61](v16, v17);
    __asm { aad     67h ; 'g' }
    _ESI = v28;
    __writeeflags(v29);
    __asm { outsd }
    __outbyte(0xA5u, _EAX);
    __asm { iret }
    JUMPOUT(0x40049C);
  }
  MEMORY[0x77E45F7F] = a2;
  return a2;
}
// 400493: positive sp value 58 has been found
// 40049B: control flows out of bounds to 40049C
// 4003A0: control flows out of bounds to 4003A1
// 4003DE: variable 'v22' is possibly undefined
// 400444: variable 'v24' is possibly undefined
// 40044F: variable 'v25' is possibly undefined
// 400473: variable 'v26' is possibly undefined
// 400473: variable 'v27' is possibly undefined
// 400491: variable 'v28' is possibly undefined
// 400492: variable 'v29' is possibly undefined
// 400381: variable 'v23' is possibly undefined
// 400391: variable 'v8' is possibly undefined

// nfuncs=2 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
// ALL OK, 2 function(s) have been successfully decompiled
