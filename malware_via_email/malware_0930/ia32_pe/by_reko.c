// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t10590; // 00410000
<anonymous> * __imp__VirtualAlloc = &g_t105A2; // 00410004
<anonymous> * __imp__VirtualProtect = &g_t105B2; // 00410008
<anonymous> * __imp__GetCurrentThreadId = &g_t105C4; // 0041000C
<anonymous> * __imp__DeleteCriticalSection = &g_t105DA; // 00410010
<anonymous> * __imp__GetModuleFileNameA = &g_t105F2; // 00410014
<anonymous> * __imp__EnterCriticalSection = &g_t10608; // 00410018
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t10620; // 0041001C
<anonymous> * __imp__GetCurrentThreadId = &g_t1063A; // 00410020
<anonymous> * __imp__LocalAlloc = &g_t10650; // 00410024
<anonymous> * __imp__SetLastError = &g_t1065E; // 00410028
<anonymous> * __imp__InterlockedDecrement = &g_t1066E; // 0041002C
<anonymous> * __imp__LeaveCriticalSection = &g_t10686; // 00410030
<anonymous> * __imp__UnhandledExceptionFilter = &g_t1069E; // 00410034
<anonymous> * __imp__GetTickCount = &g_t106BA; // 00410038
<anonymous> * __imp__FreeLibrary = &g_t106CA; // 0041003C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t106D8; // 00410040
<anonymous> * __imp__GetProcessHeap = &g_t106F2; // 00410044
<anonymous> * __imp__SetLastError = &g_t10704; // 00410048
<anonymous> * __imp__VirtualProtect = &g_t10714; // 0041004C
<anonymous> * __imp__Sleep = &g_t10726; // 00410050
<anonymous> * __imp__GetProcessHeap = &g_t1072E; // 00410054
<anonymous> * __imp__HeapDestroy = &g_t10740; // 00410058
<anonymous> * __imp__SetLastError = &g_t1074E; // 0041005C
<anonymous> * __imp__FreeLibrary = &g_t1075E; // 00410060
<anonymous> * __imp__GetModuleHandleA = &g_t1076C; // 00410064
<anonymous> * __imp__InterlockedDecrement = &g_t10780; // 00410068
<anonymous> * __imp__HeapDestroy = &g_t10798; // 0041006C
<anonymous> * __imp__InterlockedIncrement = &g_t107A6; // 00410070
<anonymous> * __imp__lstrlenA = &g_t107BE; // 00410074
<anonymous> * __imp__LeaveCriticalSection = &g_t107CA; // 00410078
<anonymous> * __imp__GetModuleFileNameW = &g_t107E2; // 0041007C
<anonymous> * __imp__GetCurrentProcess = &g_t107F8; // 00410080
<anonymous> * __imp__CreateEventW = &g_t1080C; // 00410084
<anonymous> * __imp__LeaveCriticalSection = &g_t1081C; // 00410088
<anonymous> * __imp__EnterCriticalSection = &g_t10834; // 0041008C
<anonymous> * __imp__GetModuleHandleA = &g_t1084C; // 00410090
<anonymous> * __imp__HeapAlloc = &g_t10860; // 00410094
<anonymous> * __imp__EnterCriticalSection = &g_t1086C; // 00410098
<anonymous> * __imp__EnterCriticalSection = &g_t10884; // 0041009C
<anonymous> * __imp__ReadFile = &g_t1089C; // 004100A0
<anonymous> * __imp__GetModuleHandleW = &g_t108A8; // 004100A4
<anonymous> * __imp__lstrcmpiW = &g_t108BC; // 004100A8
<anonymous> * __imp__VirtualProtect = &g_t108C8; // 004100AC
<anonymous> * __imp__HeapDestroy = &g_t108DA; // 004100B0
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t108E8; // 004100B4
<anonymous> * __imp__Sleep = &g_t10904; // 004100B8
<anonymous> * __imp__SetLastError = &g_t1090C; // 004100BC
<anonymous> * __imp__GetProcAddress = &g_t1091C; // 004100C0
<anonymous> * __imp__lstrlenA = &g_t1092E; // 004100C4
<anonymous> * __imp__GetLastError = &g_t1093A; // 004100C8
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t1094A; // 004100CC
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t10964; // 004100D0
<anonymous> * __imp__EnterCriticalSection = &g_t1097E; // 004100D4
<anonymous> * __imp__GetCurrentProcess = &g_t10996; // 004100D8
<anonymous> * __imp__LocalAlloc = &g_t109AA; // 004100DC
<anonymous> * __imp__LocalFree = &g_t109B8; // 004100E0
<anonymous> * __imp__GetModuleHandleW = &g_t109C4; // 004100E4
<anonymous> * __imp__CreateEventW = &g_t109D8; // 004100E8
<anonymous> * __imp__InitializeCriticalSection = &g_t109E8; // 004100EC
<anonymous> * __imp__InterlockedExchange = &g_t10A04; // 004100F0
<anonymous> * __imp__VirtualProtect = &g_t10A1A; // 004100F4
<anonymous> * __imp__CreateFileW = &g_t10A2C; // 004100F8
<anonymous> * __imp__HeapFree = &g_t10A3A; // 004100FC
<anonymous> * __imp__MultiByteToWideChar = &g_t10A46; // 00410100
<anonymous> * __imp__Sleep = &g_t10A5C; // 00410104
<anonymous> * __imp__GetLastError = &g_t10A64; // 00410108
<anonymous> * __imp__UnhandledExceptionFilter = &g_t10A74; // 0041010C
<anonymous> * __imp__InterlockedIncrement = &g_t10A90; // 00410110
<anonymous> * __imp__HeapAlloc = &g_t10AA8; // 00410114
<anonymous> * __imp__GetModuleHandleW = &g_t10AB4; // 00410118
<anonymous> * __imp__VirtualAlloc = &g_t10AC8; // 0041011C
<anonymous> * __imp__GetProcessHeap = &g_t10AD8; // 00410120
<anonymous> * __imp__GetLastError = &g_t10AEA; // 00410124
<anonymous> * __imp__LeaveCriticalSection = &g_t10AFA; // 00410128
<anonymous> * __imp__CloseHandle = &g_t10B12; // 0041012C
<anonymous> * __imp__GetModuleHandleA = &g_t10B20; // 00410130
<anonymous> * __imp__GetModuleHandleW = &g_t10B34; // 00410134
<anonymous> * __imp__lstrlenA = &g_t10B48; // 00410138
<anonymous> * __imp__DeleteCriticalSection = &g_t10B54; // 0041013C
<anonymous> * __imp__SetLastError = &g_t10B6C; // 00410140
<anonymous> * __imp__GetModuleHandleA = &g_t10B7C; // 00410144
<anonymous> * __imp__VirtualProtect = &g_t10B90; // 00410148
<anonymous> * __imp__InterlockedExchange = &g_t10BA2; // 0041014C
<anonymous> * __imp__InvalidateRect = &g_t10BC6; // 00410154
<anonymous> * __imp__BeginPaint = &g_t10BD8; // 00410158
<anonymous> * __imp__GetFocus = &g_t10BE6; // 0041015C
<anonymous> * __imp__DestroyWindow = &g_t10BF2; // 00410160
<anonymous> * __imp__GetDC = &g_t10C02; // 00410164
<anonymous> * __imp__PostMessageW = &g_t10C0A; // 00410168
<anonymous> * __imp__SetForegroundWindow = &g_t10C1A; // 0041016C
<anonymous> * __imp__CreateWindowExW = &g_t10C30; // 00410170
<anonymous> * __imp__GetDlgItem = &g_t10C42; // 00410174
<anonymous> * __imp__BeginPaint = &g_t10C50; // 00410178
<anonymous> * __imp__GetDC = &g_t10C5E; // 0041017C
<anonymous> * __imp__PeekMessageW = &g_t10C66; // 00410180
<anonymous> * __imp__GetFocus = &g_t10C76; // 00410184
<anonymous> * __imp__SetTimer = &g_t10C82; // 00410188
<anonymous> * __imp__IsWindow = &g_t10C8E; // 0041018C
<anonymous> * __imp__GetSysColor = &g_t10C9A; // 00410190
<anonymous> * __imp__GetSystemMetrics = &g_t10CA8; // 00410194
<anonymous> * __imp__EndPaint = &g_t10CBC; // 00410198
<anonymous> * __imp__PostMessageW = &g_t10CC8; // 0041019C
<anonymous> * __imp__DialogBoxParamW = &g_t10CD8; // 004101A0
<anonymous> * __imp__PeekMessageW = &g_t10CEA; // 004101A4
<anonymous> * __imp__GetDesktopWindow = &g_t10CFA; // 004101A8
<anonymous> * __imp__ShowWindow = &g_t10D0E; // 004101AC
<anonymous> * __imp__GetWindowLongW = &g_t10D1C; // 004101B0
<anonymous> * __imp__wsprintfA = &g_t10D2E; // 004101B4
<anonymous> * __imp__IsWindow = &g_t10D3A; // 004101B8
<anonymous> * __imp__wsprintfA = &g_t10D46; // 004101BC
<anonymous> * __imp__GetWindowLongW = &g_t10D52; // 004101C0
<anonymous> * __imp__DefWindowProcW = &g_t10D64; // 004101C4
<anonymous> * __imp__BeginPaint = &g_t10D76; // 004101C8
<anonymous> * __imp__LoadIconW = &g_t10D84; // 004101CC
<anonymous> * __imp__GetSysColor = &g_t10D90; // 004101D0
<anonymous> * __imp__GetWindowRect = &g_t10D9E; // 004101D4
<anonymous> * __imp__GetWindowRect = &g_t10DAE; // 004101D8
<anonymous> * __imp__ShowWindow = &g_t10DBE; // 004101DC
<anonymous> * __imp__SetDlgItemTextW = &g_t10DCC; // 004101E0
<anonymous> * __imp__BeginPaint = &g_t10DDE; // 004101E4
<anonymous> * __imp__BeginPaint = &g_t10DEC; // 004101E8
<anonymous> * __imp__DispatchMessageW = &g_t10DFA; // 004101EC
<anonymous> * __imp__SendDlgItemMessageW = &g_t10E0E; // 004101F0
<anonymous> * __imp__SetCursor = &g_t10E24; // 004101F4
<anonymous> * __imp__DialogBoxParamW = &g_t10E30; // 004101F8
<anonymous> * __imp__TranslateMessage = &g_t10E42; // 004101FC
<anonymous> * __imp__IsWindow = &g_t10E56; // 00410200
<anonymous> * __imp__PostQuitMessage = &g_t10E62; // 00410204
<anonymous> * __imp__LoadStringW = &g_t10E74; // 00410208
<anonymous> * __imp__DispatchMessageW = &g_t10E82; // 0041020C
<anonymous> * __imp__GetWindowRect = &g_t10E96; // 00410210
<anonymous> * __imp__LoadIconW = &g_t10EA6; // 00410214
<anonymous> * __imp__wsprintfA = &g_t10EB2; // 00410218
<anonymous> * __imp__SendDlgItemMessageW = &g_t10EBE; // 0041021C
<anonymous> * __imp__SetWindowLongW = &g_t10ED4; // 00410220
<anonymous> * __imp__EnableWindow = &g_t10EE6; // 00410224
<anonymous> * __imp__CharNextW = &g_t10EF6; // 00410228
<anonymous> * __imp__PostQuitMessage = &g_t10F02; // 0041022C
<anonymous> * __imp__CreateWindowExW = &g_t10F14; // 00410230
<anonymous> * __imp__MessageBoxW = &g_t10F26; // 00410234
<anonymous> * __imp__EnableWindow = &g_t10F34; // 00410238
<anonymous> * __imp__ShowWindow = &g_t10F44; // 0041023C
<anonymous> * __imp__SendMessageW = &g_t10F52; // 00410240
<anonymous> * __imp__LoadIconW = &g_t10F62; // 00410244
<anonymous> * __imp__CharNextW = &g_t10F6E; // 00410248
<anonymous> * __imp__GetParent = &g_t10F7A; // 0041024C
<anonymous> * __imp__SetForegroundWindow = &g_t10F86; // 00410250
<anonymous> * __imp__EndDialog = &g_t10F9C; // 00410254
<anonymous> * __imp__TranslateMessage = &g_t10FA8; // 00410258
<anonymous> * __imp__EndDialog = &g_t10FBC; // 0041025C
<anonymous> * __imp__SetWindowLongW = &g_t10FC8; // 00410260
<anonymous> * __imp__InvalidateRect = &g_t10FDA; // 00410264
<anonymous> * __imp__DefWindowProcW = &g_t10FEC; // 00410268
<anonymous> * __imp__GetDC = &g_t10FFE; // 0041026C
<anonymous> * __imp__SetDlgItemTextW = &g_t11006; // 00410270
<anonymous> * __imp__SetForegroundWindow = &g_t11018; // 00410274
<anonymous> * __imp__IsWindow = &g_t1102E; // 00410278
<anonymous> * __imp__CharNextW = &g_t1103A; // 0041027C
<anonymous> * __imp__GetFocus = &g_t11046; // 00410280
<anonymous> * __imp__IsDlgButtonChecked = &g_t11052; // 00410284
<anonymous> * __imp__GetClientRect = &g_t11068; // 00410288
<anonymous> * __imp__GetClientRect = &g_t11078; // 0041028C
<anonymous> * __imp__PostMessageW = &g_t11088; // 00410290
<anonymous> * __imp__KillTimer = &g_t11098; // 00410294
<anonymous> * __imp__LoadCursorW = &g_t110A4; // 00410298
<anonymous> * __imp__LoadStringW = &g_t110B2; // 0041029C
<anonymous> * __imp__GetDesktopWindow = &g_t110C0; // 004102A0
word32 g_dw4102E8 = 66960; // 004102E8
word32 g_dw4102EC = 66978; // 004102EC
word32 g_dw4102F0 = 66994; // 004102F0
word32 g_dw4102F4 = 0x000105C4; // 004102F4
word32 g_dw4102F8 = 0x000105DA; // 004102F8
word32 g_dw4102FC = 0x000105F2; // 004102FC
word32 g_dw410300 = 0x00010608; // 00410300
word32 g_dw410304 = 0x00010620; // 00410304
word32 g_dw410308 = 0x0001063A; // 00410308
word32 g_dw41030C = 0x00010650; // 0041030C
word32 g_dw410310 = 67166; // 00410310
word32 g_dw410314 = 0x0001066E; // 00410314
word32 g_dw410318 = 0x00010686; // 00410318
word32 g_dw41031C = 0x0001069E; // 0041031C
word32 g_dw410320 = 0x000106BA; // 00410320
word32 g_dw410324 = 67274; // 00410324
word32 g_dw410328 = 67288; // 00410328
word32 g_dw41032C = 0x000106F2; // 0041032C
word32 g_dw410330 = 0x00010704; // 00410330
word32 g_dw410334 = 0x00010714; // 00410334
word32 g_dw410338 = 67366; // 00410338
word32 g_dw41033C = 67374; // 0041033C
word32 g_dw410340 = 0x00010740; // 00410340
word32 g_dw410344 = 67406; // 00410344
word32 g_dw410348 = 67422; // 00410348
word32 g_dw41034C = 67436; // 0041034C
word32 g_dw410350 = 0x00010780; // 00410350
word32 g_dw410354 = 0x00010798; // 00410354
word32 g_dw410358 = 67494; // 00410358
word32 g_dw41035C = 0x000107BE; // 0041035C
word32 g_dw410360 = 0x000107CA; // 00410360
word32 g_dw410364 = 67554; // 00410364
word32 g_dw410368 = 67576; // 00410368
word32 g_dw41036C = 0x0001080C; // 0041036C
word32 g_dw410370 = 0x0001081C; // 00410370
word32 g_dw410374 = 67636; // 00410374
word32 g_dw410378 = 67660; // 00410378
word32 g_dw41037C = 0x00010860; // 0041037C
word32 g_dw410380 = 67692; // 00410380
word32 g_dw410384 = 67716; // 00410384
word32 g_dw410388 = 67740; // 00410388
word32 g_dw41038C = 0x000108A8; // 0041038C
word32 g_dw410390 = 67772; // 00410390
word32 g_dw410394 = 0x000108C8; // 00410394
word32 g_dw410398 = 0x000108DA; // 00410398
word32 g_dw41039C = 0x000108E8; // 0041039C
word32 g_dw4103A0 = 0x00010904; // 004103A0
word32 g_dw4103A4 = 0x0001090C; // 004103A4
word32 g_dw4103A8 = 67868; // 004103A8
word32 g_dw4103AC = 67886; // 004103AC
word32 g_dw4103B0 = 67898; // 004103B0
word32 g_dw4103B4 = 0x0001094A; // 004103B4
word32 g_dw4103B8 = 0x00010964; // 004103B8
word32 g_dw4103BC = 67966; // 004103BC
word32 g_dw4103C0 = 0x00010996; // 004103C0
word32 g_dw4103C4 = 0x000109AA; // 004103C4
word32 g_dw4103C8 = 0x000109B8; // 004103C8
word32 g_dw4103CC = 68036; // 004103CC
word32 g_dw4103D0 = 68056; // 004103D0
word32 g_dw4103D4 = 0x000109E8; // 004103D4
word32 g_dw4103D8 = 0x00010A04; // 004103D8
word32 g_dw4103DC = 0x00010A1A; // 004103DC
word32 g_dw4103E0 = 0x00010A2C; // 004103E0
word32 g_dw4103E4 = 0x00010A3A; // 004103E4
word32 g_dw4103E8 = 68166; // 004103E8
word32 g_dw4103EC = 68188; // 004103EC
word32 g_dw4103F0 = 68196; // 004103F0
word32 g_dw4103F4 = 68212; // 004103F4
word32 g_dw4103F8 = 0x00010A90; // 004103F8
word32 g_dw4103FC = 0x00010AA8; // 004103FC
word32 g_dw410400 = 68276; // 00410400
word32 g_dw410404 = 68296; // 00410404
word32 g_dw410408 = 0x00010AD8; // 00410408
word32 g_dw41040C = 0x00010AEA; // 0041040C
word32 g_dw410410 = 0x00010AFA; // 00410410
word32 g_dw410414 = 0x00010B12; // 00410414
word32 g_dw410418 = 0x00010B20; // 00410418
word32 g_dw41041C = 68404; // 0041041C
word32 g_dw410420 = 68424; // 00410420
word32 g_dw410424 = 68436; // 00410424
word32 g_dw410428 = 68460; // 00410428
word32 g_dw41042C = 68476; // 0041042C
word32 g_dw410430 = 0x00010B90; // 00410430
word32 g_dw410434 = 0x00010BA2; // 00410434
word32 g_dw41043C = 68550; // 0041043C
word32 g_dw410440 = 68568; // 00410440
word32 g_dw410444 = 68582; // 00410444
word32 g_dw410448 = 0x00010BF2; // 00410448
word32 g_dw41044C = 0x00010C02; // 0041044C
word32 g_dw410450 = 68618; // 00410450
word32 g_dw410454 = 0x00010C1A; // 00410454
word32 g_dw410458 = 68656; // 00410458
word32 g_dw41045C = 68674; // 0041045C
word32 g_dw410460 = 68688; // 00410460
word32 g_dw410464 = 0x00010C5E; // 00410464
word32 g_dw410468 = 0x00010C66; // 00410468
word32 g_dw41046C = 68726; // 0041046C
word32 g_dw410470 = 68738; // 00410470
word32 g_dw410474 = 0x00010C8E; // 00410474
word32 g_dw410478 = 68762; // 00410478
word32 g_dw41047C = 68776; // 0041047C
word32 g_dw410480 = 0x00010CBC; // 00410480
word32 g_dw410484 = 68808; // 00410484
word32 g_dw410488 = 68824; // 00410488
word32 g_dw41048C = 68842; // 0041048C
word32 g_dw410490 = 68858; // 00410490
word32 g_dw410494 = 68878; // 00410494
word32 g_dw410498 = 0x00010D1C; // 00410498
word32 g_dw41049C = 0x00010D2E; // 0041049C
word32 g_dw4104A0 = 68922; // 004104A0
word32 g_dw4104A4 = 0x00010D46; // 004104A4
word32 g_dw4104A8 = 68946; // 004104A8
word32 g_dw4104AC = 68964; // 004104AC
word32 g_dw4104B0 = 68982; // 004104B0
word32 g_dw4104B4 = 68996; // 004104B4
word32 g_dw4104B8 = 0x00010D90; // 004104B8
word32 g_dw4104BC = 69022; // 004104BC
word32 g_dw4104C0 = 0x00010DAE; // 004104C0
word32 g_dw4104C4 = 0x00010DBE; // 004104C4
word32 g_dw4104C8 = 0x00010DCC; // 004104C8
word32 g_dw4104CC = 0x00010DDE; // 004104CC
word32 g_dw4104D0 = 69100; // 004104D0
word32 g_dw4104D4 = 69114; // 004104D4
word32 g_dw4104D8 = 0x00010E0E; // 004104D8
word32 g_dw4104DC = 69156; // 004104DC
word32 g_dw4104E0 = 0x00010E30; // 004104E0
word32 g_dw4104E4 = 69186; // 004104E4
word32 g_dw4104E8 = 69206; // 004104E8
word32 g_dw4104EC = 0x00010E62; // 004104EC
word32 g_dw4104F0 = 69236; // 004104F0
word32 g_dw4104F4 = 0x00010E82; // 004104F4
word32 g_dw4104F8 = 0x00010E96; // 004104F8
word32 g_dw4104FC = 69286; // 004104FC
word32 g_dw410500 = 69298; // 00410500
word32 g_dw410504 = 0x00010EBE; // 00410504
word32 g_dw410508 = 69332; // 00410508
word32 g_dw41050C = 0x00010EE6; // 0041050C
word32 g_dw410510 = 69366; // 00410510
word32 g_dw410514 = 0x00010F02; // 00410514
word32 g_dw410518 = 69396; // 00410518
word32 g_dw41051C = 69414; // 0041051C
word32 g_dw410520 = 0x00010F34; // 00410520
word32 g_dw410524 = 69444; // 00410524
word32 g_dw410528 = 0x00010F52; // 00410528
word32 g_dw41052C = 69474; // 0041052C
word32 g_dw410530 = 69486; // 00410530
word32 g_dw410534 = 69498; // 00410534
word32 g_dw410538 = 0x00010F86; // 00410538
word32 g_dw41053C = 0x00010F9C; // 0041053C
word32 g_dw410540 = 69544; // 00410540
word32 g_dw410544 = 69564; // 00410544
word32 g_dw410548 = 69576; // 00410548
word32 g_dw41054C = 69594; // 0041054C
word32 g_dw410550 = 69612; // 00410550
word32 g_dw410554 = 0x00010FFE; // 00410554
word32 g_dw410558 = 0x00011006; // 00410558
word32 g_dw41055C = 0x00011018; // 0041055C
word32 g_dw410560 = 0x0001102E; // 00410560
word32 g_dw410564 = 69690; // 00410564
word32 g_dw410568 = 0x00011046; // 00410568
word32 g_dw41056C = 0x00011052; // 0041056C
word32 g_dw410570 = 0x00011068; // 00410570
word32 g_dw410574 = 0x00011078; // 00410574
word32 g_dw410578 = 0x00011088; // 00410578
word32 g_dw41057C = 0x00011098; // 0041057C
word32 g_dw410580 = 69796; // 00410580
word32 g_dw410584 = 0x000110B2; // 00410584
word32 g_dw410588 = 0x000110C0; // 00410588
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00406975: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
	dh >>= 0x0C;
	bh = bh ^ ch;
	bl >>= cl;
	eax -= 3019161640;
	ecx = ecx ^ 0x110C2301;
	edx = edx ^ esi;
	dh = dh ^ al;
	C.u0 = false;
	si = ~si;
	ah.u0 = 0xA3;
	v21 = (dh & 0x01 << cl) != 0x00;
	dh = __rcr<byte,byte>(dh, cl, C);
	dl |= 0x89;
	eax >>= 0x0D;
	cx >>= cl;
	esi &= eax;
	SZ = cond(esi);
	O = false;
	C.u0 = false;
	ah = ah + bh + C;
	edx <<= 0x04;
	SCZO = cond(edx);
	do
	{
		dh = dh - 0x6A - C;
		edi <<= 22;
		ch >>= cl;
		al |= ~0x28;
		C.u0 = false;
		v25 = (al & 0x01 << cl) != 0x00;
		al = __rcr<byte,byte>(al, cl, C);
		C = v25;
		ch.u0 = 0x3E;
		&ah.u2->t0000.u0 = (byte) ah + 1;
		SZO = cond(ah);
		&ecx.u1->b0000 = (bool) C.u0 + ((word32) ecx - 0x7FDE5885);
		edi &= esi;
		bl -= 118;
		SCZO = cond(bl);
		v27 = (ecx & 0x01 << 0x20 - 0x01) != 0x00;
		ecx = __rcl<word32,byte>(ecx, 0x01, C);
		v28 = (bl & 0x01 << cl) != 0x00;
		bl = __ror<byte,byte>(bl, cl);
		v29 = (edx & 0x01 << 0x0E) != 0x00;
		edx = __ror<word32,byte>(edx, 0x0E);
		dh &= bh;
		C.u0 = false;
		ecx = ecx - 0x01E80A8A - C;
		v30 = (ecx & 0x01 << 0x20 - 0x02) != 0x00;
		ecx = __rol<word32,byte>(ecx, 0x02);
		C = v30;
		dl = dl - 77 - C;
		SCZO = cond(dl);
		di = ~di;
		v32 = (al & 0x01 << 0x09) != 0x00;
		al = __rcr<byte,byte>(al, 0x09, C);
		di = di ^ si;
		SCZO = cond(eax - 527010806);
		if (Test(EQ,Z))
		{
			edi &= ebp.u2->dwB3F0F233;
			SZ = cond(edi);
			O = false;
			C.u0 = false;
			goto l0040650B;
		}
		while (true)
		{
			bl |= 11;
			ch <<= cl;
			SCZO = cond(ch);
			v42 = (edi & 0x01 << cl) != 0x00;
			edi = __rcr<word32,byte>(edi, cl, C);
			SCZO = cond(edx - 0xB208AC08);
			v43 = (ecx & 0x01 << 0x14) != 0x00;
			ecx = __rcr<word32,byte>(ecx, 0x14, C);
			bx = bx ^ ax;
			ebx <<= 0x07;
			bh |= dh;
			C.u0 = false;
			edx = edx - 2449892827 - C;
			SCZO = cond(edx);
			ah <<= 0x1B;
			cl -= bl;
			bx = ax;
			SZP = cond(cl & ah);
			C.u0 = false;
			v46 = (ecx & 0x01 << 0x20 - 0x01) != 0x00;
			ecx = __rcl<word32,byte>(ecx, 0x01, C);
			ch = cl;
			v47 = (cl & 0x01 << 0x08 - 0x02) != 0x00;
			cl = __rol<byte,byte>(cl, 0x02);
			C = v47;
			di = di + cx + C;
			ecx = ecx ^ 0xBE3B8205;
			SZ = cond(ecx);
			O = false;
			C.u0 = false;
			v50 = (dh & 0x01 << cl) != 0x00;
			dh = __ror<byte,byte>(dh, cl);
			ecx.u0 = ~0x444BB4AA;
			dx <<= cl;
			SCZO = cond(dx);
			v52 = (ch & 0x01 << 0x08 - 0x10) != 0x00;
			ch = __rcl<byte,byte>(ch, 0x10, C);
			v53 = (edi & 0x01 << 0x0E) != 0x00;
			edi = __ror<word32,byte>(edi, 0x0E);
			C = v53;
			ah.u0 = 111;
			v54 = (cl & 0x01 << cl) != 0x00;
			cl = __rcr<byte,byte>(cl, cl, C);
			C = v54;
			v55 = (cl & 0x01 << 0x08 - cl) != 0x00;
			cl = __rcl<byte,byte>(cl, cl, C);
			dl |= ah;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			v56 = (ch & 0x01 << 0x08 - 0x1C) != 0x00;
			ch = __rcl<byte,byte>(ch, 0x1C, C);
			C = v56;
			v57 = (eax & 0x01 << 0x1D) != 0x00;
			eax = __rcr<word32,byte>(eax, 0x1D, C);
			C = v57;
			v58 = (ecx & 0x01 << 0x1B) != 0x00;
			ecx = __rcr<word32,byte>(ecx, 0x1B, C);
			C = v58;
			ch <<= 0x14;
			cl = ~cl;
			ecx = -ecx;
			v68 = (edi & 0x01 << cl) != 0x00;
			edi = __ror<word32,byte>(edi, cl);
			di |= cx;
			&ebx.u1->b0000 = (word32) ebx + 1;
			SZP = cond(cx & ax);
			bl <<= 11;
			SCZO = cond(bl);
			dl = dl + al + C;
			SCZO = cond(dl);
			v71 = (ecx & 0x01 << cl) != 0x00;
			ecx = __rcr<word32,byte>(ecx, cl, C);
			C = v71;
			&bl.u2->t0000.u0 = (byte) bl + 1;
			ah = ah + ch + C;
			cx |= bx;
			&ah.u2->t0000.u0 = (byte) ah.u0 + 0x00F9;
			bx |= cx;
			al.u0 = 77;
			v72 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rol<byte,byte>(bh, cl);
			C = v72;
			v73 = (ch & 0x01 << 0x15) != 0x00;
			ch = __rcr<byte,byte>(ch, 0x15, C);
			C = v73;
			ax = (word16) ax + 1;
			ecx = ecx - 101348248 - C;
			SCZO = cond(ebx - 0x5EED8A4D);
			if (Test(EQ,Z))
				break;
			v88 = (bh & 0x01 << cl) != 0x00;
			bh = __rcr<byte,byte>(bh, cl, C);
			bl <<= cl;
			SCZO = cond(bl);
			bx = bx + cx + C;
			dx >>= cl;
			v89 = (eax & 0x01 << 0x04) != 0x00;
			eax = __ror<word32,byte>(eax, 0x04);
			al <<= 0x0A;
			edx |= 0x09840934;
			cl >>= 0x1A;
			SCZO = cond(cl);
			cl = al;
			v90 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v90;
			--dl;
			ah = ah + dl + C;
			ebx -= 2760672158;
			SCZO = cond(ebx - 822362091);
			if (Test(EQ,Z))
			{
				al = __in<byte>(dx);
				if (Test(LE,SZO))
					;
				esp -= 4;
				*esp = edi;
			}
			edx >>= 0x13;
			cl -= 0x27;
			v95 = (ch & 0x01 << cl) != 0x00;
			ch = __ror<byte,byte>(ch, cl);
			ecx >>= 22;
			edi <<= 0x0E;
			dl = ~dl;
			v96 = (cl & 0x01 << 0x08 - 0x1D) != 0x00;
			cl = __rol<byte,byte>(cl, 0x1D);
			v97 = (eax & 0x01 << 0x20 - cl) != 0x00;
			eax = __rol<word32,byte>(eax, cl);
			SZP = cond(ah & 181);
			edi <<= 0x14;
			di >>= cl;
			SCZ = cond(di);
			cl = cl + ch + C;
			SCZO = cond(cl);
l0040650B:
			al &= 0xC1;
			C.u0 = false;
			FPUF.u0 = cond(*Top - (real64) (*((int32 *) 3771913731)));
			v37 = (ax & 0x01 << 0x10 - cl) != 0x00;
			ax = __rcl<word16,byte>(ax, cl, C);
			v39 = (dl & 0x01 << 0x08 - cl) != 0x00;
			dl = __rol<byte,byte>(dl, cl);
			dh |= ah;
			edx |= 0x30B38B25;
			bh <<= 0x1D;
			edi <<= 0x13;
			SCZO = cond(edx - ~0x53C81425);
			if (Test(EQ,Z))
			{
				v41 = Mem0[esp + ebx:byte] ^ al;
				Mem0[esp + ebx:byte] = v41;
				SZ = cond(Mem0[esp + ebx:byte]);
				O = false;
				C.u0 = false;
				return;
			}
			dl >>= cl;
			SCZO = cond(dl);
l00406713:
			&bl.u2->t0000.u0 = (byte) bl + 1;
			eax += ~0x002F06DA;
			di &= cx;
			v48 = (ebx & 0x01 << 0x1A) != 0x00;
			ebx = __ror<word32,byte>(ebx, 0x1A);
			dl <<= cl;
			SCZO = cond(dl);
			edi = edi - 1504600972 - C;
			edi >>= cl;
			edi <<= 0x08;
			SCZO = cond(edi);
			&bh.u2->t0000.u0 = (bool) C.u0 + ((byte) bh.u0 + 86);
			ah -= 0xD0;
			SCZO = cond(ah);
			v49 = (dh & 0x01 << 0x08 - 0x14) != 0x00;
			dh = __rol<byte,byte>(dh, 0x14);
			C = v49;
			v59 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			dl.u0 = ~0x32;
			dx <<= cl;
			bx >>= cl;
			&eax.u1->b0000 = (word32) eax + 1;
			&dh.u2->t0000.u0 = (byte) dh.u0 + 22;
			eax = eax ^ 4003117398;
			dh <<= cl;
			SZP = cond(ah & 0x1A);
			ah <<= cl;
			SCZO = cond(edx - ~0x13BE0C40);
			if (Test(EQ,Z))
			{
				--ebx;
				v60 = (ebp & 0x01 << 0x20 - cl) != 0x00;
				ebp = __rcl<word32,byte>(ebp, cl, C);
				SZP = cond(esi.u2->bFFFFFFC0 & ch);
				O = false;
				C.u0 = false;
				&((word32) edi + edi * 0x04)->u1->b0000 = 1725178164;
				v61 = (cl & 0x01 << 0x1A) != 0x00;
				cl = __rcr<byte,byte>(cl, 0x1A, C);
				C = v61;
				do
				{
					esi <<= 0x09;
					ebx &= 0xE0A5E394;
					si += di;
					ch >>= 0x18;
					ecx <<= cl;
					ebx <<= 0x01;
					SCZO = cond(ebx);
					bl = bl + dh + C;
					SCZO = cond(bl);
					&ebx.u1->b0000 = (bool) C.u0 + ((word32) ebx - 25552750);
					SCZO = cond(ecx - 1510872721);
					if (Test(NE,Z))
					{
						&cl.u2->t0000.u0 = (byte) cl + 1;
						SZO = cond(cl);
						goto l00406638;
					}
				} while (Test(OV,O));
				ebx.u2->tE3D3ADC1.u0 = (int8) ch;
				cx = dx;
				v62 = (ch & 0x01 << cl) != 0x00;
				ch = __ror<byte,byte>(ch, cl);
				cl >>= cl;
				edi &= ecx;
				bl = ch;
				si += ax;
				v63 = (ch & 0x01 << 0x08 - 0x13) != 0x00;
				ch = __rol<byte,byte>(ch, 0x13);
				C = v63;
				v64 = (di & 0x01 << cl) != 0x00;
				di = __rcr<word16,byte>(di, cl, C);
				C = v64;
				bh = bh + bl + C;
				C = bh != 0x00;
				bh = -bh;
				v65 = (bl & 0x01 << 0x08 - 0x0C) != 0x00;
				bl = __rcl<byte,byte>(bl, 0x0C, C);
				SCZO = cond(edi - 2416454513);
				if (Test(EQ,Z))
				{
					esp -= 4;
					&esp->u1->b0000 = SCZDOP;
					v67 = esp;
					esp -= 4;
					*esp = eax;
					esp -= 4;
					*esp = ecx;
					esp -= 4;
					*esp = edx;
					esp -= 4;
					*esp = ebx;
					esp -= 4;
					*esp = v67;
					esp -= 4;
					*esp = ebp;
					esp -= 4;
					*esp = esi;
					esp -= 4;
					*esp = edi;
				}
				ecx <<= 0x0A;
				cl = cl ^ ~0x41;
				bl = bl ^ ~0x22;
				C.u0 = false;
				v70 = (cx & 0x01 << 0x10 - cl) != 0x00;
				cx = __rcl<word16,byte>(cx, cl, C);
				C = v70;
				bh = bh + dl + C;
				SZP = cond(cl & 0x19);
				C.u0 = false;
				esi = esi + ebx + C;
				edi -= 4096277994;
				ch &= cl;
				ecx -= ebx;
				SCZO = cond(ecx);
				&edx.u1->b0000 = (word32) edx + 1;
				ebx |= ecx;
				C.u0 = false;
				v85 = (esi & 0x01 << 0x20 - 0x03) != 0x00;
				esi = __rcl<word32,byte>(esi, 0x03, C);
				di <<= cl;
				SCZO = cond(di);
				cl.u0 = ~0x34;
				esi = esi - 3836777433 - C;
				v86 = (ecx & 0x01 << 0x20 - cl) != 0x00;
				ecx = __rol<word32,byte>(ecx, cl);
				ch &= 0xB8;
				v87 = (bl & 0x01 << 0x08 - 0x14) != 0x00;
				bl = __rol<byte,byte>(bl, 0x14);
				si |= ax;
				C.u0 = false;
				&ch.u2->t0000.u0 = (bool) C.u0 + ((byte) ch + 155);
				SCZO = cond(ecx - 2443072741);
				if (Test(EQ,Z))
				{
					ebp.u2->t64F512AC.u0 = (word32) *esp;
					&esp.u1->b0000 = (word32) esp + 4;
					return;
				}
				ecx <<= 0x0D;
				SCZO = cond(ecx);
				&bl.u2->t0000.u0 = (bool) C.u0 + ((byte) bl + 48);
				v98 = (esi & 0x01 << 0x20 - cl) != 0x00;
				esi = __rol<word32,byte>(esi, cl);
				C = v98;
				bl = ~bl;
				--bh;
				bh = bh + dl + C;
				bx = (word16) bx + 1;
				v99 = (edi & 0x01 << 0x20 - 0x17) != 0x00;
				edi = __rol<word32,byte>(edi, 0x17);
				ch += dh;
				si >>= cl;
				SCZO = cond(edi - 723182767);
				if (Test(NE,Z))
				{
					SCZO = cond(edx - 30049908);
					if (Test(EQ,Z))
					{
						ch.u0 = ~0x28;
						bh = bh + cl + C;
						cl <<= cl;
						SCZO = cond(cl);
						v107 = (ch & 0x01 << 0x08 - cl) != 0x00;
						ch = __rcl<byte,byte>(ch, cl, C);
						C = v107;
						al = al - 0x35 - C;
						ax = ax ^ dx;
						C.u0 = false;
						&ecx.u1->b0000 = (byte) ecx.u0 + 1;
						SZO = cond(ecx);
						return;
					}
					v108 = (esi & 0x01 << 0x13) != 0x00;
					esi = __rcr<word32,byte>(esi, 0x13, C);
					ch >>= 0x1D;
					v109 = (ebx & 0x01 << 0x20 - 0x07) != 0x00;
					ebx = __rol<word32,byte>(ebx, 0x07);
					bh.u0 = 227;
					ecx &= 0x812CBC82;
					SZ = cond(ecx);
					O = false;
					C.u0 = false;
l004063E6:
					fnD25D3FAD();
					return;
				}
				++esi;
				D = false;
				--ecx;
				v100 = *ecx.u0 - ch - C;
				*ecx.u0 = v100;
				esi |= edi;
				SZ = cond(esi);
				O = false;
				C.u0 = false;
l00406638:
				&bl.u2->t0000.u0 = (byte) bl + 1;
				ebx -= ~0x5404F23A;
				SZP = cond(esi & 0x6D332232);
				ecx = ecx ^ esi;
				C.u0 = false;
				edi = edi + 3244390841 + C;
				ch = ch ^ ah;
				SZ = cond(ch);
				O = false;
				C.u0 = false;
				fn0040794A();
				&esp.u1->b0000 = (word32) esp - 0x00003240;
				v84 = ecx;
				ecx = eax;
				eax = v84;
				al = *(union Eq_7 *) ~0x3326F231;
l004069EE:
				esp -= 2;
				&esp->u1->b0000 = cs;
				edx.u2->w000A = (int16) trunc(*Top);
				Top = (real64 *) ((char *) Top + 1);
				if (ecx == 0x00)
				{
					while (true)
					{
						eax = *esi;
						esi += 4;
						if (Test(EQ,Z))
						{
							esp -= 2;
							&esp->u1->b0000 = cs;
							esp -= 2;
							&esp->u1->b0000 = cs;
							SCZO = cond(eax - *edi);
							&edi.u1->b0000 = (word32) edi + 4;
							ax = __aam(al);
							esp -= 2;
							&esp->u1->b0000 = cs;
							esp -= 4;
							*esp = edx;
							esi.u0 = 451767907;
							v94 = *((byte) ebp.u0 + 788341737) | 0x0E;
							&((byte) ebp.u0 + 788341737)->u1->b0000 = v94;
							SZ = cond(*((byte) ebp.u0 + 788341737));
							O = false;
							C.u0 = false;
							esp -= 2;
							&esp->u1->b0000 = cs;
							goto l004069EE;
						}
l004069F6:
						esp -= 2;
						&esp->u1->b0000 = cs;
						esp -= 2;
						&esp->u1->b0000 = cs;
						v92 = *ebx ^ ah;
						*ebx = v92;
						SZ = cond(*ebx);
						O = false;
						C.u0 = false;
						ebp.u0 = 0x0AEDE30A;
						if (ecx != 0x00)
						{
							ebx = *esp;
							&esp.u1->b0000 = (word32) esp + 4;
							eax = *esi;
							esi += 4;
							ebx = *esp;
							&esp.u1->b0000 = (word32) esp + 4;
							esp -= 2;
							&esp->u1->b0000 = ds;
							esp -= 2;
							&esp->u1->b0000 = cs;
							esp -= 2;
							&esp->u1->b0000 = cs;
							fn0E5F6734();
							return;
						}
						esp -= 2;
						&esp->u1->b0000 = cs;
						&eax.u1->b0000 = (word32) eax + 1;
						ebx &= ebp;
						--edi;
						ah |= bl;
						--edi;
						SCZO = cond(eax - *edi);
						&edi.u1->b0000 = (word32) edi + 4;
						--ebp;
						SZO = cond(ebp);
						dl.u0 = 0x70;
						v93 = esi;
						esi = eax;
						eax = v93;
					}
				}
				else
				{
					ah |= bl;
					SZ = cond(ah);
					O = false;
					C.u0 = false;
					goto l004069F6;
				}
			}
			bh += bl;
			dl = dl ^ 0x49;
			SCZO = cond(edx - 2032680950);
			ebx = ebx - ~0x00919272 - C;
			v69 = (ecx & 0x01 << 0x20 - 0x1D) != 0x00;
			ecx = __rol<word32,byte>(ecx, 0x1D);
			ch &= ah;
			cl &= dl;
			cl <<= cl;
			dx = -dx;
			cl = cl ^ 0x2A;
			C.u0 = false;
			dx = (word16) dx + 1;
			SZO = cond(dx);
			cl = cl + dh + C;
			SCZO = cond(cl);
l00406687:
			v77 = (dl & 0x01 << 0x08 - 0x19) != 0x00;
			dl = __rol<byte,byte>(dl, 0x19);
			esp -= 4;
			esp->u0 = ~0x00;
			eax = *esp;
			esp += 4;
			dx >>= cl;
			SCZ = cond(dx);
			v78 = (ch & 0x01 << 0x08 - 0x18) != 0x00;
			ch = __rcl<byte,byte>(ch, 0x18, C);
			C = v78;
			v79 = (ecx & 0x01 << 0x12) != 0x00;
			ecx = __rcr<word32,byte>(ecx, 0x12, C);
			ecx = ~ecx;
			bh <<= cl;
			ch <<= cl;
			SCZO = cond(ch);
			v80 = (ch & 0x01 << 0x08 - 0x14) != 0x00;
			ch = __rcl<byte,byte>(ch, 0x14, C);
			bh <<= 0x01;
			SCZO = cond(ecx - (struct Eq_1791 *) 189223221);
			if (Test(NE,Z))
			{
				dl = dl + bh + C;
				SZP = cond(cl & dl);
				O = false;
				C.u0 = false;
				while (true)
				{
					edx = edx ^ edx;
					C.u0 = false;
					esi = esi - 0x604BAD06 - C;
					di >>= cl;
					esi -= edx;
					si = ~si;
					bh |= 0x0A;
					cl |= al;
					di = ~di;
					SCZO = cond(ecx - 1727164869);
					if (Test(EQ,Z))
						break;
					di <<= cl;
					SCZO = cond(di);
					bl = bl - ~0x0A - C;
					__syscall<byte>(0x2E);
					SZP = cond(ch & 0x0A);
					C.u0 = false;
					v102 = (si & 0x01 << 0x10 - cl) != 0x00;
					si = __rcl<word16,byte>(si, cl, C);
					v103 = (bh & 0x01 << 0x08 - 0x15) != 0x00;
					bh = __rol<byte,byte>(bh, 0x15);
					bl += ch;
					v104 = (si & 0x01 << 0x10 - cl) != 0x00;
					si = __rol<word16,byte>(si, cl);
					di |= cx;
					ebx |= eax;
					C.u0 = false;
					v105 = (bl & 0x01 << 0x08 - 0x14) != 0x00;
					bl = __rcl<byte,byte>(bl, 0x14, C);
					SCZO = cond(ebx - 0x757F9480);
					if (Test(NE,Z))
					{
						SCZO = cond(edx - ~0x00);
						if (Test(NE,Z))
							al.u0 = edx.u2->tFFFFFFFF.u0;
						else
							al.u0 = 0x2E;
						SCZO = cond(eax - 0xC000002E);
						if (Test(NE,Z))
						{
							dh = dh + ch + C;
							SCZO = cond(dh);
							v110 = (edx & 0x01 << 0x20 - 0x12) != 0x00;
							edx = __rcl<word32,byte>(edx, 0x12, C);
							dl -= bl;
							al &= 0x23;
							SZ = cond(al);
							O = false;
							C.u0 = false;
							goto l0040643D;
						}
						ax <<= cl;
						eax <<= cl;
						cl >>= 0x1A;
						edx |= 3052802336;
						SCZO = cond(esi - 1579776496);
						if (Test(EQ,Z))
						{
							Top -= (real64 *) 1;
							*Top = (real64) eax.u2->rFFFFFFBB;
							return;
						}
						ch >>= cl;
						dl >>= 0x1D;
						SCZ = cond(dl);
						v111 = (dl & 0x01 << 0x08 - 0x0C) != 0x00;
						dl = __rcl<byte,byte>(dl, 0x0C, C);
						C = v111;
						v112 = (ecx & 0x01 << 0x07) != 0x00;
						ecx = __rcr<word32,byte>(ecx, 0x07, C);
						v113 = (bh & 0x01 << 0x08 - cl) != 0x00;
						bh = __rol<byte,byte>(bh, cl);
						SZP = cond(eax & 775899986);
						v114 = (ax & 0x01 << cl) != 0x00;
						ax = __ror<word16,byte>(ax, cl);
						si += bx;
						SCZO = cond(si);
						ecx = ecx + edi + C;
						SCZO = cond(ecx);
						ax = ax - dx - C;
						v115 = (al & 0x01 << 0x08 - cl) != 0x00;
						al = __rol<byte,byte>(al, cl);
						SCZO = cond(eax - 351755397);
						if (Test(NE,Z))
						{
							v116 = (eax & 0x01 << 0x07) != 0x00;
							eax = __rcr<word32,byte>(eax, 0x07, C);
							edi <<= cl;
							dh -= bl;
							SCZO = cond(dh);
							v117 = (ah & 0x01 << cl) != 0x00;
							ah = __rcr<byte,byte>(ah, cl, C);
							eax >>= cl;
							SCZ = cond(eax);
							si = si - bx - C;
							dl <<= cl;
							ebx += eax;
							SCZO = cond(ebx);
							v118 = (dl & 0x01 << 0x0F) != 0x00;
							dl = __rcr<byte,byte>(dl, 0x0F, C);
							bh = bh ^ 33;
							SZ = cond(bh);
							O = false;
							C.u0 = false;
							al += bl;
							eax.u0 = 0x03;
							ecx &= edi;
							--bx;
							ecx <<= cl;
							cl -= 0x12;
							dx <<= cl;
							C = cl != 0x00;
							cl = -cl;
							v119 = (ebx & 0x01 << 0x20 - 0x14) != 0x00;
							ebx = __rcl<word32,byte>(ebx, 0x14, C);
							SCZO = cond(ecx - (struct Eq_1664 *) 0x199F63F8);
							if (Test(NE,Z))
							{
								bl &= 0x11;
								SZ = cond(bl);
								O = false;
								C.u0 = false;
							}
							v120 = *eax.u0 - ch;
							*eax.u0 = v120;
							SCZO = cond(v120);
							v121 = esp;
							esp = eax;
							edi = *esp;
							esp += 0x04;
							esi = *esp;
							esp += 0x04;
							ebp = *esp;
							esp += 0x04;
							esp += 0x04;
							ebx = *esp;
							esp += 0x04;
							edx = *esp;
							esp += 0x04;
							ecx = *esp;
							esp += 0x04;
							eax = *esp;
							esp += 0x04;
							&edi->u1->b0000 = al;
							&edi.u1->b0000 = (word32) edi + 1;
							esi.u0 = 3457343078;
							goto l00406687;
						}
						else
						{
							al = __in<byte>(dx);
							esp -= 4;
							&esp->u1->b0000 = 3453999453;
							ax = __aad(ax);
							goto l00406713;
						}
					}
					v106 = ebp;
					ebp = eax;
					eax = v106;
					ecx = *ebx *s ~0x45;
					SCZO = cond(ecx);
					ebx.u2->bF984D712 = 0x84;
				}
				dl = dl + (eax + 639472533)[ebp * 0x08] + C;
				SCZO = cond(dl);
				v101 = (dl & 0x01 << 0x08 - cl) != 0x00;
				dl = __rcl<byte,byte>(dl, cl, C);
				C = v101;
				goto l004063E6;
			}
			v81 = ecx;
			ecx = eax;
			esp -= 2;
			&esp->u1->b0000 = ds;
			D = true;
			eax = __in<word32>(dx);
			edi -= 4;
			esi -= *((word32) edi + (eax - 21));
			SCZO = cond(esi);
		}
		v74 = ebx;
		ebx = v74;
		--ecx;
	} while (ecx != 0x00);
	edi.u2->tFFFFFF8E.u0 = (word32) *esp;
	&esp.u1->b0000 = (word32) esp + 4;
	v75 = *((byte) ecx.u0 + 884843990) | eax;
	&((byte) ecx.u0 + 884843990)->u1->b0000 = v75;
	SZ = cond(*((byte) ecx.u0 + 884843990));
	O = false;
	C.u0 = false;
l0040643D:
	ebx = *esp;
	&esp.u1->b0000 = (word32) esp + 4;
	--cl;
	dl = dl - 0xB8 - C;
	dl = -dl;
	dl = dl ^ ch;
	eax >>= 0x1C;
	eax -= ebx;
	dl = dl ^ 0xF0;
	bh >>= 0x13;
	SCZO = cond(bh);
	v76 = (cl & 0x01 << 0x08 - 0x13) != 0x00;
	cl = __rcl<byte,byte>(cl, 0x13, C);
	C = v76;
	return;
}

// 0040745C: define fn0040745C
// Called from:
//      fn0040752D
define fn0040745C
{
	esp = fp;
	Top = 0;
	dh >>= cl;
	&cl.u2->t0000.u0 = cl.u2 + bh /8 4;
	C = dl != 0x00;
	dl = -dl;
	v12 = (cx & 0x01 << cl) != 0x00;
	cx = __rcr<word16,byte>(cx, cl, C);
	cl <<= cl;
	--dh;
	bl = bh;
	v15 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	C = v15;
	dh = ch;
	v18 = (edi & 0x01 << 0x20 - 0x09) != 0x00;
	edi = __rcl<word32,byte>(edi, 0x09, C);
	dl <<= cl;
	&edi.u1->b0000 = (word32) edi - 0x76533528;
	SCZO = cond(edi);
	fn004075F3();
}

// 004074B3: define fn004074B3
// Called from:
//      fn0040752D
define fn004074B3
{
	esp = fp;
	Top = 0;
	v5 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	ch = ch ^ dl;
	edi >>= cl;
	ecx |= 837470372;
	v16 = (di & 0x01 << cl) != 0x00;
	di = __ror<word16,byte>(di, cl);
	SZP = cond(dh & ch);
	ch |= bh;
	&ecx.u1->b0000 = (word32) ecx + 0x12C3C5BC;
	ch = ch ^ al;
	SCZO = cond(edi - 1086180127);
	if (Test(EQ,Z))
	{
		if (Test(NO,O))
		{
			dl = 0x86;
			fn004074DC();
			return;
		}
		eax = __in<word32>(dx);
		++edi;
		ebp = ebp - (eax.u2)->dwFFFFFFF0 - C;
		SCZO = cond(ebp);
	}
	edi = esi;
	&cl.u2->t0000.u0 = (byte) cl.u1 + 1;
	--dh;
	SZP = cond(dl & dh);
	C.u0 = false;
	--cl;
	edx = edx - eax - C;
	cl -= 244;
	cl <<= 0x1D;
	ch >>= cl;
	edi -= 3155113837;
	dx |= cx;
	SCZO = cond(edx - ~0x6D6E0E30);
	ecx.u0 = 1110089130;
	edx = -edx;
	ecx |= eax;
	dl = 226;
	edx &= eax;
	ch >>= cl;
	SCZ = cond(ch);
	ecx.u0 = 1149555181;
	cx = (cui16) ((bool) C.u0 + (cx + bx));
	SCZO = cond(edi - 1139853459);
	if (Test(NE,Z))
		fn0040774C();
	else
	{
		SCZO = cond(eax - 2210091595);
		if (Test(NE,Z))
		{
			dl -= ~0x14;
			bh = bh ^ 0x3B;
			C.u0 = false;
			v32 = (ecx & 0x01 << 0x20 - cl) != 0x00;
			ecx = __rcl<word32,byte>(ecx, cl, C);
			C = v32;
			ax = (word16) ((bool) C.u0 + (ax + si));
			SCZO = cond(ax);
			v35 = (bl & 0x01 << cl) != 0x00;
			bl = __rcr<byte,byte>(bl, cl, C);
			C = v35;
			esi = esi + ebx + C;
			ecx &= eax;
			cl &= dl;
			ecx >>= cl;
			cl <<= 0x11;
			SCZO = cond(cl);
			v38 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rcl<byte,byte>(dh, cl, C);
			C = v38;
			bl = bl + al + C;
			SCZO = cond(bl);
			al = al - dh - C;
			SCZO = cond(al);
			cl >>= cl;
			SCZO = cond(cl);
			++bh;
			cx = (cui16) ((bool) C.u0 + (cx + si));
			v39 = (edx & 0x01 << 0x20 - 0x0A) != 0x00;
			edx = __rol<word32,byte>(edx, 0x0A);
			dh >>= cl;
			bh -= 0x05;
			SCZO = cond(bh);
		}
		else if (Test(PO,P))
			fn0040789A();
		else
		{
			v30 = *esi;
			*edi = v30;
			++esi;
			++edi;
			eax &= 0x1CC2C0B9;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
			fn0040787D();
		}
	}
}

// 004074DC: define fn004074DC
// Called from:
//      fn004074B3
//      fn0040752D
//      fn0040774C
define fn004074DC
{
	word32 eax;
	word32 ecx;
	word16 bx;
	cl = (byte) ecx;
	bool C;
	byte dl;
	word24 edx_24_8;
	ecx_24_8 = SLICE(ecx, word24, 8);
	ecx_16_16_52 = SLICE(ecx_24_8, word16, 8);
	ah = SLICE(eax, byte, 8);
	word16 si;
	<unknown> Mem0;
	ch_18 = (byte) ecx_24_8;
	Top_3 = 0;
	bx_8 = __rcr<word16,byte>(bx, cl, C);
	bl_22 = (byte) bx_8;
	bh_25 = SLICE(bx_8, byte, 8);
	dl_11 = __rol<byte,byte>(dl, 0x17);
	edx_13 = SEQ(edx_24_8, dl_11);
	ecx_15 = ecx;
	edx_16 = edx_13 ^ ecx_15;
	dh_23 = SLICE(edx_16, byte, 8);
	dx_30 = (word16) edx_16;
	edx_16_16_74 = SLICE(edx_16, word16, 16);
	v16_19 = (ch_18 & 0x01 << 0x08 - cl) != 0x00;
	ch_20 = __rcl<byte,byte>(ch_18, cl, false);
	bl_24 = (bool) v16_19 + (bl_22 + dh_23);
	bh_26 = bh_25 ^ cl;
	bl_28 = bl_24 & ah;
	dx_32 = __rcl<word16,byte>(dx_30, cl, false);
	bx_33 = SEQ(bh_26, bl_28);
	dl_39 = (byte) dx_32;
	dh_62 = SLICE(dx_32, byte, 8);
	bx_35 = bx_33 & si;
	bl_41 = (byte) bx_35;
	cl_37 = cl + ch_20;
	eax_46 = eax;
	bh_48 = *eax_46;
	ch_50 = __rol<byte,byte>(ch_20, 0x19);
	ecx_53 = SEQ(ecx_16_16_52, ch_50, cl_37 | 228);
	ecx_57 = (ecx_53 << 0x18) - 2251182364 - (word32) (ecx_53 << 0x18 < 0x00);
	ch_59 = SLICE(ecx_57, byte, 8);
	cl_64 = (byte) ecx_57;
	ecx_16_16_72 = SLICE(ecx_57, word16, 16);
	dl_58 = (dl_39 >> 0x1A) + bh_48;
	dh_63 = -dh_62;
	di_65 = si << cl_64;
	bx_67 = SEQ(bh_48, bl_41 >> 0x09);
	di_69 = di_65 - bx_67 - (word16) (di_65 < 0x00);
	SCZO_70 = cond(di_69);
	C_71 = SLICE(SCZO_70, bool, 1);
	ecx_73 = SEQ(ecx_16_16_72, ch_59 + 0x6C, cl_64);
	edx_75 = SEQ(edx_16_16_74, dh_63, dl_58);
	O_76 = SLICE(SCZO_70, bool, 4);
	S_77 = (bool) SCZO_70;
	Z_78 = SLICE(SCZO_70, bool, 2);
	fn00407702();
}

// 0040752D: define fn0040752D
// Called from:
//      fn00407563
define fn0040752D
{
	esp = fp;
	Top = 0;
	dl >>= cl;
	bh <<= cl;
	ecx += 3003903384;
	v10 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	edi |= 1807723075;
	&cl.u2->t0000.u0 = (byte) cl.u1 + 74;
	esi = edx;
	dl <<= 22;
	eax = (word32 *) ((char *) eax - 1217);
	SCZO = cond(eax);
	--cx;
	v21 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	SCZO = cond(ecx - ~0x4E0DE634);
	if (Test(NE,Z))
	{
		ebx &= 3843756853;
		SZP = cond(bl & 0x4A);
		v25 = (edi & 0x01 << 0x1E) != 0x00;
		edi = __ror<word32,byte>(edi, 0x1E);
		C = v25;
		dl = dl + cl + C;
		SCZO = cond(dl);
		ch = ch - 0x49 - C;
		v27 = (cx & 0x01 << 0x10 - cl) != 0x00;
		cx = __rol<word16,byte>(cx, cl);
		bl = ~bl;
		edi |= 1784354780;
		ch = al;
		esi.u0 = 1458775487;
		edx >>= 0x0F;
		v29 = (ebx & 0x01 << cl) != 0x00;
		ebx = __ror<word32,byte>(ebx, cl);
		SCZO = cond(ebx - 0x18D97222);
		if (Test(NE,Z))
		{
			v35 = (bl & 0x01 << 0x08 - cl) != 0x00;
			bl = __rol<byte,byte>(bl, cl);
			C = v35;
			ch = (byte) (C.u4 + (ch + 0x13) /8 0x64F512B0);
			C = dx != 0x00;
			dx = -dx;
			v37 = (dl & 0x01 << 0x08 - 0x11) != 0x00;
			dl = __rcl<byte,byte>(dl, 0x11, C);
			v38 = (edi & 0x01 << 0x13) != 0x00;
			edi = __ror<word32,byte>(edi, 0x13);
			cl = cl ^ dh;
			edi.u0 = 1055546143;
			cx -= si;
			ebx <<= 0x0D;
			dh = 0x55;
			bh = -bh;
			SCZO = cond(ecx - 0xD52B92A6);
			if (Test(NE,Z))
			{
				esi = esi ^ 1458777882;
				dh >>= 0x0F;
				dl >>= cl;
				v44 = (bx & 0x01 << cl) != 0x00;
				bx = __ror<word16,byte>(bx, cl);
				C = v44;
				dh = dh - 0x84 - C;
				SZP = cond(ebx & eax);
				v47 = (cl & 0x01 << 0x0D) != 0x00;
				cl = __ror<byte,byte>(cl, 0x0D);
				cl >>= 0x04;
				v48 = (cl & 0x01 << 0x17) != 0x00;
				cl = __ror<byte,byte>(cl, 0x17);
				edx <<= 22;
				SCZO = cond(edx);
				fn0040774C();
			}
			else
			{
				C = __aaa(al, ah, &al, &ah);
				ebx.u0 = 1196653650;
				fn00407786();
			}
		}
		else
		{
			v30 = *eax;
			*eax = ebp;
			ebp = ~0x0846950D;
			fn004075F3();
		}
	}
}

// 00407560: define fn00407560
// Called from:
//      fn00407563
define fn00407560
{
	esp = fp;
	Top = 0;
	eax <<= 0x0F;
	SCZO = cond(eax);
	fn00407563();
}

// 00407563: define fn00407563
// Called from:
//      fn00407560
//      fn0040791C
//      fn0040791D
define fn00407563
{
	esp = fp;
	Top = null;
	SCZO = cond(eax->t0000 - edx);
	if (Test(NE,Z))
	{
		--eax;
		eax >>= 0x0F;
		SCZO = cond(edi - 3336781132);
		if (Test(NE,Z))
			fn00407560();
		else
		{
			edx_eax = (int64) eax;
			eax = (int32) ax;
			eax = (struct Eq_2445 *) ((char *) &eax->t0000 + 1);
			SZO = cond(eax);
			*Top *= (real64) ebp->wD22A88DF;
			fn0040794B();
		}
	}
	else
	{
		ecx = eax;
		eax += eax->dw003C / 84;
		v9 = eax->ptr0050;
		esp -= 4;
		*esp = (struct Eq_2445 **) v9;
		esp -= 4;
		*esp = (struct Eq_2445 **) ecx;
		eax = (struct Eq_2445 *) ((char *) &eax->ptr0050 + 48);
		eax = (struct Eq_2445 *) eax->t0000;
		eax += ecx;
		SCZO = cond(eax);
		eax = eax->ptr0010;
		eax = ecx + eax;
		eax->t0000();
		ecx = (struct Eq_2445 *) *esp;
		esp = (struct Eq_2445 **) ((char *) esp + 4);
		fn004078EC();
	}
}

// 004075F3: define fn004075F3
// Called from:
//      fn0040745C
//      fn0040752D
define fn004075F3
{
	esp = fp;
	Top = 0;
	edi = ~edi;
	edx <<= 0x03;
	SCZO = cond(edx);
	ch = (bool) C + (ch + 0x67);
	v9 = (dh & 0x01 << 0x08 - 0x10) != 0x00;
	dh = __rol<byte,byte>(dh, 0x10);
	edi -= 2254034366;
	dh = al;
	edx >>= 0x1E;
	SCZO = cond(edx);
	*eax = bl;
	dl >>= 0x1A;
	edx >>= 0x17;
	edi >>= 0x0D;
	SCZ = cond(edi);
	fn004077B8();
}

// 00407702: define fn00407702
// Called from:
//      fn0040752D
//      fn0040787D
//      fn0040789A
define fn00407702
{
	esp = fp;
	Top = null;
	dh <<= 0x07;
	dl = bh;
	dl -= bh;
	edi -= esi;
	SCZO = cond(edi);
	v15 = (cl & 0x01 << 0x08 - cl) != 0x00;
	cl = __rcl<byte,byte>(cl, cl, C);
	SZP = cond(ecx & 3525063953);
	edi >>= cl;
	&bh.u2->t0000.u0 = (byte) bh.u0 + 0x00D8;
	SCZO = cond(bh);
	v17 = (dh & 0x01 << 0x14) != 0x00;
	dh = __ror<byte,byte>(dh, 0x14);
	cl = dh;
	cl = cl ^ bh;
	C.u0 = false;
	v19 = (ecx & 0x01 << 0x15) != 0x00;
	ecx = __rcr<word32,byte>(ecx, 0x15, C);
	v21 = (ch & 0x01 << 0x08 - 22) != 0x00;
	ch = __rol<byte,byte>(ch, 22);
	dl = dl ^ ch;
	SZP = cond(cl & dh);
	ch &= bh;
	dl >>= cl;
	dl <<= cl;
	SCZO = cond(ebx - ~0x3E2C0E63);
	if (Test(NE,Z))
	{
		v54 = (cx & 0x01 << cl) != 0x00;
		cx = __rcr<word16,byte>(cx, cl, C);
		C = v54;
		bh = ~bh;
		v55 = (dx & 0x01 << 0x10 - cl) != 0x00;
		dx = __rcl<word16,byte>(dx, cl, C);
		edx <<= 0x1C;
		cl >>= 0x1E;
		SCZ = cond(cl);
		v56 = (dl & 0x01 << cl) != 0x00;
		dl = __rcr<byte,byte>(dl, cl, C);
		edx = edx ^ 2485752588;
		v57 = (dh & 0x01 << cl) != 0x00;
		dh = __ror<byte,byte>(dh, cl);
		SZP = cond(dl & 0x43);
		O = false;
		C.u0 = false;
		fn0040745C();
	}
	else
	{
		*Top *= (real64) ecx.u2->r0022;
		v25 = ebx;
		ebx = eax;
		eax = v25;
		do
		{
			v27 = (edi & 0x01 << 0x09) != 0x00;
			edi = __ror<word32,byte>(edi, 0x09);
			ecx |= 3509765606;
			v28 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			dh >>= 0x08;
			v29 = (bh & 0x01 << 0x08 - 0x13) != 0x00;
			bh = __rol<byte,byte>(bh, 0x13);
			cl += bh;
			v31 = (edx & 0x01 << 0x0D) != 0x00;
			edx = __ror<word32,byte>(edx, 0x0D);
			cl -= ~0x60;
			v33 = (di & 0x01 << 0x10 - cl) != 0x00;
			di = __rol<word16,byte>(di, cl);
			ch = ch ^ bh;
			SCZO = cond(ebx - 3870016017);
			if (Test(NE,Z))
			{
				v46 = (dl & 0x01 << 0x08 - 0x1C) != 0x00;
				dl = __rol<byte,byte>(dl, 0x1C);
				C = v46;
				fn0040787D();
				return;
			}
			esp = ebp;
			&ebp.u2->t0000.u0 = esp.u2->t0000.u2;
			&esp.u2->t0000.u0 = (word32) esp + 4;
			al.u0 = esi.u2->t0000.u0;
			&esi.u2->t0000.u0 = (word32) esi + 1;
			eax = eax - 3882370378 - C;
			SCZO = cond(eax);
			while (true)
			{
				dl = dl - bh - C;
				ecx &= esi;
				--cl;
				ch -= 0x19;
				v37 = (bh & 0x01 << 0x1D) != 0x00;
				bh = __ror<byte,byte>(bh, 0x1D);
				&edi.u1->b0000 = (word32) edi + 0x0CED4D05;
				di >>= cl;
				SCZ = cond(di);
				--cl;
				cl = cl - bh - C;
				v38 = (ecx & 0x01 << 0x20 - 0x1B) != 0x00;
				ecx = __rol<word32,byte>(ecx, 0x1B);
				v39 = (edx & 0x01 << 0x06) != 0x00;
				edx = __ror<word32,byte>(edx, 0x06);
				SCZO = cond(eax - 0x011E1D00);
				if (Test(NE,Z))
					break;
				if (Test(NE,Z))
				{
					al = __in<byte>(dx);
					&edi.u1->b0000 = (word32) edi + 1;
					__wait();
					__cli();
					ch &= ~0x25;
					cl <<= 0x0F;
					&ecx.u1->b0000 = (word32) ecx + 0x0C1BB1D8;
					--edi;
					edx = -edx;
					edx >>= 0x15;
					cl.u0 = 244;
					ch <<= 0x15;
					cl += ch;
					v41 = (dh & 0x01 << cl) != 0x00;
					dh = __ror<byte,byte>(dh, cl);
					v42 = (dx & 0x01 << cl) != 0x00;
					dx = __ror<word16,byte>(dx, cl);
					ecx = ecx ^ 0x79375E66;
					C.u0 = false;
					--esi;
					SZO = cond(esi);
					fn004074B3();
					return;
				}
				cl += cl;
				SCZO = cond(cl);
				al.u0 = esi.u2->t0000.u0;
				&esi.u2->t0000.u0 = (word32) esi + 1;
				eax = eax - 3882370378 - C;
				SCZO = cond(eax);
			}
			--dl;
			edx <<= 0x1C;
			v43 = (ecx & 0x01 << 0x20 - 0x0A) != 0x00;
			ecx = __rol<word32,byte>(ecx, 0x0A);
			C = v43;
			edx = edx - ~0x2254A51D - C;
			cl &= ~0x30;
			bh = -bh;
			di = -di;
			SZP = cond(edi & 0x3B02BF3C);
			v44 = (cl & 0x01 << cl) != 0x00;
			cl = __ror<byte,byte>(cl, cl);
			&ch.u2->t0000.u0 = ch.u2 + bl /8 4;
			&edx.u1->b0000 = (word32) edx + 709722619;
			SCZO = cond(edi - 1049482917);
		} while (Test(NE,Z));
		&esi.u2->t0000.u0 = esp.u2->t0000.u2;
		&esp.u2->t0000.u0 = (word32) esp + 4;
		SCZO = cond(eax->bFFFFFFF9 - bh);
		--eax;
		ecx = ebx->dw48D1040 *s 0x5910FF01;
		SCZO = cond(ecx);
		fn004078EC();
	}
}

// 0040774C: define fn0040774C
// Called from:
//      fn004074B3
//      fn0040752D
define fn0040774C
{
	ptr32 fp;
	word32 ebx;
	byte cl;
	bool C;
	word32 eax;
	word24 ecx_24_8;
	byte dl;
	word24 edx_24_8;
	word16 si;
	esp_17 = fp;
	Top_18 = 0;
	v5_21 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx_23 = __rcl<word32,byte>(ebx, cl, C);
	bx_28 = (word16) ebx_23;
	ebx_16_16_44 = SLICE(ebx_23, word16, 16);
	C_24 = v5_21;
	ecx_27 = SEQ(ecx_24_8, cl);
	fn004074DC();
	ebx_45 = SEQ(ebx_16_16_44, bx_32);
}

// 00407786: define fn00407786
// Called from:
//      fn0040752D
//      fn004077E4
define fn00407786
{
	fn004077E4();
	C_10 = SLICE(SCZOP_9, bool, 1);
	O_11 = SLICE(SCZOP_9, bool, 4);
	P_12 = SLICE(SCZOP_9, bool, 5);
	S_13 = (bool) SCZOP_9;
	Z_14 = SLICE(SCZOP_9, bool, 2);
	Top_5 = 0;
}

// 004077B8: define fn004077B8
// Called from:
//      fn0040752D
//      fn004075F3
define fn004077B8
{
	esp = fp;
	Top = 0;
	edi >>= 0x04;
	ecx <<= 0x1C;
	SCZO = cond(ecx);
	++dl;
	v12 = (ch & 0x01 << 0x08 - 0x18) != 0x00;
	ch = __rcl<byte,byte>(ch, 0x18, C);
	ecx <<= 0x05;
	SCZO = cond(ecx);
	ecx = C.u4 + (ecx + 392335013) / 0x64F512B0;
	SCZO = cond(ecx);
	ch = ch - ~0x2A - C;
	C = dh != 0x00;
	dh = -dh;
	++eax;
	ch = ch + bl + C;
	SCZO = cond(ch);
	fn00407702();
}

// 004077E4: define fn004077E4
// Called from:
//      fn00407563
//      fn00407786
//      fn004078EC
define fn004077E4
{
	word32 eax;
	ptr32 fp;
	byte ch;
	al = (byte) eax;
	bool C;
	byte cl;
	word32 edx;
	word16 ecx_16_16;
	ch_8 = ch + al + (byte) C;
	SCZO_10 = cond(4222243924);
	C_13.u0 = SLICE(SCZO_10, bool, 1);
	bh_14 = __rcr<byte,byte>(0x54, 0x06, C_13);
	ebx_17 = SEQ(64426, bh_14, 0x54);
	ebx_19 = __ror<word32,byte>(ebx_17, 0x15);
	&bh_20.u2->t0000.u0 = SLICE(ebx_19, byte, 8);
	bl_28 = (byte) ebx_19;
	ebx_16_16_56 = SLICE(ebx_19, word16, 16);
	bh_23 = __ror<byte,byte>(bh_20, cl);
	edi_24 = 0x75593011;
	eax_26 = eax;
	eax_24_8_46 = SLICE(eax_26 - ~0x04C0, word24, 8);
	bl_30 = __ror<byte,byte>(bl_28, cl);
	edx_ch_53 = SEQ(edx, ch_8);
	edx_ch_54 = edx_ch_53 - SEQ(3300057571, al - 0x3F);
	ch_32 = (byte) edx_ch_54;
	edx_36 = SLICE(edx_ch_54, word32, 8);
	ecx_40 = SEQ(ecx_16_16, ch_32, cl);
	ch_43 = SLICE(ecx_40 + 0x01, byte, 8);
	ecx_16_16_45 = SLICE(ecx_40 + 0x01, word16, 16);
	ebx_57 = SEQ(ebx_16_16_56, bh_23 << 0x05, bl_30);
	fn00407786();
	C_55 = SLICE(SCZOP_52, bool, 1);
	O_58 = SLICE(SCZOP_52, bool, 4);
	P_59 = SLICE(SCZOP_52, bool, 5);
	S_60 = (bool) SCZOP_52;
	Z_61 = SLICE(SCZOP_52, bool, 2);
	Top_48 = 0;
}

// 0040787D: define fn0040787D
// Called from:
//      fn004074B3
//      fn00407702
define fn0040787D
{
	esp = fp;
	Top = 0;
	di <<= cl;
	SCZO = cond(di);
	v7 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	v10 = (ch & 0x01 << 0x08) != 0x00;
	ch = __ror<byte,byte>(ch, 0x08);
	C = v10;
	dh = (byte) (C.u4 + (dh + bl) /8 0x64F512B0);
	ecx |= 2889752246;
	v17 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	v18 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	bh -= 0x5D;
	v21 = (edx & 0x01 << 0x20 - 0x0D) != 0x00;
	edx = __rol<word32,byte>(edx, 0x0D);
	SZP = cond(dl & 0xA9);
	O = false;
	C.u0 = false;
	fn0040789A();
}

// 0040789A: define fn0040789A
// Called from:
//      fn004074B3
//      fn0040787D
define fn0040789A
{
	esp = fp;
	Top = 0;
	ch = (bool) C + (ch + ah);
	SZP = cond(ecx & edx);
	O = false;
	C.u0 = false;
	fn00407702();
}

// 004078EC: define fn004078EC
// Called from:
//      fn0040752D
//      fn00407563
define fn004078EC
{
	esp = fp;
	Top = 0;
	eax = *esp;
	++esp;
	v6 = (dx & 0x01 << cl) != 0x00;
	dx = __ror<word16,byte>(dx, cl);
	dx -= si;
	SCZO = cond(dx);
	v11 = (dh & 0x01 << 0x08 - 0x05) != 0x00;
	dh = __rcl<byte,byte>(dh, 0x05, C);
	C = v11;
	v13 = (cx & 0x01 << cl) != 0x00;
	cx = __rcr<word16,byte>(cx, cl, C);
	cl = -cl;
	edi = edi ^ 0x57A8CEA0;
	C.u0 = false;
	v19 = (esi & 0x01 << 0x20 - 0x0E) != 0x00;
	esi = __rcl<word32,byte>(esi, 0x0E, C);
	SCZO = cond(edx - 2107756022);
	if (Test(NE,Z))
		fn004077E4();
	else
		fn00407915();
}

// 00407915: define fn00407915
// Called from:
//      fn00407563
//      fn004078EC
define fn00407915
{
	esp = fp;
	Top = null;
	--edx;
	SZO = cond(edx);
	al = __in<byte>(dx);
	++edi;
	eax->wF7014805 = (int16) *Top;
	fn0040791D();
}

// 0040791C: define fn0040791C
// Called from:
//      fn0040794A
define fn0040791C
{
	esp = fp;
	Top = 0;
	ecx = ~ecx;
	fn0040791D();
}

// 0040791D: define fn0040791D
// Called from:
//      fn00407563
//      fn0040791C
define fn0040791D
{
	esp = fp;
	Top = 0;
	v4 = (ecx->tFFFFFFE8.u1 & 0x01 << 0x20 - 0x01) != 0x00;
	ecx->tFFFFFFE8.u1 = (Eq_3871 (*)[]) __rcl<word32,byte>(ecx->tFFFFFFE8.u1, 0x01, C);
	v9 = eax->b0000 + al;
	eax->b0000 = v9;
	v11 = eax->b0000 + al;
	eax->b0000 = v11;
	SCZO = cond(v11);
	eax = (struct Eq_3567 *) *esp;
	esp = (struct Eq_3567 **) ((char *) esp + 4);
	esp -= 4;
	*esp = (struct Eq_3567 **) (struct Eq_3567 *) ~0x00905A4D;
	edx = (struct Eq_3567 *) *esp;
	esp = (struct Eq_3567 **) ((char *) esp + 4);
	edx = ~edx;
	fn00407563();
}

struct Eq_3567 g_t407924 = // 00407924
	{
		
		{
			~0x32
		},
		88,
	};
// 0040794A: define fn0040794A
// Called from:
//      Win32CrtStartup
define fn0040794A
{
	esp = fp;
	Top = 0;
	v5 = (cl & 0x01 << 0x08 - cl) != 0x00;
	cl = __rcl<byte,byte>(cl, cl, C);
	C = v5;
	fn0040794B();
}

// 0040794B: define fn0040794B
// Called from:
//      fn00407563
//      fn0040794A
define fn0040794B
{
	word32 ecx;
	byte al;
	Top_3 = 0;
	v4_5 = (ecx & 0x80000000) != 0x00;
	ecx_6 = __rol<word32,byte>(ecx, 0x01);
	__lock();
	al_9 = al - 0x2A - v4_5;
	SCZO_10 = cond(al_9);
	C_11 = SLICE(SCZO_10, bool, 1);
	O_12 = SLICE(SCZO_10, bool, 4);
	S_13 = (bool) SCZO_10;
	Z_14 = SLICE(SCZO_10, bool, 2);
}

