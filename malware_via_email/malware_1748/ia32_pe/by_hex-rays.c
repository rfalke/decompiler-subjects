/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// char __usercall start@<al>(int@<edx>, unsigned int _ECX@<ecx>, char@<bl>, int@<edi>, int@<esi>);


//----- (0040C996) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall start@<al>(int a1@<edx>, unsigned int _ECX@<ecx>, char a3@<bl>, int a4@<edi>, int a5@<esi>)
{
  bool v6; // cf
  bool v7; // zf
  signed int v11; // edi
  int v13; // ecx
  bool v18; // tt
  int v21; // esi
  int v23; // edx
  int v27; // esi
  int v30; // edi
  int v31; // esi
  char v32; // tt
  bool v34; // zf
  int v37; // ecx
  unsigned int v38; // ebx
  _BYTE *v39; // esi
  int v45; // edi
  int v46; // esi
  unsigned int v48; // edi
  unsigned int v50; // ecx
  unsigned int v52; // ebx
  int v56; // ecx
  bool v59; // zf

  LOBYTE(_ECX) = a3 | _ECX;
  HIWORD(_EAX) = HIWORD(a5);
  LOBYTE(a1) = (_BYTE)a1 << _ECX;
  LOBYTE(_ECX) = a5 + _ECX;
  LOBYTE(a1) = __ROR1__(a1, _ECX);
  BYTE1(_EAX) = BYTE1(a5) ^ 0xF5;
  LOBYTE(_EAX) = -(char)a5 << _ECX;
  BYTE1(_ECX) = 34;
  v46 = _EAX + __CFSHL__(-(char)a5, _ECX) + a5 + 1;
  __asm { rcr     al, cl }
  _ECX = _ECX >> _ECX;
  v6 = __CFSHL__(a4, _ECX);
  v48 = a4 << _ECX;
  BYTE1(_ECX) -= v6 - 47;
  v21 = v46 << --_ECX;
  v6 = __CFSHR__(BYTE1(a1), _ECX);
  BYTE1(a1) >>= _ECX;
  BYTE1(_ECX) <<= _ECX;
  LOWORD(_EAX) = __PAIR16__(BYTE1(_EAX) - 112 - (v6 + a1), __ROL1__(_EAX, _ECX)) & 0x7FF;
  __asm { rcr     ecx, cl }
  v23 = -a1;
  BYTE1(_ECX) += 57;
  LOBYTE(_EAX) = (_BYTE)_EAX << _ECX;
  v6 = __CFADD__(v21, v23);
  _EDX = (unsigned int *)(v21 + v23);
  LOBYTE(_ECX) = _ECX - (v6 + BYTE1(_EDX));
  v6 = __CFSHL__(BYTE1(_EAX), _ECX);
  BYTE1(_EAX) <<= _ECX;
  v31 = v21 - (v6 + _ECX);
  BYTE1(_EDX) = BYTE1(_EAX) + (BYTE1(_EDX) & 0xA9);
  LOBYTE(_EDX) = (_BYTE)_EDX + 6;
  v6 = __CFADD__((_BYTE)_EDX, BYTE1(_ECX));
  BYTE1(_ECX) += (_BYTE)_EDX;
  v32 = v6;
  v6 = __CFADD__(v6, BYTE1(_EAX));
  BYTE1(_EAX) += v32;
  v6 |= __CFADD__((_BYTE)_EAX, BYTE1(_EAX));
  BYTE1(_EAX) += _EAX;
  __asm { rcl     al, cl }
  _ESI = v31 - ((_DWORD)_EDX + v6);
  v18 = __CFSHL__(BYTE1(_EDX), _ECX);
  BYTE1(_EDX) = __ROL1__(BYTE1(_EDX), _ECX);
  _ECX = _ECX - (v18 + v48);
  _EDI = v48 >> _ECX;
  __asm { rcr     cl, cl }
  LOBYTE(_EAX) = _EAX + 1;
  LOBYTE(_ECX) = _ECX + 1;
  BYTE1(_EAX) = BYTE1(_EAX) - 10 - _ECX;
  _ECX = -_ECX;
  v6 = _ECX != 0;
  v7 = _ECX == 0;
  __asm { rcl     cl, cl }
  BYTE1(_ECX) = _ECX;
  if ( !v7 && v7 )
  {
    *(_BYTE *)_EDI = *(_BYTE *)_ESI;
    __outdword((unsigned __int16)_EDX, *_EDX);
    JUMPOUT(0x40C971);
  }
  LOBYTE(_EAX) = _EAX - (v6 - 112);
  __asm { rcl     eax, cl }
  BYTE1(_EDX) |= 0x90u;
  BYTE1(_EAX) = ~BYTE1(_EAX);
  __asm { rcr     ah, cl }
  _ECX = _ESI & _ECX;
  v34 = (_BYTE)_EAX == 0xB0;
  LOBYTE(_EAX) = _EAX + 80;
  if ( !(_BYTE)_EAX || !v34 )
  {
    _EDI = __ROR4__(_EDI, _ECX);
    _CL = -40;
    _ESI = _EDI - 1;
    __asm { rcr     edi, cl }
    _CL = 0x80;
    __asm
    {
      rcr     esi, cl
      rcl     edi, cl
      rcl     edi, cl
    }
    JUMPOUT(0x40C6B8);
  }
  LOBYTE(_EAX) = _EAX + 99;
  _EBX = -640493834;
  BYTE1(_EBX) = __ROR1__(-42, _ECX) - 26;
  __asm { rcl     edi, cl }
  ++BYTE1(_ECX);
  while ( 1 )
  {
    v37 = (unsigned int)_EDX ^ (_ECX >> _ECX);
    v38 = _ESI | (_EBX - 1);
    v39 = (_BYTE *)(_ESI - v37);
    v52 = v38 >> v37;
    LOBYTE(v37) = v52;
    LOBYTE(v52) = BYTE1(v37) & __ROL1__(v52, v52);
    BYTE1(v37) += 28;
    LOBYTE(v52) = -(v52 | 0x87);
    LOBYTE(v37) = -(char)v37;
    v11 = (((unsigned int)_EDX & (_EAX - _EDI)) - 1 - (unsigned int)_EDX) >> v37;
    LOBYTE(v37) = v37 + 40;
    _EBX = v37 | v52;
    BYTE1(v37) &= 0xEEu;
    v13 = (int)&v39[v37];
    SBYTE1(v13) >>= v13;
    LOBYTE(_EBX) = __ROL1__(_EBX, v13);
    _ECX = -v13;
    LOBYTE(_ECX) = _ECX | 0x5D;
    v45 = v11 >> _ECX;
    LOBYTE(_EBX) = __GS__ | _EBX;
    BYTE1(_ECX) -= ((unsigned __int8)_EBX < (unsigned __int8)_EDX) + __GS__;
    LOBYTE(_EBX) = __ROR1__(_EBX - (_BYTE)_EDX, _ECX);
    BYTE1(_EBX) = -73 << _ECX << _ECX;
    __asm { rcl     ebx, cl }
    v50 = __ROR4__(_ECX, _ECX);
    LOBYTE(_EBX) = (unsigned __int8)_EBX >> v50;
    BYTE1(v50) = -BYTE1(v50);
    LOBYTE(v50) = v50 ^ 6;
    _EDI = v45 - v50;
    LOBYTE(_EBX) = _EBX ^ 0x17;
    LOBYTE(v50) = ~(_BYTE)v50;
    BYTE1(v50) += BYTE1(_EDX) + __CFSHR__(v39, v50);
    v27 = _EBX;
    _EDX = (unsigned int *)((char *)_EDX + 1);
    BYTE1(v50) &= ~0x10u;
    _ECX = v50 >> v50;
    __asm { rcr     edi, cl }
    v30 = _EDI << _ECX;
    BYTE1(_EBX) = (_BYTE)_EDX;
    _EBX = v27 & _EBX;
    BYTE1(_ECX) -= ((unsigned __int8)_EBX < __GS^1__) + 118;
    LOBYTE(_EBX) = -22;
    LOBYTE(_ECX) = BYTE1(_EBX) & _ECX;
    _EDI = v30 << _ECX << _ECX;
    v56 = _ECX << _ECX;
    _ECX = v56 - 1;
    __asm { rcr     ecx, cl }
    _ESI = _EDI | v27;
    v59 = _ESI == 0;
    __asm { rcl     esi, cl }
    _ECX = __ROR4__(_ECX, _ECX);
    BYTE1(_EBX) = -71;
    if ( !v59 && v59 )
    {
      __readeflags();
      JUMPOUT(0x40C839);
    }
    if ( _EDX == (unsigned int *)20012482 )
      break;
    LOBYTE(_EBX) = -22 << _ECX;
    v6 = _EBX < (unsigned int)__CFSHL__(-22, _ECX) + _ECX;
    _EBX = _EBX - (__CFSHL__(-22, _ECX) + _ECX);
    BYTE1(_ECX) -= v6 - 71;
    __asm { rcr     ebx, cl }
    BYTE1(_ECX) = (unsigned __int8)_EDX | (BYTE1(_ECX) - 49);
    LOBYTE(_ECX) = _ECX + 107;
    _ECX = _ECX - 1;
    _EAX = __ROR4__(__GS__, 1);
    if ( !(__GS__ & 1) )
    {
      __asm { rcr     bh, cl }
      _EDI = _EDI + 1;
      _CL = _EAX + ((_BYTE)_ECX << _ECX) - 19;
      __asm { rcr     edi, cl }
      JUMPOUT(0x40C726);
    }
  }
  BYTE1(_EBX) = -5;
  _ECX = (_ECX - 20012482) << (_ECX + 62);
  __asm
  {
    rcr     ebx, cl
    rcl     dh, cl
  }
  return BYTE1(_EBX);
}
// 40C60A: positive sp value 4 has been found
// 40C00C: control flows out of bounds to 40C012
// 40C061: control flows out of bounds to 40C063
// 40C066: inconsistent fpu stack
// 40C06B: control flows out of bounds to 40C06E
// 40C110: control flows out of bounds to 40C116
// 40C146: control flows out of bounds to 40C147
// 40C18B: control flows out of bounds to 40C18D
// 40C1B2: control flows out of bounds to 40C1B3
// 40C218: control flows out of bounds to 40C21A
// 40C247: control flows out of bounds to 40C248
// 40C345: control flows out of bounds to 40C346
// 40C377: control flows out of bounds to 40C379
// 40C517: control flows out of bounds to 40C51D
// 40C544: control flows out of bounds to 40C545
// 40C64F: control flows out of bounds to 40C650
// 40C838: control flows out of bounds to 40C839
// 40C912: control flows out of bounds to 40C918
// 40C983: control flows out of bounds to 40C986
// 40BF03: control flows out of bounds to 40C3D4
// 40BF4C: control flows out of bounds to C7CB9F48
// 40BFEA: control flows out of bounds to 40C421
// 40C2A7: control flows out of bounds to 40C67C
// 40C4BC: control flows out of bounds to 40C726
// 40C628: control flows out of bounds to 40C6FB
// 40BF27: control flows out of bounds to 40BF40
// 40C095: control flows out of bounds to 40C971
// 40C17B: control flows out of bounds to 40BF4B
// 40C1AA: control flows out of bounds to 40C16D
// 40C317: control flows out of bounds to 40BF2B
// 40C373: control flows out of bounds to 40C394
// 40C375: control flows out of bounds to 40C3AD
// 40C40D: control flows out of bounds to 40C858
// 40C6F6: control flows out of bounds to 1B55F1B4
// 40C857: control flows out of bounds to 40C82C
// 40C89E: control flows out of bounds to 40C842
// 40C8D8: control flows out of bounds to 40C865
// 40C90A: control flows out of bounds to 40C6B8
// 40BF3F: conditional instruction was optimized away because eax.4!=0
// 40BFC9: conditional instruction was optimized away because eax.4!=0
// 40C09D: conditional instruction was optimized away because ch.1!=0
// 40C161: conditional instruction was optimized away because edi.4!=0
// 40C212: conditional instruction was optimized away because ah.1!=0
// 40C390: conditional instruction was optimized away because ah.1!=0
// 40C455: conditional instruction was optimized away because edi.4!=0
// 40C517: conditional instruction was optimized away because bh.1!=0
// 40C57C: conditional instruction was optimized away because ecx.4!=0
// 40C7DD: conditional instruction was optimized away because edi.4!=0
// 40C93E: conditional instruction was optimized away because dh.1!=0

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
