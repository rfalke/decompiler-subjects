// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_26 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 ebx_15 = null;
	word32 edi_261 = eax_26 + 0x1E;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		edi_261 = eax_26 + 0x1E ^ 0x0E;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x28);
	struct Eq_49 * esp_50 = fp - 0x48;
	struct Eq_52 * eax_53 = null;
	do
	{
		if (ebx_15 == edi_261)
			ebx_15 = null;
		eax_53[4199048] = (struct Eq_52) (eax_53[4199048] ^ ebx_15[0x00404000]);
		eax_53 = eax_53 + 0x01;
		ebx_15 = (Eq_17) (ebx_15 + 0x01);
	} while (eax_53 < (struct Eq_52 *) 0x1440);
	struct Eq_75 * ecx_117 = &globals->t402588;
	uint32 esi_113 = 0x00;
	uint32 dwLoc34_115 = 0x00;
	do
	{
		Eq_83 eax_101 = ecx_117->t0004;
		word16 * edx_107 = (char *) &ecx_117->t0004 + 0x04;
		if (eax_101 - 0x08 >> 0x01 > 0x00)
		{
			uint32 edi_235 = eax_101 - 0x08 >> 0x01;
			do
			{
				ui32 eax_238 = (word32) *edx_107;
				if ((eax_238 & 0xF000) == 0x3000)
				{
					struct Eq_104 * eax_252 = (eax_238 & 0x0FFF) + ecx_117->dw0000;
					eax_252->dw401008 = eax_252->dw401008 + 0xF0401008;
				}
				edx_107 = edx_107 + 0x01;
				edi_235 = edi_235 - 0x01;
			} while (edi_235 != 0x00);
			esi_113 = dwLoc34_115;
		}
		esi_113 = (word32) ecx_117->t0004 + esi_113;
		dwLoc34_115 = esi_113;
		ecx_117 = ecx_117 + Mem77[ecx_117 + 0x04:word32];
	} while (esi_113 < 232);
	struct Eq_128 * esi_121 = &globals->t401D6C;
	if (globals->dw401D7C != 0x00)
	{
		esi_150 = esi_121;
		esp_152 = esp_50;
		do
		{
			struct Eq_128 * esi_150;
			struct Eq_49 * esp_152;
			esp_152 = esp_152 - 0x04;
			esp_152->dw0000 = esi_150->dw000C + 0x00401008;
			Eq_176 eax_157 = LoadLibraryA(esp_152->dw0000);
			if (eax_157 != null)
			{
				word32 edi_178 = esi_150->dw0000;
				if (edi_178 == 0x00)
					edi_178 = esi_150->dw0010;
				word32 * edi_183 = edi_178 + 0x00401008;
				word32 * esi_186 = esi_150->dw0010 + 0x00401008;
				if (*edi_183 != 0x00)
				{
					do
					{
						word32 * esp_218;
						int32 eax_211 = *edi_183;
						word16 ax_212 = (word16) eax_211;
						if (eax_211 < 0x00)
						{
							esp_218 = esp_152 - 0x04;
							*esp_218 = (word32) ax_212;
						}
						else
						{
							esp_218 = esp_152 - 0x04;
							*esp_218 = eax_211 + 0x0040100A;
						}
						esp_152 = esp_218 - 0x04;
						esp_152->dw0000 = (word32) eax_157;
						*esi_186 = (word32) GetProcAddress(esp_152->dw0000, esp_152[0x01]);
						edi_183 = edi_183 + 0x01;
						esi_186 = esi_186 + 0x01;
					} while (*edi_183 != 0x00);
				}
				esi_150 = (struct Eq_128 *) esp_152[0x05];
			}
			esi_150 = esi_150 + 0x01;
			esp_152[0x05] = (struct Eq_49) esi_150;
		} while (esi_150->dw0010 != 0x00);
	}
	ptr32 esp_127;
	byte SCZO_128;
	word32 ebx_129;
	word32 ebp_130;
	word32 esi_131;
	word32 edi_132;
	byte SZO_133;
	byte C_134;
	word32 eax_135;
	word32 edx_136;
	byte Z_137;
	word32 ecx_138;
	byte cl_139;
	byte S_140;
	word16 ax_141;
	globals->t401A68();
	*(esp_127 - 0x04) = 0x00;
	ExitProcess(*(esp_127 - 0x04));
}

