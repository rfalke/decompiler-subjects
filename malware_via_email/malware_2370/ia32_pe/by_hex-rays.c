/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_401000();
int __stdcall sub_401017(_BYTE *);
int __stdcall start(HMODULE, unsigned __int64);
int __fastcall sub_4010B5(int, int);
// char *__usercall sub_401123@<eax>(int *@<ebx>);
_BYTE *__stdcall sub_4011EA(int, int);
unsigned int __stdcall sub_401339(int, int, int);
int __stdcall sub_4013AE(int, SIZE_T dwSize, int, int); // idb
int __stdcall sub_4014DC(HMODULE, int, int, int);
int __fastcall sub_40175F(int, _BYTE *);
int __stdcall sub_4017C7(int);
LPVOID __stdcall sub_40188A(int, SIZE_T dwSize);
// int __userpurge sub_401956@<eax>(int@<eax>, int);
void *__stdcall sub_401A31(LPVOID lpAddress, SIZE_T dwSize, int);
unsigned int __stdcall sub_401AA2(unsigned int);
// int __stdcall LoadAlterBitmap(_DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern void *(__cdecl *memcpy)(void *, const void *Src, size_t Size);


//----- (00401000) --------------------------------------------------------
int sub_401000()
{
  unsigned int v0; // kr00_4
  unsigned __int64 v1; // rax
  unsigned int v3; // [esp-Ch] [ebp-Ch]

  v0 = __readeflags();
  v3 = v0;
  v1 = __rdtsc();
  return __ROL4__(v3 + v1 * HIDWORD(v1), v1 & 0xF) ^ v1;
}

//----- (00401017) --------------------------------------------------------
int __stdcall sub_401017(_BYTE *a1)
{
  int i; // ecx

  for ( i = 0; *a1++ != 0; ++i )
    ;
  return i;
}

//----- (0040103C) --------------------------------------------------------
int __stdcall start(HMODULE a1, unsigned __int64 a2)
{
  HANDLE MutexW; // esi
  int v3; // eax

  LoadAlterBitmap(0, 0, 0);
  if ( a2 >= 4 || (_WORD)a1 )
  {
    sub_4014DC(0, 41, 0, 0);
    ExitThread(0);
  }
  MutexW = CreateMutexW(0, 0, 0);
  v3 = SetErrorMode(2u);
  return sub_4014DC(a1, a2, v3, (int)MutexW);
}
// 4070C8: using guessed type int __stdcall LoadAlterBitmap(_DWORD, _DWORD, _DWORD);

//----- (004010B5) --------------------------------------------------------
int __fastcall sub_4010B5(int a1, int a2)
{
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // edi
  unsigned int i; // esi
  int v6; // esi
  unsigned int j; // edx

  v2 = *(_DWORD *)(a2 + *(_DWORD *)(a2 + 60) + 120);
  if ( v2 )
  {
    v3 = (_DWORD *)(a2 + v2);
    v3[7] += a1;
    v3[9] += a1;
    v3[8] += a1;
    v3[3] += a1;
    v4 = v3[7] + a2;
    for ( i = 0; i < v3[5]; ++i )
      *(_DWORD *)(v4 + 4 * i) += a1;
    v6 = a2 + v3[8];
    for ( j = 0; j < v3[6]; ++j )
      *(_DWORD *)(v6 + 4 * j) += a1;
  }
  return 1;
}

//----- (00401123) --------------------------------------------------------
char *__usercall sub_401123@<eax>(int *a1@<ebx>)
{
  int v1; // ecx
  int v2; // eax
  char *result; // eax
  bool v4; // zf
  int v5; // [esp+4h] [ebp-Ch]
  _DWORD *v6; // [esp+8h] [ebp-8h]
  char *v7; // [esp+Ch] [ebp-4h]

  v1 = *a1;
  a1[10] = 0;
  v6 = (_DWORD *)(v1 + *(_DWORD *)(*(_DWORD *)(v1 + 60) + v1 + 16));
  qmemcpy(a1 + 1, v6 + 3, 0x24u);
  v2 = a1[1];
  a1[5] -= v2;
  a1[7] += v2;
  a1[3] += -8 * v2;
  a1[6] += -16 * v2;
  a1[4] += -2 * v2;
  result = (char *)VirtualAlloc(0, a1[4] + 36, 0x3000u, 0x40u);
  a1[10] = (int)result;
  v7 = result;
  v5 = 4;
  do
  {
    qmemcpy(v7, v6 + 3, v6[2]);
    result += v6[2];
    v4 = v5-- == 1;
    v7 = result;
    v6 = (_DWORD *)(*a1 + *v6);
  }
  while ( !v4 );
  a1[10] += 11;
  a1[10] += 25;
  return result;
}

//----- (004011EA) --------------------------------------------------------
_BYTE *__stdcall sub_4011EA(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // esi
  _DWORD *v6; // esi
  int v7; // ebx
  int v8; // edi
  int v9; // eax
  int v10; // ebx
  int v11; // edi
  unsigned int v12; // edx
  int v13; // edi
  int v14; // edx
  bool v15; // cf
  bool v16; // zf
  _BYTE *v17; // edi
  size_t v18; // esi
  int v19; // ecx
  HMODULE LibraryA; // ebx
  int v21; // eax
  char LibFileName[234]; // [esp+0h] [ebp-110h] BYREF
  int v23; // [esp+104h] [ebp-Ch]
  int v24; // [esp+108h] [ebp-8h]
  int v25; // [esp+10Ch] [ebp-4h]

  v2 = a1;
  v3 = a1 + *(_DWORD *)(a1 + 60);
  v4 = *(_DWORD *)(v3 + 120);
  if ( !v4 )
    return 0;
  v6 = (_DWORD *)(a1 + v4);
  v7 = v6[8];
  v8 = v6[7];
  v23 = *(_DWORD *)(v3 + 124);
  v9 = a1 + v6[9];
  v10 = a1 + v7;
  v11 = a1 + v8;
  v24 = v9;
  if ( a2 >= 0 )
  {
    v14 = 0;
    v15 = v6[6] != 0;
    v16 = v6[6] == 0;
    v25 = 0;
    if ( v15 )
    {
      while ( a2 != sub_40175F(v2, (_BYTE *)(v2 + *(_DWORD *)(v10 + 4 * v14))) )
      {
        if ( (unsigned int)++v25 >= v6[6] )
          break;
        v2 = a1;
        v14 = v25;
      }
      v14 = v25;
      v2 = a1;
      v9 = v24;
      v16 = v25 == v6[6];
    }
    if ( v16 )
      return 0;
    v13 = *(_DWORD *)(v11 + 4 * *(unsigned __int16 *)(v9 + 2 * v14));
  }
  else
  {
    v12 = (a2 & 0x7FFFFFFF) - v6[4];
    if ( v12 >= v6[5] )
      return 0;
    v13 = *(_DWORD *)(v11 + 4 * v12);
  }
  v17 = (_BYTE *)(v2 + v13);
  if ( v17 < (_BYTE *)v6 + v23 && v17 >= (_BYTE *)v6 )
  {
    v18 = 0;
    if ( *v17 != 46 )
    {
      do
        ++v18;
      while ( v17[v18] != 46 );
    }
    memcpy(LibFileName, v17, v18);
    LibFileName[v18] = 0;
    LibraryA = LoadLibraryA(LibFileName);
    if ( !LibraryA )
      return 0;
    v21 = sub_40175F(v19, &v17[v18 + 1]);
    return sub_4011EA((int)LibraryA, v21);
  }
  return v17;
}
// 401322: variable 'v19' is possibly undefined
// 4011EA: using guessed type CHAR LibFileName[234];

//----- (00401339) --------------------------------------------------------
unsigned int __stdcall sub_401339(int a1, int a2, int a3)
{
  unsigned int result; // eax
  int v5; // eax
  unsigned int v6; // [esp+4h] [ebp-4h]
  int *v7; // [esp+14h] [ebp+Ch]

  v6 = 0;
  result = *(unsigned __int16 *)(a2 + 12) + *(unsigned __int16 *)(a2 + 14);
  if ( result )
  {
    v7 = (int *)(a2 + 20);
    do
    {
      v5 = *v7;
      if ( *v7 >= 0 )
        *(_DWORD *)(a1 + v5) += a3;
      else
        sub_401339(a1, a1 + (v5 & 0x7FFFFFFF), a3);
      ++v6;
      v7 += 2;
      result = *(unsigned __int16 *)(a2 + 12) + *(unsigned __int16 *)(a2 + 14);
    }
    while ( v6 < result );
  }
  return result;
}

//----- (004013AE) --------------------------------------------------------
int __stdcall sub_4013AE(int a1, SIZE_T dwSize, int a3, int a4)
{
  char *v5; // eax
  char *v6; // esi
  _BYTE *v7; // edi
  SIZE_T v8; // ecx
  unsigned __int8 v9; // dl
  char v10; // al
  SIZE_T v11; // edx
  unsigned __int8 *v12; // eax
  int v13; // ecx
  char v14[259]; // [esp+0h] [ebp-108h] BYREF
  unsigned __int8 v15; // [esp+103h] [ebp-5h]
  LPVOID lpAddress; // [esp+104h] [ebp-4h]

  lpAddress = v14;
  memset(v14, 0, 0x100u);
  lpAddress = VirtualAlloc(0, dwSize, 0x3000u, 0x40u);
  if ( !lpAddress )
    return 0;
  do
  {
    v15 = sub_401000();
    v5 = &v14[v15];
    if ( !*v5 )
    {
      *v5 = 1;
      qmemcpy(lpAddress, (const void *)a1, dwSize);
      v6 = (char *)lpAddress;
      v7 = lpAddress;
      v8 = dwSize;
      v9 = v15;
      do
      {
        v10 = *v6++;
        *v7++ = v9 ^ v10;
        v9 = __ROL1__(v8-- + v9, 3);
      }
      while ( v8 );
    }
    v11 = dwSize;
    v12 = (unsigned __int8 *)lpAddress;
    v13 = 987652120;
    do
    {
      v13 = *v12++ ^ (33 * v13);
      --v11;
    }
    while ( v11 );
  }
  while ( v13 != a4 );
  qmemcpy((void *)a1, lpAddress, dwSize);
  VirtualAlloc(0, 0, 0x3000u, 0x40u);
  VirtualFree(lpAddress, 0, 0x8000u);
  return 1;
}

//----- (004014DC) --------------------------------------------------------
int __stdcall sub_4014DC(HMODULE a1, int a2, int a3, int a4)
{
  HMODULE ModuleHandleA; // eax
  void *v5; // eax
  void *v6; // ebx
  _DWORD *v8; // edi
  int v9; // esi
  char *v10; // ebx
  char *v11; // esi
  int v12; // edi
  unsigned int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  char *v17; // ecx
  bool v18; // cc
  _DWORD *v19; // eax
  __int16 v20; // ax
  unsigned int v21; // edx
  char *v22; // esi
  char *v23; // eax
  void *v24[3]; // [esp+7Ch] [ebp-54h] BYREF
  SIZE_T v25; // [esp+88h] [ebp-48h]
  SIZE_T dwSize; // [esp+8Ch] [ebp-44h]
  SIZE_T v27; // [esp+90h] [ebp-40h]
  int v28; // [esp+98h] [ebp-38h]
  int v29; // [esp+9Ch] [ebp-34h]
  int v30; // [esp+A0h] [ebp-30h]
  const void *v31; // [esp+A4h] [ebp-2Ch]
  int v32; // [esp+ACh] [ebp-24h]
  unsigned int *v33; // [esp+B0h] [ebp-20h]
  DWORD flOldProtect; // [esp+B4h] [ebp-1Ch] BYREF
  LPVOID lpAddress; // [esp+B8h] [ebp-18h]
  char *v36; // [esp+BCh] [ebp-14h]
  char *v37; // [esp+C0h] [ebp-10h]
  unsigned int v38; // [esp+C4h] [ebp-Ch]
  _DWORD *v39; // [esp+C8h] [ebp-8h]
  _BYTE *v40; // [esp+CCh] [ebp-4h]

  if ( a4 )
    ModuleHandleA = a1;
  else
    ModuleHandleA = GetModuleHandleA(0);
  v24[0] = ModuleHandleA;
  if ( !a4 || a2 == 1 )
  {
    sub_401123((int *)v24);
    lpAddress = (LPVOID)(dwSize != v25);
    v5 = VirtualAlloc(0, dwSize, 0x3000u, 0x40u);
    v6 = v5;
    v33 = (unsigned int *)v5;
    if ( !v5 )
      return 0;
    qmemcpy(v33, v31, dwSize);
    sub_4013AE((int)v5, dwSize, v29, v30);
    dwSize -= v28;
    if ( lpAddress )
    {
      v8 = sub_401A31(v6, v25, (int)v6 + dwSize);
      lpAddress = v8;
    }
    else
    {
      lpAddress = v6;
      v8 = v6;
    }
    if ( !v8 )
      return 0;
    v9 = v8[15];
    v33 = (_DWORD *)((char *)v8 + v27);
    v10 = (char *)v24[0] + *((_DWORD *)v24[0] + 15);
    v36 = &v10[*((unsigned __int16 *)v10 + 10) + 24];
    v11 = (char *)v8 + v9;
    v37 = &v11[*((unsigned __int16 *)v11 + 10) + 24];
    VirtualProtect(v10, 1u, 4u, &flOldProtect);
    v40 = sub_40188A((int)v8, v27);
    v12 = v40 - (_BYTE *)v24[0];
    v13 = 0;
    v32 = v40 - (_BYTE *)v24[0];
    if ( a4 && (v14 = *((_DWORD *)v11 + 30)) != 0 )
    {
      *((_DWORD *)v10 + 30) = v12 + v14;
    }
    else
    {
      *((_DWORD *)v10 + 30) = 0;
      *((_DWORD *)v10 + 31) = 0;
    }
    v15 = *((_DWORD *)v11 + 34);
    if ( v15 )
    {
      *((_DWORD *)v10 + 34) = v12 + v15;
      v16 = *((_DWORD *)v10 + 34);
      *((_DWORD *)v10 + 35) = *((_DWORD *)v11 + 35);
      sub_401339((int)v24[0] + v16, (int)v24[0] + v16, v12);
      *((_DWORD *)v10 + 20) = -1 - (unsigned int)v24[0];
    }
    v17 = &v40[-*((_DWORD *)v11 + 13)];
    v18 = *v33 <= v13;
    v38 = v13;
    if ( !v18 )
    {
      v39 = v33 + 1;
      do
      {
        v19 = &v40[*v39];
        v39 = (_DWORD *)((char *)v39 + 1);
        v39 = (_DWORD *)((char *)v39 + 3);
        *v19 += v17;
        ++v38;
      }
      while ( v38 < *v33 );
    }
    if ( !sub_4017C7((int)v40) || !sub_401956((int)v40, (int)v40) )
      return 0;
    if ( a4 )
      sub_4010B5(v12, (int)v24[0]);
    *((_DWORD *)v10 + 10) = v12 + *((_DWORD *)v11 + 10);
    v20 = *((_WORD *)v11 + 3);
    v21 = 0;
    *((_WORD *)v10 + 3) = v20;
    if ( v20 )
    {
      do
      {
        v22 = v37;
        v23 = v36;
        v37 += 16;
        v37 += 24;
        qmemcpy(v36, v22, 0x28u);
        *((_DWORD *)v23 + 3) += v32;
        v36 = v23 + 40;
        ++v21;
      }
      while ( v21 < *((unsigned __int16 *)v10 + 3) );
    }
    VirtualFree(lpAddress, 0, 0x8000u);
  }
  return ((int (__stdcall *)(int, HMODULE, int, int))((char *)v24[0]
                                                    + *(_DWORD *)((char *)v24[0] + *((_DWORD *)v24[0] + 15) + 40)))(
           a4,
           a1,
           a2,
           a3);
}
// 401660: variable 'v13' is possibly undefined
// 4014DC: using guessed type HMODULE var_54[3];

//----- (0040175F) --------------------------------------------------------
int __fastcall sub_40175F(int a1, _BYTE *a2)
{
  _BYTE *v2; // edx
  unsigned __int16 v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  v4 = sub_401017(a2);
  while ( *v2 )
    v5 = *(unsigned __int16 *)v2++ + 65599 * v5;
  if ( v5 < 0 )
    return (v4 ^ 0x5AC0 ^ v5) & 0x7FFFFFFF;
  return v5;
}
// 401779: variable 'v2' is possibly undefined

//----- (004017C7) --------------------------------------------------------
int __stdcall sub_4017C7(int a1)
{
  int v1; // edi
  int v2; // eax
  int v4; // ebx
  _DWORD *v5; // eax
  int v6; // esi
  int *v7; // esi
  int *v8; // edi
  _BYTE *v9; // eax
  HMODULE LibraryA; // [esp+8h] [ebp-Ch]
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+10h] [ebp-4h]

  v1 = a1;
  v2 = *(_DWORD *)(a1 + *(_DWORD *)(a1 + 60) + 128);
  if ( !v2 )
    return 1;
  v11 = 0;
  v4 = v2 + a1;
  v5 = (_DWORD *)(v2 + a1 + 12);
  if ( !*v5 )
    return 1;
  v6 = v4;
  while ( 1 )
  {
    LibraryA = LoadLibraryA((LPCSTR)(v1 + *v5));
    if ( !LibraryA )
      return 0;
    v12 = 0;
    v7 = (int *)(v1 + *(_DWORD *)(v6 + 16));
    if ( *v7 )
    {
      v8 = v7;
      while ( 1 )
      {
        v9 = sub_4011EA((int)LibraryA, *v8);
        if ( !v9 )
          return 0;
        ++v12;
        *v8 = (int)v9;
        v8 = &v7[v12];
        if ( !*v8 )
        {
          v1 = a1;
          break;
        }
      }
    }
    ++v11;
    v6 = 20 * v11 + v4;
    v5 = (_DWORD *)(v6 + 12);
    if ( !*(_DWORD *)(v6 + 12) )
      return 1;
  }
}

//----- (0040188A) --------------------------------------------------------
LPVOID __stdcall sub_40188A(int a1, SIZE_T dwSize)
{
  unsigned int i; // esi
  void *v3; // eax
  unsigned int v4; // ebx
  void *v5; // ebx
  LPVOID result; // eax
  void *lpAddress[256]; // [esp+1Eh] [ebp-404h]

  for ( i = 0; i < 0x100; ++i )
  {
    v3 = VirtualAlloc(0, dwSize, 0x2000u, 4u);
    lpAddress[i] = v3;
    if ( !v3 )
      return 0;
  }
  v4 = sub_401AA2(i);
  do
  {
    if ( i != v4 )
      VirtualFree(lpAddress[i], 0, 0x8000u);
    --i;
  }
  while ( i );
  v5 = lpAddress[v4];
  result = VirtualAlloc(v5, dwSize, 0x1000u, 4u);
  if ( result )
  {
    qmemcpy(v5, (const void *)a1, dwSize);
    return v5;
  }
  return result;
}
// 4018E4: conditional instruction was optimized away because esi.4>=100u
// 40188A: using guessed type LPVOID lpAddress[256];

//----- (00401956) --------------------------------------------------------
int __userpurge sub_401956@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  bool v3; // zf
  int v4; // eax
  int *i; // edi
  int v6; // ecx
  DWORD v7; // eax
  unsigned int v8; // eax
  int v10; // [esp+4Ch] [ebp-18h]
  DWORD flOldProtect; // [esp+5Ch] [ebp-8h] BYREF
  int v12; // [esp+60h] [ebp-4h]

  v2 = a1 + *(_DWORD *)(a1 + 60);
  flOldProtect = 0;
  v3 = *(_WORD *)(v2 + 6) == 0;
  v4 = *(unsigned __int16 *)(v2 + 20) + v2 + 24;
  v12 = 0;
  if ( v3 )
    return 1;
  for ( i = (int *)(v4 + 36); ; i += 10 )
  {
    v6 = *i;
    v7 = 0;
    if ( (*i & 0x20000000) != 0 )
    {
      v7 = v6 < 0 ? 64 : 32;
      goto LABEL_10;
    }
    if ( v6 >= 0 )
    {
      if ( (v6 & 0x40000000) == 0 )
        goto LABEL_10;
      v10 = 2;
    }
    else
    {
      v10 = 4;
    }
    v7 = v10;
LABEL_10:
    if ( (v6 & 0x4000000) != 0 )
      v7 |= 0x200u;
    if ( v7 && !VirtualProtect((LPVOID)(a2 + *(i - 6)), *(i - 7), v7, &flOldProtect) )
      break;
    v8 = *(unsigned __int16 *)(v2 + 6);
    if ( ++v12 >= v8 )
      return 1;
  }
  return 0;
}

//----- (00401A31) --------------------------------------------------------
void *__stdcall sub_401A31(LPVOID lpAddress, SIZE_T dwSize, int a3)
{
  void *v3; // edi
  int v4; // eax

  v3 = VirtualAlloc(0, dwSize, 0x3000u, 0x40u);
  v4 = ((int (__stdcall *)(LPVOID, void *))a3)(lpAddress, v3);
  if ( v4 == -1 || v4 != dwSize )
  {
    VirtualFree(v3, 0, 0x8000u);
    VirtualFree(lpAddress, 0, 0x8000u);
    return 0;
  }
  else
  {
    VirtualFree(lpAddress, 0, 0x8000u);
    return v3;
  }
}

//----- (00401AA2) --------------------------------------------------------
unsigned int __stdcall sub_401AA2(unsigned int a1)
{
  if ( a1 )
    return sub_401000() % a1;
  else
    return 0;
}

// nfuncs=15 queued=15 decompiled=15 lumina nreq=0 worse=0 better=0
// ALL OK, 15 function(s) have been successfully decompiled
