// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw402000 = 0x00; // 00402000
int32 g_dw402004 = 0; // 00402004
ui32 g_dw402008 = 0x00; // 00402008
word32 g_dw40200C = 0x00; // 0040200C
byte g_b402010 = 0x00; // 00402010
byte g_b402011 = 0x00; // 00402011
struct Eq_2 * g_ptr402100 = null; // 00402100
struct Eq_411 * g_ptr402104 = null; // 00402104
Eq_268 g_t402108 = // 00402108
	{
		0
	};
int32 g_dw40210C = 0; // 0040210C
Eq_427 g_t402110 = // 00402110
	{
		0
	};
word32 g_dw402114 = 0x00; // 00402114
ptr32 g_ptr402118 = 0x00; // 00402118
byte g_b40211C = 0x00; // 0040211C
struct Eq_721 * g_ptr402124 = null; // 00402124
Eq_3 g_t402128 = // 00402128
	{
		null
	};
// subject_rsrc.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw405074 = 17355; // 00405074
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__CreateThread = &g_t166C; // 00401000
<anonymous> * __imp__GetCurrentThread = &g_t167C; // 00401004
<anonymous> * __imp__GetProcAddress = &g_t1690; // 00401008
<anonymous> * __imp__GetThreadContext = &g_t16A2; // 0040100C
<anonymous> * __imp__HeapAlloc = &g_t16B6; // 00401010
<anonymous> * __imp__HeapCreate = &g_t16C2; // 00401014
<anonymous> * __imp__LoadLibraryA = &g_t16D0; // 00401018
<anonymous> * __imp__ResumeThread = &g_t16E0; // 0040101C
<anonymous> * __imp__SuspendThread = &g_t16F0; // 00401020
<anonymous> * __imp__VirtualAlloc = &g_t1700; // 00401024
// 00401030: Register (ptr32 Eq_2) fn00401030(Stack Eq_3 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack word32 dwArg0C, Register out Eq_3 edxOut)
// Called from:
//      fn0040105A
//      fn004010FD
struct Eq_2 * fn00401030(Eq_3 dwArg04, struct Eq_2 * dwArg08, word32 dwArg0C, union Eq_3 & edxOut)
{
	struct Eq_2 * eax_11 = dwArg08;
	Eq_3 edx_12 = dwArg04;
	word32 ecx_13 = dwArg0C;
	if (dwArg0C != 0x00)
	{
		do
		{
			edx_12.u0->b0000 = eax_11->b0000;
			++eax_11;
			&edx_12.u0->b0000 = (word32) edx_12 + 1;
			--ecx_13;
		} while (ecx_13 != 0x00);
	}
	edxOut = edx_12;
	return eax_11;
}

<anonymous> g_t40104F = <code>; // 0040104F
// 0040105A: Register word32 fn0040105A()
// Called from:
//      fn0040153D
word32 fn0040105A()
{
	struct Eq_2 * ebx_18 = g_ptr402100;
	word32 edx_23 = ebx_18 + Mem21[ebx_18 + 60:word32];
	g_t402128.u0 = edx_23->t0034.u0;
	word32 dwLoc08_115 = (word32) edx_23->b0006;
	Eq_3 eax_43 = VirtualAlloc(edx_23->t0034.u0, edx_23->t0050, 0x3000, 0x40);
	word32 edx_136;
	fn00401030(eax_43, g_ptr402100, edx_23->dw0054, out edx_136);
	struct Eq_70 * edi_63 = &edx_23->dw0054 + 41;
	do
	{
		word32 v20_95 = dwLoc08_115 - 0x01;
		word32 edx_85;
		word32 eax_83 = fn00401030(eax_43.u0 + edi_63->dw000C, g_ptr402100 + edi_63->dw0014, edi_63->dw0010, out edx_85);
		++edi_63;
		dwLoc08_115 = v20_95;
	} while (v20_95 != 0x00);
	word32 eax_106;
	g_t40104F();
	return eax_106;
}

// 004010D8: void fn004010D8(Stack (ptr32 byte) dwArg04, Stack word32 dwArg08)
// Called from:
//      fn004010FD
void fn004010D8(byte * dwArg04, word32 dwArg08)
{
	byte * ecx_10 = dwArg04;
	word32 edx_23 = dwArg08;
	do
	{
		*ecx_10 += 0x04;
		--*ecx_10;
		*ecx_10 += 0x2F;
		++*ecx_10;
		++ecx_10;
		--edx_23;
	} while (edx_23 != 0x00);
	g_dw402008 += 0x04;
}

// 004010FD: void fn004010FD()
// Called from:
//      Win32CrtStartup
void fn004010FD()
{
	ui32 ecx_18 = g_dw405074;
	g_dw402000 = ecx_18;
	g_dw402004 = 0x00;
	g_dw402004 += ecx_18 << 0x03;
	ui32 eax_37 = fn000016C2(4144608, 0x01, 0x00, 0x00);
	ui32 ebx_42 = g_dw402000;
	esp_36->dwFFFFFFF8 |= 0x08;
	esp_36->dwFFFFFFF4 |= eax_37;
	ui32 eax_63 = fn000016C2(0x02, 0x04, 0x08, 0x00, 0x00, ebx_42);
	esp_62->dw0000 = ecx_64;
	ui32 esi_17 = 0x00405088;
	ui32 ecx_73 = g_dw402000 + g_dw40200C;
	do
	{
		++g_dw40200C;
		--ecx_73;
	} while (ecx_73 != 0x00);
	g_dw402008 = ecx_73 | eax_63;
	esp_62->dw0000 = g_dw402000;
	struct Eq_195 * esp_91 = esp_62;
	word32 ecx_100;
	for (ecx_100 = 0x02; ecx_100 != 0x00; --ecx_100)
	{
		esp_91 -= 4;
		esp_91->dw0000 = esi_17;
		esi_17 = g_dw402008;
	}
	word32 edx_151;
	fn00401030(esp_91->dw0000, esp_91[1], esp_91[2], out edx_151);
	esp_91[2] = (struct Eq_195) g_dw402000;
	esp_91[1] = (struct Eq_195) g_dw402008;
	fn004010D8(esp_91[1], esp_91[2]);
}

// 004011EC: Register word32 fn004011EC(Sequence uint64 edx_eax, Register uint32 ecx, Register ui32 ebx, Register out Eq_266 edxOut, Register out ptr32 ebxOut, Register out Eq_268 esiOut)
// Called from:
//      fn00401344
word32 fn004011EC(uint64 edx_eax, uint32 ecx, ui32 ebx, union Eq_266 & edxOut, ptr32 & ebxOut, union Eq_268 & esiOut)
{
	Eq_268 esi_15 = g_t402108.u0;
	edxOut.u0 = (uint32) (edx_eax % ecx);
	ebxOut = ebx + ((uint32) (edx_eax /u ecx) << 0x02);
	esiOut = esi_15;
	return 0x00;
}

// 004011FC: void fn004011FC()
// Called from:
//      fn00401291
void fn004011FC()
{
	Eq_3 esi_32 = g_t402128.u0;
	word32 ebx_39 = Mem31[Mem31[esi_32 + 0x3C:word32] + esi_32 + 0x80:word32] + esi_32;
	do
	{
		word32 eax_48 = LoadLibraryA(Mem42[ebx_39 + 0x0C:word32] + Mem42[0x00402128<p32>:word32]);
		word32 * esi_53 = g_t402128.u0 + ebx_39->dw0000;
		word32 edi_55 = Mem51[ebx_39 + 16:word32] + Mem51[0x00402128<p32>:word32];
		do
		{
			*edi_55 = (word32) GetProcAddress(eax_48, g_t402128.u0 + *esi_53 + 2);
			++edi_55;
			++esi_53;
		} while (*esi_53 != 0x00);
		struct Eq_318 * ebx_79 = ebx_39 - 0x02;
		ebx_39 = (struct Eq_282 *) ((char *) ebx_79 + 22);
	} while (ebx_79->dw0022 != 0x00);
}

// 00401276: void fn00401276(Register word32 ebx)
// Called from:
//      fn00401291
void fn00401276(word32 ebx)
{
	struct Eq_348 * fs;
	struct Eq_349 * ecx_13 = fs->ptr0018;
	struct Eq_353 * ecx_14 = ecx_13->ptr0030;
	Eq_3 ebx_15 = g_t402128.u0;
	ecx_14->t0008.u0 = (struct Eq_779 *) ebx_15;
}

// 00401291: void fn00401291()
// Called from:
//      fn00401276
//      fn0040153D
void fn00401291()
{
	word32 ebx;
	fn004011FC();
	fn00401276(ebx);
}

// 004012A6: void fn004012A6(Stack word32 dwArg04, Stack (ptr32 Eq_304) dwArg08)
// Called from:
//      fn00401588
void fn004012A6(word32 dwArg04, FARPROC * dwArg08)
{
	Eq_294 dwLoc08_32;
	Eq_293 eax_10 = LoadLibraryA("ntdll.dll");
	if (dwArg04 == 0x00)
		dwLoc08_32 = (Eq_294) "ZwGetContextThread";
	else
		dwLoc08_32 = (Eq_294) "ZwSetContextThread";
	*dwArg08 = (FARPROC *) GetProcAddress(eax_10, dwLoc08_32);
}

// 004012FC: void fn004012FC(Stack (ptr32 Eq_3) dwArg04, Stack Eq_49 dwArg08)
// Called from:
//      fn00401486
void fn004012FC(union Eq_3 * dwArg04, Eq_49 dwArg08)
{
	dwArg04->u0 = (struct Eq_779 *) HeapAlloc(HeapCreate(0x01, 0x00, 0x00), 0x08, dwArg08);
}

// 00401320: void fn00401320()
// Called from:
//      fn00401486
void fn00401320()
{
	struct Eq_411 * ebx_10 = g_ptr402104;
	byte dl_21 = 0x00;
	do
	{
		ebx_10->b0000 = 0x01;
		ebx_10->b0001 = dl_21;
		++dl_21;
		++ebx_10;
		Eq_427 edx_31 = SEQ(0x00, 0x01, dl_21);
	} while (dl_21 != 0x00);
	g_t402110.u0 = (int32) edx_31;
}

// 00401344: Register word32 fn00401344()
// Called from:
//      fn00401486
word32 fn00401344()
{
	word32 esi_32;
	uip32 edx_139;
	word32 * ebx_30;
	word32 eax_105 = fn004011EC((uint64) g_dw40210C, 0x20, g_dw402008, out edx_139, out ebx_30, out esi_32);
	esi_39 = esi_32;
	do
	{
		word32 esi_39;
		byte dl_45 = (byte) edx_139;
		--esi_39;
		uint32 edi_47 = __bswap<word32>(*ebx_30) << dl_45;
		if (edi_47 >> 0x1F != 0x00)
			eax_105 += edi_47 >> 0x1F << (byte) esi_39;
		uip32 edx_141 = SEQ(SLICE(edx_139 + 0x01, word24, 8), dl_45 + 0x01);
		if (edx_139 == 0x1F)
		{
			++ebx_30;
			edx_141 = 0x00;
		}
		edx_139 = edx_141;
	} while (esi_39 != 0x00);
	g_dw40210C += esi_32;
	return eax_105;
}

// 004013A0: void fn004013A0(Stack Eq_490 dwArg04)
// Called from:
//      fn00401486
void fn004013A0(Eq_490 dwArg04)
{
	byte * ebx_38 = g_ptr402104 + dwArg04;
	memcpy(&g_b402010, ebx_38, (word32) *ebx_38 + 0x01);
}

// 004013CA: void fn004013CA()
// Called from:
//      fn00401486
void fn004013CA()
{
	++g_b402010;
	(&g_b402010)[(word32) g_b402010] = g_b40211C;
}

// 004013E4: void fn004013E4()
// Called from:
//      fn00401486
void fn004013E4()
{
	Eq_523 ecx_34 = (word32) g_b402010;
	<unknown>* edi_32 = g_ptr402100 + g_dw402114;
	g_dw402114 = (word32) ecx_34 + g_dw402114;
	memcpy(edi_32, &g_b402011, ecx_34);
	Mem42[0x00402118<p32>:word32] = edi_32 + ecx_34;
}

// 0040140E: void fn0040140E()
// Called from:
//      fn00401486
void fn0040140E()
{
	g_b40211C = g_b402011;
}

// 0040141F: void fn0040141F()
// Called from:
//      fn00401442
void fn0040141F()
{
	if (g_t402110.u0 == 0x0200)
	{
		g_t402110.u0 = 0x0100;
		g_t402108.u0 = 0x09;
	}
}

// 00401442: void fn00401442()
// Called from:
//      fn00401486
void fn00401442()
{
	uint32 ecx_23 = (word32) g_b402010;
	word32 ebx_20 = Mem9[0x00402104<p32>:word32] + Mem6[0x00402110<p32>:word32] *u 0xA0;
	*ebx_20 = (byte) ecx_23;
	memcpy(ebx_20 + 1, &g_b402011, ecx_23);
	g_t402110.u0 = (int32) (g_t402110.u0 + 0x01);
	fn0040141F();
}

// 00401486: void fn00401486()
// Called from:
//      Win32CrtStartup
void fn00401486()
{
	fn004012FC(&g_ptr402100, 60000);
	fn004012FC(&g_ptr402104, 0x00C35000);
	fn00401320();
	g_t402108.u0 = 0x09;
	Eq_490 eax_37 = fn00401344();
	fn004013A0(eax_37);
	fn004013E4();
	fn0040140E();
	Eq_490 dwLoc0C_154 = eax_37;
	while (g_dw402004 - g_dw40210C >= g_t402108.u0)
	{
		Eq_490 eax_75 = fn00401344();
		if (eax_75 > g_t402110.u0 - 0x01)
		{
			fn004013A0(dwLoc0C_154);
			fn004013CA();
		}
		else
			fn004013A0(eax_75);
		fn004013E4();
		fn0040140E();
		fn004013A0(dwLoc0C_154);
		fn004013CA();
		fn00401442();
		dwLoc0C_154 = eax_75;
	}
}

// 0040153D: Register word32 fn0040153D()
// Called from:
//      Win32CrtStartup
word32 fn0040153D()
{
	word32 eax_4 = fn0040105A();
	fn00401291();
	return eax_4;
}

// 00401549: void fn00401549(Register (ptr32 Eq_651) ebp)
// Called from:
//      fn004015D6
void fn00401549(struct Eq_651 * ebp)
{
	ebp->tFFFFFFF8 = GetCurrentThread();
	ebp->tFFFFFFFC = CreateThread(null, 0x00, ebp->dw000C + 0x01, 0x00, 0x04, null);
}

// 00401575: void fn00401575(Register (ptr32 Eq_680) ebp)
// Called from:
//      fn004015D6
void fn00401575(struct Eq_680 * ebp)
{
	ResumeThread(ebp->tFFFFFFFC);
	SuspendThread(ebp->tFFFFFFF8);
}

// 00401588: void fn00401588(Register (ptr32 Eq_695) ebp)
// Called from:
//      fn004015D6
void fn00401588(struct Eq_695 * ebp)
{
	ebp->dwFFFFFD2C = 0x00010002;
	GetThreadContext(ebp->tFFFFFFFC, ebp - 0x02D4);
	ebp->dwFFFFFDDC = ebp->dw000C;
	fn004012A6(0x01, &g_ptr402124);
	struct Eq_721 * ecx_36 = g_ptr402124;
	byte al_39 = ecx_36->b0001;
	g_ptr402124 = &g_ptr402124->b0001 + 4;
	g_ptr402124();
}

// 004015D6: void fn004015D6(Register ptr32 ebp)
// Called from:
//      Win32CrtStartup
void fn004015D6(ptr32 ebp)
{
	Eq_734 tLoc04;
	tLoc04.ptr0000 = ebp;
	fn00401549(&tLoc04);
	fn00401588(&tLoc04);
	fn00401575(&tLoc04);
}

// 004015F5: Register Eq_50 Win32CrtStartup()
Eq_50 Win32CrtStartup()
{
	ptr32 fp;
	fn004015D6(fp - 4);
	fn004010FD();
	fn00401486();
	return fn0040153D();
}

word32 g_dw401640 = 0x166C; // 00401640
word32 g_dw401644 = 5756; // 00401644
word32 g_dw401648 = 5776; // 00401648
word32 g_dw40164C = 0x16A2; // 0040164C
word32 g_dw401650 = 0x16B6; // 00401650
word32 g_dw401654 = 0x16C2; // 00401654
word32 g_dw401658 = 0x16D0; // 00401658
word32 g_dw40165C = 5856; // 0040165C
word32 g_dw401660 = 0x16F0; // 00401660
word32 g_dw401664 = 5888; // 00401664
